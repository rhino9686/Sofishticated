
lil_fish_tanks_arduino.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000194  00800100  00004ae0  00004b74  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00004ae0  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          000002c3  00800294  00800294  00004d08  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00004d08  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00004d38  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000a18  00000000  00000000  00004d78  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00014241  00000000  00000000  00005790  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00004091  00000000  00000000  000199d1  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00006c73  00000000  00000000  0001da62  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00001e78  00000000  00000000  000246d8  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00004b59  00000000  00000000  00026550  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    0000b58a  00000000  00000000  0002b0a9  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000970  00000000  00000000  00036633  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 8c 00 	jmp	0x118	; 0x118 <__dtors_end>
       4:	0c 94 43 20 	jmp	0x4086	; 0x4086 <__vector_1>
       8:	0c 94 6a 20 	jmp	0x40d4	; 0x40d4 <__vector_2>
       c:	0c 94 53 19 	jmp	0x32a6	; 0x32a6 <__vector_3>
      10:	0c 94 53 19 	jmp	0x32a6	; 0x32a6 <__vector_3>
      14:	0c 94 53 19 	jmp	0x32a6	; 0x32a6 <__vector_3>
      18:	0c 94 bf 0b 	jmp	0x177e	; 0x177e <__vector_6>
      1c:	0c 94 32 23 	jmp	0x4664	; 0x4664 <__vector_7>
      20:	0c 94 b4 00 	jmp	0x168	; 0x168 <__bad_interrupt>
      24:	0c 94 b4 00 	jmp	0x168	; 0x168 <__bad_interrupt>
      28:	0c 94 b4 00 	jmp	0x168	; 0x168 <__bad_interrupt>
      2c:	0c 94 b4 00 	jmp	0x168	; 0x168 <__bad_interrupt>
      30:	0c 94 b4 00 	jmp	0x168	; 0x168 <__bad_interrupt>
      34:	0c 94 b4 00 	jmp	0x168	; 0x168 <__bad_interrupt>
      38:	0c 94 b4 00 	jmp	0x168	; 0x168 <__bad_interrupt>
      3c:	0c 94 b4 00 	jmp	0x168	; 0x168 <__bad_interrupt>
      40:	0c 94 91 20 	jmp	0x4122	; 0x4122 <__vector_16>
      44:	0c 94 b4 00 	jmp	0x168	; 0x168 <__bad_interrupt>
      48:	0c 94 59 1e 	jmp	0x3cb2	; 0x3cb2 <__vector_18>
      4c:	0c 94 8b 1e 	jmp	0x3d16	; 0x3d16 <__vector_19>
      50:	0c 94 b4 00 	jmp	0x168	; 0x168 <__bad_interrupt>
      54:	0c 94 b4 00 	jmp	0x168	; 0x168 <__bad_interrupt>
      58:	0c 94 b4 00 	jmp	0x168	; 0x168 <__bad_interrupt>
      5c:	0c 94 b4 00 	jmp	0x168	; 0x168 <__bad_interrupt>
      60:	0c 94 b4 00 	jmp	0x168	; 0x168 <__bad_interrupt>
      64:	0c 94 b4 00 	jmp	0x168	; 0x168 <__bad_interrupt>
      68:	5d 16       	cp	r5, r29
      6a:	5d 16       	cp	r5, r29
      6c:	5d 16       	cp	r5, r29
      6e:	9c 16       	cp	r9, r28
      70:	87 16       	cp	r8, r23
      72:	96 16       	cp	r9, r22
      74:	5d 16       	cp	r5, r29
      76:	5d 16       	cp	r5, r29
      78:	9c 16       	cp	r9, r28
      7a:	87 16       	cp	r8, r23

0000007c <__trampolines_end>:
      7c:	0a 46       	sbci	r16, 0x6A	; 106
      7e:	6f 75       	andi	r22, 0x5F	; 95
      80:	6e 64       	ori	r22, 0x4E	; 78
      82:	20 4d       	sbci	r18, 0xD0	; 208
      84:	61 74       	andi	r22, 0x41	; 65
      86:	63 68       	ori	r22, 0x83	; 131
      88:	69 6e       	ori	r22, 0xE9	; 233
      8a:	67 20       	and	r6, r7
      8c:	43 6f       	ori	r20, 0xF3	; 243
      8e:	6c 6f       	ori	r22, 0xFC	; 252
      90:	72 00       	.word	0x0072	; ????

00000092 <_ZL15dscrc2x16_table>:
      92:	00 5e bc e2 61 3f dd 83 c2 9c 7e 20 a3 fd 1f 41     .^..a?....~ ...A
      a2:	00 9d 23 be 46 db 65 f8 8c 11 af 32 ca 57 e9 74     ..#.F.e....2.W.t

000000b2 <digital_pin_to_timer_PGM>:
      b2:	00 00 00 08 00 02 01 00 00 03 04 07 00 00 00 00     ................
      c2:	00 00 00 00                                         ....

000000c6 <digital_pin_to_bit_mask_PGM>:
      c6:	01 02 04 08 10 20 40 80 01 02 04 08 10 20 01 02     ..... @...... ..
      d6:	04 08 10 20                                         ... 

000000da <digital_pin_to_port_PGM>:
      da:	04 04 04 04 04 04 04 04 02 02 02 02 02 02 03 03     ................
      ea:	03 03 03 03                                         ....

000000ee <port_to_input_PGM>:
      ee:	00 00 00 00 23 00 26 00 29 00                       ....#.&.).

000000f8 <port_to_output_PGM>:
      f8:	00 00 00 00 25 00 28 00 2b 00                       ....%.(.+.

00000102 <port_to_mode_PGM>:
     102:	00 00 00 00 24 00 27 00 2a 00                       ....$.'.*.

0000010c <__ctors_start>:
     10c:	39 04       	cpc	r3, r9
     10e:	d1 04       	cpc	r13, r1
     110:	9b 06       	cpc	r9, r27
     112:	bb 1e       	adc	r11, r27

00000114 <__ctors_end>:
     114:	40 04       	cpc	r4, r0
     116:	a2 06       	cpc	r10, r18

00000118 <__dtors_end>:
     118:	11 24       	eor	r1, r1
     11a:	1f be       	out	0x3f, r1	; 63
     11c:	cf ef       	ldi	r28, 0xFF	; 255
     11e:	d8 e0       	ldi	r29, 0x08	; 8
     120:	de bf       	out	0x3e, r29	; 62
     122:	cd bf       	out	0x3d, r28	; 61

00000124 <__do_copy_data>:
     124:	12 e0       	ldi	r17, 0x02	; 2
     126:	a0 e0       	ldi	r26, 0x00	; 0
     128:	b1 e0       	ldi	r27, 0x01	; 1
     12a:	e0 ee       	ldi	r30, 0xE0	; 224
     12c:	fa e4       	ldi	r31, 0x4A	; 74
     12e:	02 c0       	rjmp	.+4      	; 0x134 <__do_copy_data+0x10>
     130:	05 90       	lpm	r0, Z+
     132:	0d 92       	st	X+, r0
     134:	a4 39       	cpi	r26, 0x94	; 148
     136:	b1 07       	cpc	r27, r17
     138:	d9 f7       	brne	.-10     	; 0x130 <__do_copy_data+0xc>

0000013a <__do_clear_bss>:
     13a:	25 e0       	ldi	r18, 0x05	; 5
     13c:	a4 e9       	ldi	r26, 0x94	; 148
     13e:	b2 e0       	ldi	r27, 0x02	; 2
     140:	01 c0       	rjmp	.+2      	; 0x144 <.do_clear_bss_start>

00000142 <.do_clear_bss_loop>:
     142:	1d 92       	st	X+, r1

00000144 <.do_clear_bss_start>:
     144:	a7 35       	cpi	r26, 0x57	; 87
     146:	b2 07       	cpc	r27, r18
     148:	e1 f7       	brne	.-8      	; 0x142 <.do_clear_bss_loop>

0000014a <__do_global_ctors>:
     14a:	10 e0       	ldi	r17, 0x00	; 0
     14c:	ca e8       	ldi	r28, 0x8A	; 138
     14e:	d0 e0       	ldi	r29, 0x00	; 0
     150:	04 c0       	rjmp	.+8      	; 0x15a <__do_global_ctors+0x10>
     152:	21 97       	sbiw	r28, 0x01	; 1
     154:	fe 01       	movw	r30, r28
     156:	0e 94 fe 23 	call	0x47fc	; 0x47fc <__tablejump2__>
     15a:	c6 38       	cpi	r28, 0x86	; 134
     15c:	d1 07       	cpc	r29, r17
     15e:	c9 f7       	brne	.-14     	; 0x152 <__do_global_ctors+0x8>
     160:	0e 94 e8 1e 	call	0x3dd0	; 0x3dd0 <main>
     164:	0c 94 63 25 	jmp	0x4ac6	; 0x4ac6 <__do_global_dtors>

00000168 <__bad_interrupt>:
     168:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

0000016c <_Z7setupCSv>:

MD_TCS230  CS(S2, S3, OE);

// add possible color strip values to specific arrays
void setupCS()
{
     16c:	0f 93       	push	r16
     16e:	1f 93       	push	r17
     170:	cf 93       	push	r28
     172:	df 93       	push	r29
     174:	cd b7       	in	r28, 0x3d	; 61
     176:	de b7       	in	r29, 0x3e	; 62
     178:	2a 97       	sbiw	r28, 0x0a	; 10
     17a:	0f b6       	in	r0, 0x3f	; 63
     17c:	f8 94       	cli
     17e:	de bf       	out	0x3e, r29	; 62
     180:	0f be       	out	0x3f, r0	; 63
     182:	cd bf       	out	0x3d, r28	; 61
	CS.begin();
     184:	84 e9       	ldi	r24, 0x94	; 148
     186:	92 e0       	ldi	r25, 0x02	; 2
     188:	0e 94 62 17 	call	0x2ec4	; 0x2ec4 <_ZN9MD_TCS2305beginEv>
	
	int index = 0;
	Color c;
	c.ppm = 0.0;
	c.p = {64, 62, 90};
     18c:	86 e0       	ldi	r24, 0x06	; 6
     18e:	e2 e4       	ldi	r30, 0x42	; 66
     190:	f1 e0       	ldi	r31, 0x01	; 1
     192:	de 01       	movw	r26, r28
     194:	15 96       	adiw	r26, 0x05	; 5
     196:	01 90       	ld	r0, Z+
     198:	0d 92       	st	X+, r0
     19a:	8a 95       	dec	r24
     19c:	e1 f7       	brne	.-8      	; 0x196 <_Z7setupCSv+0x2a>
	Ammonia[index] = c;
     19e:	19 82       	std	Y+1, r1	; 0x01
     1a0:	1a 82       	std	Y+2, r1	; 0x02
     1a2:	1b 82       	std	Y+3, r1	; 0x03
     1a4:	1c 82       	std	Y+4, r1	; 0x04
     1a6:	8a e0       	ldi	r24, 0x0A	; 10
     1a8:	fe 01       	movw	r30, r28
     1aa:	31 96       	adiw	r30, 0x01	; 1
     1ac:	a0 e6       	ldi	r26, 0x60	; 96
     1ae:	b3 e0       	ldi	r27, 0x03	; 3
     1b0:	01 90       	ld	r0, Z+
     1b2:	0d 92       	st	X+, r0
     1b4:	8a 95       	dec	r24
     1b6:	e1 f7       	brne	.-8      	; 0x1b0 <_Z7setupCSv+0x44>

	c.ppm = 0.0;
	c.p = {74, 77, 120};
     1b8:	86 e0       	ldi	r24, 0x06	; 6
     1ba:	e8 e4       	ldi	r30, 0x48	; 72
     1bc:	f1 e0       	ldi	r31, 0x01	; 1
     1be:	de 01       	movw	r26, r28
     1c0:	15 96       	adiw	r26, 0x05	; 5
     1c2:	01 90       	ld	r0, Z+
     1c4:	0d 92       	st	X+, r0
     1c6:	8a 95       	dec	r24
     1c8:	e1 f7       	brne	.-8      	; 0x1c2 <_Z7setupCSv+0x56>
	Nitrite[index] = c;
     1ca:	8a e0       	ldi	r24, 0x0A	; 10
     1cc:	fe 01       	movw	r30, r28
     1ce:	31 96       	adiw	r30, 0x01	; 1
     1d0:	aa e1       	ldi	r26, 0x1A	; 26
     1d2:	b3 e0       	ldi	r27, 0x03	; 3
     1d4:	01 90       	ld	r0, Z+
     1d6:	0d 92       	st	X+, r0
     1d8:	8a 95       	dec	r24
     1da:	e1 f7       	brne	.-8      	; 0x1d4 <_Z7setupCSv+0x68>

	c.ppm = 0.0;
	c.p = {71, 74, 123};
     1dc:	86 e0       	ldi	r24, 0x06	; 6
     1de:	ee e4       	ldi	r30, 0x4E	; 78
     1e0:	f1 e0       	ldi	r31, 0x01	; 1
     1e2:	de 01       	movw	r26, r28
     1e4:	15 96       	adiw	r26, 0x05	; 5
     1e6:	01 90       	ld	r0, Z+
     1e8:	0d 92       	st	X+, r0
     1ea:	8a 95       	dec	r24
     1ec:	e1 f7       	brne	.-8      	; 0x1e6 <_Z7setupCSv+0x7a>
	Nitrate[index] = c;
     1ee:	8a e0       	ldi	r24, 0x0A	; 10
     1f0:	fe 01       	movw	r30, r28
     1f2:	31 96       	adiw	r30, 0x01	; 1
     1f4:	a4 ed       	ldi	r26, 0xD4	; 212
     1f6:	b2 e0       	ldi	r27, 0x02	; 2
     1f8:	01 90       	ld	r0, Z+
     1fa:	0d 92       	st	X+, r0
     1fc:	8a 95       	dec	r24
     1fe:	e1 f7       	brne	.-8      	; 0x1f8 <_Z7setupCSv+0x8c>

	++index;

	c.ppm = 0.5;
	c.p = {61, 62, 91};
     200:	86 e0       	ldi	r24, 0x06	; 6
     202:	e4 e5       	ldi	r30, 0x54	; 84
     204:	f1 e0       	ldi	r31, 0x01	; 1
     206:	de 01       	movw	r26, r28
     208:	15 96       	adiw	r26, 0x05	; 5
     20a:	01 90       	ld	r0, Z+
     20c:	0d 92       	st	X+, r0
     20e:	8a 95       	dec	r24
     210:	e1 f7       	brne	.-8      	; 0x20a <_Z7setupCSv+0x9e>
	Ammonia[index] = c;
     212:	40 e0       	ldi	r20, 0x00	; 0
     214:	50 e0       	ldi	r21, 0x00	; 0
     216:	60 e0       	ldi	r22, 0x00	; 0
     218:	7f e3       	ldi	r23, 0x3F	; 63
     21a:	49 83       	std	Y+1, r20	; 0x01
     21c:	5a 83       	std	Y+2, r21	; 0x02
     21e:	6b 83       	std	Y+3, r22	; 0x03
     220:	7c 83       	std	Y+4, r23	; 0x04
     222:	8a e0       	ldi	r24, 0x0A	; 10
     224:	fe 01       	movw	r30, r28
     226:	31 96       	adiw	r30, 0x01	; 1
     228:	aa e6       	ldi	r26, 0x6A	; 106
     22a:	b3 e0       	ldi	r27, 0x03	; 3
     22c:	01 90       	ld	r0, Z+
     22e:	0d 92       	st	X+, r0
     230:	8a 95       	dec	r24
     232:	e1 f7       	brne	.-8      	; 0x22c <_Z7setupCSv+0xc0>

	c.ppm = 0.15;
	c.p = {71, 74, 123};
     234:	86 e0       	ldi	r24, 0x06	; 6
     236:	ee e4       	ldi	r30, 0x4E	; 78
     238:	f1 e0       	ldi	r31, 0x01	; 1
     23a:	de 01       	movw	r26, r28
     23c:	15 96       	adiw	r26, 0x05	; 5
     23e:	01 90       	ld	r0, Z+
     240:	0d 92       	st	X+, r0
     242:	8a 95       	dec	r24
     244:	e1 f7       	brne	.-8      	; 0x23e <_Z7setupCSv+0xd2>
	Nitrite[index] = c;
     246:	8a e9       	ldi	r24, 0x9A	; 154
     248:	99 e9       	ldi	r25, 0x99	; 153
     24a:	a9 e1       	ldi	r26, 0x19	; 25
     24c:	be e3       	ldi	r27, 0x3E	; 62
     24e:	89 83       	std	Y+1, r24	; 0x01
     250:	9a 83       	std	Y+2, r25	; 0x02
     252:	ab 83       	std	Y+3, r26	; 0x03
     254:	bc 83       	std	Y+4, r27	; 0x04
     256:	8a e0       	ldi	r24, 0x0A	; 10
     258:	fe 01       	movw	r30, r28
     25a:	31 96       	adiw	r30, 0x01	; 1
     25c:	a4 e2       	ldi	r26, 0x24	; 36
     25e:	b3 e0       	ldi	r27, 0x03	; 3
     260:	01 90       	ld	r0, Z+
     262:	0d 92       	st	X+, r0
     264:	8a 95       	dec	r24
     266:	e1 f7       	brne	.-8      	; 0x260 <_Z7setupCSv+0xf4>

	c.ppm = 0.5;
	c.p = {60, 60, 101};
     268:	86 e0       	ldi	r24, 0x06	; 6
     26a:	ea e5       	ldi	r30, 0x5A	; 90
     26c:	f1 e0       	ldi	r31, 0x01	; 1
     26e:	de 01       	movw	r26, r28
     270:	15 96       	adiw	r26, 0x05	; 5
     272:	01 90       	ld	r0, Z+
     274:	0d 92       	st	X+, r0
     276:	8a 95       	dec	r24
     278:	e1 f7       	brne	.-8      	; 0x272 <_Z7setupCSv+0x106>
	Nitrate[index] = c;
     27a:	49 83       	std	Y+1, r20	; 0x01
     27c:	5a 83       	std	Y+2, r21	; 0x02
     27e:	6b 83       	std	Y+3, r22	; 0x03
     280:	7c 83       	std	Y+4, r23	; 0x04
     282:	8a e0       	ldi	r24, 0x0A	; 10
     284:	fe 01       	movw	r30, r28
     286:	31 96       	adiw	r30, 0x01	; 1
     288:	ae ed       	ldi	r26, 0xDE	; 222
     28a:	b2 e0       	ldi	r27, 0x02	; 2
     28c:	01 90       	ld	r0, Z+
     28e:	0d 92       	st	X+, r0
     290:	8a 95       	dec	r24
     292:	e1 f7       	brne	.-8      	; 0x28c <_Z7setupCSv+0x120>

	++index;

	c.ppm = 1.0;
	c.p = {50, 63, 90};
     294:	86 e0       	ldi	r24, 0x06	; 6
     296:	e0 e6       	ldi	r30, 0x60	; 96
     298:	f1 e0       	ldi	r31, 0x01	; 1
     29a:	de 01       	movw	r26, r28
     29c:	15 96       	adiw	r26, 0x05	; 5
     29e:	01 90       	ld	r0, Z+
     2a0:	0d 92       	st	X+, r0
     2a2:	8a 95       	dec	r24
     2a4:	e1 f7       	brne	.-8      	; 0x29e <_Z7setupCSv+0x132>
	Ammonia[index] = c;
     2a6:	40 e0       	ldi	r20, 0x00	; 0
     2a8:	50 e0       	ldi	r21, 0x00	; 0
     2aa:	60 e8       	ldi	r22, 0x80	; 128
     2ac:	7f e3       	ldi	r23, 0x3F	; 63
     2ae:	49 83       	std	Y+1, r20	; 0x01
     2b0:	5a 83       	std	Y+2, r21	; 0x02
     2b2:	6b 83       	std	Y+3, r22	; 0x03
     2b4:	7c 83       	std	Y+4, r23	; 0x04
     2b6:	8a e0       	ldi	r24, 0x0A	; 10
     2b8:	fe 01       	movw	r30, r28
     2ba:	31 96       	adiw	r30, 0x01	; 1
     2bc:	a4 e7       	ldi	r26, 0x74	; 116
     2be:	b3 e0       	ldi	r27, 0x03	; 3
     2c0:	01 90       	ld	r0, Z+
     2c2:	0d 92       	st	X+, r0
     2c4:	8a 95       	dec	r24
     2c6:	e1 f7       	brne	.-8      	; 0x2c0 <_Z7setupCSv+0x154>

	c.ppm = 0.3;
	c.p = {64, 67, 114};
     2c8:	86 e0       	ldi	r24, 0x06	; 6
     2ca:	e6 e6       	ldi	r30, 0x66	; 102
     2cc:	f1 e0       	ldi	r31, 0x01	; 1
     2ce:	de 01       	movw	r26, r28
     2d0:	15 96       	adiw	r26, 0x05	; 5
     2d2:	01 90       	ld	r0, Z+
     2d4:	0d 92       	st	X+, r0
     2d6:	8a 95       	dec	r24
     2d8:	e1 f7       	brne	.-8      	; 0x2d2 <_Z7setupCSv+0x166>
	Nitrite[index] = c;
     2da:	8a e9       	ldi	r24, 0x9A	; 154
     2dc:	99 e9       	ldi	r25, 0x99	; 153
     2de:	a9 e9       	ldi	r26, 0x99	; 153
     2e0:	be e3       	ldi	r27, 0x3E	; 62
     2e2:	89 83       	std	Y+1, r24	; 0x01
     2e4:	9a 83       	std	Y+2, r25	; 0x02
     2e6:	ab 83       	std	Y+3, r26	; 0x03
     2e8:	bc 83       	std	Y+4, r27	; 0x04
     2ea:	8a e0       	ldi	r24, 0x0A	; 10
     2ec:	fe 01       	movw	r30, r28
     2ee:	31 96       	adiw	r30, 0x01	; 1
     2f0:	ae e2       	ldi	r26, 0x2E	; 46
     2f2:	b3 e0       	ldi	r27, 0x03	; 3
     2f4:	01 90       	ld	r0, Z+
     2f6:	0d 92       	st	X+, r0
     2f8:	8a 95       	dec	r24
     2fa:	e1 f7       	brne	.-8      	; 0x2f4 <_Z7setupCSv+0x188>

	c.ppm = 2.0;
	c.p = {68, 65, 114};
     2fc:	86 e0       	ldi	r24, 0x06	; 6
     2fe:	ec e6       	ldi	r30, 0x6C	; 108
     300:	f1 e0       	ldi	r31, 0x01	; 1
     302:	de 01       	movw	r26, r28
     304:	15 96       	adiw	r26, 0x05	; 5
     306:	01 90       	ld	r0, Z+
     308:	0d 92       	st	X+, r0
     30a:	8a 95       	dec	r24
     30c:	e1 f7       	brne	.-8      	; 0x306 <_Z7setupCSv+0x19a>
	Nitrate[index] = c;
     30e:	80 e0       	ldi	r24, 0x00	; 0
     310:	90 e0       	ldi	r25, 0x00	; 0
     312:	a0 e0       	ldi	r26, 0x00	; 0
     314:	b0 e4       	ldi	r27, 0x40	; 64
     316:	89 83       	std	Y+1, r24	; 0x01
     318:	9a 83       	std	Y+2, r25	; 0x02
     31a:	ab 83       	std	Y+3, r26	; 0x03
     31c:	bc 83       	std	Y+4, r27	; 0x04
     31e:	8a e0       	ldi	r24, 0x0A	; 10
     320:	fe 01       	movw	r30, r28
     322:	31 96       	adiw	r30, 0x01	; 1
     324:	a8 ee       	ldi	r26, 0xE8	; 232
     326:	b2 e0       	ldi	r27, 0x02	; 2
     328:	01 90       	ld	r0, Z+
     32a:	0d 92       	st	X+, r0
     32c:	8a 95       	dec	r24
     32e:	e1 f7       	brne	.-8      	; 0x328 <_Z7setupCSv+0x1bc>

	++index;

	c.ppm = 3.0;
	c.p = {52, 60, 90};
     330:	86 e0       	ldi	r24, 0x06	; 6
     332:	e2 e7       	ldi	r30, 0x72	; 114
     334:	f1 e0       	ldi	r31, 0x01	; 1
     336:	de 01       	movw	r26, r28
     338:	15 96       	adiw	r26, 0x05	; 5
     33a:	01 90       	ld	r0, Z+
     33c:	0d 92       	st	X+, r0
     33e:	8a 95       	dec	r24
     340:	e1 f7       	brne	.-8      	; 0x33a <_Z7setupCSv+0x1ce>
	Ammonia[index] = c;
     342:	00 e0       	ldi	r16, 0x00	; 0
     344:	10 e0       	ldi	r17, 0x00	; 0
     346:	20 e4       	ldi	r18, 0x40	; 64
     348:	30 e4       	ldi	r19, 0x40	; 64
     34a:	09 83       	std	Y+1, r16	; 0x01
     34c:	1a 83       	std	Y+2, r17	; 0x02
     34e:	2b 83       	std	Y+3, r18	; 0x03
     350:	3c 83       	std	Y+4, r19	; 0x04
     352:	8a e0       	ldi	r24, 0x0A	; 10
     354:	fe 01       	movw	r30, r28
     356:	31 96       	adiw	r30, 0x01	; 1
     358:	ae e7       	ldi	r26, 0x7E	; 126
     35a:	b3 e0       	ldi	r27, 0x03	; 3
     35c:	01 90       	ld	r0, Z+
     35e:	0d 92       	st	X+, r0
     360:	8a 95       	dec	r24
     362:	e1 f7       	brne	.-8      	; 0x35c <_Z7setupCSv+0x1f0>

	c.ppm = 1.0;
	c.p = {52, 52, 94};
     364:	86 e0       	ldi	r24, 0x06	; 6
     366:	e8 e7       	ldi	r30, 0x78	; 120
     368:	f1 e0       	ldi	r31, 0x01	; 1
     36a:	de 01       	movw	r26, r28
     36c:	15 96       	adiw	r26, 0x05	; 5
     36e:	01 90       	ld	r0, Z+
     370:	0d 92       	st	X+, r0
     372:	8a 95       	dec	r24
     374:	e1 f7       	brne	.-8      	; 0x36e <_Z7setupCSv+0x202>
	Nitrite[index] = c;
     376:	49 83       	std	Y+1, r20	; 0x01
     378:	5a 83       	std	Y+2, r21	; 0x02
     37a:	6b 83       	std	Y+3, r22	; 0x03
     37c:	7c 83       	std	Y+4, r23	; 0x04
     37e:	8a e0       	ldi	r24, 0x0A	; 10
     380:	fe 01       	movw	r30, r28
     382:	31 96       	adiw	r30, 0x01	; 1
     384:	a8 e3       	ldi	r26, 0x38	; 56
     386:	b3 e0       	ldi	r27, 0x03	; 3
     388:	01 90       	ld	r0, Z+
     38a:	0d 92       	st	X+, r0
     38c:	8a 95       	dec	r24
     38e:	e1 f7       	brne	.-8      	; 0x388 <_Z7setupCSv+0x21c>

	c.ppm = 5.0;
	c.p = {58, 53, 96};
     390:	86 e0       	ldi	r24, 0x06	; 6
     392:	ee e7       	ldi	r30, 0x7E	; 126
     394:	f1 e0       	ldi	r31, 0x01	; 1
     396:	de 01       	movw	r26, r28
     398:	15 96       	adiw	r26, 0x05	; 5
     39a:	01 90       	ld	r0, Z+
     39c:	0d 92       	st	X+, r0
     39e:	8a 95       	dec	r24
     3a0:	e1 f7       	brne	.-8      	; 0x39a <_Z7setupCSv+0x22e>
	Nitrate[index] = c;
     3a2:	80 e0       	ldi	r24, 0x00	; 0
     3a4:	90 e0       	ldi	r25, 0x00	; 0
     3a6:	a0 ea       	ldi	r26, 0xA0	; 160
     3a8:	b0 e4       	ldi	r27, 0x40	; 64
     3aa:	89 83       	std	Y+1, r24	; 0x01
     3ac:	9a 83       	std	Y+2, r25	; 0x02
     3ae:	ab 83       	std	Y+3, r26	; 0x03
     3b0:	bc 83       	std	Y+4, r27	; 0x04
     3b2:	8a e0       	ldi	r24, 0x0A	; 10
     3b4:	fe 01       	movw	r30, r28
     3b6:	31 96       	adiw	r30, 0x01	; 1
     3b8:	a2 ef       	ldi	r26, 0xF2	; 242
     3ba:	b2 e0       	ldi	r27, 0x02	; 2
     3bc:	01 90       	ld	r0, Z+
     3be:	0d 92       	st	X+, r0
     3c0:	8a 95       	dec	r24
     3c2:	e1 f7       	brne	.-8      	; 0x3bc <_Z7setupCSv+0x250>

	++index;

	c.ppm = 6.0;
	c.p = {48, 54, 86};
     3c4:	86 e0       	ldi	r24, 0x06	; 6
     3c6:	e4 e8       	ldi	r30, 0x84	; 132
     3c8:	f1 e0       	ldi	r31, 0x01	; 1
     3ca:	de 01       	movw	r26, r28
     3cc:	15 96       	adiw	r26, 0x05	; 5
     3ce:	01 90       	ld	r0, Z+
     3d0:	0d 92       	st	X+, r0
     3d2:	8a 95       	dec	r24
     3d4:	e1 f7       	brne	.-8      	; 0x3ce <_Z7setupCSv+0x262>
	Ammonia[index] = c;
     3d6:	80 e0       	ldi	r24, 0x00	; 0
     3d8:	90 e0       	ldi	r25, 0x00	; 0
     3da:	a0 ec       	ldi	r26, 0xC0	; 192
     3dc:	b0 e4       	ldi	r27, 0x40	; 64
     3de:	89 83       	std	Y+1, r24	; 0x01
     3e0:	9a 83       	std	Y+2, r25	; 0x02
     3e2:	ab 83       	std	Y+3, r26	; 0x03
     3e4:	bc 83       	std	Y+4, r27	; 0x04
     3e6:	8a e0       	ldi	r24, 0x0A	; 10
     3e8:	fe 01       	movw	r30, r28
     3ea:	31 96       	adiw	r30, 0x01	; 1
     3ec:	a8 e8       	ldi	r26, 0x88	; 136
     3ee:	b3 e0       	ldi	r27, 0x03	; 3
     3f0:	01 90       	ld	r0, Z+
     3f2:	0d 92       	st	X+, r0
     3f4:	8a 95       	dec	r24
     3f6:	e1 f7       	brne	.-8      	; 0x3f0 <_Z7setupCSv+0x284>

	c.ppm = 1.5;
	c.p = {49, 48, 88};
     3f8:	86 e0       	ldi	r24, 0x06	; 6
     3fa:	ea e8       	ldi	r30, 0x8A	; 138
     3fc:	f1 e0       	ldi	r31, 0x01	; 1
     3fe:	de 01       	movw	r26, r28
     400:	15 96       	adiw	r26, 0x05	; 5
     402:	01 90       	ld	r0, Z+
     404:	0d 92       	st	X+, r0
     406:	8a 95       	dec	r24
     408:	e1 f7       	brne	.-8      	; 0x402 <__LOCK_REGION_LENGTH__+0x2>
	Nitrite[index] = c;
     40a:	80 e0       	ldi	r24, 0x00	; 0
     40c:	90 e0       	ldi	r25, 0x00	; 0
     40e:	a0 ec       	ldi	r26, 0xC0	; 192
     410:	bf e3       	ldi	r27, 0x3F	; 63
     412:	89 83       	std	Y+1, r24	; 0x01
     414:	9a 83       	std	Y+2, r25	; 0x02
     416:	ab 83       	std	Y+3, r26	; 0x03
     418:	bc 83       	std	Y+4, r27	; 0x04
     41a:	8a e0       	ldi	r24, 0x0A	; 10
     41c:	fe 01       	movw	r30, r28
     41e:	31 96       	adiw	r30, 0x01	; 1
     420:	a2 e4       	ldi	r26, 0x42	; 66
     422:	b3 e0       	ldi	r27, 0x03	; 3
     424:	01 90       	ld	r0, Z+
     426:	0d 92       	st	X+, r0
     428:	8a 95       	dec	r24
     42a:	e1 f7       	brne	.-8      	; 0x424 <__LOCK_REGION_LENGTH__+0x24>

	c.ppm = 10.0;
	c.p = {49, 48, 88};
     42c:	86 e0       	ldi	r24, 0x06	; 6
     42e:	ea e8       	ldi	r30, 0x8A	; 138
     430:	f1 e0       	ldi	r31, 0x01	; 1
     432:	de 01       	movw	r26, r28
     434:	15 96       	adiw	r26, 0x05	; 5
     436:	01 90       	ld	r0, Z+
     438:	0d 92       	st	X+, r0
     43a:	8a 95       	dec	r24
     43c:	e1 f7       	brne	.-8      	; 0x436 <__LOCK_REGION_LENGTH__+0x36>
	Nitrate[index] = c;
     43e:	40 e0       	ldi	r20, 0x00	; 0
     440:	50 e0       	ldi	r21, 0x00	; 0
     442:	60 e2       	ldi	r22, 0x20	; 32
     444:	71 e4       	ldi	r23, 0x41	; 65
     446:	49 83       	std	Y+1, r20	; 0x01
     448:	5a 83       	std	Y+2, r21	; 0x02
     44a:	6b 83       	std	Y+3, r22	; 0x03
     44c:	7c 83       	std	Y+4, r23	; 0x04
     44e:	8a e0       	ldi	r24, 0x0A	; 10
     450:	fe 01       	movw	r30, r28
     452:	31 96       	adiw	r30, 0x01	; 1
     454:	ac ef       	ldi	r26, 0xFC	; 252
     456:	b2 e0       	ldi	r27, 0x02	; 2
     458:	01 90       	ld	r0, Z+
     45a:	0d 92       	st	X+, r0
     45c:	8a 95       	dec	r24
     45e:	e1 f7       	brne	.-8      	; 0x458 <__LOCK_REGION_LENGTH__+0x58>

	++index;

	c.ppm = 3.0;
	c.p = {54, 46, 88};
     460:	86 e0       	ldi	r24, 0x06	; 6
     462:	e0 e9       	ldi	r30, 0x90	; 144
     464:	f1 e0       	ldi	r31, 0x01	; 1
     466:	de 01       	movw	r26, r28
     468:	15 96       	adiw	r26, 0x05	; 5
     46a:	01 90       	ld	r0, Z+
     46c:	0d 92       	st	X+, r0
     46e:	8a 95       	dec	r24
     470:	e1 f7       	brne	.-8      	; 0x46a <__LOCK_REGION_LENGTH__+0x6a>
	Nitrite[index] = c;
     472:	09 83       	std	Y+1, r16	; 0x01
     474:	1a 83       	std	Y+2, r17	; 0x02
     476:	2b 83       	std	Y+3, r18	; 0x03
     478:	3c 83       	std	Y+4, r19	; 0x04
     47a:	8a e0       	ldi	r24, 0x0A	; 10
     47c:	fe 01       	movw	r30, r28
     47e:	31 96       	adiw	r30, 0x01	; 1
     480:	ac e4       	ldi	r26, 0x4C	; 76
     482:	b3 e0       	ldi	r27, 0x03	; 3
     484:	01 90       	ld	r0, Z+
     486:	0d 92       	st	X+, r0
     488:	8a 95       	dec	r24
     48a:	e1 f7       	brne	.-8      	; 0x484 <__LOCK_REGION_LENGTH__+0x84>

	c.ppm = 20.0;
	c.p = {50, 44, 86};
     48c:	86 e0       	ldi	r24, 0x06	; 6
     48e:	e6 e9       	ldi	r30, 0x96	; 150
     490:	f1 e0       	ldi	r31, 0x01	; 1
     492:	de 01       	movw	r26, r28
     494:	15 96       	adiw	r26, 0x05	; 5
     496:	01 90       	ld	r0, Z+
     498:	0d 92       	st	X+, r0
     49a:	8a 95       	dec	r24
     49c:	e1 f7       	brne	.-8      	; 0x496 <__LOCK_REGION_LENGTH__+0x96>
	Nitrate[index] = c;
     49e:	80 e0       	ldi	r24, 0x00	; 0
     4a0:	90 e0       	ldi	r25, 0x00	; 0
     4a2:	a0 ea       	ldi	r26, 0xA0	; 160
     4a4:	b1 e4       	ldi	r27, 0x41	; 65
     4a6:	89 83       	std	Y+1, r24	; 0x01
     4a8:	9a 83       	std	Y+2, r25	; 0x02
     4aa:	ab 83       	std	Y+3, r26	; 0x03
     4ac:	bc 83       	std	Y+4, r27	; 0x04
     4ae:	8a e0       	ldi	r24, 0x0A	; 10
     4b0:	fe 01       	movw	r30, r28
     4b2:	31 96       	adiw	r30, 0x01	; 1
     4b4:	a6 e0       	ldi	r26, 0x06	; 6
     4b6:	b3 e0       	ldi	r27, 0x03	; 3
     4b8:	01 90       	ld	r0, Z+
     4ba:	0d 92       	st	X+, r0
     4bc:	8a 95       	dec	r24
     4be:	e1 f7       	brne	.-8      	; 0x4b8 <__LOCK_REGION_LENGTH__+0xb8>

	++index;

	c.ppm = 10.0;
	c.p = {52, 42, 82};
     4c0:	86 e0       	ldi	r24, 0x06	; 6
     4c2:	ec e9       	ldi	r30, 0x9C	; 156
     4c4:	f1 e0       	ldi	r31, 0x01	; 1
     4c6:	de 01       	movw	r26, r28
     4c8:	15 96       	adiw	r26, 0x05	; 5
     4ca:	01 90       	ld	r0, Z+
     4cc:	0d 92       	st	X+, r0
     4ce:	8a 95       	dec	r24
     4d0:	e1 f7       	brne	.-8      	; 0x4ca <__LOCK_REGION_LENGTH__+0xca>
	Nitrite[index] = c;
     4d2:	49 83       	std	Y+1, r20	; 0x01
     4d4:	5a 83       	std	Y+2, r21	; 0x02
     4d6:	6b 83       	std	Y+3, r22	; 0x03
     4d8:	7c 83       	std	Y+4, r23	; 0x04
     4da:	8a e0       	ldi	r24, 0x0A	; 10
     4dc:	fe 01       	movw	r30, r28
     4de:	31 96       	adiw	r30, 0x01	; 1
     4e0:	a6 e5       	ldi	r26, 0x56	; 86
     4e2:	b3 e0       	ldi	r27, 0x03	; 3
     4e4:	01 90       	ld	r0, Z+
     4e6:	0d 92       	st	X+, r0
     4e8:	8a 95       	dec	r24
     4ea:	e1 f7       	brne	.-8      	; 0x4e4 <__LOCK_REGION_LENGTH__+0xe4>

	c.ppm = 50.0;
	c.p = {47, 43, 82};
     4ec:	86 e0       	ldi	r24, 0x06	; 6
     4ee:	e2 ea       	ldi	r30, 0xA2	; 162
     4f0:	f1 e0       	ldi	r31, 0x01	; 1
     4f2:	de 01       	movw	r26, r28
     4f4:	15 96       	adiw	r26, 0x05	; 5
     4f6:	01 90       	ld	r0, Z+
     4f8:	0d 92       	st	X+, r0
     4fa:	8a 95       	dec	r24
     4fc:	e1 f7       	brne	.-8      	; 0x4f6 <__LOCK_REGION_LENGTH__+0xf6>
	Nitrate[index] = c;
     4fe:	80 e0       	ldi	r24, 0x00	; 0
     500:	90 e0       	ldi	r25, 0x00	; 0
     502:	a8 e4       	ldi	r26, 0x48	; 72
     504:	b2 e4       	ldi	r27, 0x42	; 66
     506:	89 83       	std	Y+1, r24	; 0x01
     508:	9a 83       	std	Y+2, r25	; 0x02
     50a:	ab 83       	std	Y+3, r26	; 0x03
     50c:	bc 83       	std	Y+4, r27	; 0x04
     50e:	8a e0       	ldi	r24, 0x0A	; 10
     510:	fe 01       	movw	r30, r28
     512:	31 96       	adiw	r30, 0x01	; 1
     514:	a0 e1       	ldi	r26, 0x10	; 16
     516:	b3 e0       	ldi	r27, 0x03	; 3
     518:	01 90       	ld	r0, Z+
     51a:	0d 92       	st	X+, r0
     51c:	8a 95       	dec	r24
     51e:	e1 f7       	brne	.-8      	; 0x518 <__LOCK_REGION_LENGTH__+0x118>
}
     520:	2a 96       	adiw	r28, 0x0a	; 10
     522:	0f b6       	in	r0, 0x3f	; 63
     524:	f8 94       	cli
     526:	de bf       	out	0x3e, r29	; 62
     528:	0f be       	out	0x3f, r0	; 63
     52a:	cd bf       	out	0x3d, r28	; 61
     52c:	df 91       	pop	r29
     52e:	cf 91       	pop	r28
     530:	1f 91       	pop	r17
     532:	0f 91       	pop	r16
     534:	08 95       	ret

00000536 <_Z9SameColorv>:


bool SameColor()
{
	Serial.print("c: ");
     536:	68 ea       	ldi	r22, 0xA8	; 168
     538:	71 e0       	ldi	r23, 0x01	; 1
     53a:	89 e9       	ldi	r24, 0x99	; 153
     53c:	94 e0       	ldi	r25, 0x04	; 4
     53e:	0e 94 45 1f 	call	0x3e8a	; 0x3e8a <_ZN5Print5printEPKc>
	Serial.print(c.p.R);
     542:	60 91 cb 02 	lds	r22, 0x02CB	; 0x8002cb <c+0x4>
     546:	70 91 cc 02 	lds	r23, 0x02CC	; 0x8002cc <c+0x5>
     54a:	4a e0       	ldi	r20, 0x0A	; 10
     54c:	50 e0       	ldi	r21, 0x00	; 0
     54e:	89 e9       	ldi	r24, 0x99	; 153
     550:	94 e0       	ldi	r25, 0x04	; 4
     552:	0e 94 1b 20 	call	0x4036	; 0x4036 <_ZN5Print5printEii>
	Serial.print(" ");
     556:	6f e2       	ldi	r22, 0x2F	; 47
     558:	72 e0       	ldi	r23, 0x02	; 2
     55a:	89 e9       	ldi	r24, 0x99	; 153
     55c:	94 e0       	ldi	r25, 0x04	; 4
     55e:	0e 94 45 1f 	call	0x3e8a	; 0x3e8a <_ZN5Print5printEPKc>
	Serial.print(c.p.G);
     562:	60 91 cd 02 	lds	r22, 0x02CD	; 0x8002cd <c+0x6>
     566:	70 91 ce 02 	lds	r23, 0x02CE	; 0x8002ce <c+0x7>
     56a:	4a e0       	ldi	r20, 0x0A	; 10
     56c:	50 e0       	ldi	r21, 0x00	; 0
     56e:	89 e9       	ldi	r24, 0x99	; 153
     570:	94 e0       	ldi	r25, 0x04	; 4
     572:	0e 94 1b 20 	call	0x4036	; 0x4036 <_ZN5Print5printEii>
	Serial.print(" ");
     576:	6f e2       	ldi	r22, 0x2F	; 47
     578:	72 e0       	ldi	r23, 0x02	; 2
     57a:	89 e9       	ldi	r24, 0x99	; 153
     57c:	94 e0       	ldi	r25, 0x04	; 4
     57e:	0e 94 45 1f 	call	0x3e8a	; 0x3e8a <_ZN5Print5printEPKc>
	Serial.print(c.p.B);
     582:	60 91 cf 02 	lds	r22, 0x02CF	; 0x8002cf <c+0x8>
     586:	70 91 d0 02 	lds	r23, 0x02D0	; 0x8002d0 <c+0x9>
     58a:	4a e0       	ldi	r20, 0x0A	; 10
     58c:	50 e0       	ldi	r21, 0x00	; 0
     58e:	89 e9       	ldi	r24, 0x99	; 153
     590:	94 e0       	ldi	r25, 0x04	; 4
     592:	0e 94 1b 20 	call	0x4036	; 0x4036 <_ZN5Print5printEii>
	Serial.print("read_in: ");
     596:	6c ea       	ldi	r22, 0xAC	; 172
     598:	71 e0       	ldi	r23, 0x01	; 1
     59a:	89 e9       	ldi	r24, 0x99	; 153
     59c:	94 e0       	ldi	r25, 0x04	; 4
     59e:	0e 94 45 1f 	call	0x3e8a	; 0x3e8a <_ZN5Print5printEPKc>
	Serial.print(redScanned);
     5a2:	4a e0       	ldi	r20, 0x0A	; 10
     5a4:	50 e0       	ldi	r21, 0x00	; 0
     5a6:	60 91 c5 02 	lds	r22, 0x02C5	; 0x8002c5 <redScanned>
     5aa:	89 e9       	ldi	r24, 0x99	; 153
     5ac:	94 e0       	ldi	r25, 0x04	; 4
     5ae:	0e 94 ba 1f 	call	0x3f74	; 0x3f74 <_ZN5Print5printEhi>
	Serial.print(" ");
     5b2:	6f e2       	ldi	r22, 0x2F	; 47
     5b4:	72 e0       	ldi	r23, 0x02	; 2
     5b6:	89 e9       	ldi	r24, 0x99	; 153
     5b8:	94 e0       	ldi	r25, 0x04	; 4
     5ba:	0e 94 45 1f 	call	0x3e8a	; 0x3e8a <_ZN5Print5printEPKc>
	Serial.print(greenScanned);
     5be:	4a e0       	ldi	r20, 0x0A	; 10
     5c0:	50 e0       	ldi	r21, 0x00	; 0
     5c2:	60 91 c6 02 	lds	r22, 0x02C6	; 0x8002c6 <greenScanned>
     5c6:	89 e9       	ldi	r24, 0x99	; 153
     5c8:	94 e0       	ldi	r25, 0x04	; 4
     5ca:	0e 94 ba 1f 	call	0x3f74	; 0x3f74 <_ZN5Print5printEhi>
	Serial.print(" ");
     5ce:	6f e2       	ldi	r22, 0x2F	; 47
     5d0:	72 e0       	ldi	r23, 0x02	; 2
     5d2:	89 e9       	ldi	r24, 0x99	; 153
     5d4:	94 e0       	ldi	r25, 0x04	; 4
     5d6:	0e 94 45 1f 	call	0x3e8a	; 0x3e8a <_ZN5Print5printEPKc>
	Serial.print(blueScanned);
     5da:	4a e0       	ldi	r20, 0x0A	; 10
     5dc:	50 e0       	ldi	r21, 0x00	; 0
     5de:	60 91 c4 02 	lds	r22, 0x02C4	; 0x8002c4 <blueScanned>
     5e2:	89 e9       	ldi	r24, 0x99	; 153
     5e4:	94 e0       	ldi	r25, 0x04	; 4
     5e6:	0e 94 ba 1f 	call	0x3f74	; 0x3f74 <_ZN5Print5printEhi>
	// check if RGB values are within range specified by tolerance
	if (redScanned < (c.p.R - TOLERANCE) || redScanned > (c.p.R + TOLERANCE))
     5ea:	20 91 c5 02 	lds	r18, 0x02C5	; 0x8002c5 <redScanned>
     5ee:	30 e0       	ldi	r19, 0x00	; 0
     5f0:	80 91 cb 02 	lds	r24, 0x02CB	; 0x8002cb <c+0x4>
     5f4:	90 91 cc 02 	lds	r25, 0x02CC	; 0x8002cc <c+0x5>
     5f8:	ac 01       	movw	r20, r24
     5fa:	45 50       	subi	r20, 0x05	; 5
     5fc:	51 09       	sbc	r21, r1
     5fe:	24 17       	cp	r18, r20
     600:	35 07       	cpc	r19, r21
     602:	74 f1       	brlt	.+92     	; 0x660 <_Z9SameColorv+0x12a>
     604:	05 96       	adiw	r24, 0x05	; 5
     606:	82 17       	cp	r24, r18
     608:	93 07       	cpc	r25, r19
     60a:	54 f1       	brlt	.+84     	; 0x660 <_Z9SameColorv+0x12a>
	return false;
	if (greenScanned < (c.p.G - TOLERANCE) || greenScanned > (c.p.G + TOLERANCE))
     60c:	20 91 c6 02 	lds	r18, 0x02C6	; 0x8002c6 <greenScanned>
     610:	30 e0       	ldi	r19, 0x00	; 0
     612:	80 91 cd 02 	lds	r24, 0x02CD	; 0x8002cd <c+0x6>
     616:	90 91 ce 02 	lds	r25, 0x02CE	; 0x8002ce <c+0x7>
     61a:	ac 01       	movw	r20, r24
     61c:	45 50       	subi	r20, 0x05	; 5
     61e:	51 09       	sbc	r21, r1
     620:	24 17       	cp	r18, r20
     622:	35 07       	cpc	r19, r21
     624:	ec f0       	brlt	.+58     	; 0x660 <_Z9SameColorv+0x12a>
     626:	05 96       	adiw	r24, 0x05	; 5
     628:	82 17       	cp	r24, r18
     62a:	93 07       	cpc	r25, r19
     62c:	cc f0       	brlt	.+50     	; 0x660 <_Z9SameColorv+0x12a>
	return false;
	if (blueScanned < (c.p.B - TOLERANCE) || blueScanned > (c.p.B + TOLERANCE))
     62e:	20 91 c4 02 	lds	r18, 0x02C4	; 0x8002c4 <blueScanned>
     632:	30 e0       	ldi	r19, 0x00	; 0
     634:	80 91 cf 02 	lds	r24, 0x02CF	; 0x8002cf <c+0x8>
     638:	90 91 d0 02 	lds	r25, 0x02D0	; 0x8002d0 <c+0x9>
     63c:	ac 01       	movw	r20, r24
     63e:	45 50       	subi	r20, 0x05	; 5
     640:	51 09       	sbc	r21, r1
     642:	24 17       	cp	r18, r20
     644:	35 07       	cpc	r19, r21
     646:	64 f0       	brlt	.+24     	; 0x660 <_Z9SameColorv+0x12a>
     648:	05 96       	adiw	r24, 0x05	; 5
     64a:	82 17       	cp	r24, r18
     64c:	93 07       	cpc	r25, r19
     64e:	44 f0       	brlt	.+16     	; 0x660 <_Z9SameColorv+0x12a>
	return false;
	
	Serial.print(F("\nFound Matching Color"));
     650:	6c e7       	ldi	r22, 0x7C	; 124
     652:	70 e0       	ldi	r23, 0x00	; 0
     654:	89 e9       	ldi	r24, 0x99	; 153
     656:	94 e0       	ldi	r25, 0x04	; 4
     658:	0e 94 21 1f 	call	0x3e42	; 0x3e42 <_ZN5Print5printEPK19__FlashStringHelper>
	return true;
     65c:	81 e0       	ldi	r24, 0x01	; 1
     65e:	08 95       	ret
	Serial.print(greenScanned);
	Serial.print(" ");
	Serial.print(blueScanned);
	// check if RGB values are within range specified by tolerance
	if (redScanned < (c.p.R - TOLERANCE) || redScanned > (c.p.R + TOLERANCE))
	return false;
     660:	80 e0       	ldi	r24, 0x00	; 0
	if (blueScanned < (c.p.B - TOLERANCE) || blueScanned > (c.p.B + TOLERANCE))
	return false;
	
	Serial.print(F("\nFound Matching Color"));
	return true;
}
     662:	08 95       	ret

00000664 <_Z9FindMatchv>:

double FindMatch()
{
     664:	0f 93       	push	r16
     666:	1f 93       	push	r17
     668:	cf 93       	push	r28
     66a:	df 93       	push	r29
	switch(typeToRead)
     66c:	80 91 c3 02 	lds	r24, 0x02C3	; 0x8002c3 <typeToRead>
     670:	81 30       	cpi	r24, 0x01	; 1
     672:	09 f4       	brne	.+2      	; 0x676 <_Z9FindMatchv+0x12>
     674:	44 c0       	rjmp	.+136    	; 0x6fe <_Z9FindMatchv+0x9a>
     676:	40 f0       	brcs	.+16     	; 0x688 <_Z9FindMatchv+0x24>
     678:	82 30       	cpi	r24, 0x02	; 2
     67a:	09 f0       	breq	.+2      	; 0x67e <_Z9FindMatchv+0x1a>
     67c:	68 c0       	rjmp	.+208    	; 0x74e <_Z9FindMatchv+0xea>
     67e:	0a e1       	ldi	r16, 0x1A	; 26
     680:	13 e0       	ldi	r17, 0x03	; 3
     682:	c0 e0       	ldi	r28, 0x00	; 0
     684:	d0 e0       	ldi	r29, 0x00	; 0
     686:	26 c0       	rjmp	.+76     	; 0x6d4 <_Z9FindMatchv+0x70>
     688:	00 e6       	ldi	r16, 0x60	; 96
     68a:	13 e0       	ldi	r17, 0x03	; 3
     68c:	c0 e0       	ldi	r28, 0x00	; 0
     68e:	d0 e0       	ldi	r29, 0x00	; 0
		case AMMONIA:
		{
			// find matching ammonia value
			for(int i = 0; i < MAX_AMMONIA_COLORS; ++i)
			{
				c = Ammonia[i];
     690:	8a e0       	ldi	r24, 0x0A	; 10
     692:	f8 01       	movw	r30, r16
     694:	a7 ec       	ldi	r26, 0xC7	; 199
     696:	b2 e0       	ldi	r27, 0x02	; 2
     698:	01 90       	ld	r0, Z+
     69a:	0d 92       	st	X+, r0
     69c:	8a 95       	dec	r24
     69e:	e1 f7       	brne	.-8      	; 0x698 <_Z9FindMatchv+0x34>
				if(SameColor())
     6a0:	0e 94 9b 02 	call	0x536	; 0x536 <_Z9SameColorv>
     6a4:	88 23       	and	r24, r24
     6a6:	49 f0       	breq	.+18     	; 0x6ba <_Z9FindMatchv+0x56>
				return Ammonia[i].ppm;
     6a8:	8a e0       	ldi	r24, 0x0A	; 10
     6aa:	8c 9f       	mul	r24, r28
     6ac:	f0 01       	movw	r30, r0
     6ae:	8d 9f       	mul	r24, r29
     6b0:	f0 0d       	add	r31, r0
     6b2:	11 24       	eor	r1, r1
     6b4:	e0 5a       	subi	r30, 0xA0	; 160
     6b6:	fc 4f       	sbci	r31, 0xFC	; 252
     6b8:	3a c0       	rjmp	.+116    	; 0x72e <_Z9FindMatchv+0xca>
	switch(typeToRead)
	{
		case AMMONIA:
		{
			// find matching ammonia value
			for(int i = 0; i < MAX_AMMONIA_COLORS; ++i)
     6ba:	21 96       	adiw	r28, 0x01	; 1
     6bc:	06 5f       	subi	r16, 0xF6	; 246
     6be:	1f 4f       	sbci	r17, 0xFF	; 255
     6c0:	c5 30       	cpi	r28, 0x05	; 5
     6c2:	d1 05       	cpc	r29, r1
     6c4:	29 f7       	brne	.-54     	; 0x690 <_Z9FindMatchv+0x2c>
     6c6:	3e c0       	rjmp	.+124    	; 0x744 <_Z9FindMatchv+0xe0>
			break;
		}
		case NITRITE:
		{
			// find matching nitrite value
			for(int i = 0; i < MAX_NITRITE_NITRATE_COLORS; ++i)
     6c8:	21 96       	adiw	r28, 0x01	; 1
     6ca:	06 5f       	subi	r16, 0xF6	; 246
     6cc:	1f 4f       	sbci	r17, 0xFF	; 255
     6ce:	c7 30       	cpi	r28, 0x07	; 7
     6d0:	d1 05       	cpc	r29, r1
     6d2:	c1 f1       	breq	.+112    	; 0x744 <_Z9FindMatchv+0xe0>
			{
				c = Nitrite[i];
     6d4:	8a e0       	ldi	r24, 0x0A	; 10
     6d6:	f8 01       	movw	r30, r16
     6d8:	a7 ec       	ldi	r26, 0xC7	; 199
     6da:	b2 e0       	ldi	r27, 0x02	; 2
     6dc:	01 90       	ld	r0, Z+
     6de:	0d 92       	st	X+, r0
     6e0:	8a 95       	dec	r24
     6e2:	e1 f7       	brne	.-8      	; 0x6dc <_Z9FindMatchv+0x78>
				if(SameColor())
     6e4:	0e 94 9b 02 	call	0x536	; 0x536 <_Z9SameColorv>
     6e8:	88 23       	and	r24, r24
     6ea:	71 f3       	breq	.-36     	; 0x6c8 <_Z9FindMatchv+0x64>
				return Nitrite[i].ppm;
     6ec:	8a e0       	ldi	r24, 0x0A	; 10
     6ee:	8c 9f       	mul	r24, r28
     6f0:	f0 01       	movw	r30, r0
     6f2:	8d 9f       	mul	r24, r29
     6f4:	f0 0d       	add	r31, r0
     6f6:	11 24       	eor	r1, r1
     6f8:	e6 5e       	subi	r30, 0xE6	; 230
     6fa:	fc 4f       	sbci	r31, 0xFC	; 252
     6fc:	18 c0       	rjmp	.+48     	; 0x72e <_Z9FindMatchv+0xca>
     6fe:	04 ed       	ldi	r16, 0xD4	; 212
     700:	12 e0       	ldi	r17, 0x02	; 2
	return true;
}

double FindMatch()
{
	switch(typeToRead)
     702:	c0 e0       	ldi	r28, 0x00	; 0
     704:	d0 e0       	ldi	r29, 0x00	; 0
		case NITRATE:
		{
			// find matching nitrate value
			for(int i = 0; i < MAX_NITRITE_NITRATE_COLORS; ++i)
			{
				c = Nitrate[i];
     706:	8a e0       	ldi	r24, 0x0A	; 10
     708:	f8 01       	movw	r30, r16
     70a:	a7 ec       	ldi	r26, 0xC7	; 199
     70c:	b2 e0       	ldi	r27, 0x02	; 2
     70e:	01 90       	ld	r0, Z+
     710:	0d 92       	st	X+, r0
     712:	8a 95       	dec	r24
     714:	e1 f7       	brne	.-8      	; 0x70e <_Z9FindMatchv+0xaa>
				if(SameColor())
     716:	0e 94 9b 02 	call	0x536	; 0x536 <_Z9SameColorv>
     71a:	88 23       	and	r24, r24
     71c:	69 f0       	breq	.+26     	; 0x738 <_Z9FindMatchv+0xd4>
				return Nitrate[i].ppm;
     71e:	8a e0       	ldi	r24, 0x0A	; 10
     720:	8c 9f       	mul	r24, r28
     722:	f0 01       	movw	r30, r0
     724:	8d 9f       	mul	r24, r29
     726:	f0 0d       	add	r31, r0
     728:	11 24       	eor	r1, r1
     72a:	ec 52       	subi	r30, 0x2C	; 44
     72c:	fd 4f       	sbci	r31, 0xFD	; 253
     72e:	30 81       	ld	r19, Z
     730:	21 81       	ldd	r18, Z+1	; 0x01
     732:	92 81       	ldd	r25, Z+2	; 0x02
     734:	83 81       	ldd	r24, Z+3	; 0x03
     736:	0a c0       	rjmp	.+20     	; 0x74c <_Z9FindMatchv+0xe8>
			break;
		}
		case NITRATE:
		{
			// find matching nitrate value
			for(int i = 0; i < MAX_NITRITE_NITRATE_COLORS; ++i)
     738:	21 96       	adiw	r28, 0x01	; 1
     73a:	06 5f       	subi	r16, 0xF6	; 246
     73c:	1f 4f       	sbci	r17, 0xFF	; 255
     73e:	c7 30       	cpi	r28, 0x07	; 7
     740:	d1 05       	cpc	r29, r1
     742:	09 f7       	brne	.-62     	; 0x706 <_Z9FindMatchv+0xa2>
			{
				c = Ammonia[i];
				if(SameColor())
				return Ammonia[i].ppm;
			}
			return -1;
     744:	30 e0       	ldi	r19, 0x00	; 0
     746:	20 e0       	ldi	r18, 0x00	; 0
     748:	90 e8       	ldi	r25, 0x80	; 128
     74a:	8f eb       	ldi	r24, 0xBF	; 191
     74c:	ac 01       	movw	r20, r24
			}
			return -1;
			break;
		}
	}
}
     74e:	63 2f       	mov	r22, r19
     750:	72 2f       	mov	r23, r18
     752:	85 2f       	mov	r24, r21
     754:	94 2f       	mov	r25, r20
     756:	df 91       	pop	r29
     758:	cf 91       	pop	r28
     75a:	1f 91       	pop	r17
     75c:	0f 91       	pop	r16
     75e:	08 95       	ret

00000760 <_Z9ScanColor8ReadType>:

long ScanColor(ReadType r)
{
	typeToRead = r;
     760:	80 93 c3 02 	sts	0x02C3, r24	; 0x8002c3 <typeToRead>
	CS.read();
     764:	84 e9       	ldi	r24, 0x94	; 148
     766:	92 e0       	ldi	r25, 0x02	; 2
     768:	0e 94 57 18 	call	0x30ae	; 0x30ae <_ZN9MD_TCS2304readEv>
	while(CS.available() == 0);  // wait for read to complete
     76c:	84 e9       	ldi	r24, 0x94	; 148
     76e:	92 e0       	ldi	r25, 0x02	; 2
     770:	0e 94 61 18 	call	0x30c2	; 0x30c2 <_ZN9MD_TCS2309availableEv>
     774:	88 23       	and	r24, r24
     776:	d1 f3       	breq	.-12     	; 0x76c <_Z9ScanColor8ReadType+0xc>
	CS.getRGB(&rgb);
     778:	61 ed       	ldi	r22, 0xD1	; 209
     77a:	72 e0       	ldi	r23, 0x02	; 2
     77c:	84 e9       	ldi	r24, 0x94	; 148
     77e:	92 e0       	ldi	r25, 0x02	; 2
     780:	0e 94 8d 17 	call	0x2f1a	; 0x2f1a <_ZN9MD_TCS2306getRGBEP9colorData>
	greenScanned = rgb.value[TCS230_RGB_G];
     784:	80 91 d2 02 	lds	r24, 0x02D2	; 0x8002d2 <rgb+0x1>
     788:	80 93 c6 02 	sts	0x02C6, r24	; 0x8002c6 <greenScanned>
	redScanned = rgb.value[TCS230_RGB_R];
     78c:	80 91 d1 02 	lds	r24, 0x02D1	; 0x8002d1 <rgb>
     790:	80 93 c5 02 	sts	0x02C5, r24	; 0x8002c5 <redScanned>
	blueScanned = rgb.value[TCS230_RGB_B];
     794:	80 91 d3 02 	lds	r24, 0x02D3	; 0x8002d3 <rgb+0x2>
     798:	80 93 c4 02 	sts	0x02C4, r24	; 0x8002c4 <blueScanned>
	// look for match
	Serial.println("RGB");
     79c:	66 eb       	ldi	r22, 0xB6	; 182
     79e:	71 e0       	ldi	r23, 0x01	; 1
     7a0:	89 e9       	ldi	r24, 0x99	; 153
     7a2:	94 e0       	ldi	r25, 0x04	; 4
     7a4:	0e 94 52 1f 	call	0x3ea4	; 0x3ea4 <_ZN5Print7printlnEPKc>
	Serial.println(redScanned);
     7a8:	4a e0       	ldi	r20, 0x0A	; 10
     7aa:	50 e0       	ldi	r21, 0x00	; 0
     7ac:	60 91 c5 02 	lds	r22, 0x02C5	; 0x8002c5 <redScanned>
     7b0:	89 e9       	ldi	r24, 0x99	; 153
     7b2:	94 e0       	ldi	r25, 0x04	; 4
     7b4:	0e 94 c1 1f 	call	0x3f82	; 0x3f82 <_ZN5Print7printlnEhi>
	Serial.println(greenScanned);
     7b8:	4a e0       	ldi	r20, 0x0A	; 10
     7ba:	50 e0       	ldi	r21, 0x00	; 0
     7bc:	60 91 c6 02 	lds	r22, 0x02C6	; 0x8002c6 <greenScanned>
     7c0:	89 e9       	ldi	r24, 0x99	; 153
     7c2:	94 e0       	ldi	r25, 0x04	; 4
     7c4:	0e 94 c1 1f 	call	0x3f82	; 0x3f82 <_ZN5Print7printlnEhi>
	Serial.println(blueScanned);
     7c8:	4a e0       	ldi	r20, 0x0A	; 10
     7ca:	50 e0       	ldi	r21, 0x00	; 0
     7cc:	60 91 c4 02 	lds	r22, 0x02C4	; 0x8002c4 <blueScanned>
     7d0:	89 e9       	ldi	r24, 0x99	; 153
     7d2:	94 e0       	ldi	r25, 0x04	; 4
     7d4:	0e 94 c1 1f 	call	0x3f82	; 0x3f82 <_ZN5Print7printlnEhi>
	return FindMatch();
     7d8:	0e 94 32 03 	call	0x664	; 0x664 <_Z9FindMatchv>
     7dc:	0e 94 c3 1b 	call	0x3786	; 0x3786 <__fixsfsi>
}
     7e0:	08 95       	ret

000007e2 <_Z13findTestStrip8ReadType>:

bool findTestStrip(ReadType r)
{
     7e2:	cf 93       	push	r28
	typeToRead = r;
     7e4:	80 93 c3 02 	sts	0x02C3, r24	; 0x8002c3 <typeToRead>
	// Scan for color
	CS.read();
     7e8:	84 e9       	ldi	r24, 0x94	; 148
     7ea:	92 e0       	ldi	r25, 0x02	; 2
     7ec:	0e 94 57 18 	call	0x30ae	; 0x30ae <_ZN9MD_TCS2304readEv>
	while (CS.available() == 0);
     7f0:	84 e9       	ldi	r24, 0x94	; 148
     7f2:	92 e0       	ldi	r25, 0x02	; 2
     7f4:	0e 94 61 18 	call	0x30c2	; 0x30c2 <_ZN9MD_TCS2309availableEv>
     7f8:	88 23       	and	r24, r24
     7fa:	d1 f3       	breq	.-12     	; 0x7f0 <_Z13findTestStrip8ReadType+0xe>
	CS.getRGB(&rgb);
     7fc:	61 ed       	ldi	r22, 0xD1	; 209
     7fe:	72 e0       	ldi	r23, 0x02	; 2
     800:	84 e9       	ldi	r24, 0x94	; 148
     802:	92 e0       	ldi	r25, 0x02	; 2
     804:	0e 94 8d 17 	call	0x2f1a	; 0x2f1a <_ZN9MD_TCS2306getRGBEP9colorData>
	greenScanned = rgb.value[TCS230_RGB_G];
     808:	80 91 d2 02 	lds	r24, 0x02D2	; 0x8002d2 <rgb+0x1>
     80c:	80 93 c6 02 	sts	0x02C6, r24	; 0x8002c6 <greenScanned>
	redScanned = rgb.value[TCS230_RGB_R];
     810:	80 91 d1 02 	lds	r24, 0x02D1	; 0x8002d1 <rgb>
     814:	80 93 c5 02 	sts	0x02C5, r24	; 0x8002c5 <redScanned>
	blueScanned = rgb.value[TCS230_RGB_B];
     818:	80 91 d3 02 	lds	r24, 0x02D3	; 0x8002d3 <rgb+0x2>
     81c:	80 93 c4 02 	sts	0x02C4, r24	; 0x8002c4 <blueScanned>
	// look for match against black
	c = EmptyTestBox;
     820:	8a e0       	ldi	r24, 0x0A	; 10
     822:	e0 e1       	ldi	r30, 0x10	; 16
     824:	f1 e0       	ldi	r31, 0x01	; 1
     826:	a7 ec       	ldi	r26, 0xC7	; 199
     828:	b2 e0       	ldi	r27, 0x02	; 2
     82a:	01 90       	ld	r0, Z+
     82c:	0d 92       	st	X+, r0
     82e:	8a 95       	dec	r24
     830:	e1 f7       	brne	.-8      	; 0x82a <_Z13findTestStrip8ReadType+0x48>
	bool foundEmptyBox = SameColor();
     832:	0e 94 9b 02 	call	0x536	; 0x536 <_Z9SameColorv>
	c = WhiteTestStrip;
     836:	9a e0       	ldi	r25, 0x0A	; 10
     838:	e6 e0       	ldi	r30, 0x06	; 6
     83a:	f1 e0       	ldi	r31, 0x01	; 1
     83c:	a7 ec       	ldi	r26, 0xC7	; 199
     83e:	b2 e0       	ldi	r27, 0x02	; 2
     840:	01 90       	ld	r0, Z+
     842:	0d 92       	st	X+, r0
     844:	9a 95       	dec	r25
     846:	e1 f7       	brne	.-8      	; 0x840 <_Z13findTestStrip8ReadType+0x5e>
	foundEmptyBox =  foundEmptyBox || SameColor();
     848:	81 11       	cpse	r24, r1
     84a:	05 c0       	rjmp	.+10     	; 0x856 <_Z13findTestStrip8ReadType+0x74>
     84c:	0e 94 9b 02 	call	0x536	; 0x536 <_Z9SameColorv>
     850:	c8 2f       	mov	r28, r24
     852:	88 23       	and	r24, r24
     854:	59 f0       	breq	.+22     	; 0x86c <_Z13findTestStrip8ReadType+0x8a>
	return foundEmptyBox && (FindMatch() == -1);
     856:	0e 94 32 03 	call	0x664	; 0x664 <_Z9FindMatchv>
     85a:	c1 e0       	ldi	r28, 0x01	; 1
     85c:	20 e0       	ldi	r18, 0x00	; 0
     85e:	30 e0       	ldi	r19, 0x00	; 0
     860:	40 e8       	ldi	r20, 0x80	; 128
     862:	5f eb       	ldi	r21, 0xBF	; 191
     864:	0e 94 4c 1b 	call	0x3698	; 0x3698 <__cmpsf2>
     868:	81 11       	cpse	r24, r1
     86a:	c0 e0       	ldi	r28, 0x00	; 0
     86c:	8c 2f       	mov	r24, r28
     86e:	cf 91       	pop	r28
     870:	08 95       	ret

00000872 <_GLOBAL__sub_I_Ammonia>:
uint8_t redScanned;
uint8_t blueScanned;

ReadType typeToRead;

MD_TCS230  CS(S2, S3, OE);
     872:	28 e0       	ldi	r18, 0x08	; 8
     874:	4d e0       	ldi	r20, 0x0D	; 13
     876:	6c e0       	ldi	r22, 0x0C	; 12
     878:	84 e9       	ldi	r24, 0x94	; 148
     87a:	92 e0       	ldi	r25, 0x02	; 2
     87c:	0c 94 f0 16 	jmp	0x2de0	; 0x2de0 <_ZN9MD_TCS230C1Ehhh>

00000880 <_GLOBAL__sub_D_Ammonia>:
     880:	84 e9       	ldi	r24, 0x94	; 148
     882:	92 e0       	ldi	r25, 0x02	; 2
     884:	0c 94 04 17 	jmp	0x2e08	; 0x2e08 <_ZN9MD_TCS230D1Ev>

00000888 <_Z11measureTempv>:

#define TEMP_PIN 6

OneWire ds(TEMP_PIN); // Temp sensor on pin 6

float measureTemp() {
     888:	ef 92       	push	r14
     88a:	ff 92       	push	r15
     88c:	0f 93       	push	r16
     88e:	1f 93       	push	r17
     890:	cf 93       	push	r28
     892:	df 93       	push	r29
     894:	cd b7       	in	r28, 0x3d	; 61
     896:	de b7       	in	r29, 0x3e	; 62
     898:	64 97       	sbiw	r28, 0x14	; 20
     89a:	0f b6       	in	r0, 0x3f	; 63
     89c:	f8 94       	cli
     89e:	de bf       	out	0x3e, r29	; 62
     8a0:	0f be       	out	0x3f, r0	; 63
     8a2:	cd bf       	out	0x3d, r28	; 61
	byte i;
	byte data[12];
	byte addr[8];
	float celsius; //, fahrenheit;
	
	ds.reset_search();
     8a4:	82 e9       	ldi	r24, 0x92	; 146
     8a6:	93 e0       	ldi	r25, 0x03	; 3
     8a8:	0e 94 8d 08 	call	0x111a	; 0x111a <_ZN7OneWire12reset_searchEv>
	delay(250);
     8ac:	6a ef       	ldi	r22, 0xFA	; 250
     8ae:	70 e0       	ldi	r23, 0x00	; 0
     8b0:	80 e0       	ldi	r24, 0x00	; 0
     8b2:	90 e0       	ldi	r25, 0x00	; 0
     8b4:	0e 94 00 21 	call	0x4200	; 0x4200 <delay>
	ds.search(addr);
     8b8:	41 e0       	ldi	r20, 0x01	; 1
     8ba:	be 01       	movw	r22, r28
     8bc:	63 5f       	subi	r22, 0xF3	; 243
     8be:	7f 4f       	sbci	r23, 0xFF	; 255
     8c0:	82 e9       	ldi	r24, 0x92	; 146
     8c2:	93 e0       	ldi	r25, 0x03	; 3
     8c4:	0e 94 bc 08 	call	0x1178	; 0x1178 <_ZN7OneWire6searchEPhb>

	if (OneWire::crc8(addr, 7) != addr[7]) {
     8c8:	67 e0       	ldi	r22, 0x07	; 7
     8ca:	ce 01       	movw	r24, r28
     8cc:	0d 96       	adiw	r24, 0x0d	; 13
     8ce:	0e 94 43 09 	call	0x1286	; 0x1286 <_ZN7OneWire4crc8EPKhh>
     8d2:	9c 89       	ldd	r25, Y+20	; 0x14
     8d4:	89 13       	cpse	r24, r25
     8d6:	54 c0       	rjmp	.+168    	; 0x980 <__stack+0x81>
		return -1;
	}

	ds.reset();
     8d8:	82 e9       	ldi	r24, 0x92	; 146
     8da:	93 e0       	ldi	r25, 0x03	; 3
     8dc:	0e 94 81 07 	call	0xf02	; 0xf02 <_ZN7OneWire5resetEv>
	ds.select(addr);
     8e0:	be 01       	movw	r22, r28
     8e2:	63 5f       	subi	r22, 0xF3	; 243
     8e4:	7f 4f       	sbci	r23, 0xFF	; 255
     8e6:	82 e9       	ldi	r24, 0x92	; 146
     8e8:	93 e0       	ldi	r25, 0x03	; 3
     8ea:	0e 94 6e 08 	call	0x10dc	; 0x10dc <_ZN7OneWire6selectEPKh>
	ds.write(0x44, 1);        // start conversion, with parasite power on at the end
     8ee:	41 e0       	ldi	r20, 0x01	; 1
     8f0:	64 e4       	ldi	r22, 0x44	; 68
     8f2:	82 e9       	ldi	r24, 0x92	; 146
     8f4:	93 e0       	ldi	r25, 0x03	; 3
     8f6:	0e 94 1e 08 	call	0x103c	; 0x103c <_ZN7OneWire5writeEhh>
	
	delay(1000);     // maybe 750ms is enough, maybe not
     8fa:	68 ee       	ldi	r22, 0xE8	; 232
     8fc:	73 e0       	ldi	r23, 0x03	; 3
     8fe:	80 e0       	ldi	r24, 0x00	; 0
     900:	90 e0       	ldi	r25, 0x00	; 0
     902:	0e 94 00 21 	call	0x4200	; 0x4200 <delay>
	
	ds.reset();
     906:	82 e9       	ldi	r24, 0x92	; 146
     908:	93 e0       	ldi	r25, 0x03	; 3
     90a:	0e 94 81 07 	call	0xf02	; 0xf02 <_ZN7OneWire5resetEv>
	ds.select(addr);
     90e:	be 01       	movw	r22, r28
     910:	63 5f       	subi	r22, 0xF3	; 243
     912:	7f 4f       	sbci	r23, 0xFF	; 255
     914:	82 e9       	ldi	r24, 0x92	; 146
     916:	93 e0       	ldi	r25, 0x03	; 3
     918:	0e 94 6e 08 	call	0x10dc	; 0x10dc <_ZN7OneWire6selectEPKh>
	ds.write(0xBE);         // Read Scratchpad
     91c:	40 e0       	ldi	r20, 0x00	; 0
     91e:	6e eb       	ldi	r22, 0xBE	; 190
     920:	82 e9       	ldi	r24, 0x92	; 146
     922:	93 e0       	ldi	r25, 0x03	; 3
     924:	0e 94 1e 08 	call	0x103c	; 0x103c <_ZN7OneWire5writeEhh>
     928:	8e 01       	movw	r16, r28
     92a:	0f 5f       	subi	r16, 0xFF	; 255
     92c:	1f 4f       	sbci	r17, 0xFF	; 255
     92e:	7e 01       	movw	r14, r28
     930:	8a e0       	ldi	r24, 0x0A	; 10
     932:	e8 0e       	add	r14, r24
     934:	f1 1c       	adc	r15, r1

	for ( i = 0; i < 9; i++) {           // we need 9 bytes
		data[i] = ds.read();
     936:	82 e9       	ldi	r24, 0x92	; 146
     938:	93 e0       	ldi	r25, 0x03	; 3
     93a:	0e 94 52 08 	call	0x10a4	; 0x10a4 <_ZN7OneWire4readEv>
     93e:	f8 01       	movw	r30, r16
     940:	81 93       	st	Z+, r24
     942:	8f 01       	movw	r16, r30
	
	ds.reset();
	ds.select(addr);
	ds.write(0xBE);         // Read Scratchpad

	for ( i = 0; i < 9; i++) {           // we need 9 bytes
     944:	ee 15       	cp	r30, r14
     946:	ff 05       	cpc	r31, r15
     948:	b1 f7       	brne	.-20     	; 0x936 <__stack+0x37>

	// Convert the data to actual temperature
	// because the result is a 16 bit signed integer, it should
	// be stored to an "int16_t" type, which is always 16 bits
	// even when compiled on a 32 bit processor.
	int16_t raw = (data[1] << 8) | data[0];
     94a:	69 81       	ldd	r22, Y+1	; 0x01
     94c:	7a 81       	ldd	r23, Y+2	; 0x02

	byte cfg = (data[4] & 0x60);
     94e:	8d 81       	ldd	r24, Y+5	; 0x05
     950:	80 76       	andi	r24, 0x60	; 96
	// at lower res, the low bits are undefined, so let's zero them
	if (cfg == 0x00) raw = raw & ~7;  // 9 bit resolution, 93.75 ms
     952:	11 f4       	brne	.+4      	; 0x958 <__stack+0x59>
     954:	68 7f       	andi	r22, 0xF8	; 248
     956:	07 c0       	rjmp	.+14     	; 0x966 <__stack+0x67>
	else if (cfg == 0x20) raw = raw & ~3; // 10 bit res, 187.5 ms
     958:	80 32       	cpi	r24, 0x20	; 32
     95a:	11 f4       	brne	.+4      	; 0x960 <__stack+0x61>
     95c:	6c 7f       	andi	r22, 0xFC	; 252
     95e:	03 c0       	rjmp	.+6      	; 0x966 <__stack+0x67>
	else if (cfg == 0x40) raw = raw & ~1; // 11 bit res, 375 ms
     960:	80 34       	cpi	r24, 0x40	; 64
     962:	09 f4       	brne	.+2      	; 0x966 <__stack+0x67>
     964:	6e 7f       	andi	r22, 0xFE	; 254
	
	celsius = (float)raw / 16.0;
     966:	07 2e       	mov	r0, r23
     968:	00 0c       	add	r0, r0
     96a:	88 0b       	sbc	r24, r24
     96c:	99 0b       	sbc	r25, r25
     96e:	0e 94 fb 1b 	call	0x37f6	; 0x37f6 <__floatsisf>
     972:	20 e0       	ldi	r18, 0x00	; 0
     974:	30 e0       	ldi	r19, 0x00	; 0
     976:	40 e8       	ldi	r20, 0x80	; 128
     978:	5d e3       	ldi	r21, 0x3D	; 61
     97a:	0e 94 ab 1c 	call	0x3956	; 0x3956 <__mulsf3>
	return celsius;
     97e:	04 c0       	rjmp	.+8      	; 0x988 <__stack+0x89>
	ds.reset_search();
	delay(250);
	ds.search(addr);

	if (OneWire::crc8(addr, 7) != addr[7]) {
		return -1;
     980:	60 e0       	ldi	r22, 0x00	; 0
     982:	70 e0       	ldi	r23, 0x00	; 0
     984:	80 e8       	ldi	r24, 0x80	; 128
     986:	9f eb       	ldi	r25, 0xBF	; 191
	else if (cfg == 0x20) raw = raw & ~3; // 10 bit res, 187.5 ms
	else if (cfg == 0x40) raw = raw & ~1; // 11 bit res, 375 ms
	
	celsius = (float)raw / 16.0;
	return celsius;
     988:	64 96       	adiw	r28, 0x14	; 20
     98a:	0f b6       	in	r0, 0x3f	; 63
     98c:	f8 94       	cli
     98e:	de bf       	out	0x3e, r29	; 62
     990:	0f be       	out	0x3f, r0	; 63
     992:	cd bf       	out	0x3d, r28	; 61
     994:	df 91       	pop	r29
     996:	cf 91       	pop	r28
     998:	1f 91       	pop	r17
     99a:	0f 91       	pop	r16
     99c:	ff 90       	pop	r15
     99e:	ef 90       	pop	r14
     9a0:	08 95       	ret

000009a2 <_GLOBAL__sub_I_ds>:
    bool LastDeviceFlag;
#endif

  public:
    OneWire() { }
    OneWire(uint8_t pin) { begin(pin); }
     9a2:	66 e0       	ldi	r22, 0x06	; 6
     9a4:	82 e9       	ldi	r24, 0x92	; 146
     9a6:	93 e0       	ldi	r25, 0x03	; 3
     9a8:	0c 94 99 08 	jmp	0x1132	; 0x1132 <_ZN7OneWire5beginEh>

000009ac <_Z20TaskPHandTemperaturePv>:
}


// get pH and temp reading from sensors
void TaskPHandTemperature(void *pvParameters)
{
     9ac:	cf 93       	push	r28
     9ae:	df 93       	push	r29
     9b0:	00 d0       	rcall	.+0      	; 0x9b2 <_Z20TaskPHandTemperaturePv+0x6>
     9b2:	cd b7       	in	r28, 0x3d	; 61
     9b4:	de b7       	in	r29, 0x3e	; 62
  (void) pvParameters;
  
	TickType_t xLastWakeTime = xTaskGetTickCount();
     9b6:	0e 94 1c 11 	call	0x2238	; 0x2238 <xTaskGetTickCount>
     9ba:	9a 83       	std	Y+2, r25	; 0x02
     9bc:	89 83       	std	Y+1, r24	; 0x01
	for (;;) // A Task shall never return or exit.
	{
		// Gets pH value
		phValue = calcPH() * 100;
     9be:	0e 94 5b 09 	call	0x12b6	; 0x12b6 <_Z6calcPHv>
     9c2:	20 e0       	ldi	r18, 0x00	; 0
     9c4:	30 e0       	ldi	r19, 0x00	; 0
     9c6:	48 ec       	ldi	r20, 0xC8	; 200
     9c8:	52 e4       	ldi	r21, 0x42	; 66
     9ca:	0e 94 ab 1c 	call	0x3956	; 0x3956 <__mulsf3>
     9ce:	0e 94 c3 1b 	call	0x3786	; 0x3786 <__fixsfsi>
     9d2:	60 93 c8 03 	sts	0x03C8, r22	; 0x8003c8 <phValue>
     9d6:	70 93 c9 03 	sts	0x03C9, r23	; 0x8003c9 <phValue+0x1>
     9da:	80 93 ca 03 	sts	0x03CA, r24	; 0x8003ca <phValue+0x2>
     9de:	90 93 cb 03 	sts	0x03CB, r25	; 0x8003cb <phValue+0x3>
		// Gets temperature value in Celsius
		tempValue = measureTemp() * 100;
     9e2:	0e 94 44 04 	call	0x888	; 0x888 <_Z11measureTempv>
     9e6:	20 e0       	ldi	r18, 0x00	; 0
     9e8:	30 e0       	ldi	r19, 0x00	; 0
     9ea:	48 ec       	ldi	r20, 0xC8	; 200
     9ec:	52 e4       	ldi	r21, 0x42	; 66
     9ee:	0e 94 ab 1c 	call	0x3956	; 0x3956 <__mulsf3>
     9f2:	0e 94 c3 1b 	call	0x3786	; 0x3786 <__fixsfsi>
     9f6:	9b 01       	movw	r18, r22
     9f8:	70 93 c7 03 	sts	0x03C7, r23	; 0x8003c7 <tempValue+0x1>
     9fc:	60 93 c6 03 	sts	0x03C6, r22	; 0x8003c6 <tempValue>
		//Serial.println("check temp");

		// RELAY LOGIC (switching on 0.5 C above and below temperature threshold)
		if (tempValue < (tempThreshold - 50)) {
     a00:	80 91 1b 01 	lds	r24, 0x011B	; 0x80011b <tempThreshold>
     a04:	90 91 1c 01 	lds	r25, 0x011C	; 0x80011c <tempThreshold+0x1>
     a08:	ac 01       	movw	r20, r24
     a0a:	42 53       	subi	r20, 0x32	; 50
     a0c:	51 09       	sbc	r21, r1
     a0e:	24 17       	cp	r18, r20
     a10:	35 07       	cpc	r19, r21
     a12:	14 f4       	brge	.+4      	; 0xa18 <_Z20TaskPHandTemperaturePv+0x6c>
			digitalWrite(relay, HIGH);
     a14:	61 e0       	ldi	r22, 0x01	; 1
     a16:	05 c0       	rjmp	.+10     	; 0xa22 <_Z20TaskPHandTemperaturePv+0x76>
		}
		else if (tempValue > (tempThreshold + 50)) {
     a18:	c2 96       	adiw	r24, 0x32	; 50
     a1a:	82 17       	cp	r24, r18
     a1c:	93 07       	cpc	r25, r19
     a1e:	24 f4       	brge	.+8      	; 0xa28 <_Z20TaskPHandTemperaturePv+0x7c>
			digitalWrite(relay, LOW);
     a20:	60 e0       	ldi	r22, 0x00	; 0
     a22:	84 e0       	ldi	r24, 0x04	; 4
     a24:	0e 94 63 22 	call	0x44c6	; 0x44c6 <digitalWrite>
		}
    // check pH and temp every 5 sec
    vTaskDelayUntil( &xLastWakeTime, 5000 / portTICK_PERIOD_MS );
     a28:	68 e3       	ldi	r22, 0x38	; 56
     a2a:	71 e0       	ldi	r23, 0x01	; 1
     a2c:	ce 01       	movw	r24, r28
     a2e:	01 96       	adiw	r24, 0x01	; 1
     a30:	0e 94 41 12 	call	0x2482	; 0x2482 <vTaskDelayUntil>
void TaskPHandTemperature(void *pvParameters)
{
  (void) pvParameters;
  
	TickType_t xLastWakeTime = xTaskGetTickCount();
	for (;;) // A Task shall never return or exit.
     a34:	c4 cf       	rjmp	.-120    	; 0x9be <_Z20TaskPHandTemperaturePv+0x12>

00000a36 <_ZN5Print5writeEPKc>:
    int getWriteError() { return write_error; }
    void clearWriteError() { setWriteError(0); }
  
    virtual size_t write(uint8_t) = 0;
    size_t write(const char *str) {
      if (str == NULL) return 0;
     a36:	61 15       	cp	r22, r1
     a38:	71 05       	cpc	r23, r1
     a3a:	79 f0       	breq	.+30     	; 0xa5a <_ZN5Print5writeEPKc+0x24>
      return write((const uint8_t *)str, strlen(str));
     a3c:	fb 01       	movw	r30, r22
     a3e:	01 90       	ld	r0, Z+
     a40:	00 20       	and	r0, r0
     a42:	e9 f7       	brne	.-6      	; 0xa3e <_ZN5Print5writeEPKc+0x8>
     a44:	31 97       	sbiw	r30, 0x01	; 1
     a46:	af 01       	movw	r20, r30
     a48:	46 1b       	sub	r20, r22
     a4a:	57 0b       	sbc	r21, r23
     a4c:	dc 01       	movw	r26, r24
     a4e:	ed 91       	ld	r30, X+
     a50:	fc 91       	ld	r31, X
     a52:	02 80       	ldd	r0, Z+2	; 0x02
     a54:	f3 81       	ldd	r31, Z+3	; 0x03
     a56:	e0 2d       	mov	r30, r0
     a58:	09 94       	ijmp
    }
     a5a:	80 e0       	ldi	r24, 0x00	; 0
     a5c:	90 e0       	ldi	r25, 0x00	; 0
     a5e:	08 95       	ret

00000a60 <_Z6setLED8LEDColor>:
LEDColor White = {255, 255, 255};
LEDColor Off = {0, 0, 0};


void setLED(LEDColor c)
{
     a60:	cf 93       	push	r28
     a62:	df 93       	push	r29
     a64:	00 d0       	rcall	.+0      	; 0xa66 <_Z6setLED8LEDColor+0x6>
     a66:	00 d0       	rcall	.+0      	; 0xa68 <_Z6setLED8LEDColor+0x8>
     a68:	00 d0       	rcall	.+0      	; 0xa6a <_Z6setLED8LEDColor+0xa>
     a6a:	cd b7       	in	r28, 0x3d	; 61
     a6c:	de b7       	in	r29, 0x3e	; 62
     a6e:	49 83       	std	Y+1, r20	; 0x01
     a70:	5a 83       	std	Y+2, r21	; 0x02
     a72:	6b 83       	std	Y+3, r22	; 0x03
     a74:	7c 83       	std	Y+4, r23	; 0x04
     a76:	8d 83       	std	Y+5, r24	; 0x05
     a78:	9e 83       	std	Y+6, r25	; 0x06
	analogWrite(R_LED, c.r);
     a7a:	69 81       	ldd	r22, Y+1	; 0x01
     a7c:	7a 81       	ldd	r23, Y+2	; 0x02
     a7e:	8f e0       	ldi	r24, 0x0F	; 15
     a80:	0e 94 9f 21 	call	0x433e	; 0x433e <analogWrite>
	analogWrite(G_LED, c.g);
     a84:	6b 81       	ldd	r22, Y+3	; 0x03
     a86:	7c 81       	ldd	r23, Y+4	; 0x04
     a88:	80 e1       	ldi	r24, 0x10	; 16
     a8a:	0e 94 9f 21 	call	0x433e	; 0x433e <analogWrite>
	analogWrite(B_LED, c.b);
     a8e:	6d 81       	ldd	r22, Y+5	; 0x05
     a90:	7e 81       	ldd	r23, Y+6	; 0x06
     a92:	81 e1       	ldi	r24, 0x11	; 17
}
     a94:	26 96       	adiw	r28, 0x06	; 6
     a96:	0f b6       	in	r0, 0x3f	; 63
     a98:	f8 94       	cli
     a9a:	de bf       	out	0x3e, r29	; 62
     a9c:	0f be       	out	0x3f, r0	; 63
     a9e:	cd bf       	out	0x3d, r28	; 61
     aa0:	df 91       	pop	r29
     aa2:	cf 91       	pop	r28

void setLED(LEDColor c)
{
	analogWrite(R_LED, c.r);
	analogWrite(G_LED, c.g);
	analogWrite(B_LED, c.b);
     aa4:	0c 94 9f 21 	jmp	0x433e	; 0x433e <analogWrite>

00000aa8 <_Z15TaskColorSensorPv>:
// get Ammonia, Nitrite, and Nitrate reading from color sensor
void TaskColorSensor(void *pvParameters)
{
	(void) pvParameters;
  
	TickType_t xLastWakeTime = xTaskGetTickCount();
     aa8:	0e 94 1c 11 	call	0x2238	; 0x2238 <xTaskGetTickCount>
				case 'N':
				{
					while (findTestStrip(NITRATE));
					setLED(Green);
					delay(250); // allow user to see LED and stop moving test strip
					nitrateValue = ScanColor(NITRATE) * 100;					
     aac:	c4 e6       	ldi	r28, 0x64	; 100
	(void) pvParameters;
  
	TickType_t xLastWakeTime = xTaskGetTickCount();
	for (;;) // A Task shall never return or exit.
	{
		if ( xSemaphoreTake( xSerialSemaphoreColorSensor, ( TickType_t ) 1 ) == pdTRUE )
     aae:	61 e0       	ldi	r22, 0x01	; 1
     ab0:	70 e0       	ldi	r23, 0x00	; 0
     ab2:	80 91 c4 03 	lds	r24, 0x03C4	; 0x8003c4 <xSerialSemaphoreColorSensor>
     ab6:	90 91 c5 03 	lds	r25, 0x03C5	; 0x8003c5 <xSerialSemaphoreColorSensor+0x1>
     aba:	0e 94 59 0e 	call	0x1cb2	; 0x1cb2 <xQueueSemaphoreTake>
     abe:	81 30       	cpi	r24, 0x01	; 1
     ac0:	09 f0       	breq	.+2      	; 0xac4 <_Z15TaskColorSensorPv+0x1c>
     ac2:	a3 c0       	rjmp	.+326    	; 0xc0a <_Z15TaskColorSensorPv+0x162>
		{
			switch (colorToRead)
     ac4:	80 91 1a 01 	lds	r24, 0x011A	; 0x80011a <colorToRead>
     ac8:	8e 34       	cpi	r24, 0x4E	; 78
     aca:	09 f4       	brne	.+2      	; 0xace <_Z15TaskColorSensorPv+0x26>
     acc:	57 c0       	rjmp	.+174    	; 0xb7c <_Z15TaskColorSensorPv+0xd4>
     ace:	8e 36       	cpi	r24, 0x6E	; 110
     ad0:	49 f1       	breq	.+82     	; 0xb24 <_Z15TaskColorSensorPv+0x7c>
     ad2:	81 34       	cpi	r24, 0x41	; 65
     ad4:	09 f0       	breq	.+2      	; 0xad8 <_Z15TaskColorSensorPv+0x30>
     ad6:	8b c0       	rjmp	.+278    	; 0xbee <_Z15TaskColorSensorPv+0x146>
			{
				case 'A':
				{
					while (findTestStrip(AMMONIA));
     ad8:	80 e0       	ldi	r24, 0x00	; 0
     ada:	0e 94 f1 03 	call	0x7e2	; 0x7e2 <_Z13findTestStrip8ReadType>
     ade:	81 11       	cpse	r24, r1
     ae0:	fb cf       	rjmp	.-10     	; 0xad8 <_Z15TaskColorSensorPv+0x30>
					setLED(Red);
     ae2:	40 91 2f 01 	lds	r20, 0x012F	; 0x80012f <Red>
     ae6:	50 91 30 01 	lds	r21, 0x0130	; 0x800130 <Red+0x1>
     aea:	60 91 31 01 	lds	r22, 0x0131	; 0x800131 <Red+0x2>
     aee:	70 91 32 01 	lds	r23, 0x0132	; 0x800132 <Red+0x3>
     af2:	80 91 33 01 	lds	r24, 0x0133	; 0x800133 <Red+0x4>
     af6:	90 91 34 01 	lds	r25, 0x0134	; 0x800134 <Red+0x5>
     afa:	0e 94 30 05 	call	0xa60	; 0xa60 <_Z6setLED8LEDColor>
					delay(250);
     afe:	6a ef       	ldi	r22, 0xFA	; 250
     b00:	70 e0       	ldi	r23, 0x00	; 0
     b02:	80 e0       	ldi	r24, 0x00	; 0
     b04:	90 e0       	ldi	r25, 0x00	; 0
     b06:	0e 94 00 21 	call	0x4200	; 0x4200 <delay>
					ammoniaValue = ScanColor(AMMONIA) * 100;
     b0a:	80 e0       	ldi	r24, 0x00	; 0
     b0c:	0e 94 b0 03 	call	0x760	; 0x760 <_Z9ScanColor8ReadType>
     b10:	c6 9f       	mul	r28, r22
     b12:	90 01       	movw	r18, r0
     b14:	c7 9f       	mul	r28, r23
     b16:	30 0d       	add	r19, r0
     b18:	11 24       	eor	r1, r1
     b1a:	30 93 22 01 	sts	0x0122, r19	; 0x800122 <ammoniaValue+0x1>
     b1e:	20 93 21 01 	sts	0x0121, r18	; 0x800121 <ammoniaValue>
     b22:	25 c0       	rjmp	.+74     	; 0xb6e <_Z15TaskColorSensorPv+0xc6>
					delay(250);
					break;
				}
				case 'n':
				{
					while (findTestStrip(NITRITE));
     b24:	82 e0       	ldi	r24, 0x02	; 2
     b26:	0e 94 f1 03 	call	0x7e2	; 0x7e2 <_Z13findTestStrip8ReadType>
     b2a:	81 11       	cpse	r24, r1
     b2c:	fb cf       	rjmp	.-10     	; 0xb24 <_Z15TaskColorSensorPv+0x7c>
					setLED(Blue);
     b2e:	40 91 23 01 	lds	r20, 0x0123	; 0x800123 <Blue>
     b32:	50 91 24 01 	lds	r21, 0x0124	; 0x800124 <Blue+0x1>
     b36:	60 91 25 01 	lds	r22, 0x0125	; 0x800125 <Blue+0x2>
     b3a:	70 91 26 01 	lds	r23, 0x0126	; 0x800126 <Blue+0x3>
     b3e:	80 91 27 01 	lds	r24, 0x0127	; 0x800127 <Blue+0x4>
     b42:	90 91 28 01 	lds	r25, 0x0128	; 0x800128 <Blue+0x5>
     b46:	0e 94 30 05 	call	0xa60	; 0xa60 <_Z6setLED8LEDColor>
					delay(250);
     b4a:	6a ef       	ldi	r22, 0xFA	; 250
     b4c:	70 e0       	ldi	r23, 0x00	; 0
     b4e:	80 e0       	ldi	r24, 0x00	; 0
     b50:	90 e0       	ldi	r25, 0x00	; 0
     b52:	0e 94 00 21 	call	0x4200	; 0x4200 <delay>
					nitriteValue = ScanColor(NITRITE) * 100;
     b56:	82 e0       	ldi	r24, 0x02	; 2
     b58:	0e 94 b0 03 	call	0x760	; 0x760 <_Z9ScanColor8ReadType>
     b5c:	c6 9f       	mul	r28, r22
     b5e:	90 01       	movw	r18, r0
     b60:	c7 9f       	mul	r28, r23
     b62:	30 0d       	add	r19, r0
     b64:	11 24       	eor	r1, r1
     b66:	30 93 1e 01 	sts	0x011E, r19	; 0x80011e <nitriteValue+0x1>
     b6a:	20 93 1d 01 	sts	0x011D, r18	; 0x80011d <nitriteValue>
					delay(250);
     b6e:	6a ef       	ldi	r22, 0xFA	; 250
     b70:	70 e0       	ldi	r23, 0x00	; 0
     b72:	80 e0       	ldi	r24, 0x00	; 0
     b74:	90 e0       	ldi	r25, 0x00	; 0
     b76:	0e 94 00 21 	call	0x4200	; 0x4200 <delay>
					break;
     b7a:	39 c0       	rjmp	.+114    	; 0xbee <_Z15TaskColorSensorPv+0x146>
				}
				case 'N':
				{
					while (findTestStrip(NITRATE));
     b7c:	81 e0       	ldi	r24, 0x01	; 1
     b7e:	0e 94 f1 03 	call	0x7e2	; 0x7e2 <_Z13findTestStrip8ReadType>
     b82:	81 11       	cpse	r24, r1
     b84:	fb cf       	rjmp	.-10     	; 0xb7c <_Z15TaskColorSensorPv+0xd4>
					setLED(Green);
     b86:	40 91 29 01 	lds	r20, 0x0129	; 0x800129 <Green>
     b8a:	50 91 2a 01 	lds	r21, 0x012A	; 0x80012a <Green+0x1>
     b8e:	60 91 2b 01 	lds	r22, 0x012B	; 0x80012b <Green+0x2>
     b92:	70 91 2c 01 	lds	r23, 0x012C	; 0x80012c <Green+0x3>
     b96:	80 91 2d 01 	lds	r24, 0x012D	; 0x80012d <Green+0x4>
     b9a:	90 91 2e 01 	lds	r25, 0x012E	; 0x80012e <Green+0x5>
     b9e:	0e 94 30 05 	call	0xa60	; 0xa60 <_Z6setLED8LEDColor>
					delay(250); // allow user to see LED and stop moving test strip
     ba2:	6a ef       	ldi	r22, 0xFA	; 250
     ba4:	70 e0       	ldi	r23, 0x00	; 0
     ba6:	80 e0       	ldi	r24, 0x00	; 0
     ba8:	90 e0       	ldi	r25, 0x00	; 0
     baa:	0e 94 00 21 	call	0x4200	; 0x4200 <delay>
					nitrateValue = ScanColor(NITRATE) * 100;					
     bae:	81 e0       	ldi	r24, 0x01	; 1
     bb0:	0e 94 b0 03 	call	0x760	; 0x760 <_Z9ScanColor8ReadType>
     bb4:	c6 9f       	mul	r28, r22
     bb6:	90 01       	movw	r18, r0
     bb8:	c7 9f       	mul	r28, r23
     bba:	30 0d       	add	r19, r0
     bbc:	11 24       	eor	r1, r1
     bbe:	30 93 20 01 	sts	0x0120, r19	; 0x800120 <nitrateValue+0x1>
     bc2:	20 93 1f 01 	sts	0x011F, r18	; 0x80011f <nitrateValue>
					delay(250);
     bc6:	6a ef       	ldi	r22, 0xFA	; 250
     bc8:	70 e0       	ldi	r23, 0x00	; 0
     bca:	80 e0       	ldi	r24, 0x00	; 0
     bcc:	90 e0       	ldi	r25, 0x00	; 0
     bce:	0e 94 00 21 	call	0x4200	; 0x4200 <delay>
					setLED(Off);
     bd2:	40 91 cc 03 	lds	r20, 0x03CC	; 0x8003cc <Off>
     bd6:	50 91 cd 03 	lds	r21, 0x03CD	; 0x8003cd <Off+0x1>
     bda:	60 91 ce 03 	lds	r22, 0x03CE	; 0x8003ce <Off+0x2>
     bde:	70 91 cf 03 	lds	r23, 0x03CF	; 0x8003cf <Off+0x3>
     be2:	80 91 d0 03 	lds	r24, 0x03D0	; 0x8003d0 <Off+0x4>
     be6:	90 91 d1 03 	lds	r25, 0x03D1	; 0x8003d1 <Off+0x5>
     bea:	0e 94 30 05 	call	0xa60	; 0xa60 <_Z6setLED8LEDColor>
					break;
				}
			}
			setLED(Off);	  
     bee:	40 91 cc 03 	lds	r20, 0x03CC	; 0x8003cc <Off>
     bf2:	50 91 cd 03 	lds	r21, 0x03CD	; 0x8003cd <Off+0x1>
     bf6:	60 91 ce 03 	lds	r22, 0x03CE	; 0x8003ce <Off+0x2>
     bfa:	70 91 cf 03 	lds	r23, 0x03CF	; 0x8003cf <Off+0x3>
     bfe:	80 91 d0 03 	lds	r24, 0x03D0	; 0x8003d0 <Off+0x4>
     c02:	90 91 d1 03 	lds	r25, 0x03D1	; 0x8003d1 <Off+0x5>
     c06:	0e 94 30 05 	call	0xa60	; 0xa60 <_Z6setLED8LEDColor>
		}
		vTaskDelay(1); // 1 tick delay between reads for stability*/
     c0a:	81 e0       	ldi	r24, 0x01	; 1
     c0c:	90 e0       	ldi	r25, 0x00	; 0
     c0e:	0e 94 79 12 	call	0x24f2	; 0x24f2 <vTaskDelay>
void TaskColorSensor(void *pvParameters)
{
	(void) pvParameters;
  
	TickType_t xLastWakeTime = xTaskGetTickCount();
	for (;;) // A Task shall never return or exit.
     c12:	4d cf       	rjmp	.-358    	; 0xaae <_Z15TaskColorSensorPv+0x6>

00000c14 <_Z8setupLEDv>:
}

void setupLED()
{
	pinMode(R_LED, OUTPUT);
     c14:	61 e0       	ldi	r22, 0x01	; 1
     c16:	8f e0       	ldi	r24, 0x0F	; 15
     c18:	0e 94 27 22 	call	0x444e	; 0x444e <pinMode>
	pinMode(G_LED, OUTPUT);
     c1c:	61 e0       	ldi	r22, 0x01	; 1
     c1e:	80 e1       	ldi	r24, 0x10	; 16
     c20:	0e 94 27 22 	call	0x444e	; 0x444e <pinMode>
	pinMode(B_LED, OUTPUT);
     c24:	61 e0       	ldi	r22, 0x01	; 1
     c26:	81 e1       	ldi	r24, 0x11	; 17
     c28:	0e 94 27 22 	call	0x444e	; 0x444e <pinMode>
	setLED(Off);
     c2c:	40 91 cc 03 	lds	r20, 0x03CC	; 0x8003cc <Off>
     c30:	50 91 cd 03 	lds	r21, 0x03CD	; 0x8003cd <Off+0x1>
     c34:	60 91 ce 03 	lds	r22, 0x03CE	; 0x8003ce <Off+0x2>
     c38:	70 91 cf 03 	lds	r23, 0x03CF	; 0x8003cf <Off+0x3>
     c3c:	80 91 d0 03 	lds	r24, 0x03D0	; 0x8003d0 <Off+0x4>
     c40:	90 91 d1 03 	lds	r25, 0x03D1	; 0x8003d1 <Off+0x5>
     c44:	0c 94 30 05 	jmp	0xa60	; 0xa60 <_Z6setLED8LEDColor>

00000c48 <setup>:
TaskHandle_t xPHandTemperature;

SoftwareSerial serial(rxPin, txPin);

// the setup function runs once when you press reset or power the board
void setup() {  
     c48:	ef 92       	push	r14
     c4a:	ff 92       	push	r15
     c4c:	0f 93       	push	r16
	// initialize serial communication at 115200 bits per second:
	serial.begin(115200);
     c4e:	40 e0       	ldi	r20, 0x00	; 0
     c50:	52 ec       	ldi	r21, 0xC2	; 194
     c52:	61 e0       	ldi	r22, 0x01	; 1
     c54:	70 e0       	ldi	r23, 0x00	; 0
     c56:	81 ea       	ldi	r24, 0xA1	; 161
     c58:	93 e0       	ldi	r25, 0x03	; 3
     c5a:	0e 94 51 1a 	call	0x34a2	; 0x34a2 <_ZN14SoftwareSerial5beginEl>
	pinMode(wifiRst, OUTPUT);
     c5e:	61 e0       	ldi	r22, 0x01	; 1
     c60:	8a e0       	ldi	r24, 0x0A	; 10
     c62:	0e 94 27 22 	call	0x444e	; 0x444e <pinMode>
	pinMode(relay, OUTPUT);
     c66:	61 e0       	ldi	r22, 0x01	; 1
     c68:	84 e0       	ldi	r24, 0x04	; 4
     c6a:	0e 94 27 22 	call	0x444e	; 0x444e <pinMode>
	digitalWrite(relay, HIGH);
     c6e:	61 e0       	ldi	r22, 0x01	; 1
     c70:	84 e0       	ldi	r24, 0x04	; 4
     c72:	0e 94 63 22 	call	0x44c6	; 0x44c6 <digitalWrite>
  public:
    inline HardwareSerial(
      volatile uint8_t *ubrrh, volatile uint8_t *ubrrl,
      volatile uint8_t *ucsra, volatile uint8_t *ucsrb,
      volatile uint8_t *ucsrc, volatile uint8_t *udr);
    void begin(unsigned long baud) { begin(baud, SERIAL_8N1); }
     c76:	26 e0       	ldi	r18, 0x06	; 6
     c78:	40 e0       	ldi	r20, 0x00	; 0
     c7a:	52 ec       	ldi	r21, 0xC2	; 194
     c7c:	61 e0       	ldi	r22, 0x01	; 1
     c7e:	70 e0       	ldi	r23, 0x00	; 0
     c80:	89 e9       	ldi	r24, 0x99	; 153
     c82:	94 e0       	ldi	r25, 0x04	; 4
     c84:	0e 94 f4 1d 	call	0x3be8	; 0x3be8 <_ZN14HardwareSerial5beginEmh>
	while (!serial) {
		; // wait for serial port to connect. Needed for native USB, on LEONARDO, MICRO, YUN, and other 32u4 based boards.
	}
  
	// drive Wifi Enable pin High
	digitalWrite(wifiRst, HIGH);
     c88:	61 e0       	ldi	r22, 0x01	; 1
     c8a:	8a e0       	ldi	r24, 0x0A	; 10
     c8c:	0e 94 63 22 	call	0x44c6	; 0x44c6 <digitalWrite>
	// load test strip color data and initialize indicator LED
	setupCS();
     c90:	0e 94 b6 00 	call	0x16c	; 0x16c <_Z7setupCSv>
	setupLED();
     c94:	0e 94 0a 06 	call	0xc14	; 0xc14 <_Z8setupLEDv>
 
	// create interrupt to be triggered by Wifi module
	attachInterrupt(digitalPinToInterrupt(2), fromWifi, RISING);
     c98:	43 e0       	ldi	r20, 0x03	; 3
     c9a:	50 e0       	ldi	r21, 0x00	; 0
     c9c:	66 ea       	ldi	r22, 0xA6	; 166
     c9e:	76 e0       	ldi	r23, 0x06	; 6
     ca0:	80 e0       	ldi	r24, 0x00	; 0
     ca2:	0e 94 23 20 	call	0x4046	; 0x4046 <attachInterrupt>
	
	if (xSerialSemaphoreColorSensor == NULL)
     ca6:	80 91 c4 03 	lds	r24, 0x03C4	; 0x8003c4 <xSerialSemaphoreColorSensor>
     caa:	90 91 c5 03 	lds	r25, 0x03C5	; 0x8003c5 <xSerialSemaphoreColorSensor+0x1>
     cae:	89 2b       	or	r24, r25
     cb0:	f9 f4       	brne	.+62     	; 0xcf0 <setup+0xa8>
	{
		vSemaphoreCreateBinary(xSerialSemaphoreColorSensor);	
     cb2:	43 e0       	ldi	r20, 0x03	; 3
     cb4:	60 e0       	ldi	r22, 0x00	; 0
     cb6:	81 e0       	ldi	r24, 0x01	; 1
     cb8:	0e 94 b7 0c 	call	0x196e	; 0x196e <xQueueGenericCreate>
     cbc:	90 93 c5 03 	sts	0x03C5, r25	; 0x8003c5 <xSerialSemaphoreColorSensor+0x1>
     cc0:	80 93 c4 03 	sts	0x03C4, r24	; 0x8003c4 <xSerialSemaphoreColorSensor>
     cc4:	00 97       	sbiw	r24, 0x00	; 0
     cc6:	39 f0       	breq	.+14     	; 0xcd6 <setup+0x8e>
     cc8:	20 e0       	ldi	r18, 0x00	; 0
     cca:	40 e0       	ldi	r20, 0x00	; 0
     ccc:	50 e0       	ldi	r21, 0x00	; 0
     cce:	60 e0       	ldi	r22, 0x00	; 0
     cd0:	70 e0       	ldi	r23, 0x00	; 0
     cd2:	0e 94 df 0c 	call	0x19be	; 0x19be <xQueueGenericSend>
		if ( ( xSerialSemaphoreColorSensor ) != NULL ) {
     cd6:	80 91 c4 03 	lds	r24, 0x03C4	; 0x8003c4 <xSerialSemaphoreColorSensor>
     cda:	90 91 c5 03 	lds	r25, 0x03C5	; 0x8003c5 <xSerialSemaphoreColorSensor+0x1>
     cde:	00 97       	sbiw	r24, 0x00	; 0
     ce0:	39 f0       	breq	.+14     	; 0xcf0 <setup+0xa8>
			xSemaphoreGive( ( xSerialSemaphoreColorSensor ) ); }
     ce2:	20 e0       	ldi	r18, 0x00	; 0
     ce4:	40 e0       	ldi	r20, 0x00	; 0
     ce6:	50 e0       	ldi	r21, 0x00	; 0
     ce8:	60 e0       	ldi	r22, 0x00	; 0
     cea:	70 e0       	ldi	r23, 0x00	; 0
     cec:	0e 94 df 0c 	call	0x19be	; 0x19be <xQueueGenericSend>
	TaskColorSensor
	,  (const portCHAR *)"ColorSensor"
	,  128
	,  NULL
	,  2
	,  &xColorSensor ); 
     cf0:	82 ec       	ldi	r24, 0xC2	; 194
     cf2:	e8 2e       	mov	r14, r24
     cf4:	83 e0       	ldi	r24, 0x03	; 3
     cf6:	f8 2e       	mov	r15, r24
     cf8:	02 e0       	ldi	r16, 0x02	; 2
     cfa:	20 e0       	ldi	r18, 0x00	; 0
     cfc:	30 e0       	ldi	r19, 0x00	; 0
     cfe:	40 e8       	ldi	r20, 0x80	; 128
     d00:	50 e0       	ldi	r21, 0x00	; 0
     d02:	6a eb       	ldi	r22, 0xBA	; 186
     d04:	71 e0       	ldi	r23, 0x01	; 1
     d06:	84 e5       	ldi	r24, 0x54	; 84
     d08:	95 e0       	ldi	r25, 0x05	; 5
     d0a:	0e 94 dc 0f 	call	0x1fb8	; 0x1fb8 <xTaskCreate>
	TaskPHandTemperature
	,  (const portCHAR *) "PHandTemperature"
	,  128
	,  NULL
	,  2
	,  &xPHandTemperature );
     d0e:	90 ec       	ldi	r25, 0xC0	; 192
     d10:	e9 2e       	mov	r14, r25
     d12:	93 e0       	ldi	r25, 0x03	; 3
     d14:	f9 2e       	mov	r15, r25
     d16:	20 e0       	ldi	r18, 0x00	; 0
     d18:	30 e0       	ldi	r19, 0x00	; 0
     d1a:	40 e8       	ldi	r20, 0x80	; 128
     d1c:	50 e0       	ldi	r21, 0x00	; 0
     d1e:	66 ec       	ldi	r22, 0xC6	; 198
     d20:	71 e0       	ldi	r23, 0x01	; 1
     d22:	86 ed       	ldi	r24, 0xD6	; 214
     d24:	94 e0       	ldi	r25, 0x04	; 4
     d26:	0e 94 dc 0f 	call	0x1fb8	; 0x1fb8 <xTaskCreate>

	// Now the task scheduler, which takes over control of scheduling individual tasks, is automatically started.
	vTaskStartScheduler();
}
     d2a:	0f 91       	pop	r16
     d2c:	ff 90       	pop	r15
     d2e:	ef 90       	pop	r14
	,  NULL
	,  2
	,  &xPHandTemperature );

	// Now the task scheduler, which takes over control of scheduling individual tasks, is automatically started.
	vTaskStartScheduler();
     d30:	0c 94 e8 10 	jmp	0x21d0	; 0x21d0 <vTaskStartScheduler>

00000d34 <loop>:
}

void loop()
{
     d34:	08 95       	ret

00000d36 <_GLOBAL__sub_I_Red>:
SemaphoreHandle_t xSerialSemaphoreColorSensor;

TaskHandle_t xColorSensor;
TaskHandle_t xPHandTemperature;

SoftwareSerial serial(rxPin, txPin);
     d36:	20 e0       	ldi	r18, 0x00	; 0
     d38:	43 e0       	ldi	r20, 0x03	; 3
     d3a:	62 e0       	ldi	r22, 0x02	; 2
     d3c:	81 ea       	ldi	r24, 0xA1	; 161
     d3e:	93 e0       	ldi	r25, 0x03	; 3
     d40:	0c 94 26 1a 	jmp	0x344c	; 0x344c <_ZN14SoftwareSerialC1Ehhb>

00000d44 <_GLOBAL__sub_D_Red>:
     d44:	81 ea       	ldi	r24, 0xA1	; 161
     d46:	93 e0       	ldi	r25, 0x03	; 3
     d48:	0c 94 cd 19 	jmp	0x339a	; 0x339a <_ZN14SoftwareSerialD1Ev>

00000d4c <_Z8fromWifiv>:
  }
}


void fromWifi()
{
     d4c:	cf 93       	push	r28
	char action = '\0';
	// check for data from Wifi
	if (serial.available())
     d4e:	81 ea       	ldi	r24, 0xA1	; 161
     d50:	93 e0       	ldi	r25, 0x03	; 3
     d52:	0e 94 fc 18 	call	0x31f8	; 0x31f8 <_ZN14SoftwareSerial9availableEv>
     d56:	89 2b       	or	r24, r25
     d58:	99 f0       	breq	.+38     	; 0xd80 <_Z8fromWifiv+0x34>
	{
		delay(100); // allows all serial sent to be received together
     d5a:	64 e6       	ldi	r22, 0x64	; 100
     d5c:	70 e0       	ldi	r23, 0x00	; 0
     d5e:	80 e0       	ldi	r24, 0x00	; 0
     d60:	90 e0       	ldi	r25, 0x00	; 0
     d62:	0e 94 00 21 	call	0x4200	; 0x4200 <delay>
}


void fromWifi()
{
	char action = '\0';
     d66:	c0 e0       	ldi	r28, 0x00	; 0
	// check for data from Wifi
	if (serial.available())
	{
		delay(100); // allows all serial sent to be received together
		while (serial.available())
     d68:	81 ea       	ldi	r24, 0xA1	; 161
     d6a:	93 e0       	ldi	r25, 0x03	; 3
     d6c:	0e 94 fc 18 	call	0x31f8	; 0x31f8 <_ZN14SoftwareSerial9availableEv>
     d70:	89 2b       	or	r24, r25
     d72:	39 f0       	breq	.+14     	; 0xd82 <_Z8fromWifiv+0x36>
		{
			action = serial.read();
     d74:	81 ea       	ldi	r24, 0xA1	; 161
     d76:	93 e0       	ldi	r25, 0x03	; 3
     d78:	0e 94 72 18 	call	0x30e4	; 0x30e4 <_ZN14SoftwareSerial4readEv>
     d7c:	c8 2f       	mov	r28, r24
	char action = '\0';
	// check for data from Wifi
	if (serial.available())
	{
		delay(100); // allows all serial sent to be received together
		while (serial.available())
     d7e:	f4 cf       	rjmp	.-24     	; 0xd68 <_Z8fromWifiv+0x1c>
}


void fromWifi()
{
	char action = '\0';
     d80:	c0 e0       	ldi	r28, 0x00	; 0
		while (serial.available())
		{
			action = serial.read();
		}
	}
	Serial.println ("Action:");
     d82:	67 ed       	ldi	r22, 0xD7	; 215
     d84:	71 e0       	ldi	r23, 0x01	; 1
     d86:	89 e9       	ldi	r24, 0x99	; 153
     d88:	94 e0       	ldi	r25, 0x04	; 4
     d8a:	0e 94 52 1f 	call	0x3ea4	; 0x3ea4 <_ZN5Print7printlnEPKc>
	Serial.print(action);
     d8e:	6c 2f       	mov	r22, r28
     d90:	89 e9       	ldi	r24, 0x99	; 153
     d92:	94 e0       	ldi	r25, 0x04	; 4
     d94:	0e 94 47 1f 	call	0x3e8e	; 0x3e8e <_ZN5Print5printEc>

	static BaseType_t xHigherPriorityTaskWoken;
	xHigherPriorityTaskWoken = pdFALSE;
     d98:	10 92 a0 03 	sts	0x03A0, r1	; 0x8003a0 <_ZZ8fromWifivE24xHigherPriorityTaskWoken>

	switch(action)
     d9c:	ce 34       	cpi	r28, 0x4E	; 78
     d9e:	09 f4       	brne	.+2      	; 0xda2 <_Z8fromWifiv+0x56>
     da0:	74 c0       	rjmp	.+232    	; 0xe8a <_Z8fromWifiv+0x13e>
     da2:	e8 f5       	brcc	.+122    	; 0xe1e <_Z8fromWifiv+0xd2>
     da4:	c1 34       	cpi	r28, 0x41	; 65
     da6:	09 f4       	brne	.+2      	; 0xdaa <_Z8fromWifiv+0x5e>
     da8:	5c c0       	rjmp	.+184    	; 0xe62 <_Z8fromWifiv+0x116>
     daa:	c3 34       	cpi	r28, 0x43	; 67
     dac:	09 f0       	breq	.+2      	; 0xdb0 <_Z8fromWifiv+0x64>
     dae:	94 c0       	rjmp	.+296    	; 0xed8 <_Z8fromWifiv+0x18c>
		xSemaphoreGiveFromISR(xSerialSemaphoreColorSensor, &xHigherPriorityTaskWoken);
		break;
	}
	case 'C':
	{
		serial.write("ammonia:");
     db0:	6c e0       	ldi	r22, 0x0C	; 12
     db2:	72 e0       	ldi	r23, 0x02	; 2
     db4:	81 ea       	ldi	r24, 0xA1	; 161
     db6:	93 e0       	ldi	r25, 0x03	; 3
     db8:	0e 94 1b 05 	call	0xa36	; 0xa36 <_ZN5Print5writeEPKc>
		serial.print(ammoniaValue);
     dbc:	60 91 21 01 	lds	r22, 0x0121	; 0x800121 <ammoniaValue>
     dc0:	70 91 22 01 	lds	r23, 0x0122	; 0x800122 <ammoniaValue+0x1>
     dc4:	4a e0       	ldi	r20, 0x0A	; 10
     dc6:	50 e0       	ldi	r21, 0x00	; 0
     dc8:	81 ea       	ldi	r24, 0xA1	; 161
     dca:	93 e0       	ldi	r25, 0x03	; 3
     dcc:	0e 94 1b 20 	call	0x4036	; 0x4036 <_ZN5Print5printEii>
		serial.write("   nitrate:");
     dd0:	65 e1       	ldi	r22, 0x15	; 21
     dd2:	72 e0       	ldi	r23, 0x02	; 2
     dd4:	81 ea       	ldi	r24, 0xA1	; 161
     dd6:	93 e0       	ldi	r25, 0x03	; 3
     dd8:	0e 94 1b 05 	call	0xa36	; 0xa36 <_ZN5Print5writeEPKc>
		serial.print(nitrateValue);
     ddc:	60 91 1f 01 	lds	r22, 0x011F	; 0x80011f <nitrateValue>
     de0:	70 91 20 01 	lds	r23, 0x0120	; 0x800120 <nitrateValue+0x1>
     de4:	4a e0       	ldi	r20, 0x0A	; 10
     de6:	50 e0       	ldi	r21, 0x00	; 0
     de8:	81 ea       	ldi	r24, 0xA1	; 161
     dea:	93 e0       	ldi	r25, 0x03	; 3
     dec:	0e 94 1b 20 	call	0x4036	; 0x4036 <_ZN5Print5printEii>
		serial.write("   nitrite:");
     df0:	61 e2       	ldi	r22, 0x21	; 33
     df2:	72 e0       	ldi	r23, 0x02	; 2
     df4:	81 ea       	ldi	r24, 0xA1	; 161
     df6:	93 e0       	ldi	r25, 0x03	; 3
     df8:	0e 94 1b 05 	call	0xa36	; 0xa36 <_ZN5Print5writeEPKc>
		serial.print(nitriteValue);
     dfc:	60 91 1d 01 	lds	r22, 0x011D	; 0x80011d <nitriteValue>
     e00:	70 91 1e 01 	lds	r23, 0x011E	; 0x80011e <nitriteValue+0x1>
     e04:	4a e0       	ldi	r20, 0x0A	; 10
     e06:	50 e0       	ldi	r21, 0x00	; 0
     e08:	81 ea       	ldi	r24, 0xA1	; 161
     e0a:	93 e0       	ldi	r25, 0x03	; 3
     e0c:	0e 94 1b 20 	call	0x4036	; 0x4036 <_ZN5Print5printEii>
		serial.write("   ");
     e10:	6d e2       	ldi	r22, 0x2D	; 45
     e12:	72 e0       	ldi	r23, 0x02	; 2
     e14:	81 ea       	ldi	r24, 0xA1	; 161
     e16:	93 e0       	ldi	r25, 0x03	; 3
     e18:	0e 94 1b 05 	call	0xa36	; 0xa36 <_ZN5Print5writeEPKc>
		break;
     e1c:	5d c0       	rjmp	.+186    	; 0xed8 <_Z8fromWifiv+0x18c>
	Serial.print(action);

	static BaseType_t xHigherPriorityTaskWoken;
	xHigherPriorityTaskWoken = pdFALSE;

	switch(action)
     e1e:	c4 35       	cpi	r28, 0x54	; 84
     e20:	b9 f1       	breq	.+110    	; 0xe90 <_Z8fromWifiv+0x144>
     e22:	ce 36       	cpi	r28, 0x6E	; 110
     e24:	09 f1       	breq	.+66     	; 0xe68 <_Z8fromWifiv+0x11c>
     e26:	c0 35       	cpi	r28, 0x50	; 80
     e28:	09 f0       	breq	.+2      	; 0xe2c <_Z8fromWifiv+0xe0>
     e2a:	56 c0       	rjmp	.+172    	; 0xed8 <_Z8fromWifiv+0x18c>
		serial.write("   ");
		break;
	}
	case 'P':
	{
		Serial.println("inside ph");
     e2c:	61 e3       	ldi	r22, 0x31	; 49
     e2e:	72 e0       	ldi	r23, 0x02	; 2
     e30:	89 e9       	ldi	r24, 0x99	; 153
     e32:	94 e0       	ldi	r25, 0x04	; 4
     e34:	0e 94 52 1f 	call	0x3ea4	; 0x3ea4 <_ZN5Print7printlnEPKc>
		serial.write("ph:");
     e38:	6b e3       	ldi	r22, 0x3B	; 59
     e3a:	72 e0       	ldi	r23, 0x02	; 2
     e3c:	81 ea       	ldi	r24, 0xA1	; 161
     e3e:	93 e0       	ldi	r25, 0x03	; 3
     e40:	0e 94 1b 05 	call	0xa36	; 0xa36 <_ZN5Print5writeEPKc>
		serial.print(phValue);
     e44:	40 91 c8 03 	lds	r20, 0x03C8	; 0x8003c8 <phValue>
     e48:	50 91 c9 03 	lds	r21, 0x03C9	; 0x8003c9 <phValue+0x1>
     e4c:	60 91 ca 03 	lds	r22, 0x03CA	; 0x8003ca <phValue+0x2>
     e50:	70 91 cb 03 	lds	r23, 0x03CB	; 0x8003cb <phValue+0x3>
     e54:	2a e0       	ldi	r18, 0x0A	; 10
     e56:	30 e0       	ldi	r19, 0x00	; 0
     e58:	81 ea       	ldi	r24, 0xA1	; 161
     e5a:	93 e0       	ldi	r25, 0x03	; 3
     e5c:	0e 94 d3 1f 	call	0x3fa6	; 0x3fa6 <_ZN5Print5printEli>
		break;
     e60:	3b c0       	rjmp	.+118    	; 0xed8 <_Z8fromWifiv+0x18c>

	switch(action)
	{
	case 'A':
	{
		Serial.println("inside ammonia");
     e62:	6f ed       	ldi	r22, 0xDF	; 223
     e64:	71 e0       	ldi	r23, 0x01	; 1
     e66:	02 c0       	rjmp	.+4      	; 0xe6c <_Z8fromWifiv+0x120>
		xSemaphoreGiveFromISR(xSerialSemaphoreColorSensor, &xHigherPriorityTaskWoken);
		break;
	}
	case 'n':
	{
		Serial.println("inside nitrite");
     e68:	6e ee       	ldi	r22, 0xEE	; 238
     e6a:	71 e0       	ldi	r23, 0x01	; 1
     e6c:	89 e9       	ldi	r24, 0x99	; 153
     e6e:	94 e0       	ldi	r25, 0x04	; 4
     e70:	0e 94 52 1f 	call	0x3ea4	; 0x3ea4 <_ZN5Print7printlnEPKc>
		colorToRead = 'n';
     e74:	c0 93 1a 01 	sts	0x011A, r28	; 0x80011a <colorToRead>
		xSemaphoreGiveFromISR(xSerialSemaphoreColorSensor, &xHigherPriorityTaskWoken);
     e78:	60 ea       	ldi	r22, 0xA0	; 160
     e7a:	73 e0       	ldi	r23, 0x03	; 3
     e7c:	80 91 c4 03 	lds	r24, 0x03C4	; 0x8003c4 <xSerialSemaphoreColorSensor>
     e80:	90 91 c5 03 	lds	r25, 0x03C5	; 0x8003c5 <xSerialSemaphoreColorSensor+0x1>
     e84:	0e 94 a4 0d 	call	0x1b48	; 0x1b48 <xQueueGiveFromISR>
		break;
     e88:	27 c0       	rjmp	.+78     	; 0xed8 <_Z8fromWifiv+0x18c>
	}
	case 'N':
	{
		Serial.println("inside nitrate");
     e8a:	6d ef       	ldi	r22, 0xFD	; 253
     e8c:	71 e0       	ldi	r23, 0x01	; 1
     e8e:	ee cf       	rjmp	.-36     	; 0xe6c <_Z8fromWifiv+0x120>
		serial.print(phValue);
		break;
	}
	case 'T':
	{
		setLED(Green);
     e90:	40 91 29 01 	lds	r20, 0x0129	; 0x800129 <Green>
     e94:	50 91 2a 01 	lds	r21, 0x012A	; 0x80012a <Green+0x1>
     e98:	60 91 2b 01 	lds	r22, 0x012B	; 0x80012b <Green+0x2>
     e9c:	70 91 2c 01 	lds	r23, 0x012C	; 0x80012c <Green+0x3>
     ea0:	80 91 2d 01 	lds	r24, 0x012D	; 0x80012d <Green+0x4>
     ea4:	90 91 2e 01 	lds	r25, 0x012E	; 0x80012e <Green+0x5>
     ea8:	0e 94 30 05 	call	0xa60	; 0xa60 <_Z6setLED8LEDColor>
		Serial.println("inside temp");
     eac:	6f e3       	ldi	r22, 0x3F	; 63
     eae:	72 e0       	ldi	r23, 0x02	; 2
     eb0:	89 e9       	ldi	r24, 0x99	; 153
     eb2:	94 e0       	ldi	r25, 0x04	; 4
     eb4:	0e 94 52 1f 	call	0x3ea4	; 0x3ea4 <_ZN5Print7printlnEPKc>
		serial.write("temp:");
     eb8:	6b e4       	ldi	r22, 0x4B	; 75
     eba:	72 e0       	ldi	r23, 0x02	; 2
     ebc:	81 ea       	ldi	r24, 0xA1	; 161
     ebe:	93 e0       	ldi	r25, 0x03	; 3
     ec0:	0e 94 1b 05 	call	0xa36	; 0xa36 <_ZN5Print5writeEPKc>
		serial.print(tempValue);
     ec4:	60 91 c6 03 	lds	r22, 0x03C6	; 0x8003c6 <tempValue>
     ec8:	70 91 c7 03 	lds	r23, 0x03C7	; 0x8003c7 <tempValue+0x1>
     ecc:	4a e0       	ldi	r20, 0x0A	; 10
     ece:	50 e0       	ldi	r21, 0x00	; 0
     ed0:	81 ea       	ldi	r24, 0xA1	; 161
     ed2:	93 e0       	ldi	r25, 0x03	; 3
     ed4:	0e 94 1b 20 	call	0x4036	; 0x4036 <_ZN5Print5printEii>
		break;
	}
	default:
		break;
	}
	delay(500);
     ed8:	64 ef       	ldi	r22, 0xF4	; 244
     eda:	71 e0       	ldi	r23, 0x01	; 1
     edc:	80 e0       	ldi	r24, 0x00	; 0
     ede:	90 e0       	ldi	r25, 0x00	; 0
     ee0:	0e 94 00 21 	call	0x4200	; 0x4200 <delay>
	setLED(Off);
     ee4:	40 91 cc 03 	lds	r20, 0x03CC	; 0x8003cc <Off>
     ee8:	50 91 cd 03 	lds	r21, 0x03CD	; 0x8003cd <Off+0x1>
     eec:	60 91 ce 03 	lds	r22, 0x03CE	; 0x8003ce <Off+0x2>
     ef0:	70 91 cf 03 	lds	r23, 0x03CF	; 0x8003cf <Off+0x3>
     ef4:	80 91 d0 03 	lds	r24, 0x03D0	; 0x8003d0 <Off+0x4>
     ef8:	90 91 d1 03 	lds	r25, 0x03D1	; 0x8003d1 <Off+0x5>
}
     efc:	cf 91       	pop	r28
	}
	default:
		break;
	}
	delay(500);
	setLED(Off);
     efe:	0c 94 30 05 	jmp	0xa60	; 0xa60 <_Z6setLED8LEDColor>

00000f02 <_ZN7OneWire5resetEv>:
   ROM_NO[0] = family_code;
   for (uint8_t i = 1; i < 8; i++)
      ROM_NO[i] = 0;
   LastDiscrepancy = 64;
   LastFamilyDiscrepancy = 0;
   LastDeviceFlag = false;
     f02:	ff 92       	push	r15
     f04:	0f 93       	push	r16
     f06:	1f 93       	push	r17
     f08:	cf 93       	push	r28
     f0a:	df 93       	push	r29
     f0c:	fc 01       	movw	r30, r24
     f0e:	f0 80       	ld	r15, Z
     f10:	c1 81       	ldd	r28, Z+1	; 0x01
     f12:	d2 81       	ldd	r29, Z+2	; 0x02
     f14:	f8 94       	cli
     f16:	89 81       	ldd	r24, Y+1	; 0x01
     f18:	0f 2d       	mov	r16, r15
     f1a:	00 95       	com	r16
     f1c:	80 23       	and	r24, r16
     f1e:	89 83       	std	Y+1, r24	; 0x01
     f20:	78 94       	sei
     f22:	1d e7       	ldi	r17, 0x7D	; 125
     f24:	11 50       	subi	r17, 0x01	; 1
     f26:	29 f1       	breq	.+74     	; 0xf72 <_ZN7OneWire5resetEv+0x70>
     f28:	82 e0       	ldi	r24, 0x02	; 2
     f2a:	90 e0       	ldi	r25, 0x00	; 0
     f2c:	0e 94 3c 21 	call	0x4278	; 0x4278 <delayMicroseconds>
     f30:	88 81       	ld	r24, Y
     f32:	8f 21       	and	r24, r15
     f34:	b9 f3       	breq	.-18     	; 0xf24 <_ZN7OneWire5resetEv+0x22>
     f36:	f8 94       	cli
     f38:	8a 81       	ldd	r24, Y+2	; 0x02
     f3a:	80 23       	and	r24, r16
     f3c:	8a 83       	std	Y+2, r24	; 0x02
     f3e:	89 81       	ldd	r24, Y+1	; 0x01
     f40:	8f 29       	or	r24, r15
     f42:	89 83       	std	Y+1, r24	; 0x01
     f44:	78 94       	sei
     f46:	80 ee       	ldi	r24, 0xE0	; 224
     f48:	91 e0       	ldi	r25, 0x01	; 1
     f4a:	0e 94 3c 21 	call	0x4278	; 0x4278 <delayMicroseconds>
     f4e:	f8 94       	cli
     f50:	89 81       	ldd	r24, Y+1	; 0x01
     f52:	08 23       	and	r16, r24
     f54:	09 83       	std	Y+1, r16	; 0x01
     f56:	86 e4       	ldi	r24, 0x46	; 70
     f58:	90 e0       	ldi	r25, 0x00	; 0
     f5a:	0e 94 3c 21 	call	0x4278	; 0x4278 <delayMicroseconds>
     f5e:	88 81       	ld	r24, Y
     f60:	f8 22       	and	r15, r24
     f62:	11 e0       	ldi	r17, 0x01	; 1
     f64:	09 f0       	breq	.+2      	; 0xf68 <_ZN7OneWire5resetEv+0x66>
     f66:	10 e0       	ldi	r17, 0x00	; 0
     f68:	78 94       	sei
     f6a:	8a e9       	ldi	r24, 0x9A	; 154
     f6c:	91 e0       	ldi	r25, 0x01	; 1
     f6e:	0e 94 3c 21 	call	0x4278	; 0x4278 <delayMicroseconds>
     f72:	81 2f       	mov	r24, r17
     f74:	df 91       	pop	r29
     f76:	cf 91       	pop	r28
     f78:	1f 91       	pop	r17
     f7a:	0f 91       	pop	r16
     f7c:	ff 90       	pop	r15
     f7e:	08 95       	ret

00000f80 <_ZN7OneWire9write_bitEh>:
     f80:	1f 93       	push	r17
     f82:	cf 93       	push	r28
     f84:	df 93       	push	r29
     f86:	fc 01       	movw	r30, r24
     f88:	10 81       	ld	r17, Z
     f8a:	c1 81       	ldd	r28, Z+1	; 0x01
     f8c:	d2 81       	ldd	r29, Z+2	; 0x02
     f8e:	81 2f       	mov	r24, r17
     f90:	80 95       	com	r24
     f92:	60 ff       	sbrs	r22, 0
     f94:	12 c0       	rjmp	.+36     	; 0xfba <_ZN7OneWire9write_bitEh+0x3a>
     f96:	f8 94       	cli
     f98:	9a 81       	ldd	r25, Y+2	; 0x02
     f9a:	89 23       	and	r24, r25
     f9c:	8a 83       	std	Y+2, r24	; 0x02
     f9e:	89 81       	ldd	r24, Y+1	; 0x01
     fa0:	81 2b       	or	r24, r17
     fa2:	89 83       	std	Y+1, r24	; 0x01
     fa4:	8a e0       	ldi	r24, 0x0A	; 10
     fa6:	90 e0       	ldi	r25, 0x00	; 0
     fa8:	0e 94 3c 21 	call	0x4278	; 0x4278 <delayMicroseconds>
     fac:	8a 81       	ldd	r24, Y+2	; 0x02
     fae:	18 2b       	or	r17, r24
     fb0:	1a 83       	std	Y+2, r17	; 0x02
     fb2:	78 94       	sei
     fb4:	87 e3       	ldi	r24, 0x37	; 55
     fb6:	90 e0       	ldi	r25, 0x00	; 0
     fb8:	11 c0       	rjmp	.+34     	; 0xfdc <_ZN7OneWire9write_bitEh+0x5c>
     fba:	f8 94       	cli
     fbc:	9a 81       	ldd	r25, Y+2	; 0x02
     fbe:	89 23       	and	r24, r25
     fc0:	8a 83       	std	Y+2, r24	; 0x02
     fc2:	89 81       	ldd	r24, Y+1	; 0x01
     fc4:	81 2b       	or	r24, r17
     fc6:	89 83       	std	Y+1, r24	; 0x01
     fc8:	81 e4       	ldi	r24, 0x41	; 65
     fca:	90 e0       	ldi	r25, 0x00	; 0
     fcc:	0e 94 3c 21 	call	0x4278	; 0x4278 <delayMicroseconds>
     fd0:	8a 81       	ldd	r24, Y+2	; 0x02
     fd2:	18 2b       	or	r17, r24
     fd4:	1a 83       	std	Y+2, r17	; 0x02
     fd6:	78 94       	sei
     fd8:	85 e0       	ldi	r24, 0x05	; 5
     fda:	90 e0       	ldi	r25, 0x00	; 0
     fdc:	df 91       	pop	r29
     fde:	cf 91       	pop	r28
     fe0:	1f 91       	pop	r17
     fe2:	0c 94 3c 21 	jmp	0x4278	; 0x4278 <delayMicroseconds>

00000fe6 <_ZN7OneWire8read_bitEv>:
     fe6:	0f 93       	push	r16
     fe8:	1f 93       	push	r17
     fea:	cf 93       	push	r28
     fec:	df 93       	push	r29
     fee:	fc 01       	movw	r30, r24
     ff0:	00 81       	ld	r16, Z
     ff2:	c1 81       	ldd	r28, Z+1	; 0x01
     ff4:	d2 81       	ldd	r29, Z+2	; 0x02
     ff6:	f8 94       	cli
     ff8:	89 81       	ldd	r24, Y+1	; 0x01
     ffa:	80 2b       	or	r24, r16
     ffc:	89 83       	std	Y+1, r24	; 0x01
     ffe:	8a 81       	ldd	r24, Y+2	; 0x02
    1000:	10 2f       	mov	r17, r16
    1002:	10 95       	com	r17
    1004:	81 23       	and	r24, r17
    1006:	8a 83       	std	Y+2, r24	; 0x02
    1008:	83 e0       	ldi	r24, 0x03	; 3
    100a:	90 e0       	ldi	r25, 0x00	; 0
    100c:	0e 94 3c 21 	call	0x4278	; 0x4278 <delayMicroseconds>
    1010:	89 81       	ldd	r24, Y+1	; 0x01
    1012:	18 23       	and	r17, r24
    1014:	19 83       	std	Y+1, r17	; 0x01
    1016:	8a e0       	ldi	r24, 0x0A	; 10
    1018:	90 e0       	ldi	r25, 0x00	; 0
    101a:	0e 94 3c 21 	call	0x4278	; 0x4278 <delayMicroseconds>
    101e:	c8 81       	ld	r28, Y
    1020:	78 94       	sei
    1022:	85 e3       	ldi	r24, 0x35	; 53
    1024:	90 e0       	ldi	r25, 0x00	; 0
    1026:	0e 94 3c 21 	call	0x4278	; 0x4278 <delayMicroseconds>
    102a:	c0 23       	and	r28, r16
    102c:	81 e0       	ldi	r24, 0x01	; 1
    102e:	09 f4       	brne	.+2      	; 0x1032 <_ZN7OneWire8read_bitEv+0x4c>
    1030:	80 e0       	ldi	r24, 0x00	; 0
    1032:	df 91       	pop	r29
    1034:	cf 91       	pop	r28
    1036:	1f 91       	pop	r17
    1038:	0f 91       	pop	r16
    103a:	08 95       	ret

0000103c <_ZN7OneWire5writeEhh>:
    103c:	df 92       	push	r13
    103e:	ef 92       	push	r14
    1040:	ff 92       	push	r15
    1042:	0f 93       	push	r16
    1044:	1f 93       	push	r17
    1046:	cf 93       	push	r28
    1048:	df 93       	push	r29
    104a:	ec 01       	movw	r28, r24
    104c:	d6 2e       	mov	r13, r22
    104e:	e4 2e       	mov	r14, r20
    1050:	08 e0       	ldi	r16, 0x08	; 8
    1052:	10 e0       	ldi	r17, 0x00	; 0
    1054:	ff 24       	eor	r15, r15
    1056:	f3 94       	inc	r15
    1058:	61 e0       	ldi	r22, 0x01	; 1
    105a:	8d 2d       	mov	r24, r13
    105c:	8f 21       	and	r24, r15
    105e:	09 f4       	brne	.+2      	; 0x1062 <_ZN7OneWire5writeEhh+0x26>
    1060:	60 e0       	ldi	r22, 0x00	; 0
    1062:	ce 01       	movw	r24, r28
    1064:	0e 94 c0 07 	call	0xf80	; 0xf80 <_ZN7OneWire9write_bitEh>
    1068:	ff 0c       	add	r15, r15
    106a:	01 50       	subi	r16, 0x01	; 1
    106c:	11 09       	sbc	r17, r1
    106e:	a1 f7       	brne	.-24     	; 0x1058 <_ZN7OneWire5writeEhh+0x1c>
    1070:	e1 10       	cpse	r14, r1
    1072:	10 c0       	rjmp	.+32     	; 0x1094 <_ZN7OneWire5writeEhh+0x58>
    1074:	f8 94       	cli
    1076:	e9 81       	ldd	r30, Y+1	; 0x01
    1078:	fa 81       	ldd	r31, Y+2	; 0x02
    107a:	91 81       	ldd	r25, Z+1	; 0x01
    107c:	88 81       	ld	r24, Y
    107e:	80 95       	com	r24
    1080:	89 23       	and	r24, r25
    1082:	81 83       	std	Z+1, r24	; 0x01
    1084:	e9 81       	ldd	r30, Y+1	; 0x01
    1086:	fa 81       	ldd	r31, Y+2	; 0x02
    1088:	92 81       	ldd	r25, Z+2	; 0x02
    108a:	88 81       	ld	r24, Y
    108c:	80 95       	com	r24
    108e:	89 23       	and	r24, r25
    1090:	82 83       	std	Z+2, r24	; 0x02
    1092:	78 94       	sei
    1094:	df 91       	pop	r29
    1096:	cf 91       	pop	r28
    1098:	1f 91       	pop	r17
    109a:	0f 91       	pop	r16
    109c:	ff 90       	pop	r15
    109e:	ef 90       	pop	r14
    10a0:	df 90       	pop	r13
    10a2:	08 95       	ret

000010a4 <_ZN7OneWire4readEv>:
    10a4:	ef 92       	push	r14
    10a6:	ff 92       	push	r15
    10a8:	0f 93       	push	r16
    10aa:	1f 93       	push	r17
    10ac:	cf 93       	push	r28
    10ae:	df 93       	push	r29
    10b0:	7c 01       	movw	r14, r24
    10b2:	08 e0       	ldi	r16, 0x08	; 8
    10b4:	10 e0       	ldi	r17, 0x00	; 0
    10b6:	c0 e0       	ldi	r28, 0x00	; 0
    10b8:	d1 e0       	ldi	r29, 0x01	; 1
    10ba:	c7 01       	movw	r24, r14
    10bc:	0e 94 f3 07 	call	0xfe6	; 0xfe6 <_ZN7OneWire8read_bitEv>
    10c0:	81 11       	cpse	r24, r1
    10c2:	cd 2b       	or	r28, r29
    10c4:	dd 0f       	add	r29, r29
    10c6:	01 50       	subi	r16, 0x01	; 1
    10c8:	11 09       	sbc	r17, r1
    10ca:	b9 f7       	brne	.-18     	; 0x10ba <_ZN7OneWire4readEv+0x16>
    10cc:	8c 2f       	mov	r24, r28
    10ce:	df 91       	pop	r29
    10d0:	cf 91       	pop	r28
    10d2:	1f 91       	pop	r17
    10d4:	0f 91       	pop	r16
    10d6:	ff 90       	pop	r15
    10d8:	ef 90       	pop	r14
    10da:	08 95       	ret

000010dc <_ZN7OneWire6selectEPKh>:
    10dc:	ef 92       	push	r14
    10de:	ff 92       	push	r15
    10e0:	0f 93       	push	r16
    10e2:	1f 93       	push	r17
    10e4:	cf 93       	push	r28
    10e6:	df 93       	push	r29
    10e8:	8c 01       	movw	r16, r24
    10ea:	7b 01       	movw	r14, r22
    10ec:	40 e0       	ldi	r20, 0x00	; 0
    10ee:	65 e5       	ldi	r22, 0x55	; 85
    10f0:	0e 94 1e 08 	call	0x103c	; 0x103c <_ZN7OneWire5writeEhh>
    10f4:	e7 01       	movw	r28, r14
    10f6:	88 e0       	ldi	r24, 0x08	; 8
    10f8:	e8 0e       	add	r14, r24
    10fa:	f1 1c       	adc	r15, r1
    10fc:	69 91       	ld	r22, Y+
    10fe:	40 e0       	ldi	r20, 0x00	; 0
    1100:	c8 01       	movw	r24, r16
    1102:	0e 94 1e 08 	call	0x103c	; 0x103c <_ZN7OneWire5writeEhh>
    1106:	ce 15       	cp	r28, r14
    1108:	df 05       	cpc	r29, r15
    110a:	c1 f7       	brne	.-16     	; 0x10fc <_ZN7OneWire6selectEPKh+0x20>
    110c:	df 91       	pop	r29
    110e:	cf 91       	pop	r28
    1110:	1f 91       	pop	r17
    1112:	0f 91       	pop	r16
    1114:	ff 90       	pop	r15
    1116:	ef 90       	pop	r14
    1118:	08 95       	ret

0000111a <_ZN7OneWire12reset_searchEv>:
    111a:	fc 01       	movw	r30, r24
    111c:	13 86       	std	Z+11, r1	; 0x0b
    111e:	15 86       	std	Z+13, r1	; 0x0d
    1120:	14 86       	std	Z+12, r1	; 0x0c
    1122:	dc 01       	movw	r26, r24
    1124:	1b 96       	adiw	r26, 0x0b	; 11
    1126:	33 96       	adiw	r30, 0x03	; 3
    1128:	1e 92       	st	-X, r1
    112a:	ae 17       	cp	r26, r30
    112c:	bf 07       	cpc	r27, r31
    112e:	e1 f7       	brne	.-8      	; 0x1128 <_ZN7OneWire12reset_searchEv+0xe>
    1130:	08 95       	ret

00001132 <_ZN7OneWire5beginEh>:
    1132:	1f 93       	push	r17
    1134:	cf 93       	push	r28
    1136:	df 93       	push	r29
    1138:	ec 01       	movw	r28, r24
    113a:	16 2f       	mov	r17, r22
    113c:	60 e0       	ldi	r22, 0x00	; 0
    113e:	81 2f       	mov	r24, r17
    1140:	0e 94 27 22 	call	0x444e	; 0x444e <pinMode>
    1144:	61 2f       	mov	r22, r17
    1146:	70 e0       	ldi	r23, 0x00	; 0
    1148:	fb 01       	movw	r30, r22
    114a:	ea 53       	subi	r30, 0x3A	; 58
    114c:	ff 4f       	sbci	r31, 0xFF	; 255
    114e:	e4 91       	lpm	r30, Z
    1150:	e8 83       	st	Y, r30
    1152:	fb 01       	movw	r30, r22
    1154:	e6 52       	subi	r30, 0x26	; 38
    1156:	ff 4f       	sbci	r31, 0xFF	; 255
    1158:	e4 91       	lpm	r30, Z
    115a:	f0 e0       	ldi	r31, 0x00	; 0
    115c:	ee 0f       	add	r30, r30
    115e:	ff 1f       	adc	r31, r31
    1160:	e2 51       	subi	r30, 0x12	; 18
    1162:	ff 4f       	sbci	r31, 0xFF	; 255
    1164:	85 91       	lpm	r24, Z+
    1166:	94 91       	lpm	r25, Z
    1168:	9a 83       	std	Y+2, r25	; 0x02
    116a:	89 83       	std	Y+1, r24	; 0x01
    116c:	ce 01       	movw	r24, r28
    116e:	df 91       	pop	r29
    1170:	cf 91       	pop	r28
    1172:	1f 91       	pop	r17
    1174:	0c 94 8d 08 	jmp	0x111a	; 0x111a <_ZN7OneWire12reset_searchEv>

00001178 <_ZN7OneWire6searchEPhb>:
// search state.
// Return TRUE  : device found, ROM number in ROM_NO buffer
//        FALSE : device not found, end of search
//
bool OneWire::search(uint8_t *newAddr, bool search_mode /* = true */)
{
    1178:	bf 92       	push	r11
    117a:	cf 92       	push	r12
    117c:	df 92       	push	r13
    117e:	ef 92       	push	r14
    1180:	ff 92       	push	r15
    1182:	0f 93       	push	r16
    1184:	1f 93       	push	r17
    1186:	cf 93       	push	r28
    1188:	df 93       	push	r29
    118a:	ec 01       	movw	r28, r24
    118c:	6b 01       	movw	r12, r22
    118e:	14 2f       	mov	r17, r20
   rom_byte_number = 0;
   rom_byte_mask = 1;
   search_result = false;

   // if the last call was not the last one
   if (!LastDeviceFlag) {
    1190:	8d 85       	ldd	r24, Y+13	; 0x0d
    1192:	81 11       	cpse	r24, r1
    1194:	05 c0       	rjmp	.+10     	; 0x11a0 <_ZN7OneWire6searchEPhb+0x28>
      // 1-Wire reset
      if (!reset()) {
    1196:	ce 01       	movw	r24, r28
    1198:	0e 94 81 07 	call	0xf02	; 0xf02 <_ZN7OneWire5resetEv>
    119c:	81 11       	cpse	r24, r1
    119e:	05 c0       	rjmp	.+10     	; 0x11aa <_ZN7OneWire6searchEPhb+0x32>
         // reset the search
         LastDiscrepancy = 0;
    11a0:	1b 86       	std	Y+11, r1	; 0x0b
         LastDeviceFlag = false;
    11a2:	1d 86       	std	Y+13, r1	; 0x0d
         LastFamilyDiscrepancy = 0;
    11a4:	1c 86       	std	Y+12, r1	; 0x0c
         return false;
    11a6:	80 e0       	ldi	r24, 0x00	; 0
    11a8:	64 c0       	rjmp	.+200    	; 0x1272 <_ZN7OneWire6searchEPhb+0xfa>
      }

      // issue the search command
      if (search_mode == true) {
        write(0xF0);   // NORMAL SEARCH
    11aa:	40 e0       	ldi	r20, 0x00	; 0
         LastFamilyDiscrepancy = 0;
         return false;
      }

      // issue the search command
      if (search_mode == true) {
    11ac:	11 23       	and	r17, r17
    11ae:	11 f0       	breq	.+4      	; 0x11b4 <_ZN7OneWire6searchEPhb+0x3c>
        write(0xF0);   // NORMAL SEARCH
    11b0:	60 ef       	ldi	r22, 0xF0	; 240
    11b2:	01 c0       	rjmp	.+2      	; 0x11b6 <_ZN7OneWire6searchEPhb+0x3e>
      } else {
        write(0xEC);   // CONDITIONAL SEARCH
    11b4:	6c ee       	ldi	r22, 0xEC	; 236
    11b6:	ce 01       	movw	r24, r28
    11b8:	0e 94 1e 08 	call	0x103c	; 0x103c <_ZN7OneWire5writeEhh>
// search state.
// Return TRUE  : device found, ROM number in ROM_NO buffer
//        FALSE : device not found, end of search
//
bool OneWire::search(uint8_t *newAddr, bool search_mode /* = true */)
{
    11bc:	01 e0       	ldi	r16, 0x01	; 1
    11be:	e1 2c       	mov	r14, r1
    11c0:	b1 2c       	mov	r11, r1
    11c2:	11 e0       	ldi	r17, 0x01	; 1

      // loop to do the search
      do
      {
         // read a bit and its complement
         id_bit = read_bit();
    11c4:	ce 01       	movw	r24, r28
    11c6:	0e 94 f3 07 	call	0xfe6	; 0xfe6 <_ZN7OneWire8read_bitEv>
    11ca:	f8 2e       	mov	r15, r24
         cmp_id_bit = read_bit();
    11cc:	ce 01       	movw	r24, r28
    11ce:	0e 94 f3 07 	call	0xfe6	; 0xfe6 <_ZN7OneWire8read_bitEv>

         // check for no devices on 1-wire
         if ((id_bit == 1) && (cmp_id_bit == 1)) {
    11d2:	91 e0       	ldi	r25, 0x01	; 1
    11d4:	f9 12       	cpse	r15, r25
    11d6:	03 c0       	rjmp	.+6      	; 0x11de <_ZN7OneWire6searchEPhb+0x66>
    11d8:	81 30       	cpi	r24, 0x01	; 1
    11da:	b1 f4       	brne	.+44     	; 0x1208 <_ZN7OneWire6searchEPhb+0x90>
    11dc:	34 c0       	rjmp	.+104    	; 0x1246 <_ZN7OneWire6searchEPhb+0xce>
    11de:	2e 2d       	mov	r18, r14
    11e0:	30 e0       	ldi	r19, 0x00	; 0
            break;
         } else {
            // all devices coupled have 0 or 1
            if (id_bit != cmp_id_bit) {
    11e2:	f8 12       	cpse	r15, r24
    11e4:	1b c0       	rjmp	.+54     	; 0x121c <_ZN7OneWire6searchEPhb+0xa4>
               search_direction = id_bit;  // bit write value for search
            } else {
               // if this discrepancy if before the Last Discrepancy
               // on a previous next then pick the same as last time
               if (id_bit_number < LastDiscrepancy) {
    11e6:	8b 85       	ldd	r24, Y+11	; 0x0b
    11e8:	18 17       	cp	r17, r24
    11ea:	38 f4       	brcc	.+14     	; 0x11fa <_ZN7OneWire6searchEPhb+0x82>
                  search_direction = ((ROM_NO[rom_byte_number] & rom_byte_mask) > 0);
    11ec:	fe 01       	movw	r30, r28
    11ee:	e2 0f       	add	r30, r18
    11f0:	f3 1f       	adc	r31, r19
    11f2:	83 81       	ldd	r24, Z+3	; 0x03
    11f4:	80 23       	and	r24, r16
    11f6:	41 f4       	brne	.+16     	; 0x1208 <_ZN7OneWire6searchEPhb+0x90>
    11f8:	02 c0       	rjmp	.+4      	; 0x11fe <_ZN7OneWire6searchEPhb+0x86>
               } else {
                  // if equal to last pick 1, if not then pick 0
                  search_direction = (id_bit_number == LastDiscrepancy);
    11fa:	18 17       	cp	r17, r24
    11fc:	29 f0       	breq	.+10     	; 0x1208 <_ZN7OneWire6searchEPhb+0x90>
    11fe:	f1 2c       	mov	r15, r1
               // if 0 was picked then record its position in LastZero
               if (search_direction == 0) {
                  last_zero = id_bit_number;

                  // check for Last discrepancy in family
                  if (last_zero < 9)
    1200:	19 30       	cpi	r17, 0x09	; 9
    1202:	58 f4       	brcc	.+22     	; 0x121a <_ZN7OneWire6searchEPhb+0xa2>
                     LastFamilyDiscrepancy = last_zero;
    1204:	1c 87       	std	Y+12, r17	; 0x0c
    1206:	09 c0       	rjmp	.+18     	; 0x121a <_ZN7OneWire6searchEPhb+0xa2>
            }

            // set or clear the bit in the ROM byte rom_byte_number
            // with mask rom_byte_mask
            if (search_direction == 1)
              ROM_NO[rom_byte_number] |= rom_byte_mask;
    1208:	fe 01       	movw	r30, r28
    120a:	ee 0d       	add	r30, r14
    120c:	f1 1d       	adc	r31, r1
    120e:	83 81       	ldd	r24, Z+3	; 0x03
    1210:	80 2b       	or	r24, r16
    1212:	83 83       	std	Z+3, r24	; 0x03
    1214:	ff 24       	eor	r15, r15
    1216:	f3 94       	inc	r15
    1218:	09 c0       	rjmp	.+18     	; 0x122c <_ZN7OneWire6searchEPhb+0xb4>
// search state.
// Return TRUE  : device found, ROM number in ROM_NO buffer
//        FALSE : device not found, end of search
//
bool OneWire::search(uint8_t *newAddr, bool search_mode /* = true */)
{
    121a:	b1 2e       	mov	r11, r17
            // set or clear the bit in the ROM byte rom_byte_number
            // with mask rom_byte_mask
            if (search_direction == 1)
              ROM_NO[rom_byte_number] |= rom_byte_mask;
            else
              ROM_NO[rom_byte_number] &= ~rom_byte_mask;
    121c:	fe 01       	movw	r30, r28
    121e:	e2 0f       	add	r30, r18
    1220:	f3 1f       	adc	r31, r19
    1222:	93 81       	ldd	r25, Z+3	; 0x03
    1224:	80 2f       	mov	r24, r16
    1226:	80 95       	com	r24
    1228:	89 23       	and	r24, r25
    122a:	83 83       	std	Z+3, r24	; 0x03

            // serial number search direction write bit
            write_bit(search_direction);
    122c:	6f 2d       	mov	r22, r15
    122e:	ce 01       	movw	r24, r28
    1230:	0e 94 c0 07 	call	0xf80	; 0xf80 <_ZN7OneWire9write_bitEh>

            // increment the byte counter id_bit_number
            // and shift the mask rom_byte_mask
            id_bit_number++;
    1234:	1f 5f       	subi	r17, 0xFF	; 255
            rom_byte_mask <<= 1;
    1236:	00 0f       	add	r16, r16

            // if the mask is 0 then go to new SerialNum byte rom_byte_number and reset mask
            if (rom_byte_mask == 0) {
    1238:	11 f4       	brne	.+4      	; 0x123e <_ZN7OneWire6searchEPhb+0xc6>
                rom_byte_number++;
    123a:	e3 94       	inc	r14
                rom_byte_mask = 1;
    123c:	01 e0       	ldi	r16, 0x01	; 1
            }
         }
      }
      while(rom_byte_number < 8);  // loop until through all ROM bytes 0-7
    123e:	87 e0       	ldi	r24, 0x07	; 7
    1240:	8e 15       	cp	r24, r14
    1242:	08 f0       	brcs	.+2      	; 0x1246 <_ZN7OneWire6searchEPhb+0xce>
    1244:	bf cf       	rjmp	.-130    	; 0x11c4 <_ZN7OneWire6searchEPhb+0x4c>

      // if the search was successful then
      if (!(id_bit_number < 65)) {
    1246:	11 34       	cpi	r17, 0x41	; 65
    1248:	08 f4       	brcc	.+2      	; 0x124c <_ZN7OneWire6searchEPhb+0xd4>
    124a:	aa cf       	rjmp	.-172    	; 0x11a0 <_ZN7OneWire6searchEPhb+0x28>
         // search successful so set LastDiscrepancy,LastDeviceFlag,search_result
         LastDiscrepancy = last_zero;
    124c:	bb 86       	std	Y+11, r11	; 0x0b

         // check for last device
         if (LastDiscrepancy == 0) {
    124e:	b1 10       	cpse	r11, r1
    1250:	02 c0       	rjmp	.+4      	; 0x1256 <_ZN7OneWire6searchEPhb+0xde>
            LastDeviceFlag = true;
    1252:	81 e0       	ldi	r24, 0x01	; 1
    1254:	8d 87       	std	Y+13, r24	; 0x0d
         search_result = true;
      }
   }

   // if no device found then reset counters so next 'search' will be like a first
   if (!search_result || !ROM_NO[0]) {
    1256:	8b 81       	ldd	r24, Y+3	; 0x03
    1258:	88 23       	and	r24, r24
    125a:	09 f4       	brne	.+2      	; 0x125e <_ZN7OneWire6searchEPhb+0xe6>
    125c:	a1 cf       	rjmp	.-190    	; 0x11a0 <_ZN7OneWire6searchEPhb+0x28>
    125e:	de 01       	movw	r26, r28
    1260:	13 96       	adiw	r26, 0x03	; 3
    1262:	f6 01       	movw	r30, r12
    1264:	2b 96       	adiw	r28, 0x0b	; 11
      LastDiscrepancy = 0;
      LastDeviceFlag = false;
      LastFamilyDiscrepancy = 0;
      search_result = false;
   } else {
      for (int i = 0; i < 8; i++) newAddr[i] = ROM_NO[i];
    1266:	8d 91       	ld	r24, X+
    1268:	81 93       	st	Z+, r24
    126a:	ca 17       	cp	r28, r26
    126c:	db 07       	cpc	r29, r27
    126e:	d9 f7       	brne	.-10     	; 0x1266 <_ZN7OneWire6searchEPhb+0xee>
    1270:	81 e0       	ldi	r24, 0x01	; 1
   }
   return search_result;
  }
    1272:	df 91       	pop	r29
    1274:	cf 91       	pop	r28
    1276:	1f 91       	pop	r17
    1278:	0f 91       	pop	r16
    127a:	ff 90       	pop	r15
    127c:	ef 90       	pop	r14
    127e:	df 90       	pop	r13
    1280:	cf 90       	pop	r12
    1282:	bf 90       	pop	r11
    1284:	08 95       	ret

00001286 <_ZN7OneWire4crc8EPKhh>:
};

// Compute a Dallas Semiconductor 8 bit CRC. These show up in the ROM
// and the registers.  (Use tiny 2x16 entry CRC table)
uint8_t OneWire::crc8(const uint8_t *addr, uint8_t len)
{
    1286:	dc 01       	movw	r26, r24
	uint8_t crc = 0;
    1288:	80 e0       	ldi	r24, 0x00	; 0

	while (len--) {
    128a:	61 50       	subi	r22, 0x01	; 1
    128c:	98 f0       	brcs	.+38     	; 0x12b4 <_ZN7OneWire4crc8EPKhh+0x2e>
		crc = *addr++ ^ crc;  // just re-using crc as intermediate
    128e:	2d 91       	ld	r18, X+
    1290:	98 2f       	mov	r25, r24
    1292:	92 27       	eor	r25, r18
		crc = pgm_read_byte(dscrc2x16_table + (crc & 0x0f)) ^
    1294:	e9 2f       	mov	r30, r25
    1296:	ef 70       	andi	r30, 0x0F	; 15
    1298:	f0 e0       	ldi	r31, 0x00	; 0
    129a:	ee 56       	subi	r30, 0x6E	; 110
    129c:	ff 4f       	sbci	r31, 0xFF	; 255
    129e:	24 91       	lpm	r18, Z
		pgm_read_byte(dscrc2x16_table + 16 + ((crc >> 4) & 0x0f));
    12a0:	92 95       	swap	r25
    12a2:	9f 70       	andi	r25, 0x0F	; 15
    12a4:	e9 2f       	mov	r30, r25
    12a6:	f0 e0       	ldi	r31, 0x00	; 0
    12a8:	ee 55       	subi	r30, 0x5E	; 94
    12aa:	ff 4f       	sbci	r31, 0xFF	; 255
    12ac:	e4 91       	lpm	r30, Z
    12ae:	82 2f       	mov	r24, r18
    12b0:	8e 27       	eor	r24, r30
// and the registers.  (Use tiny 2x16 entry CRC table)
uint8_t OneWire::crc8(const uint8_t *addr, uint8_t len)
{
	uint8_t crc = 0;

	while (len--) {
    12b2:	eb cf       	rjmp	.-42     	; 0x128a <_ZN7OneWire4crc8EPKhh+0x4>
		crc = pgm_read_byte(dscrc2x16_table + (crc & 0x0f)) ^
		pgm_read_byte(dscrc2x16_table + 16 + ((crc >> 4) & 0x0f));
	}

	return crc;
}
    12b4:	08 95       	ret

000012b6 <_Z6calcPHv>:
float neutralVoltage = 404.0;
float acidVoltage = 166.0;


float calcPH()
{
    12b6:	8f 92       	push	r8
    12b8:	9f 92       	push	r9
    12ba:	af 92       	push	r10
    12bc:	bf 92       	push	r11
    12be:	cf 92       	push	r12
    12c0:	df 92       	push	r13
    12c2:	ef 92       	push	r14
    12c4:	ff 92       	push	r15
    12c6:	cf 93       	push	r28
    12c8:	df 93       	push	r29
	float voltage = analogRead(PH_PIN);
    12ca:	8e e0       	ldi	r24, 0x0E	; 14
    12cc:	0e 94 82 21 	call	0x4304	; 0x4304 <analogRead>
    12d0:	ec 01       	movw	r28, r24
	float slope = (7.0 - 4.0) / (neutralVoltage - acidVoltage);
    12d2:	80 90 39 01 	lds	r8, 0x0139	; 0x800139 <neutralVoltage>
    12d6:	90 90 3a 01 	lds	r9, 0x013A	; 0x80013a <neutralVoltage+0x1>
    12da:	a0 90 3b 01 	lds	r10, 0x013B	; 0x80013b <neutralVoltage+0x2>
    12de:	b0 90 3c 01 	lds	r11, 0x013C	; 0x80013c <neutralVoltage+0x3>
    12e2:	20 91 35 01 	lds	r18, 0x0135	; 0x800135 <acidVoltage>
    12e6:	30 91 36 01 	lds	r19, 0x0136	; 0x800136 <acidVoltage+0x1>
    12ea:	40 91 37 01 	lds	r20, 0x0137	; 0x800137 <acidVoltage+0x2>
    12ee:	50 91 38 01 	lds	r21, 0x0138	; 0x800138 <acidVoltage+0x3>
    12f2:	c5 01       	movw	r24, r10
    12f4:	b4 01       	movw	r22, r8
    12f6:	0e 94 df 1a 	call	0x35be	; 0x35be <__subsf3>
    12fa:	9b 01       	movw	r18, r22
    12fc:	ac 01       	movw	r20, r24
    12fe:	60 e0       	ldi	r22, 0x00	; 0
    1300:	70 e0       	ldi	r23, 0x00	; 0
    1302:	80 e4       	ldi	r24, 0x40	; 64
    1304:	90 e4       	ldi	r25, 0x40	; 64
    1306:	0e 94 51 1b 	call	0x36a2	; 0x36a2 <__divsf3>
    130a:	6b 01       	movw	r12, r22
    130c:	7c 01       	movw	r14, r24
	float intercept = 7.0 - (slope * neutralVoltage);
	return (slope * voltage) + intercept;
    130e:	9b 01       	movw	r18, r22
    1310:	ac 01       	movw	r20, r24
    1312:	c5 01       	movw	r24, r10
    1314:	b4 01       	movw	r22, r8
    1316:	0e 94 ab 1c 	call	0x3956	; 0x3956 <__mulsf3>
    131a:	9b 01       	movw	r18, r22
    131c:	ac 01       	movw	r20, r24
    131e:	60 e0       	ldi	r22, 0x00	; 0
    1320:	70 e0       	ldi	r23, 0x00	; 0
    1322:	80 ee       	ldi	r24, 0xE0	; 224
    1324:	90 e4       	ldi	r25, 0x40	; 64
    1326:	0e 94 df 1a 	call	0x35be	; 0x35be <__subsf3>
    132a:	4b 01       	movw	r8, r22
    132c:	5c 01       	movw	r10, r24
    132e:	be 01       	movw	r22, r28
    1330:	dd 0f       	add	r29, r29
    1332:	88 0b       	sbc	r24, r24
    1334:	99 0b       	sbc	r25, r25
    1336:	0e 94 fb 1b 	call	0x37f6	; 0x37f6 <__floatsisf>
    133a:	a7 01       	movw	r20, r14
    133c:	96 01       	movw	r18, r12
    133e:	0e 94 ab 1c 	call	0x3956	; 0x3956 <__mulsf3>
    1342:	9b 01       	movw	r18, r22
    1344:	ac 01       	movw	r20, r24
    1346:	c5 01       	movw	r24, r10
    1348:	b4 01       	movw	r22, r8
    134a:	0e 94 e0 1a 	call	0x35c0	; 0x35c0 <__addsf3>
    134e:	df 91       	pop	r29
    1350:	cf 91       	pop	r28
    1352:	ff 90       	pop	r15
    1354:	ef 90       	pop	r14
    1356:	df 90       	pop	r13
    1358:	cf 90       	pop	r12
    135a:	bf 90       	pop	r11
    135c:	af 90       	pop	r10
    135e:	9f 90       	pop	r9
    1360:	8f 90       	pop	r8
    1362:	08 95       	ret

00001364 <pvPortMalloc>:
#if( configSUPPORT_DYNAMIC_ALLOCATION > 0 )

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
    1364:	cf 93       	push	r28
    1366:	df 93       	push	r29
    1368:	ec 01       	movw	r28, r24
void *pvReturn;

    vTaskSuspendAll();
    136a:	0e 94 16 11 	call	0x222c	; 0x222c <vTaskSuspendAll>
    {
        pvReturn = malloc( xWantedSize );
    136e:	ce 01       	movw	r24, r28
    1370:	0e 94 32 24 	call	0x4864	; 0x4864 <malloc>
    1374:	ec 01       	movw	r28, r24
        traceMALLOC( pvReturn, xWantedSize );
    }
    ( void ) xTaskResumeAll();
    1376:	0e 94 d2 11 	call	0x23a4	; 0x23a4 <xTaskResumeAll>

    #if( configUSE_MALLOC_FAILED_HOOK == 1 )
    {
        if( pvReturn == NULL )
    137a:	20 97       	sbiw	r28, 0x00	; 0
    137c:	11 f4       	brne	.+4      	; 0x1382 <pvPortMalloc+0x1e>
        {
            extern void vApplicationMallocFailedHook( void );
            vApplicationMallocFailedHook();
    137e:	0e 94 af 16 	call	0x2d5e	; 0x2d5e <vApplicationMallocFailedHook>
        }
    }
    #endif

    return pvReturn;
}
    1382:	ce 01       	movw	r24, r28
    1384:	df 91       	pop	r29
    1386:	cf 91       	pop	r28
    1388:	08 95       	ret

0000138a <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
    138a:	cf 93       	push	r28
    138c:	df 93       	push	r29
    if( pv )
    138e:	00 97       	sbiw	r24, 0x00	; 0
    1390:	51 f0       	breq	.+20     	; 0x13a6 <vPortFree+0x1c>
    1392:	ec 01       	movw	r28, r24
    {
        vTaskSuspendAll();
    1394:	0e 94 16 11 	call	0x222c	; 0x222c <vTaskSuspendAll>
        {
            free( pv );
    1398:	ce 01       	movw	r24, r28
    139a:	0e 94 ca 24 	call	0x4994	; 0x4994 <free>
            traceFREE( pv, 0 );
        }
        ( void ) xTaskResumeAll();
    }
}
    139e:	df 91       	pop	r29
    13a0:	cf 91       	pop	r28
        vTaskSuspendAll();
        {
            free( pv );
            traceFREE( pv, 0 );
        }
        ( void ) xTaskResumeAll();
    13a2:	0c 94 d2 11 	jmp	0x23a4	; 0x23a4 <xTaskResumeAll>
    }
}
    13a6:	df 91       	pop	r29
    13a8:	cf 91       	pop	r28
    13aa:	08 95       	ret

000013ac <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
    13ac:	fc 01       	movw	r30, r24
    /* The list structure contains a list item which is used to mark the
    end of the list.  To initialise the list the list end is inserted
    as the only list entry. */
    pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );            /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    13ae:	03 96       	adiw	r24, 0x03	; 3
    13b0:	92 83       	std	Z+2, r25	; 0x02
    13b2:	81 83       	std	Z+1, r24	; 0x01

    /* The list end value is the highest possible value in the list to
    ensure it remains at the end of the list. */
    pxList->xListEnd.xItemValue = portMAX_DELAY;
    13b4:	2f ef       	ldi	r18, 0xFF	; 255
    13b6:	3f ef       	ldi	r19, 0xFF	; 255
    13b8:	34 83       	std	Z+4, r19	; 0x04
    13ba:	23 83       	std	Z+3, r18	; 0x03

    /* The list end next and previous pointers point to itself so we know
    when the list is empty. */
    pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );    /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    13bc:	96 83       	std	Z+6, r25	; 0x06
    13be:	85 83       	std	Z+5, r24	; 0x05
    pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    13c0:	90 87       	std	Z+8, r25	; 0x08
    13c2:	87 83       	std	Z+7, r24	; 0x07

    pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
    13c4:	10 82       	st	Z, r1
    13c6:	08 95       	ret

000013c8 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
    /* Make sure the list item is not recorded as being on a list. */
    pxItem->pxContainer = NULL;
    13c8:	fc 01       	movw	r30, r24
    13ca:	11 86       	std	Z+9, r1	; 0x09
    13cc:	10 86       	std	Z+8, r1	; 0x08
    13ce:	08 95       	ret

000013d0 <vListInsertEnd>:
    listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    13d0:	cf 93       	push	r28
    13d2:	df 93       	push	r29
    13d4:	9c 01       	movw	r18, r24
    13d6:	fb 01       	movw	r30, r22
ListItem_t * const pxIndex = pxList->pxIndex;
    13d8:	dc 01       	movw	r26, r24
    13da:	11 96       	adiw	r26, 0x01	; 1
    13dc:	cd 91       	ld	r28, X+
    13de:	dc 91       	ld	r29, X
    13e0:	12 97       	sbiw	r26, 0x02	; 2
    listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

    /* Insert a new list item into pxList, but rather than sort the list,
    makes the new list item the last item to be removed by a call to
    listGET_OWNER_OF_NEXT_ENTRY(). */
    pxNewListItem->pxNext = pxIndex;
    13e2:	d3 83       	std	Z+3, r29	; 0x03
    13e4:	c2 83       	std	Z+2, r28	; 0x02
    pxNewListItem->pxPrevious = pxIndex->pxPrevious;
    13e6:	8c 81       	ldd	r24, Y+4	; 0x04
    13e8:	9d 81       	ldd	r25, Y+5	; 0x05
    13ea:	95 83       	std	Z+5, r25	; 0x05
    13ec:	84 83       	std	Z+4, r24	; 0x04

    /* Only used during decision coverage testing. */
    mtCOVERAGE_TEST_DELAY();

    pxIndex->pxPrevious->pxNext = pxNewListItem;
    13ee:	8c 81       	ldd	r24, Y+4	; 0x04
    13f0:	9d 81       	ldd	r25, Y+5	; 0x05
    13f2:	dc 01       	movw	r26, r24
    13f4:	13 96       	adiw	r26, 0x03	; 3
    13f6:	7c 93       	st	X, r23
    13f8:	6e 93       	st	-X, r22
    13fa:	12 97       	sbiw	r26, 0x02	; 2
    pxIndex->pxPrevious = pxNewListItem;
    13fc:	7d 83       	std	Y+5, r23	; 0x05
    13fe:	6c 83       	std	Y+4, r22	; 0x04

    /* Remember which list the item is in. */
    pxNewListItem->pxContainer = pxList;
    1400:	31 87       	std	Z+9, r19	; 0x09
    1402:	20 87       	std	Z+8, r18	; 0x08

    ( pxList->uxNumberOfItems )++;
    1404:	f9 01       	movw	r30, r18
    1406:	80 81       	ld	r24, Z
    1408:	8f 5f       	subi	r24, 0xFF	; 255
    140a:	80 83       	st	Z, r24
}
    140c:	df 91       	pop	r29
    140e:	cf 91       	pop	r28
    1410:	08 95       	ret

00001412 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    1412:	0f 93       	push	r16
    1414:	1f 93       	push	r17
    1416:	cf 93       	push	r28
    1418:	df 93       	push	r29
    141a:	8c 01       	movw	r16, r24
    141c:	fb 01       	movw	r30, r22
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
    141e:	80 81       	ld	r24, Z
    1420:	91 81       	ldd	r25, Z+1	; 0x01
    new list item should be placed after it.  This ensures that TCBs which are
    stored in ready lists (all of which have the same xItemValue value) get a
    share of the CPU.  However, if the xItemValue is the same as the back marker
    the iteration loop below will not end.  Therefore the value is checked
    first, and the algorithm slightly modified if necessary. */
    if( xValueOfInsertion == portMAX_DELAY )
    1422:	8f 3f       	cpi	r24, 0xFF	; 255
    1424:	2f ef       	ldi	r18, 0xFF	; 255
    1426:	92 07       	cpc	r25, r18
    1428:	21 f4       	brne	.+8      	; 0x1432 <vListInsert+0x20>
    {
        pxIterator = pxList->xListEnd.pxPrevious;
    142a:	e8 01       	movw	r28, r16
    142c:	af 81       	ldd	r26, Y+7	; 0x07
    142e:	b8 85       	ldd	r27, Y+8	; 0x08
    1430:	0e c0       	rjmp	.+28     	; 0x144e <vListInsert+0x3c>
            4) Using a queue or semaphore before it has been initialised or
               before the scheduler has been started (are interrupts firing
               before vTaskStartScheduler() has been called?).
        **********************************************************************/

        for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. *//*lint !e440 The iterator moves to a different value, not xValueOfInsertion. */
    1432:	d8 01       	movw	r26, r16
    1434:	13 96       	adiw	r26, 0x03	; 3
    1436:	12 96       	adiw	r26, 0x02	; 2
    1438:	2d 91       	ld	r18, X+
    143a:	3c 91       	ld	r19, X
    143c:	13 97       	sbiw	r26, 0x03	; 3
    143e:	e9 01       	movw	r28, r18
    1440:	48 81       	ld	r20, Y
    1442:	59 81       	ldd	r21, Y+1	; 0x01
    1444:	84 17       	cp	r24, r20
    1446:	95 07       	cpc	r25, r21
    1448:	10 f0       	brcs	.+4      	; 0x144e <vListInsert+0x3c>
    144a:	d9 01       	movw	r26, r18
    144c:	f4 cf       	rjmp	.-24     	; 0x1436 <vListInsert+0x24>
            /* There is nothing to do here, just iterating to the wanted
            insertion position. */
        }
    }

    pxNewListItem->pxNext = pxIterator->pxNext;
    144e:	12 96       	adiw	r26, 0x02	; 2
    1450:	8d 91       	ld	r24, X+
    1452:	9c 91       	ld	r25, X
    1454:	13 97       	sbiw	r26, 0x03	; 3
    1456:	93 83       	std	Z+3, r25	; 0x03
    1458:	82 83       	std	Z+2, r24	; 0x02
    pxNewListItem->pxNext->pxPrevious = pxNewListItem;
    145a:	ec 01       	movw	r28, r24
    145c:	fd 83       	std	Y+5, r31	; 0x05
    145e:	ec 83       	std	Y+4, r30	; 0x04
    pxNewListItem->pxPrevious = pxIterator;
    1460:	b5 83       	std	Z+5, r27	; 0x05
    1462:	a4 83       	std	Z+4, r26	; 0x04
    pxIterator->pxNext = pxNewListItem;
    1464:	13 96       	adiw	r26, 0x03	; 3
    1466:	fc 93       	st	X, r31
    1468:	ee 93       	st	-X, r30
    146a:	12 97       	sbiw	r26, 0x02	; 2

    /* Remember which list the item is in.  This allows fast removal of the
    item later. */
    pxNewListItem->pxContainer = pxList;
    146c:	11 87       	std	Z+9, r17	; 0x09
    146e:	00 87       	std	Z+8, r16	; 0x08

    ( pxList->uxNumberOfItems )++;
    1470:	f8 01       	movw	r30, r16
    1472:	80 81       	ld	r24, Z
    1474:	8f 5f       	subi	r24, 0xFF	; 255
    1476:	80 83       	st	Z, r24
}
    1478:	df 91       	pop	r29
    147a:	cf 91       	pop	r28
    147c:	1f 91       	pop	r17
    147e:	0f 91       	pop	r16
    1480:	08 95       	ret

00001482 <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
    1482:	cf 93       	push	r28
    1484:	df 93       	push	r29
    1486:	fc 01       	movw	r30, r24
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = pxItemToRemove->pxContainer;
    1488:	a0 85       	ldd	r26, Z+8	; 0x08
    148a:	b1 85       	ldd	r27, Z+9	; 0x09

    pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    148c:	82 81       	ldd	r24, Z+2	; 0x02
    148e:	93 81       	ldd	r25, Z+3	; 0x03
    1490:	24 81       	ldd	r18, Z+4	; 0x04
    1492:	35 81       	ldd	r19, Z+5	; 0x05
    1494:	ec 01       	movw	r28, r24
    1496:	3d 83       	std	Y+5, r19	; 0x05
    1498:	2c 83       	std	Y+4, r18	; 0x04
    pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    149a:	c4 81       	ldd	r28, Z+4	; 0x04
    149c:	d5 81       	ldd	r29, Z+5	; 0x05
    149e:	9b 83       	std	Y+3, r25	; 0x03
    14a0:	8a 83       	std	Y+2, r24	; 0x02

    /* Only used during decision coverage testing. */
    mtCOVERAGE_TEST_DELAY();

    /* Make sure the index is left pointing to a valid item. */
    if( pxList->pxIndex == pxItemToRemove )
    14a2:	11 96       	adiw	r26, 0x01	; 1
    14a4:	8d 91       	ld	r24, X+
    14a6:	9c 91       	ld	r25, X
    14a8:	12 97       	sbiw	r26, 0x02	; 2
    14aa:	e8 17       	cp	r30, r24
    14ac:	f9 07       	cpc	r31, r25
    14ae:	21 f4       	brne	.+8      	; 0x14b8 <uxListRemove+0x36>
    {
        pxList->pxIndex = pxItemToRemove->pxPrevious;
    14b0:	12 96       	adiw	r26, 0x02	; 2
    14b2:	dc 93       	st	X, r29
    14b4:	ce 93       	st	-X, r28
    14b6:	11 97       	sbiw	r26, 0x01	; 1
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }

    pxItemToRemove->pxContainer = NULL;
    14b8:	11 86       	std	Z+9, r1	; 0x09
    14ba:	10 86       	std	Z+8, r1	; 0x08
    ( pxList->uxNumberOfItems )--;
    14bc:	8c 91       	ld	r24, X
    14be:	81 50       	subi	r24, 0x01	; 1
    14c0:	8c 93       	st	X, r24

    return pxList->uxNumberOfItems;
    14c2:	8c 91       	ld	r24, X
}
    14c4:	df 91       	pop	r29
    14c6:	cf 91       	pop	r28
    14c8:	08 95       	ret

000014ca <pxPortInitialiseStack>:
		);
	}
	else
	{
        uint8_t register temp_reg;
		__asm__ __volatile__ (
    14ca:	31 e1       	ldi	r19, 0x11	; 17
    14cc:	fc 01       	movw	r30, r24
    14ce:	30 83       	st	Z, r19
    14d0:	31 97       	sbiw	r30, 0x01	; 1
    14d2:	22 e2       	ldi	r18, 0x22	; 34
    14d4:	20 83       	st	Z, r18
    14d6:	31 97       	sbiw	r30, 0x01	; 1
    14d8:	a3 e3       	ldi	r26, 0x33	; 51
    14da:	a0 83       	st	Z, r26
    14dc:	31 97       	sbiw	r30, 0x01	; 1
    14de:	60 83       	st	Z, r22
    14e0:	31 97       	sbiw	r30, 0x01	; 1
    14e2:	70 83       	st	Z, r23
    14e4:	31 97       	sbiw	r30, 0x01	; 1
    14e6:	10 82       	st	Z, r1
    14e8:	31 97       	sbiw	r30, 0x01	; 1
    14ea:	60 e8       	ldi	r22, 0x80	; 128
    14ec:	60 83       	st	Z, r22
    14ee:	31 97       	sbiw	r30, 0x01	; 1
    14f0:	10 82       	st	Z, r1
    14f2:	31 97       	sbiw	r30, 0x01	; 1
    14f4:	62 e0       	ldi	r22, 0x02	; 2
    14f6:	60 83       	st	Z, r22
    14f8:	31 97       	sbiw	r30, 0x01	; 1
    14fa:	63 e0       	ldi	r22, 0x03	; 3
    14fc:	60 83       	st	Z, r22
    14fe:	31 97       	sbiw	r30, 0x01	; 1
    1500:	64 e0       	ldi	r22, 0x04	; 4
    1502:	60 83       	st	Z, r22
    1504:	31 97       	sbiw	r30, 0x01	; 1
    1506:	65 e0       	ldi	r22, 0x05	; 5
    1508:	60 83       	st	Z, r22
    150a:	31 97       	sbiw	r30, 0x01	; 1
    150c:	66 e0       	ldi	r22, 0x06	; 6
    150e:	60 83       	st	Z, r22
    1510:	31 97       	sbiw	r30, 0x01	; 1
    1512:	67 e0       	ldi	r22, 0x07	; 7
    1514:	60 83       	st	Z, r22
    1516:	31 97       	sbiw	r30, 0x01	; 1
    1518:	68 e0       	ldi	r22, 0x08	; 8
    151a:	60 83       	st	Z, r22
    151c:	31 97       	sbiw	r30, 0x01	; 1
    151e:	69 e0       	ldi	r22, 0x09	; 9
    1520:	60 83       	st	Z, r22
    1522:	31 97       	sbiw	r30, 0x01	; 1
    1524:	60 e1       	ldi	r22, 0x10	; 16
    1526:	60 83       	st	Z, r22
    1528:	31 97       	sbiw	r30, 0x01	; 1
    152a:	30 83       	st	Z, r19
    152c:	31 97       	sbiw	r30, 0x01	; 1
    152e:	32 e1       	ldi	r19, 0x12	; 18
    1530:	30 83       	st	Z, r19
    1532:	31 97       	sbiw	r30, 0x01	; 1
    1534:	33 e1       	ldi	r19, 0x13	; 19
    1536:	30 83       	st	Z, r19
    1538:	31 97       	sbiw	r30, 0x01	; 1
    153a:	34 e1       	ldi	r19, 0x14	; 20
    153c:	30 83       	st	Z, r19
    153e:	31 97       	sbiw	r30, 0x01	; 1
    1540:	35 e1       	ldi	r19, 0x15	; 21
    1542:	30 83       	st	Z, r19
    1544:	31 97       	sbiw	r30, 0x01	; 1
    1546:	36 e1       	ldi	r19, 0x16	; 22
    1548:	30 83       	st	Z, r19
    154a:	31 97       	sbiw	r30, 0x01	; 1
    154c:	37 e1       	ldi	r19, 0x17	; 23
    154e:	30 83       	st	Z, r19
    1550:	31 97       	sbiw	r30, 0x01	; 1
    1552:	38 e1       	ldi	r19, 0x18	; 24
    1554:	30 83       	st	Z, r19
    1556:	31 97       	sbiw	r30, 0x01	; 1
    1558:	39 e1       	ldi	r19, 0x19	; 25
    155a:	30 83       	st	Z, r19
    155c:	31 97       	sbiw	r30, 0x01	; 1
    155e:	30 e2       	ldi	r19, 0x20	; 32
    1560:	30 83       	st	Z, r19
    1562:	31 97       	sbiw	r30, 0x01	; 1
    1564:	31 e2       	ldi	r19, 0x21	; 33
    1566:	30 83       	st	Z, r19
    1568:	31 97       	sbiw	r30, 0x01	; 1
    156a:	20 83       	st	Z, r18
    156c:	31 97       	sbiw	r30, 0x01	; 1
    156e:	23 e2       	ldi	r18, 0x23	; 35
    1570:	20 83       	st	Z, r18
    1572:	31 97       	sbiw	r30, 0x01	; 1
    1574:	40 83       	st	Z, r20
    1576:	31 97       	sbiw	r30, 0x01	; 1
    1578:	50 83       	st	Z, r21
    157a:	31 97       	sbiw	r30, 0x01	; 1
    157c:	26 e2       	ldi	r18, 0x26	; 38
    157e:	20 83       	st	Z, r18
    1580:	31 97       	sbiw	r30, 0x01	; 1
    1582:	27 e2       	ldi	r18, 0x27	; 39
    1584:	20 83       	st	Z, r18
    1586:	31 97       	sbiw	r30, 0x01	; 1
    1588:	28 e2       	ldi	r18, 0x28	; 40
    158a:	20 83       	st	Z, r18
    158c:	31 97       	sbiw	r30, 0x01	; 1
    158e:	29 e2       	ldi	r18, 0x29	; 41
    1590:	20 83       	st	Z, r18
    1592:	31 97       	sbiw	r30, 0x01	; 1
    1594:	20 e3       	ldi	r18, 0x30	; 48
    1596:	20 83       	st	Z, r18
    1598:	31 97       	sbiw	r30, 0x01	; 1
    159a:	21 e3       	ldi	r18, 0x31	; 49
    159c:	20 83       	st	Z, r18
    159e:	86 97       	sbiw	r24, 0x26	; 38
    15a0:	08 95       	ret

000015a2 <xPortStartScheduler>:
    15a2:	a8 95       	wdr
    15a4:	90 ec       	ldi	r25, 0xC0	; 192
    15a6:	88 e1       	ldi	r24, 0x18	; 24
    15a8:	0f b6       	in	r0, 0x3f	; 63
    15aa:	f8 94       	cli
    15ac:	a8 95       	wdr
    15ae:	80 93 60 00 	sts	0x0060, r24	; 0x800060 <__DATA_REGION_ORIGIN__>
    15b2:	0f be       	out	0x3f, r0	; 63
    15b4:	90 93 60 00 	sts	0x0060, r25	; 0x800060 <__DATA_REGION_ORIGIN__>
    15b8:	a0 91 36 04 	lds	r26, 0x0436	; 0x800436 <pxCurrentTCB>
    15bc:	b0 91 37 04 	lds	r27, 0x0437	; 0x800437 <pxCurrentTCB+0x1>
    15c0:	cd 91       	ld	r28, X+
    15c2:	cd bf       	out	0x3d, r28	; 61
    15c4:	dd 91       	ld	r29, X+
    15c6:	de bf       	out	0x3e, r29	; 62
    15c8:	ff 91       	pop	r31
    15ca:	ef 91       	pop	r30
    15cc:	df 91       	pop	r29
    15ce:	cf 91       	pop	r28
    15d0:	bf 91       	pop	r27
    15d2:	af 91       	pop	r26
    15d4:	9f 91       	pop	r25
    15d6:	8f 91       	pop	r24
    15d8:	7f 91       	pop	r23
    15da:	6f 91       	pop	r22
    15dc:	5f 91       	pop	r21
    15de:	4f 91       	pop	r20
    15e0:	3f 91       	pop	r19
    15e2:	2f 91       	pop	r18
    15e4:	1f 91       	pop	r17
    15e6:	0f 91       	pop	r16
    15e8:	ff 90       	pop	r15
    15ea:	ef 90       	pop	r14
    15ec:	df 90       	pop	r13
    15ee:	cf 90       	pop	r12
    15f0:	bf 90       	pop	r11
    15f2:	af 90       	pop	r10
    15f4:	9f 90       	pop	r9
    15f6:	8f 90       	pop	r8
    15f8:	7f 90       	pop	r7
    15fa:	6f 90       	pop	r6
    15fc:	5f 90       	pop	r5
    15fe:	4f 90       	pop	r4
    1600:	3f 90       	pop	r3
    1602:	2f 90       	pop	r2
    1604:	1f 90       	pop	r1
    1606:	0f 90       	pop	r0
    1608:	0f be       	out	0x3f, r0	; 63
    160a:	0f 90       	pop	r0
    160c:	08 95       	ret
    160e:	81 e0       	ldi	r24, 0x01	; 1
    1610:	08 95       	ret

00001612 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( hot, flatten, naked ) );
void vPortYield( void )
{
    portSAVE_CONTEXT();
    1612:	0f 92       	push	r0
    1614:	0f b6       	in	r0, 0x3f	; 63
    1616:	f8 94       	cli
    1618:	0f 92       	push	r0
    161a:	1f 92       	push	r1
    161c:	11 24       	eor	r1, r1
    161e:	2f 92       	push	r2
    1620:	3f 92       	push	r3
    1622:	4f 92       	push	r4
    1624:	5f 92       	push	r5
    1626:	6f 92       	push	r6
    1628:	7f 92       	push	r7
    162a:	8f 92       	push	r8
    162c:	9f 92       	push	r9
    162e:	af 92       	push	r10
    1630:	bf 92       	push	r11
    1632:	cf 92       	push	r12
    1634:	df 92       	push	r13
    1636:	ef 92       	push	r14
    1638:	ff 92       	push	r15
    163a:	0f 93       	push	r16
    163c:	1f 93       	push	r17
    163e:	2f 93       	push	r18
    1640:	3f 93       	push	r19
    1642:	4f 93       	push	r20
    1644:	5f 93       	push	r21
    1646:	6f 93       	push	r22
    1648:	7f 93       	push	r23
    164a:	8f 93       	push	r24
    164c:	9f 93       	push	r25
    164e:	af 93       	push	r26
    1650:	bf 93       	push	r27
    1652:	cf 93       	push	r28
    1654:	df 93       	push	r29
    1656:	ef 93       	push	r30
    1658:	ff 93       	push	r31
    165a:	a0 91 36 04 	lds	r26, 0x0436	; 0x800436 <pxCurrentTCB>
    165e:	b0 91 37 04 	lds	r27, 0x0437	; 0x800437 <pxCurrentTCB+0x1>
    1662:	0d b6       	in	r0, 0x3d	; 61
    1664:	0d 92       	st	X+, r0
    1666:	0e b6       	in	r0, 0x3e	; 62
    1668:	0d 92       	st	X+, r0
    vTaskSwitchContext();
    166a:	0e 94 8e 12 	call	0x251c	; 0x251c <vTaskSwitchContext>
    portRESTORE_CONTEXT();
    166e:	a0 91 36 04 	lds	r26, 0x0436	; 0x800436 <pxCurrentTCB>
    1672:	b0 91 37 04 	lds	r27, 0x0437	; 0x800437 <pxCurrentTCB+0x1>
    1676:	cd 91       	ld	r28, X+
    1678:	cd bf       	out	0x3d, r28	; 61
    167a:	dd 91       	ld	r29, X+
    167c:	de bf       	out	0x3e, r29	; 62
    167e:	ff 91       	pop	r31
    1680:	ef 91       	pop	r30
    1682:	df 91       	pop	r29
    1684:	cf 91       	pop	r28
    1686:	bf 91       	pop	r27
    1688:	af 91       	pop	r26
    168a:	9f 91       	pop	r25
    168c:	8f 91       	pop	r24
    168e:	7f 91       	pop	r23
    1690:	6f 91       	pop	r22
    1692:	5f 91       	pop	r21
    1694:	4f 91       	pop	r20
    1696:	3f 91       	pop	r19
    1698:	2f 91       	pop	r18
    169a:	1f 91       	pop	r17
    169c:	0f 91       	pop	r16
    169e:	ff 90       	pop	r15
    16a0:	ef 90       	pop	r14
    16a2:	df 90       	pop	r13
    16a4:	cf 90       	pop	r12
    16a6:	bf 90       	pop	r11
    16a8:	af 90       	pop	r10
    16aa:	9f 90       	pop	r9
    16ac:	8f 90       	pop	r8
    16ae:	7f 90       	pop	r7
    16b0:	6f 90       	pop	r6
    16b2:	5f 90       	pop	r5
    16b4:	4f 90       	pop	r4
    16b6:	3f 90       	pop	r3
    16b8:	2f 90       	pop	r2
    16ba:	1f 90       	pop	r1
    16bc:	0f 90       	pop	r0
    16be:	0f be       	out	0x3f, r0	; 63
    16c0:	0f 90       	pop	r0

    __asm__ __volatile__ ( "ret" );
    16c2:	08 95       	ret

000016c4 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( hot, flatten, naked ) );
void vPortYieldFromTick( void )
{
    portSAVE_CONTEXT();
    16c4:	0f 92       	push	r0
    16c6:	0f b6       	in	r0, 0x3f	; 63
    16c8:	f8 94       	cli
    16ca:	0f 92       	push	r0
    16cc:	1f 92       	push	r1
    16ce:	11 24       	eor	r1, r1
    16d0:	2f 92       	push	r2
    16d2:	3f 92       	push	r3
    16d4:	4f 92       	push	r4
    16d6:	5f 92       	push	r5
    16d8:	6f 92       	push	r6
    16da:	7f 92       	push	r7
    16dc:	8f 92       	push	r8
    16de:	9f 92       	push	r9
    16e0:	af 92       	push	r10
    16e2:	bf 92       	push	r11
    16e4:	cf 92       	push	r12
    16e6:	df 92       	push	r13
    16e8:	ef 92       	push	r14
    16ea:	ff 92       	push	r15
    16ec:	0f 93       	push	r16
    16ee:	1f 93       	push	r17
    16f0:	2f 93       	push	r18
    16f2:	3f 93       	push	r19
    16f4:	4f 93       	push	r20
    16f6:	5f 93       	push	r21
    16f8:	6f 93       	push	r22
    16fa:	7f 93       	push	r23
    16fc:	8f 93       	push	r24
    16fe:	9f 93       	push	r25
    1700:	af 93       	push	r26
    1702:	bf 93       	push	r27
    1704:	cf 93       	push	r28
    1706:	df 93       	push	r29
    1708:	ef 93       	push	r30
    170a:	ff 93       	push	r31
    170c:	a0 91 36 04 	lds	r26, 0x0436	; 0x800436 <pxCurrentTCB>
    1710:	b0 91 37 04 	lds	r27, 0x0437	; 0x800437 <pxCurrentTCB+0x1>
    1714:	0d b6       	in	r0, 0x3d	; 61
    1716:	0d 92       	st	X+, r0
    1718:	0e b6       	in	r0, 0x3e	; 62
    171a:	0d 92       	st	X+, r0

    sleep_reset();        //     reset the sleep_mode() faster than sleep_disable();
    171c:	13 be       	out	0x33, r1	; 51

    if( xTaskIncrementTick() != pdFALSE )
    171e:	0e 94 26 11 	call	0x224c	; 0x224c <xTaskIncrementTick>
    1722:	81 11       	cpse	r24, r1
    {
        vTaskSwitchContext();
    1724:	0e 94 8e 12 	call	0x251c	; 0x251c <vTaskSwitchContext>
    }

    portRESTORE_CONTEXT();
    1728:	a0 91 36 04 	lds	r26, 0x0436	; 0x800436 <pxCurrentTCB>
    172c:	b0 91 37 04 	lds	r27, 0x0437	; 0x800437 <pxCurrentTCB+0x1>
    1730:	cd 91       	ld	r28, X+
    1732:	cd bf       	out	0x3d, r28	; 61
    1734:	dd 91       	ld	r29, X+
    1736:	de bf       	out	0x3e, r29	; 62
    1738:	ff 91       	pop	r31
    173a:	ef 91       	pop	r30
    173c:	df 91       	pop	r29
    173e:	cf 91       	pop	r28
    1740:	bf 91       	pop	r27
    1742:	af 91       	pop	r26
    1744:	9f 91       	pop	r25
    1746:	8f 91       	pop	r24
    1748:	7f 91       	pop	r23
    174a:	6f 91       	pop	r22
    174c:	5f 91       	pop	r21
    174e:	4f 91       	pop	r20
    1750:	3f 91       	pop	r19
    1752:	2f 91       	pop	r18
    1754:	1f 91       	pop	r17
    1756:	0f 91       	pop	r16
    1758:	ff 90       	pop	r15
    175a:	ef 90       	pop	r14
    175c:	df 90       	pop	r13
    175e:	cf 90       	pop	r12
    1760:	bf 90       	pop	r11
    1762:	af 90       	pop	r10
    1764:	9f 90       	pop	r9
    1766:	8f 90       	pop	r8
    1768:	7f 90       	pop	r7
    176a:	6f 90       	pop	r6
    176c:	5f 90       	pop	r5
    176e:	4f 90       	pop	r4
    1770:	3f 90       	pop	r3
    1772:	2f 90       	pop	r2
    1774:	1f 90       	pop	r1
    1776:	0f 90       	pop	r0
    1778:	0f be       	out	0x3f, r0	; 63
    177a:	0f 90       	pop	r0

    __asm__ __volatile__ ( "ret" );
    177c:	08 95       	ret

0000177e <__vector_6>:
     */
    ISR(portSCHEDULER_ISR, ISR_NAKED) __attribute__ ((hot, flatten));
//  ISR(portSCHEDULER_ISR, ISR_NAKED ISR_NOBLOCK) __attribute__ ((hot, flatten));
    ISR(portSCHEDULER_ISR)
    {
        vPortYieldFromTick();
    177e:	0e 94 62 0b 	call	0x16c4	; 0x16c4 <vPortYieldFromTick>
        __asm__ __volatile__ ( "reti" );
    1782:	18 95       	reti

00001784 <prvIsQueueEmpty>:
    {
        xReturn = pdFALSE;
    }

    return xReturn;
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
    1784:	0f b6       	in	r0, 0x3f	; 63
    1786:	f8 94       	cli
    1788:	0f 92       	push	r0
    178a:	fc 01       	movw	r30, r24
    178c:	92 8d       	ldd	r25, Z+26	; 0x1a
    178e:	0f 90       	pop	r0
    1790:	0f be       	out	0x3f, r0	; 63
    1792:	81 e0       	ldi	r24, 0x01	; 1
    1794:	91 11       	cpse	r25, r1
    1796:	80 e0       	ldi	r24, 0x00	; 0
    1798:	08 95       	ret

0000179a <prvCopyDataToQueue>:
    179a:	0f 93       	push	r16
    179c:	1f 93       	push	r17
    179e:	cf 93       	push	r28
    17a0:	df 93       	push	r29
    17a2:	ec 01       	movw	r28, r24
    17a4:	04 2f       	mov	r16, r20
    17a6:	1a 8d       	ldd	r17, Y+26	; 0x1a
    17a8:	4c 8d       	ldd	r20, Y+28	; 0x1c
    17aa:	41 11       	cpse	r20, r1
    17ac:	0b c0       	rjmp	.+22     	; 0x17c4 <prvCopyDataToQueue+0x2a>
    17ae:	88 81       	ld	r24, Y
    17b0:	99 81       	ldd	r25, Y+1	; 0x01
    17b2:	89 2b       	or	r24, r25
    17b4:	e9 f5       	brne	.+122    	; 0x1830 <prvCopyDataToQueue+0x96>
    17b6:	8c 81       	ldd	r24, Y+4	; 0x04
    17b8:	9d 81       	ldd	r25, Y+5	; 0x05
    17ba:	0e 94 08 14 	call	0x2810	; 0x2810 <xTaskPriorityDisinherit>
    17be:	1d 82       	std	Y+5, r1	; 0x05
    17c0:	1c 82       	std	Y+4, r1	; 0x04
    17c2:	37 c0       	rjmp	.+110    	; 0x1832 <prvCopyDataToQueue+0x98>
    17c4:	50 e0       	ldi	r21, 0x00	; 0
    17c6:	01 11       	cpse	r16, r1
    17c8:	15 c0       	rjmp	.+42     	; 0x17f4 <prvCopyDataToQueue+0x5a>
    17ca:	8a 81       	ldd	r24, Y+2	; 0x02
    17cc:	9b 81       	ldd	r25, Y+3	; 0x03
    17ce:	0e 94 53 25 	call	0x4aa6	; 0x4aa6 <memcpy>
    17d2:	2c 8d       	ldd	r18, Y+28	; 0x1c
    17d4:	8a 81       	ldd	r24, Y+2	; 0x02
    17d6:	9b 81       	ldd	r25, Y+3	; 0x03
    17d8:	82 0f       	add	r24, r18
    17da:	91 1d       	adc	r25, r1
    17dc:	9b 83       	std	Y+3, r25	; 0x03
    17de:	8a 83       	std	Y+2, r24	; 0x02
    17e0:	2c 81       	ldd	r18, Y+4	; 0x04
    17e2:	3d 81       	ldd	r19, Y+5	; 0x05
    17e4:	82 17       	cp	r24, r18
    17e6:	93 07       	cpc	r25, r19
    17e8:	18 f1       	brcs	.+70     	; 0x1830 <prvCopyDataToQueue+0x96>
    17ea:	88 81       	ld	r24, Y
    17ec:	99 81       	ldd	r25, Y+1	; 0x01
    17ee:	9b 83       	std	Y+3, r25	; 0x03
    17f0:	8a 83       	std	Y+2, r24	; 0x02
    17f2:	1e c0       	rjmp	.+60     	; 0x1830 <prvCopyDataToQueue+0x96>
    17f4:	8e 81       	ldd	r24, Y+6	; 0x06
    17f6:	9f 81       	ldd	r25, Y+7	; 0x07
    17f8:	0e 94 53 25 	call	0x4aa6	; 0x4aa6 <memcpy>
    17fc:	8c 8d       	ldd	r24, Y+28	; 0x1c
    17fe:	90 e0       	ldi	r25, 0x00	; 0
    1800:	91 95       	neg	r25
    1802:	81 95       	neg	r24
    1804:	91 09       	sbc	r25, r1
    1806:	2e 81       	ldd	r18, Y+6	; 0x06
    1808:	3f 81       	ldd	r19, Y+7	; 0x07
    180a:	28 0f       	add	r18, r24
    180c:	39 1f       	adc	r19, r25
    180e:	3f 83       	std	Y+7, r19	; 0x07
    1810:	2e 83       	std	Y+6, r18	; 0x06
    1812:	48 81       	ld	r20, Y
    1814:	59 81       	ldd	r21, Y+1	; 0x01
    1816:	24 17       	cp	r18, r20
    1818:	35 07       	cpc	r19, r21
    181a:	30 f4       	brcc	.+12     	; 0x1828 <prvCopyDataToQueue+0x8e>
    181c:	2c 81       	ldd	r18, Y+4	; 0x04
    181e:	3d 81       	ldd	r19, Y+5	; 0x05
    1820:	82 0f       	add	r24, r18
    1822:	93 1f       	adc	r25, r19
    1824:	9f 83       	std	Y+7, r25	; 0x07
    1826:	8e 83       	std	Y+6, r24	; 0x06
    1828:	02 30       	cpi	r16, 0x02	; 2
    182a:	11 f4       	brne	.+4      	; 0x1830 <prvCopyDataToQueue+0x96>
    182c:	11 11       	cpse	r17, r1
    182e:	11 50       	subi	r17, 0x01	; 1
    1830:	80 e0       	ldi	r24, 0x00	; 0
    1832:	1f 5f       	subi	r17, 0xFF	; 255
    1834:	1a 8f       	std	Y+26, r17	; 0x1a
    1836:	df 91       	pop	r29
    1838:	cf 91       	pop	r28
    183a:	1f 91       	pop	r17
    183c:	0f 91       	pop	r16
    183e:	08 95       	ret

00001840 <prvCopyDataFromQueue>:
    1840:	fc 01       	movw	r30, r24
    1842:	cb 01       	movw	r24, r22
    1844:	44 8d       	ldd	r20, Z+28	; 0x1c
    1846:	44 23       	and	r20, r20
    1848:	a1 f0       	breq	.+40     	; 0x1872 <prvCopyDataFromQueue+0x32>
    184a:	50 e0       	ldi	r21, 0x00	; 0
    184c:	26 81       	ldd	r18, Z+6	; 0x06
    184e:	37 81       	ldd	r19, Z+7	; 0x07
    1850:	24 0f       	add	r18, r20
    1852:	35 1f       	adc	r19, r21
    1854:	37 83       	std	Z+7, r19	; 0x07
    1856:	26 83       	std	Z+6, r18	; 0x06
    1858:	64 81       	ldd	r22, Z+4	; 0x04
    185a:	75 81       	ldd	r23, Z+5	; 0x05
    185c:	26 17       	cp	r18, r22
    185e:	37 07       	cpc	r19, r23
    1860:	20 f0       	brcs	.+8      	; 0x186a <prvCopyDataFromQueue+0x2a>
    1862:	20 81       	ld	r18, Z
    1864:	31 81       	ldd	r19, Z+1	; 0x01
    1866:	37 83       	std	Z+7, r19	; 0x07
    1868:	26 83       	std	Z+6, r18	; 0x06
    186a:	66 81       	ldd	r22, Z+6	; 0x06
    186c:	77 81       	ldd	r23, Z+7	; 0x07
    186e:	0c 94 53 25 	jmp	0x4aa6	; 0x4aa6 <memcpy>
    1872:	08 95       	ret

00001874 <prvUnlockQueue>:
    1874:	ef 92       	push	r14
    1876:	ff 92       	push	r15
    1878:	1f 93       	push	r17
    187a:	cf 93       	push	r28
    187c:	df 93       	push	r29
    187e:	ec 01       	movw	r28, r24
    1880:	0f b6       	in	r0, 0x3f	; 63
    1882:	f8 94       	cli
    1884:	0f 92       	push	r0
    1886:	1e 8d       	ldd	r17, Y+30	; 0x1e
    1888:	7c 01       	movw	r14, r24
    188a:	81 e1       	ldi	r24, 0x11	; 17
    188c:	e8 0e       	add	r14, r24
    188e:	f1 1c       	adc	r15, r1
    1890:	11 16       	cp	r1, r17
    1892:	5c f4       	brge	.+22     	; 0x18aa <prvUnlockQueue+0x36>
    1894:	89 89       	ldd	r24, Y+17	; 0x11
    1896:	88 23       	and	r24, r24
    1898:	41 f0       	breq	.+16     	; 0x18aa <prvUnlockQueue+0x36>
    189a:	c7 01       	movw	r24, r14
    189c:	0e 94 15 13 	call	0x262a	; 0x262a <xTaskRemoveFromEventList>
    18a0:	81 11       	cpse	r24, r1
    18a2:	0e 94 93 13 	call	0x2726	; 0x2726 <vTaskMissedYield>
    18a6:	11 50       	subi	r17, 0x01	; 1
    18a8:	f3 cf       	rjmp	.-26     	; 0x1890 <prvUnlockQueue+0x1c>
    18aa:	8f ef       	ldi	r24, 0xFF	; 255
    18ac:	8e 8f       	std	Y+30, r24	; 0x1e
    18ae:	0f 90       	pop	r0
    18b0:	0f be       	out	0x3f, r0	; 63
    18b2:	0f b6       	in	r0, 0x3f	; 63
    18b4:	f8 94       	cli
    18b6:	0f 92       	push	r0
    18b8:	1d 8d       	ldd	r17, Y+29	; 0x1d
    18ba:	7e 01       	movw	r14, r28
    18bc:	88 e0       	ldi	r24, 0x08	; 8
    18be:	e8 0e       	add	r14, r24
    18c0:	f1 1c       	adc	r15, r1
    18c2:	11 16       	cp	r1, r17
    18c4:	5c f4       	brge	.+22     	; 0x18dc <prvUnlockQueue+0x68>
    18c6:	88 85       	ldd	r24, Y+8	; 0x08
    18c8:	88 23       	and	r24, r24
    18ca:	41 f0       	breq	.+16     	; 0x18dc <prvUnlockQueue+0x68>
    18cc:	c7 01       	movw	r24, r14
    18ce:	0e 94 15 13 	call	0x262a	; 0x262a <xTaskRemoveFromEventList>
    18d2:	81 11       	cpse	r24, r1
    18d4:	0e 94 93 13 	call	0x2726	; 0x2726 <vTaskMissedYield>
    18d8:	11 50       	subi	r17, 0x01	; 1
    18da:	f3 cf       	rjmp	.-26     	; 0x18c2 <prvUnlockQueue+0x4e>
    18dc:	8f ef       	ldi	r24, 0xFF	; 255
    18de:	8d 8f       	std	Y+29, r24	; 0x1d
    18e0:	0f 90       	pop	r0
    18e2:	0f be       	out	0x3f, r0	; 63
    18e4:	df 91       	pop	r29
    18e6:	cf 91       	pop	r28
    18e8:	1f 91       	pop	r17
    18ea:	ff 90       	pop	r15
    18ec:	ef 90       	pop	r14
    18ee:	08 95       	ret

000018f0 <xQueueGenericReset>:
    18f0:	cf 93       	push	r28
    18f2:	df 93       	push	r29
    18f4:	ec 01       	movw	r28, r24
    18f6:	0f b6       	in	r0, 0x3f	; 63
    18f8:	f8 94       	cli
    18fa:	0f 92       	push	r0
    18fc:	48 81       	ld	r20, Y
    18fe:	59 81       	ldd	r21, Y+1	; 0x01
    1900:	8b 8d       	ldd	r24, Y+27	; 0x1b
    1902:	7c 8d       	ldd	r23, Y+28	; 0x1c
    1904:	9a 01       	movw	r18, r20
    1906:	87 9f       	mul	r24, r23
    1908:	20 0d       	add	r18, r0
    190a:	31 1d       	adc	r19, r1
    190c:	11 24       	eor	r1, r1
    190e:	3d 83       	std	Y+5, r19	; 0x05
    1910:	2c 83       	std	Y+4, r18	; 0x04
    1912:	1a 8e       	std	Y+26, r1	; 0x1a
    1914:	5b 83       	std	Y+3, r21	; 0x03
    1916:	4a 83       	std	Y+2, r20	; 0x02
    1918:	90 e0       	ldi	r25, 0x00	; 0
    191a:	01 97       	sbiw	r24, 0x01	; 1
    191c:	78 9f       	mul	r23, r24
    191e:	90 01       	movw	r18, r0
    1920:	79 9f       	mul	r23, r25
    1922:	30 0d       	add	r19, r0
    1924:	11 24       	eor	r1, r1
    1926:	ca 01       	movw	r24, r20
    1928:	82 0f       	add	r24, r18
    192a:	93 1f       	adc	r25, r19
    192c:	9f 83       	std	Y+7, r25	; 0x07
    192e:	8e 83       	std	Y+6, r24	; 0x06
    1930:	8f ef       	ldi	r24, 0xFF	; 255
    1932:	8d 8f       	std	Y+29, r24	; 0x1d
    1934:	8e 8f       	std	Y+30, r24	; 0x1e
    1936:	61 11       	cpse	r22, r1
    1938:	0c c0       	rjmp	.+24     	; 0x1952 <xQueueGenericReset+0x62>
    193a:	88 85       	ldd	r24, Y+8	; 0x08
    193c:	88 23       	and	r24, r24
    193e:	89 f0       	breq	.+34     	; 0x1962 <xQueueGenericReset+0x72>
    1940:	ce 01       	movw	r24, r28
    1942:	08 96       	adiw	r24, 0x08	; 8
    1944:	0e 94 15 13 	call	0x262a	; 0x262a <xTaskRemoveFromEventList>
    1948:	88 23       	and	r24, r24
    194a:	59 f0       	breq	.+22     	; 0x1962 <xQueueGenericReset+0x72>
    194c:	0e 94 09 0b 	call	0x1612	; 0x1612 <vPortYield>
    1950:	08 c0       	rjmp	.+16     	; 0x1962 <xQueueGenericReset+0x72>
    1952:	ce 01       	movw	r24, r28
    1954:	08 96       	adiw	r24, 0x08	; 8
    1956:	0e 94 d6 09 	call	0x13ac	; 0x13ac <vListInitialise>
    195a:	ce 01       	movw	r24, r28
    195c:	41 96       	adiw	r24, 0x11	; 17
    195e:	0e 94 d6 09 	call	0x13ac	; 0x13ac <vListInitialise>
    1962:	0f 90       	pop	r0
    1964:	0f be       	out	0x3f, r0	; 63
    1966:	81 e0       	ldi	r24, 0x01	; 1
    1968:	df 91       	pop	r29
    196a:	cf 91       	pop	r28
    196c:	08 95       	ret

0000196e <xQueueGenericCreate>:
    196e:	0f 93       	push	r16
    1970:	1f 93       	push	r17
    1972:	cf 93       	push	r28
    1974:	df 93       	push	r29
    1976:	08 2f       	mov	r16, r24
    1978:	16 2f       	mov	r17, r22
    197a:	66 23       	and	r22, r22
    197c:	21 f0       	breq	.+8      	; 0x1986 <xQueueGenericCreate+0x18>
    197e:	86 9f       	mul	r24, r22
    1980:	c0 01       	movw	r24, r0
    1982:	11 24       	eor	r1, r1
    1984:	02 c0       	rjmp	.+4      	; 0x198a <xQueueGenericCreate+0x1c>
    1986:	80 e0       	ldi	r24, 0x00	; 0
    1988:	90 e0       	ldi	r25, 0x00	; 0
    198a:	4f 96       	adiw	r24, 0x1f	; 31
    198c:	0e 94 b2 09 	call	0x1364	; 0x1364 <pvPortMalloc>
    1990:	ec 01       	movw	r28, r24
    1992:	00 97       	sbiw	r24, 0x00	; 0
    1994:	71 f0       	breq	.+28     	; 0x19b2 <xQueueGenericCreate+0x44>
    1996:	11 11       	cpse	r17, r1
    1998:	03 c0       	rjmp	.+6      	; 0x19a0 <xQueueGenericCreate+0x32>
    199a:	99 83       	std	Y+1, r25	; 0x01
    199c:	88 83       	st	Y, r24
    199e:	03 c0       	rjmp	.+6      	; 0x19a6 <xQueueGenericCreate+0x38>
    19a0:	4f 96       	adiw	r24, 0x1f	; 31
    19a2:	99 83       	std	Y+1, r25	; 0x01
    19a4:	88 83       	st	Y, r24
    19a6:	0b 8f       	std	Y+27, r16	; 0x1b
    19a8:	1c 8f       	std	Y+28, r17	; 0x1c
    19aa:	61 e0       	ldi	r22, 0x01	; 1
    19ac:	ce 01       	movw	r24, r28
    19ae:	0e 94 78 0c 	call	0x18f0	; 0x18f0 <xQueueGenericReset>
    19b2:	ce 01       	movw	r24, r28
    19b4:	df 91       	pop	r29
    19b6:	cf 91       	pop	r28
    19b8:	1f 91       	pop	r17
    19ba:	0f 91       	pop	r16
    19bc:	08 95       	ret

000019be <xQueueGenericSend>:
    19be:	af 92       	push	r10
    19c0:	bf 92       	push	r11
    19c2:	cf 92       	push	r12
    19c4:	df 92       	push	r13
    19c6:	ff 92       	push	r15
    19c8:	0f 93       	push	r16
    19ca:	1f 93       	push	r17
    19cc:	cf 93       	push	r28
    19ce:	df 93       	push	r29
    19d0:	00 d0       	rcall	.+0      	; 0x19d2 <xQueueGenericSend+0x14>
    19d2:	00 d0       	rcall	.+0      	; 0x19d4 <xQueueGenericSend+0x16>
    19d4:	1f 92       	push	r1
    19d6:	cd b7       	in	r28, 0x3d	; 61
    19d8:	de b7       	in	r29, 0x3e	; 62
    19da:	8c 01       	movw	r16, r24
    19dc:	6b 01       	movw	r12, r22
    19de:	5d 83       	std	Y+5, r21	; 0x05
    19e0:	4c 83       	std	Y+4, r20	; 0x04
    19e2:	f2 2e       	mov	r15, r18
    19e4:	80 e0       	ldi	r24, 0x00	; 0
    19e6:	58 01       	movw	r10, r16
    19e8:	98 e0       	ldi	r25, 0x08	; 8
    19ea:	a9 0e       	add	r10, r25
    19ec:	b1 1c       	adc	r11, r1
    19ee:	0f b6       	in	r0, 0x3f	; 63
    19f0:	f8 94       	cli
    19f2:	0f 92       	push	r0
    19f4:	f8 01       	movw	r30, r16
    19f6:	22 8d       	ldd	r18, Z+26	; 0x1a
    19f8:	93 8d       	ldd	r25, Z+27	; 0x1b
    19fa:	29 17       	cp	r18, r25
    19fc:	18 f0       	brcs	.+6      	; 0x1a04 <xQueueGenericSend+0x46>
    19fe:	f2 e0       	ldi	r31, 0x02	; 2
    1a00:	ff 12       	cpse	r15, r31
    1a02:	14 c0       	rjmp	.+40     	; 0x1a2c <xQueueGenericSend+0x6e>
    1a04:	4f 2d       	mov	r20, r15
    1a06:	b6 01       	movw	r22, r12
    1a08:	c8 01       	movw	r24, r16
    1a0a:	0e 94 cd 0b 	call	0x179a	; 0x179a <prvCopyDataToQueue>
    1a0e:	f8 01       	movw	r30, r16
    1a10:	91 89       	ldd	r25, Z+17	; 0x11
    1a12:	99 23       	and	r25, r25
    1a14:	21 f0       	breq	.+8      	; 0x1a1e <xQueueGenericSend+0x60>
    1a16:	c8 01       	movw	r24, r16
    1a18:	41 96       	adiw	r24, 0x11	; 17
    1a1a:	0e 94 15 13 	call	0x262a	; 0x262a <xTaskRemoveFromEventList>
    1a1e:	81 11       	cpse	r24, r1
    1a20:	0e 94 09 0b 	call	0x1612	; 0x1612 <vPortYield>
    1a24:	0f 90       	pop	r0
    1a26:	0f be       	out	0x3f, r0	; 63
    1a28:	81 e0       	ldi	r24, 0x01	; 1
    1a2a:	50 c0       	rjmp	.+160    	; 0x1acc <xQueueGenericSend+0x10e>
    1a2c:	2c 81       	ldd	r18, Y+4	; 0x04
    1a2e:	3d 81       	ldd	r19, Y+5	; 0x05
    1a30:	23 2b       	or	r18, r19
    1a32:	19 f4       	brne	.+6      	; 0x1a3a <xQueueGenericSend+0x7c>
    1a34:	0f 90       	pop	r0
    1a36:	0f be       	out	0x3f, r0	; 63
    1a38:	48 c0       	rjmp	.+144    	; 0x1aca <xQueueGenericSend+0x10c>
    1a3a:	81 11       	cpse	r24, r1
    1a3c:	04 c0       	rjmp	.+8      	; 0x1a46 <xQueueGenericSend+0x88>
    1a3e:	ce 01       	movw	r24, r28
    1a40:	01 96       	adiw	r24, 0x01	; 1
    1a42:	0e 94 55 13 	call	0x26aa	; 0x26aa <vTaskInternalSetTimeOutState>
    1a46:	0f 90       	pop	r0
    1a48:	0f be       	out	0x3f, r0	; 63
    1a4a:	0e 94 16 11 	call	0x222c	; 0x222c <vTaskSuspendAll>
    1a4e:	0f b6       	in	r0, 0x3f	; 63
    1a50:	f8 94       	cli
    1a52:	0f 92       	push	r0
    1a54:	f8 01       	movw	r30, r16
    1a56:	85 8d       	ldd	r24, Z+29	; 0x1d
    1a58:	8f 3f       	cpi	r24, 0xFF	; 255
    1a5a:	09 f4       	brne	.+2      	; 0x1a5e <xQueueGenericSend+0xa0>
    1a5c:	15 8e       	std	Z+29, r1	; 0x1d
    1a5e:	f8 01       	movw	r30, r16
    1a60:	86 8d       	ldd	r24, Z+30	; 0x1e
    1a62:	8f 3f       	cpi	r24, 0xFF	; 255
    1a64:	09 f4       	brne	.+2      	; 0x1a68 <xQueueGenericSend+0xaa>
    1a66:	16 8e       	std	Z+30, r1	; 0x1e
    1a68:	0f 90       	pop	r0
    1a6a:	0f be       	out	0x3f, r0	; 63
    1a6c:	be 01       	movw	r22, r28
    1a6e:	6c 5f       	subi	r22, 0xFC	; 252
    1a70:	7f 4f       	sbci	r23, 0xFF	; 255
    1a72:	ce 01       	movw	r24, r28
    1a74:	01 96       	adiw	r24, 0x01	; 1
    1a76:	0e 94 60 13 	call	0x26c0	; 0x26c0 <xTaskCheckForTimeOut>
    1a7a:	81 11       	cpse	r24, r1
    1a7c:	21 c0       	rjmp	.+66     	; 0x1ac0 <xQueueGenericSend+0x102>
    1a7e:	0f b6       	in	r0, 0x3f	; 63
    1a80:	f8 94       	cli
    1a82:	0f 92       	push	r0
    1a84:	f8 01       	movw	r30, r16
    1a86:	92 8d       	ldd	r25, Z+26	; 0x1a
    1a88:	83 8d       	ldd	r24, Z+27	; 0x1b
    1a8a:	0f 90       	pop	r0
    1a8c:	0f be       	out	0x3f, r0	; 63
    1a8e:	98 13       	cpse	r25, r24
    1a90:	11 c0       	rjmp	.+34     	; 0x1ab4 <xQueueGenericSend+0xf6>
    1a92:	6c 81       	ldd	r22, Y+4	; 0x04
    1a94:	7d 81       	ldd	r23, Y+5	; 0x05
    1a96:	c5 01       	movw	r24, r10
    1a98:	0e 94 ec 12 	call	0x25d8	; 0x25d8 <vTaskPlaceOnEventList>
    1a9c:	c8 01       	movw	r24, r16
    1a9e:	0e 94 3a 0c 	call	0x1874	; 0x1874 <prvUnlockQueue>
    1aa2:	0e 94 d2 11 	call	0x23a4	; 0x23a4 <xTaskResumeAll>
    1aa6:	88 23       	and	r24, r24
    1aa8:	11 f0       	breq	.+4      	; 0x1aae <xQueueGenericSend+0xf0>
    1aaa:	81 e0       	ldi	r24, 0x01	; 1
    1aac:	a0 cf       	rjmp	.-192    	; 0x19ee <xQueueGenericSend+0x30>
    1aae:	0e 94 09 0b 	call	0x1612	; 0x1612 <vPortYield>
    1ab2:	fb cf       	rjmp	.-10     	; 0x1aaa <xQueueGenericSend+0xec>
    1ab4:	c8 01       	movw	r24, r16
    1ab6:	0e 94 3a 0c 	call	0x1874	; 0x1874 <prvUnlockQueue>
    1aba:	0e 94 d2 11 	call	0x23a4	; 0x23a4 <xTaskResumeAll>
    1abe:	f5 cf       	rjmp	.-22     	; 0x1aaa <xQueueGenericSend+0xec>
    1ac0:	c8 01       	movw	r24, r16
    1ac2:	0e 94 3a 0c 	call	0x1874	; 0x1874 <prvUnlockQueue>
    1ac6:	0e 94 d2 11 	call	0x23a4	; 0x23a4 <xTaskResumeAll>
    1aca:	80 e0       	ldi	r24, 0x00	; 0
    1acc:	0f 90       	pop	r0
    1ace:	0f 90       	pop	r0
    1ad0:	0f 90       	pop	r0
    1ad2:	0f 90       	pop	r0
    1ad4:	0f 90       	pop	r0
    1ad6:	df 91       	pop	r29
    1ad8:	cf 91       	pop	r28
    1ada:	1f 91       	pop	r17
    1adc:	0f 91       	pop	r16
    1ade:	ff 90       	pop	r15
    1ae0:	df 90       	pop	r13
    1ae2:	cf 90       	pop	r12
    1ae4:	bf 90       	pop	r11
    1ae6:	af 90       	pop	r10
    1ae8:	08 95       	ret

00001aea <xQueueGenericSendFromISR>:
    1aea:	ef 92       	push	r14
    1aec:	ff 92       	push	r15
    1aee:	1f 93       	push	r17
    1af0:	cf 93       	push	r28
    1af2:	df 93       	push	r29
    1af4:	ec 01       	movw	r28, r24
    1af6:	9a 8d       	ldd	r25, Y+26	; 0x1a
    1af8:	8b 8d       	ldd	r24, Y+27	; 0x1b
    1afa:	98 17       	cp	r25, r24
    1afc:	10 f0       	brcs	.+4      	; 0x1b02 <xQueueGenericSendFromISR+0x18>
    1afe:	22 30       	cpi	r18, 0x02	; 2
    1b00:	e1 f4       	brne	.+56     	; 0x1b3a <xQueueGenericSendFromISR+0x50>
    1b02:	7a 01       	movw	r14, r20
    1b04:	1e 8d       	ldd	r17, Y+30	; 0x1e
    1b06:	42 2f       	mov	r20, r18
    1b08:	ce 01       	movw	r24, r28
    1b0a:	0e 94 cd 0b 	call	0x179a	; 0x179a <prvCopyDataToQueue>
    1b0e:	1f 3f       	cpi	r17, 0xFF	; 255
    1b10:	81 f4       	brne	.+32     	; 0x1b32 <xQueueGenericSendFromISR+0x48>
    1b12:	89 89       	ldd	r24, Y+17	; 0x11
    1b14:	88 23       	and	r24, r24
    1b16:	79 f0       	breq	.+30     	; 0x1b36 <xQueueGenericSendFromISR+0x4c>
    1b18:	ce 01       	movw	r24, r28
    1b1a:	41 96       	adiw	r24, 0x11	; 17
    1b1c:	0e 94 15 13 	call	0x262a	; 0x262a <xTaskRemoveFromEventList>
    1b20:	88 23       	and	r24, r24
    1b22:	49 f0       	breq	.+18     	; 0x1b36 <xQueueGenericSendFromISR+0x4c>
    1b24:	e1 14       	cp	r14, r1
    1b26:	f1 04       	cpc	r15, r1
    1b28:	31 f0       	breq	.+12     	; 0x1b36 <xQueueGenericSendFromISR+0x4c>
    1b2a:	81 e0       	ldi	r24, 0x01	; 1
    1b2c:	f7 01       	movw	r30, r14
    1b2e:	80 83       	st	Z, r24
    1b30:	05 c0       	rjmp	.+10     	; 0x1b3c <xQueueGenericSendFromISR+0x52>
    1b32:	1f 5f       	subi	r17, 0xFF	; 255
    1b34:	1e 8f       	std	Y+30, r17	; 0x1e
    1b36:	81 e0       	ldi	r24, 0x01	; 1
    1b38:	01 c0       	rjmp	.+2      	; 0x1b3c <xQueueGenericSendFromISR+0x52>
    1b3a:	80 e0       	ldi	r24, 0x00	; 0
    1b3c:	df 91       	pop	r29
    1b3e:	cf 91       	pop	r28
    1b40:	1f 91       	pop	r17
    1b42:	ff 90       	pop	r15
    1b44:	ef 90       	pop	r14
    1b46:	08 95       	ret

00001b48 <xQueueGiveFromISR>:
    1b48:	cf 93       	push	r28
    1b4a:	df 93       	push	r29
    1b4c:	fc 01       	movw	r30, r24
    1b4e:	92 8d       	ldd	r25, Z+26	; 0x1a
    1b50:	83 8d       	ldd	r24, Z+27	; 0x1b
    1b52:	98 17       	cp	r25, r24
    1b54:	c0 f4       	brcc	.+48     	; 0x1b86 <xQueueGiveFromISR+0x3e>
    1b56:	86 8d       	ldd	r24, Z+30	; 0x1e
    1b58:	9f 5f       	subi	r25, 0xFF	; 255
    1b5a:	92 8f       	std	Z+26, r25	; 0x1a
    1b5c:	8f 3f       	cpi	r24, 0xFF	; 255
    1b5e:	79 f4       	brne	.+30     	; 0x1b7e <xQueueGiveFromISR+0x36>
    1b60:	81 89       	ldd	r24, Z+17	; 0x11
    1b62:	88 23       	and	r24, r24
    1b64:	71 f0       	breq	.+28     	; 0x1b82 <xQueueGiveFromISR+0x3a>
    1b66:	eb 01       	movw	r28, r22
    1b68:	cf 01       	movw	r24, r30
    1b6a:	41 96       	adiw	r24, 0x11	; 17
    1b6c:	0e 94 15 13 	call	0x262a	; 0x262a <xTaskRemoveFromEventList>
    1b70:	88 23       	and	r24, r24
    1b72:	39 f0       	breq	.+14     	; 0x1b82 <xQueueGiveFromISR+0x3a>
    1b74:	20 97       	sbiw	r28, 0x00	; 0
    1b76:	29 f0       	breq	.+10     	; 0x1b82 <xQueueGiveFromISR+0x3a>
    1b78:	81 e0       	ldi	r24, 0x01	; 1
    1b7a:	88 83       	st	Y, r24
    1b7c:	05 c0       	rjmp	.+10     	; 0x1b88 <xQueueGiveFromISR+0x40>
    1b7e:	8f 5f       	subi	r24, 0xFF	; 255
    1b80:	86 8f       	std	Z+30, r24	; 0x1e
    1b82:	81 e0       	ldi	r24, 0x01	; 1
    1b84:	01 c0       	rjmp	.+2      	; 0x1b88 <xQueueGiveFromISR+0x40>
    1b86:	80 e0       	ldi	r24, 0x00	; 0
    1b88:	df 91       	pop	r29
    1b8a:	cf 91       	pop	r28
    1b8c:	08 95       	ret

00001b8e <xQueueReceive>:
    1b8e:	af 92       	push	r10
    1b90:	bf 92       	push	r11
    1b92:	cf 92       	push	r12
    1b94:	df 92       	push	r13
    1b96:	ff 92       	push	r15
    1b98:	0f 93       	push	r16
    1b9a:	1f 93       	push	r17
    1b9c:	cf 93       	push	r28
    1b9e:	df 93       	push	r29
    1ba0:	00 d0       	rcall	.+0      	; 0x1ba2 <xQueueReceive+0x14>
    1ba2:	00 d0       	rcall	.+0      	; 0x1ba4 <xQueueReceive+0x16>
    1ba4:	1f 92       	push	r1
    1ba6:	cd b7       	in	r28, 0x3d	; 61
    1ba8:	de b7       	in	r29, 0x3e	; 62
    1baa:	8c 01       	movw	r16, r24
    1bac:	6b 01       	movw	r12, r22
    1bae:	5d 83       	std	Y+5, r21	; 0x05
    1bb0:	4c 83       	std	Y+4, r20	; 0x04
    1bb2:	80 e0       	ldi	r24, 0x00	; 0
    1bb4:	58 01       	movw	r10, r16
    1bb6:	91 e1       	ldi	r25, 0x11	; 17
    1bb8:	a9 0e       	add	r10, r25
    1bba:	b1 1c       	adc	r11, r1
    1bbc:	0f b6       	in	r0, 0x3f	; 63
    1bbe:	f8 94       	cli
    1bc0:	0f 92       	push	r0
    1bc2:	f8 01       	movw	r30, r16
    1bc4:	f2 8c       	ldd	r15, Z+26	; 0x1a
    1bc6:	ff 20       	and	r15, r15
    1bc8:	a9 f0       	breq	.+42     	; 0x1bf4 <xQueueReceive+0x66>
    1bca:	b6 01       	movw	r22, r12
    1bcc:	c8 01       	movw	r24, r16
    1bce:	0e 94 20 0c 	call	0x1840	; 0x1840 <prvCopyDataFromQueue>
    1bd2:	fa 94       	dec	r15
    1bd4:	f8 01       	movw	r30, r16
    1bd6:	f2 8e       	std	Z+26, r15	; 0x1a
    1bd8:	80 85       	ldd	r24, Z+8	; 0x08
    1bda:	88 23       	and	r24, r24
    1bdc:	39 f0       	breq	.+14     	; 0x1bec <xQueueReceive+0x5e>
    1bde:	c8 01       	movw	r24, r16
    1be0:	08 96       	adiw	r24, 0x08	; 8
    1be2:	0e 94 15 13 	call	0x262a	; 0x262a <xTaskRemoveFromEventList>
    1be6:	81 11       	cpse	r24, r1
    1be8:	0e 94 09 0b 	call	0x1612	; 0x1612 <vPortYield>
    1bec:	0f 90       	pop	r0
    1bee:	0f be       	out	0x3f, r0	; 63
    1bf0:	81 e0       	ldi	r24, 0x01	; 1
    1bf2:	50 c0       	rjmp	.+160    	; 0x1c94 <xQueueReceive+0x106>
    1bf4:	2c 81       	ldd	r18, Y+4	; 0x04
    1bf6:	3d 81       	ldd	r19, Y+5	; 0x05
    1bf8:	23 2b       	or	r18, r19
    1bfa:	19 f4       	brne	.+6      	; 0x1c02 <xQueueReceive+0x74>
    1bfc:	0f 90       	pop	r0
    1bfe:	0f be       	out	0x3f, r0	; 63
    1c00:	48 c0       	rjmp	.+144    	; 0x1c92 <xQueueReceive+0x104>
    1c02:	81 11       	cpse	r24, r1
    1c04:	04 c0       	rjmp	.+8      	; 0x1c0e <xQueueReceive+0x80>
    1c06:	ce 01       	movw	r24, r28
    1c08:	01 96       	adiw	r24, 0x01	; 1
    1c0a:	0e 94 55 13 	call	0x26aa	; 0x26aa <vTaskInternalSetTimeOutState>
    1c0e:	0f 90       	pop	r0
    1c10:	0f be       	out	0x3f, r0	; 63
    1c12:	0e 94 16 11 	call	0x222c	; 0x222c <vTaskSuspendAll>
    1c16:	0f b6       	in	r0, 0x3f	; 63
    1c18:	f8 94       	cli
    1c1a:	0f 92       	push	r0
    1c1c:	f8 01       	movw	r30, r16
    1c1e:	85 8d       	ldd	r24, Z+29	; 0x1d
    1c20:	8f 3f       	cpi	r24, 0xFF	; 255
    1c22:	09 f4       	brne	.+2      	; 0x1c26 <xQueueReceive+0x98>
    1c24:	15 8e       	std	Z+29, r1	; 0x1d
    1c26:	f8 01       	movw	r30, r16
    1c28:	86 8d       	ldd	r24, Z+30	; 0x1e
    1c2a:	8f 3f       	cpi	r24, 0xFF	; 255
    1c2c:	09 f4       	brne	.+2      	; 0x1c30 <xQueueReceive+0xa2>
    1c2e:	16 8e       	std	Z+30, r1	; 0x1e
    1c30:	0f 90       	pop	r0
    1c32:	0f be       	out	0x3f, r0	; 63
    1c34:	be 01       	movw	r22, r28
    1c36:	6c 5f       	subi	r22, 0xFC	; 252
    1c38:	7f 4f       	sbci	r23, 0xFF	; 255
    1c3a:	ce 01       	movw	r24, r28
    1c3c:	01 96       	adiw	r24, 0x01	; 1
    1c3e:	0e 94 60 13 	call	0x26c0	; 0x26c0 <xTaskCheckForTimeOut>
    1c42:	81 11       	cpse	r24, r1
    1c44:	1c c0       	rjmp	.+56     	; 0x1c7e <xQueueReceive+0xf0>
    1c46:	c8 01       	movw	r24, r16
    1c48:	0e 94 c2 0b 	call	0x1784	; 0x1784 <prvIsQueueEmpty>
    1c4c:	88 23       	and	r24, r24
    1c4e:	89 f0       	breq	.+34     	; 0x1c72 <xQueueReceive+0xe4>
    1c50:	6c 81       	ldd	r22, Y+4	; 0x04
    1c52:	7d 81       	ldd	r23, Y+5	; 0x05
    1c54:	c5 01       	movw	r24, r10
    1c56:	0e 94 ec 12 	call	0x25d8	; 0x25d8 <vTaskPlaceOnEventList>
    1c5a:	c8 01       	movw	r24, r16
    1c5c:	0e 94 3a 0c 	call	0x1874	; 0x1874 <prvUnlockQueue>
    1c60:	0e 94 d2 11 	call	0x23a4	; 0x23a4 <xTaskResumeAll>
    1c64:	88 23       	and	r24, r24
    1c66:	11 f0       	breq	.+4      	; 0x1c6c <xQueueReceive+0xde>
    1c68:	81 e0       	ldi	r24, 0x01	; 1
    1c6a:	a8 cf       	rjmp	.-176    	; 0x1bbc <xQueueReceive+0x2e>
    1c6c:	0e 94 09 0b 	call	0x1612	; 0x1612 <vPortYield>
    1c70:	fb cf       	rjmp	.-10     	; 0x1c68 <xQueueReceive+0xda>
    1c72:	c8 01       	movw	r24, r16
    1c74:	0e 94 3a 0c 	call	0x1874	; 0x1874 <prvUnlockQueue>
    1c78:	0e 94 d2 11 	call	0x23a4	; 0x23a4 <xTaskResumeAll>
    1c7c:	f5 cf       	rjmp	.-22     	; 0x1c68 <xQueueReceive+0xda>
    1c7e:	c8 01       	movw	r24, r16
    1c80:	0e 94 3a 0c 	call	0x1874	; 0x1874 <prvUnlockQueue>
    1c84:	0e 94 d2 11 	call	0x23a4	; 0x23a4 <xTaskResumeAll>
    1c88:	c8 01       	movw	r24, r16
    1c8a:	0e 94 c2 0b 	call	0x1784	; 0x1784 <prvIsQueueEmpty>
    1c8e:	88 23       	and	r24, r24
    1c90:	59 f3       	breq	.-42     	; 0x1c68 <xQueueReceive+0xda>
    1c92:	80 e0       	ldi	r24, 0x00	; 0
    1c94:	0f 90       	pop	r0
    1c96:	0f 90       	pop	r0
    1c98:	0f 90       	pop	r0
    1c9a:	0f 90       	pop	r0
    1c9c:	0f 90       	pop	r0
    1c9e:	df 91       	pop	r29
    1ca0:	cf 91       	pop	r28
    1ca2:	1f 91       	pop	r17
    1ca4:	0f 91       	pop	r16
    1ca6:	ff 90       	pop	r15
    1ca8:	df 90       	pop	r13
    1caa:	cf 90       	pop	r12
    1cac:	bf 90       	pop	r11
    1cae:	af 90       	pop	r10
    1cb0:	08 95       	ret

00001cb2 <xQueueSemaphoreTake>:
    1cb2:	cf 92       	push	r12
    1cb4:	df 92       	push	r13
    1cb6:	ff 92       	push	r15
    1cb8:	0f 93       	push	r16
    1cba:	1f 93       	push	r17
    1cbc:	cf 93       	push	r28
    1cbe:	df 93       	push	r29
    1cc0:	00 d0       	rcall	.+0      	; 0x1cc2 <xQueueSemaphoreTake+0x10>
    1cc2:	00 d0       	rcall	.+0      	; 0x1cc4 <xQueueSemaphoreTake+0x12>
    1cc4:	1f 92       	push	r1
    1cc6:	cd b7       	in	r28, 0x3d	; 61
    1cc8:	de b7       	in	r29, 0x3e	; 62
    1cca:	8c 01       	movw	r16, r24
    1ccc:	7d 83       	std	Y+5, r23	; 0x05
    1cce:	6c 83       	std	Y+4, r22	; 0x04
    1cd0:	f1 2c       	mov	r15, r1
    1cd2:	90 e0       	ldi	r25, 0x00	; 0
    1cd4:	68 01       	movw	r12, r16
    1cd6:	81 e1       	ldi	r24, 0x11	; 17
    1cd8:	c8 0e       	add	r12, r24
    1cda:	d1 1c       	adc	r13, r1
    1cdc:	0f b6       	in	r0, 0x3f	; 63
    1cde:	f8 94       	cli
    1ce0:	0f 92       	push	r0
    1ce2:	d8 01       	movw	r26, r16
    1ce4:	5a 96       	adiw	r26, 0x1a	; 26
    1ce6:	8c 91       	ld	r24, X
    1ce8:	5a 97       	sbiw	r26, 0x1a	; 26
    1cea:	88 23       	and	r24, r24
    1cec:	e9 f0       	breq	.+58     	; 0x1d28 <xQueueSemaphoreTake+0x76>
    1cee:	81 50       	subi	r24, 0x01	; 1
    1cf0:	5a 96       	adiw	r26, 0x1a	; 26
    1cf2:	8c 93       	st	X, r24
    1cf4:	5a 97       	sbiw	r26, 0x1a	; 26
    1cf6:	8d 91       	ld	r24, X+
    1cf8:	9c 91       	ld	r25, X
    1cfa:	89 2b       	or	r24, r25
    1cfc:	29 f4       	brne	.+10     	; 0x1d08 <xQueueSemaphoreTake+0x56>
    1cfe:	0e 94 89 14 	call	0x2912	; 0x2912 <pvTaskIncrementMutexHeldCount>
    1d02:	f8 01       	movw	r30, r16
    1d04:	95 83       	std	Z+5, r25	; 0x05
    1d06:	84 83       	std	Z+4, r24	; 0x04
    1d08:	d8 01       	movw	r26, r16
    1d0a:	18 96       	adiw	r26, 0x08	; 8
    1d0c:	8c 91       	ld	r24, X
    1d0e:	88 23       	and	r24, r24
    1d10:	39 f0       	breq	.+14     	; 0x1d20 <xQueueSemaphoreTake+0x6e>
    1d12:	c8 01       	movw	r24, r16
    1d14:	08 96       	adiw	r24, 0x08	; 8
    1d16:	0e 94 15 13 	call	0x262a	; 0x262a <xTaskRemoveFromEventList>
    1d1a:	81 11       	cpse	r24, r1
    1d1c:	0e 94 09 0b 	call	0x1612	; 0x1612 <vPortYield>
    1d20:	0f 90       	pop	r0
    1d22:	0f be       	out	0x3f, r0	; 63
    1d24:	81 e0       	ldi	r24, 0x01	; 1
    1d26:	7a c0       	rjmp	.+244    	; 0x1e1c <xQueueSemaphoreTake+0x16a>
    1d28:	2c 81       	ldd	r18, Y+4	; 0x04
    1d2a:	3d 81       	ldd	r19, Y+5	; 0x05
    1d2c:	23 2b       	or	r18, r19
    1d2e:	09 f4       	brne	.+2      	; 0x1d32 <xQueueSemaphoreTake+0x80>
    1d30:	72 c0       	rjmp	.+228    	; 0x1e16 <xQueueSemaphoreTake+0x164>
    1d32:	91 11       	cpse	r25, r1
    1d34:	04 c0       	rjmp	.+8      	; 0x1d3e <xQueueSemaphoreTake+0x8c>
    1d36:	ce 01       	movw	r24, r28
    1d38:	01 96       	adiw	r24, 0x01	; 1
    1d3a:	0e 94 55 13 	call	0x26aa	; 0x26aa <vTaskInternalSetTimeOutState>
    1d3e:	0f 90       	pop	r0
    1d40:	0f be       	out	0x3f, r0	; 63
    1d42:	0e 94 16 11 	call	0x222c	; 0x222c <vTaskSuspendAll>
    1d46:	0f b6       	in	r0, 0x3f	; 63
    1d48:	f8 94       	cli
    1d4a:	0f 92       	push	r0
    1d4c:	f8 01       	movw	r30, r16
    1d4e:	85 8d       	ldd	r24, Z+29	; 0x1d
    1d50:	8f 3f       	cpi	r24, 0xFF	; 255
    1d52:	09 f4       	brne	.+2      	; 0x1d56 <xQueueSemaphoreTake+0xa4>
    1d54:	15 8e       	std	Z+29, r1	; 0x1d
    1d56:	d8 01       	movw	r26, r16
    1d58:	5e 96       	adiw	r26, 0x1e	; 30
    1d5a:	8c 91       	ld	r24, X
    1d5c:	5e 97       	sbiw	r26, 0x1e	; 30
    1d5e:	8f 3f       	cpi	r24, 0xFF	; 255
    1d60:	11 f4       	brne	.+4      	; 0x1d66 <xQueueSemaphoreTake+0xb4>
    1d62:	5e 96       	adiw	r26, 0x1e	; 30
    1d64:	1c 92       	st	X, r1
    1d66:	0f 90       	pop	r0
    1d68:	0f be       	out	0x3f, r0	; 63
    1d6a:	be 01       	movw	r22, r28
    1d6c:	6c 5f       	subi	r22, 0xFC	; 252
    1d6e:	7f 4f       	sbci	r23, 0xFF	; 255
    1d70:	ce 01       	movw	r24, r28
    1d72:	01 96       	adiw	r24, 0x01	; 1
    1d74:	0e 94 60 13 	call	0x26c0	; 0x26c0 <xTaskCheckForTimeOut>
    1d78:	81 11       	cpse	r24, r1
    1d7a:	2b c0       	rjmp	.+86     	; 0x1dd2 <xQueueSemaphoreTake+0x120>
    1d7c:	c8 01       	movw	r24, r16
    1d7e:	0e 94 c2 0b 	call	0x1784	; 0x1784 <prvIsQueueEmpty>
    1d82:	88 23       	and	r24, r24
    1d84:	01 f1       	breq	.+64     	; 0x1dc6 <xQueueSemaphoreTake+0x114>
    1d86:	f8 01       	movw	r30, r16
    1d88:	80 81       	ld	r24, Z
    1d8a:	91 81       	ldd	r25, Z+1	; 0x01
    1d8c:	89 2b       	or	r24, r25
    1d8e:	51 f4       	brne	.+20     	; 0x1da4 <xQueueSemaphoreTake+0xf2>
    1d90:	0f b6       	in	r0, 0x3f	; 63
    1d92:	f8 94       	cli
    1d94:	0f 92       	push	r0
    1d96:	84 81       	ldd	r24, Z+4	; 0x04
    1d98:	95 81       	ldd	r25, Z+5	; 0x05
    1d9a:	0e 94 a5 13 	call	0x274a	; 0x274a <xTaskPriorityInherit>
    1d9e:	f8 2e       	mov	r15, r24
    1da0:	0f 90       	pop	r0
    1da2:	0f be       	out	0x3f, r0	; 63
    1da4:	6c 81       	ldd	r22, Y+4	; 0x04
    1da6:	7d 81       	ldd	r23, Y+5	; 0x05
    1da8:	c6 01       	movw	r24, r12
    1daa:	0e 94 ec 12 	call	0x25d8	; 0x25d8 <vTaskPlaceOnEventList>
    1dae:	c8 01       	movw	r24, r16
    1db0:	0e 94 3a 0c 	call	0x1874	; 0x1874 <prvUnlockQueue>
    1db4:	0e 94 d2 11 	call	0x23a4	; 0x23a4 <xTaskResumeAll>
    1db8:	88 23       	and	r24, r24
    1dba:	11 f0       	breq	.+4      	; 0x1dc0 <xQueueSemaphoreTake+0x10e>
    1dbc:	91 e0       	ldi	r25, 0x01	; 1
    1dbe:	8e cf       	rjmp	.-228    	; 0x1cdc <xQueueSemaphoreTake+0x2a>
    1dc0:	0e 94 09 0b 	call	0x1612	; 0x1612 <vPortYield>
    1dc4:	fb cf       	rjmp	.-10     	; 0x1dbc <xQueueSemaphoreTake+0x10a>
    1dc6:	c8 01       	movw	r24, r16
    1dc8:	0e 94 3a 0c 	call	0x1874	; 0x1874 <prvUnlockQueue>
    1dcc:	0e 94 d2 11 	call	0x23a4	; 0x23a4 <xTaskResumeAll>
    1dd0:	f5 cf       	rjmp	.-22     	; 0x1dbc <xQueueSemaphoreTake+0x10a>
    1dd2:	c8 01       	movw	r24, r16
    1dd4:	0e 94 3a 0c 	call	0x1874	; 0x1874 <prvUnlockQueue>
    1dd8:	0e 94 d2 11 	call	0x23a4	; 0x23a4 <xTaskResumeAll>
    1ddc:	c8 01       	movw	r24, r16
    1dde:	0e 94 c2 0b 	call	0x1784	; 0x1784 <prvIsQueueEmpty>
    1de2:	88 23       	and	r24, r24
    1de4:	59 f3       	breq	.-42     	; 0x1dbc <xQueueSemaphoreTake+0x10a>
    1de6:	ff 20       	and	r15, r15
    1de8:	c1 f0       	breq	.+48     	; 0x1e1a <xQueueSemaphoreTake+0x168>
    1dea:	0f b6       	in	r0, 0x3f	; 63
    1dec:	f8 94       	cli
    1dee:	0f 92       	push	r0
    1df0:	f8 01       	movw	r30, r16
    1df2:	81 89       	ldd	r24, Z+17	; 0x11
    1df4:	88 23       	and	r24, r24
    1df6:	39 f0       	breq	.+14     	; 0x1e06 <xQueueSemaphoreTake+0x154>
    1df8:	06 88       	ldd	r0, Z+22	; 0x16
    1dfa:	f7 89       	ldd	r31, Z+23	; 0x17
    1dfc:	e0 2d       	mov	r30, r0
    1dfe:	80 81       	ld	r24, Z
    1e00:	64 e0       	ldi	r22, 0x04	; 4
    1e02:	68 1b       	sub	r22, r24
    1e04:	01 c0       	rjmp	.+2      	; 0x1e08 <xQueueSemaphoreTake+0x156>
    1e06:	60 e0       	ldi	r22, 0x00	; 0
    1e08:	d8 01       	movw	r26, r16
    1e0a:	14 96       	adiw	r26, 0x04	; 4
    1e0c:	8d 91       	ld	r24, X+
    1e0e:	9c 91       	ld	r25, X
    1e10:	15 97       	sbiw	r26, 0x05	; 5
    1e12:	0e 94 42 14 	call	0x2884	; 0x2884 <vTaskPriorityDisinheritAfterTimeout>
    1e16:	0f 90       	pop	r0
    1e18:	0f be       	out	0x3f, r0	; 63
    1e1a:	80 e0       	ldi	r24, 0x00	; 0
    1e1c:	0f 90       	pop	r0
    1e1e:	0f 90       	pop	r0
    1e20:	0f 90       	pop	r0
    1e22:	0f 90       	pop	r0
    1e24:	0f 90       	pop	r0
    1e26:	df 91       	pop	r29
    1e28:	cf 91       	pop	r28
    1e2a:	1f 91       	pop	r17
    1e2c:	0f 91       	pop	r16
    1e2e:	ff 90       	pop	r15
    1e30:	df 90       	pop	r13
    1e32:	cf 90       	pop	r12
    1e34:	08 95       	ret

00001e36 <vQueueWaitForMessageRestricted>:
/*-----------------------------------------------------------*/

#if ( configUSE_TIMERS == 1 )

    void vQueueWaitForMessageRestricted( QueueHandle_t xQueue, TickType_t xTicksToWait, const BaseType_t xWaitIndefinitely )
    {
    1e36:	cf 93       	push	r28
    1e38:	df 93       	push	r29
    1e3a:	ec 01       	movw	r28, r24
        will not actually cause the task to block, just place it on a blocked
        list.  It will not block until the scheduler is unlocked - at which
        time a yield will be performed.  If an item is added to the queue while
        the queue is locked, and the calling task blocks on the queue, then the
        calling task will be immediately unblocked when the queue is unlocked. */
        prvLockQueue( pxQueue );
    1e3c:	0f b6       	in	r0, 0x3f	; 63
    1e3e:	f8 94       	cli
    1e40:	0f 92       	push	r0
    1e42:	8d 8d       	ldd	r24, Y+29	; 0x1d
    1e44:	8f 3f       	cpi	r24, 0xFF	; 255
    1e46:	09 f4       	brne	.+2      	; 0x1e4a <vQueueWaitForMessageRestricted+0x14>
    1e48:	1d 8e       	std	Y+29, r1	; 0x1d
    1e4a:	8e 8d       	ldd	r24, Y+30	; 0x1e
    1e4c:	8f 3f       	cpi	r24, 0xFF	; 255
    1e4e:	09 f4       	brne	.+2      	; 0x1e52 <vQueueWaitForMessageRestricted+0x1c>
    1e50:	1e 8e       	std	Y+30, r1	; 0x1e
    1e52:	0f 90       	pop	r0
    1e54:	0f be       	out	0x3f, r0	; 63
        if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0U )
    1e56:	8a 8d       	ldd	r24, Y+26	; 0x1a
    1e58:	81 11       	cpse	r24, r1
    1e5a:	04 c0       	rjmp	.+8      	; 0x1e64 <vQueueWaitForMessageRestricted+0x2e>
        {
            /* There is nothing in the queue, block for the specified period. */
            vTaskPlaceOnEventListRestricted( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait, xWaitIndefinitely );
    1e5c:	ce 01       	movw	r24, r28
    1e5e:	41 96       	adiw	r24, 0x11	; 17
    1e60:	0e 94 fd 12 	call	0x25fa	; 0x25fa <vTaskPlaceOnEventListRestricted>
        }
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }
        prvUnlockQueue( pxQueue );
    1e64:	ce 01       	movw	r24, r28
    }
    1e66:	df 91       	pop	r29
    1e68:	cf 91       	pop	r28
        }
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }
        prvUnlockQueue( pxQueue );
    1e6a:	0c 94 3a 0c 	jmp	0x1874	; 0x1874 <prvUnlockQueue>

00001e6e <prvResetNextTaskUnblockTime>:
    /* Reset the event list item to its normal value - so it can be used with
    queues and semaphores. */
    listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */

    return uxReturn;
}
    1e6e:	e0 91 fe 03 	lds	r30, 0x03FE	; 0x8003fe <pxDelayedTaskList>
    1e72:	f0 91 ff 03 	lds	r31, 0x03FF	; 0x8003ff <pxDelayedTaskList+0x1>
    1e76:	80 81       	ld	r24, Z
    1e78:	81 11       	cpse	r24, r1
    1e7a:	03 c0       	rjmp	.+6      	; 0x1e82 <prvResetNextTaskUnblockTime+0x14>
    1e7c:	8f ef       	ldi	r24, 0xFF	; 255
    1e7e:	9f ef       	ldi	r25, 0xFF	; 255
    1e80:	0c c0       	rjmp	.+24     	; 0x1e9a <prvResetNextTaskUnblockTime+0x2c>
    1e82:	e0 91 fe 03 	lds	r30, 0x03FE	; 0x8003fe <pxDelayedTaskList>
    1e86:	f0 91 ff 03 	lds	r31, 0x03FF	; 0x8003ff <pxDelayedTaskList+0x1>
    1e8a:	05 80       	ldd	r0, Z+5	; 0x05
    1e8c:	f6 81       	ldd	r31, Z+6	; 0x06
    1e8e:	e0 2d       	mov	r30, r0
    1e90:	06 80       	ldd	r0, Z+6	; 0x06
    1e92:	f7 81       	ldd	r31, Z+7	; 0x07
    1e94:	e0 2d       	mov	r30, r0
    1e96:	82 81       	ldd	r24, Z+2	; 0x02
    1e98:	93 81       	ldd	r25, Z+3	; 0x03
    1e9a:	90 93 d6 03 	sts	0x03D6, r25	; 0x8003d6 <xNextTaskUnblockTime+0x1>
    1e9e:	80 93 d5 03 	sts	0x03D5, r24	; 0x8003d5 <xNextTaskUnblockTime>
    1ea2:	08 95       	ret

00001ea4 <prvAddCurrentTaskToDelayedList>:
    1ea4:	ff 92       	push	r15
    1ea6:	0f 93       	push	r16
    1ea8:	1f 93       	push	r17
    1eaa:	cf 93       	push	r28
    1eac:	df 93       	push	r29
    1eae:	ec 01       	movw	r28, r24
    1eb0:	f6 2e       	mov	r15, r22
    1eb2:	00 91 dd 03 	lds	r16, 0x03DD	; 0x8003dd <xTickCount>
    1eb6:	10 91 de 03 	lds	r17, 0x03DE	; 0x8003de <xTickCount+0x1>
    1eba:	80 91 36 04 	lds	r24, 0x0436	; 0x800436 <pxCurrentTCB>
    1ebe:	90 91 37 04 	lds	r25, 0x0437	; 0x800437 <pxCurrentTCB+0x1>
    1ec2:	02 96       	adiw	r24, 0x02	; 2
    1ec4:	0e 94 41 0a 	call	0x1482	; 0x1482 <uxListRemove>
    1ec8:	cf 3f       	cpi	r28, 0xFF	; 255
    1eca:	8f ef       	ldi	r24, 0xFF	; 255
    1ecc:	d8 07       	cpc	r29, r24
    1ece:	89 f4       	brne	.+34     	; 0x1ef2 <prvAddCurrentTaskToDelayedList+0x4e>
    1ed0:	ff 20       	and	r15, r15
    1ed2:	79 f0       	breq	.+30     	; 0x1ef2 <prvAddCurrentTaskToDelayedList+0x4e>
    1ed4:	60 91 36 04 	lds	r22, 0x0436	; 0x800436 <pxCurrentTCB>
    1ed8:	70 91 37 04 	lds	r23, 0x0437	; 0x800437 <pxCurrentTCB+0x1>
    1edc:	6e 5f       	subi	r22, 0xFE	; 254
    1ede:	7f 4f       	sbci	r23, 0xFF	; 255
    1ee0:	80 ee       	ldi	r24, 0xE0	; 224
    1ee2:	93 e0       	ldi	r25, 0x03	; 3
    1ee4:	df 91       	pop	r29
    1ee6:	cf 91       	pop	r28
    1ee8:	1f 91       	pop	r17
    1eea:	0f 91       	pop	r16
    1eec:	ff 90       	pop	r15
    1eee:	0c 94 e8 09 	jmp	0x13d0	; 0x13d0 <vListInsertEnd>
    1ef2:	c0 0f       	add	r28, r16
    1ef4:	d1 1f       	adc	r29, r17
    1ef6:	e0 91 36 04 	lds	r30, 0x0436	; 0x800436 <pxCurrentTCB>
    1efa:	f0 91 37 04 	lds	r31, 0x0437	; 0x800437 <pxCurrentTCB+0x1>
    1efe:	d3 83       	std	Z+3, r29	; 0x03
    1f00:	c2 83       	std	Z+2, r28	; 0x02
    1f02:	60 91 36 04 	lds	r22, 0x0436	; 0x800436 <pxCurrentTCB>
    1f06:	70 91 37 04 	lds	r23, 0x0437	; 0x800437 <pxCurrentTCB+0x1>
    1f0a:	c0 17       	cp	r28, r16
    1f0c:	d1 07       	cpc	r29, r17
    1f0e:	68 f4       	brcc	.+26     	; 0x1f2a <prvAddCurrentTaskToDelayedList+0x86>
    1f10:	80 91 fc 03 	lds	r24, 0x03FC	; 0x8003fc <pxOverflowDelayedTaskList>
    1f14:	90 91 fd 03 	lds	r25, 0x03FD	; 0x8003fd <pxOverflowDelayedTaskList+0x1>
    1f18:	6e 5f       	subi	r22, 0xFE	; 254
    1f1a:	7f 4f       	sbci	r23, 0xFF	; 255
    1f1c:	df 91       	pop	r29
    1f1e:	cf 91       	pop	r28
    1f20:	1f 91       	pop	r17
    1f22:	0f 91       	pop	r16
    1f24:	ff 90       	pop	r15
    1f26:	0c 94 09 0a 	jmp	0x1412	; 0x1412 <vListInsert>
    1f2a:	80 91 fe 03 	lds	r24, 0x03FE	; 0x8003fe <pxDelayedTaskList>
    1f2e:	90 91 ff 03 	lds	r25, 0x03FF	; 0x8003ff <pxDelayedTaskList+0x1>
    1f32:	6e 5f       	subi	r22, 0xFE	; 254
    1f34:	7f 4f       	sbci	r23, 0xFF	; 255
    1f36:	0e 94 09 0a 	call	0x1412	; 0x1412 <vListInsert>
    1f3a:	80 91 d5 03 	lds	r24, 0x03D5	; 0x8003d5 <xNextTaskUnblockTime>
    1f3e:	90 91 d6 03 	lds	r25, 0x03D6	; 0x8003d6 <xNextTaskUnblockTime+0x1>
    1f42:	c8 17       	cp	r28, r24
    1f44:	d9 07       	cpc	r29, r25
    1f46:	20 f4       	brcc	.+8      	; 0x1f50 <prvAddCurrentTaskToDelayedList+0xac>
    1f48:	d0 93 d6 03 	sts	0x03D6, r29	; 0x8003d6 <xNextTaskUnblockTime+0x1>
    1f4c:	c0 93 d5 03 	sts	0x03D5, r28	; 0x8003d5 <xNextTaskUnblockTime>
    1f50:	df 91       	pop	r29
    1f52:	cf 91       	pop	r28
    1f54:	1f 91       	pop	r17
    1f56:	0f 91       	pop	r16
    1f58:	ff 90       	pop	r15
    1f5a:	08 95       	ret

00001f5c <prvIdleTask>:
    1f5c:	80 91 e9 03 	lds	r24, 0x03E9	; 0x8003e9 <uxDeletedTasksWaitingCleanUp>
    1f60:	88 23       	and	r24, r24
    1f62:	09 f1       	breq	.+66     	; 0x1fa6 <prvIdleTask+0x4a>
    1f64:	0f b6       	in	r0, 0x3f	; 63
    1f66:	f8 94       	cli
    1f68:	0f 92       	push	r0
    1f6a:	e0 91 ef 03 	lds	r30, 0x03EF	; 0x8003ef <xTasksWaitingTermination+0x5>
    1f6e:	f0 91 f0 03 	lds	r31, 0x03F0	; 0x8003f0 <xTasksWaitingTermination+0x6>
    1f72:	c6 81       	ldd	r28, Z+6	; 0x06
    1f74:	d7 81       	ldd	r29, Z+7	; 0x07
    1f76:	ce 01       	movw	r24, r28
    1f78:	02 96       	adiw	r24, 0x02	; 2
    1f7a:	0e 94 41 0a 	call	0x1482	; 0x1482 <uxListRemove>
    1f7e:	80 91 df 03 	lds	r24, 0x03DF	; 0x8003df <uxCurrentNumberOfTasks>
    1f82:	81 50       	subi	r24, 0x01	; 1
    1f84:	80 93 df 03 	sts	0x03DF, r24	; 0x8003df <uxCurrentNumberOfTasks>
    1f88:	80 91 e9 03 	lds	r24, 0x03E9	; 0x8003e9 <uxDeletedTasksWaitingCleanUp>
    1f8c:	81 50       	subi	r24, 0x01	; 1
    1f8e:	80 93 e9 03 	sts	0x03E9, r24	; 0x8003e9 <uxDeletedTasksWaitingCleanUp>
    1f92:	0f 90       	pop	r0
    1f94:	0f be       	out	0x3f, r0	; 63
    1f96:	8f 89       	ldd	r24, Y+23	; 0x17
    1f98:	98 8d       	ldd	r25, Y+24	; 0x18
    1f9a:	0e 94 c5 09 	call	0x138a	; 0x138a <vPortFree>
    1f9e:	ce 01       	movw	r24, r28
    1fa0:	0e 94 c5 09 	call	0x138a	; 0x138a <vPortFree>
    1fa4:	db cf       	rjmp	.-74     	; 0x1f5c <prvIdleTask>
    1fa6:	80 91 12 04 	lds	r24, 0x0412	; 0x800412 <pxReadyTasksLists>
    1faa:	82 30       	cpi	r24, 0x02	; 2
    1fac:	10 f0       	brcs	.+4      	; 0x1fb2 <prvIdleTask+0x56>
    1fae:	0e 94 09 0b 	call	0x1612	; 0x1612 <vPortYield>
    1fb2:	0e 94 a6 16 	call	0x2d4c	; 0x2d4c <vApplicationIdleHook>
    1fb6:	d2 cf       	rjmp	.-92     	; 0x1f5c <prvIdleTask>

00001fb8 <xTaskCreate>:
    1fb8:	5f 92       	push	r5
    1fba:	6f 92       	push	r6
    1fbc:	7f 92       	push	r7
    1fbe:	8f 92       	push	r8
    1fc0:	9f 92       	push	r9
    1fc2:	af 92       	push	r10
    1fc4:	bf 92       	push	r11
    1fc6:	cf 92       	push	r12
    1fc8:	df 92       	push	r13
    1fca:	ef 92       	push	r14
    1fcc:	ff 92       	push	r15
    1fce:	0f 93       	push	r16
    1fd0:	1f 93       	push	r17
    1fd2:	cf 93       	push	r28
    1fd4:	df 93       	push	r29
    1fd6:	3c 01       	movw	r6, r24
    1fd8:	6b 01       	movw	r12, r22
    1fda:	5a 01       	movw	r10, r20
    1fdc:	49 01       	movw	r8, r18
    1fde:	50 2e       	mov	r5, r16
    1fe0:	ca 01       	movw	r24, r20
    1fe2:	0e 94 b2 09 	call	0x1364	; 0x1364 <pvPortMalloc>
    1fe6:	8c 01       	movw	r16, r24
    1fe8:	89 2b       	or	r24, r25
    1fea:	09 f4       	brne	.+2      	; 0x1fee <xTaskCreate+0x36>
    1fec:	e0 c0       	rjmp	.+448    	; 0x21ae <xTaskCreate+0x1f6>
    1fee:	88 e2       	ldi	r24, 0x28	; 40
    1ff0:	90 e0       	ldi	r25, 0x00	; 0
    1ff2:	0e 94 b2 09 	call	0x1364	; 0x1364 <pvPortMalloc>
    1ff6:	ec 01       	movw	r28, r24
    1ff8:	89 2b       	or	r24, r25
    1ffa:	c9 f0       	breq	.+50     	; 0x202e <xTaskCreate+0x76>
    1ffc:	18 8f       	std	Y+24, r17	; 0x18
    1ffe:	0f 8b       	std	Y+23, r16	; 0x17
    2000:	a5 01       	movw	r20, r10
    2002:	65 ea       	ldi	r22, 0xA5	; 165
    2004:	70 e0       	ldi	r23, 0x00	; 0
    2006:	c8 01       	movw	r24, r16
    2008:	0e 94 5c 25 	call	0x4ab8	; 0x4ab8 <memset>
    200c:	21 e0       	ldi	r18, 0x01	; 1
    200e:	a2 1a       	sub	r10, r18
    2010:	b1 08       	sbc	r11, r1
    2012:	8f 89       	ldd	r24, Y+23	; 0x17
    2014:	98 8d       	ldd	r25, Y+24	; 0x18
    2016:	a8 0e       	add	r10, r24
    2018:	b9 1e       	adc	r11, r25
    201a:	c1 14       	cp	r12, r1
    201c:	d1 04       	cpc	r13, r1
    201e:	c9 f0       	breq	.+50     	; 0x2052 <xTaskCreate+0x9a>
    2020:	be 01       	movw	r22, r28
    2022:	67 5e       	subi	r22, 0xE7	; 231
    2024:	7f 4f       	sbci	r23, 0xFF	; 255
    2026:	f6 01       	movw	r30, r12
    2028:	c6 01       	movw	r24, r12
    202a:	08 96       	adiw	r24, 0x08	; 8
    202c:	07 c0       	rjmp	.+14     	; 0x203c <xTaskCreate+0x84>
    202e:	c8 01       	movw	r24, r16
    2030:	0e 94 c5 09 	call	0x138a	; 0x138a <vPortFree>
    2034:	bc c0       	rjmp	.+376    	; 0x21ae <xTaskCreate+0x1f6>
    2036:	e8 17       	cp	r30, r24
    2038:	f9 07       	cpc	r31, r25
    203a:	49 f0       	breq	.+18     	; 0x204e <xTaskCreate+0x96>
    203c:	9f 01       	movw	r18, r30
    203e:	41 91       	ld	r20, Z+
    2040:	db 01       	movw	r26, r22
    2042:	4d 93       	st	X+, r20
    2044:	bd 01       	movw	r22, r26
    2046:	d9 01       	movw	r26, r18
    2048:	2c 91       	ld	r18, X
    204a:	21 11       	cpse	r18, r1
    204c:	f4 cf       	rjmp	.-24     	; 0x2036 <xTaskCreate+0x7e>
    204e:	18 a2       	std	Y+32, r1	; 0x20
    2050:	01 c0       	rjmp	.+2      	; 0x2054 <xTaskCreate+0x9c>
    2052:	19 8e       	std	Y+25, r1	; 0x19
    2054:	05 2d       	mov	r16, r5
    2056:	04 30       	cpi	r16, 0x04	; 4
    2058:	08 f0       	brcs	.+2      	; 0x205c <xTaskCreate+0xa4>
    205a:	03 e0       	ldi	r16, 0x03	; 3
    205c:	0e 8b       	std	Y+22, r16	; 0x16
    205e:	09 a3       	std	Y+33, r16	; 0x21
    2060:	1a a2       	std	Y+34, r1	; 0x22
    2062:	6e 01       	movw	r12, r28
    2064:	b2 e0       	ldi	r27, 0x02	; 2
    2066:	cb 0e       	add	r12, r27
    2068:	d1 1c       	adc	r13, r1
    206a:	c6 01       	movw	r24, r12
    206c:	0e 94 e4 09 	call	0x13c8	; 0x13c8 <vListInitialiseItem>
    2070:	ce 01       	movw	r24, r28
    2072:	0c 96       	adiw	r24, 0x0c	; 12
    2074:	0e 94 e4 09 	call	0x13c8	; 0x13c8 <vListInitialiseItem>
    2078:	d9 87       	std	Y+9, r29	; 0x09
    207a:	c8 87       	std	Y+8, r28	; 0x08
    207c:	84 e0       	ldi	r24, 0x04	; 4
    207e:	90 e0       	ldi	r25, 0x00	; 0
    2080:	80 1b       	sub	r24, r16
    2082:	91 09       	sbc	r25, r1
    2084:	9d 87       	std	Y+13, r25	; 0x0d
    2086:	8c 87       	std	Y+12, r24	; 0x0c
    2088:	db 8b       	std	Y+19, r29	; 0x13
    208a:	ca 8b       	std	Y+18, r28	; 0x12
    208c:	1b a2       	std	Y+35, r1	; 0x23
    208e:	1c a2       	std	Y+36, r1	; 0x24
    2090:	1d a2       	std	Y+37, r1	; 0x25
    2092:	1e a2       	std	Y+38, r1	; 0x26
    2094:	1f a2       	std	Y+39, r1	; 0x27
    2096:	a4 01       	movw	r20, r8
    2098:	b3 01       	movw	r22, r6
    209a:	c5 01       	movw	r24, r10
    209c:	0e 94 65 0a 	call	0x14ca	; 0x14ca <pxPortInitialiseStack>
    20a0:	99 83       	std	Y+1, r25	; 0x01
    20a2:	88 83       	st	Y, r24
    20a4:	e1 14       	cp	r14, r1
    20a6:	f1 04       	cpc	r15, r1
    20a8:	19 f0       	breq	.+6      	; 0x20b0 <xTaskCreate+0xf8>
    20aa:	f7 01       	movw	r30, r14
    20ac:	d1 83       	std	Z+1, r29	; 0x01
    20ae:	c0 83       	st	Z, r28
    20b0:	0f b6       	in	r0, 0x3f	; 63
    20b2:	f8 94       	cli
    20b4:	0f 92       	push	r0
    20b6:	80 91 df 03 	lds	r24, 0x03DF	; 0x8003df <uxCurrentNumberOfTasks>
    20ba:	8f 5f       	subi	r24, 0xFF	; 255
    20bc:	80 93 df 03 	sts	0x03DF, r24	; 0x8003df <uxCurrentNumberOfTasks>
    20c0:	80 91 36 04 	lds	r24, 0x0436	; 0x800436 <pxCurrentTCB>
    20c4:	90 91 37 04 	lds	r25, 0x0437	; 0x800437 <pxCurrentTCB+0x1>
    20c8:	89 2b       	or	r24, r25
    20ca:	d1 f5       	brne	.+116    	; 0x2140 <xTaskCreate+0x188>
    20cc:	d0 93 37 04 	sts	0x0437, r29	; 0x800437 <pxCurrentTCB+0x1>
    20d0:	c0 93 36 04 	sts	0x0436, r28	; 0x800436 <pxCurrentTCB>
    20d4:	80 91 df 03 	lds	r24, 0x03DF	; 0x8003df <uxCurrentNumberOfTasks>
    20d8:	81 30       	cpi	r24, 0x01	; 1
    20da:	09 f0       	breq	.+2      	; 0x20de <xTaskCreate+0x126>
    20dc:	41 c0       	rjmp	.+130    	; 0x2160 <xTaskCreate+0x1a8>
    20de:	82 e1       	ldi	r24, 0x12	; 18
    20e0:	94 e0       	ldi	r25, 0x04	; 4
    20e2:	0e 94 d6 09 	call	0x13ac	; 0x13ac <vListInitialise>
    20e6:	8b e1       	ldi	r24, 0x1B	; 27
    20e8:	94 e0       	ldi	r25, 0x04	; 4
    20ea:	0e 94 d6 09 	call	0x13ac	; 0x13ac <vListInitialise>
    20ee:	84 e2       	ldi	r24, 0x24	; 36
    20f0:	94 e0       	ldi	r25, 0x04	; 4
    20f2:	0e 94 d6 09 	call	0x13ac	; 0x13ac <vListInitialise>
    20f6:	8d e2       	ldi	r24, 0x2D	; 45
    20f8:	94 e0       	ldi	r25, 0x04	; 4
    20fa:	0e 94 d6 09 	call	0x13ac	; 0x13ac <vListInitialise>
    20fe:	89 e0       	ldi	r24, 0x09	; 9
    2100:	94 e0       	ldi	r25, 0x04	; 4
    2102:	0e 94 d6 09 	call	0x13ac	; 0x13ac <vListInitialise>
    2106:	80 e0       	ldi	r24, 0x00	; 0
    2108:	94 e0       	ldi	r25, 0x04	; 4
    210a:	0e 94 d6 09 	call	0x13ac	; 0x13ac <vListInitialise>
    210e:	83 ef       	ldi	r24, 0xF3	; 243
    2110:	93 e0       	ldi	r25, 0x03	; 3
    2112:	0e 94 d6 09 	call	0x13ac	; 0x13ac <vListInitialise>
    2116:	8a ee       	ldi	r24, 0xEA	; 234
    2118:	93 e0       	ldi	r25, 0x03	; 3
    211a:	0e 94 d6 09 	call	0x13ac	; 0x13ac <vListInitialise>
    211e:	80 ee       	ldi	r24, 0xE0	; 224
    2120:	93 e0       	ldi	r25, 0x03	; 3
    2122:	0e 94 d6 09 	call	0x13ac	; 0x13ac <vListInitialise>
    2126:	89 e0       	ldi	r24, 0x09	; 9
    2128:	94 e0       	ldi	r25, 0x04	; 4
    212a:	90 93 ff 03 	sts	0x03FF, r25	; 0x8003ff <pxDelayedTaskList+0x1>
    212e:	80 93 fe 03 	sts	0x03FE, r24	; 0x8003fe <pxDelayedTaskList>
    2132:	80 e0       	ldi	r24, 0x00	; 0
    2134:	94 e0       	ldi	r25, 0x04	; 4
    2136:	90 93 fd 03 	sts	0x03FD, r25	; 0x8003fd <pxOverflowDelayedTaskList+0x1>
    213a:	80 93 fc 03 	sts	0x03FC, r24	; 0x8003fc <pxOverflowDelayedTaskList>
    213e:	10 c0       	rjmp	.+32     	; 0x2160 <xTaskCreate+0x1a8>
    2140:	80 91 db 03 	lds	r24, 0x03DB	; 0x8003db <xSchedulerRunning>
    2144:	81 11       	cpse	r24, r1
    2146:	0c c0       	rjmp	.+24     	; 0x2160 <xTaskCreate+0x1a8>
    2148:	e0 91 36 04 	lds	r30, 0x0436	; 0x800436 <pxCurrentTCB>
    214c:	f0 91 37 04 	lds	r31, 0x0437	; 0x800437 <pxCurrentTCB+0x1>
    2150:	96 89       	ldd	r25, Z+22	; 0x16
    2152:	8e 89       	ldd	r24, Y+22	; 0x16
    2154:	89 17       	cp	r24, r25
    2156:	20 f0       	brcs	.+8      	; 0x2160 <xTaskCreate+0x1a8>
    2158:	d0 93 37 04 	sts	0x0437, r29	; 0x800437 <pxCurrentTCB+0x1>
    215c:	c0 93 36 04 	sts	0x0436, r28	; 0x800436 <pxCurrentTCB>
    2160:	80 91 d7 03 	lds	r24, 0x03D7	; 0x8003d7 <uxTaskNumber>
    2164:	8f 5f       	subi	r24, 0xFF	; 255
    2166:	80 93 d7 03 	sts	0x03D7, r24	; 0x8003d7 <uxTaskNumber>
    216a:	8e 89       	ldd	r24, Y+22	; 0x16
    216c:	90 91 dc 03 	lds	r25, 0x03DC	; 0x8003dc <uxTopReadyPriority>
    2170:	98 17       	cp	r25, r24
    2172:	10 f4       	brcc	.+4      	; 0x2178 <xTaskCreate+0x1c0>
    2174:	80 93 dc 03 	sts	0x03DC, r24	; 0x8003dc <uxTopReadyPriority>
    2178:	f9 e0       	ldi	r31, 0x09	; 9
    217a:	8f 9f       	mul	r24, r31
    217c:	c0 01       	movw	r24, r0
    217e:	11 24       	eor	r1, r1
    2180:	b6 01       	movw	r22, r12
    2182:	8e 5e       	subi	r24, 0xEE	; 238
    2184:	9b 4f       	sbci	r25, 0xFB	; 251
    2186:	0e 94 e8 09 	call	0x13d0	; 0x13d0 <vListInsertEnd>
    218a:	0f 90       	pop	r0
    218c:	0f be       	out	0x3f, r0	; 63
    218e:	80 91 db 03 	lds	r24, 0x03DB	; 0x8003db <xSchedulerRunning>
    2192:	88 23       	and	r24, r24
    2194:	51 f0       	breq	.+20     	; 0x21aa <xTaskCreate+0x1f2>
    2196:	e0 91 36 04 	lds	r30, 0x0436	; 0x800436 <pxCurrentTCB>
    219a:	f0 91 37 04 	lds	r31, 0x0437	; 0x800437 <pxCurrentTCB+0x1>
    219e:	96 89       	ldd	r25, Z+22	; 0x16
    21a0:	8e 89       	ldd	r24, Y+22	; 0x16
    21a2:	98 17       	cp	r25, r24
    21a4:	10 f4       	brcc	.+4      	; 0x21aa <xTaskCreate+0x1f2>
    21a6:	0e 94 09 0b 	call	0x1612	; 0x1612 <vPortYield>
    21aa:	81 e0       	ldi	r24, 0x01	; 1
    21ac:	01 c0       	rjmp	.+2      	; 0x21b0 <xTaskCreate+0x1f8>
    21ae:	8f ef       	ldi	r24, 0xFF	; 255
    21b0:	df 91       	pop	r29
    21b2:	cf 91       	pop	r28
    21b4:	1f 91       	pop	r17
    21b6:	0f 91       	pop	r16
    21b8:	ff 90       	pop	r15
    21ba:	ef 90       	pop	r14
    21bc:	df 90       	pop	r13
    21be:	cf 90       	pop	r12
    21c0:	bf 90       	pop	r11
    21c2:	af 90       	pop	r10
    21c4:	9f 90       	pop	r9
    21c6:	8f 90       	pop	r8
    21c8:	7f 90       	pop	r7
    21ca:	6f 90       	pop	r6
    21cc:	5f 90       	pop	r5
    21ce:	08 95       	ret

000021d0 <vTaskStartScheduler>:
    21d0:	ef 92       	push	r14
    21d2:	ff 92       	push	r15
    21d4:	0f 93       	push	r16
    21d6:	83 ed       	ldi	r24, 0xD3	; 211
    21d8:	e8 2e       	mov	r14, r24
    21da:	83 e0       	ldi	r24, 0x03	; 3
    21dc:	f8 2e       	mov	r15, r24
    21de:	00 e0       	ldi	r16, 0x00	; 0
    21e0:	20 e0       	ldi	r18, 0x00	; 0
    21e2:	30 e0       	ldi	r19, 0x00	; 0
    21e4:	40 ec       	ldi	r20, 0xC0	; 192
    21e6:	50 e0       	ldi	r21, 0x00	; 0
    21e8:	61 e5       	ldi	r22, 0x51	; 81
    21ea:	72 e0       	ldi	r23, 0x02	; 2
    21ec:	8e ea       	ldi	r24, 0xAE	; 174
    21ee:	9f e0       	ldi	r25, 0x0F	; 15
    21f0:	0e 94 dc 0f 	call	0x1fb8	; 0x1fb8 <xTaskCreate>
    21f4:	81 30       	cpi	r24, 0x01	; 1
    21f6:	b1 f4       	brne	.+44     	; 0x2224 <vTaskStartScheduler+0x54>
    21f8:	0e 94 ee 14 	call	0x29dc	; 0x29dc <xTimerCreateTimerTask>
    21fc:	81 30       	cpi	r24, 0x01	; 1
    21fe:	91 f4       	brne	.+36     	; 0x2224 <vTaskStartScheduler+0x54>
    2200:	f8 94       	cli
    2202:	2f ef       	ldi	r18, 0xFF	; 255
    2204:	3f ef       	ldi	r19, 0xFF	; 255
    2206:	30 93 d6 03 	sts	0x03D6, r19	; 0x8003d6 <xNextTaskUnblockTime+0x1>
    220a:	20 93 d5 03 	sts	0x03D5, r18	; 0x8003d5 <xNextTaskUnblockTime>
    220e:	80 93 db 03 	sts	0x03DB, r24	; 0x8003db <xSchedulerRunning>
    2212:	10 92 de 03 	sts	0x03DE, r1	; 0x8003de <xTickCount+0x1>
    2216:	10 92 dd 03 	sts	0x03DD, r1	; 0x8003dd <xTickCount>
    221a:	0f 91       	pop	r16
    221c:	ff 90       	pop	r15
    221e:	ef 90       	pop	r14
    2220:	0c 94 d1 0a 	jmp	0x15a2	; 0x15a2 <xPortStartScheduler>
    2224:	0f 91       	pop	r16
    2226:	ff 90       	pop	r15
    2228:	ef 90       	pop	r14
    222a:	08 95       	ret

0000222c <vTaskSuspendAll>:
    222c:	80 91 d2 03 	lds	r24, 0x03D2	; 0x8003d2 <uxSchedulerSuspended>
    2230:	8f 5f       	subi	r24, 0xFF	; 255
    2232:	80 93 d2 03 	sts	0x03D2, r24	; 0x8003d2 <uxSchedulerSuspended>
    2236:	08 95       	ret

00002238 <xTaskGetTickCount>:
    2238:	0f b6       	in	r0, 0x3f	; 63
    223a:	f8 94       	cli
    223c:	0f 92       	push	r0
    223e:	80 91 dd 03 	lds	r24, 0x03DD	; 0x8003dd <xTickCount>
    2242:	90 91 de 03 	lds	r25, 0x03DE	; 0x8003de <xTickCount+0x1>
    2246:	0f 90       	pop	r0
    2248:	0f be       	out	0x3f, r0	; 63
    224a:	08 95       	ret

0000224c <xTaskIncrementTick>:
    224c:	cf 92       	push	r12
    224e:	df 92       	push	r13
    2250:	ef 92       	push	r14
    2252:	ff 92       	push	r15
    2254:	0f 93       	push	r16
    2256:	1f 93       	push	r17
    2258:	cf 93       	push	r28
    225a:	df 93       	push	r29
    225c:	80 91 d2 03 	lds	r24, 0x03D2	; 0x8003d2 <uxSchedulerSuspended>
    2260:	81 11       	cpse	r24, r1
    2262:	8c c0       	rjmp	.+280    	; 0x237c <xTaskIncrementTick+0x130>
    2264:	00 91 dd 03 	lds	r16, 0x03DD	; 0x8003dd <xTickCount>
    2268:	10 91 de 03 	lds	r17, 0x03DE	; 0x8003de <xTickCount+0x1>
    226c:	0f 5f       	subi	r16, 0xFF	; 255
    226e:	1f 4f       	sbci	r17, 0xFF	; 255
    2270:	10 93 de 03 	sts	0x03DE, r17	; 0x8003de <xTickCount+0x1>
    2274:	00 93 dd 03 	sts	0x03DD, r16	; 0x8003dd <xTickCount>
    2278:	01 15       	cp	r16, r1
    227a:	11 05       	cpc	r17, r1
    227c:	b9 f4       	brne	.+46     	; 0x22ac <xTaskIncrementTick+0x60>
    227e:	80 91 fe 03 	lds	r24, 0x03FE	; 0x8003fe <pxDelayedTaskList>
    2282:	90 91 ff 03 	lds	r25, 0x03FF	; 0x8003ff <pxDelayedTaskList+0x1>
    2286:	20 91 fc 03 	lds	r18, 0x03FC	; 0x8003fc <pxOverflowDelayedTaskList>
    228a:	30 91 fd 03 	lds	r19, 0x03FD	; 0x8003fd <pxOverflowDelayedTaskList+0x1>
    228e:	30 93 ff 03 	sts	0x03FF, r19	; 0x8003ff <pxDelayedTaskList+0x1>
    2292:	20 93 fe 03 	sts	0x03FE, r18	; 0x8003fe <pxDelayedTaskList>
    2296:	90 93 fd 03 	sts	0x03FD, r25	; 0x8003fd <pxOverflowDelayedTaskList+0x1>
    229a:	80 93 fc 03 	sts	0x03FC, r24	; 0x8003fc <pxOverflowDelayedTaskList>
    229e:	80 91 d8 03 	lds	r24, 0x03D8	; 0x8003d8 <xNumOfOverflows>
    22a2:	8f 5f       	subi	r24, 0xFF	; 255
    22a4:	80 93 d8 03 	sts	0x03D8, r24	; 0x8003d8 <xNumOfOverflows>
    22a8:	0e 94 37 0f 	call	0x1e6e	; 0x1e6e <prvResetNextTaskUnblockTime>
    22ac:	80 91 d5 03 	lds	r24, 0x03D5	; 0x8003d5 <xNextTaskUnblockTime>
    22b0:	90 91 d6 03 	lds	r25, 0x03D6	; 0x8003d6 <xNextTaskUnblockTime+0x1>
    22b4:	c0 e0       	ldi	r28, 0x00	; 0
    22b6:	08 17       	cp	r16, r24
    22b8:	19 07       	cpc	r17, r25
    22ba:	08 f4       	brcc	.+2      	; 0x22be <xTaskIncrementTick+0x72>
    22bc:	4f c0       	rjmp	.+158    	; 0x235c <xTaskIncrementTick+0x110>
    22be:	d9 e0       	ldi	r29, 0x09	; 9
    22c0:	e0 91 fe 03 	lds	r30, 0x03FE	; 0x8003fe <pxDelayedTaskList>
    22c4:	f0 91 ff 03 	lds	r31, 0x03FF	; 0x8003ff <pxDelayedTaskList+0x1>
    22c8:	80 81       	ld	r24, Z
    22ca:	81 11       	cpse	r24, r1
    22cc:	03 c0       	rjmp	.+6      	; 0x22d4 <xTaskIncrementTick+0x88>
    22ce:	8f ef       	ldi	r24, 0xFF	; 255
    22d0:	9f ef       	ldi	r25, 0xFF	; 255
    22d2:	11 c0       	rjmp	.+34     	; 0x22f6 <xTaskIncrementTick+0xaa>
    22d4:	e0 91 fe 03 	lds	r30, 0x03FE	; 0x8003fe <pxDelayedTaskList>
    22d8:	f0 91 ff 03 	lds	r31, 0x03FF	; 0x8003ff <pxDelayedTaskList+0x1>
    22dc:	05 80       	ldd	r0, Z+5	; 0x05
    22de:	f6 81       	ldd	r31, Z+6	; 0x06
    22e0:	e0 2d       	mov	r30, r0
    22e2:	e6 80       	ldd	r14, Z+6	; 0x06
    22e4:	f7 80       	ldd	r15, Z+7	; 0x07
    22e6:	d7 01       	movw	r26, r14
    22e8:	12 96       	adiw	r26, 0x02	; 2
    22ea:	8d 91       	ld	r24, X+
    22ec:	9c 91       	ld	r25, X
    22ee:	13 97       	sbiw	r26, 0x03	; 3
    22f0:	08 17       	cp	r16, r24
    22f2:	19 07       	cpc	r17, r25
    22f4:	28 f4       	brcc	.+10     	; 0x2300 <xTaskIncrementTick+0xb4>
    22f6:	90 93 d6 03 	sts	0x03D6, r25	; 0x8003d6 <xNextTaskUnblockTime+0x1>
    22fa:	80 93 d5 03 	sts	0x03D5, r24	; 0x8003d5 <xNextTaskUnblockTime>
    22fe:	2e c0       	rjmp	.+92     	; 0x235c <xTaskIncrementTick+0x110>
    2300:	67 01       	movw	r12, r14
    2302:	b2 e0       	ldi	r27, 0x02	; 2
    2304:	cb 0e       	add	r12, r27
    2306:	d1 1c       	adc	r13, r1
    2308:	c6 01       	movw	r24, r12
    230a:	0e 94 41 0a 	call	0x1482	; 0x1482 <uxListRemove>
    230e:	f7 01       	movw	r30, r14
    2310:	84 89       	ldd	r24, Z+20	; 0x14
    2312:	95 89       	ldd	r25, Z+21	; 0x15
    2314:	89 2b       	or	r24, r25
    2316:	21 f0       	breq	.+8      	; 0x2320 <xTaskIncrementTick+0xd4>
    2318:	c7 01       	movw	r24, r14
    231a:	0c 96       	adiw	r24, 0x0c	; 12
    231c:	0e 94 41 0a 	call	0x1482	; 0x1482 <uxListRemove>
    2320:	d7 01       	movw	r26, r14
    2322:	56 96       	adiw	r26, 0x16	; 22
    2324:	8c 91       	ld	r24, X
    2326:	90 91 dc 03 	lds	r25, 0x03DC	; 0x8003dc <uxTopReadyPriority>
    232a:	98 17       	cp	r25, r24
    232c:	10 f4       	brcc	.+4      	; 0x2332 <xTaskIncrementTick+0xe6>
    232e:	80 93 dc 03 	sts	0x03DC, r24	; 0x8003dc <uxTopReadyPriority>
    2332:	d8 9f       	mul	r29, r24
    2334:	c0 01       	movw	r24, r0
    2336:	11 24       	eor	r1, r1
    2338:	b6 01       	movw	r22, r12
    233a:	8e 5e       	subi	r24, 0xEE	; 238
    233c:	9b 4f       	sbci	r25, 0xFB	; 251
    233e:	0e 94 e8 09 	call	0x13d0	; 0x13d0 <vListInsertEnd>
    2342:	e0 91 36 04 	lds	r30, 0x0436	; 0x800436 <pxCurrentTCB>
    2346:	f0 91 37 04 	lds	r31, 0x0437	; 0x800437 <pxCurrentTCB+0x1>
    234a:	d7 01       	movw	r26, r14
    234c:	56 96       	adiw	r26, 0x16	; 22
    234e:	9c 91       	ld	r25, X
    2350:	86 89       	ldd	r24, Z+22	; 0x16
    2352:	98 17       	cp	r25, r24
    2354:	08 f4       	brcc	.+2      	; 0x2358 <xTaskIncrementTick+0x10c>
    2356:	b4 cf       	rjmp	.-152    	; 0x22c0 <xTaskIncrementTick+0x74>
    2358:	c1 e0       	ldi	r28, 0x01	; 1
    235a:	b2 cf       	rjmp	.-156    	; 0x22c0 <xTaskIncrementTick+0x74>
    235c:	e0 91 36 04 	lds	r30, 0x0436	; 0x800436 <pxCurrentTCB>
    2360:	f0 91 37 04 	lds	r31, 0x0437	; 0x800437 <pxCurrentTCB+0x1>
    2364:	e6 89       	ldd	r30, Z+22	; 0x16
    2366:	b9 e0       	ldi	r27, 0x09	; 9
    2368:	eb 9f       	mul	r30, r27
    236a:	f0 01       	movw	r30, r0
    236c:	11 24       	eor	r1, r1
    236e:	ee 5e       	subi	r30, 0xEE	; 238
    2370:	fb 4f       	sbci	r31, 0xFB	; 251
    2372:	80 81       	ld	r24, Z
    2374:	82 30       	cpi	r24, 0x02	; 2
    2376:	40 f0       	brcs	.+16     	; 0x2388 <xTaskIncrementTick+0x13c>
    2378:	c1 e0       	ldi	r28, 0x01	; 1
    237a:	06 c0       	rjmp	.+12     	; 0x2388 <xTaskIncrementTick+0x13c>
    237c:	80 91 da 03 	lds	r24, 0x03DA	; 0x8003da <uxPendedTicks>
    2380:	8f 5f       	subi	r24, 0xFF	; 255
    2382:	80 93 da 03 	sts	0x03DA, r24	; 0x8003da <uxPendedTicks>
    2386:	c0 e0       	ldi	r28, 0x00	; 0
    2388:	80 91 d9 03 	lds	r24, 0x03D9	; 0x8003d9 <xYieldPending>
    238c:	81 11       	cpse	r24, r1
    238e:	c1 e0       	ldi	r28, 0x01	; 1
    2390:	8c 2f       	mov	r24, r28
    2392:	df 91       	pop	r29
    2394:	cf 91       	pop	r28
    2396:	1f 91       	pop	r17
    2398:	0f 91       	pop	r16
    239a:	ff 90       	pop	r15
    239c:	ef 90       	pop	r14
    239e:	df 90       	pop	r13
    23a0:	cf 90       	pop	r12
    23a2:	08 95       	ret

000023a4 <xTaskResumeAll>:
    23a4:	ef 92       	push	r14
    23a6:	ff 92       	push	r15
    23a8:	0f 93       	push	r16
    23aa:	1f 93       	push	r17
    23ac:	cf 93       	push	r28
    23ae:	df 93       	push	r29
    23b0:	0f b6       	in	r0, 0x3f	; 63
    23b2:	f8 94       	cli
    23b4:	0f 92       	push	r0
    23b6:	80 91 d2 03 	lds	r24, 0x03D2	; 0x8003d2 <uxSchedulerSuspended>
    23ba:	81 50       	subi	r24, 0x01	; 1
    23bc:	80 93 d2 03 	sts	0x03D2, r24	; 0x8003d2 <uxSchedulerSuspended>
    23c0:	80 91 d2 03 	lds	r24, 0x03D2	; 0x8003d2 <uxSchedulerSuspended>
    23c4:	88 23       	and	r24, r24
    23c6:	11 f0       	breq	.+4      	; 0x23cc <xTaskResumeAll+0x28>
    23c8:	80 e0       	ldi	r24, 0x00	; 0
    23ca:	52 c0       	rjmp	.+164    	; 0x2470 <xTaskResumeAll+0xcc>
    23cc:	80 91 df 03 	lds	r24, 0x03DF	; 0x8003df <uxCurrentNumberOfTasks>
    23d0:	88 23       	and	r24, r24
    23d2:	d1 f3       	breq	.-12     	; 0x23c8 <xTaskResumeAll+0x24>
    23d4:	c0 e0       	ldi	r28, 0x00	; 0
    23d6:	d0 e0       	ldi	r29, 0x00	; 0
    23d8:	89 e0       	ldi	r24, 0x09	; 9
    23da:	f8 2e       	mov	r15, r24
    23dc:	ee 24       	eor	r14, r14
    23de:	e3 94       	inc	r14
    23e0:	80 91 f3 03 	lds	r24, 0x03F3	; 0x8003f3 <xPendingReadyList>
    23e4:	88 23       	and	r24, r24
    23e6:	51 f1       	breq	.+84     	; 0x243c <xTaskResumeAll+0x98>
    23e8:	e0 91 f8 03 	lds	r30, 0x03F8	; 0x8003f8 <xPendingReadyList+0x5>
    23ec:	f0 91 f9 03 	lds	r31, 0x03F9	; 0x8003f9 <xPendingReadyList+0x6>
    23f0:	c6 81       	ldd	r28, Z+6	; 0x06
    23f2:	d7 81       	ldd	r29, Z+7	; 0x07
    23f4:	ce 01       	movw	r24, r28
    23f6:	0c 96       	adiw	r24, 0x0c	; 12
    23f8:	0e 94 41 0a 	call	0x1482	; 0x1482 <uxListRemove>
    23fc:	8e 01       	movw	r16, r28
    23fe:	0e 5f       	subi	r16, 0xFE	; 254
    2400:	1f 4f       	sbci	r17, 0xFF	; 255
    2402:	c8 01       	movw	r24, r16
    2404:	0e 94 41 0a 	call	0x1482	; 0x1482 <uxListRemove>
    2408:	8e 89       	ldd	r24, Y+22	; 0x16
    240a:	90 91 dc 03 	lds	r25, 0x03DC	; 0x8003dc <uxTopReadyPriority>
    240e:	98 17       	cp	r25, r24
    2410:	10 f4       	brcc	.+4      	; 0x2416 <xTaskResumeAll+0x72>
    2412:	80 93 dc 03 	sts	0x03DC, r24	; 0x8003dc <uxTopReadyPriority>
    2416:	f8 9e       	mul	r15, r24
    2418:	c0 01       	movw	r24, r0
    241a:	11 24       	eor	r1, r1
    241c:	b8 01       	movw	r22, r16
    241e:	8e 5e       	subi	r24, 0xEE	; 238
    2420:	9b 4f       	sbci	r25, 0xFB	; 251
    2422:	0e 94 e8 09 	call	0x13d0	; 0x13d0 <vListInsertEnd>
    2426:	e0 91 36 04 	lds	r30, 0x0436	; 0x800436 <pxCurrentTCB>
    242a:	f0 91 37 04 	lds	r31, 0x0437	; 0x800437 <pxCurrentTCB+0x1>
    242e:	9e 89       	ldd	r25, Y+22	; 0x16
    2430:	86 89       	ldd	r24, Z+22	; 0x16
    2432:	98 17       	cp	r25, r24
    2434:	a8 f2       	brcs	.-86     	; 0x23e0 <xTaskResumeAll+0x3c>
    2436:	e0 92 d9 03 	sts	0x03D9, r14	; 0x8003d9 <xYieldPending>
    243a:	d2 cf       	rjmp	.-92     	; 0x23e0 <xTaskResumeAll+0x3c>
    243c:	cd 2b       	or	r28, r29
    243e:	11 f0       	breq	.+4      	; 0x2444 <xTaskResumeAll+0xa0>
    2440:	0e 94 37 0f 	call	0x1e6e	; 0x1e6e <prvResetNextTaskUnblockTime>
    2444:	c0 91 da 03 	lds	r28, 0x03DA	; 0x8003da <uxPendedTicks>
    2448:	cc 23       	and	r28, r28
    244a:	51 f0       	breq	.+20     	; 0x2460 <xTaskResumeAll+0xbc>
    244c:	d1 e0       	ldi	r29, 0x01	; 1
    244e:	0e 94 26 11 	call	0x224c	; 0x224c <xTaskIncrementTick>
    2452:	81 11       	cpse	r24, r1
    2454:	d0 93 d9 03 	sts	0x03D9, r29	; 0x8003d9 <xYieldPending>
    2458:	c1 50       	subi	r28, 0x01	; 1
    245a:	c9 f7       	brne	.-14     	; 0x244e <xTaskResumeAll+0xaa>
    245c:	10 92 da 03 	sts	0x03DA, r1	; 0x8003da <uxPendedTicks>
    2460:	80 91 d9 03 	lds	r24, 0x03D9	; 0x8003d9 <xYieldPending>
    2464:	88 23       	and	r24, r24
    2466:	09 f4       	brne	.+2      	; 0x246a <xTaskResumeAll+0xc6>
    2468:	af cf       	rjmp	.-162    	; 0x23c8 <xTaskResumeAll+0x24>
    246a:	0e 94 09 0b 	call	0x1612	; 0x1612 <vPortYield>
    246e:	81 e0       	ldi	r24, 0x01	; 1
    2470:	0f 90       	pop	r0
    2472:	0f be       	out	0x3f, r0	; 63
    2474:	df 91       	pop	r29
    2476:	cf 91       	pop	r28
    2478:	1f 91       	pop	r17
    247a:	0f 91       	pop	r16
    247c:	ff 90       	pop	r15
    247e:	ef 90       	pop	r14
    2480:	08 95       	ret

00002482 <vTaskDelayUntil>:
    2482:	0f 93       	push	r16
    2484:	1f 93       	push	r17
    2486:	cf 93       	push	r28
    2488:	df 93       	push	r29
    248a:	8c 01       	movw	r16, r24
    248c:	eb 01       	movw	r28, r22
    248e:	0e 94 16 11 	call	0x222c	; 0x222c <vTaskSuspendAll>
    2492:	40 91 dd 03 	lds	r20, 0x03DD	; 0x8003dd <xTickCount>
    2496:	50 91 de 03 	lds	r21, 0x03DE	; 0x8003de <xTickCount+0x1>
    249a:	f8 01       	movw	r30, r16
    249c:	20 81       	ld	r18, Z
    249e:	31 81       	ldd	r19, Z+1	; 0x01
    24a0:	c9 01       	movw	r24, r18
    24a2:	8c 0f       	add	r24, r28
    24a4:	9d 1f       	adc	r25, r29
    24a6:	42 17       	cp	r20, r18
    24a8:	53 07       	cpc	r21, r19
    24aa:	20 f4       	brcc	.+8      	; 0x24b4 <vTaskDelayUntil+0x32>
    24ac:	82 17       	cp	r24, r18
    24ae:	93 07       	cpc	r25, r19
    24b0:	40 f4       	brcc	.+16     	; 0x24c2 <vTaskDelayUntil+0x40>
    24b2:	03 c0       	rjmp	.+6      	; 0x24ba <vTaskDelayUntil+0x38>
    24b4:	82 17       	cp	r24, r18
    24b6:	93 07       	cpc	r25, r19
    24b8:	30 f0       	brcs	.+12     	; 0x24c6 <vTaskDelayUntil+0x44>
    24ba:	21 e0       	ldi	r18, 0x01	; 1
    24bc:	48 17       	cp	r20, r24
    24be:	59 07       	cpc	r21, r25
    24c0:	18 f0       	brcs	.+6      	; 0x24c8 <vTaskDelayUntil+0x46>
    24c2:	20 e0       	ldi	r18, 0x00	; 0
    24c4:	01 c0       	rjmp	.+2      	; 0x24c8 <vTaskDelayUntil+0x46>
    24c6:	21 e0       	ldi	r18, 0x01	; 1
    24c8:	f8 01       	movw	r30, r16
    24ca:	91 83       	std	Z+1, r25	; 0x01
    24cc:	80 83       	st	Z, r24
    24ce:	22 23       	and	r18, r18
    24d0:	29 f0       	breq	.+10     	; 0x24dc <vTaskDelayUntil+0x5a>
    24d2:	60 e0       	ldi	r22, 0x00	; 0
    24d4:	84 1b       	sub	r24, r20
    24d6:	95 0b       	sbc	r25, r21
    24d8:	0e 94 52 0f 	call	0x1ea4	; 0x1ea4 <prvAddCurrentTaskToDelayedList>
    24dc:	0e 94 d2 11 	call	0x23a4	; 0x23a4 <xTaskResumeAll>
    24e0:	81 11       	cpse	r24, r1
    24e2:	02 c0       	rjmp	.+4      	; 0x24e8 <vTaskDelayUntil+0x66>
    24e4:	0e 94 09 0b 	call	0x1612	; 0x1612 <vPortYield>
    24e8:	df 91       	pop	r29
    24ea:	cf 91       	pop	r28
    24ec:	1f 91       	pop	r17
    24ee:	0f 91       	pop	r16
    24f0:	08 95       	ret

000024f2 <vTaskDelay>:
    24f2:	cf 93       	push	r28
    24f4:	df 93       	push	r29
    24f6:	ec 01       	movw	r28, r24
    24f8:	89 2b       	or	r24, r25
    24fa:	19 f4       	brne	.+6      	; 0x2502 <vTaskDelay+0x10>
    24fc:	0e 94 09 0b 	call	0x1612	; 0x1612 <vPortYield>
    2500:	0a c0       	rjmp	.+20     	; 0x2516 <vTaskDelay+0x24>
    2502:	0e 94 16 11 	call	0x222c	; 0x222c <vTaskSuspendAll>
    2506:	60 e0       	ldi	r22, 0x00	; 0
    2508:	ce 01       	movw	r24, r28
    250a:	0e 94 52 0f 	call	0x1ea4	; 0x1ea4 <prvAddCurrentTaskToDelayedList>
    250e:	0e 94 d2 11 	call	0x23a4	; 0x23a4 <xTaskResumeAll>
    2512:	88 23       	and	r24, r24
    2514:	99 f3       	breq	.-26     	; 0x24fc <vTaskDelay+0xa>
    2516:	df 91       	pop	r29
    2518:	cf 91       	pop	r28
    251a:	08 95       	ret

0000251c <vTaskSwitchContext>:
    251c:	80 91 d2 03 	lds	r24, 0x03D2	; 0x8003d2 <uxSchedulerSuspended>
    2520:	88 23       	and	r24, r24
    2522:	21 f0       	breq	.+8      	; 0x252c <vTaskSwitchContext+0x10>
    2524:	81 e0       	ldi	r24, 0x01	; 1
    2526:	80 93 d9 03 	sts	0x03D9, r24	; 0x8003d9 <xYieldPending>
    252a:	08 95       	ret
    252c:	10 92 d9 03 	sts	0x03D9, r1	; 0x8003d9 <xYieldPending>
    2530:	a0 91 36 04 	lds	r26, 0x0436	; 0x800436 <pxCurrentTCB>
    2534:	b0 91 37 04 	lds	r27, 0x0437	; 0x800437 <pxCurrentTCB+0x1>
    2538:	e0 91 36 04 	lds	r30, 0x0436	; 0x800436 <pxCurrentTCB>
    253c:	f0 91 37 04 	lds	r31, 0x0437	; 0x800437 <pxCurrentTCB+0x1>
    2540:	2d 91       	ld	r18, X+
    2542:	3c 91       	ld	r19, X
    2544:	87 89       	ldd	r24, Z+23	; 0x17
    2546:	90 8d       	ldd	r25, Z+24	; 0x18
    2548:	82 17       	cp	r24, r18
    254a:	93 07       	cpc	r25, r19
    254c:	60 f0       	brcs	.+24     	; 0x2566 <vTaskSwitchContext+0x4a>
    254e:	60 91 36 04 	lds	r22, 0x0436	; 0x800436 <pxCurrentTCB>
    2552:	70 91 37 04 	lds	r23, 0x0437	; 0x800437 <pxCurrentTCB+0x1>
    2556:	80 91 36 04 	lds	r24, 0x0436	; 0x800436 <pxCurrentTCB>
    255a:	90 91 37 04 	lds	r25, 0x0437	; 0x800437 <pxCurrentTCB+0x1>
    255e:	67 5e       	subi	r22, 0xE7	; 231
    2560:	7f 4f       	sbci	r23, 0xFF	; 255
    2562:	0e 94 bc 16 	call	0x2d78	; 0x2d78 <vApplicationStackOverflowHook>
    2566:	80 91 dc 03 	lds	r24, 0x03DC	; 0x8003dc <uxTopReadyPriority>
    256a:	69 e0       	ldi	r22, 0x09	; 9
    256c:	48 2f       	mov	r20, r24
    256e:	50 e0       	ldi	r21, 0x00	; 0
    2570:	64 9f       	mul	r22, r20
    2572:	90 01       	movw	r18, r0
    2574:	65 9f       	mul	r22, r21
    2576:	30 0d       	add	r19, r0
    2578:	11 24       	eor	r1, r1
    257a:	f9 01       	movw	r30, r18
    257c:	ee 5e       	subi	r30, 0xEE	; 238
    257e:	fb 4f       	sbci	r31, 0xFB	; 251
    2580:	90 81       	ld	r25, Z
    2582:	91 11       	cpse	r25, r1
    2584:	02 c0       	rjmp	.+4      	; 0x258a <vTaskSwitchContext+0x6e>
    2586:	81 50       	subi	r24, 0x01	; 1
    2588:	f1 cf       	rjmp	.-30     	; 0x256c <vTaskSwitchContext+0x50>
    258a:	a1 81       	ldd	r26, Z+1	; 0x01
    258c:	b2 81       	ldd	r27, Z+2	; 0x02
    258e:	12 96       	adiw	r26, 0x02	; 2
    2590:	0d 90       	ld	r0, X+
    2592:	bc 91       	ld	r27, X
    2594:	a0 2d       	mov	r26, r0
    2596:	b2 83       	std	Z+2, r27	; 0x02
    2598:	a1 83       	std	Z+1, r26	; 0x01
    259a:	2b 5e       	subi	r18, 0xEB	; 235
    259c:	3b 4f       	sbci	r19, 0xFB	; 251
    259e:	a2 17       	cp	r26, r18
    25a0:	b3 07       	cpc	r27, r19
    25a2:	31 f4       	brne	.+12     	; 0x25b0 <vTaskSwitchContext+0x94>
    25a4:	12 96       	adiw	r26, 0x02	; 2
    25a6:	2d 91       	ld	r18, X+
    25a8:	3c 91       	ld	r19, X
    25aa:	13 97       	sbiw	r26, 0x03	; 3
    25ac:	32 83       	std	Z+2, r19	; 0x02
    25ae:	21 83       	std	Z+1, r18	; 0x01
    25b0:	99 e0       	ldi	r25, 0x09	; 9
    25b2:	94 9f       	mul	r25, r20
    25b4:	f0 01       	movw	r30, r0
    25b6:	95 9f       	mul	r25, r21
    25b8:	f0 0d       	add	r31, r0
    25ba:	11 24       	eor	r1, r1
    25bc:	ee 5e       	subi	r30, 0xEE	; 238
    25be:	fb 4f       	sbci	r31, 0xFB	; 251
    25c0:	01 80       	ldd	r0, Z+1	; 0x01
    25c2:	f2 81       	ldd	r31, Z+2	; 0x02
    25c4:	e0 2d       	mov	r30, r0
    25c6:	26 81       	ldd	r18, Z+6	; 0x06
    25c8:	37 81       	ldd	r19, Z+7	; 0x07
    25ca:	30 93 37 04 	sts	0x0437, r19	; 0x800437 <pxCurrentTCB+0x1>
    25ce:	20 93 36 04 	sts	0x0436, r18	; 0x800436 <pxCurrentTCB>
    25d2:	80 93 dc 03 	sts	0x03DC, r24	; 0x8003dc <uxTopReadyPriority>
    25d6:	08 95       	ret

000025d8 <vTaskPlaceOnEventList>:
    25d8:	cf 93       	push	r28
    25da:	df 93       	push	r29
    25dc:	eb 01       	movw	r28, r22
    25de:	60 91 36 04 	lds	r22, 0x0436	; 0x800436 <pxCurrentTCB>
    25e2:	70 91 37 04 	lds	r23, 0x0437	; 0x800437 <pxCurrentTCB+0x1>
    25e6:	64 5f       	subi	r22, 0xF4	; 244
    25e8:	7f 4f       	sbci	r23, 0xFF	; 255
    25ea:	0e 94 09 0a 	call	0x1412	; 0x1412 <vListInsert>
    25ee:	61 e0       	ldi	r22, 0x01	; 1
    25f0:	ce 01       	movw	r24, r28
    25f2:	df 91       	pop	r29
    25f4:	cf 91       	pop	r28
    25f6:	0c 94 52 0f 	jmp	0x1ea4	; 0x1ea4 <prvAddCurrentTaskToDelayedList>

000025fa <vTaskPlaceOnEventListRestricted>:
    25fa:	1f 93       	push	r17
    25fc:	cf 93       	push	r28
    25fe:	df 93       	push	r29
    2600:	eb 01       	movw	r28, r22
    2602:	14 2f       	mov	r17, r20
    2604:	60 91 36 04 	lds	r22, 0x0436	; 0x800436 <pxCurrentTCB>
    2608:	70 91 37 04 	lds	r23, 0x0437	; 0x800437 <pxCurrentTCB+0x1>
    260c:	64 5f       	subi	r22, 0xF4	; 244
    260e:	7f 4f       	sbci	r23, 0xFF	; 255
    2610:	0e 94 e8 09 	call	0x13d0	; 0x13d0 <vListInsertEnd>
    2614:	11 23       	and	r17, r17
    2616:	11 f0       	breq	.+4      	; 0x261c <vTaskPlaceOnEventListRestricted+0x22>
    2618:	cf ef       	ldi	r28, 0xFF	; 255
    261a:	df ef       	ldi	r29, 0xFF	; 255
    261c:	61 2f       	mov	r22, r17
    261e:	ce 01       	movw	r24, r28
    2620:	df 91       	pop	r29
    2622:	cf 91       	pop	r28
    2624:	1f 91       	pop	r17
    2626:	0c 94 52 0f 	jmp	0x1ea4	; 0x1ea4 <prvAddCurrentTaskToDelayedList>

0000262a <xTaskRemoveFromEventList>:
    262a:	0f 93       	push	r16
    262c:	1f 93       	push	r17
    262e:	cf 93       	push	r28
    2630:	df 93       	push	r29
    2632:	dc 01       	movw	r26, r24
    2634:	15 96       	adiw	r26, 0x05	; 5
    2636:	ed 91       	ld	r30, X+
    2638:	fc 91       	ld	r31, X
    263a:	16 97       	sbiw	r26, 0x06	; 6
    263c:	c6 81       	ldd	r28, Z+6	; 0x06
    263e:	d7 81       	ldd	r29, Z+7	; 0x07
    2640:	8e 01       	movw	r16, r28
    2642:	04 5f       	subi	r16, 0xF4	; 244
    2644:	1f 4f       	sbci	r17, 0xFF	; 255
    2646:	c8 01       	movw	r24, r16
    2648:	0e 94 41 0a 	call	0x1482	; 0x1482 <uxListRemove>
    264c:	80 91 d2 03 	lds	r24, 0x03D2	; 0x8003d2 <uxSchedulerSuspended>
    2650:	81 11       	cpse	r24, r1
    2652:	14 c0       	rjmp	.+40     	; 0x267c <xTaskRemoveFromEventList+0x52>
    2654:	0a 50       	subi	r16, 0x0A	; 10
    2656:	11 09       	sbc	r17, r1
    2658:	c8 01       	movw	r24, r16
    265a:	0e 94 41 0a 	call	0x1482	; 0x1482 <uxListRemove>
    265e:	8e 89       	ldd	r24, Y+22	; 0x16
    2660:	90 91 dc 03 	lds	r25, 0x03DC	; 0x8003dc <uxTopReadyPriority>
    2664:	98 17       	cp	r25, r24
    2666:	10 f4       	brcc	.+4      	; 0x266c <xTaskRemoveFromEventList+0x42>
    2668:	80 93 dc 03 	sts	0x03DC, r24	; 0x8003dc <uxTopReadyPriority>
    266c:	b9 e0       	ldi	r27, 0x09	; 9
    266e:	8b 9f       	mul	r24, r27
    2670:	c0 01       	movw	r24, r0
    2672:	11 24       	eor	r1, r1
    2674:	b8 01       	movw	r22, r16
    2676:	8e 5e       	subi	r24, 0xEE	; 238
    2678:	9b 4f       	sbci	r25, 0xFB	; 251
    267a:	03 c0       	rjmp	.+6      	; 0x2682 <xTaskRemoveFromEventList+0x58>
    267c:	b8 01       	movw	r22, r16
    267e:	83 ef       	ldi	r24, 0xF3	; 243
    2680:	93 e0       	ldi	r25, 0x03	; 3
    2682:	0e 94 e8 09 	call	0x13d0	; 0x13d0 <vListInsertEnd>
    2686:	e0 91 36 04 	lds	r30, 0x0436	; 0x800436 <pxCurrentTCB>
    268a:	f0 91 37 04 	lds	r31, 0x0437	; 0x800437 <pxCurrentTCB+0x1>
    268e:	9e 89       	ldd	r25, Y+22	; 0x16
    2690:	86 89       	ldd	r24, Z+22	; 0x16
    2692:	89 17       	cp	r24, r25
    2694:	20 f4       	brcc	.+8      	; 0x269e <xTaskRemoveFromEventList+0x74>
    2696:	81 e0       	ldi	r24, 0x01	; 1
    2698:	80 93 d9 03 	sts	0x03D9, r24	; 0x8003d9 <xYieldPending>
    269c:	01 c0       	rjmp	.+2      	; 0x26a0 <xTaskRemoveFromEventList+0x76>
    269e:	80 e0       	ldi	r24, 0x00	; 0
    26a0:	df 91       	pop	r29
    26a2:	cf 91       	pop	r28
    26a4:	1f 91       	pop	r17
    26a6:	0f 91       	pop	r16
    26a8:	08 95       	ret

000026aa <vTaskInternalSetTimeOutState>:
    26aa:	20 91 d8 03 	lds	r18, 0x03D8	; 0x8003d8 <xNumOfOverflows>
    26ae:	fc 01       	movw	r30, r24
    26b0:	20 83       	st	Z, r18
    26b2:	20 91 dd 03 	lds	r18, 0x03DD	; 0x8003dd <xTickCount>
    26b6:	30 91 de 03 	lds	r19, 0x03DE	; 0x8003de <xTickCount+0x1>
    26ba:	32 83       	std	Z+2, r19	; 0x02
    26bc:	21 83       	std	Z+1, r18	; 0x01
    26be:	08 95       	ret

000026c0 <xTaskCheckForTimeOut>:
    26c0:	cf 93       	push	r28
    26c2:	df 93       	push	r29
    26c4:	0f b6       	in	r0, 0x3f	; 63
    26c6:	f8 94       	cli
    26c8:	0f 92       	push	r0
    26ca:	40 91 dd 03 	lds	r20, 0x03DD	; 0x8003dd <xTickCount>
    26ce:	50 91 de 03 	lds	r21, 0x03DE	; 0x8003de <xTickCount+0x1>
    26d2:	db 01       	movw	r26, r22
    26d4:	2d 91       	ld	r18, X+
    26d6:	3c 91       	ld	r19, X
    26d8:	2f 3f       	cpi	r18, 0xFF	; 255
    26da:	bf ef       	ldi	r27, 0xFF	; 255
    26dc:	3b 07       	cpc	r19, r27
    26de:	d9 f0       	breq	.+54     	; 0x2716 <xTaskCheckForTimeOut+0x56>
    26e0:	ec 01       	movw	r28, r24
    26e2:	e9 81       	ldd	r30, Y+1	; 0x01
    26e4:	fa 81       	ldd	r31, Y+2	; 0x02
    26e6:	a0 91 d8 03 	lds	r26, 0x03D8	; 0x8003d8 <xNumOfOverflows>
    26ea:	b8 81       	ld	r27, Y
    26ec:	ba 17       	cp	r27, r26
    26ee:	19 f0       	breq	.+6      	; 0x26f6 <xTaskCheckForTimeOut+0x36>
    26f0:	4e 17       	cp	r20, r30
    26f2:	5f 07       	cpc	r21, r31
    26f4:	90 f4       	brcc	.+36     	; 0x271a <xTaskCheckForTimeOut+0x5a>
    26f6:	4e 1b       	sub	r20, r30
    26f8:	5f 0b       	sbc	r21, r31
    26fa:	fb 01       	movw	r30, r22
    26fc:	42 17       	cp	r20, r18
    26fe:	53 07       	cpc	r21, r19
    2700:	38 f4       	brcc	.+14     	; 0x2710 <xTaskCheckForTimeOut+0x50>
    2702:	24 1b       	sub	r18, r20
    2704:	35 0b       	sbc	r19, r21
    2706:	31 83       	std	Z+1, r19	; 0x01
    2708:	20 83       	st	Z, r18
    270a:	0e 94 55 13 	call	0x26aa	; 0x26aa <vTaskInternalSetTimeOutState>
    270e:	03 c0       	rjmp	.+6      	; 0x2716 <xTaskCheckForTimeOut+0x56>
    2710:	11 82       	std	Z+1, r1	; 0x01
    2712:	10 82       	st	Z, r1
    2714:	02 c0       	rjmp	.+4      	; 0x271a <xTaskCheckForTimeOut+0x5a>
    2716:	80 e0       	ldi	r24, 0x00	; 0
    2718:	01 c0       	rjmp	.+2      	; 0x271c <xTaskCheckForTimeOut+0x5c>
    271a:	81 e0       	ldi	r24, 0x01	; 1
    271c:	0f 90       	pop	r0
    271e:	0f be       	out	0x3f, r0	; 63
    2720:	df 91       	pop	r29
    2722:	cf 91       	pop	r28
    2724:	08 95       	ret

00002726 <vTaskMissedYield>:
    2726:	81 e0       	ldi	r24, 0x01	; 1
    2728:	80 93 d9 03 	sts	0x03D9, r24	; 0x8003d9 <xYieldPending>
    272c:	08 95       	ret

0000272e <xTaskGetSchedulerState>:
    272e:	80 91 db 03 	lds	r24, 0x03DB	; 0x8003db <xSchedulerRunning>
    2732:	88 23       	and	r24, r24
    2734:	31 f0       	breq	.+12     	; 0x2742 <xTaskGetSchedulerState+0x14>
    2736:	80 91 d2 03 	lds	r24, 0x03D2	; 0x8003d2 <uxSchedulerSuspended>
    273a:	88 23       	and	r24, r24
    273c:	21 f0       	breq	.+8      	; 0x2746 <xTaskGetSchedulerState+0x18>
    273e:	80 e0       	ldi	r24, 0x00	; 0
    2740:	08 95       	ret
    2742:	81 e0       	ldi	r24, 0x01	; 1
    2744:	08 95       	ret
    2746:	82 e0       	ldi	r24, 0x02	; 2
    2748:	08 95       	ret

0000274a <xTaskPriorityInherit>:
    274a:	0f 93       	push	r16
    274c:	1f 93       	push	r17
    274e:	cf 93       	push	r28
    2750:	df 93       	push	r29
    2752:	fc 01       	movw	r30, r24
    2754:	89 2b       	or	r24, r25
    2756:	09 f4       	brne	.+2      	; 0x275a <xTaskPriorityInherit+0x10>
    2758:	55 c0       	rjmp	.+170    	; 0x2804 <xTaskPriorityInherit+0xba>
    275a:	86 89       	ldd	r24, Z+22	; 0x16
    275c:	a0 91 36 04 	lds	r26, 0x0436	; 0x800436 <pxCurrentTCB>
    2760:	b0 91 37 04 	lds	r27, 0x0437	; 0x800437 <pxCurrentTCB+0x1>
    2764:	56 96       	adiw	r26, 0x16	; 22
    2766:	9c 91       	ld	r25, X
    2768:	89 17       	cp	r24, r25
    276a:	08 f0       	brcs	.+2      	; 0x276e <xTaskPriorityInherit+0x24>
    276c:	41 c0       	rjmp	.+130    	; 0x27f0 <xTaskPriorityInherit+0xa6>
    276e:	24 85       	ldd	r18, Z+12	; 0x0c
    2770:	35 85       	ldd	r19, Z+13	; 0x0d
    2772:	37 fd       	sbrc	r19, 7
    2774:	0c c0       	rjmp	.+24     	; 0x278e <xTaskPriorityInherit+0x44>
    2776:	a0 91 36 04 	lds	r26, 0x0436	; 0x800436 <pxCurrentTCB>
    277a:	b0 91 37 04 	lds	r27, 0x0437	; 0x800437 <pxCurrentTCB+0x1>
    277e:	56 96       	adiw	r26, 0x16	; 22
    2780:	9c 91       	ld	r25, X
    2782:	24 e0       	ldi	r18, 0x04	; 4
    2784:	30 e0       	ldi	r19, 0x00	; 0
    2786:	29 1b       	sub	r18, r25
    2788:	31 09       	sbc	r19, r1
    278a:	35 87       	std	Z+13, r19	; 0x0d
    278c:	24 87       	std	Z+12, r18	; 0x0c
    278e:	29 e0       	ldi	r18, 0x09	; 9
    2790:	82 9f       	mul	r24, r18
    2792:	c0 01       	movw	r24, r0
    2794:	11 24       	eor	r1, r1
    2796:	8e 5e       	subi	r24, 0xEE	; 238
    2798:	9b 4f       	sbci	r25, 0xFB	; 251
    279a:	22 85       	ldd	r18, Z+10	; 0x0a
    279c:	33 85       	ldd	r19, Z+11	; 0x0b
    279e:	28 17       	cp	r18, r24
    27a0:	39 07       	cpc	r19, r25
    27a2:	e9 f4       	brne	.+58     	; 0x27de <xTaskPriorityInherit+0x94>
    27a4:	8f 01       	movw	r16, r30
    27a6:	ef 01       	movw	r28, r30
    27a8:	22 96       	adiw	r28, 0x02	; 2
    27aa:	ce 01       	movw	r24, r28
    27ac:	0e 94 41 0a 	call	0x1482	; 0x1482 <uxListRemove>
    27b0:	e0 91 36 04 	lds	r30, 0x0436	; 0x800436 <pxCurrentTCB>
    27b4:	f0 91 37 04 	lds	r31, 0x0437	; 0x800437 <pxCurrentTCB+0x1>
    27b8:	86 89       	ldd	r24, Z+22	; 0x16
    27ba:	f8 01       	movw	r30, r16
    27bc:	86 8b       	std	Z+22, r24	; 0x16
    27be:	90 91 dc 03 	lds	r25, 0x03DC	; 0x8003dc <uxTopReadyPriority>
    27c2:	98 17       	cp	r25, r24
    27c4:	10 f4       	brcc	.+4      	; 0x27ca <xTaskPriorityInherit+0x80>
    27c6:	80 93 dc 03 	sts	0x03DC, r24	; 0x8003dc <uxTopReadyPriority>
    27ca:	f9 e0       	ldi	r31, 0x09	; 9
    27cc:	8f 9f       	mul	r24, r31
    27ce:	c0 01       	movw	r24, r0
    27d0:	11 24       	eor	r1, r1
    27d2:	be 01       	movw	r22, r28
    27d4:	8e 5e       	subi	r24, 0xEE	; 238
    27d6:	9b 4f       	sbci	r25, 0xFB	; 251
    27d8:	0e 94 e8 09 	call	0x13d0	; 0x13d0 <vListInsertEnd>
    27dc:	07 c0       	rjmp	.+14     	; 0x27ec <xTaskPriorityInherit+0xa2>
    27de:	a0 91 36 04 	lds	r26, 0x0436	; 0x800436 <pxCurrentTCB>
    27e2:	b0 91 37 04 	lds	r27, 0x0437	; 0x800437 <pxCurrentTCB+0x1>
    27e6:	56 96       	adiw	r26, 0x16	; 22
    27e8:	8c 91       	ld	r24, X
    27ea:	86 8b       	std	Z+22, r24	; 0x16
    27ec:	81 e0       	ldi	r24, 0x01	; 1
    27ee:	0b c0       	rjmp	.+22     	; 0x2806 <xTaskPriorityInherit+0xbc>
    27f0:	a0 91 36 04 	lds	r26, 0x0436	; 0x800436 <pxCurrentTCB>
    27f4:	b0 91 37 04 	lds	r27, 0x0437	; 0x800437 <pxCurrentTCB+0x1>
    27f8:	81 e0       	ldi	r24, 0x01	; 1
    27fa:	21 a1       	ldd	r18, Z+33	; 0x21
    27fc:	56 96       	adiw	r26, 0x16	; 22
    27fe:	9c 91       	ld	r25, X
    2800:	29 17       	cp	r18, r25
    2802:	08 f0       	brcs	.+2      	; 0x2806 <xTaskPriorityInherit+0xbc>
    2804:	80 e0       	ldi	r24, 0x00	; 0
    2806:	df 91       	pop	r29
    2808:	cf 91       	pop	r28
    280a:	1f 91       	pop	r17
    280c:	0f 91       	pop	r16
    280e:	08 95       	ret

00002810 <xTaskPriorityDisinherit>:
    2810:	0f 93       	push	r16
    2812:	1f 93       	push	r17
    2814:	cf 93       	push	r28
    2816:	df 93       	push	r29
    2818:	fc 01       	movw	r30, r24
    281a:	89 2b       	or	r24, r25
    281c:	11 f4       	brne	.+4      	; 0x2822 <xTaskPriorityDisinherit+0x12>
    281e:	80 e0       	ldi	r24, 0x00	; 0
    2820:	2c c0       	rjmp	.+88     	; 0x287a <xTaskPriorityDisinherit+0x6a>
    2822:	82 a1       	ldd	r24, Z+34	; 0x22
    2824:	81 50       	subi	r24, 0x01	; 1
    2826:	82 a3       	std	Z+34, r24	; 0x22
    2828:	26 89       	ldd	r18, Z+22	; 0x16
    282a:	91 a1       	ldd	r25, Z+33	; 0x21
    282c:	29 17       	cp	r18, r25
    282e:	b9 f3       	breq	.-18     	; 0x281e <xTaskPriorityDisinherit+0xe>
    2830:	81 11       	cpse	r24, r1
    2832:	f5 cf       	rjmp	.-22     	; 0x281e <xTaskPriorityDisinherit+0xe>
    2834:	ef 01       	movw	r28, r30
    2836:	8f 01       	movw	r16, r30
    2838:	0e 5f       	subi	r16, 0xFE	; 254
    283a:	1f 4f       	sbci	r17, 0xFF	; 255
    283c:	c8 01       	movw	r24, r16
    283e:	0e 94 41 0a 	call	0x1482	; 0x1482 <uxListRemove>
    2842:	89 a1       	ldd	r24, Y+33	; 0x21
    2844:	8e 8b       	std	Y+22, r24	; 0x16
    2846:	48 2f       	mov	r20, r24
    2848:	50 e0       	ldi	r21, 0x00	; 0
    284a:	24 e0       	ldi	r18, 0x04	; 4
    284c:	30 e0       	ldi	r19, 0x00	; 0
    284e:	24 1b       	sub	r18, r20
    2850:	35 0b       	sbc	r19, r21
    2852:	3d 87       	std	Y+13, r19	; 0x0d
    2854:	2c 87       	std	Y+12, r18	; 0x0c
    2856:	90 91 dc 03 	lds	r25, 0x03DC	; 0x8003dc <uxTopReadyPriority>
    285a:	98 17       	cp	r25, r24
    285c:	10 f4       	brcc	.+4      	; 0x2862 <xTaskPriorityDisinherit+0x52>
    285e:	80 93 dc 03 	sts	0x03DC, r24	; 0x8003dc <uxTopReadyPriority>
    2862:	29 e0       	ldi	r18, 0x09	; 9
    2864:	24 9f       	mul	r18, r20
    2866:	c0 01       	movw	r24, r0
    2868:	25 9f       	mul	r18, r21
    286a:	90 0d       	add	r25, r0
    286c:	11 24       	eor	r1, r1
    286e:	b8 01       	movw	r22, r16
    2870:	8e 5e       	subi	r24, 0xEE	; 238
    2872:	9b 4f       	sbci	r25, 0xFB	; 251
    2874:	0e 94 e8 09 	call	0x13d0	; 0x13d0 <vListInsertEnd>
    2878:	81 e0       	ldi	r24, 0x01	; 1
    287a:	df 91       	pop	r29
    287c:	cf 91       	pop	r28
    287e:	1f 91       	pop	r17
    2880:	0f 91       	pop	r16
    2882:	08 95       	ret

00002884 <vTaskPriorityDisinheritAfterTimeout>:
    2884:	0f 93       	push	r16
    2886:	1f 93       	push	r17
    2888:	cf 93       	push	r28
    288a:	df 93       	push	r29
    288c:	fc 01       	movw	r30, r24
    288e:	89 2b       	or	r24, r25
    2890:	d9 f1       	breq	.+118    	; 0x2908 <vTaskPriorityDisinheritAfterTimeout+0x84>
    2892:	91 a1       	ldd	r25, Z+33	; 0x21
    2894:	96 17       	cp	r25, r22
    2896:	08 f4       	brcc	.+2      	; 0x289a <vTaskPriorityDisinheritAfterTimeout+0x16>
    2898:	96 2f       	mov	r25, r22
    289a:	86 89       	ldd	r24, Z+22	; 0x16
    289c:	89 17       	cp	r24, r25
    289e:	a1 f1       	breq	.+104    	; 0x2908 <vTaskPriorityDisinheritAfterTimeout+0x84>
    28a0:	22 a1       	ldd	r18, Z+34	; 0x22
    28a2:	21 30       	cpi	r18, 0x01	; 1
    28a4:	89 f5       	brne	.+98     	; 0x2908 <vTaskPriorityDisinheritAfterTimeout+0x84>
    28a6:	96 8b       	std	Z+22, r25	; 0x16
    28a8:	24 85       	ldd	r18, Z+12	; 0x0c
    28aa:	35 85       	ldd	r19, Z+13	; 0x0d
    28ac:	37 fd       	sbrc	r19, 7
    28ae:	06 c0       	rjmp	.+12     	; 0x28bc <vTaskPriorityDisinheritAfterTimeout+0x38>
    28b0:	24 e0       	ldi	r18, 0x04	; 4
    28b2:	30 e0       	ldi	r19, 0x00	; 0
    28b4:	29 1b       	sub	r18, r25
    28b6:	31 09       	sbc	r19, r1
    28b8:	35 87       	std	Z+13, r19	; 0x0d
    28ba:	24 87       	std	Z+12, r18	; 0x0c
    28bc:	29 e0       	ldi	r18, 0x09	; 9
    28be:	82 9f       	mul	r24, r18
    28c0:	c0 01       	movw	r24, r0
    28c2:	11 24       	eor	r1, r1
    28c4:	8e 5e       	subi	r24, 0xEE	; 238
    28c6:	9b 4f       	sbci	r25, 0xFB	; 251
    28c8:	22 85       	ldd	r18, Z+10	; 0x0a
    28ca:	33 85       	ldd	r19, Z+11	; 0x0b
    28cc:	28 17       	cp	r18, r24
    28ce:	39 07       	cpc	r19, r25
    28d0:	d9 f4       	brne	.+54     	; 0x2908 <vTaskPriorityDisinheritAfterTimeout+0x84>
    28d2:	ef 01       	movw	r28, r30
    28d4:	8f 01       	movw	r16, r30
    28d6:	0e 5f       	subi	r16, 0xFE	; 254
    28d8:	1f 4f       	sbci	r17, 0xFF	; 255
    28da:	c8 01       	movw	r24, r16
    28dc:	0e 94 41 0a 	call	0x1482	; 0x1482 <uxListRemove>
    28e0:	8e 89       	ldd	r24, Y+22	; 0x16
    28e2:	90 91 dc 03 	lds	r25, 0x03DC	; 0x8003dc <uxTopReadyPriority>
    28e6:	98 17       	cp	r25, r24
    28e8:	10 f4       	brcc	.+4      	; 0x28ee <vTaskPriorityDisinheritAfterTimeout+0x6a>
    28ea:	80 93 dc 03 	sts	0x03DC, r24	; 0x8003dc <uxTopReadyPriority>
    28ee:	29 e0       	ldi	r18, 0x09	; 9
    28f0:	82 9f       	mul	r24, r18
    28f2:	c0 01       	movw	r24, r0
    28f4:	11 24       	eor	r1, r1
    28f6:	b8 01       	movw	r22, r16
    28f8:	8e 5e       	subi	r24, 0xEE	; 238
    28fa:	9b 4f       	sbci	r25, 0xFB	; 251
    28fc:	df 91       	pop	r29
    28fe:	cf 91       	pop	r28
    2900:	1f 91       	pop	r17
    2902:	0f 91       	pop	r16
    2904:	0c 94 e8 09 	jmp	0x13d0	; 0x13d0 <vListInsertEnd>
    2908:	df 91       	pop	r29
    290a:	cf 91       	pop	r28
    290c:	1f 91       	pop	r17
    290e:	0f 91       	pop	r16
    2910:	08 95       	ret

00002912 <pvTaskIncrementMutexHeldCount>:

    TaskHandle_t pvTaskIncrementMutexHeldCount( void )
    {
        /* If xSemaphoreCreateMutex() is called before any tasks have been created
        then pxCurrentTCB will be NULL. */
        if( pxCurrentTCB != NULL )
    2912:	80 91 36 04 	lds	r24, 0x0436	; 0x800436 <pxCurrentTCB>
    2916:	90 91 37 04 	lds	r25, 0x0437	; 0x800437 <pxCurrentTCB+0x1>
    291a:	89 2b       	or	r24, r25
    291c:	39 f0       	breq	.+14     	; 0x292c <pvTaskIncrementMutexHeldCount+0x1a>
        {
            ( pxCurrentTCB->uxMutexesHeld )++;
    291e:	e0 91 36 04 	lds	r30, 0x0436	; 0x800436 <pxCurrentTCB>
    2922:	f0 91 37 04 	lds	r31, 0x0437	; 0x800437 <pxCurrentTCB+0x1>
    2926:	82 a1       	ldd	r24, Z+34	; 0x22
    2928:	8f 5f       	subi	r24, 0xFF	; 255
    292a:	82 a3       	std	Z+34, r24	; 0x22
        }

        return pxCurrentTCB;
    292c:	80 91 36 04 	lds	r24, 0x0436	; 0x800436 <pxCurrentTCB>
    2930:	90 91 37 04 	lds	r25, 0x0437	; 0x800437 <pxCurrentTCB+0x1>
    }
    2934:	08 95       	ret

00002936 <prvCheckForValidListAndQueue>:
            pxNewTimer->ucStatus = 0x00;
            prvInitialiseNewTimer( pcTimerName, xTimerPeriodInTicks, uxAutoReload, pvTimerID, pxCallbackFunction, pxNewTimer );
        }

        return pxNewTimer;
    }
    2936:	0f b6       	in	r0, 0x3f	; 63
    2938:	f8 94       	cli
    293a:	0f 92       	push	r0
    293c:	80 91 3c 04 	lds	r24, 0x043C	; 0x80043c <xTimerQueue>
    2940:	90 91 3d 04 	lds	r25, 0x043D	; 0x80043d <xTimerQueue+0x1>
    2944:	89 2b       	or	r24, r25
    2946:	e9 f4       	brne	.+58     	; 0x2982 <prvCheckForValidListAndQueue+0x4c>
    2948:	8b e4       	ldi	r24, 0x4B	; 75
    294a:	94 e0       	ldi	r25, 0x04	; 4
    294c:	0e 94 d6 09 	call	0x13ac	; 0x13ac <vListInitialise>
    2950:	82 e4       	ldi	r24, 0x42	; 66
    2952:	94 e0       	ldi	r25, 0x04	; 4
    2954:	0e 94 d6 09 	call	0x13ac	; 0x13ac <vListInitialise>
    2958:	8b e4       	ldi	r24, 0x4B	; 75
    295a:	94 e0       	ldi	r25, 0x04	; 4
    295c:	90 93 41 04 	sts	0x0441, r25	; 0x800441 <pxCurrentTimerList+0x1>
    2960:	80 93 40 04 	sts	0x0440, r24	; 0x800440 <pxCurrentTimerList>
    2964:	82 e4       	ldi	r24, 0x42	; 66
    2966:	94 e0       	ldi	r25, 0x04	; 4
    2968:	90 93 3f 04 	sts	0x043F, r25	; 0x80043f <pxOverflowTimerList+0x1>
    296c:	80 93 3e 04 	sts	0x043E, r24	; 0x80043e <pxOverflowTimerList>
    2970:	40 e0       	ldi	r20, 0x00	; 0
    2972:	65 e0       	ldi	r22, 0x05	; 5
    2974:	8a e0       	ldi	r24, 0x0A	; 10
    2976:	0e 94 b7 0c 	call	0x196e	; 0x196e <xQueueGenericCreate>
    297a:	90 93 3d 04 	sts	0x043D, r25	; 0x80043d <xTimerQueue+0x1>
    297e:	80 93 3c 04 	sts	0x043C, r24	; 0x80043c <xTimerQueue>
    2982:	0f 90       	pop	r0
    2984:	0f be       	out	0x3f, r0	; 63
    2986:	08 95       	ret

00002988 <prvInsertTimerInActiveList>:
    2988:	fc 01       	movw	r30, r24
    298a:	73 83       	std	Z+3, r23	; 0x03
    298c:	62 83       	std	Z+2, r22	; 0x02
    298e:	91 87       	std	Z+9, r25	; 0x09
    2990:	80 87       	std	Z+8, r24	; 0x08
    2992:	46 17       	cp	r20, r22
    2994:	57 07       	cpc	r21, r23
    2996:	78 f0       	brcs	.+30     	; 0x29b6 <prvInsertTimerInActiveList+0x2e>
    2998:	42 1b       	sub	r20, r18
    299a:	53 0b       	sbc	r21, r19
    299c:	84 85       	ldd	r24, Z+12	; 0x0c
    299e:	95 85       	ldd	r25, Z+13	; 0x0d
    29a0:	48 17       	cp	r20, r24
    29a2:	59 07       	cpc	r21, r25
    29a4:	c8 f4       	brcc	.+50     	; 0x29d8 <prvInsertTimerInActiveList+0x50>
    29a6:	bf 01       	movw	r22, r30
    29a8:	6e 5f       	subi	r22, 0xFE	; 254
    29aa:	7f 4f       	sbci	r23, 0xFF	; 255
    29ac:	80 91 3e 04 	lds	r24, 0x043E	; 0x80043e <pxOverflowTimerList>
    29b0:	90 91 3f 04 	lds	r25, 0x043F	; 0x80043f <pxOverflowTimerList+0x1>
    29b4:	0d c0       	rjmp	.+26     	; 0x29d0 <prvInsertTimerInActiveList+0x48>
    29b6:	42 17       	cp	r20, r18
    29b8:	53 07       	cpc	r21, r19
    29ba:	18 f4       	brcc	.+6      	; 0x29c2 <prvInsertTimerInActiveList+0x3a>
    29bc:	62 17       	cp	r22, r18
    29be:	73 07       	cpc	r23, r19
    29c0:	58 f4       	brcc	.+22     	; 0x29d8 <prvInsertTimerInActiveList+0x50>
    29c2:	bf 01       	movw	r22, r30
    29c4:	6e 5f       	subi	r22, 0xFE	; 254
    29c6:	7f 4f       	sbci	r23, 0xFF	; 255
    29c8:	80 91 40 04 	lds	r24, 0x0440	; 0x800440 <pxCurrentTimerList>
    29cc:	90 91 41 04 	lds	r25, 0x0441	; 0x800441 <pxCurrentTimerList+0x1>
    29d0:	0e 94 09 0a 	call	0x1412	; 0x1412 <vListInsert>
    29d4:	80 e0       	ldi	r24, 0x00	; 0
    29d6:	08 95       	ret
    29d8:	81 e0       	ldi	r24, 0x01	; 1
    29da:	08 95       	ret

000029dc <xTimerCreateTimerTask>:
    29dc:	ef 92       	push	r14
    29de:	ff 92       	push	r15
    29e0:	0f 93       	push	r16
    29e2:	0e 94 9b 14 	call	0x2936	; 0x2936 <prvCheckForValidListAndQueue>
    29e6:	80 91 3c 04 	lds	r24, 0x043C	; 0x80043c <xTimerQueue>
    29ea:	90 91 3d 04 	lds	r25, 0x043D	; 0x80043d <xTimerQueue+0x1>
    29ee:	89 2b       	or	r24, r25
    29f0:	81 f0       	breq	.+32     	; 0x2a12 <xTimerCreateTimerTask+0x36>
    29f2:	8a e3       	ldi	r24, 0x3A	; 58
    29f4:	e8 2e       	mov	r14, r24
    29f6:	84 e0       	ldi	r24, 0x04	; 4
    29f8:	f8 2e       	mov	r15, r24
    29fa:	03 e0       	ldi	r16, 0x03	; 3
    29fc:	20 e0       	ldi	r18, 0x00	; 0
    29fe:	30 e0       	ldi	r19, 0x00	; 0
    2a00:	45 e5       	ldi	r20, 0x55	; 85
    2a02:	50 e0       	ldi	r21, 0x00	; 0
    2a04:	66 e5       	ldi	r22, 0x56	; 86
    2a06:	72 e0       	ldi	r23, 0x02	; 2
    2a08:	8e e9       	ldi	r24, 0x9E	; 158
    2a0a:	95 e1       	ldi	r25, 0x15	; 21
    2a0c:	0e 94 dc 0f 	call	0x1fb8	; 0x1fb8 <xTaskCreate>
    2a10:	01 c0       	rjmp	.+2      	; 0x2a14 <xTimerCreateTimerTask+0x38>
    2a12:	80 e0       	ldi	r24, 0x00	; 0
    2a14:	0f 91       	pop	r16
    2a16:	ff 90       	pop	r15
    2a18:	ef 90       	pop	r14
    2a1a:	08 95       	ret

00002a1c <xTimerGenericCommand>:
    }
}
/*-----------------------------------------------------------*/

BaseType_t xTimerGenericCommand( TimerHandle_t xTimer, const BaseType_t xCommandID, const TickType_t xOptionalValue, BaseType_t * const pxHigherPriorityTaskWoken, const TickType_t xTicksToWait )
{
    2a1c:	0f 93       	push	r16
    2a1e:	1f 93       	push	r17
    2a20:	cf 93       	push	r28
    2a22:	df 93       	push	r29
    2a24:	00 d0       	rcall	.+0      	; 0x2a26 <xTimerGenericCommand+0xa>
    2a26:	00 d0       	rcall	.+0      	; 0x2a28 <xTimerGenericCommand+0xc>
    2a28:	1f 92       	push	r1
    2a2a:	cd b7       	in	r28, 0x3d	; 61
    2a2c:	de b7       	in	r29, 0x3e	; 62

    configASSERT( xTimer );

    /* Send a message to the timer service task to perform a particular action
    on a particular timer definition. */
    if( xTimerQueue != NULL )
    2a2e:	a0 91 3c 04 	lds	r26, 0x043C	; 0x80043c <xTimerQueue>
    2a32:	b0 91 3d 04 	lds	r27, 0x043D	; 0x80043d <xTimerQueue+0x1>
    2a36:	10 97       	sbiw	r26, 0x00	; 0
    2a38:	29 f1       	breq	.+74     	; 0x2a84 <xTimerGenericCommand+0x68>
    2a3a:	f9 01       	movw	r30, r18
    {
        /* Send a command to the timer service task to start the xTimer timer. */
        xMessage.xMessageID = xCommandID;
    2a3c:	69 83       	std	Y+1, r22	; 0x01
        xMessage.u.xTimerParameters.xMessageValue = xOptionalValue;
    2a3e:	5b 83       	std	Y+3, r21	; 0x03
    2a40:	4a 83       	std	Y+2, r20	; 0x02
        xMessage.u.xTimerParameters.pxTimer = xTimer;
    2a42:	9d 83       	std	Y+5, r25	; 0x05
    2a44:	8c 83       	std	Y+4, r24	; 0x04

        if( xCommandID < tmrFIRST_FROM_ISR_COMMAND )
    2a46:	66 30       	cpi	r22, 0x06	; 6
    2a48:	a4 f4       	brge	.+40     	; 0x2a72 <xTimerGenericCommand+0x56>
        {
            if( xTaskGetSchedulerState() == taskSCHEDULER_RUNNING )
    2a4a:	0e 94 97 13 	call	0x272e	; 0x272e <xTaskGetSchedulerState>
    2a4e:	e0 91 3c 04 	lds	r30, 0x043C	; 0x80043c <xTimerQueue>
    2a52:	f0 91 3d 04 	lds	r31, 0x043D	; 0x80043d <xTimerQueue+0x1>
            {
                xReturn = xQueueSendToBack( xTimerQueue, &xMessage, xTicksToWait );
    2a56:	20 e0       	ldi	r18, 0x00	; 0
        xMessage.u.xTimerParameters.xMessageValue = xOptionalValue;
        xMessage.u.xTimerParameters.pxTimer = xTimer;

        if( xCommandID < tmrFIRST_FROM_ISR_COMMAND )
        {
            if( xTaskGetSchedulerState() == taskSCHEDULER_RUNNING )
    2a58:	82 30       	cpi	r24, 0x02	; 2
    2a5a:	11 f4       	brne	.+4      	; 0x2a60 <xTimerGenericCommand+0x44>
            {
                xReturn = xQueueSendToBack( xTimerQueue, &xMessage, xTicksToWait );
    2a5c:	a8 01       	movw	r20, r16
    2a5e:	02 c0       	rjmp	.+4      	; 0x2a64 <xTimerGenericCommand+0x48>
            }
            else
            {
                xReturn = xQueueSendToBack( xTimerQueue, &xMessage, tmrNO_DELAY );
    2a60:	40 e0       	ldi	r20, 0x00	; 0
    2a62:	50 e0       	ldi	r21, 0x00	; 0
    2a64:	be 01       	movw	r22, r28
    2a66:	6f 5f       	subi	r22, 0xFF	; 255
    2a68:	7f 4f       	sbci	r23, 0xFF	; 255
    2a6a:	cf 01       	movw	r24, r30
    2a6c:	0e 94 df 0c 	call	0x19be	; 0x19be <xQueueGenericSend>
    2a70:	0a c0       	rjmp	.+20     	; 0x2a86 <xTimerGenericCommand+0x6a>
            }
        }
        else
        {
            xReturn = xQueueSendToBackFromISR( xTimerQueue, &xMessage, pxHigherPriorityTaskWoken );
    2a72:	20 e0       	ldi	r18, 0x00	; 0
    2a74:	af 01       	movw	r20, r30
    2a76:	be 01       	movw	r22, r28
    2a78:	6f 5f       	subi	r22, 0xFF	; 255
    2a7a:	7f 4f       	sbci	r23, 0xFF	; 255
    2a7c:	cd 01       	movw	r24, r26
    2a7e:	0e 94 75 0d 	call	0x1aea	; 0x1aea <xQueueGenericSendFromISR>
    2a82:	01 c0       	rjmp	.+2      	; 0x2a86 <xTimerGenericCommand+0x6a>
}
/*-----------------------------------------------------------*/

BaseType_t xTimerGenericCommand( TimerHandle_t xTimer, const BaseType_t xCommandID, const TickType_t xOptionalValue, BaseType_t * const pxHigherPriorityTaskWoken, const TickType_t xTicksToWait )
{
BaseType_t xReturn = pdFAIL;
    2a84:	80 e0       	ldi	r24, 0x00	; 0
    {
        mtCOVERAGE_TEST_MARKER();
    }

    return xReturn;
}
    2a86:	0f 90       	pop	r0
    2a88:	0f 90       	pop	r0
    2a8a:	0f 90       	pop	r0
    2a8c:	0f 90       	pop	r0
    2a8e:	0f 90       	pop	r0
    2a90:	df 91       	pop	r29
    2a92:	cf 91       	pop	r28
    2a94:	1f 91       	pop	r17
    2a96:	0f 91       	pop	r16
    2a98:	08 95       	ret

00002a9a <prvSwitchTimerLists>:
    }
}
/*-----------------------------------------------------------*/

static void prvSwitchTimerLists( void )
{
    2a9a:	ef 92       	push	r14
    2a9c:	ff 92       	push	r15
    2a9e:	0f 93       	push	r16
    2aa0:	1f 93       	push	r17
    2aa2:	cf 93       	push	r28
    2aa4:	df 93       	push	r29

    /* The tick count has overflowed.  The timer lists must be switched.
    If there are any timers still referenced from the current timer list
    then they must have expired and should be processed before the lists
    are switched. */
    while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
    2aa6:	e0 91 40 04 	lds	r30, 0x0440	; 0x800440 <pxCurrentTimerList>
    2aaa:	f0 91 41 04 	lds	r31, 0x0441	; 0x800441 <pxCurrentTimerList+0x1>
    2aae:	80 81       	ld	r24, Z
    2ab0:	88 23       	and	r24, r24
    2ab2:	89 f1       	breq	.+98     	; 0x2b16 <prvSwitchTimerLists+0x7c>
    {
        xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
    2ab4:	05 80       	ldd	r0, Z+5	; 0x05
    2ab6:	f6 81       	ldd	r31, Z+6	; 0x06
    2ab8:	e0 2d       	mov	r30, r0
    2aba:	e0 80       	ld	r14, Z
    2abc:	f1 80       	ldd	r15, Z+1	; 0x01

        /* Remove the timer from the list. */
        pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList ); /*lint !e9087 !e9079 void * is used as this macro is used with tasks and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    2abe:	c6 81       	ldd	r28, Z+6	; 0x06
    2ac0:	d7 81       	ldd	r29, Z+7	; 0x07
        ( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
    2ac2:	8e 01       	movw	r16, r28
    2ac4:	0e 5f       	subi	r16, 0xFE	; 254
    2ac6:	1f 4f       	sbci	r17, 0xFF	; 255
    2ac8:	c8 01       	movw	r24, r16
    2aca:	0e 94 41 0a 	call	0x1482	; 0x1482 <uxListRemove>
        traceTIMER_EXPIRED( pxTimer );

        /* Execute its callback, then send a command to restart the timer if
        it is an auto-reload timer.  It cannot be restarted here as the lists
        have not yet been switched. */
        pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
    2ace:	e8 89       	ldd	r30, Y+16	; 0x10
    2ad0:	f9 89       	ldd	r31, Y+17	; 0x11
    2ad2:	ce 01       	movw	r24, r28
    2ad4:	09 95       	icall

        if( ( pxTimer->ucStatus & tmrSTATUS_IS_AUTORELOAD ) != 0 )
    2ad6:	8a 89       	ldd	r24, Y+18	; 0x12
    2ad8:	82 ff       	sbrs	r24, 2
    2ada:	e5 cf       	rjmp	.-54     	; 0x2aa6 <prvSwitchTimerLists+0xc>
            the timer going into the same timer list then it has already expired
            and the timer should be re-inserted into the current list so it is
            processed again within this loop.  Otherwise a command should be sent
            to restart the timer to ensure it is only inserted into a list after
            the lists have been swapped. */
            xReloadTime = ( xNextExpireTime + pxTimer->xTimerPeriodInTicks );
    2adc:	8c 85       	ldd	r24, Y+12	; 0x0c
    2ade:	9d 85       	ldd	r25, Y+13	; 0x0d
    2ae0:	8e 0d       	add	r24, r14
    2ae2:	9f 1d       	adc	r25, r15
            if( xReloadTime > xNextExpireTime )
    2ae4:	e8 16       	cp	r14, r24
    2ae6:	f9 06       	cpc	r15, r25
    2ae8:	60 f4       	brcc	.+24     	; 0x2b02 <prvSwitchTimerLists+0x68>
            {
                listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xReloadTime );
    2aea:	9b 83       	std	Y+3, r25	; 0x03
    2aec:	8a 83       	std	Y+2, r24	; 0x02
                listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
    2aee:	d9 87       	std	Y+9, r29	; 0x09
    2af0:	c8 87       	std	Y+8, r28	; 0x08
                vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
    2af2:	b8 01       	movw	r22, r16
    2af4:	80 91 40 04 	lds	r24, 0x0440	; 0x800440 <pxCurrentTimerList>
    2af8:	90 91 41 04 	lds	r25, 0x0441	; 0x800441 <pxCurrentTimerList+0x1>
    2afc:	0e 94 09 0a 	call	0x1412	; 0x1412 <vListInsert>
    2b00:	d2 cf       	rjmp	.-92     	; 0x2aa6 <prvSwitchTimerLists+0xc>
            }
            else
            {
                xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY );
    2b02:	00 e0       	ldi	r16, 0x00	; 0
    2b04:	10 e0       	ldi	r17, 0x00	; 0
    2b06:	20 e0       	ldi	r18, 0x00	; 0
    2b08:	30 e0       	ldi	r19, 0x00	; 0
    2b0a:	a7 01       	movw	r20, r14
    2b0c:	60 e0       	ldi	r22, 0x00	; 0
    2b0e:	ce 01       	movw	r24, r28
    2b10:	0e 94 0e 15 	call	0x2a1c	; 0x2a1c <xTimerGenericCommand>
    2b14:	c8 cf       	rjmp	.-112    	; 0x2aa6 <prvSwitchTimerLists+0xc>
            mtCOVERAGE_TEST_MARKER();
        }
    }

    pxTemp = pxCurrentTimerList;
    pxCurrentTimerList = pxOverflowTimerList;
    2b16:	80 91 3e 04 	lds	r24, 0x043E	; 0x80043e <pxOverflowTimerList>
    2b1a:	90 91 3f 04 	lds	r25, 0x043F	; 0x80043f <pxOverflowTimerList+0x1>
    2b1e:	90 93 41 04 	sts	0x0441, r25	; 0x800441 <pxCurrentTimerList+0x1>
    2b22:	80 93 40 04 	sts	0x0440, r24	; 0x800440 <pxCurrentTimerList>
    pxOverflowTimerList = pxTemp;
    2b26:	f0 93 3f 04 	sts	0x043F, r31	; 0x80043f <pxOverflowTimerList+0x1>
    2b2a:	e0 93 3e 04 	sts	0x043E, r30	; 0x80043e <pxOverflowTimerList>
}
    2b2e:	df 91       	pop	r29
    2b30:	cf 91       	pop	r28
    2b32:	1f 91       	pop	r17
    2b34:	0f 91       	pop	r16
    2b36:	ff 90       	pop	r15
    2b38:	ef 90       	pop	r14
    2b3a:	08 95       	ret

00002b3c <prvTimerTask>:
    pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
}
/*-----------------------------------------------------------*/

static portTASK_FUNCTION( prvTimerTask, pvParameters )
{
    2b3c:	cf 93       	push	r28
    2b3e:	df 93       	push	r29
    2b40:	00 d0       	rcall	.+0      	; 0x2b42 <prvTimerTask+0x6>
    2b42:	00 d0       	rcall	.+0      	; 0x2b44 <prvTimerTask+0x8>
    2b44:	1f 92       	push	r1
    2b46:	cd b7       	in	r28, 0x3d	; 61
    2b48:	de b7       	in	r29, 0x3e	; 62
    the timer with the nearest expiry time will expire.  If there are no
    active timers then just set the next expire time to 0.  That will cause
    this task to unblock when the tick count overflows, at which point the
    timer lists will be switched and the next expiry time can be
    re-assessed.  */
    *pxListWasEmpty = listLIST_IS_EMPTY( pxCurrentTimerList );
    2b4a:	e0 91 40 04 	lds	r30, 0x0440	; 0x800440 <pxCurrentTimerList>
    2b4e:	f0 91 41 04 	lds	r31, 0x0441	; 0x800441 <pxCurrentTimerList+0x1>
    2b52:	d0 80       	ld	r13, Z
    if( *pxListWasEmpty == pdFALSE )
    2b54:	dd 20       	and	r13, r13
    2b56:	31 f0       	breq	.+12     	; 0x2b64 <prvTimerTask+0x28>
    {
        xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
    2b58:	05 80       	ldd	r0, Z+5	; 0x05
    2b5a:	f6 81       	ldd	r31, Z+6	; 0x06
    2b5c:	e0 2d       	mov	r30, r0
    2b5e:	e0 80       	ld	r14, Z
    2b60:	f1 80       	ldd	r15, Z+1	; 0x01
    2b62:	02 c0       	rjmp	.+4      	; 0x2b68 <prvTimerTask+0x2c>
    }
    else
    {
        /* Ensure the task unblocks when the tick count rolls over. */
        xNextExpireTime = ( TickType_t ) 0U;
    2b64:	e1 2c       	mov	r14, r1
    2b66:	f1 2c       	mov	r15, r1
static void prvProcessTimerOrBlockTask( const TickType_t xNextExpireTime, BaseType_t xListWasEmpty )
{
TickType_t xTimeNow;
BaseType_t xTimerListsWereSwitched;

    vTaskSuspendAll();
    2b68:	0e 94 16 11 	call	0x222c	; 0x222c <vTaskSuspendAll>
static TickType_t prvSampleTimeNow( BaseType_t * const pxTimerListsWereSwitched )
{
TickType_t xTimeNow;
PRIVILEGED_DATA static TickType_t xLastTime = ( TickType_t ) 0U; /*lint !e956 Variable is only accessible to one task. */

    xTimeNow = xTaskGetTickCount();
    2b6c:	0e 94 1c 11 	call	0x2238	; 0x2238 <xTaskGetTickCount>
    2b70:	8c 01       	movw	r16, r24

    if( xTimeNow < xLastTime )
    2b72:	80 91 38 04 	lds	r24, 0x0438	; 0x800438 <xLastTime.2412>
    2b76:	90 91 39 04 	lds	r25, 0x0439	; 0x800439 <xLastTime.2412+0x1>
    2b7a:	08 17       	cp	r16, r24
    2b7c:	19 07       	cpc	r17, r25
    2b7e:	20 f4       	brcc	.+8      	; 0x2b88 <prvTimerTask+0x4c>
    {
        prvSwitchTimerLists();
    2b80:	0e 94 4d 15 	call	0x2a9a	; 0x2a9a <prvSwitchTimerLists>
        *pxTimerListsWereSwitched = pdTRUE;
    2b84:	81 e0       	ldi	r24, 0x01	; 1
    2b86:	01 c0       	rjmp	.+2      	; 0x2b8a <prvTimerTask+0x4e>
    }
    else
    {
        *pxTimerListsWereSwitched = pdFALSE;
    2b88:	80 e0       	ldi	r24, 0x00	; 0
    }

    xLastTime = xTimeNow;
    2b8a:	10 93 39 04 	sts	0x0439, r17	; 0x800439 <xLastTime.2412+0x1>
    2b8e:	00 93 38 04 	sts	0x0438, r16	; 0x800438 <xLastTime.2412>
        has expired or not.  If obtaining the time causes the lists to switch
        then don't process this timer as any timers that remained in the list
        when the lists were switched will have been processed within the
        prvSampleTimeNow() function. */
        xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
        if( xTimerListsWereSwitched == pdFALSE )
    2b92:	81 11       	cpse	r24, r1
    2b94:	55 c0       	rjmp	.+170    	; 0x2c40 <prvTimerTask+0x104>
        {
            /* The tick count has not overflowed, has the timer expired? */
            if( ( xListWasEmpty == pdFALSE ) && ( xNextExpireTime <= xTimeNow ) )
    2b96:	dd 20       	and	r13, r13
    2b98:	d9 f1       	breq	.+118    	; 0x2c10 <prvTimerTask+0xd4>
    2b9a:	0e 15       	cp	r16, r14
    2b9c:	1f 05       	cpc	r17, r15
    2b9e:	08 f4       	brcc	.+2      	; 0x2ba2 <prvTimerTask+0x66>
    2ba0:	3e c0       	rjmp	.+124    	; 0x2c1e <prvTimerTask+0xe2>
            {
                ( void ) xTaskResumeAll();
    2ba2:	0e 94 d2 11 	call	0x23a4	; 0x23a4 <xTaskResumeAll>
/*-----------------------------------------------------------*/

static void prvProcessExpiredTimer( const TickType_t xNextExpireTime, const TickType_t xTimeNow )
{
BaseType_t xResult;
Timer_t * const pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList ); /*lint !e9087 !e9079 void * is used as this macro is used with tasks and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    2ba6:	e0 91 40 04 	lds	r30, 0x0440	; 0x800440 <pxCurrentTimerList>
    2baa:	f0 91 41 04 	lds	r31, 0x0441	; 0x800441 <pxCurrentTimerList+0x1>
    2bae:	05 80       	ldd	r0, Z+5	; 0x05
    2bb0:	f6 81       	ldd	r31, Z+6	; 0x06
    2bb2:	e0 2d       	mov	r30, r0
    2bb4:	c6 80       	ldd	r12, Z+6	; 0x06
    2bb6:	d7 80       	ldd	r13, Z+7	; 0x07

    /* Remove the timer from the list of active timers.  A check has already
    been performed to ensure the list is not empty. */
    ( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
    2bb8:	c6 01       	movw	r24, r12
    2bba:	02 96       	adiw	r24, 0x02	; 2
    2bbc:	0e 94 41 0a 	call	0x1482	; 0x1482 <uxListRemove>
    traceTIMER_EXPIRED( pxTimer );

    /* If the timer is an auto reload timer then calculate the next
    expiry time and re-insert the timer in the list of active timers. */
    if( ( pxTimer->ucStatus & tmrSTATUS_IS_AUTORELOAD ) != 0 )
    2bc0:	d6 01       	movw	r26, r12
    2bc2:	52 96       	adiw	r26, 0x12	; 18
    2bc4:	8c 91       	ld	r24, X
    2bc6:	52 97       	sbiw	r26, 0x12	; 18
    2bc8:	82 ff       	sbrs	r24, 2
    2bca:	17 c0       	rjmp	.+46     	; 0x2bfa <prvTimerTask+0xbe>
    {
        /* The timer is inserted into a list using a time relative to anything
        other than the current time.  It will therefore be inserted into the
        correct list relative to the time this task thinks it is now. */
        if( prvInsertTimerInActiveList( pxTimer, ( xNextExpireTime + pxTimer->xTimerPeriodInTicks ), xTimeNow, xNextExpireTime ) != pdFALSE )
    2bcc:	1c 96       	adiw	r26, 0x0c	; 12
    2bce:	6d 91       	ld	r22, X+
    2bd0:	7c 91       	ld	r23, X
    2bd2:	1d 97       	sbiw	r26, 0x0d	; 13
    2bd4:	6e 0d       	add	r22, r14
    2bd6:	7f 1d       	adc	r23, r15
    2bd8:	97 01       	movw	r18, r14
    2bda:	a8 01       	movw	r20, r16
    2bdc:	c6 01       	movw	r24, r12
    2bde:	0e 94 c4 14 	call	0x2988	; 0x2988 <prvInsertTimerInActiveList>
    2be2:	88 23       	and	r24, r24
    2be4:	69 f0       	breq	.+26     	; 0x2c00 <prvTimerTask+0xc4>
        {
            /* The timer expired before it was added to the active timer
            list.  Reload it now.  */
            xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY );
    2be6:	00 e0       	ldi	r16, 0x00	; 0
    2be8:	10 e0       	ldi	r17, 0x00	; 0
    2bea:	20 e0       	ldi	r18, 0x00	; 0
    2bec:	30 e0       	ldi	r19, 0x00	; 0
    2bee:	a7 01       	movw	r20, r14
    2bf0:	60 e0       	ldi	r22, 0x00	; 0
    2bf2:	c6 01       	movw	r24, r12
    2bf4:	0e 94 0e 15 	call	0x2a1c	; 0x2a1c <xTimerGenericCommand>
    2bf8:	03 c0       	rjmp	.+6      	; 0x2c00 <prvTimerTask+0xc4>
            mtCOVERAGE_TEST_MARKER();
        }
    }
    else
    {
        pxTimer->ucStatus &= ~tmrSTATUS_IS_ACTIVE;
    2bfa:	8e 7f       	andi	r24, 0xFE	; 254
    2bfc:	f6 01       	movw	r30, r12
    2bfe:	82 8b       	std	Z+18, r24	; 0x12
        mtCOVERAGE_TEST_MARKER();
    }

    /* Call the timer callback. */
    pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
    2c00:	d6 01       	movw	r26, r12
    2c02:	50 96       	adiw	r26, 0x10	; 16
    2c04:	ed 91       	ld	r30, X+
    2c06:	fc 91       	ld	r31, X
    2c08:	51 97       	sbiw	r26, 0x11	; 17
    2c0a:	c6 01       	movw	r24, r12
    2c0c:	09 95       	icall
    2c0e:	1e c0       	rjmp	.+60     	; 0x2c4c <prvTimerTask+0x110>
                case when the current timer list is empty. */
                if( xListWasEmpty != pdFALSE )
                {
                    /* The current timer list is empty - is the overflow list
                    also empty? */
                    xListWasEmpty = listLIST_IS_EMPTY( pxOverflowTimerList );
    2c10:	e0 91 3e 04 	lds	r30, 0x043E	; 0x80043e <pxOverflowTimerList>
    2c14:	f0 91 3f 04 	lds	r31, 0x043F	; 0x80043f <pxOverflowTimerList+0x1>
    2c18:	80 81       	ld	r24, Z
    2c1a:	41 e0       	ldi	r20, 0x01	; 1
    2c1c:	81 11       	cpse	r24, r1
        prvSampleTimeNow() function. */
        xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
        if( xTimerListsWereSwitched == pdFALSE )
        {
            /* The tick count has not overflowed, has the timer expired? */
            if( ( xListWasEmpty == pdFALSE ) && ( xNextExpireTime <= xTimeNow ) )
    2c1e:	40 e0       	ldi	r20, 0x00	; 0
                    /* The current timer list is empty - is the overflow list
                    also empty? */
                    xListWasEmpty = listLIST_IS_EMPTY( pxOverflowTimerList );
                }

                vQueueWaitForMessageRestricted( xTimerQueue, ( xNextExpireTime - xTimeNow ), xListWasEmpty );
    2c20:	b7 01       	movw	r22, r14
    2c22:	60 1b       	sub	r22, r16
    2c24:	71 0b       	sbc	r23, r17
    2c26:	80 91 3c 04 	lds	r24, 0x043C	; 0x80043c <xTimerQueue>
    2c2a:	90 91 3d 04 	lds	r25, 0x043D	; 0x80043d <xTimerQueue+0x1>
    2c2e:	0e 94 1b 0f 	call	0x1e36	; 0x1e36 <vQueueWaitForMessageRestricted>

                if( xTaskResumeAll() == pdFALSE )
    2c32:	0e 94 d2 11 	call	0x23a4	; 0x23a4 <xTaskResumeAll>
    2c36:	81 11       	cpse	r24, r1
    2c38:	09 c0       	rjmp	.+18     	; 0x2c4c <prvTimerTask+0x110>
                {
                    /* Yield to wait for either a command to arrive, or the
                    block time to expire.  If a command arrived between the
                    critical section being exited and this yield then the yield
                    will not cause the task to block. */
                    portYIELD_WITHIN_API();
    2c3a:	0e 94 09 0b 	call	0x1612	; 0x1612 <vPortYield>
    2c3e:	06 c0       	rjmp	.+12     	; 0x2c4c <prvTimerTask+0x110>
                }
            }
        }
        else
        {
            ( void ) xTaskResumeAll();
    2c40:	0e 94 d2 11 	call	0x23a4	; 0x23a4 <xTaskResumeAll>
    2c44:	03 c0       	rjmp	.+6      	; 0x2c4c <prvTimerTask+0x110>
        }
        #endif /* INCLUDE_xTimerPendFunctionCall */

        /* Commands that are positive are timer commands rather than pended
        function calls. */
        if( xMessage.xMessageID >= ( BaseType_t ) 0 )
    2c46:	89 81       	ldd	r24, Y+1	; 0x01
    2c48:	87 ff       	sbrs	r24, 7
    2c4a:	0e c0       	rjmp	.+28     	; 0x2c68 <prvTimerTask+0x12c>
DaemonTaskMessage_t xMessage;
Timer_t *pxTimer;
BaseType_t xTimerListsWereSwitched, xResult;
TickType_t xTimeNow;

    while( xQueueReceive( xTimerQueue, &xMessage, tmrNO_DELAY ) != pdFAIL ) /*lint !e603 xMessage does not have to be initialised as it is passed out, not in, and it is not used unless xQueueReceive() returns pdTRUE. */
    2c4c:	40 e0       	ldi	r20, 0x00	; 0
    2c4e:	50 e0       	ldi	r21, 0x00	; 0
    2c50:	be 01       	movw	r22, r28
    2c52:	6f 5f       	subi	r22, 0xFF	; 255
    2c54:	7f 4f       	sbci	r23, 0xFF	; 255
    2c56:	80 91 3c 04 	lds	r24, 0x043C	; 0x80043c <xTimerQueue>
    2c5a:	90 91 3d 04 	lds	r25, 0x043D	; 0x80043d <xTimerQueue+0x1>
    2c5e:	0e 94 c7 0d 	call	0x1b8e	; 0x1b8e <xQueueReceive>
    2c62:	81 11       	cpse	r24, r1
    2c64:	f0 cf       	rjmp	.-32     	; 0x2c46 <prvTimerTask+0x10a>
    2c66:	71 cf       	rjmp	.-286    	; 0x2b4a <prvTimerTask+0xe>
        function calls. */
        if( xMessage.xMessageID >= ( BaseType_t ) 0 )
        {
            /* The messages uses the xTimerParameters member to work on a
            software timer. */
            pxTimer = xMessage.u.xTimerParameters.pxTimer;
    2c68:	ec 80       	ldd	r14, Y+4	; 0x04
    2c6a:	fd 80       	ldd	r15, Y+5	; 0x05

        if( listIS_CONTAINED_WITHIN( NULL, &( pxTimer->xTimerListItem ) ) == pdFALSE ) /*lint !e961. The cast is only redundant when NULL is passed into the macro. */
    2c6c:	f7 01       	movw	r30, r14
    2c6e:	82 85       	ldd	r24, Z+10	; 0x0a
    2c70:	93 85       	ldd	r25, Z+11	; 0x0b
    2c72:	89 2b       	or	r24, r25
    2c74:	21 f0       	breq	.+8      	; 0x2c7e <prvTimerTask+0x142>
            {
                /* The timer is in a list, remove it. */
                ( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
    2c76:	c7 01       	movw	r24, r14
    2c78:	02 96       	adiw	r24, 0x02	; 2
    2c7a:	0e 94 41 0a 	call	0x1482	; 0x1482 <uxListRemove>
static TickType_t prvSampleTimeNow( BaseType_t * const pxTimerListsWereSwitched )
{
TickType_t xTimeNow;
PRIVILEGED_DATA static TickType_t xLastTime = ( TickType_t ) 0U; /*lint !e956 Variable is only accessible to one task. */

    xTimeNow = xTaskGetTickCount();
    2c7e:	0e 94 1c 11 	call	0x2238	; 0x2238 <xTaskGetTickCount>
    2c82:	6c 01       	movw	r12, r24

    if( xTimeNow < xLastTime )
    2c84:	80 91 38 04 	lds	r24, 0x0438	; 0x800438 <xLastTime.2412>
    2c88:	90 91 39 04 	lds	r25, 0x0439	; 0x800439 <xLastTime.2412+0x1>
    2c8c:	c8 16       	cp	r12, r24
    2c8e:	d9 06       	cpc	r13, r25
    2c90:	10 f4       	brcc	.+4      	; 0x2c96 <prvTimerTask+0x15a>
    {
        prvSwitchTimerLists();
    2c92:	0e 94 4d 15 	call	0x2a9a	; 0x2a9a <prvSwitchTimerLists>
    else
    {
        *pxTimerListsWereSwitched = pdFALSE;
    }

    xLastTime = xTimeNow;
    2c96:	d0 92 39 04 	sts	0x0439, r13	; 0x800439 <xLastTime.2412+0x1>
    2c9a:	c0 92 38 04 	sts	0x0438, r12	; 0x800438 <xLastTime.2412>
            possibility of a higher priority task adding a message to the message
            queue with a time that is ahead of the timer daemon task (because it
            pre-empted the timer daemon task after the xTimeNow value was set). */
            xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );

            switch( xMessage.xMessageID )
    2c9e:	e9 81       	ldd	r30, Y+1	; 0x01
    2ca0:	0e 2e       	mov	r0, r30
    2ca2:	00 0c       	add	r0, r0
    2ca4:	ff 0b       	sbc	r31, r31
    2ca6:	ea 30       	cpi	r30, 0x0A	; 10
    2ca8:	f1 05       	cpc	r31, r1
    2caa:	80 f6       	brcc	.-96     	; 0x2c4c <prvTimerTask+0x110>
    2cac:	ec 5c       	subi	r30, 0xCC	; 204
    2cae:	ff 4f       	sbci	r31, 0xFF	; 255
    2cb0:	d7 01       	movw	r26, r14
    2cb2:	52 96       	adiw	r26, 0x12	; 18
    2cb4:	8c 91       	ld	r24, X
    2cb6:	0c 94 fe 23 	jmp	0x47fc	; 0x47fc <__tablejump2__>
                case tmrCOMMAND_START_FROM_ISR :
                case tmrCOMMAND_RESET :
                case tmrCOMMAND_RESET_FROM_ISR :
                case tmrCOMMAND_START_DONT_TRACE :
                    /* Start or restart a timer. */
                    pxTimer->ucStatus |= tmrSTATUS_IS_ACTIVE;
    2cba:	81 60       	ori	r24, 0x01	; 1
    2cbc:	f7 01       	movw	r30, r14
    2cbe:	82 8b       	std	Z+18, r24	; 0x12
                    if( prvInsertTimerInActiveList( pxTimer,  xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, xTimeNow, xMessage.u.xTimerParameters.xMessageValue ) != pdFALSE )
    2cc0:	2a 81       	ldd	r18, Y+2	; 0x02
    2cc2:	3b 81       	ldd	r19, Y+3	; 0x03
    2cc4:	64 85       	ldd	r22, Z+12	; 0x0c
    2cc6:	75 85       	ldd	r23, Z+13	; 0x0d
    2cc8:	62 0f       	add	r22, r18
    2cca:	73 1f       	adc	r23, r19
    2ccc:	a6 01       	movw	r20, r12
    2cce:	c7 01       	movw	r24, r14
    2cd0:	0e 94 c4 14 	call	0x2988	; 0x2988 <prvInsertTimerInActiveList>
    2cd4:	88 23       	and	r24, r24
    2cd6:	09 f4       	brne	.+2      	; 0x2cda <prvTimerTask+0x19e>
    2cd8:	b9 cf       	rjmp	.-142    	; 0x2c4c <prvTimerTask+0x110>
                    {
                        /* The timer expired before it was added to the active
                        timer list.  Process it now. */
                        pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
    2cda:	d7 01       	movw	r26, r14
    2cdc:	50 96       	adiw	r26, 0x10	; 16
    2cde:	ed 91       	ld	r30, X+
    2ce0:	fc 91       	ld	r31, X
    2ce2:	51 97       	sbiw	r26, 0x11	; 17
    2ce4:	c7 01       	movw	r24, r14
    2ce6:	09 95       	icall
                        traceTIMER_EXPIRED( pxTimer );

                        if( ( pxTimer->ucStatus & tmrSTATUS_IS_AUTORELOAD ) != 0 )
    2ce8:	f7 01       	movw	r30, r14
    2cea:	82 89       	ldd	r24, Z+18	; 0x12
    2cec:	82 ff       	sbrs	r24, 2
    2cee:	ae cf       	rjmp	.-164    	; 0x2c4c <prvTimerTask+0x110>
                        {
                            xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, NULL, tmrNO_DELAY );
    2cf0:	4a 81       	ldd	r20, Y+2	; 0x02
    2cf2:	5b 81       	ldd	r21, Y+3	; 0x03
    2cf4:	84 85       	ldd	r24, Z+12	; 0x0c
    2cf6:	95 85       	ldd	r25, Z+13	; 0x0d
    2cf8:	48 0f       	add	r20, r24
    2cfa:	59 1f       	adc	r21, r25
    2cfc:	00 e0       	ldi	r16, 0x00	; 0
    2cfe:	10 e0       	ldi	r17, 0x00	; 0
    2d00:	20 e0       	ldi	r18, 0x00	; 0
    2d02:	30 e0       	ldi	r19, 0x00	; 0
    2d04:	60 e0       	ldi	r22, 0x00	; 0
    2d06:	c7 01       	movw	r24, r14
    2d08:	0e 94 0e 15 	call	0x2a1c	; 0x2a1c <xTimerGenericCommand>
    2d0c:	9f cf       	rjmp	.-194    	; 0x2c4c <prvTimerTask+0x110>
                    pxTimer->ucStatus &= ~tmrSTATUS_IS_ACTIVE;
                    break;

                case tmrCOMMAND_CHANGE_PERIOD :
                case tmrCOMMAND_CHANGE_PERIOD_FROM_ISR :
                    pxTimer->ucStatus |= tmrSTATUS_IS_ACTIVE;
    2d0e:	81 60       	ori	r24, 0x01	; 1
    2d10:	f7 01       	movw	r30, r14
    2d12:	82 8b       	std	Z+18, r24	; 0x12
                    pxTimer->xTimerPeriodInTicks = xMessage.u.xTimerParameters.xMessageValue;
    2d14:	6a 81       	ldd	r22, Y+2	; 0x02
    2d16:	7b 81       	ldd	r23, Y+3	; 0x03
    2d18:	75 87       	std	Z+13, r23	; 0x0d
    2d1a:	64 87       	std	Z+12, r22	; 0x0c
                    be longer or shorter than the old one.  The command time is
                    therefore set to the current time, and as the period cannot
                    be zero the next expiry time can only be in the future,
                    meaning (unlike for the xTimerStart() case above) there is
                    no fail case that needs to be handled here. */
                    ( void ) prvInsertTimerInActiveList( pxTimer, ( xTimeNow + pxTimer->xTimerPeriodInTicks ), xTimeNow, xTimeNow );
    2d1c:	6c 0d       	add	r22, r12
    2d1e:	7d 1d       	adc	r23, r13
    2d20:	96 01       	movw	r18, r12
    2d22:	a6 01       	movw	r20, r12
    2d24:	c7 01       	movw	r24, r14
    2d26:	0e 94 c4 14 	call	0x2988	; 0x2988 <prvInsertTimerInActiveList>
    2d2a:	90 cf       	rjmp	.-224    	; 0x2c4c <prvTimerTask+0x110>
                    #if ( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
                    {
                    /* The timer has already been removed from the active list,
                    just free up the memory if the memory was dynamically
                    allocated. */
                        if( ( pxTimer->ucStatus & tmrSTATUS_IS_STATICALLY_ALLOCATED ) == ( uint8_t ) 0 )
    2d2c:	81 fd       	sbrc	r24, 1
    2d2e:	04 c0       	rjmp	.+8      	; 0x2d38 <prvTimerTask+0x1fc>
                        {
                            vPortFree( pxTimer );
    2d30:	c7 01       	movw	r24, r14
    2d32:	0e 94 c5 09 	call	0x138a	; 0x138a <vPortFree>
    2d36:	8a cf       	rjmp	.-236    	; 0x2c4c <prvTimerTask+0x110>
                        }
                        else
                        {
                            pxTimer->ucStatus &= ~tmrSTATUS_IS_ACTIVE;
    2d38:	8e 7f       	andi	r24, 0xFE	; 254
    2d3a:	d7 01       	movw	r26, r14
    2d3c:	52 96       	adiw	r26, 0x12	; 18
    2d3e:	8c 93       	st	X, r24
    2d40:	85 cf       	rjmp	.-246    	; 0x2c4c <prvTimerTask+0x110>

00002d42 <initVariant>:
{
#if defined(USBCON)
    USBDevice.attach();
#endif

    setup();        // the normal Arduino setup() function is run here.
    2d42:	0e 94 24 06 	call	0xc48	; 0xc48 <setup>
    vTaskStartScheduler(); // initialise and run the freeRTOS scheduler. Execution should never return here.
    2d46:	0e 94 e8 10 	call	0x21d0	; 0x21d0 <vTaskStartScheduler>
    2d4a:	08 95       	ret

00002d4c <vApplicationIdleHook>:
 */
void vApplicationIdleHook( void ) __attribute__((weak));

void vApplicationIdleHook( void )
{
    loop();        // the normal Arduino loop() function is run here.
    2d4c:	0e 94 9a 06 	call	0xd34	; 0xd34 <loop>
    if (serialEventRun) serialEventRun();
    2d50:	85 e5       	ldi	r24, 0x55	; 85
    2d52:	9d e1       	ldi	r25, 0x1D	; 29
    2d54:	89 2b       	or	r24, r25
    2d56:	11 f0       	breq	.+4      	; 0x2d5c <vApplicationIdleHook+0x10>
    2d58:	0c 94 55 1d 	jmp	0x3aaa	; 0x3aaa <_Z14serialEventRunv>
    2d5c:	08 95       	ret

00002d5e <vApplicationMallocFailedHook>:
#elif defined(__AVR_ATmega644P__) || defined(__AVR_ATmega644PA__) || defined(__AVR_ATmega1284P__) || defined(__AVR_ATmega1284PA__) // Seeed Goldilocks with 1284p
    DDRB  |= _BV(DDB7);
    PORTB |= _BV(PORTB7);       // Main (red PB7) LED on. Main LED on.

#elif defined(__AVR_ATmega328P__) || defined(__AVR_ATmega168__) || defined(__AVR_ATmega8__) // assume we're using an Arduino Uno with 328p
    DDRB  |= _BV(DDB5);
    2d5e:	25 9a       	sbi	0x04, 5	; 4
    PORTB |= _BV(PORTB5);       // Main (red PB5) LED on. Main LED on.
    2d60:	2d 9a       	sbi	0x05, 5	; 5
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    2d62:	2f ef       	ldi	r18, 0xFF	; 255
    2d64:	80 e7       	ldi	r24, 0x70	; 112
    2d66:	92 e0       	ldi	r25, 0x02	; 2
    2d68:	21 50       	subi	r18, 0x01	; 1
    2d6a:	80 40       	sbci	r24, 0x00	; 0
    2d6c:	90 40       	sbci	r25, 0x00	; 0
    2d6e:	e1 f7       	brne	.-8      	; 0x2d68 <vApplicationMallocFailedHook+0xa>
    2d70:	00 c0       	rjmp	.+0      	; 0x2d72 <vApplicationMallocFailedHook+0x14>
    2d72:	00 00       	nop

#elif defined(__AVR_ATmega644P__) || defined(__AVR_ATmega644PA__) || defined(__AVR_ATmega1284P__) || defined(__AVR_ATmega1284PA__) // Seeed Goldilocks with 1284p
        PINB  |= _BV(PINB7);       // Main (red PB7) LED toggle. Main LED fast blink.

#elif defined(__AVR_ATmega328P__) || defined(__AVR_ATmega168__) || defined(__AVR_ATmega8__) // assume we're using an Arduino Uno with 328p
        PINB  |= _BV(PINB5);       // Main (red PB5) LED toggle. Main LED fast blink.
    2d74:	1d 9a       	sbi	0x03, 5	; 3
    2d76:	f5 cf       	rjmp	.-22     	; 0x2d62 <vApplicationMallocFailedHook+0x4>

00002d78 <vApplicationStackOverflowHook>:
#elif defined(__AVR_ATmega644P__) || defined(__AVR_ATmega644PA__) || defined(__AVR_ATmega1284P__) || defined(__AVR_ATmega1284PA__) // Seeed Goldilocks with 1284p
    DDRB  |= _BV(DDB7);
    PORTB |= _BV(PORTB7);       // Main (red PB7) LED on. Main LED on.

#elif defined(__AVR_ATmega328P__) || defined(__AVR_ATmega168__) || defined(__AVR_ATmega8__) // assume we're using an Arduino Uno with 328p
    DDRB  |= _BV(DDB5);
    2d78:	25 9a       	sbi	0x04, 5	; 4
    PORTB |= _BV(PORTB5);       // Main (red PB5) LED on. Main LED on.
    2d7a:	2d 9a       	sbi	0x05, 5	; 5
    2d7c:	2f ef       	ldi	r18, 0xFF	; 255
    2d7e:	87 ea       	ldi	r24, 0xA7	; 167
    2d80:	91 e6       	ldi	r25, 0x61	; 97
    2d82:	21 50       	subi	r18, 0x01	; 1
    2d84:	80 40       	sbci	r24, 0x00	; 0
    2d86:	90 40       	sbci	r25, 0x00	; 0
    2d88:	e1 f7       	brne	.-8      	; 0x2d82 <vApplicationStackOverflowHook+0xa>
    2d8a:	00 c0       	rjmp	.+0      	; 0x2d8c <vApplicationStackOverflowHook+0x14>
    2d8c:	00 00       	nop

#elif defined(__AVR_ATmega644P__) || defined(__AVR_ATmega644PA__) || defined(__AVR_ATmega1284P__) || defined(__AVR_ATmega1284PA__) // Seeed Goldilocks with 1284p
        PINB  |= _BV(PINB7);       // Main (red PB7) LED toggle. Main LED slow blink.

#elif defined(__AVR_ATmega328P__) || defined(__AVR_ATmega168__) || defined(__AVR_ATmega8__) // assume we're using an Arduino Uno with 328p
        PINB  |= _BV(PINB5);       // Main (red PB5) LED toggle. Main LED slow blink.
    2d8e:	1d 9a       	sbi	0x03, 5	; 3
    2d90:	f5 cf       	rjmp	.-22     	; 0x2d7c <vApplicationStackOverflowHook+0x4>

00002d92 <_ZN9MD_TCS23010initialiseEv>:
  }
  FreqCount.end();      // stop
  DUMP("VALUE ", FreqCount.read());

  return(FreqCount.read() * _readDiv);
}
    2d92:	0f 93       	push	r16
    2d94:	1f 93       	push	r17
    2d96:	fc 01       	movw	r30, r24
    2d98:	8f ef       	ldi	r24, 0xFF	; 255
    2d9a:	80 83       	st	Z, r24
    2d9c:	81 83       	std	Z+1, r24	; 0x01
    2d9e:	82 83       	std	Z+2, r24	; 0x02
    2da0:	83 83       	std	Z+3, r24	; 0x03
    2da2:	84 83       	std	Z+4, r24	; 0x04
    2da4:	8a e0       	ldi	r24, 0x0A	; 10
    2da6:	85 83       	std	Z+5, r24	; 0x05
    2da8:	16 82       	std	Z+6, r1	; 0x06
    2daa:	df 01       	movw	r26, r30
    2dac:	17 96       	adiw	r26, 0x07	; 7
    2dae:	73 96       	adiw	r30, 0x13	; 19
    2db0:	00 e7       	ldi	r16, 0x70	; 112
    2db2:	17 e1       	ldi	r17, 0x17	; 23
    2db4:	20 e0       	ldi	r18, 0x00	; 0
    2db6:	30 e0       	ldi	r19, 0x00	; 0
    2db8:	48 ed       	ldi	r20, 0xD8	; 216
    2dba:	56 ed       	ldi	r21, 0xD6	; 214
    2dbc:	60 e0       	ldi	r22, 0x00	; 0
    2dbe:	70 e0       	ldi	r23, 0x00	; 0
    2dc0:	0d 93       	st	X+, r16
    2dc2:	1d 93       	st	X+, r17
    2dc4:	2d 93       	st	X+, r18
    2dc6:	3d 93       	st	X+, r19
    2dc8:	18 96       	adiw	r26, 0x08	; 8
    2dca:	4d 93       	st	X+, r20
    2dcc:	5d 93       	st	X+, r21
    2dce:	6d 93       	st	X+, r22
    2dd0:	7c 93       	st	X, r23
    2dd2:	1b 97       	sbiw	r26, 0x0b	; 11
    2dd4:	ae 17       	cp	r26, r30
    2dd6:	bf 07       	cpc	r27, r31
    2dd8:	99 f7       	brne	.-26     	; 0x2dc0 <_ZN9MD_TCS23010initialiseEv+0x2e>
    2dda:	1f 91       	pop	r17
    2ddc:	0f 91       	pop	r16
    2dde:	08 95       	ret

00002de0 <_ZN9MD_TCS230C1Ehhh>:
    2de0:	ff 92       	push	r15
    2de2:	0f 93       	push	r16
    2de4:	1f 93       	push	r17
    2de6:	cf 93       	push	r28
    2de8:	df 93       	push	r29
    2dea:	ec 01       	movw	r28, r24
    2dec:	f6 2e       	mov	r15, r22
    2dee:	04 2f       	mov	r16, r20
    2df0:	12 2f       	mov	r17, r18
    2df2:	0e 94 c9 16 	call	0x2d92	; 0x2d92 <_ZN9MD_TCS23010initialiseEv>
    2df6:	fb 82       	std	Y+3, r15	; 0x03
    2df8:	0c 83       	std	Y+4, r16	; 0x04
    2dfa:	18 83       	st	Y, r17
    2dfc:	df 91       	pop	r29
    2dfe:	cf 91       	pop	r28
    2e00:	1f 91       	pop	r17
    2e02:	0f 91       	pop	r16
    2e04:	ff 90       	pop	r15
    2e06:	08 95       	ret

00002e08 <_ZN9MD_TCS230D1Ev>:
    2e08:	08 95       	ret

00002e0a <_ZN9MD_TCS2309setFilterEh>:
    2e0a:	cf 93       	push	r28
    2e0c:	df 93       	push	r29
    2e0e:	ec 01       	movw	r28, r24
    2e10:	8b 81       	ldd	r24, Y+3	; 0x03
    2e12:	8f 3f       	cpi	r24, 0xFF	; 255
    2e14:	e9 f0       	breq	.+58     	; 0x2e50 <_ZN9MD_TCS2309setFilterEh+0x46>
    2e16:	9c 81       	ldd	r25, Y+4	; 0x04
    2e18:	9f 3f       	cpi	r25, 0xFF	; 255
    2e1a:	d1 f0       	breq	.+52     	; 0x2e50 <_ZN9MD_TCS2309setFilterEh+0x46>
    2e1c:	61 30       	cpi	r22, 0x01	; 1
    2e1e:	49 f0       	breq	.+18     	; 0x2e32 <_ZN9MD_TCS2309setFilterEh+0x28>
    2e20:	30 f0       	brcs	.+12     	; 0x2e2e <_ZN9MD_TCS2309setFilterEh+0x24>
    2e22:	62 30       	cpi	r22, 0x02	; 2
    2e24:	41 f0       	breq	.+16     	; 0x2e36 <_ZN9MD_TCS2309setFilterEh+0x2c>
    2e26:	63 30       	cpi	r22, 0x03	; 3
    2e28:	99 f4       	brne	.+38     	; 0x2e50 <_ZN9MD_TCS2309setFilterEh+0x46>
    2e2a:	61 e0       	ldi	r22, 0x01	; 1
    2e2c:	09 c0       	rjmp	.+18     	; 0x2e40 <_ZN9MD_TCS2309setFilterEh+0x36>
    2e2e:	60 e0       	ldi	r22, 0x00	; 0
    2e30:	07 c0       	rjmp	.+14     	; 0x2e40 <_ZN9MD_TCS2309setFilterEh+0x36>
    2e32:	61 e0       	ldi	r22, 0x01	; 1
    2e34:	01 c0       	rjmp	.+2      	; 0x2e38 <_ZN9MD_TCS2309setFilterEh+0x2e>
    2e36:	60 e0       	ldi	r22, 0x00	; 0
    2e38:	0e 94 63 22 	call	0x44c6	; 0x44c6 <digitalWrite>
    2e3c:	61 e0       	ldi	r22, 0x01	; 1
    2e3e:	03 c0       	rjmp	.+6      	; 0x2e46 <_ZN9MD_TCS2309setFilterEh+0x3c>
    2e40:	0e 94 63 22 	call	0x44c6	; 0x44c6 <digitalWrite>
    2e44:	60 e0       	ldi	r22, 0x00	; 0
    2e46:	8c 81       	ldd	r24, Y+4	; 0x04
    2e48:	df 91       	pop	r29
    2e4a:	cf 91       	pop	r28
    2e4c:	0c 94 63 22 	jmp	0x44c6	; 0x44c6 <digitalWrite>
    2e50:	df 91       	pop	r29
    2e52:	cf 91       	pop	r28
    2e54:	08 95       	ret

00002e56 <_ZN9MD_TCS23013setFrequency2Eh>:
    2e56:	cf 93       	push	r28
    2e58:	df 93       	push	r29
    2e5a:	ec 01       	movw	r28, r24
    2e5c:	89 81       	ldd	r24, Y+1	; 0x01
    2e5e:	8f 3f       	cpi	r24, 0xFF	; 255
    2e60:	e9 f0       	breq	.+58     	; 0x2e9c <_ZN9MD_TCS23013setFrequency2Eh+0x46>
    2e62:	9a 81       	ldd	r25, Y+2	; 0x02
    2e64:	9f 3f       	cpi	r25, 0xFF	; 255
    2e66:	d1 f0       	breq	.+52     	; 0x2e9c <_ZN9MD_TCS23013setFrequency2Eh+0x46>
    2e68:	61 30       	cpi	r22, 0x01	; 1
    2e6a:	49 f0       	breq	.+18     	; 0x2e7e <_ZN9MD_TCS23013setFrequency2Eh+0x28>
    2e6c:	30 f0       	brcs	.+12     	; 0x2e7a <_ZN9MD_TCS23013setFrequency2Eh+0x24>
    2e6e:	62 30       	cpi	r22, 0x02	; 2
    2e70:	41 f0       	breq	.+16     	; 0x2e82 <_ZN9MD_TCS23013setFrequency2Eh+0x2c>
    2e72:	63 30       	cpi	r22, 0x03	; 3
    2e74:	99 f4       	brne	.+38     	; 0x2e9c <_ZN9MD_TCS23013setFrequency2Eh+0x46>
    2e76:	60 e0       	ldi	r22, 0x00	; 0
    2e78:	09 c0       	rjmp	.+18     	; 0x2e8c <_ZN9MD_TCS23013setFrequency2Eh+0x36>
    2e7a:	61 e0       	ldi	r22, 0x01	; 1
    2e7c:	03 c0       	rjmp	.+6      	; 0x2e84 <_ZN9MD_TCS23013setFrequency2Eh+0x2e>
    2e7e:	61 e0       	ldi	r22, 0x01	; 1
    2e80:	05 c0       	rjmp	.+10     	; 0x2e8c <_ZN9MD_TCS23013setFrequency2Eh+0x36>
    2e82:	60 e0       	ldi	r22, 0x00	; 0
    2e84:	0e 94 63 22 	call	0x44c6	; 0x44c6 <digitalWrite>
    2e88:	61 e0       	ldi	r22, 0x01	; 1
    2e8a:	03 c0       	rjmp	.+6      	; 0x2e92 <_ZN9MD_TCS23013setFrequency2Eh+0x3c>
    2e8c:	0e 94 63 22 	call	0x44c6	; 0x44c6 <digitalWrite>
    2e90:	60 e0       	ldi	r22, 0x00	; 0
    2e92:	8a 81       	ldd	r24, Y+2	; 0x02
    2e94:	df 91       	pop	r29
    2e96:	cf 91       	pop	r28
    2e98:	0c 94 63 22 	jmp	0x44c6	; 0x44c6 <digitalWrite>
    2e9c:	df 91       	pop	r29
    2e9e:	cf 91       	pop	r28
    2ea0:	08 95       	ret

00002ea2 <_ZN9MD_TCS2309setEnableEb>:
    2ea2:	fc 01       	movw	r30, r24
    2ea4:	20 81       	ld	r18, Z
    2ea6:	2f 3f       	cpi	r18, 0xFF	; 255
    2ea8:	29 f0       	breq	.+10     	; 0x2eb4 <_ZN9MD_TCS2309setEnableEb+0x12>
    2eaa:	91 e0       	ldi	r25, 0x01	; 1
    2eac:	69 27       	eor	r22, r25
    2eae:	82 2f       	mov	r24, r18
    2eb0:	0c 94 63 22 	jmp	0x44c6	; 0x44c6 <digitalWrite>
    2eb4:	66 23       	and	r22, r22
    2eb6:	19 f0       	breq	.+6      	; 0x2ebe <_ZN9MD_TCS2309setEnableEb+0x1c>
    2eb8:	fc 01       	movw	r30, r24
    2eba:	66 81       	ldd	r22, Z+6	; 0x06
    2ebc:	01 c0       	rjmp	.+2      	; 0x2ec0 <_ZN9MD_TCS2309setEnableEb+0x1e>
    2ebe:	63 e0       	ldi	r22, 0x03	; 3
    2ec0:	0c 94 2b 17 	jmp	0x2e56	; 0x2e56 <_ZN9MD_TCS23013setFrequency2Eh>

00002ec4 <_ZN9MD_TCS2305beginEv>:
    2ec4:	cf 93       	push	r28
    2ec6:	df 93       	push	r29
    2ec8:	ec 01       	movw	r28, r24
    2eca:	89 81       	ldd	r24, Y+1	; 0x01
    2ecc:	8f 3f       	cpi	r24, 0xFF	; 255
    2ece:	19 f0       	breq	.+6      	; 0x2ed6 <_ZN9MD_TCS2305beginEv+0x12>
    2ed0:	61 e0       	ldi	r22, 0x01	; 1
    2ed2:	0e 94 27 22 	call	0x444e	; 0x444e <pinMode>
    2ed6:	8a 81       	ldd	r24, Y+2	; 0x02
    2ed8:	8f 3f       	cpi	r24, 0xFF	; 255
    2eda:	19 f0       	breq	.+6      	; 0x2ee2 <_ZN9MD_TCS2305beginEv+0x1e>
    2edc:	61 e0       	ldi	r22, 0x01	; 1
    2ede:	0e 94 27 22 	call	0x444e	; 0x444e <pinMode>
    2ee2:	8b 81       	ldd	r24, Y+3	; 0x03
    2ee4:	8f 3f       	cpi	r24, 0xFF	; 255
    2ee6:	19 f0       	breq	.+6      	; 0x2eee <_ZN9MD_TCS2305beginEv+0x2a>
    2ee8:	61 e0       	ldi	r22, 0x01	; 1
    2eea:	0e 94 27 22 	call	0x444e	; 0x444e <pinMode>
    2eee:	8c 81       	ldd	r24, Y+4	; 0x04
    2ef0:	8f 3f       	cpi	r24, 0xFF	; 255
    2ef2:	19 f0       	breq	.+6      	; 0x2efa <_ZN9MD_TCS2305beginEv+0x36>
    2ef4:	61 e0       	ldi	r22, 0x01	; 1
    2ef6:	0e 94 27 22 	call	0x444e	; 0x444e <pinMode>
    2efa:	88 81       	ld	r24, Y
    2efc:	8f 3f       	cpi	r24, 0xFF	; 255
    2efe:	19 f0       	breq	.+6      	; 0x2f06 <_ZN9MD_TCS2305beginEv+0x42>
    2f00:	61 e0       	ldi	r22, 0x01	; 1
    2f02:	0e 94 27 22 	call	0x444e	; 0x444e <pinMode>
    2f06:	60 e0       	ldi	r22, 0x00	; 0
    2f08:	ce 01       	movw	r24, r28
    2f0a:	0e 94 51 17 	call	0x2ea2	; 0x2ea2 <_ZN9MD_TCS2309setEnableEb>
    2f0e:	6e 81       	ldd	r22, Y+6	; 0x06
    2f10:	ce 01       	movw	r24, r28
    2f12:	df 91       	pop	r29
    2f14:	cf 91       	pop	r28
    2f16:	0c 94 2b 17 	jmp	0x2e56	; 0x2e56 <_ZN9MD_TCS23013setFrequency2Eh>

00002f1a <_ZN9MD_TCS2306getRGBEP9colorData>:
    2f1a:	dc 01       	movw	r26, r24
    2f1c:	fb 01       	movw	r30, r22
    2f1e:	30 97       	sbiw	r30, 0x00	; 0
    2f20:	59 f0       	breq	.+22     	; 0x2f38 <_ZN9MD_TCS2306getRGBEP9colorData+0x1e>
    2f22:	9b 96       	adiw	r26, 0x2b	; 43
    2f24:	8c 91       	ld	r24, X
    2f26:	9b 97       	sbiw	r26, 0x2b	; 43
    2f28:	80 83       	st	Z, r24
    2f2a:	9c 96       	adiw	r26, 0x2c	; 44
    2f2c:	8c 91       	ld	r24, X
    2f2e:	9c 97       	sbiw	r26, 0x2c	; 44
    2f30:	81 83       	std	Z+1, r24	; 0x01
    2f32:	9d 96       	adiw	r26, 0x2d	; 45
    2f34:	8c 91       	ld	r24, X
    2f36:	82 83       	std	Z+2, r24	; 0x02
    2f38:	08 95       	ret

00002f3a <_ZN9MD_TCS23017RGBTransformationEv>:
  return(s);
}

void MD_TCS230::RGBTransformation(void)
// Exploiting linear relationship to remap the range 
{
    2f3a:	4f 92       	push	r4
    2f3c:	5f 92       	push	r5
    2f3e:	6f 92       	push	r6
    2f40:	7f 92       	push	r7
    2f42:	8f 92       	push	r8
    2f44:	9f 92       	push	r9
    2f46:	af 92       	push	r10
    2f48:	bf 92       	push	r11
    2f4a:	df 92       	push	r13
    2f4c:	ef 92       	push	r14
    2f4e:	ff 92       	push	r15
    2f50:	0f 93       	push	r16
    2f52:	1f 93       	push	r17
    2f54:	cf 93       	push	r28
    2f56:	df 93       	push	r29
    2f58:	8c 01       	movw	r16, r24
    2f5a:	09 5f       	subi	r16, 0xF9	; 249
    2f5c:	1f 4f       	sbci	r17, 0xFF	; 255
    2f5e:	ec 01       	movw	r28, r24
    2f60:	7c 01       	movw	r14, r24
    2f62:	83 e1       	ldi	r24, 0x13	; 19
    2f64:	e8 0e       	add	r14, r24
    2f66:	f1 1c       	adc	r15, r1
    x = (_Fo.value[i] - _Fd.value[i]) * 255;
    x /= (_Fw.value[i] - _Fd.value[i]);

    // copy results back into the global structures
    if (x < 0) _rgb.value[i] = 0; 
    else if (x > 255) _rgb.value[i] = 255;
    2f68:	dd 24       	eor	r13, r13
    2f6a:	da 94       	dec	r13
    2f6c:	f8 01       	movw	r30, r16
{
  int32_t x;

  for (uint8_t i=0; i<RGB_SIZE; i++)
  {
    x = (_Fo.value[i] - _Fd.value[i]) * 255;
    2f6e:	d8 01       	movw	r26, r16
    2f70:	8d 90       	ld	r8, X+
    2f72:	9d 90       	ld	r9, X+
    2f74:	ad 90       	ld	r10, X+
    2f76:	bd 90       	ld	r11, X+
    2f78:	8d 01       	movw	r16, r26
    2f7a:	80 8d       	ldd	r24, Z+24	; 0x18
    2f7c:	91 8d       	ldd	r25, Z+25	; 0x19
    2f7e:	a2 8d       	ldd	r26, Z+26	; 0x1a
    2f80:	b3 8d       	ldd	r27, Z+27	; 0x1b
    2f82:	9c 01       	movw	r18, r24
    2f84:	ad 01       	movw	r20, r26
    2f86:	28 19       	sub	r18, r8
    2f88:	39 09       	sbc	r19, r9
    2f8a:	4a 09       	sbc	r20, r10
    2f8c:	5b 09       	sbc	r21, r11
    2f8e:	af ef       	ldi	r26, 0xFF	; 255
    2f90:	b0 e0       	ldi	r27, 0x00	; 0
    2f92:	0e 94 04 24 	call	0x4808	; 0x4808 <__muluhisi3>
    x /= (_Fw.value[i] - _Fd.value[i]);
    2f96:	f8 01       	movw	r30, r16
    2f98:	40 84       	ldd	r4, Z+8	; 0x08
    2f9a:	51 84       	ldd	r5, Z+9	; 0x09
    2f9c:	62 84       	ldd	r6, Z+10	; 0x0a
    2f9e:	73 84       	ldd	r7, Z+11	; 0x0b
    2fa0:	a3 01       	movw	r20, r6
    2fa2:	92 01       	movw	r18, r4
    2fa4:	28 19       	sub	r18, r8
    2fa6:	39 09       	sbc	r19, r9
    2fa8:	4a 09       	sbc	r20, r10
    2faa:	5b 09       	sbc	r21, r11
    2fac:	0e 94 df 23 	call	0x47be	; 0x47be <__divmodsi4>

    // copy results back into the global structures
    if (x < 0) _rgb.value[i] = 0; 
    2fb0:	57 ff       	sbrs	r21, 7
    2fb2:	02 c0       	rjmp	.+4      	; 0x2fb8 <_ZN9MD_TCS23017RGBTransformationEv+0x7e>
    2fb4:	1b a6       	std	Y+43, r1	; 0x2b
    2fb6:	09 c0       	rjmp	.+18     	; 0x2fca <_ZN9MD_TCS23017RGBTransformationEv+0x90>
    else if (x > 255) _rgb.value[i] = 255;
    2fb8:	2f 3f       	cpi	r18, 0xFF	; 255
    2fba:	31 05       	cpc	r19, r1
    2fbc:	41 05       	cpc	r20, r1
    2fbe:	51 05       	cpc	r21, r1
    2fc0:	19 f0       	breq	.+6      	; 0x2fc8 <_ZN9MD_TCS23017RGBTransformationEv+0x8e>
    2fc2:	14 f0       	brlt	.+4      	; 0x2fc8 <_ZN9MD_TCS23017RGBTransformationEv+0x8e>
    2fc4:	db a6       	std	Y+43, r13	; 0x2b
    2fc6:	01 c0       	rjmp	.+2      	; 0x2fca <_ZN9MD_TCS23017RGBTransformationEv+0x90>
    else _rgb.value[i] = x;
    2fc8:	2b a7       	std	Y+43, r18	; 0x2b
    2fca:	21 96       	adiw	r28, 0x01	; 1
void MD_TCS230::RGBTransformation(void)
// Exploiting linear relationship to remap the range 
{
  int32_t x;

  for (uint8_t i=0; i<RGB_SIZE; i++)
    2fcc:	0e 15       	cp	r16, r14
    2fce:	1f 05       	cpc	r17, r15
    2fd0:	69 f6       	brne	.-102    	; 0x2f6c <_ZN9MD_TCS23017RGBTransformationEv+0x32>
    // copy results back into the global structures
    if (x < 0) _rgb.value[i] = 0; 
    else if (x > 255) _rgb.value[i] = 255;
    else _rgb.value[i] = x;
  }
}
    2fd2:	df 91       	pop	r29
    2fd4:	cf 91       	pop	r28
    2fd6:	1f 91       	pop	r17
    2fd8:	0f 91       	pop	r16
    2fda:	ff 90       	pop	r15
    2fdc:	ef 90       	pop	r14
    2fde:	df 90       	pop	r13
    2fe0:	bf 90       	pop	r11
    2fe2:	af 90       	pop	r10
    2fe4:	9f 90       	pop	r9
    2fe6:	8f 90       	pop	r8
    2fe8:	7f 90       	pop	r7
    2fea:	6f 90       	pop	r6
    2fec:	5f 90       	pop	r5
    2fee:	4f 90       	pop	r4
    2ff0:	08 95       	ret

00002ff2 <_ZN9MD_TCS2307readFSMEh>:
  return(_readState == 0);
}

uint8_t MD_TCS230::readFSM(uint8_t s)
// Finite State Machine to read a value (internal function)
{
    2ff2:	0f 93       	push	r16
    2ff4:	1f 93       	push	r17
    2ff6:	cf 93       	push	r28
    2ff8:	df 93       	push	r29
    2ffa:	8c 01       	movw	r16, r24
    2ffc:	c6 2f       	mov	r28, r22
  static const uint8_t seq[] = { TCS230_RGB_R, TCS230_RGB_G, TCS230_RGB_B };
  static uint8_t       currCol;  // index for seq above

  switch(s)
    2ffe:	61 30       	cpi	r22, 0x01	; 1
    3000:	49 f0       	breq	.+18     	; 0x3014 <_ZN9MD_TCS2307readFSMEh+0x22>
    3002:	18 f0       	brcs	.+6      	; 0x300a <_ZN9MD_TCS2307readFSMEh+0x18>
    3004:	62 30       	cpi	r22, 0x02	; 2
    3006:	d9 f0       	breq	.+54     	; 0x303e <_ZN9MD_TCS2307readFSMEh+0x4c>
    3008:	4c c0       	rjmp	.+152    	; 0x30a2 <_ZN9MD_TCS2307readFSMEh+0xb0>
  {
  case 0: // enable the hardware for reading
    DUMPS("\n0");
    currCol = 0;  // RGB_R but we don't care
    300a:	10 92 54 04 	sts	0x0454, r1	; 0x800454 <_ZZN9MD_TCS2307readFSMEhE7currCol>
    setEnable(true);
    300e:	61 e0       	ldi	r22, 0x01	; 1
    3010:	0e 94 51 17 	call	0x2ea2	; 0x2ea2 <_ZN9MD_TCS2309setEnableEb>
    s++;
    // fall through to the next state

  case 1: // select a filter and start a reading
    DUMPS("\n1");
    setFilter(seq[currCol]);
    3014:	e0 91 54 04 	lds	r30, 0x0454	; 0x800454 <_ZZN9MD_TCS2307readFSMEhE7currCol>
    3018:	f0 e0       	ldi	r31, 0x00	; 0
    301a:	e2 5a       	subi	r30, 0xA2	; 162
    301c:	fd 4f       	sbci	r31, 0xFD	; 253
    301e:	60 81       	ld	r22, Z
    3020:	c8 01       	movw	r24, r16
    3022:	0e 94 05 17 	call	0x2e0a	; 0x2e0a <_ZN9MD_TCS2309setFilterEh>
    FreqCount.begin(1000/_readDiv);
    3026:	f8 01       	movw	r30, r16
    3028:	65 81       	ldd	r22, Z+5	; 0x05
    302a:	70 e0       	ldi	r23, 0x00	; 0
    302c:	88 ee       	ldi	r24, 0xE8	; 232
    302e:	93 e0       	ldi	r25, 0x03	; 3
    3030:	0e 94 a9 23 	call	0x4752	; 0x4752 <__divmodhi4>
    3034:	cb 01       	movw	r24, r22
    3036:	0e 94 92 22 	call	0x4524	; 0x4524 <_ZN14FreqCountClass5beginEj>
    s++;
    303a:	c2 e0       	ldi	r28, 0x02	; 2
    break;
    303c:	32 c0       	rjmp	.+100    	; 0x30a2 <_ZN9MD_TCS2307readFSMEh+0xb0>

  case 2: // see if a value is available
    DUMPS("2");
    if (FreqCount.available())
    303e:	0e 94 0a 23 	call	0x4614	; 0x4614 <_ZN14FreqCountClass9availableEv>
    3042:	88 23       	and	r24, r24
    3044:	71 f1       	breq	.+92     	; 0x30a2 <_ZN9MD_TCS2307readFSMEh+0xb0>
    {
      DUMP(" VALUE ", FreqCount.read());
      // read the value and save it 
      _Fo.value[seq[currCol++]] = FreqCount.read() * _readDiv;
    3046:	e0 91 54 04 	lds	r30, 0x0454	; 0x800454 <_ZZN9MD_TCS2307readFSMEhE7currCol>
    304a:	81 e0       	ldi	r24, 0x01	; 1
    304c:	8e 0f       	add	r24, r30
    304e:	80 93 54 04 	sts	0x0454, r24	; 0x800454 <_ZZN9MD_TCS2307readFSMEhE7currCol>
    3052:	f0 e0       	ldi	r31, 0x00	; 0
    3054:	e2 5a       	subi	r30, 0xA2	; 162
    3056:	fd 4f       	sbci	r31, 0xFD	; 253
    3058:	c0 81       	ld	r28, Z
    305a:	d0 e0       	ldi	r29, 0x00	; 0
    305c:	0e 94 0d 23 	call	0x461a	; 0x461a <_ZN14FreqCountClass4readEv>
    3060:	9b 01       	movw	r18, r22
    3062:	ac 01       	movw	r20, r24
    3064:	cc 0f       	add	r28, r28
    3066:	dd 1f       	adc	r29, r29
    3068:	cc 0f       	add	r28, r28
    306a:	dd 1f       	adc	r29, r29
    306c:	c0 0f       	add	r28, r16
    306e:	d1 1f       	adc	r29, r17
    3070:	f8 01       	movw	r30, r16
    3072:	a5 81       	ldd	r26, Z+5	; 0x05
    3074:	b0 e0       	ldi	r27, 0x00	; 0
    3076:	0e 94 04 24 	call	0x4808	; 0x4808 <__muluhisi3>
    307a:	6f 8f       	std	Y+31, r22	; 0x1f
    307c:	78 a3       	std	Y+32, r23	; 0x20
    307e:	89 a3       	std	Y+33, r24	; 0x21
    3080:	9a a3       	std	Y+34, r25	; 0x22

      if (currCol < RGB_SIZE)
    3082:	80 91 54 04 	lds	r24, 0x0454	; 0x800454 <_ZZN9MD_TCS2307readFSMEhE7currCol>
    3086:	83 30       	cpi	r24, 0x03	; 3
    3088:	58 f0       	brcs	.+22     	; 0x30a0 <_ZN9MD_TCS2307readFSMEh+0xae>
        s--;
      }
      else
      {
        // end this reading session
        FreqCount.end();
    308a:	0e 94 1b 23 	call	0x4636	; 0x4636 <_ZN14FreqCountClass3endEv>
        setEnable(false);
    308e:	60 e0       	ldi	r22, 0x00	; 0
    3090:	c8 01       	movw	r24, r16
    3092:	0e 94 51 17 	call	0x2ea2	; 0x2ea2 <_ZN9MD_TCS2309setEnableEb>
        RGBTransformation();
    3096:	c8 01       	movw	r24, r16
    3098:	0e 94 9d 17 	call	0x2f3a	; 0x2f3a <_ZN9MD_TCS23017RGBTransformationEv>
        s = 0;
    309c:	c0 e0       	ldi	r28, 0x00	; 0
    309e:	01 c0       	rjmp	.+2      	; 0x30a2 <_ZN9MD_TCS2307readFSMEh+0xb0>
      _Fo.value[seq[currCol++]] = FreqCount.read() * _readDiv;

      if (currCol < RGB_SIZE)
      {
        // loop around again on next call to available()
        s--;
    30a0:	c1 e0       	ldi	r28, 0x01	; 1
    }
    break;
  }

  return(s);
}
    30a2:	8c 2f       	mov	r24, r28
    30a4:	df 91       	pop	r29
    30a6:	cf 91       	pop	r28
    30a8:	1f 91       	pop	r17
    30aa:	0f 91       	pop	r16
    30ac:	08 95       	ret

000030ae <_ZN9MD_TCS2304readEv>:
  return(FreqCount.read() * _readDiv);
}

void MD_TCS230::read(void)
// initiate the finite state machine for reading a value
{
    30ae:	cf 93       	push	r28
    30b0:	df 93       	push	r29
    30b2:	ec 01       	movw	r28, r24
  _readState = readFSM(0);
    30b4:	60 e0       	ldi	r22, 0x00	; 0
    30b6:	0e 94 f9 17 	call	0x2ff2	; 0x2ff2 <_ZN9MD_TCS2307readFSMEh>
    30ba:	8e a7       	std	Y+46, r24	; 0x2e
}
    30bc:	df 91       	pop	r29
    30be:	cf 91       	pop	r28
    30c0:	08 95       	ret

000030c2 <_ZN9MD_TCS2309availableEv>:

bool MD_TCS230::available(void)
// check if a value is ready. Called repeatedly until it is!
{
    30c2:	cf 93       	push	r28
    30c4:	df 93       	push	r29
    30c6:	ec 01       	movw	r28, r24
  _readState = readFSM(_readState);
    30c8:	6e a5       	ldd	r22, Y+46	; 0x2e
    30ca:	0e 94 f9 17 	call	0x2ff2	; 0x2ff2 <_ZN9MD_TCS2307readFSMEh>
    30ce:	98 2f       	mov	r25, r24
    30d0:	8e a7       	std	Y+46, r24	; 0x2e

  return(_readState == 0);
    30d2:	81 e0       	ldi	r24, 0x01	; 1
    30d4:	91 11       	cpse	r25, r1
    30d6:	80 e0       	ldi	r24, 0x00	; 0
}
    30d8:	df 91       	pop	r29
    30da:	cf 91       	pop	r28
    30dc:	08 95       	ret

000030de <_ZN5Print17availableForWriteEv>:
uint16_t SoftwareSerial::subtract_cap(uint16_t num, uint16_t sub) {
  if (num > sub)
    return num - sub;
  else
    return 1;
}
    30de:	80 e0       	ldi	r24, 0x00	; 0
    30e0:	90 e0       	ldi	r25, 0x00	; 0
    30e2:	08 95       	ret

000030e4 <_ZN14SoftwareSerial4readEv>:
    30e4:	20 91 97 04 	lds	r18, 0x0497	; 0x800497 <_ZN14SoftwareSerial13active_objectE>
    30e8:	30 91 98 04 	lds	r19, 0x0498	; 0x800498 <_ZN14SoftwareSerial13active_objectE+0x1>
    30ec:	28 17       	cp	r18, r24
    30ee:	39 07       	cpc	r19, r25
    30f0:	b9 f4       	brne	.+46     	; 0x3120 <_ZN14SoftwareSerial4readEv+0x3c>
    30f2:	90 91 55 04 	lds	r25, 0x0455	; 0x800455 <_ZN14SoftwareSerial20_receive_buffer_headE>
    30f6:	80 91 56 04 	lds	r24, 0x0456	; 0x800456 <_ZN14SoftwareSerial20_receive_buffer_tailE>
    30fa:	98 17       	cp	r25, r24
    30fc:	89 f0       	breq	.+34     	; 0x3120 <_ZN14SoftwareSerial4readEv+0x3c>
    30fe:	e0 91 55 04 	lds	r30, 0x0455	; 0x800455 <_ZN14SoftwareSerial20_receive_buffer_headE>
    3102:	f0 e0       	ldi	r31, 0x00	; 0
    3104:	e9 5a       	subi	r30, 0xA9	; 169
    3106:	fb 4f       	sbci	r31, 0xFB	; 251
    3108:	80 81       	ld	r24, Z
    310a:	20 91 55 04 	lds	r18, 0x0455	; 0x800455 <_ZN14SoftwareSerial20_receive_buffer_headE>
    310e:	30 e0       	ldi	r19, 0x00	; 0
    3110:	2f 5f       	subi	r18, 0xFF	; 255
    3112:	3f 4f       	sbci	r19, 0xFF	; 255
    3114:	2f 73       	andi	r18, 0x3F	; 63
    3116:	33 27       	eor	r19, r19
    3118:	20 93 55 04 	sts	0x0455, r18	; 0x800455 <_ZN14SoftwareSerial20_receive_buffer_headE>
    311c:	90 e0       	ldi	r25, 0x00	; 0
    311e:	08 95       	ret
    3120:	8f ef       	ldi	r24, 0xFF	; 255
    3122:	9f ef       	ldi	r25, 0xFF	; 255
    3124:	08 95       	ret

00003126 <_ZN14SoftwareSerial5writeEh>:
    3126:	1f 93       	push	r17
    3128:	cf 93       	push	r28
    312a:	df 93       	push	r29
    312c:	dc 01       	movw	r26, r24
    312e:	5c 96       	adiw	r26, 0x1c	; 28
    3130:	8d 91       	ld	r24, X+
    3132:	9c 91       	ld	r25, X
    3134:	5d 97       	sbiw	r26, 0x1d	; 29
    3136:	00 97       	sbiw	r24, 0x00	; 0
    3138:	39 f4       	brne	.+14     	; 0x3148 <_ZN14SoftwareSerial5writeEh+0x22>
    313a:	21 e0       	ldi	r18, 0x01	; 1
    313c:	30 e0       	ldi	r19, 0x00	; 0
    313e:	13 96       	adiw	r26, 0x03	; 3
    3140:	3c 93       	st	X, r19
    3142:	2e 93       	st	-X, r18
    3144:	12 97       	sbiw	r26, 0x02	; 2
    3146:	3b c0       	rjmp	.+118    	; 0x31be <_ZN14SoftwareSerial5writeEh+0x98>
    3148:	51 96       	adiw	r26, 0x11	; 17
    314a:	ed 91       	ld	r30, X+
    314c:	fc 91       	ld	r31, X
    314e:	52 97       	sbiw	r26, 0x12	; 18
    3150:	50 96       	adiw	r26, 0x10	; 16
    3152:	2c 91       	ld	r18, X
    3154:	50 97       	sbiw	r26, 0x10	; 16
    3156:	32 2f       	mov	r19, r18
    3158:	30 95       	com	r19
    315a:	1f b7       	in	r17, 0x3f	; 63
    315c:	5e 96       	adiw	r26, 0x1e	; 30
    315e:	4c 91       	ld	r20, X
    3160:	5e 97       	sbiw	r26, 0x1e	; 30
    3162:	74 2f       	mov	r23, r20
    3164:	72 70       	andi	r23, 0x02	; 2
    3166:	41 fd       	sbrc	r20, 1
    3168:	60 95       	com	r22
    316a:	f8 94       	cli
    316c:	40 81       	ld	r20, Z
    316e:	77 23       	and	r23, r23
    3170:	11 f0       	breq	.+4      	; 0x3176 <_ZN14SoftwareSerial5writeEh+0x50>
    3172:	42 2b       	or	r20, r18
    3174:	01 c0       	rjmp	.+2      	; 0x3178 <_ZN14SoftwareSerial5writeEh+0x52>
    3176:	43 23       	and	r20, r19
    3178:	40 83       	st	Z, r20
    317a:	ec 01       	movw	r28, r24
    317c:	21 97       	sbiw	r28, 0x01	; 1
    317e:	f1 f7       	brne	.-4      	; 0x317c <_ZN14SoftwareSerial5writeEh+0x56>
    3180:	48 e0       	ldi	r20, 0x08	; 8
    3182:	50 81       	ld	r21, Z
    3184:	60 ff       	sbrs	r22, 0
    3186:	02 c0       	rjmp	.+4      	; 0x318c <_ZN14SoftwareSerial5writeEh+0x66>
    3188:	52 2b       	or	r21, r18
    318a:	01 c0       	rjmp	.+2      	; 0x318e <_ZN14SoftwareSerial5writeEh+0x68>
    318c:	53 23       	and	r21, r19
    318e:	50 83       	st	Z, r21
    3190:	ec 01       	movw	r28, r24
    3192:	21 97       	sbiw	r28, 0x01	; 1
    3194:	f1 f7       	brne	.-4      	; 0x3192 <_ZN14SoftwareSerial5writeEh+0x6c>
    3196:	66 95       	lsr	r22
    3198:	41 50       	subi	r20, 0x01	; 1
    319a:	99 f7       	brne	.-26     	; 0x3182 <_ZN14SoftwareSerial5writeEh+0x5c>
    319c:	80 81       	ld	r24, Z
    319e:	77 23       	and	r23, r23
    31a0:	19 f0       	breq	.+6      	; 0x31a8 <_ZN14SoftwareSerial5writeEh+0x82>
    31a2:	83 23       	and	r24, r19
    31a4:	80 83       	st	Z, r24
    31a6:	02 c0       	rjmp	.+4      	; 0x31ac <_ZN14SoftwareSerial5writeEh+0x86>
    31a8:	28 2b       	or	r18, r24
    31aa:	20 83       	st	Z, r18
    31ac:	1f bf       	out	0x3f, r17	; 63
    31ae:	5c 96       	adiw	r26, 0x1c	; 28
    31b0:	8d 91       	ld	r24, X+
    31b2:	9c 91       	ld	r25, X
    31b4:	5d 97       	sbiw	r26, 0x1d	; 29
    31b6:	01 97       	sbiw	r24, 0x01	; 1
    31b8:	f1 f7       	brne	.-4      	; 0x31b6 <_ZN14SoftwareSerial5writeEh+0x90>
    31ba:	81 e0       	ldi	r24, 0x01	; 1
    31bc:	90 e0       	ldi	r25, 0x00	; 0
    31be:	df 91       	pop	r29
    31c0:	cf 91       	pop	r28
    31c2:	1f 91       	pop	r17
    31c4:	08 95       	ret

000031c6 <_ZN14SoftwareSerial5flushEv>:
    31c6:	08 95       	ret

000031c8 <_ZN14SoftwareSerial4peekEv>:
    31c8:	20 91 97 04 	lds	r18, 0x0497	; 0x800497 <_ZN14SoftwareSerial13active_objectE>
    31cc:	30 91 98 04 	lds	r19, 0x0498	; 0x800498 <_ZN14SoftwareSerial13active_objectE+0x1>
    31d0:	28 17       	cp	r18, r24
    31d2:	39 07       	cpc	r19, r25
    31d4:	71 f4       	brne	.+28     	; 0x31f2 <_ZN14SoftwareSerial4peekEv+0x2a>
    31d6:	90 91 55 04 	lds	r25, 0x0455	; 0x800455 <_ZN14SoftwareSerial20_receive_buffer_headE>
    31da:	80 91 56 04 	lds	r24, 0x0456	; 0x800456 <_ZN14SoftwareSerial20_receive_buffer_tailE>
    31de:	98 17       	cp	r25, r24
    31e0:	41 f0       	breq	.+16     	; 0x31f2 <_ZN14SoftwareSerial4peekEv+0x2a>
    31e2:	e0 91 55 04 	lds	r30, 0x0455	; 0x800455 <_ZN14SoftwareSerial20_receive_buffer_headE>
    31e6:	f0 e0       	ldi	r31, 0x00	; 0
    31e8:	e9 5a       	subi	r30, 0xA9	; 169
    31ea:	fb 4f       	sbci	r31, 0xFB	; 251
    31ec:	80 81       	ld	r24, Z
    31ee:	90 e0       	ldi	r25, 0x00	; 0
    31f0:	08 95       	ret
    31f2:	8f ef       	ldi	r24, 0xFF	; 255
    31f4:	9f ef       	ldi	r25, 0xFF	; 255
    31f6:	08 95       	ret

000031f8 <_ZN14SoftwareSerial9availableEv>:
    31f8:	20 91 97 04 	lds	r18, 0x0497	; 0x800497 <_ZN14SoftwareSerial13active_objectE>
    31fc:	30 91 98 04 	lds	r19, 0x0498	; 0x800498 <_ZN14SoftwareSerial13active_objectE+0x1>
    3200:	28 17       	cp	r18, r24
    3202:	39 07       	cpc	r19, r25
    3204:	71 f4       	brne	.+28     	; 0x3222 <_ZN14SoftwareSerial9availableEv+0x2a>
    3206:	80 91 56 04 	lds	r24, 0x0456	; 0x800456 <_ZN14SoftwareSerial20_receive_buffer_tailE>
    320a:	20 91 55 04 	lds	r18, 0x0455	; 0x800455 <_ZN14SoftwareSerial20_receive_buffer_headE>
    320e:	90 e0       	ldi	r25, 0x00	; 0
    3210:	80 5c       	subi	r24, 0xC0	; 192
    3212:	9f 4f       	sbci	r25, 0xFF	; 255
    3214:	82 1b       	sub	r24, r18
    3216:	91 09       	sbc	r25, r1
    3218:	60 e4       	ldi	r22, 0x40	; 64
    321a:	70 e0       	ldi	r23, 0x00	; 0
    321c:	0e 94 a9 23 	call	0x4752	; 0x4752 <__divmodhi4>
    3220:	08 95       	ret
    3222:	80 e0       	ldi	r24, 0x00	; 0
    3224:	90 e0       	ldi	r25, 0x00	; 0
    3226:	08 95       	ret

00003228 <_ZN14SoftwareSerial13stopListeningEv>:
    3228:	e0 91 97 04 	lds	r30, 0x0497	; 0x800497 <_ZN14SoftwareSerial13active_objectE>
    322c:	f0 91 98 04 	lds	r31, 0x0498	; 0x800498 <_ZN14SoftwareSerial13active_objectE+0x1>
    3230:	e8 17       	cp	r30, r24
    3232:	f9 07       	cpc	r31, r25
    3234:	69 f4       	brne	.+26     	; 0x3250 <_ZN14SoftwareSerial13stopListeningEv+0x28>
    3236:	a3 89       	ldd	r26, Z+19	; 0x13
    3238:	b4 89       	ldd	r27, Z+20	; 0x14
    323a:	9c 91       	ld	r25, X
    323c:	85 89       	ldd	r24, Z+21	; 0x15
    323e:	80 95       	com	r24
    3240:	89 23       	and	r24, r25
    3242:	8c 93       	st	X, r24
    3244:	10 92 98 04 	sts	0x0498, r1	; 0x800498 <_ZN14SoftwareSerial13active_objectE+0x1>
    3248:	10 92 97 04 	sts	0x0497, r1	; 0x800497 <_ZN14SoftwareSerial13active_objectE>
    324c:	81 e0       	ldi	r24, 0x01	; 1
    324e:	08 95       	ret
    3250:	80 e0       	ldi	r24, 0x00	; 0
    3252:	08 95       	ret

00003254 <_ZN14SoftwareSerial6listenEv>:
    3254:	cf 93       	push	r28
    3256:	df 93       	push	r29
    3258:	ec 01       	movw	r28, r24
    325a:	8a 8d       	ldd	r24, Y+26	; 0x1a
    325c:	9b 8d       	ldd	r25, Y+27	; 0x1b
    325e:	89 2b       	or	r24, r25
    3260:	f1 f0       	breq	.+60     	; 0x329e <_ZN14SoftwareSerial6listenEv+0x4a>
    3262:	80 91 97 04 	lds	r24, 0x0497	; 0x800497 <_ZN14SoftwareSerial13active_objectE>
    3266:	90 91 98 04 	lds	r25, 0x0498	; 0x800498 <_ZN14SoftwareSerial13active_objectE+0x1>
    326a:	c8 17       	cp	r28, r24
    326c:	d9 07       	cpc	r29, r25
    326e:	b9 f0       	breq	.+46     	; 0x329e <_ZN14SoftwareSerial6listenEv+0x4a>
    3270:	00 97       	sbiw	r24, 0x00	; 0
    3272:	11 f0       	breq	.+4      	; 0x3278 <_ZN14SoftwareSerial6listenEv+0x24>
    3274:	0e 94 14 19 	call	0x3228	; 0x3228 <_ZN14SoftwareSerial13stopListeningEv>
    3278:	8e 8d       	ldd	r24, Y+30	; 0x1e
    327a:	8e 7f       	andi	r24, 0xFE	; 254
    327c:	8e 8f       	std	Y+30, r24	; 0x1e
    327e:	10 92 56 04 	sts	0x0456, r1	; 0x800456 <_ZN14SoftwareSerial20_receive_buffer_tailE>
    3282:	10 92 55 04 	sts	0x0455, r1	; 0x800455 <_ZN14SoftwareSerial20_receive_buffer_headE>
    3286:	d0 93 98 04 	sts	0x0498, r29	; 0x800498 <_ZN14SoftwareSerial13active_objectE+0x1>
    328a:	c0 93 97 04 	sts	0x0497, r28	; 0x800497 <_ZN14SoftwareSerial13active_objectE>
    328e:	eb 89       	ldd	r30, Y+19	; 0x13
    3290:	fc 89       	ldd	r31, Y+20	; 0x14
    3292:	90 81       	ld	r25, Z
    3294:	8d 89       	ldd	r24, Y+21	; 0x15
    3296:	89 2b       	or	r24, r25
    3298:	80 83       	st	Z, r24
    329a:	81 e0       	ldi	r24, 0x01	; 1
    329c:	01 c0       	rjmp	.+2      	; 0x32a0 <_ZN14SoftwareSerial6listenEv+0x4c>
    329e:	80 e0       	ldi	r24, 0x00	; 0
    32a0:	df 91       	pop	r29
    32a2:	cf 91       	pop	r28
    32a4:	08 95       	ret

000032a6 <__vector_3>:
    32a6:	1f 92       	push	r1
    32a8:	0f 92       	push	r0
    32aa:	0f b6       	in	r0, 0x3f	; 63
    32ac:	0f 92       	push	r0
    32ae:	11 24       	eor	r1, r1
    32b0:	2f 93       	push	r18
    32b2:	3f 93       	push	r19
    32b4:	4f 93       	push	r20
    32b6:	5f 93       	push	r21
    32b8:	6f 93       	push	r22
    32ba:	7f 93       	push	r23
    32bc:	8f 93       	push	r24
    32be:	9f 93       	push	r25
    32c0:	af 93       	push	r26
    32c2:	bf 93       	push	r27
    32c4:	ef 93       	push	r30
    32c6:	ff 93       	push	r31
    32c8:	e0 91 97 04 	lds	r30, 0x0497	; 0x800497 <_ZN14SoftwareSerial13active_objectE>
    32cc:	f0 91 98 04 	lds	r31, 0x0498	; 0x800498 <_ZN14SoftwareSerial13active_objectE+0x1>
    32d0:	30 97       	sbiw	r30, 0x00	; 0
    32d2:	09 f4       	brne	.+2      	; 0x32d6 <__vector_3+0x30>
    32d4:	51 c0       	rjmp	.+162    	; 0x3378 <__vector_3+0xd2>
    32d6:	96 8d       	ldd	r25, Z+30	; 0x1e
    32d8:	a6 85       	ldd	r26, Z+14	; 0x0e
    32da:	b7 85       	ldd	r27, Z+15	; 0x0f
    32dc:	85 85       	ldd	r24, Z+13	; 0x0d
    32de:	91 ff       	sbrs	r25, 1
    32e0:	04 c0       	rjmp	.+8      	; 0x32ea <__vector_3+0x44>
    32e2:	9c 91       	ld	r25, X
    32e4:	89 23       	and	r24, r25
    32e6:	29 f4       	brne	.+10     	; 0x32f2 <__vector_3+0x4c>
    32e8:	47 c0       	rjmp	.+142    	; 0x3378 <__vector_3+0xd2>
    32ea:	9c 91       	ld	r25, X
    32ec:	89 23       	and	r24, r25
    32ee:	09 f0       	breq	.+2      	; 0x32f2 <__vector_3+0x4c>
    32f0:	43 c0       	rjmp	.+134    	; 0x3378 <__vector_3+0xd2>
    32f2:	a3 89       	ldd	r26, Z+19	; 0x13
    32f4:	b4 89       	ldd	r27, Z+20	; 0x14
    32f6:	9c 91       	ld	r25, X
    32f8:	85 89       	ldd	r24, Z+21	; 0x15
    32fa:	80 95       	com	r24
    32fc:	89 23       	and	r24, r25
    32fe:	8c 93       	st	X, r24
    3300:	86 89       	ldd	r24, Z+22	; 0x16
    3302:	97 89       	ldd	r25, Z+23	; 0x17
    3304:	01 97       	sbiw	r24, 0x01	; 1
    3306:	f1 f7       	brne	.-4      	; 0x3304 <__vector_3+0x5e>
    3308:	60 8d       	ldd	r22, Z+24	; 0x18
    330a:	71 8d       	ldd	r23, Z+25	; 0x19
    330c:	a6 85       	ldd	r26, Z+14	; 0x0e
    330e:	b7 85       	ldd	r27, Z+15	; 0x0f
    3310:	55 85       	ldd	r21, Z+13	; 0x0d
    3312:	38 e0       	ldi	r19, 0x08	; 8
    3314:	20 e0       	ldi	r18, 0x00	; 0
    3316:	cb 01       	movw	r24, r22
    3318:	01 97       	sbiw	r24, 0x01	; 1
    331a:	f1 f7       	brne	.-4      	; 0x3318 <__vector_3+0x72>
    331c:	82 2f       	mov	r24, r18
    331e:	90 e0       	ldi	r25, 0x00	; 0
    3320:	95 95       	asr	r25
    3322:	87 95       	ror	r24
    3324:	28 2f       	mov	r18, r24
    3326:	4c 91       	ld	r20, X
    3328:	45 23       	and	r20, r21
    332a:	09 f0       	breq	.+2      	; 0x332e <__vector_3+0x88>
    332c:	20 68       	ori	r18, 0x80	; 128
    332e:	31 50       	subi	r19, 0x01	; 1
    3330:	91 f7       	brne	.-28     	; 0x3316 <__vector_3+0x70>
    3332:	86 8d       	ldd	r24, Z+30	; 0x1e
    3334:	81 fd       	sbrc	r24, 1
    3336:	20 95       	com	r18
    3338:	80 91 56 04 	lds	r24, 0x0456	; 0x800456 <_ZN14SoftwareSerial20_receive_buffer_tailE>
    333c:	90 e0       	ldi	r25, 0x00	; 0
    333e:	01 96       	adiw	r24, 0x01	; 1
    3340:	8f 73       	andi	r24, 0x3F	; 63
    3342:	99 27       	eor	r25, r25
    3344:	30 91 55 04 	lds	r19, 0x0455	; 0x800455 <_ZN14SoftwareSerial20_receive_buffer_headE>
    3348:	38 17       	cp	r19, r24
    334a:	49 f0       	breq	.+18     	; 0x335e <__vector_3+0xb8>
    334c:	a0 91 56 04 	lds	r26, 0x0456	; 0x800456 <_ZN14SoftwareSerial20_receive_buffer_tailE>
    3350:	b0 e0       	ldi	r27, 0x00	; 0
    3352:	a9 5a       	subi	r26, 0xA9	; 169
    3354:	bb 4f       	sbci	r27, 0xFB	; 251
    3356:	2c 93       	st	X, r18
    3358:	80 93 56 04 	sts	0x0456, r24	; 0x800456 <_ZN14SoftwareSerial20_receive_buffer_tailE>
    335c:	03 c0       	rjmp	.+6      	; 0x3364 <__vector_3+0xbe>
    335e:	86 8d       	ldd	r24, Z+30	; 0x1e
    3360:	81 60       	ori	r24, 0x01	; 1
    3362:	86 8f       	std	Z+30, r24	; 0x1e
    3364:	82 8d       	ldd	r24, Z+26	; 0x1a
    3366:	93 8d       	ldd	r25, Z+27	; 0x1b
    3368:	01 97       	sbiw	r24, 0x01	; 1
    336a:	f1 f7       	brne	.-4      	; 0x3368 <__vector_3+0xc2>
    336c:	a3 89       	ldd	r26, Z+19	; 0x13
    336e:	b4 89       	ldd	r27, Z+20	; 0x14
    3370:	9c 91       	ld	r25, X
    3372:	85 89       	ldd	r24, Z+21	; 0x15
    3374:	89 2b       	or	r24, r25
    3376:	8c 93       	st	X, r24
    3378:	ff 91       	pop	r31
    337a:	ef 91       	pop	r30
    337c:	bf 91       	pop	r27
    337e:	af 91       	pop	r26
    3380:	9f 91       	pop	r25
    3382:	8f 91       	pop	r24
    3384:	7f 91       	pop	r23
    3386:	6f 91       	pop	r22
    3388:	5f 91       	pop	r21
    338a:	4f 91       	pop	r20
    338c:	3f 91       	pop	r19
    338e:	2f 91       	pop	r18
    3390:	0f 90       	pop	r0
    3392:	0f be       	out	0x3f, r0	; 63
    3394:	0f 90       	pop	r0
    3396:	1f 90       	pop	r1
    3398:	18 95       	reti

0000339a <_ZN14SoftwareSerialD1Ev>:
    339a:	25 e6       	ldi	r18, 0x65	; 101
    339c:	32 e0       	ldi	r19, 0x02	; 2
    339e:	fc 01       	movw	r30, r24
    33a0:	31 83       	std	Z+1, r19	; 0x01
    33a2:	20 83       	st	Z, r18
    33a4:	0c 94 14 19 	jmp	0x3228	; 0x3228 <_ZN14SoftwareSerial13stopListeningEv>

000033a8 <_ZN14SoftwareSerial5setTXEh>:
    33a8:	1f 93       	push	r17
    33aa:	cf 93       	push	r28
    33ac:	df 93       	push	r29
    33ae:	ec 01       	movw	r28, r24
    33b0:	16 2f       	mov	r17, r22
    33b2:	6e 8d       	ldd	r22, Y+30	; 0x1e
    33b4:	66 95       	lsr	r22
    33b6:	61 70       	andi	r22, 0x01	; 1
    33b8:	81 e0       	ldi	r24, 0x01	; 1
    33ba:	68 27       	eor	r22, r24
    33bc:	81 2f       	mov	r24, r17
    33be:	0e 94 63 22 	call	0x44c6	; 0x44c6 <digitalWrite>
    33c2:	61 e0       	ldi	r22, 0x01	; 1
    33c4:	81 2f       	mov	r24, r17
    33c6:	0e 94 27 22 	call	0x444e	; 0x444e <pinMode>
    33ca:	81 2f       	mov	r24, r17
    33cc:	90 e0       	ldi	r25, 0x00	; 0
    33ce:	fc 01       	movw	r30, r24
    33d0:	ea 53       	subi	r30, 0x3A	; 58
    33d2:	ff 4f       	sbci	r31, 0xFF	; 255
    33d4:	e4 91       	lpm	r30, Z
    33d6:	e8 8b       	std	Y+16, r30	; 0x10
    33d8:	fc 01       	movw	r30, r24
    33da:	e6 52       	subi	r30, 0x26	; 38
    33dc:	ff 4f       	sbci	r31, 0xFF	; 255
    33de:	e4 91       	lpm	r30, Z
    33e0:	f0 e0       	ldi	r31, 0x00	; 0
    33e2:	ee 0f       	add	r30, r30
    33e4:	ff 1f       	adc	r31, r31
    33e6:	e8 50       	subi	r30, 0x08	; 8
    33e8:	ff 4f       	sbci	r31, 0xFF	; 255
    33ea:	85 91       	lpm	r24, Z+
    33ec:	94 91       	lpm	r25, Z
    33ee:	9a 8b       	std	Y+18, r25	; 0x12
    33f0:	89 8b       	std	Y+17, r24	; 0x11
    33f2:	df 91       	pop	r29
    33f4:	cf 91       	pop	r28
    33f6:	1f 91       	pop	r17
    33f8:	08 95       	ret

000033fa <_ZN14SoftwareSerial5setRXEh>:
    33fa:	1f 93       	push	r17
    33fc:	cf 93       	push	r28
    33fe:	df 93       	push	r29
    3400:	ec 01       	movw	r28, r24
    3402:	16 2f       	mov	r17, r22
    3404:	60 e0       	ldi	r22, 0x00	; 0
    3406:	81 2f       	mov	r24, r17
    3408:	0e 94 27 22 	call	0x444e	; 0x444e <pinMode>
    340c:	8e 8d       	ldd	r24, Y+30	; 0x1e
    340e:	81 fd       	sbrc	r24, 1
    3410:	04 c0       	rjmp	.+8      	; 0x341a <_ZN14SoftwareSerial5setRXEh+0x20>
    3412:	61 e0       	ldi	r22, 0x01	; 1
    3414:	81 2f       	mov	r24, r17
    3416:	0e 94 63 22 	call	0x44c6	; 0x44c6 <digitalWrite>
    341a:	1c 87       	std	Y+12, r17	; 0x0c
    341c:	81 2f       	mov	r24, r17
    341e:	90 e0       	ldi	r25, 0x00	; 0
    3420:	fc 01       	movw	r30, r24
    3422:	ea 53       	subi	r30, 0x3A	; 58
    3424:	ff 4f       	sbci	r31, 0xFF	; 255
    3426:	e4 91       	lpm	r30, Z
    3428:	ed 87       	std	Y+13, r30	; 0x0d
    342a:	fc 01       	movw	r30, r24
    342c:	e6 52       	subi	r30, 0x26	; 38
    342e:	ff 4f       	sbci	r31, 0xFF	; 255
    3430:	e4 91       	lpm	r30, Z
    3432:	f0 e0       	ldi	r31, 0x00	; 0
    3434:	ee 0f       	add	r30, r30
    3436:	ff 1f       	adc	r31, r31
    3438:	e2 51       	subi	r30, 0x12	; 18
    343a:	ff 4f       	sbci	r31, 0xFF	; 255
    343c:	85 91       	lpm	r24, Z+
    343e:	94 91       	lpm	r25, Z
    3440:	9f 87       	std	Y+15, r25	; 0x0f
    3442:	8e 87       	std	Y+14, r24	; 0x0e
    3444:	df 91       	pop	r29
    3446:	cf 91       	pop	r28
    3448:	1f 91       	pop	r17
    344a:	08 95       	ret

0000344c <_ZN14SoftwareSerialC1Ehhb>:
    344c:	1f 93       	push	r17
    344e:	cf 93       	push	r28
    3450:	df 93       	push	r29
    3452:	ec 01       	movw	r28, r24
    3454:	16 2f       	mov	r17, r22
    3456:	1b 82       	std	Y+3, r1	; 0x03
    3458:	1a 82       	std	Y+2, r1	; 0x02
    345a:	88 ee       	ldi	r24, 0xE8	; 232
    345c:	93 e0       	ldi	r25, 0x03	; 3
    345e:	a0 e0       	ldi	r26, 0x00	; 0
    3460:	b0 e0       	ldi	r27, 0x00	; 0
    3462:	8c 83       	std	Y+4, r24	; 0x04
    3464:	9d 83       	std	Y+5, r25	; 0x05
    3466:	ae 83       	std	Y+6, r26	; 0x06
    3468:	bf 83       	std	Y+7, r27	; 0x07
    346a:	85 e6       	ldi	r24, 0x65	; 101
    346c:	92 e0       	ldi	r25, 0x02	; 2
    346e:	99 83       	std	Y+1, r25	; 0x01
    3470:	88 83       	st	Y, r24
    3472:	1f 8a       	std	Y+23, r1	; 0x17
    3474:	1e 8a       	std	Y+22, r1	; 0x16
    3476:	19 8e       	std	Y+25, r1	; 0x19
    3478:	18 8e       	std	Y+24, r1	; 0x18
    347a:	1b 8e       	std	Y+27, r1	; 0x1b
    347c:	1a 8e       	std	Y+26, r1	; 0x1a
    347e:	1d 8e       	std	Y+29, r1	; 0x1d
    3480:	1c 8e       	std	Y+28, r1	; 0x1c
    3482:	8e 8d       	ldd	r24, Y+30	; 0x1e
    3484:	8e 7f       	andi	r24, 0xFE	; 254
    3486:	20 fb       	bst	r18, 0
    3488:	81 f9       	bld	r24, 1
    348a:	8e 8f       	std	Y+30, r24	; 0x1e
    348c:	64 2f       	mov	r22, r20
    348e:	ce 01       	movw	r24, r28
    3490:	0e 94 d4 19 	call	0x33a8	; 0x33a8 <_ZN14SoftwareSerial5setTXEh>
    3494:	61 2f       	mov	r22, r17
    3496:	ce 01       	movw	r24, r28
    3498:	df 91       	pop	r29
    349a:	cf 91       	pop	r28
    349c:	1f 91       	pop	r17
    349e:	0c 94 fd 19 	jmp	0x33fa	; 0x33fa <_ZN14SoftwareSerial5setRXEh>

000034a2 <_ZN14SoftwareSerial5beginEl>:
//
// Public methods
//

void SoftwareSerial::begin(long speed)
{
    34a2:	cf 93       	push	r28
    34a4:	df 93       	push	r29
    34a6:	ec 01       	movw	r28, r24
    34a8:	9a 01       	movw	r18, r20
    34aa:	ab 01       	movw	r20, r22
  _rx_delay_centering = _rx_delay_intrabit = _rx_delay_stopbit = _tx_delay = 0;
    34ac:	1b 8e       	std	Y+27, r1	; 0x1b
    34ae:	1a 8e       	std	Y+26, r1	; 0x1a
    34b0:	19 8e       	std	Y+25, r1	; 0x19
    34b2:	18 8e       	std	Y+24, r1	; 0x18
    34b4:	1f 8a       	std	Y+23, r1	; 0x17
    34b6:	1e 8a       	std	Y+22, r1	; 0x16

  // Precalculate the various delays, in number of 4-cycle delays
  uint16_t bit_delay = (F_CPU / speed) / 4;
    34b8:	60 e0       	ldi	r22, 0x00	; 0
    34ba:	79 e0       	ldi	r23, 0x09	; 9
    34bc:	8d e3       	ldi	r24, 0x3D	; 61
    34be:	90 e0       	ldi	r25, 0x00	; 0
    34c0:	0e 94 df 23 	call	0x47be	; 0x47be <__divmodsi4>
    34c4:	f9 01       	movw	r30, r18
  uint8_t port = digitalPinToPort(rx);
  _receivePortRegister = portInputRegister(port);
}

uint16_t SoftwareSerial::subtract_cap(uint16_t num, uint16_t sub) {
  if (num > sub)
    34c6:	24 30       	cpi	r18, 0x04	; 4
    34c8:	31 05       	cpc	r19, r1
    34ca:	18 f0       	brcs	.+6      	; 0x34d2 <_ZN14SoftwareSerial5beginEl+0x30>
    return num - sub;
    34cc:	c9 01       	movw	r24, r18
    34ce:	03 97       	sbiw	r24, 0x03	; 3
    34d0:	02 c0       	rjmp	.+4      	; 0x34d6 <_ZN14SoftwareSerial5beginEl+0x34>
  else
    return 1;
    34d2:	81 e0       	ldi	r24, 0x01	; 1
    34d4:	90 e0       	ldi	r25, 0x00	; 0
  // 12 (gcc 4.8.2) or 13 (gcc 4.3.2) cycles from start bit to first bit,
  // 15 (gcc 4.8.2) or 16 (gcc 4.3.2) cycles between bits,
  // 12 (gcc 4.8.2) or 14 (gcc 4.3.2) cycles from last bit to stop bit
  // These are all close enough to just use 15 cycles, since the inter-bit
  // timings are the most critical (deviations stack 8 times)
  _tx_delay = subtract_cap(bit_delay, 15 / 4);
    34d6:	9d 8f       	std	Y+29, r25	; 0x1d
    34d8:	8c 8f       	std	Y+28, r24	; 0x1c

  // Only setup rx when we have a valid PCINT for this pin
  if (digitalPinToPCICR(_receivePin)) {
    34da:	6c 85       	ldd	r22, Y+12	; 0x0c
    34dc:	66 31       	cpi	r22, 0x16	; 22
    34de:	08 f0       	brcs	.+2      	; 0x34e2 <_ZN14SoftwareSerial5beginEl+0x40>
    34e0:	69 c0       	rjmp	.+210    	; 0x35b4 <_ZN14SoftwareSerial5beginEl+0x112>
    // are 17 more cycles until the pin value is read (excluding the
    // delay in the loop).
    // We want to have a total delay of 1.5 bit time. Inside the loop,
    // we already wait for 1 bit time - 23 cycles, so here we wait for
    // 0.5 bit time - (71 + 18 - 22) cycles.
    _rx_delay_centering = subtract_cap(bit_delay / 2, (4 + 4 + 75 + 17 - 23) / 4);
    34e2:	c9 01       	movw	r24, r18
    34e4:	96 95       	lsr	r25
    34e6:	87 95       	ror	r24
  uint8_t port = digitalPinToPort(rx);
  _receivePortRegister = portInputRegister(port);
}

uint16_t SoftwareSerial::subtract_cap(uint16_t num, uint16_t sub) {
  if (num > sub)
    34e8:	84 31       	cpi	r24, 0x14	; 20
    34ea:	91 05       	cpc	r25, r1
    34ec:	10 f0       	brcs	.+4      	; 0x34f2 <_ZN14SoftwareSerial5beginEl+0x50>
    return num - sub;
    34ee:	43 97       	sbiw	r24, 0x13	; 19
    34f0:	02 c0       	rjmp	.+4      	; 0x34f6 <_ZN14SoftwareSerial5beginEl+0x54>
  else
    return 1;
    34f2:	81 e0       	ldi	r24, 0x01	; 1
    34f4:	90 e0       	ldi	r25, 0x00	; 0
    // are 17 more cycles until the pin value is read (excluding the
    // delay in the loop).
    // We want to have a total delay of 1.5 bit time. Inside the loop,
    // we already wait for 1 bit time - 23 cycles, so here we wait for
    // 0.5 bit time - (71 + 18 - 22) cycles.
    _rx_delay_centering = subtract_cap(bit_delay / 2, (4 + 4 + 75 + 17 - 23) / 4);
    34f6:	9f 8b       	std	Y+23, r25	; 0x17
    34f8:	8e 8b       	std	Y+22, r24	; 0x16
  uint8_t port = digitalPinToPort(rx);
  _receivePortRegister = portInputRegister(port);
}

uint16_t SoftwareSerial::subtract_cap(uint16_t num, uint16_t sub) {
  if (num > sub)
    34fa:	36 97       	sbiw	r30, 0x06	; 6
    34fc:	18 f0       	brcs	.+6      	; 0x3504 <_ZN14SoftwareSerial5beginEl+0x62>
    return num - sub;
    34fe:	c9 01       	movw	r24, r18
    3500:	05 97       	sbiw	r24, 0x05	; 5
    3502:	02 c0       	rjmp	.+4      	; 0x3508 <_ZN14SoftwareSerial5beginEl+0x66>
  else
    return 1;
    3504:	81 e0       	ldi	r24, 0x01	; 1
    3506:	90 e0       	ldi	r25, 0x00	; 0
    // we already wait for 1 bit time - 23 cycles, so here we wait for
    // 0.5 bit time - (71 + 18 - 22) cycles.
    _rx_delay_centering = subtract_cap(bit_delay / 2, (4 + 4 + 75 + 17 - 23) / 4);

    // There are 23 cycles in each loop iteration (excluding the delay)
    _rx_delay_intrabit = subtract_cap(bit_delay, 23 / 4);
    3508:	99 8f       	std	Y+25, r25	; 0x19
    350a:	88 8f       	std	Y+24, r24	; 0x18
    // mask is enabled again (which _must_ happen during the stopbit).
    // This delay aims at 3/4 of a bit time, meaning the end of the
    // delay will be at 1/4th of the stopbit. This allows some extra
    // time for ISR cleanup, which makes 115200 baud at 16Mhz work more
    // reliably
    _rx_delay_stopbit = subtract_cap(bit_delay * 3 / 4, (37 + 11) / 4);
    350c:	c9 01       	movw	r24, r18
    350e:	88 0f       	add	r24, r24
    3510:	99 1f       	adc	r25, r25
    3512:	28 0f       	add	r18, r24
    3514:	39 1f       	adc	r19, r25
    3516:	36 95       	lsr	r19
    3518:	27 95       	ror	r18
    351a:	36 95       	lsr	r19
    351c:	27 95       	ror	r18
  uint8_t port = digitalPinToPort(rx);
  _receivePortRegister = portInputRegister(port);
}

uint16_t SoftwareSerial::subtract_cap(uint16_t num, uint16_t sub) {
  if (num > sub)
    351e:	2d 30       	cpi	r18, 0x0D	; 13
    3520:	31 05       	cpc	r19, r1
    3522:	18 f0       	brcs	.+6      	; 0x352a <_ZN14SoftwareSerial5beginEl+0x88>
    return num - sub;
    3524:	2c 50       	subi	r18, 0x0C	; 12
    3526:	31 09       	sbc	r19, r1
    3528:	02 c0       	rjmp	.+4      	; 0x352e <_ZN14SoftwareSerial5beginEl+0x8c>
  else
    return 1;
    352a:	21 e0       	ldi	r18, 0x01	; 1
    352c:	30 e0       	ldi	r19, 0x00	; 0
    // mask is enabled again (which _must_ happen during the stopbit).
    // This delay aims at 3/4 of a bit time, meaning the end of the
    // delay will be at 1/4th of the stopbit. This allows some extra
    // time for ISR cleanup, which makes 115200 baud at 16Mhz work more
    // reliably
    _rx_delay_stopbit = subtract_cap(bit_delay * 3 / 4, (37 + 11) / 4);
    352e:	3b 8f       	std	Y+27, r19	; 0x1b
    3530:	2a 8f       	std	Y+26, r18	; 0x1a


    // Enable the PCINT for the entire port here, but never disable it
    // (others might also need it, so we disable the interrupt by using
    // the per-pin PCMSK register).
    *digitalPinToPCICR(_receivePin) |= _BV(digitalPinToPCICRbit(_receivePin));
    3532:	90 91 68 00 	lds	r25, 0x0068	; 0x800068 <__DATA_REGION_ORIGIN__+0x8>
    3536:	68 30       	cpi	r22, 0x08	; 8
    3538:	50 f0       	brcs	.+20     	; 0x354e <_ZN14SoftwareSerial5beginEl+0xac>
    353a:	21 e0       	ldi	r18, 0x01	; 1
    353c:	6e 30       	cpi	r22, 0x0E	; 14
    353e:	08 f4       	brcc	.+2      	; 0x3542 <_ZN14SoftwareSerial5beginEl+0xa0>
    3540:	20 e0       	ldi	r18, 0x00	; 0
    3542:	81 e0       	ldi	r24, 0x01	; 1
    3544:	01 c0       	rjmp	.+2      	; 0x3548 <_ZN14SoftwareSerial5beginEl+0xa6>
    3546:	88 0f       	add	r24, r24
    3548:	2a 95       	dec	r18
    354a:	ea f7       	brpl	.-6      	; 0x3546 <_ZN14SoftwareSerial5beginEl+0xa4>
    354c:	01 c0       	rjmp	.+2      	; 0x3550 <_ZN14SoftwareSerial5beginEl+0xae>
    354e:	84 e0       	ldi	r24, 0x04	; 4
    3550:	89 2b       	or	r24, r25
    3552:	80 93 68 00 	sts	0x0068, r24	; 0x800068 <__DATA_REGION_ORIGIN__+0x8>
    // Precalculate the pcint mask register and value, so setRxIntMask
    // can be used inside the ISR without costing too much time.
    _pcint_maskreg = digitalPinToPCMSK(_receivePin);
    3556:	9c 85       	ldd	r25, Y+12	; 0x0c
    3558:	98 30       	cpi	r25, 0x08	; 8
    355a:	38 f0       	brcs	.+14     	; 0x356a <_ZN14SoftwareSerial5beginEl+0xc8>
    355c:	9e 30       	cpi	r25, 0x0E	; 14
    355e:	40 f0       	brcs	.+16     	; 0x3570 <_ZN14SoftwareSerial5beginEl+0xce>
    3560:	96 31       	cpi	r25, 0x16	; 22
    3562:	48 f0       	brcs	.+18     	; 0x3576 <_ZN14SoftwareSerial5beginEl+0xd4>
    3564:	20 e0       	ldi	r18, 0x00	; 0
    3566:	30 e0       	ldi	r19, 0x00	; 0
    3568:	08 c0       	rjmp	.+16     	; 0x357a <_ZN14SoftwareSerial5beginEl+0xd8>
    356a:	2d e6       	ldi	r18, 0x6D	; 109
    356c:	30 e0       	ldi	r19, 0x00	; 0
    356e:	05 c0       	rjmp	.+10     	; 0x357a <_ZN14SoftwareSerial5beginEl+0xd8>
    3570:	2b e6       	ldi	r18, 0x6B	; 107
    3572:	30 e0       	ldi	r19, 0x00	; 0
    3574:	02 c0       	rjmp	.+4      	; 0x357a <_ZN14SoftwareSerial5beginEl+0xd8>
    3576:	2c e6       	ldi	r18, 0x6C	; 108
    3578:	30 e0       	ldi	r19, 0x00	; 0
    357a:	3c 8b       	std	Y+20, r19	; 0x14
    357c:	2b 8b       	std	Y+19, r18	; 0x13
    _pcint_maskvalue = _BV(digitalPinToPCMSKbit(_receivePin));
    357e:	98 30       	cpi	r25, 0x08	; 8
    3580:	30 f4       	brcc	.+12     	; 0x358e <_ZN14SoftwareSerial5beginEl+0xec>
    3582:	81 e0       	ldi	r24, 0x01	; 1
    3584:	01 c0       	rjmp	.+2      	; 0x3588 <_ZN14SoftwareSerial5beginEl+0xe6>
    3586:	88 0f       	add	r24, r24
    3588:	9a 95       	dec	r25
    358a:	ea f7       	brpl	.-6      	; 0x3586 <_ZN14SoftwareSerial5beginEl+0xe4>
    358c:	0e c0       	rjmp	.+28     	; 0x35aa <_ZN14SoftwareSerial5beginEl+0x108>
    358e:	29 2f       	mov	r18, r25
    3590:	30 e0       	ldi	r19, 0x00	; 0
    3592:	9e 30       	cpi	r25, 0x0E	; 14
    3594:	18 f4       	brcc	.+6      	; 0x359c <_ZN14SoftwareSerial5beginEl+0xfa>
    3596:	28 50       	subi	r18, 0x08	; 8
    3598:	31 09       	sbc	r19, r1
    359a:	02 c0       	rjmp	.+4      	; 0x35a0 <_ZN14SoftwareSerial5beginEl+0xfe>
    359c:	2e 50       	subi	r18, 0x0E	; 14
    359e:	31 09       	sbc	r19, r1
    35a0:	81 e0       	ldi	r24, 0x01	; 1
    35a2:	01 c0       	rjmp	.+2      	; 0x35a6 <_ZN14SoftwareSerial5beginEl+0x104>
    35a4:	88 0f       	add	r24, r24
    35a6:	2a 95       	dec	r18
    35a8:	ea f7       	brpl	.-6      	; 0x35a4 <_ZN14SoftwareSerial5beginEl+0x102>
    35aa:	8d 8b       	std	Y+21, r24	; 0x15
	__asm__ volatile (
		"1: sbiw %0,1" "\n\t"
		"brne 1b"
		: "=w" (__count)
		: "0" (__count)
	);
    35ac:	8c 8d       	ldd	r24, Y+28	; 0x1c
    35ae:	9d 8d       	ldd	r25, Y+29	; 0x1d
    35b0:	01 97       	sbiw	r24, 0x01	; 1
    35b2:	f1 f7       	brne	.-4      	; 0x35b0 <_ZN14SoftwareSerial5beginEl+0x10e>
#if _DEBUG
  pinMode(_DEBUG_PIN1, OUTPUT);
  pinMode(_DEBUG_PIN2, OUTPUT);
#endif

  listen();
    35b4:	ce 01       	movw	r24, r28
}
    35b6:	df 91       	pop	r29
    35b8:	cf 91       	pop	r28
#if _DEBUG
  pinMode(_DEBUG_PIN1, OUTPUT);
  pinMode(_DEBUG_PIN2, OUTPUT);
#endif

  listen();
    35ba:	0c 94 2a 19 	jmp	0x3254	; 0x3254 <_ZN14SoftwareSerial6listenEv>

000035be <__subsf3>:
    35be:	50 58       	subi	r21, 0x80	; 128

000035c0 <__addsf3>:
    35c0:	bb 27       	eor	r27, r27
    35c2:	aa 27       	eor	r26, r26
    35c4:	0e 94 f7 1a 	call	0x35ee	; 0x35ee <__addsf3x>
    35c8:	0c 94 71 1c 	jmp	0x38e2	; 0x38e2 <__fp_round>
    35cc:	0e 94 63 1c 	call	0x38c6	; 0x38c6 <__fp_pscA>
    35d0:	38 f0       	brcs	.+14     	; 0x35e0 <__addsf3+0x20>
    35d2:	0e 94 6a 1c 	call	0x38d4	; 0x38d4 <__fp_pscB>
    35d6:	20 f0       	brcs	.+8      	; 0x35e0 <__addsf3+0x20>
    35d8:	39 f4       	brne	.+14     	; 0x35e8 <__addsf3+0x28>
    35da:	9f 3f       	cpi	r25, 0xFF	; 255
    35dc:	19 f4       	brne	.+6      	; 0x35e4 <__addsf3+0x24>
    35de:	26 f4       	brtc	.+8      	; 0x35e8 <__addsf3+0x28>
    35e0:	0c 94 60 1c 	jmp	0x38c0	; 0x38c0 <__fp_nan>
    35e4:	0e f4       	brtc	.+2      	; 0x35e8 <__addsf3+0x28>
    35e6:	e0 95       	com	r30
    35e8:	e7 fb       	bst	r30, 7
    35ea:	0c 94 5a 1c 	jmp	0x38b4	; 0x38b4 <__fp_inf>

000035ee <__addsf3x>:
    35ee:	e9 2f       	mov	r30, r25
    35f0:	0e 94 82 1c 	call	0x3904	; 0x3904 <__fp_split3>
    35f4:	58 f3       	brcs	.-42     	; 0x35cc <__addsf3+0xc>
    35f6:	ba 17       	cp	r27, r26
    35f8:	62 07       	cpc	r22, r18
    35fa:	73 07       	cpc	r23, r19
    35fc:	84 07       	cpc	r24, r20
    35fe:	95 07       	cpc	r25, r21
    3600:	20 f0       	brcs	.+8      	; 0x360a <__addsf3x+0x1c>
    3602:	79 f4       	brne	.+30     	; 0x3622 <__addsf3x+0x34>
    3604:	a6 f5       	brtc	.+104    	; 0x366e <__addsf3x+0x80>
    3606:	0c 94 a4 1c 	jmp	0x3948	; 0x3948 <__fp_zero>
    360a:	0e f4       	brtc	.+2      	; 0x360e <__addsf3x+0x20>
    360c:	e0 95       	com	r30
    360e:	0b 2e       	mov	r0, r27
    3610:	ba 2f       	mov	r27, r26
    3612:	a0 2d       	mov	r26, r0
    3614:	0b 01       	movw	r0, r22
    3616:	b9 01       	movw	r22, r18
    3618:	90 01       	movw	r18, r0
    361a:	0c 01       	movw	r0, r24
    361c:	ca 01       	movw	r24, r20
    361e:	a0 01       	movw	r20, r0
    3620:	11 24       	eor	r1, r1
    3622:	ff 27       	eor	r31, r31
    3624:	59 1b       	sub	r21, r25
    3626:	99 f0       	breq	.+38     	; 0x364e <__addsf3x+0x60>
    3628:	59 3f       	cpi	r21, 0xF9	; 249
    362a:	50 f4       	brcc	.+20     	; 0x3640 <__addsf3x+0x52>
    362c:	50 3e       	cpi	r21, 0xE0	; 224
    362e:	68 f1       	brcs	.+90     	; 0x368a <__addsf3x+0x9c>
    3630:	1a 16       	cp	r1, r26
    3632:	f0 40       	sbci	r31, 0x00	; 0
    3634:	a2 2f       	mov	r26, r18
    3636:	23 2f       	mov	r18, r19
    3638:	34 2f       	mov	r19, r20
    363a:	44 27       	eor	r20, r20
    363c:	58 5f       	subi	r21, 0xF8	; 248
    363e:	f3 cf       	rjmp	.-26     	; 0x3626 <__addsf3x+0x38>
    3640:	46 95       	lsr	r20
    3642:	37 95       	ror	r19
    3644:	27 95       	ror	r18
    3646:	a7 95       	ror	r26
    3648:	f0 40       	sbci	r31, 0x00	; 0
    364a:	53 95       	inc	r21
    364c:	c9 f7       	brne	.-14     	; 0x3640 <__addsf3x+0x52>
    364e:	7e f4       	brtc	.+30     	; 0x366e <__addsf3x+0x80>
    3650:	1f 16       	cp	r1, r31
    3652:	ba 0b       	sbc	r27, r26
    3654:	62 0b       	sbc	r22, r18
    3656:	73 0b       	sbc	r23, r19
    3658:	84 0b       	sbc	r24, r20
    365a:	ba f0       	brmi	.+46     	; 0x368a <__addsf3x+0x9c>
    365c:	91 50       	subi	r25, 0x01	; 1
    365e:	a1 f0       	breq	.+40     	; 0x3688 <__addsf3x+0x9a>
    3660:	ff 0f       	add	r31, r31
    3662:	bb 1f       	adc	r27, r27
    3664:	66 1f       	adc	r22, r22
    3666:	77 1f       	adc	r23, r23
    3668:	88 1f       	adc	r24, r24
    366a:	c2 f7       	brpl	.-16     	; 0x365c <__addsf3x+0x6e>
    366c:	0e c0       	rjmp	.+28     	; 0x368a <__addsf3x+0x9c>
    366e:	ba 0f       	add	r27, r26
    3670:	62 1f       	adc	r22, r18
    3672:	73 1f       	adc	r23, r19
    3674:	84 1f       	adc	r24, r20
    3676:	48 f4       	brcc	.+18     	; 0x368a <__addsf3x+0x9c>
    3678:	87 95       	ror	r24
    367a:	77 95       	ror	r23
    367c:	67 95       	ror	r22
    367e:	b7 95       	ror	r27
    3680:	f7 95       	ror	r31
    3682:	9e 3f       	cpi	r25, 0xFE	; 254
    3684:	08 f0       	brcs	.+2      	; 0x3688 <__addsf3x+0x9a>
    3686:	b0 cf       	rjmp	.-160    	; 0x35e8 <__addsf3+0x28>
    3688:	93 95       	inc	r25
    368a:	88 0f       	add	r24, r24
    368c:	08 f0       	brcs	.+2      	; 0x3690 <__addsf3x+0xa2>
    368e:	99 27       	eor	r25, r25
    3690:	ee 0f       	add	r30, r30
    3692:	97 95       	ror	r25
    3694:	87 95       	ror	r24
    3696:	08 95       	ret

00003698 <__cmpsf2>:
    3698:	0e 94 36 1c 	call	0x386c	; 0x386c <__fp_cmp>
    369c:	08 f4       	brcc	.+2      	; 0x36a0 <__cmpsf2+0x8>
    369e:	81 e0       	ldi	r24, 0x01	; 1
    36a0:	08 95       	ret

000036a2 <__divsf3>:
    36a2:	0e 94 65 1b 	call	0x36ca	; 0x36ca <__divsf3x>
    36a6:	0c 94 71 1c 	jmp	0x38e2	; 0x38e2 <__fp_round>
    36aa:	0e 94 6a 1c 	call	0x38d4	; 0x38d4 <__fp_pscB>
    36ae:	58 f0       	brcs	.+22     	; 0x36c6 <__divsf3+0x24>
    36b0:	0e 94 63 1c 	call	0x38c6	; 0x38c6 <__fp_pscA>
    36b4:	40 f0       	brcs	.+16     	; 0x36c6 <__divsf3+0x24>
    36b6:	29 f4       	brne	.+10     	; 0x36c2 <__divsf3+0x20>
    36b8:	5f 3f       	cpi	r21, 0xFF	; 255
    36ba:	29 f0       	breq	.+10     	; 0x36c6 <__divsf3+0x24>
    36bc:	0c 94 5a 1c 	jmp	0x38b4	; 0x38b4 <__fp_inf>
    36c0:	51 11       	cpse	r21, r1
    36c2:	0c 94 a5 1c 	jmp	0x394a	; 0x394a <__fp_szero>
    36c6:	0c 94 60 1c 	jmp	0x38c0	; 0x38c0 <__fp_nan>

000036ca <__divsf3x>:
    36ca:	0e 94 82 1c 	call	0x3904	; 0x3904 <__fp_split3>
    36ce:	68 f3       	brcs	.-38     	; 0x36aa <__divsf3+0x8>

000036d0 <__divsf3_pse>:
    36d0:	99 23       	and	r25, r25
    36d2:	b1 f3       	breq	.-20     	; 0x36c0 <__divsf3+0x1e>
    36d4:	55 23       	and	r21, r21
    36d6:	91 f3       	breq	.-28     	; 0x36bc <__divsf3+0x1a>
    36d8:	95 1b       	sub	r25, r21
    36da:	55 0b       	sbc	r21, r21
    36dc:	bb 27       	eor	r27, r27
    36de:	aa 27       	eor	r26, r26
    36e0:	62 17       	cp	r22, r18
    36e2:	73 07       	cpc	r23, r19
    36e4:	84 07       	cpc	r24, r20
    36e6:	38 f0       	brcs	.+14     	; 0x36f6 <__divsf3_pse+0x26>
    36e8:	9f 5f       	subi	r25, 0xFF	; 255
    36ea:	5f 4f       	sbci	r21, 0xFF	; 255
    36ec:	22 0f       	add	r18, r18
    36ee:	33 1f       	adc	r19, r19
    36f0:	44 1f       	adc	r20, r20
    36f2:	aa 1f       	adc	r26, r26
    36f4:	a9 f3       	breq	.-22     	; 0x36e0 <__divsf3_pse+0x10>
    36f6:	35 d0       	rcall	.+106    	; 0x3762 <__divsf3_pse+0x92>
    36f8:	0e 2e       	mov	r0, r30
    36fa:	3a f0       	brmi	.+14     	; 0x370a <__divsf3_pse+0x3a>
    36fc:	e0 e8       	ldi	r30, 0x80	; 128
    36fe:	32 d0       	rcall	.+100    	; 0x3764 <__divsf3_pse+0x94>
    3700:	91 50       	subi	r25, 0x01	; 1
    3702:	50 40       	sbci	r21, 0x00	; 0
    3704:	e6 95       	lsr	r30
    3706:	00 1c       	adc	r0, r0
    3708:	ca f7       	brpl	.-14     	; 0x36fc <__divsf3_pse+0x2c>
    370a:	2b d0       	rcall	.+86     	; 0x3762 <__divsf3_pse+0x92>
    370c:	fe 2f       	mov	r31, r30
    370e:	29 d0       	rcall	.+82     	; 0x3762 <__divsf3_pse+0x92>
    3710:	66 0f       	add	r22, r22
    3712:	77 1f       	adc	r23, r23
    3714:	88 1f       	adc	r24, r24
    3716:	bb 1f       	adc	r27, r27
    3718:	26 17       	cp	r18, r22
    371a:	37 07       	cpc	r19, r23
    371c:	48 07       	cpc	r20, r24
    371e:	ab 07       	cpc	r26, r27
    3720:	b0 e8       	ldi	r27, 0x80	; 128
    3722:	09 f0       	breq	.+2      	; 0x3726 <__divsf3_pse+0x56>
    3724:	bb 0b       	sbc	r27, r27
    3726:	80 2d       	mov	r24, r0
    3728:	bf 01       	movw	r22, r30
    372a:	ff 27       	eor	r31, r31
    372c:	93 58       	subi	r25, 0x83	; 131
    372e:	5f 4f       	sbci	r21, 0xFF	; 255
    3730:	3a f0       	brmi	.+14     	; 0x3740 <__divsf3_pse+0x70>
    3732:	9e 3f       	cpi	r25, 0xFE	; 254
    3734:	51 05       	cpc	r21, r1
    3736:	78 f0       	brcs	.+30     	; 0x3756 <__divsf3_pse+0x86>
    3738:	0c 94 5a 1c 	jmp	0x38b4	; 0x38b4 <__fp_inf>
    373c:	0c 94 a5 1c 	jmp	0x394a	; 0x394a <__fp_szero>
    3740:	5f 3f       	cpi	r21, 0xFF	; 255
    3742:	e4 f3       	brlt	.-8      	; 0x373c <__divsf3_pse+0x6c>
    3744:	98 3e       	cpi	r25, 0xE8	; 232
    3746:	d4 f3       	brlt	.-12     	; 0x373c <__divsf3_pse+0x6c>
    3748:	86 95       	lsr	r24
    374a:	77 95       	ror	r23
    374c:	67 95       	ror	r22
    374e:	b7 95       	ror	r27
    3750:	f7 95       	ror	r31
    3752:	9f 5f       	subi	r25, 0xFF	; 255
    3754:	c9 f7       	brne	.-14     	; 0x3748 <__divsf3_pse+0x78>
    3756:	88 0f       	add	r24, r24
    3758:	91 1d       	adc	r25, r1
    375a:	96 95       	lsr	r25
    375c:	87 95       	ror	r24
    375e:	97 f9       	bld	r25, 7
    3760:	08 95       	ret
    3762:	e1 e0       	ldi	r30, 0x01	; 1
    3764:	66 0f       	add	r22, r22
    3766:	77 1f       	adc	r23, r23
    3768:	88 1f       	adc	r24, r24
    376a:	bb 1f       	adc	r27, r27
    376c:	62 17       	cp	r22, r18
    376e:	73 07       	cpc	r23, r19
    3770:	84 07       	cpc	r24, r20
    3772:	ba 07       	cpc	r27, r26
    3774:	20 f0       	brcs	.+8      	; 0x377e <__divsf3_pse+0xae>
    3776:	62 1b       	sub	r22, r18
    3778:	73 0b       	sbc	r23, r19
    377a:	84 0b       	sbc	r24, r20
    377c:	ba 0b       	sbc	r27, r26
    377e:	ee 1f       	adc	r30, r30
    3780:	88 f7       	brcc	.-30     	; 0x3764 <__divsf3_pse+0x94>
    3782:	e0 95       	com	r30
    3784:	08 95       	ret

00003786 <__fixsfsi>:
    3786:	0e 94 ca 1b 	call	0x3794	; 0x3794 <__fixunssfsi>
    378a:	68 94       	set
    378c:	b1 11       	cpse	r27, r1
    378e:	0c 94 a5 1c 	jmp	0x394a	; 0x394a <__fp_szero>
    3792:	08 95       	ret

00003794 <__fixunssfsi>:
    3794:	0e 94 8a 1c 	call	0x3914	; 0x3914 <__fp_splitA>
    3798:	88 f0       	brcs	.+34     	; 0x37bc <__fixunssfsi+0x28>
    379a:	9f 57       	subi	r25, 0x7F	; 127
    379c:	98 f0       	brcs	.+38     	; 0x37c4 <__fixunssfsi+0x30>
    379e:	b9 2f       	mov	r27, r25
    37a0:	99 27       	eor	r25, r25
    37a2:	b7 51       	subi	r27, 0x17	; 23
    37a4:	b0 f0       	brcs	.+44     	; 0x37d2 <__fixunssfsi+0x3e>
    37a6:	e1 f0       	breq	.+56     	; 0x37e0 <__fixunssfsi+0x4c>
    37a8:	66 0f       	add	r22, r22
    37aa:	77 1f       	adc	r23, r23
    37ac:	88 1f       	adc	r24, r24
    37ae:	99 1f       	adc	r25, r25
    37b0:	1a f0       	brmi	.+6      	; 0x37b8 <__fixunssfsi+0x24>
    37b2:	ba 95       	dec	r27
    37b4:	c9 f7       	brne	.-14     	; 0x37a8 <__fixunssfsi+0x14>
    37b6:	14 c0       	rjmp	.+40     	; 0x37e0 <__fixunssfsi+0x4c>
    37b8:	b1 30       	cpi	r27, 0x01	; 1
    37ba:	91 f0       	breq	.+36     	; 0x37e0 <__fixunssfsi+0x4c>
    37bc:	0e 94 a4 1c 	call	0x3948	; 0x3948 <__fp_zero>
    37c0:	b1 e0       	ldi	r27, 0x01	; 1
    37c2:	08 95       	ret
    37c4:	0c 94 a4 1c 	jmp	0x3948	; 0x3948 <__fp_zero>
    37c8:	67 2f       	mov	r22, r23
    37ca:	78 2f       	mov	r23, r24
    37cc:	88 27       	eor	r24, r24
    37ce:	b8 5f       	subi	r27, 0xF8	; 248
    37d0:	39 f0       	breq	.+14     	; 0x37e0 <__fixunssfsi+0x4c>
    37d2:	b9 3f       	cpi	r27, 0xF9	; 249
    37d4:	cc f3       	brlt	.-14     	; 0x37c8 <__fixunssfsi+0x34>
    37d6:	86 95       	lsr	r24
    37d8:	77 95       	ror	r23
    37da:	67 95       	ror	r22
    37dc:	b3 95       	inc	r27
    37de:	d9 f7       	brne	.-10     	; 0x37d6 <__fixunssfsi+0x42>
    37e0:	3e f4       	brtc	.+14     	; 0x37f0 <__fixunssfsi+0x5c>
    37e2:	90 95       	com	r25
    37e4:	80 95       	com	r24
    37e6:	70 95       	com	r23
    37e8:	61 95       	neg	r22
    37ea:	7f 4f       	sbci	r23, 0xFF	; 255
    37ec:	8f 4f       	sbci	r24, 0xFF	; 255
    37ee:	9f 4f       	sbci	r25, 0xFF	; 255
    37f0:	08 95       	ret

000037f2 <__floatunsisf>:
    37f2:	e8 94       	clt
    37f4:	09 c0       	rjmp	.+18     	; 0x3808 <__floatsisf+0x12>

000037f6 <__floatsisf>:
    37f6:	97 fb       	bst	r25, 7
    37f8:	3e f4       	brtc	.+14     	; 0x3808 <__floatsisf+0x12>
    37fa:	90 95       	com	r25
    37fc:	80 95       	com	r24
    37fe:	70 95       	com	r23
    3800:	61 95       	neg	r22
    3802:	7f 4f       	sbci	r23, 0xFF	; 255
    3804:	8f 4f       	sbci	r24, 0xFF	; 255
    3806:	9f 4f       	sbci	r25, 0xFF	; 255
    3808:	99 23       	and	r25, r25
    380a:	a9 f0       	breq	.+42     	; 0x3836 <__floatsisf+0x40>
    380c:	f9 2f       	mov	r31, r25
    380e:	96 e9       	ldi	r25, 0x96	; 150
    3810:	bb 27       	eor	r27, r27
    3812:	93 95       	inc	r25
    3814:	f6 95       	lsr	r31
    3816:	87 95       	ror	r24
    3818:	77 95       	ror	r23
    381a:	67 95       	ror	r22
    381c:	b7 95       	ror	r27
    381e:	f1 11       	cpse	r31, r1
    3820:	f8 cf       	rjmp	.-16     	; 0x3812 <__floatsisf+0x1c>
    3822:	fa f4       	brpl	.+62     	; 0x3862 <__floatsisf+0x6c>
    3824:	bb 0f       	add	r27, r27
    3826:	11 f4       	brne	.+4      	; 0x382c <__floatsisf+0x36>
    3828:	60 ff       	sbrs	r22, 0
    382a:	1b c0       	rjmp	.+54     	; 0x3862 <__floatsisf+0x6c>
    382c:	6f 5f       	subi	r22, 0xFF	; 255
    382e:	7f 4f       	sbci	r23, 0xFF	; 255
    3830:	8f 4f       	sbci	r24, 0xFF	; 255
    3832:	9f 4f       	sbci	r25, 0xFF	; 255
    3834:	16 c0       	rjmp	.+44     	; 0x3862 <__floatsisf+0x6c>
    3836:	88 23       	and	r24, r24
    3838:	11 f0       	breq	.+4      	; 0x383e <__floatsisf+0x48>
    383a:	96 e9       	ldi	r25, 0x96	; 150
    383c:	11 c0       	rjmp	.+34     	; 0x3860 <__floatsisf+0x6a>
    383e:	77 23       	and	r23, r23
    3840:	21 f0       	breq	.+8      	; 0x384a <__floatsisf+0x54>
    3842:	9e e8       	ldi	r25, 0x8E	; 142
    3844:	87 2f       	mov	r24, r23
    3846:	76 2f       	mov	r23, r22
    3848:	05 c0       	rjmp	.+10     	; 0x3854 <__floatsisf+0x5e>
    384a:	66 23       	and	r22, r22
    384c:	71 f0       	breq	.+28     	; 0x386a <__floatsisf+0x74>
    384e:	96 e8       	ldi	r25, 0x86	; 134
    3850:	86 2f       	mov	r24, r22
    3852:	70 e0       	ldi	r23, 0x00	; 0
    3854:	60 e0       	ldi	r22, 0x00	; 0
    3856:	2a f0       	brmi	.+10     	; 0x3862 <__floatsisf+0x6c>
    3858:	9a 95       	dec	r25
    385a:	66 0f       	add	r22, r22
    385c:	77 1f       	adc	r23, r23
    385e:	88 1f       	adc	r24, r24
    3860:	da f7       	brpl	.-10     	; 0x3858 <__floatsisf+0x62>
    3862:	88 0f       	add	r24, r24
    3864:	96 95       	lsr	r25
    3866:	87 95       	ror	r24
    3868:	97 f9       	bld	r25, 7
    386a:	08 95       	ret

0000386c <__fp_cmp>:
    386c:	99 0f       	add	r25, r25
    386e:	00 08       	sbc	r0, r0
    3870:	55 0f       	add	r21, r21
    3872:	aa 0b       	sbc	r26, r26
    3874:	e0 e8       	ldi	r30, 0x80	; 128
    3876:	fe ef       	ldi	r31, 0xFE	; 254
    3878:	16 16       	cp	r1, r22
    387a:	17 06       	cpc	r1, r23
    387c:	e8 07       	cpc	r30, r24
    387e:	f9 07       	cpc	r31, r25
    3880:	c0 f0       	brcs	.+48     	; 0x38b2 <__fp_cmp+0x46>
    3882:	12 16       	cp	r1, r18
    3884:	13 06       	cpc	r1, r19
    3886:	e4 07       	cpc	r30, r20
    3888:	f5 07       	cpc	r31, r21
    388a:	98 f0       	brcs	.+38     	; 0x38b2 <__fp_cmp+0x46>
    388c:	62 1b       	sub	r22, r18
    388e:	73 0b       	sbc	r23, r19
    3890:	84 0b       	sbc	r24, r20
    3892:	95 0b       	sbc	r25, r21
    3894:	39 f4       	brne	.+14     	; 0x38a4 <__fp_cmp+0x38>
    3896:	0a 26       	eor	r0, r26
    3898:	61 f0       	breq	.+24     	; 0x38b2 <__fp_cmp+0x46>
    389a:	23 2b       	or	r18, r19
    389c:	24 2b       	or	r18, r20
    389e:	25 2b       	or	r18, r21
    38a0:	21 f4       	brne	.+8      	; 0x38aa <__fp_cmp+0x3e>
    38a2:	08 95       	ret
    38a4:	0a 26       	eor	r0, r26
    38a6:	09 f4       	brne	.+2      	; 0x38aa <__fp_cmp+0x3e>
    38a8:	a1 40       	sbci	r26, 0x01	; 1
    38aa:	a6 95       	lsr	r26
    38ac:	8f ef       	ldi	r24, 0xFF	; 255
    38ae:	81 1d       	adc	r24, r1
    38b0:	81 1d       	adc	r24, r1
    38b2:	08 95       	ret

000038b4 <__fp_inf>:
    38b4:	97 f9       	bld	r25, 7
    38b6:	9f 67       	ori	r25, 0x7F	; 127
    38b8:	80 e8       	ldi	r24, 0x80	; 128
    38ba:	70 e0       	ldi	r23, 0x00	; 0
    38bc:	60 e0       	ldi	r22, 0x00	; 0
    38be:	08 95       	ret

000038c0 <__fp_nan>:
    38c0:	9f ef       	ldi	r25, 0xFF	; 255
    38c2:	80 ec       	ldi	r24, 0xC0	; 192
    38c4:	08 95       	ret

000038c6 <__fp_pscA>:
    38c6:	00 24       	eor	r0, r0
    38c8:	0a 94       	dec	r0
    38ca:	16 16       	cp	r1, r22
    38cc:	17 06       	cpc	r1, r23
    38ce:	18 06       	cpc	r1, r24
    38d0:	09 06       	cpc	r0, r25
    38d2:	08 95       	ret

000038d4 <__fp_pscB>:
    38d4:	00 24       	eor	r0, r0
    38d6:	0a 94       	dec	r0
    38d8:	12 16       	cp	r1, r18
    38da:	13 06       	cpc	r1, r19
    38dc:	14 06       	cpc	r1, r20
    38de:	05 06       	cpc	r0, r21
    38e0:	08 95       	ret

000038e2 <__fp_round>:
    38e2:	09 2e       	mov	r0, r25
    38e4:	03 94       	inc	r0
    38e6:	00 0c       	add	r0, r0
    38e8:	11 f4       	brne	.+4      	; 0x38ee <__fp_round+0xc>
    38ea:	88 23       	and	r24, r24
    38ec:	52 f0       	brmi	.+20     	; 0x3902 <__fp_round+0x20>
    38ee:	bb 0f       	add	r27, r27
    38f0:	40 f4       	brcc	.+16     	; 0x3902 <__fp_round+0x20>
    38f2:	bf 2b       	or	r27, r31
    38f4:	11 f4       	brne	.+4      	; 0x38fa <__fp_round+0x18>
    38f6:	60 ff       	sbrs	r22, 0
    38f8:	04 c0       	rjmp	.+8      	; 0x3902 <__fp_round+0x20>
    38fa:	6f 5f       	subi	r22, 0xFF	; 255
    38fc:	7f 4f       	sbci	r23, 0xFF	; 255
    38fe:	8f 4f       	sbci	r24, 0xFF	; 255
    3900:	9f 4f       	sbci	r25, 0xFF	; 255
    3902:	08 95       	ret

00003904 <__fp_split3>:
    3904:	57 fd       	sbrc	r21, 7
    3906:	90 58       	subi	r25, 0x80	; 128
    3908:	44 0f       	add	r20, r20
    390a:	55 1f       	adc	r21, r21
    390c:	59 f0       	breq	.+22     	; 0x3924 <__fp_splitA+0x10>
    390e:	5f 3f       	cpi	r21, 0xFF	; 255
    3910:	71 f0       	breq	.+28     	; 0x392e <__fp_splitA+0x1a>
    3912:	47 95       	ror	r20

00003914 <__fp_splitA>:
    3914:	88 0f       	add	r24, r24
    3916:	97 fb       	bst	r25, 7
    3918:	99 1f       	adc	r25, r25
    391a:	61 f0       	breq	.+24     	; 0x3934 <__fp_splitA+0x20>
    391c:	9f 3f       	cpi	r25, 0xFF	; 255
    391e:	79 f0       	breq	.+30     	; 0x393e <__fp_splitA+0x2a>
    3920:	87 95       	ror	r24
    3922:	08 95       	ret
    3924:	12 16       	cp	r1, r18
    3926:	13 06       	cpc	r1, r19
    3928:	14 06       	cpc	r1, r20
    392a:	55 1f       	adc	r21, r21
    392c:	f2 cf       	rjmp	.-28     	; 0x3912 <__fp_split3+0xe>
    392e:	46 95       	lsr	r20
    3930:	f1 df       	rcall	.-30     	; 0x3914 <__fp_splitA>
    3932:	08 c0       	rjmp	.+16     	; 0x3944 <__fp_splitA+0x30>
    3934:	16 16       	cp	r1, r22
    3936:	17 06       	cpc	r1, r23
    3938:	18 06       	cpc	r1, r24
    393a:	99 1f       	adc	r25, r25
    393c:	f1 cf       	rjmp	.-30     	; 0x3920 <__fp_splitA+0xc>
    393e:	86 95       	lsr	r24
    3940:	71 05       	cpc	r23, r1
    3942:	61 05       	cpc	r22, r1
    3944:	08 94       	sec
    3946:	08 95       	ret

00003948 <__fp_zero>:
    3948:	e8 94       	clt

0000394a <__fp_szero>:
    394a:	bb 27       	eor	r27, r27
    394c:	66 27       	eor	r22, r22
    394e:	77 27       	eor	r23, r23
    3950:	cb 01       	movw	r24, r22
    3952:	97 f9       	bld	r25, 7
    3954:	08 95       	ret

00003956 <__mulsf3>:
    3956:	0e 94 be 1c 	call	0x397c	; 0x397c <__mulsf3x>
    395a:	0c 94 71 1c 	jmp	0x38e2	; 0x38e2 <__fp_round>
    395e:	0e 94 63 1c 	call	0x38c6	; 0x38c6 <__fp_pscA>
    3962:	38 f0       	brcs	.+14     	; 0x3972 <__mulsf3+0x1c>
    3964:	0e 94 6a 1c 	call	0x38d4	; 0x38d4 <__fp_pscB>
    3968:	20 f0       	brcs	.+8      	; 0x3972 <__mulsf3+0x1c>
    396a:	95 23       	and	r25, r21
    396c:	11 f0       	breq	.+4      	; 0x3972 <__mulsf3+0x1c>
    396e:	0c 94 5a 1c 	jmp	0x38b4	; 0x38b4 <__fp_inf>
    3972:	0c 94 60 1c 	jmp	0x38c0	; 0x38c0 <__fp_nan>
    3976:	11 24       	eor	r1, r1
    3978:	0c 94 a5 1c 	jmp	0x394a	; 0x394a <__fp_szero>

0000397c <__mulsf3x>:
    397c:	0e 94 82 1c 	call	0x3904	; 0x3904 <__fp_split3>
    3980:	70 f3       	brcs	.-36     	; 0x395e <__mulsf3+0x8>

00003982 <__mulsf3_pse>:
    3982:	95 9f       	mul	r25, r21
    3984:	c1 f3       	breq	.-16     	; 0x3976 <__mulsf3+0x20>
    3986:	95 0f       	add	r25, r21
    3988:	50 e0       	ldi	r21, 0x00	; 0
    398a:	55 1f       	adc	r21, r21
    398c:	62 9f       	mul	r22, r18
    398e:	f0 01       	movw	r30, r0
    3990:	72 9f       	mul	r23, r18
    3992:	bb 27       	eor	r27, r27
    3994:	f0 0d       	add	r31, r0
    3996:	b1 1d       	adc	r27, r1
    3998:	63 9f       	mul	r22, r19
    399a:	aa 27       	eor	r26, r26
    399c:	f0 0d       	add	r31, r0
    399e:	b1 1d       	adc	r27, r1
    39a0:	aa 1f       	adc	r26, r26
    39a2:	64 9f       	mul	r22, r20
    39a4:	66 27       	eor	r22, r22
    39a6:	b0 0d       	add	r27, r0
    39a8:	a1 1d       	adc	r26, r1
    39aa:	66 1f       	adc	r22, r22
    39ac:	82 9f       	mul	r24, r18
    39ae:	22 27       	eor	r18, r18
    39b0:	b0 0d       	add	r27, r0
    39b2:	a1 1d       	adc	r26, r1
    39b4:	62 1f       	adc	r22, r18
    39b6:	73 9f       	mul	r23, r19
    39b8:	b0 0d       	add	r27, r0
    39ba:	a1 1d       	adc	r26, r1
    39bc:	62 1f       	adc	r22, r18
    39be:	83 9f       	mul	r24, r19
    39c0:	a0 0d       	add	r26, r0
    39c2:	61 1d       	adc	r22, r1
    39c4:	22 1f       	adc	r18, r18
    39c6:	74 9f       	mul	r23, r20
    39c8:	33 27       	eor	r19, r19
    39ca:	a0 0d       	add	r26, r0
    39cc:	61 1d       	adc	r22, r1
    39ce:	23 1f       	adc	r18, r19
    39d0:	84 9f       	mul	r24, r20
    39d2:	60 0d       	add	r22, r0
    39d4:	21 1d       	adc	r18, r1
    39d6:	82 2f       	mov	r24, r18
    39d8:	76 2f       	mov	r23, r22
    39da:	6a 2f       	mov	r22, r26
    39dc:	11 24       	eor	r1, r1
    39de:	9f 57       	subi	r25, 0x7F	; 127
    39e0:	50 40       	sbci	r21, 0x00	; 0
    39e2:	9a f0       	brmi	.+38     	; 0x3a0a <__mulsf3_pse+0x88>
    39e4:	f1 f0       	breq	.+60     	; 0x3a22 <__mulsf3_pse+0xa0>
    39e6:	88 23       	and	r24, r24
    39e8:	4a f0       	brmi	.+18     	; 0x39fc <__mulsf3_pse+0x7a>
    39ea:	ee 0f       	add	r30, r30
    39ec:	ff 1f       	adc	r31, r31
    39ee:	bb 1f       	adc	r27, r27
    39f0:	66 1f       	adc	r22, r22
    39f2:	77 1f       	adc	r23, r23
    39f4:	88 1f       	adc	r24, r24
    39f6:	91 50       	subi	r25, 0x01	; 1
    39f8:	50 40       	sbci	r21, 0x00	; 0
    39fa:	a9 f7       	brne	.-22     	; 0x39e6 <__mulsf3_pse+0x64>
    39fc:	9e 3f       	cpi	r25, 0xFE	; 254
    39fe:	51 05       	cpc	r21, r1
    3a00:	80 f0       	brcs	.+32     	; 0x3a22 <__mulsf3_pse+0xa0>
    3a02:	0c 94 5a 1c 	jmp	0x38b4	; 0x38b4 <__fp_inf>
    3a06:	0c 94 a5 1c 	jmp	0x394a	; 0x394a <__fp_szero>
    3a0a:	5f 3f       	cpi	r21, 0xFF	; 255
    3a0c:	e4 f3       	brlt	.-8      	; 0x3a06 <__mulsf3_pse+0x84>
    3a0e:	98 3e       	cpi	r25, 0xE8	; 232
    3a10:	d4 f3       	brlt	.-12     	; 0x3a06 <__mulsf3_pse+0x84>
    3a12:	86 95       	lsr	r24
    3a14:	77 95       	ror	r23
    3a16:	67 95       	ror	r22
    3a18:	b7 95       	ror	r27
    3a1a:	f7 95       	ror	r31
    3a1c:	e7 95       	ror	r30
    3a1e:	9f 5f       	subi	r25, 0xFF	; 255
    3a20:	c1 f7       	brne	.-16     	; 0x3a12 <__mulsf3_pse+0x90>
    3a22:	fe 2b       	or	r31, r30
    3a24:	88 0f       	add	r24, r24
    3a26:	91 1d       	adc	r25, r1
    3a28:	96 95       	lsr	r25
    3a2a:	87 95       	ror	r24
    3a2c:	97 f9       	bld	r25, 7
    3a2e:	08 95       	ret

00003a30 <_ZN14HardwareSerial9availableEv>:
  // clear any received data
  _rx_buffer_head = _rx_buffer_tail;
}

int HardwareSerial::available(void)
{
    3a30:	fc 01       	movw	r30, r24
  return ((unsigned int)(SERIAL_RX_BUFFER_SIZE + _rx_buffer_head - _rx_buffer_tail)) % SERIAL_RX_BUFFER_SIZE;
    3a32:	91 8d       	ldd	r25, Z+25	; 0x19
    3a34:	22 8d       	ldd	r18, Z+26	; 0x1a
    3a36:	89 2f       	mov	r24, r25
    3a38:	90 e0       	ldi	r25, 0x00	; 0
    3a3a:	80 5c       	subi	r24, 0xC0	; 192
    3a3c:	9f 4f       	sbci	r25, 0xFF	; 255
    3a3e:	82 1b       	sub	r24, r18
    3a40:	91 09       	sbc	r25, r1
}
    3a42:	8f 73       	andi	r24, 0x3F	; 63
    3a44:	99 27       	eor	r25, r25
    3a46:	08 95       	ret

00003a48 <_ZN14HardwareSerial4peekEv>:

int HardwareSerial::peek(void)
{
    3a48:	fc 01       	movw	r30, r24
  if (_rx_buffer_head == _rx_buffer_tail) {
    3a4a:	91 8d       	ldd	r25, Z+25	; 0x19
    3a4c:	82 8d       	ldd	r24, Z+26	; 0x1a
    3a4e:	98 17       	cp	r25, r24
    3a50:	31 f0       	breq	.+12     	; 0x3a5e <_ZN14HardwareSerial4peekEv+0x16>
    return -1;
  } else {
    return _rx_buffer[_rx_buffer_tail];
    3a52:	82 8d       	ldd	r24, Z+26	; 0x1a
    3a54:	e8 0f       	add	r30, r24
    3a56:	f1 1d       	adc	r31, r1
    3a58:	85 8d       	ldd	r24, Z+29	; 0x1d
    3a5a:	90 e0       	ldi	r25, 0x00	; 0
    3a5c:	08 95       	ret
}

int HardwareSerial::peek(void)
{
  if (_rx_buffer_head == _rx_buffer_tail) {
    return -1;
    3a5e:	8f ef       	ldi	r24, 0xFF	; 255
    3a60:	9f ef       	ldi	r25, 0xFF	; 255
  } else {
    return _rx_buffer[_rx_buffer_tail];
  }
}
    3a62:	08 95       	ret

00003a64 <_ZN14HardwareSerial4readEv>:

int HardwareSerial::read(void)
{
    3a64:	fc 01       	movw	r30, r24
  // if the head isn't ahead of the tail, we don't have any characters
  if (_rx_buffer_head == _rx_buffer_tail) {
    3a66:	91 8d       	ldd	r25, Z+25	; 0x19
    3a68:	82 8d       	ldd	r24, Z+26	; 0x1a
    3a6a:	98 17       	cp	r25, r24
    3a6c:	61 f0       	breq	.+24     	; 0x3a86 <_ZN14HardwareSerial4readEv+0x22>
    return -1;
  } else {
    unsigned char c = _rx_buffer[_rx_buffer_tail];
    3a6e:	82 8d       	ldd	r24, Z+26	; 0x1a
    3a70:	df 01       	movw	r26, r30
    3a72:	a8 0f       	add	r26, r24
    3a74:	b1 1d       	adc	r27, r1
    3a76:	5d 96       	adiw	r26, 0x1d	; 29
    3a78:	8c 91       	ld	r24, X
    _rx_buffer_tail = (rx_buffer_index_t)(_rx_buffer_tail + 1) % SERIAL_RX_BUFFER_SIZE;
    3a7a:	92 8d       	ldd	r25, Z+26	; 0x1a
    3a7c:	9f 5f       	subi	r25, 0xFF	; 255
    3a7e:	9f 73       	andi	r25, 0x3F	; 63
    3a80:	92 8f       	std	Z+26, r25	; 0x1a
    return c;
    3a82:	90 e0       	ldi	r25, 0x00	; 0
    3a84:	08 95       	ret

int HardwareSerial::read(void)
{
  // if the head isn't ahead of the tail, we don't have any characters
  if (_rx_buffer_head == _rx_buffer_tail) {
    return -1;
    3a86:	8f ef       	ldi	r24, 0xFF	; 255
    3a88:	9f ef       	ldi	r25, 0xFF	; 255
  } else {
    unsigned char c = _rx_buffer[_rx_buffer_tail];
    _rx_buffer_tail = (rx_buffer_index_t)(_rx_buffer_tail + 1) % SERIAL_RX_BUFFER_SIZE;
    return c;
  }
}
    3a8a:	08 95       	ret

00003a8c <_ZN14HardwareSerial17availableForWriteEv>:
{
  tx_buffer_index_t head;
  tx_buffer_index_t tail;

  TX_BUFFER_ATOMIC {
    head = _tx_buffer_head;
    3a8c:	fc 01       	movw	r30, r24
    3a8e:	53 8d       	ldd	r21, Z+27	; 0x1b
    tail = _tx_buffer_tail;
    3a90:	44 8d       	ldd	r20, Z+28	; 0x1c
    3a92:	25 2f       	mov	r18, r21
    3a94:	30 e0       	ldi	r19, 0x00	; 0
    3a96:	84 2f       	mov	r24, r20
    3a98:	90 e0       	ldi	r25, 0x00	; 0
  }
  if (head >= tail) return SERIAL_TX_BUFFER_SIZE - 1 - head + tail;
    3a9a:	82 1b       	sub	r24, r18
    3a9c:	93 0b       	sbc	r25, r19
    3a9e:	54 17       	cp	r21, r20
    3aa0:	10 f0       	brcs	.+4      	; 0x3aa6 <_ZN14HardwareSerial17availableForWriteEv+0x1a>
    3aa2:	cf 96       	adiw	r24, 0x3f	; 63
    3aa4:	08 95       	ret
  return tail - head - 1;
    3aa6:	01 97       	sbiw	r24, 0x01	; 1
}
    3aa8:	08 95       	ret

00003aaa <_Z14serialEventRunv>:
#endif

void serialEventRun(void)
{
#if defined(HAVE_HWSERIAL0)
  if (Serial0_available && serialEvent && Serial0_available()) serialEvent();
    3aaa:	81 eb       	ldi	r24, 0xB1	; 177
    3aac:	9e e1       	ldi	r25, 0x1E	; 30
    3aae:	89 2b       	or	r24, r25
    3ab0:	49 f0       	breq	.+18     	; 0x3ac4 <_Z14serialEventRunv+0x1a>
    3ab2:	80 e0       	ldi	r24, 0x00	; 0
    3ab4:	90 e0       	ldi	r25, 0x00	; 0
    3ab6:	89 2b       	or	r24, r25
    3ab8:	29 f0       	breq	.+10     	; 0x3ac4 <_Z14serialEventRunv+0x1a>
    3aba:	0e 94 b1 1e 	call	0x3d62	; 0x3d62 <_Z17Serial0_availablev>
    3abe:	81 11       	cpse	r24, r1
    3ac0:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>
    3ac4:	08 95       	ret

00003ac6 <_ZN14HardwareSerial17_tx_udr_empty_irqEv>:
#endif

// Actual interrupt handlers //////////////////////////////////////////////////////////////

void HardwareSerial::_tx_udr_empty_irq(void)
{
    3ac6:	fc 01       	movw	r30, r24
  // If interrupts are enabled, there must be more data in the output
  // buffer. Send the next byte
  unsigned char c = _tx_buffer[_tx_buffer_tail];
    3ac8:	84 8d       	ldd	r24, Z+28	; 0x1c
    3aca:	df 01       	movw	r26, r30
    3acc:	a8 0f       	add	r26, r24
    3ace:	b1 1d       	adc	r27, r1
    3ad0:	a3 5a       	subi	r26, 0xA3	; 163
    3ad2:	bf 4f       	sbci	r27, 0xFF	; 255
    3ad4:	2c 91       	ld	r18, X
  _tx_buffer_tail = (_tx_buffer_tail + 1) % SERIAL_TX_BUFFER_SIZE;
    3ad6:	84 8d       	ldd	r24, Z+28	; 0x1c
    3ad8:	90 e0       	ldi	r25, 0x00	; 0
    3ada:	01 96       	adiw	r24, 0x01	; 1
    3adc:	8f 73       	andi	r24, 0x3F	; 63
    3ade:	99 27       	eor	r25, r25
    3ae0:	84 8f       	std	Z+28, r24	; 0x1c

  *_udr = c;
    3ae2:	a6 89       	ldd	r26, Z+22	; 0x16
    3ae4:	b7 89       	ldd	r27, Z+23	; 0x17
    3ae6:	2c 93       	st	X, r18
  // location". This makes sure flush() won't return until the bytes
  // actually got written. Other r/w bits are preserved, and zeroes
  // written to the rest.

#ifdef MPCM0
  *_ucsra = ((*_ucsra) & ((1 << U2X0) | (1 << MPCM0))) | (1 << TXC0);
    3ae8:	a0 89       	ldd	r26, Z+16	; 0x10
    3aea:	b1 89       	ldd	r27, Z+17	; 0x11
    3aec:	8c 91       	ld	r24, X
    3aee:	83 70       	andi	r24, 0x03	; 3
    3af0:	80 64       	ori	r24, 0x40	; 64
    3af2:	8c 93       	st	X, r24
#else
  *_ucsra = ((*_ucsra) & ((1 << U2X0) | (1 << TXC0)));
#endif

  if (_tx_buffer_head == _tx_buffer_tail) {
    3af4:	93 8d       	ldd	r25, Z+27	; 0x1b
    3af6:	84 8d       	ldd	r24, Z+28	; 0x1c
    3af8:	98 13       	cpse	r25, r24
    3afa:	06 c0       	rjmp	.+12     	; 0x3b08 <_ZN14HardwareSerial17_tx_udr_empty_irqEv+0x42>
    // Buffer empty, so disable interrupts
    cbi(*_ucsrb, UDRIE0);
    3afc:	02 88       	ldd	r0, Z+18	; 0x12
    3afe:	f3 89       	ldd	r31, Z+19	; 0x13
    3b00:	e0 2d       	mov	r30, r0
    3b02:	80 81       	ld	r24, Z
    3b04:	8f 7d       	andi	r24, 0xDF	; 223
    3b06:	80 83       	st	Z, r24
    3b08:	08 95       	ret

00003b0a <_ZN14HardwareSerial5writeEh>:
  // If we get here, nothing is queued anymore (DRIE is disabled) and
  // the hardware finished tranmission (TXC is set).
}

size_t HardwareSerial::write(uint8_t c)
{
    3b0a:	ef 92       	push	r14
    3b0c:	ff 92       	push	r15
    3b0e:	0f 93       	push	r16
    3b10:	1f 93       	push	r17
    3b12:	cf 93       	push	r28
    3b14:	df 93       	push	r29
    3b16:	ec 01       	movw	r28, r24
  _written = true;
    3b18:	81 e0       	ldi	r24, 0x01	; 1
    3b1a:	88 8f       	std	Y+24, r24	; 0x18
  // If the buffer and the data register is empty, just write the byte
  // to the data register and be done. This shortcut helps
  // significantly improve the effective datarate at high (>
  // 500kbit/s) bitrates, where interrupt overhead becomes a slowdown.
  if (_tx_buffer_head == _tx_buffer_tail && bit_is_set(*_ucsra, UDRE0)) {
    3b1c:	9b 8d       	ldd	r25, Y+27	; 0x1b
    3b1e:	8c 8d       	ldd	r24, Y+28	; 0x1c
    3b20:	98 13       	cpse	r25, r24
    3b22:	05 c0       	rjmp	.+10     	; 0x3b2e <_ZN14HardwareSerial5writeEh+0x24>
    3b24:	e8 89       	ldd	r30, Y+16	; 0x10
    3b26:	f9 89       	ldd	r31, Y+17	; 0x11
    3b28:	80 81       	ld	r24, Z
    3b2a:	85 fd       	sbrc	r24, 5
    3b2c:	26 c0       	rjmp	.+76     	; 0x3b7a <_ZN14HardwareSerial5writeEh+0x70>
    3b2e:	f6 2e       	mov	r15, r22
      *_ucsra = ((*_ucsra) & ((1 << U2X0) | (1 << TXC0)));
#endif
    }
    return 1;
  }
  tx_buffer_index_t i = (_tx_buffer_head + 1) % SERIAL_TX_BUFFER_SIZE;
    3b30:	0b 8d       	ldd	r16, Y+27	; 0x1b
    3b32:	10 e0       	ldi	r17, 0x00	; 0
    3b34:	0f 5f       	subi	r16, 0xFF	; 255
    3b36:	1f 4f       	sbci	r17, 0xFF	; 255
    3b38:	0f 73       	andi	r16, 0x3F	; 63
    3b3a:	11 27       	eor	r17, r17
    3b3c:	e0 2e       	mov	r14, r16
	
  // If the output buffer is full, there's nothing for it other than to 
  // wait for the interrupt handler to empty it a bit
  while (i == _tx_buffer_tail) {
    3b3e:	8c 8d       	ldd	r24, Y+28	; 0x1c
    3b40:	e8 12       	cpse	r14, r24
    3b42:	0c c0       	rjmp	.+24     	; 0x3b5c <_ZN14HardwareSerial5writeEh+0x52>
    if (bit_is_clear(SREG, SREG_I)) {
    3b44:	0f b6       	in	r0, 0x3f	; 63
    3b46:	07 fc       	sbrc	r0, 7
    3b48:	fa cf       	rjmp	.-12     	; 0x3b3e <_ZN14HardwareSerial5writeEh+0x34>
      // Interrupts are disabled, so we'll have to poll the data
      // register empty flag ourselves. If it is set, pretend an
      // interrupt has happened and call the handler to free up
      // space for us.
      if(bit_is_set(*_ucsra, UDRE0))
    3b4a:	e8 89       	ldd	r30, Y+16	; 0x10
    3b4c:	f9 89       	ldd	r31, Y+17	; 0x11
    3b4e:	80 81       	ld	r24, Z
    3b50:	85 ff       	sbrs	r24, 5
    3b52:	f5 cf       	rjmp	.-22     	; 0x3b3e <_ZN14HardwareSerial5writeEh+0x34>
	_tx_udr_empty_irq();
    3b54:	ce 01       	movw	r24, r28
    3b56:	0e 94 63 1d 	call	0x3ac6	; 0x3ac6 <_ZN14HardwareSerial17_tx_udr_empty_irqEv>
    3b5a:	f1 cf       	rjmp	.-30     	; 0x3b3e <_ZN14HardwareSerial5writeEh+0x34>
    } else {
      // nop, the interrupt handler will free up space for us
    }
  }

  _tx_buffer[_tx_buffer_head] = c;
    3b5c:	8b 8d       	ldd	r24, Y+27	; 0x1b
    3b5e:	fe 01       	movw	r30, r28
    3b60:	e8 0f       	add	r30, r24
    3b62:	f1 1d       	adc	r31, r1
    3b64:	e3 5a       	subi	r30, 0xA3	; 163
    3b66:	ff 4f       	sbci	r31, 0xFF	; 255
    3b68:	f0 82       	st	Z, r15

  // make atomic to prevent execution of ISR between setting the
  // head pointer and setting the interrupt flag resulting in buffer
  // retransmission
  ATOMIC_BLOCK(ATOMIC_RESTORESTATE) {
    3b6a:	9f b7       	in	r25, 0x3f	; 63
    return 1;
}

static __inline__ uint8_t __iCliRetVal(void)
{
    cli();
    3b6c:	f8 94       	cli
    _tx_buffer_head = i;
    3b6e:	0b 8f       	std	Y+27, r16	; 0x1b
    sbi(*_ucsrb, UDRIE0);
    3b70:	ea 89       	ldd	r30, Y+18	; 0x12
    3b72:	fb 89       	ldd	r31, Y+19	; 0x13
    3b74:	80 81       	ld	r24, Z
    3b76:	80 62       	ori	r24, 0x20	; 32
    3b78:	0a c0       	rjmp	.+20     	; 0x3b8e <_ZN14HardwareSerial5writeEh+0x84>
    // So writing UDR must happen first.
    // Writing UDR and clearing TC must be done atomically, otherwise
    // interrupts might delay the TXC clear so the byte written to UDR
    // is transmitted (setting TXC) before clearing TXC. Then TXC will
    // be cleared when no bytes are left, causing flush() to hang
    ATOMIC_BLOCK(ATOMIC_RESTORESTATE) {
    3b7a:	9f b7       	in	r25, 0x3f	; 63
    3b7c:	f8 94       	cli
      *_udr = c;
    3b7e:	ee 89       	ldd	r30, Y+22	; 0x16
    3b80:	ff 89       	ldd	r31, Y+23	; 0x17
    3b82:	60 83       	st	Z, r22
#ifdef MPCM0
      *_ucsra = ((*_ucsra) & ((1 << U2X0) | (1 << MPCM0))) | (1 << TXC0);
    3b84:	e8 89       	ldd	r30, Y+16	; 0x10
    3b86:	f9 89       	ldd	r31, Y+17	; 0x11
    3b88:	80 81       	ld	r24, Z
    3b8a:	83 70       	andi	r24, 0x03	; 3
    3b8c:	80 64       	ori	r24, 0x40	; 64
    3b8e:	80 83       	st	Z, r24
    (void)__s;
}

static __inline__ void __iRestore(const  uint8_t *__s)
{
    SREG = *__s;
    3b90:	9f bf       	out	0x3f, r25	; 63
    _tx_buffer_head = i;
    sbi(*_ucsrb, UDRIE0);
  }
  
  return 1;
}
    3b92:	81 e0       	ldi	r24, 0x01	; 1
    3b94:	90 e0       	ldi	r25, 0x00	; 0
    3b96:	df 91       	pop	r29
    3b98:	cf 91       	pop	r28
    3b9a:	1f 91       	pop	r17
    3b9c:	0f 91       	pop	r16
    3b9e:	ff 90       	pop	r15
    3ba0:	ef 90       	pop	r14
    3ba2:	08 95       	ret

00003ba4 <_ZN14HardwareSerial5flushEv>:
  if (head >= tail) return SERIAL_TX_BUFFER_SIZE - 1 - head + tail;
  return tail - head - 1;
}

void HardwareSerial::flush()
{
    3ba4:	cf 93       	push	r28
    3ba6:	df 93       	push	r29
    3ba8:	ec 01       	movw	r28, r24
  // If we have never written a byte, no need to flush. This special
  // case is needed since there is no way to force the TXC (transmit
  // complete) bit to 1 during initialization
  if (!_written)
    3baa:	88 8d       	ldd	r24, Y+24	; 0x18
    3bac:	88 23       	and	r24, r24
    3bae:	c9 f0       	breq	.+50     	; 0x3be2 <_ZN14HardwareSerial5flushEv+0x3e>
    return;

  while (bit_is_set(*_ucsrb, UDRIE0) || bit_is_clear(*_ucsra, TXC0)) {
    3bb0:	ea 89       	ldd	r30, Y+18	; 0x12
    3bb2:	fb 89       	ldd	r31, Y+19	; 0x13
    3bb4:	80 81       	ld	r24, Z
    3bb6:	85 fd       	sbrc	r24, 5
    3bb8:	05 c0       	rjmp	.+10     	; 0x3bc4 <_ZN14HardwareSerial5flushEv+0x20>
    3bba:	a8 89       	ldd	r26, Y+16	; 0x10
    3bbc:	b9 89       	ldd	r27, Y+17	; 0x11
    3bbe:	8c 91       	ld	r24, X
    3bc0:	86 fd       	sbrc	r24, 6
    3bc2:	0f c0       	rjmp	.+30     	; 0x3be2 <_ZN14HardwareSerial5flushEv+0x3e>
    if (bit_is_clear(SREG, SREG_I) && bit_is_set(*_ucsrb, UDRIE0))
    3bc4:	0f b6       	in	r0, 0x3f	; 63
    3bc6:	07 fc       	sbrc	r0, 7
    3bc8:	f5 cf       	rjmp	.-22     	; 0x3bb4 <_ZN14HardwareSerial5flushEv+0x10>
    3bca:	80 81       	ld	r24, Z
    3bcc:	85 ff       	sbrs	r24, 5
    3bce:	f2 cf       	rjmp	.-28     	; 0x3bb4 <_ZN14HardwareSerial5flushEv+0x10>
	// Interrupts are globally disabled, but the DR empty
	// interrupt should be enabled, so poll the DR empty flag to
	// prevent deadlock
	if (bit_is_set(*_ucsra, UDRE0))
    3bd0:	a8 89       	ldd	r26, Y+16	; 0x10
    3bd2:	b9 89       	ldd	r27, Y+17	; 0x11
    3bd4:	8c 91       	ld	r24, X
    3bd6:	85 ff       	sbrs	r24, 5
    3bd8:	ed cf       	rjmp	.-38     	; 0x3bb4 <_ZN14HardwareSerial5flushEv+0x10>
	  _tx_udr_empty_irq();
    3bda:	ce 01       	movw	r24, r28
    3bdc:	0e 94 63 1d 	call	0x3ac6	; 0x3ac6 <_ZN14HardwareSerial17_tx_udr_empty_irqEv>
    3be0:	e7 cf       	rjmp	.-50     	; 0x3bb0 <_ZN14HardwareSerial5flushEv+0xc>
  }
  // If we get here, nothing is queued anymore (DRIE is disabled) and
  // the hardware finished tranmission (TXC is set).
}
    3be2:	df 91       	pop	r29
    3be4:	cf 91       	pop	r28
    3be6:	08 95       	ret

00003be8 <_ZN14HardwareSerial5beginEmh>:
}

// Public Methods //////////////////////////////////////////////////////////////

void HardwareSerial::begin(unsigned long baud, byte config)
{
    3be8:	cf 92       	push	r12
    3bea:	df 92       	push	r13
    3bec:	ef 92       	push	r14
    3bee:	ff 92       	push	r15
    3bf0:	1f 93       	push	r17
    3bf2:	cf 93       	push	r28
    3bf4:	df 93       	push	r29
    3bf6:	ec 01       	movw	r28, r24
    3bf8:	6a 01       	movw	r12, r20
    3bfa:	7b 01       	movw	r14, r22
    3bfc:	12 2f       	mov	r17, r18
  // Try u2x mode first
  uint16_t baud_setting = (F_CPU / 4 / baud - 1) / 2;
  *_ucsra = 1 << U2X0;
    3bfe:	e8 89       	ldd	r30, Y+16	; 0x10
    3c00:	f9 89       	ldd	r31, Y+17	; 0x11
    3c02:	82 e0       	ldi	r24, 0x02	; 2
    3c04:	80 83       	st	Z, r24
  // hardcoded exception for 57600 for compatibility with the bootloader
  // shipped with the Duemilanove and previous boards and the firmware
  // on the 8U2 on the Uno and Mega 2560. Also, The baud_setting cannot
  // be > 4095, so switch back to non-u2x mode if the baud rate is too
  // low.
  if (((F_CPU == 16000000UL) && (baud == 57600)) || (baud_setting >4095))
    3c06:	41 15       	cp	r20, r1
    3c08:	51 4e       	sbci	r21, 0xE1	; 225
    3c0a:	61 05       	cpc	r22, r1
    3c0c:	71 05       	cpc	r23, r1
    3c0e:	b1 f0       	breq	.+44     	; 0x3c3c <_ZN14HardwareSerial5beginEmh+0x54>
// Public Methods //////////////////////////////////////////////////////////////

void HardwareSerial::begin(unsigned long baud, byte config)
{
  // Try u2x mode first
  uint16_t baud_setting = (F_CPU / 4 / baud - 1) / 2;
    3c10:	60 e0       	ldi	r22, 0x00	; 0
    3c12:	79 e0       	ldi	r23, 0x09	; 9
    3c14:	8d e3       	ldi	r24, 0x3D	; 61
    3c16:	90 e0       	ldi	r25, 0x00	; 0
    3c18:	a7 01       	movw	r20, r14
    3c1a:	96 01       	movw	r18, r12
    3c1c:	0e 94 bd 23 	call	0x477a	; 0x477a <__udivmodsi4>
    3c20:	da 01       	movw	r26, r20
    3c22:	c9 01       	movw	r24, r18
    3c24:	01 97       	sbiw	r24, 0x01	; 1
    3c26:	a1 09       	sbc	r26, r1
    3c28:	b1 09       	sbc	r27, r1
    3c2a:	b6 95       	lsr	r27
    3c2c:	a7 95       	ror	r26
    3c2e:	97 95       	ror	r25
    3c30:	87 95       	ror	r24
    3c32:	9c 01       	movw	r18, r24
  // hardcoded exception for 57600 for compatibility with the bootloader
  // shipped with the Duemilanove and previous boards and the firmware
  // on the 8U2 on the Uno and Mega 2560. Also, The baud_setting cannot
  // be > 4095, so switch back to non-u2x mode if the baud rate is too
  // low.
  if (((F_CPU == 16000000UL) && (baud == 57600)) || (baud_setting >4095))
    3c34:	21 15       	cp	r18, r1
    3c36:	80 e1       	ldi	r24, 0x10	; 16
    3c38:	38 07       	cpc	r19, r24
    3c3a:	a8 f0       	brcs	.+42     	; 0x3c66 <_ZN14HardwareSerial5beginEmh+0x7e>
  {
    *_ucsra = 0;
    3c3c:	e8 89       	ldd	r30, Y+16	; 0x10
    3c3e:	f9 89       	ldd	r31, Y+17	; 0x11
    3c40:	10 82       	st	Z, r1
    baud_setting = (F_CPU / 8 / baud - 1) / 2;
    3c42:	60 e8       	ldi	r22, 0x80	; 128
    3c44:	74 e8       	ldi	r23, 0x84	; 132
    3c46:	8e e1       	ldi	r24, 0x1E	; 30
    3c48:	90 e0       	ldi	r25, 0x00	; 0
    3c4a:	a7 01       	movw	r20, r14
    3c4c:	96 01       	movw	r18, r12
    3c4e:	0e 94 bd 23 	call	0x477a	; 0x477a <__udivmodsi4>
    3c52:	da 01       	movw	r26, r20
    3c54:	c9 01       	movw	r24, r18
    3c56:	01 97       	sbiw	r24, 0x01	; 1
    3c58:	a1 09       	sbc	r26, r1
    3c5a:	b1 09       	sbc	r27, r1
    3c5c:	b6 95       	lsr	r27
    3c5e:	a7 95       	ror	r26
    3c60:	97 95       	ror	r25
    3c62:	87 95       	ror	r24
    3c64:	9c 01       	movw	r18, r24
  }

  // assign the baud_setting, a.k.a. ubrr (USART Baud Rate Register)
  *_ubrrh = baud_setting >> 8;
    3c66:	ec 85       	ldd	r30, Y+12	; 0x0c
    3c68:	fd 85       	ldd	r31, Y+13	; 0x0d
    3c6a:	30 83       	st	Z, r19
  *_ubrrl = baud_setting;
    3c6c:	ee 85       	ldd	r30, Y+14	; 0x0e
    3c6e:	ff 85       	ldd	r31, Y+15	; 0x0f
    3c70:	20 83       	st	Z, r18

  _written = false;
    3c72:	18 8e       	std	Y+24, r1	; 0x18

  //set the data bits, parity, and stop bits
#if defined(__AVR_ATmega8__)
  config |= 0x80; // select UCSRC register (shared with UBRRH)
#endif
  *_ucsrc = config;
    3c74:	ec 89       	ldd	r30, Y+20	; 0x14
    3c76:	fd 89       	ldd	r31, Y+21	; 0x15
    3c78:	10 83       	st	Z, r17
  
  sbi(*_ucsrb, RXEN0);
    3c7a:	ea 89       	ldd	r30, Y+18	; 0x12
    3c7c:	fb 89       	ldd	r31, Y+19	; 0x13
    3c7e:	80 81       	ld	r24, Z
    3c80:	80 61       	ori	r24, 0x10	; 16
    3c82:	80 83       	st	Z, r24
  sbi(*_ucsrb, TXEN0);
    3c84:	ea 89       	ldd	r30, Y+18	; 0x12
    3c86:	fb 89       	ldd	r31, Y+19	; 0x13
    3c88:	80 81       	ld	r24, Z
    3c8a:	88 60       	ori	r24, 0x08	; 8
    3c8c:	80 83       	st	Z, r24
  sbi(*_ucsrb, RXCIE0);
    3c8e:	ea 89       	ldd	r30, Y+18	; 0x12
    3c90:	fb 89       	ldd	r31, Y+19	; 0x13
    3c92:	80 81       	ld	r24, Z
    3c94:	80 68       	ori	r24, 0x80	; 128
    3c96:	80 83       	st	Z, r24
  cbi(*_ucsrb, UDRIE0);
    3c98:	ea 89       	ldd	r30, Y+18	; 0x12
    3c9a:	fb 89       	ldd	r31, Y+19	; 0x13
    3c9c:	80 81       	ld	r24, Z
    3c9e:	8f 7d       	andi	r24, 0xDF	; 223
    3ca0:	80 83       	st	Z, r24
}
    3ca2:	df 91       	pop	r29
    3ca4:	cf 91       	pop	r28
    3ca6:	1f 91       	pop	r17
    3ca8:	ff 90       	pop	r15
    3caa:	ef 90       	pop	r14
    3cac:	df 90       	pop	r13
    3cae:	cf 90       	pop	r12
    3cb0:	08 95       	ret

00003cb2 <__vector_18>:
#elif defined(USART_RXC_vect)
  ISR(USART_RXC_vect) // ATmega8
#else
  #error "Don't know what the Data Received vector is called for Serial"
#endif
  {
    3cb2:	1f 92       	push	r1
    3cb4:	0f 92       	push	r0
    3cb6:	0f b6       	in	r0, 0x3f	; 63
    3cb8:	0f 92       	push	r0
    3cba:	11 24       	eor	r1, r1
    3cbc:	2f 93       	push	r18
    3cbe:	8f 93       	push	r24
    3cc0:	9f 93       	push	r25
    3cc2:	ef 93       	push	r30
    3cc4:	ff 93       	push	r31

// Actual interrupt handlers //////////////////////////////////////////////////////////////

void HardwareSerial::_rx_complete_irq(void)
{
  if (bit_is_clear(*_ucsra, UPE0)) {
    3cc6:	e0 91 a9 04 	lds	r30, 0x04A9	; 0x8004a9 <Serial+0x10>
    3cca:	f0 91 aa 04 	lds	r31, 0x04AA	; 0x8004aa <Serial+0x11>
    3cce:	80 81       	ld	r24, Z
    3cd0:	e0 91 af 04 	lds	r30, 0x04AF	; 0x8004af <Serial+0x16>
    3cd4:	f0 91 b0 04 	lds	r31, 0x04B0	; 0x8004b0 <Serial+0x17>
    3cd8:	82 fd       	sbrc	r24, 2
    3cda:	12 c0       	rjmp	.+36     	; 0x3d00 <__vector_18+0x4e>
    // No Parity error, read byte and store it in the buffer if there is
    // room
    unsigned char c = *_udr;
    3cdc:	90 81       	ld	r25, Z
    rx_buffer_index_t i = (unsigned int)(_rx_buffer_head + 1) % SERIAL_RX_BUFFER_SIZE;
    3cde:	80 91 b2 04 	lds	r24, 0x04B2	; 0x8004b2 <Serial+0x19>
    3ce2:	8f 5f       	subi	r24, 0xFF	; 255
    3ce4:	8f 73       	andi	r24, 0x3F	; 63

    // if we should be storing the received character into the location
    // just before the tail (meaning that the head would advance to the
    // current location of the tail), we're about to overflow the buffer
    // and so we don't write the character or advance the head.
    if (i != _rx_buffer_tail) {
    3ce6:	20 91 b3 04 	lds	r18, 0x04B3	; 0x8004b3 <Serial+0x1a>
    3cea:	82 17       	cp	r24, r18
    3cec:	51 f0       	breq	.+20     	; 0x3d02 <__vector_18+0x50>
      _rx_buffer[_rx_buffer_head] = c;
    3cee:	e0 91 b2 04 	lds	r30, 0x04B2	; 0x8004b2 <Serial+0x19>
    3cf2:	f0 e0       	ldi	r31, 0x00	; 0
    3cf4:	e7 56       	subi	r30, 0x67	; 103
    3cf6:	fb 4f       	sbci	r31, 0xFB	; 251
    3cf8:	95 8f       	std	Z+29, r25	; 0x1d
      _rx_buffer_head = i;
    3cfa:	80 93 b2 04 	sts	0x04B2, r24	; 0x8004b2 <Serial+0x19>
    3cfe:	01 c0       	rjmp	.+2      	; 0x3d02 <__vector_18+0x50>
    }
  } else {
    // Parity error, read byte but discard it
    *_udr;
    3d00:	80 81       	ld	r24, Z
    Serial._rx_complete_irq();
  }
    3d02:	ff 91       	pop	r31
    3d04:	ef 91       	pop	r30
    3d06:	9f 91       	pop	r25
    3d08:	8f 91       	pop	r24
    3d0a:	2f 91       	pop	r18
    3d0c:	0f 90       	pop	r0
    3d0e:	0f be       	out	0x3f, r0	; 63
    3d10:	0f 90       	pop	r0
    3d12:	1f 90       	pop	r1
    3d14:	18 95       	reti

00003d16 <__vector_19>:
#elif defined(USART_UDRE_vect)
ISR(USART_UDRE_vect)
#else
  #error "Don't know what the Data Register Empty vector is called for Serial"
#endif
{
    3d16:	1f 92       	push	r1
    3d18:	0f 92       	push	r0
    3d1a:	0f b6       	in	r0, 0x3f	; 63
    3d1c:	0f 92       	push	r0
    3d1e:	11 24       	eor	r1, r1
    3d20:	2f 93       	push	r18
    3d22:	3f 93       	push	r19
    3d24:	4f 93       	push	r20
    3d26:	5f 93       	push	r21
    3d28:	6f 93       	push	r22
    3d2a:	7f 93       	push	r23
    3d2c:	8f 93       	push	r24
    3d2e:	9f 93       	push	r25
    3d30:	af 93       	push	r26
    3d32:	bf 93       	push	r27
    3d34:	ef 93       	push	r30
    3d36:	ff 93       	push	r31
  Serial._tx_udr_empty_irq();
    3d38:	89 e9       	ldi	r24, 0x99	; 153
    3d3a:	94 e0       	ldi	r25, 0x04	; 4
    3d3c:	0e 94 63 1d 	call	0x3ac6	; 0x3ac6 <_ZN14HardwareSerial17_tx_udr_empty_irqEv>
}
    3d40:	ff 91       	pop	r31
    3d42:	ef 91       	pop	r30
    3d44:	bf 91       	pop	r27
    3d46:	af 91       	pop	r26
    3d48:	9f 91       	pop	r25
    3d4a:	8f 91       	pop	r24
    3d4c:	7f 91       	pop	r23
    3d4e:	6f 91       	pop	r22
    3d50:	5f 91       	pop	r21
    3d52:	4f 91       	pop	r20
    3d54:	3f 91       	pop	r19
    3d56:	2f 91       	pop	r18
    3d58:	0f 90       	pop	r0
    3d5a:	0f be       	out	0x3f, r0	; 63
    3d5c:	0f 90       	pop	r0
    3d5e:	1f 90       	pop	r1
    3d60:	18 95       	reti

00003d62 <_Z17Serial0_availablev>:
#endif

// Function that can be weakly referenced by serialEventRun to prevent
// pulling in this file if it's not otherwise used.
bool Serial0_available() {
  return Serial.available();
    3d62:	89 e9       	ldi	r24, 0x99	; 153
    3d64:	94 e0       	ldi	r25, 0x04	; 4
    3d66:	0e 94 18 1d 	call	0x3a30	; 0x3a30 <_ZN14HardwareSerial9availableEv>
    3d6a:	21 e0       	ldi	r18, 0x01	; 1
    3d6c:	89 2b       	or	r24, r25
    3d6e:	09 f4       	brne	.+2      	; 0x3d72 <_Z17Serial0_availablev+0x10>
    3d70:	20 e0       	ldi	r18, 0x00	; 0
}
    3d72:	82 2f       	mov	r24, r18
    3d74:	08 95       	ret

00003d76 <_GLOBAL__sub_I___vector_18>:
    size_t printNumber(unsigned long, uint8_t);
    size_t printFloat(double, uint8_t);
  protected:
    void setWriteError(int err = 1) { write_error = err; }
  public:
    Print() : write_error(0) {}
    3d76:	e9 e9       	ldi	r30, 0x99	; 153
    3d78:	f4 e0       	ldi	r31, 0x04	; 4
    3d7a:	13 82       	std	Z+3, r1	; 0x03
    3d7c:	12 82       	std	Z+2, r1	; 0x02
  public:
    virtual int available() = 0;
    virtual int read() = 0;
    virtual int peek() = 0;

    Stream() {_timeout=1000;}
    3d7e:	88 ee       	ldi	r24, 0xE8	; 232
    3d80:	93 e0       	ldi	r25, 0x03	; 3
    3d82:	a0 e0       	ldi	r26, 0x00	; 0
    3d84:	b0 e0       	ldi	r27, 0x00	; 0
    3d86:	84 83       	std	Z+4, r24	; 0x04
    3d88:	95 83       	std	Z+5, r25	; 0x05
    3d8a:	a6 83       	std	Z+6, r26	; 0x06
    3d8c:	b7 83       	std	Z+7, r27	; 0x07
  volatile uint8_t *ucsrc, volatile uint8_t *udr) :
    _ubrrh(ubrrh), _ubrrl(ubrrl),
    _ucsra(ucsra), _ucsrb(ucsrb), _ucsrc(ucsrc),
    _udr(udr),
    _rx_buffer_head(0), _rx_buffer_tail(0),
    _tx_buffer_head(0), _tx_buffer_tail(0)
    3d8e:	87 e7       	ldi	r24, 0x77	; 119
    3d90:	92 e0       	ldi	r25, 0x02	; 2
    3d92:	91 83       	std	Z+1, r25	; 0x01
    3d94:	80 83       	st	Z, r24
    3d96:	85 ec       	ldi	r24, 0xC5	; 197
    3d98:	90 e0       	ldi	r25, 0x00	; 0
    3d9a:	95 87       	std	Z+13, r25	; 0x0d
    3d9c:	84 87       	std	Z+12, r24	; 0x0c
    3d9e:	84 ec       	ldi	r24, 0xC4	; 196
    3da0:	90 e0       	ldi	r25, 0x00	; 0
    3da2:	97 87       	std	Z+15, r25	; 0x0f
    3da4:	86 87       	std	Z+14, r24	; 0x0e
    3da6:	80 ec       	ldi	r24, 0xC0	; 192
    3da8:	90 e0       	ldi	r25, 0x00	; 0
    3daa:	91 8b       	std	Z+17, r25	; 0x11
    3dac:	80 8b       	std	Z+16, r24	; 0x10
    3dae:	81 ec       	ldi	r24, 0xC1	; 193
    3db0:	90 e0       	ldi	r25, 0x00	; 0
    3db2:	93 8b       	std	Z+19, r25	; 0x13
    3db4:	82 8b       	std	Z+18, r24	; 0x12
    3db6:	82 ec       	ldi	r24, 0xC2	; 194
    3db8:	90 e0       	ldi	r25, 0x00	; 0
    3dba:	95 8b       	std	Z+21, r25	; 0x15
    3dbc:	84 8b       	std	Z+20, r24	; 0x14
    3dbe:	86 ec       	ldi	r24, 0xC6	; 198
    3dc0:	90 e0       	ldi	r25, 0x00	; 0
    3dc2:	97 8b       	std	Z+23, r25	; 0x17
    3dc4:	86 8b       	std	Z+22, r24	; 0x16
    3dc6:	11 8e       	std	Z+25, r1	; 0x19
    3dc8:	12 8e       	std	Z+26, r1	; 0x1a
    3dca:	13 8e       	std	Z+27, r1	; 0x1b
    3dcc:	14 8e       	std	Z+28, r1	; 0x1c
    3dce:	08 95       	ret

00003dd0 <main>:
void setupUSB() __attribute__((weak));
void setupUSB() { }

int main(void)
{
	init();
    3dd0:	0e 94 47 21 	call	0x428e	; 0x428e <init>

	initVariant();
    3dd4:	0e 94 a1 16 	call	0x2d42	; 0x2d42 <initVariant>

#if defined(USBCON)
	USBDevice.attach();
#endif
	
	setup();
    3dd8:	0e 94 24 06 	call	0xc48	; 0xc48 <setup>
    
	for (;;) {
		loop();
		if (serialEventRun) serialEventRun();
    3ddc:	c5 e5       	ldi	r28, 0x55	; 85
    3dde:	dd e1       	ldi	r29, 0x1D	; 29
#endif
	
	setup();
    
	for (;;) {
		loop();
    3de0:	0e 94 9a 06 	call	0xd34	; 0xd34 <loop>
		if (serialEventRun) serialEventRun();
    3de4:	20 97       	sbiw	r28, 0x00	; 0
    3de6:	e1 f3       	breq	.-8      	; 0x3de0 <main+0x10>
    3de8:	0e 94 55 1d 	call	0x3aaa	; 0x3aaa <_Z14serialEventRunv>
    3dec:	f9 cf       	rjmp	.-14     	; 0x3de0 <main+0x10>

00003dee <_ZN5Print5writeEPKhj>:
size_t Print::println(unsigned long num, int base)
{
  size_t n = print(num, base);
  n += println();
  return n;
}
    3dee:	cf 92       	push	r12
    3df0:	df 92       	push	r13
    3df2:	ef 92       	push	r14
    3df4:	ff 92       	push	r15
    3df6:	0f 93       	push	r16
    3df8:	1f 93       	push	r17
    3dfa:	cf 93       	push	r28
    3dfc:	df 93       	push	r29
    3dfe:	6c 01       	movw	r12, r24
    3e00:	7a 01       	movw	r14, r20
    3e02:	8b 01       	movw	r16, r22
    3e04:	c0 e0       	ldi	r28, 0x00	; 0
    3e06:	d0 e0       	ldi	r29, 0x00	; 0
    3e08:	ce 15       	cp	r28, r14
    3e0a:	df 05       	cpc	r29, r15
    3e0c:	81 f0       	breq	.+32     	; 0x3e2e <_ZN5Print5writeEPKhj+0x40>
    3e0e:	d8 01       	movw	r26, r16
    3e10:	6d 91       	ld	r22, X+
    3e12:	8d 01       	movw	r16, r26
    3e14:	d6 01       	movw	r26, r12
    3e16:	ed 91       	ld	r30, X+
    3e18:	fc 91       	ld	r31, X
    3e1a:	01 90       	ld	r0, Z+
    3e1c:	f0 81       	ld	r31, Z
    3e1e:	e0 2d       	mov	r30, r0
    3e20:	c6 01       	movw	r24, r12
    3e22:	09 95       	icall
    3e24:	89 2b       	or	r24, r25
    3e26:	11 f0       	breq	.+4      	; 0x3e2c <_ZN5Print5writeEPKhj+0x3e>
    3e28:	21 96       	adiw	r28, 0x01	; 1
    3e2a:	ee cf       	rjmp	.-36     	; 0x3e08 <_ZN5Print5writeEPKhj+0x1a>
    3e2c:	7e 01       	movw	r14, r28
    3e2e:	c7 01       	movw	r24, r14
    3e30:	df 91       	pop	r29
    3e32:	cf 91       	pop	r28
    3e34:	1f 91       	pop	r17
    3e36:	0f 91       	pop	r16
    3e38:	ff 90       	pop	r15
    3e3a:	ef 90       	pop	r14
    3e3c:	df 90       	pop	r13
    3e3e:	cf 90       	pop	r12
    3e40:	08 95       	ret

00003e42 <_ZN5Print5printEPK19__FlashStringHelper>:
    3e42:	ef 92       	push	r14
    3e44:	ff 92       	push	r15
    3e46:	0f 93       	push	r16
    3e48:	1f 93       	push	r17
    3e4a:	cf 93       	push	r28
    3e4c:	df 93       	push	r29
    3e4e:	8c 01       	movw	r16, r24
    3e50:	7b 01       	movw	r14, r22
    3e52:	c0 e0       	ldi	r28, 0x00	; 0
    3e54:	d0 e0       	ldi	r29, 0x00	; 0
    3e56:	f7 01       	movw	r30, r14
    3e58:	ec 0f       	add	r30, r28
    3e5a:	fd 1f       	adc	r31, r29
    3e5c:	64 91       	lpm	r22, Z
    3e5e:	66 23       	and	r22, r22
    3e60:	61 f0       	breq	.+24     	; 0x3e7a <_ZN5Print5printEPK19__FlashStringHelper+0x38>
    3e62:	d8 01       	movw	r26, r16
    3e64:	ed 91       	ld	r30, X+
    3e66:	fc 91       	ld	r31, X
    3e68:	01 90       	ld	r0, Z+
    3e6a:	f0 81       	ld	r31, Z
    3e6c:	e0 2d       	mov	r30, r0
    3e6e:	c8 01       	movw	r24, r16
    3e70:	09 95       	icall
    3e72:	89 2b       	or	r24, r25
    3e74:	11 f0       	breq	.+4      	; 0x3e7a <_ZN5Print5printEPK19__FlashStringHelper+0x38>
    3e76:	21 96       	adiw	r28, 0x01	; 1
    3e78:	ee cf       	rjmp	.-36     	; 0x3e56 <_ZN5Print5printEPK19__FlashStringHelper+0x14>
    3e7a:	ce 01       	movw	r24, r28
    3e7c:	df 91       	pop	r29
    3e7e:	cf 91       	pop	r28
    3e80:	1f 91       	pop	r17
    3e82:	0f 91       	pop	r16
    3e84:	ff 90       	pop	r15
    3e86:	ef 90       	pop	r14
    3e88:	08 95       	ret

00003e8a <_ZN5Print5printEPKc>:
    3e8a:	0c 94 1b 05 	jmp	0xa36	; 0xa36 <_ZN5Print5writeEPKc>

00003e8e <_ZN5Print5printEc>:
    3e8e:	dc 01       	movw	r26, r24
    3e90:	ed 91       	ld	r30, X+
    3e92:	fc 91       	ld	r31, X
    3e94:	01 90       	ld	r0, Z+
    3e96:	f0 81       	ld	r31, Z
    3e98:	e0 2d       	mov	r30, r0
    3e9a:	09 94       	ijmp

00003e9c <_ZN5Print7printlnEv>:
    3e9c:	65 e8       	ldi	r22, 0x85	; 133
    3e9e:	72 e0       	ldi	r23, 0x02	; 2
    3ea0:	0c 94 1b 05 	jmp	0xa36	; 0xa36 <_ZN5Print5writeEPKc>

00003ea4 <_ZN5Print7printlnEPKc>:
    3ea4:	0f 93       	push	r16
    3ea6:	1f 93       	push	r17
    3ea8:	cf 93       	push	r28
    3eaa:	df 93       	push	r29
    3eac:	ec 01       	movw	r28, r24
    3eae:	0e 94 1b 05 	call	0xa36	; 0xa36 <_ZN5Print5writeEPKc>
    3eb2:	8c 01       	movw	r16, r24
    3eb4:	ce 01       	movw	r24, r28
    3eb6:	0e 94 4e 1f 	call	0x3e9c	; 0x3e9c <_ZN5Print7printlnEv>
    3eba:	80 0f       	add	r24, r16
    3ebc:	91 1f       	adc	r25, r17
    3ebe:	df 91       	pop	r29
    3ec0:	cf 91       	pop	r28
    3ec2:	1f 91       	pop	r17
    3ec4:	0f 91       	pop	r16
    3ec6:	08 95       	ret

00003ec8 <_ZN5Print11printNumberEmh>:
    3ec8:	8f 92       	push	r8
    3eca:	9f 92       	push	r9
    3ecc:	af 92       	push	r10
    3ece:	bf 92       	push	r11
    3ed0:	ef 92       	push	r14
    3ed2:	ff 92       	push	r15
    3ed4:	0f 93       	push	r16
    3ed6:	1f 93       	push	r17
    3ed8:	cf 93       	push	r28
    3eda:	df 93       	push	r29
    3edc:	cd b7       	in	r28, 0x3d	; 61
    3ede:	de b7       	in	r29, 0x3e	; 62
    3ee0:	a1 97       	sbiw	r28, 0x21	; 33
    3ee2:	0f b6       	in	r0, 0x3f	; 63
    3ee4:	f8 94       	cli
    3ee6:	de bf       	out	0x3e, r29	; 62
    3ee8:	0f be       	out	0x3f, r0	; 63
    3eea:	cd bf       	out	0x3d, r28	; 61
    3eec:	7c 01       	movw	r14, r24
    3eee:	fa 01       	movw	r30, r20
    3ef0:	cb 01       	movw	r24, r22
    3ef2:	19 a2       	std	Y+33, r1	; 0x21
    3ef4:	22 30       	cpi	r18, 0x02	; 2
    3ef6:	08 f4       	brcc	.+2      	; 0x3efa <_ZN5Print11printNumberEmh+0x32>
    3ef8:	2a e0       	ldi	r18, 0x0A	; 10
    3efa:	8e 01       	movw	r16, r28
    3efc:	0f 5d       	subi	r16, 0xDF	; 223
    3efe:	1f 4f       	sbci	r17, 0xFF	; 255
    3f00:	82 2e       	mov	r8, r18
    3f02:	91 2c       	mov	r9, r1
    3f04:	a1 2c       	mov	r10, r1
    3f06:	b1 2c       	mov	r11, r1
    3f08:	bf 01       	movw	r22, r30
    3f0a:	a5 01       	movw	r20, r10
    3f0c:	94 01       	movw	r18, r8
    3f0e:	0e 94 bd 23 	call	0x477a	; 0x477a <__udivmodsi4>
    3f12:	f9 01       	movw	r30, r18
    3f14:	ca 01       	movw	r24, r20
    3f16:	01 50       	subi	r16, 0x01	; 1
    3f18:	11 09       	sbc	r17, r1
    3f1a:	6a 30       	cpi	r22, 0x0A	; 10
    3f1c:	10 f4       	brcc	.+4      	; 0x3f22 <_ZN5Print11printNumberEmh+0x5a>
    3f1e:	60 5d       	subi	r22, 0xD0	; 208
    3f20:	01 c0       	rjmp	.+2      	; 0x3f24 <_ZN5Print11printNumberEmh+0x5c>
    3f22:	69 5c       	subi	r22, 0xC9	; 201
    3f24:	d8 01       	movw	r26, r16
    3f26:	6c 93       	st	X, r22
    3f28:	23 2b       	or	r18, r19
    3f2a:	24 2b       	or	r18, r20
    3f2c:	25 2b       	or	r18, r21
    3f2e:	61 f7       	brne	.-40     	; 0x3f08 <_ZN5Print11printNumberEmh+0x40>
    3f30:	b8 01       	movw	r22, r16
    3f32:	c7 01       	movw	r24, r14
    3f34:	0e 94 1b 05 	call	0xa36	; 0xa36 <_ZN5Print5writeEPKc>
    3f38:	a1 96       	adiw	r28, 0x21	; 33
    3f3a:	0f b6       	in	r0, 0x3f	; 63
    3f3c:	f8 94       	cli
    3f3e:	de bf       	out	0x3e, r29	; 62
    3f40:	0f be       	out	0x3f, r0	; 63
    3f42:	cd bf       	out	0x3d, r28	; 61
    3f44:	df 91       	pop	r29
    3f46:	cf 91       	pop	r28
    3f48:	1f 91       	pop	r17
    3f4a:	0f 91       	pop	r16
    3f4c:	ff 90       	pop	r15
    3f4e:	ef 90       	pop	r14
    3f50:	bf 90       	pop	r11
    3f52:	af 90       	pop	r10
    3f54:	9f 90       	pop	r9
    3f56:	8f 90       	pop	r8
    3f58:	08 95       	ret

00003f5a <_ZN5Print5printEmi>:
    3f5a:	21 15       	cp	r18, r1
    3f5c:	31 05       	cpc	r19, r1
    3f5e:	41 f4       	brne	.+16     	; 0x3f70 <_ZN5Print5printEmi+0x16>
    3f60:	dc 01       	movw	r26, r24
    3f62:	ed 91       	ld	r30, X+
    3f64:	fc 91       	ld	r31, X
    3f66:	01 90       	ld	r0, Z+
    3f68:	f0 81       	ld	r31, Z
    3f6a:	e0 2d       	mov	r30, r0
    3f6c:	64 2f       	mov	r22, r20
    3f6e:	09 94       	ijmp
    3f70:	0c 94 64 1f 	jmp	0x3ec8	; 0x3ec8 <_ZN5Print11printNumberEmh>

00003f74 <_ZN5Print5printEhi>:
    3f74:	9a 01       	movw	r18, r20
    3f76:	46 2f       	mov	r20, r22
    3f78:	50 e0       	ldi	r21, 0x00	; 0
    3f7a:	60 e0       	ldi	r22, 0x00	; 0
    3f7c:	70 e0       	ldi	r23, 0x00	; 0
    3f7e:	0c 94 ad 1f 	jmp	0x3f5a	; 0x3f5a <_ZN5Print5printEmi>

00003f82 <_ZN5Print7printlnEhi>:
    3f82:	0f 93       	push	r16
    3f84:	1f 93       	push	r17
    3f86:	cf 93       	push	r28
    3f88:	df 93       	push	r29
    3f8a:	ec 01       	movw	r28, r24
    3f8c:	0e 94 ba 1f 	call	0x3f74	; 0x3f74 <_ZN5Print5printEhi>
    3f90:	8c 01       	movw	r16, r24
    3f92:	ce 01       	movw	r24, r28
    3f94:	0e 94 4e 1f 	call	0x3e9c	; 0x3e9c <_ZN5Print7printlnEv>
    3f98:	80 0f       	add	r24, r16
    3f9a:	91 1f       	adc	r25, r17
    3f9c:	df 91       	pop	r29
    3f9e:	cf 91       	pop	r28
    3fa0:	1f 91       	pop	r17
    3fa2:	0f 91       	pop	r16
    3fa4:	08 95       	ret

00003fa6 <_ZN5Print5printEli>:
{
  return print((unsigned long) n, base);
}

size_t Print::print(long n, int base)
{
    3fa6:	cf 92       	push	r12
    3fa8:	df 92       	push	r13
    3faa:	ef 92       	push	r14
    3fac:	ff 92       	push	r15
    3fae:	0f 93       	push	r16
    3fb0:	1f 93       	push	r17
    3fb2:	cf 93       	push	r28
    3fb4:	df 93       	push	r29
  if (base == 0) {
    3fb6:	21 15       	cp	r18, r1
    3fb8:	31 05       	cpc	r19, r1
    3fba:	81 f4       	brne	.+32     	; 0x3fdc <_ZN5Print5printEli+0x36>
    return write(n);
    3fbc:	dc 01       	movw	r26, r24
    3fbe:	ed 91       	ld	r30, X+
    3fc0:	fc 91       	ld	r31, X
    3fc2:	01 90       	ld	r0, Z+
    3fc4:	f0 81       	ld	r31, Z
    3fc6:	e0 2d       	mov	r30, r0
    3fc8:	64 2f       	mov	r22, r20
    }
    return printNumber(n, 10);
  } else {
    return printNumber(n, base);
  }
}
    3fca:	df 91       	pop	r29
    3fcc:	cf 91       	pop	r28
    3fce:	1f 91       	pop	r17
    3fd0:	0f 91       	pop	r16
    3fd2:	ff 90       	pop	r15
    3fd4:	ef 90       	pop	r14
    3fd6:	df 90       	pop	r13
    3fd8:	cf 90       	pop	r12
}

size_t Print::print(long n, int base)
{
  if (base == 0) {
    return write(n);
    3fda:	09 94       	ijmp
  } else if (base == 10) {
    3fdc:	2a 30       	cpi	r18, 0x0A	; 10
    3fde:	31 05       	cpc	r19, r1
    3fe0:	01 f5       	brne	.+64     	; 0x4022 <_ZN5Print5printEli+0x7c>
    if (n < 0) {
    3fe2:	77 ff       	sbrs	r23, 7
    3fe4:	1d c0       	rjmp	.+58     	; 0x4020 <_ZN5Print5printEli+0x7a>
    3fe6:	6a 01       	movw	r12, r20
    3fe8:	7b 01       	movw	r14, r22
    3fea:	ec 01       	movw	r28, r24
      int t = print('-');
    3fec:	6d e2       	ldi	r22, 0x2D	; 45
    3fee:	0e 94 47 1f 	call	0x3e8e	; 0x3e8e <_ZN5Print5printEc>
    3ff2:	8c 01       	movw	r16, r24
      n = -n;
      return printNumber(n, 10) + t;
    3ff4:	44 27       	eor	r20, r20
    3ff6:	55 27       	eor	r21, r21
    3ff8:	ba 01       	movw	r22, r20
    3ffa:	4c 19       	sub	r20, r12
    3ffc:	5d 09       	sbc	r21, r13
    3ffe:	6e 09       	sbc	r22, r14
    4000:	7f 09       	sbc	r23, r15
    4002:	2a e0       	ldi	r18, 0x0A	; 10
    4004:	ce 01       	movw	r24, r28
    4006:	0e 94 64 1f 	call	0x3ec8	; 0x3ec8 <_ZN5Print11printNumberEmh>
    400a:	80 0f       	add	r24, r16
    400c:	91 1f       	adc	r25, r17
    }
    return printNumber(n, 10);
  } else {
    return printNumber(n, base);
  }
}
    400e:	df 91       	pop	r29
    4010:	cf 91       	pop	r28
    4012:	1f 91       	pop	r17
    4014:	0f 91       	pop	r16
    4016:	ff 90       	pop	r15
    4018:	ef 90       	pop	r14
    401a:	df 90       	pop	r13
    401c:	cf 90       	pop	r12
    401e:	08 95       	ret
    if (n < 0) {
      int t = print('-');
      n = -n;
      return printNumber(n, 10) + t;
    }
    return printNumber(n, 10);
    4020:	2a e0       	ldi	r18, 0x0A	; 10
  } else {
    return printNumber(n, base);
  }
}
    4022:	df 91       	pop	r29
    4024:	cf 91       	pop	r28
    4026:	1f 91       	pop	r17
    4028:	0f 91       	pop	r16
    402a:	ff 90       	pop	r15
    402c:	ef 90       	pop	r14
    402e:	df 90       	pop	r13
    4030:	cf 90       	pop	r12
      n = -n;
      return printNumber(n, 10) + t;
    }
    return printNumber(n, 10);
  } else {
    return printNumber(n, base);
    4032:	0c 94 64 1f 	jmp	0x3ec8	; 0x3ec8 <_ZN5Print11printNumberEmh>

00004036 <_ZN5Print5printEii>:
{
  return print((unsigned long) b, base);
}

size_t Print::print(int n, int base)
{
    4036:	9a 01       	movw	r18, r20
  return print((long) n, base);
    4038:	ab 01       	movw	r20, r22
    403a:	77 0f       	add	r23, r23
    403c:	66 0b       	sbc	r22, r22
    403e:	77 0b       	sbc	r23, r23
    4040:	0c 94 d3 1f 	jmp	0x3fa6	; 0x3fa6 <_ZN5Print5printEli>

00004044 <nothing>:
    #endif
      break;       
#endif
    }
      
    intFunc[interruptNum] = nothing;
    4044:	08 95       	ret

00004046 <attachInterrupt>:
    4046:	82 30       	cpi	r24, 0x02	; 2
    4048:	e8 f4       	brcc	.+58     	; 0x4084 <attachInterrupt+0x3e>
    404a:	e8 2f       	mov	r30, r24
    404c:	f0 e0       	ldi	r31, 0x00	; 0
    404e:	ee 0f       	add	r30, r30
    4050:	ff 1f       	adc	r31, r31
    4052:	e3 5c       	subi	r30, 0xC3	; 195
    4054:	fe 4f       	sbci	r31, 0xFE	; 254
    4056:	71 83       	std	Z+1, r23	; 0x01
    4058:	60 83       	st	Z, r22
    405a:	81 30       	cpi	r24, 0x01	; 1
    405c:	41 f0       	breq	.+16     	; 0x406e <attachInterrupt+0x28>
    405e:	80 91 69 00 	lds	r24, 0x0069	; 0x800069 <__DATA_REGION_ORIGIN__+0x9>
    4062:	8c 7f       	andi	r24, 0xFC	; 252
    4064:	48 2b       	or	r20, r24
    4066:	40 93 69 00 	sts	0x0069, r20	; 0x800069 <__DATA_REGION_ORIGIN__+0x9>
    406a:	e8 9a       	sbi	0x1d, 0	; 29
    406c:	08 95       	ret
    406e:	80 91 69 00 	lds	r24, 0x0069	; 0x800069 <__DATA_REGION_ORIGIN__+0x9>
    4072:	83 7f       	andi	r24, 0xF3	; 243
    4074:	44 0f       	add	r20, r20
    4076:	55 1f       	adc	r21, r21
    4078:	44 0f       	add	r20, r20
    407a:	55 1f       	adc	r21, r21
    407c:	48 2b       	or	r20, r24
    407e:	40 93 69 00 	sts	0x0069, r20	; 0x800069 <__DATA_REGION_ORIGIN__+0x9>
    4082:	e9 9a       	sbi	0x1d, 1	; 29
    4084:	08 95       	ret

00004086 <__vector_1>:
IMPLEMENT_ISR(INT6_vect, EXTERNAL_INT_6)
IMPLEMENT_ISR(INT7_vect, EXTERNAL_INT_7)

#else

IMPLEMENT_ISR(INT0_vect, EXTERNAL_INT_0)
    4086:	1f 92       	push	r1
    4088:	0f 92       	push	r0
    408a:	0f b6       	in	r0, 0x3f	; 63
    408c:	0f 92       	push	r0
    408e:	11 24       	eor	r1, r1
    4090:	2f 93       	push	r18
    4092:	3f 93       	push	r19
    4094:	4f 93       	push	r20
    4096:	5f 93       	push	r21
    4098:	6f 93       	push	r22
    409a:	7f 93       	push	r23
    409c:	8f 93       	push	r24
    409e:	9f 93       	push	r25
    40a0:	af 93       	push	r26
    40a2:	bf 93       	push	r27
    40a4:	ef 93       	push	r30
    40a6:	ff 93       	push	r31
    40a8:	e0 91 3d 01 	lds	r30, 0x013D	; 0x80013d <intFunc>
    40ac:	f0 91 3e 01 	lds	r31, 0x013E	; 0x80013e <intFunc+0x1>
    40b0:	09 95       	icall
    40b2:	ff 91       	pop	r31
    40b4:	ef 91       	pop	r30
    40b6:	bf 91       	pop	r27
    40b8:	af 91       	pop	r26
    40ba:	9f 91       	pop	r25
    40bc:	8f 91       	pop	r24
    40be:	7f 91       	pop	r23
    40c0:	6f 91       	pop	r22
    40c2:	5f 91       	pop	r21
    40c4:	4f 91       	pop	r20
    40c6:	3f 91       	pop	r19
    40c8:	2f 91       	pop	r18
    40ca:	0f 90       	pop	r0
    40cc:	0f be       	out	0x3f, r0	; 63
    40ce:	0f 90       	pop	r0
    40d0:	1f 90       	pop	r1
    40d2:	18 95       	reti

000040d4 <__vector_2>:
IMPLEMENT_ISR(INT1_vect, EXTERNAL_INT_1)
    40d4:	1f 92       	push	r1
    40d6:	0f 92       	push	r0
    40d8:	0f b6       	in	r0, 0x3f	; 63
    40da:	0f 92       	push	r0
    40dc:	11 24       	eor	r1, r1
    40de:	2f 93       	push	r18
    40e0:	3f 93       	push	r19
    40e2:	4f 93       	push	r20
    40e4:	5f 93       	push	r21
    40e6:	6f 93       	push	r22
    40e8:	7f 93       	push	r23
    40ea:	8f 93       	push	r24
    40ec:	9f 93       	push	r25
    40ee:	af 93       	push	r26
    40f0:	bf 93       	push	r27
    40f2:	ef 93       	push	r30
    40f4:	ff 93       	push	r31
    40f6:	e0 91 3f 01 	lds	r30, 0x013F	; 0x80013f <intFunc+0x2>
    40fa:	f0 91 40 01 	lds	r31, 0x0140	; 0x800140 <intFunc+0x3>
    40fe:	09 95       	icall
    4100:	ff 91       	pop	r31
    4102:	ef 91       	pop	r30
    4104:	bf 91       	pop	r27
    4106:	af 91       	pop	r26
    4108:	9f 91       	pop	r25
    410a:	8f 91       	pop	r24
    410c:	7f 91       	pop	r23
    410e:	6f 91       	pop	r22
    4110:	5f 91       	pop	r21
    4112:	4f 91       	pop	r20
    4114:	3f 91       	pop	r19
    4116:	2f 91       	pop	r18
    4118:	0f 90       	pop	r0
    411a:	0f be       	out	0x3f, r0	; 63
    411c:	0f 90       	pop	r0
    411e:	1f 90       	pop	r1
    4120:	18 95       	reti

00004122 <__vector_16>:
	cli();
	m = timer0_millis;
	SREG = oldSREG;

	return m;
}
    4122:	1f 92       	push	r1
    4124:	0f 92       	push	r0
    4126:	0f b6       	in	r0, 0x3f	; 63
    4128:	0f 92       	push	r0
    412a:	11 24       	eor	r1, r1
    412c:	2f 93       	push	r18
    412e:	3f 93       	push	r19
    4130:	8f 93       	push	r24
    4132:	9f 93       	push	r25
    4134:	af 93       	push	r26
    4136:	bf 93       	push	r27
    4138:	80 91 37 05 	lds	r24, 0x0537	; 0x800537 <timer0_millis>
    413c:	90 91 38 05 	lds	r25, 0x0538	; 0x800538 <timer0_millis+0x1>
    4140:	a0 91 39 05 	lds	r26, 0x0539	; 0x800539 <timer0_millis+0x2>
    4144:	b0 91 3a 05 	lds	r27, 0x053A	; 0x80053a <timer0_millis+0x3>
    4148:	30 91 36 05 	lds	r19, 0x0536	; 0x800536 <timer0_fract>
    414c:	23 e0       	ldi	r18, 0x03	; 3
    414e:	23 0f       	add	r18, r19
    4150:	2d 37       	cpi	r18, 0x7D	; 125
    4152:	20 f4       	brcc	.+8      	; 0x415c <__vector_16+0x3a>
    4154:	01 96       	adiw	r24, 0x01	; 1
    4156:	a1 1d       	adc	r26, r1
    4158:	b1 1d       	adc	r27, r1
    415a:	05 c0       	rjmp	.+10     	; 0x4166 <__vector_16+0x44>
    415c:	26 e8       	ldi	r18, 0x86	; 134
    415e:	23 0f       	add	r18, r19
    4160:	02 96       	adiw	r24, 0x02	; 2
    4162:	a1 1d       	adc	r26, r1
    4164:	b1 1d       	adc	r27, r1
    4166:	20 93 36 05 	sts	0x0536, r18	; 0x800536 <timer0_fract>
    416a:	80 93 37 05 	sts	0x0537, r24	; 0x800537 <timer0_millis>
    416e:	90 93 38 05 	sts	0x0538, r25	; 0x800538 <timer0_millis+0x1>
    4172:	a0 93 39 05 	sts	0x0539, r26	; 0x800539 <timer0_millis+0x2>
    4176:	b0 93 3a 05 	sts	0x053A, r27	; 0x80053a <timer0_millis+0x3>
    417a:	80 91 3b 05 	lds	r24, 0x053B	; 0x80053b <timer0_overflow_count>
    417e:	90 91 3c 05 	lds	r25, 0x053C	; 0x80053c <timer0_overflow_count+0x1>
    4182:	a0 91 3d 05 	lds	r26, 0x053D	; 0x80053d <timer0_overflow_count+0x2>
    4186:	b0 91 3e 05 	lds	r27, 0x053E	; 0x80053e <timer0_overflow_count+0x3>
    418a:	01 96       	adiw	r24, 0x01	; 1
    418c:	a1 1d       	adc	r26, r1
    418e:	b1 1d       	adc	r27, r1
    4190:	80 93 3b 05 	sts	0x053B, r24	; 0x80053b <timer0_overflow_count>
    4194:	90 93 3c 05 	sts	0x053C, r25	; 0x80053c <timer0_overflow_count+0x1>
    4198:	a0 93 3d 05 	sts	0x053D, r26	; 0x80053d <timer0_overflow_count+0x2>
    419c:	b0 93 3e 05 	sts	0x053E, r27	; 0x80053e <timer0_overflow_count+0x3>
    41a0:	bf 91       	pop	r27
    41a2:	af 91       	pop	r26
    41a4:	9f 91       	pop	r25
    41a6:	8f 91       	pop	r24
    41a8:	3f 91       	pop	r19
    41aa:	2f 91       	pop	r18
    41ac:	0f 90       	pop	r0
    41ae:	0f be       	out	0x3f, r0	; 63
    41b0:	0f 90       	pop	r0
    41b2:	1f 90       	pop	r1
    41b4:	18 95       	reti

000041b6 <micros>:

unsigned long micros() {
	unsigned long m;
	uint8_t oldSREG = SREG, t;
    41b6:	3f b7       	in	r19, 0x3f	; 63
	
	cli();
    41b8:	f8 94       	cli
	m = timer0_overflow_count;
    41ba:	80 91 3b 05 	lds	r24, 0x053B	; 0x80053b <timer0_overflow_count>
    41be:	90 91 3c 05 	lds	r25, 0x053C	; 0x80053c <timer0_overflow_count+0x1>
    41c2:	a0 91 3d 05 	lds	r26, 0x053D	; 0x80053d <timer0_overflow_count+0x2>
    41c6:	b0 91 3e 05 	lds	r27, 0x053E	; 0x80053e <timer0_overflow_count+0x3>
#if defined(TCNT0)
	t = TCNT0;
    41ca:	26 b5       	in	r18, 0x26	; 38
#else
	#error TIMER 0 not defined
#endif

#ifdef TIFR0
	if ((TIFR0 & _BV(TOV0)) && (t < 255))
    41cc:	a8 9b       	sbis	0x15, 0	; 21
    41ce:	05 c0       	rjmp	.+10     	; 0x41da <micros+0x24>
    41d0:	2f 3f       	cpi	r18, 0xFF	; 255
    41d2:	19 f0       	breq	.+6      	; 0x41da <micros+0x24>
		m++;
    41d4:	01 96       	adiw	r24, 0x01	; 1
    41d6:	a1 1d       	adc	r26, r1
    41d8:	b1 1d       	adc	r27, r1
#else
	if ((TIFR & _BV(TOV0)) && (t < 255))
		m++;
#endif

	SREG = oldSREG;
    41da:	3f bf       	out	0x3f, r19	; 63
	
	return ((m << 8) + t) * (64 / clockCyclesPerMicrosecond());
    41dc:	ba 2f       	mov	r27, r26
    41de:	a9 2f       	mov	r26, r25
    41e0:	98 2f       	mov	r25, r24
    41e2:	88 27       	eor	r24, r24
    41e4:	82 0f       	add	r24, r18
    41e6:	91 1d       	adc	r25, r1
    41e8:	a1 1d       	adc	r26, r1
    41ea:	b1 1d       	adc	r27, r1
    41ec:	bc 01       	movw	r22, r24
    41ee:	cd 01       	movw	r24, r26
    41f0:	42 e0       	ldi	r20, 0x02	; 2
    41f2:	66 0f       	add	r22, r22
    41f4:	77 1f       	adc	r23, r23
    41f6:	88 1f       	adc	r24, r24
    41f8:	99 1f       	adc	r25, r25
    41fa:	4a 95       	dec	r20
    41fc:	d1 f7       	brne	.-12     	; 0x41f2 <micros+0x3c>
}
    41fe:	08 95       	ret

00004200 <delay>:

void delay(unsigned long ms)
{
    4200:	8f 92       	push	r8
    4202:	9f 92       	push	r9
    4204:	af 92       	push	r10
    4206:	bf 92       	push	r11
    4208:	cf 92       	push	r12
    420a:	df 92       	push	r13
    420c:	ef 92       	push	r14
    420e:	ff 92       	push	r15
    4210:	6b 01       	movw	r12, r22
    4212:	7c 01       	movw	r14, r24
	uint32_t start = micros();
    4214:	0e 94 db 20 	call	0x41b6	; 0x41b6 <micros>
    4218:	4b 01       	movw	r8, r22
    421a:	5c 01       	movw	r10, r24

	while (ms > 0) {
    421c:	c1 14       	cp	r12, r1
    421e:	d1 04       	cpc	r13, r1
    4220:	e1 04       	cpc	r14, r1
    4222:	f1 04       	cpc	r15, r1
    4224:	01 f1       	breq	.+64     	; 0x4266 <delay+0x66>
		yield();
    4226:	0e 94 a8 23 	call	0x4750	; 0x4750 <yield>
		while ( ms > 0 && (micros() - start) >= 1000) {
    422a:	0e 94 db 20 	call	0x41b6	; 0x41b6 <micros>
    422e:	dc 01       	movw	r26, r24
    4230:	cb 01       	movw	r24, r22
    4232:	88 19       	sub	r24, r8
    4234:	99 09       	sbc	r25, r9
    4236:	aa 09       	sbc	r26, r10
    4238:	bb 09       	sbc	r27, r11
    423a:	88 3e       	cpi	r24, 0xE8	; 232
    423c:	93 40       	sbci	r25, 0x03	; 3
    423e:	a1 05       	cpc	r26, r1
    4240:	b1 05       	cpc	r27, r1
    4242:	60 f3       	brcs	.-40     	; 0x421c <delay+0x1c>
			ms--;
    4244:	21 e0       	ldi	r18, 0x01	; 1
    4246:	c2 1a       	sub	r12, r18
    4248:	d1 08       	sbc	r13, r1
    424a:	e1 08       	sbc	r14, r1
    424c:	f1 08       	sbc	r15, r1
			start += 1000;
    424e:	88 ee       	ldi	r24, 0xE8	; 232
    4250:	88 0e       	add	r8, r24
    4252:	83 e0       	ldi	r24, 0x03	; 3
    4254:	98 1e       	adc	r9, r24
    4256:	a1 1c       	adc	r10, r1
    4258:	b1 1c       	adc	r11, r1
{
	uint32_t start = micros();

	while (ms > 0) {
		yield();
		while ( ms > 0 && (micros() - start) >= 1000) {
    425a:	c1 14       	cp	r12, r1
    425c:	d1 04       	cpc	r13, r1
    425e:	e1 04       	cpc	r14, r1
    4260:	f1 04       	cpc	r15, r1
    4262:	19 f7       	brne	.-58     	; 0x422a <delay+0x2a>
    4264:	db cf       	rjmp	.-74     	; 0x421c <delay+0x1c>
			ms--;
			start += 1000;
		}
	}
}
    4266:	ff 90       	pop	r15
    4268:	ef 90       	pop	r14
    426a:	df 90       	pop	r13
    426c:	cf 90       	pop	r12
    426e:	bf 90       	pop	r11
    4270:	af 90       	pop	r10
    4272:	9f 90       	pop	r9
    4274:	8f 90       	pop	r8
    4276:	08 95       	ret

00004278 <delayMicroseconds>:
#elif F_CPU >= 16000000L
	// for the 16 MHz clock on most Arduino boards

	// for a one-microsecond delay, simply return.  the overhead
	// of the function call takes 14 (16) cycles, which is 1us
	if (us <= 1) return; //  = 3 cycles, (4 when true)
    4278:	82 30       	cpi	r24, 0x02	; 2
    427a:	91 05       	cpc	r25, r1
    427c:	38 f0       	brcs	.+14     	; 0x428c <delayMicroseconds+0x14>

	// the following loop takes 1/4 of a microsecond (4 cycles)
	// per iteration, so execute it four times for each microsecond of
	// delay requested.
	us <<= 2; // x4 us, = 4 cycles
    427e:	88 0f       	add	r24, r24
    4280:	99 1f       	adc	r25, r25
    4282:	88 0f       	add	r24, r24
    4284:	99 1f       	adc	r25, r25

	// account for the time taken in the preceeding commands.
	// we just burned 19 (21) cycles above, remove 5, (5*4=20)
	// us is at least 8 so we can substract 5
	us -= 5; // = 2 cycles,
    4286:	05 97       	sbiw	r24, 0x05	; 5
	

#endif

	// busy wait
	__asm__ __volatile__ (
    4288:	01 97       	sbiw	r24, 0x01	; 1
    428a:	f1 f7       	brne	.-4      	; 0x4288 <delayMicroseconds+0x10>
    428c:	08 95       	ret

0000428e <init>:

void init()
{
	// this needs to be called before setup() or some functions won't
	// work there
	sei();
    428e:	78 94       	sei
	
	// on the ATmega168, timer 0 is also used for fast hardware pwm
	// (using phase-correct PWM would mean that timer 0 overflowed half as often
	// resulting in different millis() behavior on the ATmega8 and ATmega168)
#if defined(TCCR0A) && defined(WGM01)
	sbi(TCCR0A, WGM01);
    4290:	84 b5       	in	r24, 0x24	; 36
    4292:	82 60       	ori	r24, 0x02	; 2
    4294:	84 bd       	out	0x24, r24	; 36
	sbi(TCCR0A, WGM00);
    4296:	84 b5       	in	r24, 0x24	; 36
    4298:	81 60       	ori	r24, 0x01	; 1
    429a:	84 bd       	out	0x24, r24	; 36
	// this combination is for the standard atmega8
	sbi(TCCR0, CS01);
	sbi(TCCR0, CS00);
#elif defined(TCCR0B) && defined(CS01) && defined(CS00)
	// this combination is for the standard 168/328/1280/2560
	sbi(TCCR0B, CS01);
    429c:	85 b5       	in	r24, 0x25	; 37
    429e:	82 60       	ori	r24, 0x02	; 2
    42a0:	85 bd       	out	0x25, r24	; 37
	sbi(TCCR0B, CS00);
    42a2:	85 b5       	in	r24, 0x25	; 37
    42a4:	81 60       	ori	r24, 0x01	; 1
    42a6:	85 bd       	out	0x25, r24	; 37

	// enable timer 0 overflow interrupt
#if defined(TIMSK) && defined(TOIE0)
	sbi(TIMSK, TOIE0);
#elif defined(TIMSK0) && defined(TOIE0)
	sbi(TIMSK0, TOIE0);
    42a8:	ee e6       	ldi	r30, 0x6E	; 110
    42aa:	f0 e0       	ldi	r31, 0x00	; 0
    42ac:	80 81       	ld	r24, Z
    42ae:	81 60       	ori	r24, 0x01	; 1
    42b0:	80 83       	st	Z, r24
	// this is better for motors as it ensures an even waveform
	// note, however, that fast pwm mode can achieve a frequency of up
	// 8 MHz (with a 16 MHz clock) at 50% duty cycle

#if defined(TCCR1B) && defined(CS11) && defined(CS10)
	TCCR1B = 0;
    42b2:	e1 e8       	ldi	r30, 0x81	; 129
    42b4:	f0 e0       	ldi	r31, 0x00	; 0
    42b6:	10 82       	st	Z, r1

	// set timer 1 prescale factor to 64
	sbi(TCCR1B, CS11);
    42b8:	80 81       	ld	r24, Z
    42ba:	82 60       	ori	r24, 0x02	; 2
    42bc:	80 83       	st	Z, r24
#if F_CPU >= 8000000L
	sbi(TCCR1B, CS10);
    42be:	80 81       	ld	r24, Z
    42c0:	81 60       	ori	r24, 0x01	; 1
    42c2:	80 83       	st	Z, r24
	sbi(TCCR1, CS10);
#endif
#endif
	// put timer 1 in 8-bit phase correct pwm mode
#if defined(TCCR1A) && defined(WGM10)
	sbi(TCCR1A, WGM10);
    42c4:	e0 e8       	ldi	r30, 0x80	; 128
    42c6:	f0 e0       	ldi	r31, 0x00	; 0
    42c8:	80 81       	ld	r24, Z
    42ca:	81 60       	ori	r24, 0x01	; 1
    42cc:	80 83       	st	Z, r24

	// set timer 2 prescale factor to 64
#if defined(TCCR2) && defined(CS22)
	sbi(TCCR2, CS22);
#elif defined(TCCR2B) && defined(CS22)
	sbi(TCCR2B, CS22);
    42ce:	e1 eb       	ldi	r30, 0xB1	; 177
    42d0:	f0 e0       	ldi	r31, 0x00	; 0
    42d2:	80 81       	ld	r24, Z
    42d4:	84 60       	ori	r24, 0x04	; 4
    42d6:	80 83       	st	Z, r24

	// configure timer 2 for phase correct pwm (8-bit)
#if defined(TCCR2) && defined(WGM20)
	sbi(TCCR2, WGM20);
#elif defined(TCCR2A) && defined(WGM20)
	sbi(TCCR2A, WGM20);
    42d8:	e0 eb       	ldi	r30, 0xB0	; 176
    42da:	f0 e0       	ldi	r31, 0x00	; 0
    42dc:	80 81       	ld	r24, Z
    42de:	81 60       	ori	r24, 0x01	; 1
    42e0:	80 83       	st	Z, r24
#endif

#if defined(ADCSRA)
	// set a2d prescaler so we are inside the desired 50-200 KHz range.
	#if F_CPU >= 16000000 // 16 MHz / 128 = 125 KHz
		sbi(ADCSRA, ADPS2);
    42e2:	ea e7       	ldi	r30, 0x7A	; 122
    42e4:	f0 e0       	ldi	r31, 0x00	; 0
    42e6:	80 81       	ld	r24, Z
    42e8:	84 60       	ori	r24, 0x04	; 4
    42ea:	80 83       	st	Z, r24
		sbi(ADCSRA, ADPS1);
    42ec:	80 81       	ld	r24, Z
    42ee:	82 60       	ori	r24, 0x02	; 2
    42f0:	80 83       	st	Z, r24
		sbi(ADCSRA, ADPS0);
    42f2:	80 81       	ld	r24, Z
    42f4:	81 60       	ori	r24, 0x01	; 1
    42f6:	80 83       	st	Z, r24
		cbi(ADCSRA, ADPS2);
		cbi(ADCSRA, ADPS1);
		sbi(ADCSRA, ADPS0);
	#endif
	// enable a2d conversions
	sbi(ADCSRA, ADEN);
    42f8:	80 81       	ld	r24, Z
    42fa:	80 68       	ori	r24, 0x80	; 128
    42fc:	80 83       	st	Z, r24
	// here so they can be used as normal digital i/o; they will be
	// reconnected in Serial.begin()
#if defined(UCSRB)
	UCSRB = 0;
#elif defined(UCSR0B)
	UCSR0B = 0;
    42fe:	10 92 c1 00 	sts	0x00C1, r1	; 0x8000c1 <__DATA_REGION_ORIGIN__+0x61>
    4302:	08 95       	ret

00004304 <analogRead>:
#elif defined(__AVR_ATmega32U4__)
	if (pin >= 18) pin -= 18; // allow for channel or pin numbers
#elif defined(__AVR_ATmega1284__) || defined(__AVR_ATmega1284P__) || defined(__AVR_ATmega644__) || defined(__AVR_ATmega644A__) || defined(__AVR_ATmega644P__) || defined(__AVR_ATmega644PA__)
	if (pin >= 24) pin -= 24; // allow for channel or pin numbers
#else
	if (pin >= 14) pin -= 14; // allow for channel or pin numbers
    4304:	8e 30       	cpi	r24, 0x0E	; 14
    4306:	08 f0       	brcs	.+2      	; 0x430a <analogRead+0x6>
    4308:	8e 50       	subi	r24, 0x0E	; 14
	// to 0 (the default).
#if defined(ADMUX)
#if defined(__AVR_ATtiny25__) || defined(__AVR_ATtiny45__) || defined(__AVR_ATtiny85__)
	ADMUX = (analog_reference << 4) | (pin & 0x07);
#else
	ADMUX = (analog_reference << 6) | (pin & 0x07);
    430a:	20 91 41 01 	lds	r18, 0x0141	; 0x800141 <analog_reference>
    430e:	90 e4       	ldi	r25, 0x40	; 64
    4310:	29 9f       	mul	r18, r25
    4312:	90 01       	movw	r18, r0
    4314:	11 24       	eor	r1, r1
    4316:	87 70       	andi	r24, 0x07	; 7
    4318:	82 2b       	or	r24, r18
    431a:	80 93 7c 00 	sts	0x007C, r24	; 0x80007c <__DATA_REGION_ORIGIN__+0x1c>
	// without a delay, we seem to read from the wrong channel
	//delay(1);

#if defined(ADCSRA) && defined(ADCL)
	// start the conversion
	sbi(ADCSRA, ADSC);
    431e:	80 91 7a 00 	lds	r24, 0x007A	; 0x80007a <__DATA_REGION_ORIGIN__+0x1a>
    4322:	80 64       	ori	r24, 0x40	; 64
    4324:	80 93 7a 00 	sts	0x007A, r24	; 0x80007a <__DATA_REGION_ORIGIN__+0x1a>

	// ADSC is cleared when the conversion finishes
	while (bit_is_set(ADCSRA, ADSC));
    4328:	80 91 7a 00 	lds	r24, 0x007A	; 0x80007a <__DATA_REGION_ORIGIN__+0x1a>
    432c:	86 fd       	sbrc	r24, 6
    432e:	fc cf       	rjmp	.-8      	; 0x4328 <analogRead+0x24>

	// we have to read ADCL first; doing so locks both ADCL
	// and ADCH until ADCH is read.  reading ADCL second would
	// cause the results of each conversion to be discarded,
	// as ADCL and ADCH would be locked when it completed.
	low  = ADCL;
    4330:	80 91 78 00 	lds	r24, 0x0078	; 0x800078 <__DATA_REGION_ORIGIN__+0x18>
	high = ADCH;
    4334:	20 91 79 00 	lds	r18, 0x0079	; 0x800079 <__DATA_REGION_ORIGIN__+0x19>
	low  = 0;
	high = 0;
#endif

	// combine the two bytes
	return (high << 8) | low;
    4338:	90 e0       	ldi	r25, 0x00	; 0
}
    433a:	92 2b       	or	r25, r18
    433c:	08 95       	ret

0000433e <analogWrite>:
// Right now, PWM output only works on the pins with
// hardware support.  These are defined in the appropriate
// pins_*.c file.  For the rest of the pins, we default
// to digital output.
void analogWrite(uint8_t pin, int val)
{
    433e:	1f 93       	push	r17
    4340:	cf 93       	push	r28
    4342:	df 93       	push	r29
    4344:	18 2f       	mov	r17, r24
    4346:	eb 01       	movw	r28, r22
	// We need to make sure the PWM output is enabled for those pins
	// that support it, as we turn it off when digitally reading or
	// writing with them.  Also, make sure the pin is in output mode
	// for consistenty with Wiring, which doesn't require a pinMode
	// call for the analog output pins.
	pinMode(pin, OUTPUT);
    4348:	61 e0       	ldi	r22, 0x01	; 1
    434a:	0e 94 27 22 	call	0x444e	; 0x444e <pinMode>
	if (val == 0)
    434e:	20 97       	sbiw	r28, 0x00	; 0
    4350:	11 f4       	brne	.+4      	; 0x4356 <analogWrite+0x18>
	{
		digitalWrite(pin, LOW);
    4352:	60 e0       	ldi	r22, 0x00	; 0
    4354:	04 c0       	rjmp	.+8      	; 0x435e <analogWrite+0x20>
	}
	else if (val == 255)
    4356:	cf 3f       	cpi	r28, 0xFF	; 255
    4358:	d1 05       	cpc	r29, r1
    435a:	39 f4       	brne	.+14     	; 0x436a <analogWrite+0x2c>
	{
		digitalWrite(pin, HIGH);
    435c:	61 e0       	ldi	r22, 0x01	; 1
    435e:	81 2f       	mov	r24, r17
				} else {
					digitalWrite(pin, HIGH);
				}
		}
	}
}
    4360:	df 91       	pop	r29
    4362:	cf 91       	pop	r28
    4364:	1f 91       	pop	r17
	{
		digitalWrite(pin, LOW);
	}
	else if (val == 255)
	{
		digitalWrite(pin, HIGH);
    4366:	0c 94 63 22 	jmp	0x44c6	; 0x44c6 <digitalWrite>
	}
	else
	{
		switch(digitalPinToTimer(pin))
    436a:	e1 2f       	mov	r30, r17
    436c:	f0 e0       	ldi	r31, 0x00	; 0
    436e:	ee 54       	subi	r30, 0x4E	; 78
    4370:	ff 4f       	sbci	r31, 0xFF	; 255
    4372:	e4 91       	lpm	r30, Z
    4374:	e3 30       	cpi	r30, 0x03	; 3
    4376:	f9 f0       	breq	.+62     	; 0x43b6 <analogWrite+0x78>
    4378:	48 f4       	brcc	.+18     	; 0x438c <analogWrite+0x4e>
    437a:	e1 30       	cpi	r30, 0x01	; 1
    437c:	b9 f0       	breq	.+46     	; 0x43ac <analogWrite+0x6e>
    437e:	e2 30       	cpi	r30, 0x02	; 2
    4380:	a1 f5       	brne	.+104    	; 0x43ea <analogWrite+0xac>
			#endif

			#if defined(TCCR0A) && defined(COM0B1)
			case TIMER0B:
				// connect pwm to pin on timer 0, channel B
				sbi(TCCR0A, COM0B1);
    4382:	84 b5       	in	r24, 0x24	; 36
    4384:	80 62       	ori	r24, 0x20	; 32
    4386:	84 bd       	out	0x24, r24	; 36
				OCR0B = val; // set pwm duty
    4388:	c8 bd       	out	0x28, r28	; 40
				break;
    438a:	34 c0       	rjmp	.+104    	; 0x43f4 <analogWrite+0xb6>
	{
		digitalWrite(pin, HIGH);
	}
	else
	{
		switch(digitalPinToTimer(pin))
    438c:	e7 30       	cpi	r30, 0x07	; 7
    438e:	e9 f0       	breq	.+58     	; 0x43ca <analogWrite+0x8c>
    4390:	e8 30       	cpi	r30, 0x08	; 8
    4392:	19 f1       	breq	.+70     	; 0x43da <analogWrite+0x9c>
    4394:	e4 30       	cpi	r30, 0x04	; 4
    4396:	49 f5       	brne	.+82     	; 0x43ea <analogWrite+0xac>
			#endif

			#if defined(TCCR1A) && defined(COM1B1)
			case TIMER1B:
				// connect pwm to pin on timer 1, channel B
				sbi(TCCR1A, COM1B1);
    4398:	80 91 80 00 	lds	r24, 0x0080	; 0x800080 <__DATA_REGION_ORIGIN__+0x20>
    439c:	80 62       	ori	r24, 0x20	; 32
    439e:	80 93 80 00 	sts	0x0080, r24	; 0x800080 <__DATA_REGION_ORIGIN__+0x20>
				OCR1B = val; // set pwm duty
    43a2:	d0 93 8b 00 	sts	0x008B, r29	; 0x80008b <__DATA_REGION_ORIGIN__+0x2b>
    43a6:	c0 93 8a 00 	sts	0x008A, r28	; 0x80008a <__DATA_REGION_ORIGIN__+0x2a>
				break;
    43aa:	24 c0       	rjmp	.+72     	; 0x43f4 <analogWrite+0xb6>
			#endif

			#if defined(TCCR0A) && defined(COM0A1)
			case TIMER0A:
				// connect pwm to pin on timer 0, channel A
				sbi(TCCR0A, COM0A1);
    43ac:	84 b5       	in	r24, 0x24	; 36
    43ae:	80 68       	ori	r24, 0x80	; 128
    43b0:	84 bd       	out	0x24, r24	; 36
				OCR0A = val; // set pwm duty
    43b2:	c7 bd       	out	0x27, r28	; 39
				break;
    43b4:	1f c0       	rjmp	.+62     	; 0x43f4 <analogWrite+0xb6>
			#endif

			#if defined(TCCR1A) && defined(COM1A1)
			case TIMER1A:
				// connect pwm to pin on timer 1, channel A
				sbi(TCCR1A, COM1A1);
    43b6:	80 91 80 00 	lds	r24, 0x0080	; 0x800080 <__DATA_REGION_ORIGIN__+0x20>
    43ba:	80 68       	ori	r24, 0x80	; 128
    43bc:	80 93 80 00 	sts	0x0080, r24	; 0x800080 <__DATA_REGION_ORIGIN__+0x20>
				OCR1A = val; // set pwm duty
    43c0:	d0 93 89 00 	sts	0x0089, r29	; 0x800089 <__DATA_REGION_ORIGIN__+0x29>
    43c4:	c0 93 88 00 	sts	0x0088, r28	; 0x800088 <__DATA_REGION_ORIGIN__+0x28>
				break;
    43c8:	15 c0       	rjmp	.+42     	; 0x43f4 <analogWrite+0xb6>
			#endif

			#if defined(TCCR2A) && defined(COM2A1)
			case TIMER2A:
				// connect pwm to pin on timer 2, channel A
				sbi(TCCR2A, COM2A1);
    43ca:	80 91 b0 00 	lds	r24, 0x00B0	; 0x8000b0 <__DATA_REGION_ORIGIN__+0x50>
    43ce:	80 68       	ori	r24, 0x80	; 128
    43d0:	80 93 b0 00 	sts	0x00B0, r24	; 0x8000b0 <__DATA_REGION_ORIGIN__+0x50>
				OCR2A = val; // set pwm duty
    43d4:	c0 93 b3 00 	sts	0x00B3, r28	; 0x8000b3 <__DATA_REGION_ORIGIN__+0x53>
				break;
    43d8:	0d c0       	rjmp	.+26     	; 0x43f4 <analogWrite+0xb6>
			#endif

			#if defined(TCCR2A) && defined(COM2B1)
			case TIMER2B:
				// connect pwm to pin on timer 2, channel B
				sbi(TCCR2A, COM2B1);
    43da:	80 91 b0 00 	lds	r24, 0x00B0	; 0x8000b0 <__DATA_REGION_ORIGIN__+0x50>
    43de:	80 62       	ori	r24, 0x20	; 32
    43e0:	80 93 b0 00 	sts	0x00B0, r24	; 0x8000b0 <__DATA_REGION_ORIGIN__+0x50>
				OCR2B = val; // set pwm duty
    43e4:	c0 93 b4 00 	sts	0x00B4, r28	; 0x8000b4 <__DATA_REGION_ORIGIN__+0x54>
				break;
    43e8:	05 c0       	rjmp	.+10     	; 0x43f4 <analogWrite+0xb6>
				break;
			#endif

			case NOT_ON_TIMER:
			default:
				if (val < 128) {
    43ea:	c0 38       	cpi	r28, 0x80	; 128
    43ec:	d1 05       	cpc	r29, r1
    43ee:	0c f0       	brlt	.+2      	; 0x43f2 <analogWrite+0xb4>
    43f0:	b5 cf       	rjmp	.-150    	; 0x435c <analogWrite+0x1e>
    43f2:	af cf       	rjmp	.-162    	; 0x4352 <analogWrite+0x14>
				} else {
					digitalWrite(pin, HIGH);
				}
		}
	}
}
    43f4:	df 91       	pop	r29
    43f6:	cf 91       	pop	r28
    43f8:	1f 91       	pop	r17
    43fa:	08 95       	ret

000043fc <turnOffPWM>:
//
//static inline void turnOffPWM(uint8_t timer) __attribute__ ((always_inline));
//static inline void turnOffPWM(uint8_t timer)
static void turnOffPWM(uint8_t timer)
{
	switch (timer)
    43fc:	83 30       	cpi	r24, 0x03	; 3
    43fe:	81 f0       	breq	.+32     	; 0x4420 <turnOffPWM+0x24>
    4400:	28 f4       	brcc	.+10     	; 0x440c <turnOffPWM+0x10>
    4402:	81 30       	cpi	r24, 0x01	; 1
    4404:	99 f0       	breq	.+38     	; 0x442c <turnOffPWM+0x30>
    4406:	82 30       	cpi	r24, 0x02	; 2
    4408:	a1 f0       	breq	.+40     	; 0x4432 <turnOffPWM+0x36>
    440a:	08 95       	ret
    440c:	87 30       	cpi	r24, 0x07	; 7
    440e:	a9 f0       	breq	.+42     	; 0x443a <turnOffPWM+0x3e>
    4410:	88 30       	cpi	r24, 0x08	; 8
    4412:	b9 f0       	breq	.+46     	; 0x4442 <turnOffPWM+0x46>
    4414:	84 30       	cpi	r24, 0x04	; 4
    4416:	d1 f4       	brne	.+52     	; 0x444c <turnOffPWM+0x50>
	{
		#if defined(TCCR1A) && defined(COM1A1)
		case TIMER1A:   cbi(TCCR1A, COM1A1);    break;
		#endif
		#if defined(TCCR1A) && defined(COM1B1)
		case TIMER1B:   cbi(TCCR1A, COM1B1);    break;
    4418:	80 91 80 00 	lds	r24, 0x0080	; 0x800080 <__DATA_REGION_ORIGIN__+0x20>
    441c:	8f 7d       	andi	r24, 0xDF	; 223
    441e:	03 c0       	rjmp	.+6      	; 0x4426 <turnOffPWM+0x2a>
static void turnOffPWM(uint8_t timer)
{
	switch (timer)
	{
		#if defined(TCCR1A) && defined(COM1A1)
		case TIMER1A:   cbi(TCCR1A, COM1A1);    break;
    4420:	80 91 80 00 	lds	r24, 0x0080	; 0x800080 <__DATA_REGION_ORIGIN__+0x20>
    4424:	8f 77       	andi	r24, 0x7F	; 127
		#endif
		#if defined(TCCR1A) && defined(COM1B1)
		case TIMER1B:   cbi(TCCR1A, COM1B1);    break;
    4426:	80 93 80 00 	sts	0x0080, r24	; 0x800080 <__DATA_REGION_ORIGIN__+0x20>
    442a:	08 95       	ret
		#if defined(TCCR2) && defined(COM21)
		case  TIMER2:   cbi(TCCR2, COM21);      break;
		#endif
		
		#if defined(TCCR0A) && defined(COM0A1)
		case  TIMER0A:  cbi(TCCR0A, COM0A1);    break;
    442c:	84 b5       	in	r24, 0x24	; 36
    442e:	8f 77       	andi	r24, 0x7F	; 127
    4430:	02 c0       	rjmp	.+4      	; 0x4436 <turnOffPWM+0x3a>
		#endif
		
		#if defined(TCCR0A) && defined(COM0B1)
		case  TIMER0B:  cbi(TCCR0A, COM0B1);    break;
    4432:	84 b5       	in	r24, 0x24	; 36
    4434:	8f 7d       	andi	r24, 0xDF	; 223
    4436:	84 bd       	out	0x24, r24	; 36
    4438:	08 95       	ret
		#endif
		#if defined(TCCR2A) && defined(COM2A1)
		case  TIMER2A:  cbi(TCCR2A, COM2A1);    break;
    443a:	80 91 b0 00 	lds	r24, 0x00B0	; 0x8000b0 <__DATA_REGION_ORIGIN__+0x50>
    443e:	8f 77       	andi	r24, 0x7F	; 127
    4440:	03 c0       	rjmp	.+6      	; 0x4448 <turnOffPWM+0x4c>
		#endif
		#if defined(TCCR2A) && defined(COM2B1)
		case  TIMER2B:  cbi(TCCR2A, COM2B1);    break;
    4442:	80 91 b0 00 	lds	r24, 0x00B0	; 0x8000b0 <__DATA_REGION_ORIGIN__+0x50>
    4446:	8f 7d       	andi	r24, 0xDF	; 223
    4448:	80 93 b0 00 	sts	0x00B0, r24	; 0x8000b0 <__DATA_REGION_ORIGIN__+0x50>
    444c:	08 95       	ret

0000444e <pinMode>:
#define ARDUINO_MAIN
#include "wiring_private.h"
#include "pins_arduino.h"

void pinMode(uint8_t pin, uint8_t mode)
{
    444e:	cf 93       	push	r28
    4450:	df 93       	push	r29
	uint8_t bit = digitalPinToBitMask(pin);
    4452:	90 e0       	ldi	r25, 0x00	; 0
    4454:	fc 01       	movw	r30, r24
    4456:	ea 53       	subi	r30, 0x3A	; 58
    4458:	ff 4f       	sbci	r31, 0xFF	; 255
    445a:	24 91       	lpm	r18, Z
	uint8_t port = digitalPinToPort(pin);
    445c:	fc 01       	movw	r30, r24
    445e:	e6 52       	subi	r30, 0x26	; 38
    4460:	ff 4f       	sbci	r31, 0xFF	; 255
    4462:	84 91       	lpm	r24, Z
	volatile uint8_t *reg, *out;

	if (port == NOT_A_PIN) return;
    4464:	88 23       	and	r24, r24
    4466:	61 f1       	breq	.+88     	; 0x44c0 <pinMode+0x72>

	// JWS: can I let the optimizer do this?
	reg = portModeRegister(port);
    4468:	90 e0       	ldi	r25, 0x00	; 0
    446a:	88 0f       	add	r24, r24
    446c:	99 1f       	adc	r25, r25
    446e:	fc 01       	movw	r30, r24
    4470:	ee 5f       	subi	r30, 0xFE	; 254
    4472:	fe 4f       	sbci	r31, 0xFE	; 254
    4474:	c5 91       	lpm	r28, Z+
    4476:	d4 91       	lpm	r29, Z
	out = portOutputRegister(port);
    4478:	fc 01       	movw	r30, r24
    447a:	e8 50       	subi	r30, 0x08	; 8
    447c:	ff 4f       	sbci	r31, 0xFF	; 255
    447e:	a5 91       	lpm	r26, Z+
    4480:	b4 91       	lpm	r27, Z

	if (mode == INPUT) { 
    4482:	61 11       	cpse	r22, r1
    4484:	09 c0       	rjmp	.+18     	; 0x4498 <pinMode+0x4a>
		uint8_t oldSREG = SREG;
    4486:	9f b7       	in	r25, 0x3f	; 63
                cli();
    4488:	f8 94       	cli
		*reg &= ~bit;
    448a:	88 81       	ld	r24, Y
    448c:	20 95       	com	r18
    448e:	82 23       	and	r24, r18
    4490:	88 83       	st	Y, r24
		*out &= ~bit;
    4492:	ec 91       	ld	r30, X
    4494:	2e 23       	and	r18, r30
    4496:	0b c0       	rjmp	.+22     	; 0x44ae <pinMode+0x60>
		SREG = oldSREG;
	} else if (mode == INPUT_PULLUP) {
    4498:	62 30       	cpi	r22, 0x02	; 2
    449a:	61 f4       	brne	.+24     	; 0x44b4 <pinMode+0x66>
		uint8_t oldSREG = SREG;
    449c:	9f b7       	in	r25, 0x3f	; 63
                cli();
    449e:	f8 94       	cli
		*reg &= ~bit;
    44a0:	88 81       	ld	r24, Y
    44a2:	32 2f       	mov	r19, r18
    44a4:	30 95       	com	r19
    44a6:	83 23       	and	r24, r19
    44a8:	88 83       	st	Y, r24
		*out |= bit;
    44aa:	ec 91       	ld	r30, X
    44ac:	2e 2b       	or	r18, r30
    44ae:	2c 93       	st	X, r18
		SREG = oldSREG;
    44b0:	9f bf       	out	0x3f, r25	; 63
    44b2:	06 c0       	rjmp	.+12     	; 0x44c0 <pinMode+0x72>
	} else {
		uint8_t oldSREG = SREG;
    44b4:	8f b7       	in	r24, 0x3f	; 63
                cli();
    44b6:	f8 94       	cli
		*reg |= bit;
    44b8:	e8 81       	ld	r30, Y
    44ba:	2e 2b       	or	r18, r30
    44bc:	28 83       	st	Y, r18
		SREG = oldSREG;
    44be:	8f bf       	out	0x3f, r24	; 63
	}
}
    44c0:	df 91       	pop	r29
    44c2:	cf 91       	pop	r28
    44c4:	08 95       	ret

000044c6 <digitalWrite>:
		#endif
	}
}

void digitalWrite(uint8_t pin, uint8_t val)
{
    44c6:	1f 93       	push	r17
    44c8:	cf 93       	push	r28
    44ca:	df 93       	push	r29
	uint8_t timer = digitalPinToTimer(pin);
    44cc:	28 2f       	mov	r18, r24
    44ce:	30 e0       	ldi	r19, 0x00	; 0
    44d0:	f9 01       	movw	r30, r18
    44d2:	ee 54       	subi	r30, 0x4E	; 78
    44d4:	ff 4f       	sbci	r31, 0xFF	; 255
    44d6:	84 91       	lpm	r24, Z
	uint8_t bit = digitalPinToBitMask(pin);
    44d8:	f9 01       	movw	r30, r18
    44da:	ea 53       	subi	r30, 0x3A	; 58
    44dc:	ff 4f       	sbci	r31, 0xFF	; 255
    44de:	d4 91       	lpm	r29, Z
	uint8_t port = digitalPinToPort(pin);
    44e0:	f9 01       	movw	r30, r18
    44e2:	e6 52       	subi	r30, 0x26	; 38
    44e4:	ff 4f       	sbci	r31, 0xFF	; 255
    44e6:	c4 91       	lpm	r28, Z
	volatile uint8_t *out;

	if (port == NOT_A_PIN) return;
    44e8:	cc 23       	and	r28, r28
    44ea:	c1 f0       	breq	.+48     	; 0x451c <digitalWrite+0x56>
    44ec:	16 2f       	mov	r17, r22

	// If the pin that support PWM output, we need to turn it off
	// before doing a digital write.
	if (timer != NOT_ON_TIMER) turnOffPWM(timer);
    44ee:	81 11       	cpse	r24, r1
    44f0:	0e 94 fe 21 	call	0x43fc	; 0x43fc <turnOffPWM>

	out = portOutputRegister(port);
    44f4:	ec 2f       	mov	r30, r28
    44f6:	f0 e0       	ldi	r31, 0x00	; 0
    44f8:	ee 0f       	add	r30, r30
    44fa:	ff 1f       	adc	r31, r31
    44fc:	e8 50       	subi	r30, 0x08	; 8
    44fe:	ff 4f       	sbci	r31, 0xFF	; 255
    4500:	a5 91       	lpm	r26, Z+
    4502:	b4 91       	lpm	r27, Z

	uint8_t oldSREG = SREG;
    4504:	9f b7       	in	r25, 0x3f	; 63
	cli();
    4506:	f8 94       	cli

	if (val == LOW) {
    4508:	11 11       	cpse	r17, r1
    450a:	04 c0       	rjmp	.+8      	; 0x4514 <digitalWrite+0x4e>
		*out &= ~bit;
    450c:	8c 91       	ld	r24, X
    450e:	d0 95       	com	r29
    4510:	d8 23       	and	r29, r24
    4512:	02 c0       	rjmp	.+4      	; 0x4518 <digitalWrite+0x52>
	} else {
		*out |= bit;
    4514:	ec 91       	ld	r30, X
    4516:	de 2b       	or	r29, r30
    4518:	dc 93       	st	X, r29
	}

	SREG = oldSREG;
    451a:	9f bf       	out	0x3f, r25	; 63
}
    451c:	df 91       	pop	r29
    451e:	cf 91       	pop	r28
    4520:	1f 91       	pop	r17
    4522:	08 95       	ret

00004524 <_ZN14FreqCountClass5beginEj>:
static uint16_t gate_index;


void FreqCountClass::begin(uint16_t msec)
{
	if (msec < 1) return;
    4524:	00 97       	sbiw	r24, 0x00	; 0
    4526:	09 f4       	brne	.+2      	; 0x452a <_ZN14FreqCountClass5beginEj+0x6>
    4528:	74 c0       	rjmp	.+232    	; 0x4612 <L_130_loop+0xc>
	gate_index = 0;
    452a:	10 92 40 05 	sts	0x0540, r1	; 0x800540 <_ZL10gate_index+0x1>
    452e:	10 92 3f 05 	sts	0x053F, r1	; 0x80053f <_ZL10gate_index>
	count_msw = 0;
    4532:	10 92 4d 05 	sts	0x054D, r1	; 0x80054d <_ZL9count_msw+0x1>
    4536:	10 92 4c 05 	sts	0x054C, r1	; 0x80054c <_ZL9count_msw>
	count_prev = 0;
    453a:	10 92 48 05 	sts	0x0548, r1	; 0x800548 <_ZL10count_prev>
    453e:	10 92 49 05 	sts	0x0549, r1	; 0x800549 <_ZL10count_prev+0x1>
    4542:	10 92 4a 05 	sts	0x054A, r1	; 0x80054a <_ZL10count_prev+0x2>
    4546:	10 92 4b 05 	sts	0x054B, r1	; 0x80054b <_ZL10count_prev+0x3>
	count_ready = 0;
    454a:	10 92 43 05 	sts	0x0543, r1	; 0x800543 <_ZL11count_ready>

static uint8_t saveTCCR1A, saveTCCR1B;

static inline void counter_init(void)
{
	saveTCCR1A = TCCR1A;
    454e:	20 91 80 00 	lds	r18, 0x0080	; 0x800080 <__DATA_REGION_ORIGIN__+0x20>
    4552:	20 93 52 05 	sts	0x0552, r18	; 0x800552 <_ZL10saveTCCR1A>
	saveTCCR1B = TCCR1B;
    4556:	20 91 81 00 	lds	r18, 0x0081	; 0x800081 <__DATA_REGION_ORIGIN__+0x21>
    455a:	20 93 51 05 	sts	0x0551, r18	; 0x800551 <_ZL10saveTCCR1B>
	TCCR1B = 0;
    455e:	10 92 81 00 	sts	0x0081, r1	; 0x800081 <__DATA_REGION_ORIGIN__+0x21>
	TCCR1A = 0;
    4562:	10 92 80 00 	sts	0x0080, r1	; 0x800080 <__DATA_REGION_ORIGIN__+0x20>
	TCNT1 = 0;
    4566:	10 92 85 00 	sts	0x0085, r1	; 0x800085 <__DATA_REGION_ORIGIN__+0x25>
    456a:	10 92 84 00 	sts	0x0084, r1	; 0x800084 <__DATA_REGION_ORIGIN__+0x24>
	TIFR1 = (1<<TOV1);
    456e:	21 e0       	ldi	r18, 0x01	; 1
    4570:	26 bb       	out	0x16, r18	; 22
	TIMSK1 = 0;
    4572:	10 92 6f 00 	sts	0x006F, r1	; 0x80006f <__DATA_REGION_ORIGIN__+0xf>

static inline uint16_t timer_init(uint16_t msec)
{
	uint16_t gate_len;

	saveTCCR2A = TCCR2A;
    4576:	20 91 b0 00 	lds	r18, 0x00B0	; 0x8000b0 <__DATA_REGION_ORIGIN__+0x50>
    457a:	20 93 50 05 	sts	0x0550, r18	; 0x800550 <_ZL10saveTCCR2A>
	saveTCCR2B = TCCR2B;
    457e:	20 91 b1 00 	lds	r18, 0x00B1	; 0x8000b1 <__DATA_REGION_ORIGIN__+0x51>
    4582:	20 93 4f 05 	sts	0x054F, r18	; 0x80054f <_ZL10saveTCCR2B>
	TCCR2B = 0;
    4586:	10 92 b1 00 	sts	0x00B1, r1	; 0x8000b1 <__DATA_REGION_ORIGIN__+0x51>
	TCCR2A = (1<<WGM21);
    458a:	22 e0       	ldi	r18, 0x02	; 2
    458c:	20 93 b0 00 	sts	0x00B0, r18	; 0x8000b0 <__DATA_REGION_ORIGIN__+0x50>
	if ((msec & 7) == 0) {
    4590:	9c 01       	movw	r18, r24
    4592:	27 70       	andi	r18, 0x07	; 7
    4594:	33 27       	eor	r19, r19
    4596:	23 2b       	or	r18, r19
    4598:	51 f4       	brne	.+20     	; 0x45ae <_ZN14FreqCountClass5beginEj+0x8a>
		gate_len = msec >> 3;
    459a:	43 e0       	ldi	r20, 0x03	; 3
    459c:	96 95       	lsr	r25
    459e:	87 95       	ror	r24
    45a0:	4a 95       	dec	r20
    45a2:	e1 f7       	brne	.-8      	; 0x459c <_ZN14FreqCountClass5beginEj+0x78>
		OCR2A = TIMER2_OCR2A_8MS_VAL;
    45a4:	2c e7       	ldi	r18, 0x7C	; 124
    45a6:	20 93 b3 00 	sts	0x00B3, r18	; 0x8000b3 <__DATA_REGION_ORIGIN__+0x53>
		startTCCR2B = TIMER2_TCCR2B_8MS_VAL;
    45aa:	27 e0       	ldi	r18, 0x07	; 7
    45ac:	18 c0       	rjmp	.+48     	; 0x45de <_ZN14FreqCountClass5beginEj+0xba>
	} else if ((msec & 3) == 0) {
    45ae:	9c 01       	movw	r18, r24
    45b0:	23 70       	andi	r18, 0x03	; 3
    45b2:	33 27       	eor	r19, r19
    45b4:	23 2b       	or	r18, r19
    45b6:	31 f4       	brne	.+12     	; 0x45c4 <_ZN14FreqCountClass5beginEj+0xa0>
		gate_len = msec >> 2;
    45b8:	96 95       	lsr	r25
    45ba:	87 95       	ror	r24
    45bc:	96 95       	lsr	r25
    45be:	87 95       	ror	r24
		OCR2A = TIMER2_OCR2A_4MS_VAL;
    45c0:	29 ef       	ldi	r18, 0xF9	; 249
    45c2:	05 c0       	rjmp	.+10     	; 0x45ce <_ZN14FreqCountClass5beginEj+0xaa>
		startTCCR2B = TIMER2_TCCR2B_4MS_VAL;
	} else if ((msec & 1) == 0) {
    45c4:	80 fd       	sbrc	r24, 0
    45c6:	07 c0       	rjmp	.+14     	; 0x45d6 <_ZN14FreqCountClass5beginEj+0xb2>
		gate_len = msec >> 1;
    45c8:	96 95       	lsr	r25
    45ca:	87 95       	ror	r24
		OCR2A = TIMER2_OCR2A_2MS_VAL;
    45cc:	2c e7       	ldi	r18, 0x7C	; 124
    45ce:	20 93 b3 00 	sts	0x00B3, r18	; 0x8000b3 <__DATA_REGION_ORIGIN__+0x53>
		startTCCR2B = TIMER2_TCCR2B_2MS_VAL;
    45d2:	26 e0       	ldi	r18, 0x06	; 6
    45d4:	04 c0       	rjmp	.+8      	; 0x45de <_ZN14FreqCountClass5beginEj+0xba>
	} else {
		gate_len = msec;
		OCR2A = TIMER2_OCR2A_1MS_VAL;
    45d6:	2c e7       	ldi	r18, 0x7C	; 124
    45d8:	20 93 b3 00 	sts	0x00B3, r18	; 0x8000b3 <__DATA_REGION_ORIGIN__+0x53>
		startTCCR2B = TIMER2_TCCR2B_1MS_VAL;
    45dc:	25 e0       	ldi	r18, 0x05	; 5
    45de:	20 93 4e 05 	sts	0x054E, r18	; 0x80054e <_ZL11startTCCR2B>
	}
	TIFR2 = (1<<OCF2A);
    45e2:	22 e0       	ldi	r18, 0x02	; 2
    45e4:	27 bb       	out	0x17, r18	; 23
	TCNT2 = 0;
    45e6:	10 92 b2 00 	sts	0x00B2, r1	; 0x8000b2 <__DATA_REGION_ORIGIN__+0x52>
	counter_init();
	gate_length = timer_init(msec);
    45ea:	90 93 42 05 	sts	0x0542, r25	; 0x800542 <_ZL11gate_length+0x1>
    45ee:	80 93 41 05 	sts	0x0541, r24	; 0x800541 <_ZL11gate_length>
	uint8_t status = SREG;
    45f2:	9f b7       	in	r25, 0x3f	; 63
	cli();
    45f4:	f8 94       	cli
	return gate_len;
}

static inline void timer_start(void)
{
	GTCCR = (1<<PSRASY);
    45f6:	23 bd       	out	0x23, r18	; 35
	TCCR2B = startTCCR2B;
    45f8:	80 91 4e 05 	lds	r24, 0x054E	; 0x80054e <_ZL11startTCCR2B>
    45fc:	80 93 b1 00 	sts	0x00B1, r24	; 0x8000b1 <__DATA_REGION_ORIGIN__+0x51>
	TIMSK2 = (1<<OCIE2A);
    4600:	20 93 70 00 	sts	0x0070, r18	; 0x800070 <__DATA_REGION_ORIGIN__+0x10>
		"L_%=_loop:"
		"subi   %0, 1"		"\n\t"
		"brne   L_%=_loop"	"\n\t"
		: "+d" (cycles_times_3)
		: "0" (cycles_times_3)
	);
    4604:	8b e0       	ldi	r24, 0x0B	; 11

00004606 <L_130_loop>:
    4606:	81 50       	subi	r24, 0x01	; 1
    4608:	f1 f7       	brne	.-4      	; 0x4606 <L_130_loop>
	TIMSK1 = 0;
}

static inline void counter_start(void)
{
	TCCR1B = (1<<CS12) | (1<<CS11) | (1<<CS10);
    460a:	87 e0       	ldi	r24, 0x07	; 7
    460c:	80 93 81 00 	sts	0x0081, r24	; 0x800081 <__DATA_REGION_ORIGIN__+0x21>
	timer_start();
	timer_isr_latency_delay();
	counter_start();
	SREG = status;
    4610:	9f bf       	out	0x3f, r25	; 63
    4612:	08 95       	ret

00004614 <_ZN14FreqCountClass9availableEv>:
}

uint8_t FreqCountClass::available(void)
{
	return count_ready;
    4614:	80 91 43 05 	lds	r24, 0x0543	; 0x800543 <_ZL11count_ready>
}
    4618:	08 95       	ret

0000461a <_ZN14FreqCountClass4readEv>:
uint32_t FreqCountClass::read(void)
{
	uint32_t count;
	uint8_t status;

	status = SREG;
    461a:	2f b7       	in	r18, 0x3f	; 63
	cli();
    461c:	f8 94       	cli
	count = count_output;
    461e:	60 91 44 05 	lds	r22, 0x0544	; 0x800544 <_ZL12count_output>
    4622:	70 91 45 05 	lds	r23, 0x0545	; 0x800545 <_ZL12count_output+0x1>
    4626:	80 91 46 05 	lds	r24, 0x0546	; 0x800546 <_ZL12count_output+0x2>
    462a:	90 91 47 05 	lds	r25, 0x0547	; 0x800547 <_ZL12count_output+0x3>
	count_ready = 0;
    462e:	10 92 43 05 	sts	0x0543, r1	; 0x800543 <_ZL11count_ready>
	SREG = status;
    4632:	2f bf       	out	0x3f, r18	; 63
	return count;
}
    4634:	08 95       	ret

00004636 <_ZN14FreqCountClass3endEv>:
	TIMSK2 = (1<<OCIE2A);
}

static inline void timer_shutdown(void)
{
	TCCR2B = 0;
    4636:	e1 eb       	ldi	r30, 0xB1	; 177
    4638:	f0 e0       	ldi	r31, 0x00	; 0
    463a:	10 82       	st	Z, r1
	TIMSK2 = 0;
    463c:	10 92 70 00 	sts	0x0070, r1	; 0x800070 <__DATA_REGION_ORIGIN__+0x10>
	TCCR2A = saveTCCR2A;
    4640:	80 91 50 05 	lds	r24, 0x0550	; 0x800550 <_ZL10saveTCCR2A>
    4644:	80 93 b0 00 	sts	0x00B0, r24	; 0x8000b0 <__DATA_REGION_ORIGIN__+0x50>
	TCCR2B = saveTCCR2B;
    4648:	80 91 4f 05 	lds	r24, 0x054F	; 0x80054f <_ZL10saveTCCR2B>
    464c:	80 83       	st	Z, r24
	TCCR1B = (1<<CS12) | (1<<CS11) | (1<<CS10);
}

static inline void counter_shutdown(void)
{
	TCCR1B = 0;
    464e:	e1 e8       	ldi	r30, 0x81	; 129
    4650:	f0 e0       	ldi	r31, 0x00	; 0
    4652:	10 82       	st	Z, r1
	TCCR1A = saveTCCR1A;
    4654:	80 91 52 05 	lds	r24, 0x0552	; 0x800552 <_ZL10saveTCCR1A>
    4658:	80 93 80 00 	sts	0x0080, r24	; 0x800080 <__DATA_REGION_ORIGIN__+0x20>
	TCCR1B = saveTCCR1B;
    465c:	80 91 51 05 	lds	r24, 0x0551	; 0x800551 <_ZL10saveTCCR1B>
    4660:	80 83       	st	Z, r24
    4662:	08 95       	ret

00004664 <__vector_7>:
	counter_shutdown();
}


ISR(TIMER_ISR_VECTOR)
{
    4664:	1f 92       	push	r1
    4666:	0f 92       	push	r0
    4668:	0f b6       	in	r0, 0x3f	; 63
    466a:	0f 92       	push	r0
    466c:	11 24       	eor	r1, r1
    466e:	0f 93       	push	r16
    4670:	1f 93       	push	r17
    4672:	2f 93       	push	r18
    4674:	3f 93       	push	r19
    4676:	4f 93       	push	r20
    4678:	5f 93       	push	r21
    467a:	6f 93       	push	r22
    467c:	7f 93       	push	r23
    467e:	8f 93       	push	r24
    4680:	9f 93       	push	r25
    4682:	af 93       	push	r26
    4684:	bf 93       	push	r27
}

static inline uint16_t counter_read(void)
{
	return TCNT1;
    4686:	20 91 84 00 	lds	r18, 0x0084	; 0x800084 <__DATA_REGION_ORIGIN__+0x24>
    468a:	30 91 85 00 	lds	r19, 0x0085	; 0x800085 <__DATA_REGION_ORIGIN__+0x25>
	uint16_t count_lsw;
	uint32_t count;
	uint16_t index, length;

	count_lsw = counter_read();
	if (counter_overflow()) {
    468e:	b0 9b       	sbis	0x16, 0	; 22
    4690:	0b c0       	rjmp	.+22     	; 0x46a8 <__vector_7+0x44>
	return TIFR1 & (1<<TOV1);
}

static inline void counter_overflow_reset(void)
{
	TIFR1 = (1<<TOV1);
    4692:	81 e0       	ldi	r24, 0x01	; 1
    4694:	86 bb       	out	0x16, r24	; 22
		counter_overflow_reset();
		count_msw++;
    4696:	80 91 4c 05 	lds	r24, 0x054C	; 0x80054c <_ZL9count_msw>
    469a:	90 91 4d 05 	lds	r25, 0x054D	; 0x80054d <_ZL9count_msw+0x1>
    469e:	01 96       	adiw	r24, 0x01	; 1
    46a0:	90 93 4d 05 	sts	0x054D, r25	; 0x80054d <_ZL9count_msw+0x1>
    46a4:	80 93 4c 05 	sts	0x054C, r24	; 0x80054c <_ZL9count_msw>
	}
	index = gate_index + 1;
    46a8:	80 91 3f 05 	lds	r24, 0x053F	; 0x80053f <_ZL10gate_index>
    46ac:	90 91 40 05 	lds	r25, 0x0540	; 0x800540 <_ZL10gate_index+0x1>
    46b0:	01 96       	adiw	r24, 0x01	; 1
	length = gate_length;
	if (index >= length) {
    46b2:	40 91 41 05 	lds	r20, 0x0541	; 0x800541 <_ZL11gate_length>
    46b6:	50 91 42 05 	lds	r21, 0x0542	; 0x800542 <_ZL11gate_length+0x1>
    46ba:	84 17       	cp	r24, r20
    46bc:	95 07       	cpc	r25, r21
    46be:	98 f1       	brcs	.+102    	; 0x4726 <__vector_7+0xc2>
		gate_index = 0;
    46c0:	10 92 40 05 	sts	0x0540, r1	; 0x800540 <_ZL10gate_index+0x1>
    46c4:	10 92 3f 05 	sts	0x053F, r1	; 0x80053f <_ZL10gate_index>
		count = ((uint32_t)count_msw << 16) + count_lsw;
    46c8:	80 91 4c 05 	lds	r24, 0x054C	; 0x80054c <_ZL9count_msw>
    46cc:	90 91 4d 05 	lds	r25, 0x054D	; 0x80054d <_ZL9count_msw+0x1>
    46d0:	a0 e0       	ldi	r26, 0x00	; 0
    46d2:	b0 e0       	ldi	r27, 0x00	; 0
    46d4:	dc 01       	movw	r26, r24
    46d6:	99 27       	eor	r25, r25
    46d8:	88 27       	eor	r24, r24
    46da:	82 0f       	add	r24, r18
    46dc:	93 1f       	adc	r25, r19
    46de:	a1 1d       	adc	r26, r1
    46e0:	b1 1d       	adc	r27, r1
		count_output = count - count_prev;
    46e2:	40 91 48 05 	lds	r20, 0x0548	; 0x800548 <_ZL10count_prev>
    46e6:	50 91 49 05 	lds	r21, 0x0549	; 0x800549 <_ZL10count_prev+0x1>
    46ea:	60 91 4a 05 	lds	r22, 0x054A	; 0x80054a <_ZL10count_prev+0x2>
    46ee:	70 91 4b 05 	lds	r23, 0x054B	; 0x80054b <_ZL10count_prev+0x3>
    46f2:	8c 01       	movw	r16, r24
    46f4:	9d 01       	movw	r18, r26
    46f6:	04 1b       	sub	r16, r20
    46f8:	15 0b       	sbc	r17, r21
    46fa:	26 0b       	sbc	r18, r22
    46fc:	37 0b       	sbc	r19, r23
    46fe:	00 93 44 05 	sts	0x0544, r16	; 0x800544 <_ZL12count_output>
    4702:	10 93 45 05 	sts	0x0545, r17	; 0x800545 <_ZL12count_output+0x1>
    4706:	20 93 46 05 	sts	0x0546, r18	; 0x800546 <_ZL12count_output+0x2>
    470a:	30 93 47 05 	sts	0x0547, r19	; 0x800547 <_ZL12count_output+0x3>
		count_prev = count;
    470e:	80 93 48 05 	sts	0x0548, r24	; 0x800548 <_ZL10count_prev>
    4712:	90 93 49 05 	sts	0x0549, r25	; 0x800549 <_ZL10count_prev+0x1>
    4716:	a0 93 4a 05 	sts	0x054A, r26	; 0x80054a <_ZL10count_prev+0x2>
    471a:	b0 93 4b 05 	sts	0x054B, r27	; 0x80054b <_ZL10count_prev+0x3>
		count_ready = 1;
    471e:	81 e0       	ldi	r24, 0x01	; 1
    4720:	80 93 43 05 	sts	0x0543, r24	; 0x800543 <_ZL11count_ready>
    4724:	04 c0       	rjmp	.+8      	; 0x472e <__vector_7+0xca>
		restore_other_interrupts();
	} else {
		if (index == length - 1) disable_other_interrupts();
		gate_index = index;
    4726:	90 93 40 05 	sts	0x0540, r25	; 0x800540 <_ZL10gate_index+0x1>
    472a:	80 93 3f 05 	sts	0x053F, r24	; 0x80053f <_ZL10gate_index>
	}
}
    472e:	bf 91       	pop	r27
    4730:	af 91       	pop	r26
    4732:	9f 91       	pop	r25
    4734:	8f 91       	pop	r24
    4736:	7f 91       	pop	r23
    4738:	6f 91       	pop	r22
    473a:	5f 91       	pop	r21
    473c:	4f 91       	pop	r20
    473e:	3f 91       	pop	r19
    4740:	2f 91       	pop	r18
    4742:	1f 91       	pop	r17
    4744:	0f 91       	pop	r16
    4746:	0f 90       	pop	r0
    4748:	0f be       	out	0x3f, r0	; 63
    474a:	0f 90       	pop	r0
    474c:	1f 90       	pop	r1
    474e:	18 95       	reti

00004750 <yield>:
 * libraries or sketches that supports cooperative threads.
 *
 * Its defined as a weak symbol and it can be redefined to implement a
 * real cooperative scheduler.
 */
static void __empty() {
    4750:	08 95       	ret

00004752 <__divmodhi4>:
    4752:	97 fb       	bst	r25, 7
    4754:	07 2e       	mov	r0, r23
    4756:	16 f4       	brtc	.+4      	; 0x475c <__divmodhi4+0xa>
    4758:	00 94       	com	r0
    475a:	07 d0       	rcall	.+14     	; 0x476a <__divmodhi4_neg1>
    475c:	77 fd       	sbrc	r23, 7
    475e:	09 d0       	rcall	.+18     	; 0x4772 <__divmodhi4_neg2>
    4760:	0e 94 0f 24 	call	0x481e	; 0x481e <__udivmodhi4>
    4764:	07 fc       	sbrc	r0, 7
    4766:	05 d0       	rcall	.+10     	; 0x4772 <__divmodhi4_neg2>
    4768:	3e f4       	brtc	.+14     	; 0x4778 <__divmodhi4_exit>

0000476a <__divmodhi4_neg1>:
    476a:	90 95       	com	r25
    476c:	81 95       	neg	r24
    476e:	9f 4f       	sbci	r25, 0xFF	; 255
    4770:	08 95       	ret

00004772 <__divmodhi4_neg2>:
    4772:	70 95       	com	r23
    4774:	61 95       	neg	r22
    4776:	7f 4f       	sbci	r23, 0xFF	; 255

00004778 <__divmodhi4_exit>:
    4778:	08 95       	ret

0000477a <__udivmodsi4>:
    477a:	a1 e2       	ldi	r26, 0x21	; 33
    477c:	1a 2e       	mov	r1, r26
    477e:	aa 1b       	sub	r26, r26
    4780:	bb 1b       	sub	r27, r27
    4782:	fd 01       	movw	r30, r26
    4784:	0d c0       	rjmp	.+26     	; 0x47a0 <__udivmodsi4_ep>

00004786 <__udivmodsi4_loop>:
    4786:	aa 1f       	adc	r26, r26
    4788:	bb 1f       	adc	r27, r27
    478a:	ee 1f       	adc	r30, r30
    478c:	ff 1f       	adc	r31, r31
    478e:	a2 17       	cp	r26, r18
    4790:	b3 07       	cpc	r27, r19
    4792:	e4 07       	cpc	r30, r20
    4794:	f5 07       	cpc	r31, r21
    4796:	20 f0       	brcs	.+8      	; 0x47a0 <__udivmodsi4_ep>
    4798:	a2 1b       	sub	r26, r18
    479a:	b3 0b       	sbc	r27, r19
    479c:	e4 0b       	sbc	r30, r20
    479e:	f5 0b       	sbc	r31, r21

000047a0 <__udivmodsi4_ep>:
    47a0:	66 1f       	adc	r22, r22
    47a2:	77 1f       	adc	r23, r23
    47a4:	88 1f       	adc	r24, r24
    47a6:	99 1f       	adc	r25, r25
    47a8:	1a 94       	dec	r1
    47aa:	69 f7       	brne	.-38     	; 0x4786 <__udivmodsi4_loop>
    47ac:	60 95       	com	r22
    47ae:	70 95       	com	r23
    47b0:	80 95       	com	r24
    47b2:	90 95       	com	r25
    47b4:	9b 01       	movw	r18, r22
    47b6:	ac 01       	movw	r20, r24
    47b8:	bd 01       	movw	r22, r26
    47ba:	cf 01       	movw	r24, r30
    47bc:	08 95       	ret

000047be <__divmodsi4>:
    47be:	05 2e       	mov	r0, r21
    47c0:	97 fb       	bst	r25, 7
    47c2:	1e f4       	brtc	.+6      	; 0x47ca <__divmodsi4+0xc>
    47c4:	00 94       	com	r0
    47c6:	0e 94 f6 23 	call	0x47ec	; 0x47ec <__negsi2>
    47ca:	57 fd       	sbrc	r21, 7
    47cc:	07 d0       	rcall	.+14     	; 0x47dc <__divmodsi4_neg2>
    47ce:	0e 94 bd 23 	call	0x477a	; 0x477a <__udivmodsi4>
    47d2:	07 fc       	sbrc	r0, 7
    47d4:	03 d0       	rcall	.+6      	; 0x47dc <__divmodsi4_neg2>
    47d6:	4e f4       	brtc	.+18     	; 0x47ea <__divmodsi4_exit>
    47d8:	0c 94 f6 23 	jmp	0x47ec	; 0x47ec <__negsi2>

000047dc <__divmodsi4_neg2>:
    47dc:	50 95       	com	r21
    47de:	40 95       	com	r20
    47e0:	30 95       	com	r19
    47e2:	21 95       	neg	r18
    47e4:	3f 4f       	sbci	r19, 0xFF	; 255
    47e6:	4f 4f       	sbci	r20, 0xFF	; 255
    47e8:	5f 4f       	sbci	r21, 0xFF	; 255

000047ea <__divmodsi4_exit>:
    47ea:	08 95       	ret

000047ec <__negsi2>:
    47ec:	90 95       	com	r25
    47ee:	80 95       	com	r24
    47f0:	70 95       	com	r23
    47f2:	61 95       	neg	r22
    47f4:	7f 4f       	sbci	r23, 0xFF	; 255
    47f6:	8f 4f       	sbci	r24, 0xFF	; 255
    47f8:	9f 4f       	sbci	r25, 0xFF	; 255
    47fa:	08 95       	ret

000047fc <__tablejump2__>:
    47fc:	ee 0f       	add	r30, r30
    47fe:	ff 1f       	adc	r31, r31
    4800:	05 90       	lpm	r0, Z+
    4802:	f4 91       	lpm	r31, Z
    4804:	e0 2d       	mov	r30, r0
    4806:	09 94       	ijmp

00004808 <__muluhisi3>:
    4808:	0e 94 23 24 	call	0x4846	; 0x4846 <__umulhisi3>
    480c:	a5 9f       	mul	r26, r21
    480e:	90 0d       	add	r25, r0
    4810:	b4 9f       	mul	r27, r20
    4812:	90 0d       	add	r25, r0
    4814:	a4 9f       	mul	r26, r20
    4816:	80 0d       	add	r24, r0
    4818:	91 1d       	adc	r25, r1
    481a:	11 24       	eor	r1, r1
    481c:	08 95       	ret

0000481e <__udivmodhi4>:
    481e:	aa 1b       	sub	r26, r26
    4820:	bb 1b       	sub	r27, r27
    4822:	51 e1       	ldi	r21, 0x11	; 17
    4824:	07 c0       	rjmp	.+14     	; 0x4834 <__udivmodhi4_ep>

00004826 <__udivmodhi4_loop>:
    4826:	aa 1f       	adc	r26, r26
    4828:	bb 1f       	adc	r27, r27
    482a:	a6 17       	cp	r26, r22
    482c:	b7 07       	cpc	r27, r23
    482e:	10 f0       	brcs	.+4      	; 0x4834 <__udivmodhi4_ep>
    4830:	a6 1b       	sub	r26, r22
    4832:	b7 0b       	sbc	r27, r23

00004834 <__udivmodhi4_ep>:
    4834:	88 1f       	adc	r24, r24
    4836:	99 1f       	adc	r25, r25
    4838:	5a 95       	dec	r21
    483a:	a9 f7       	brne	.-22     	; 0x4826 <__udivmodhi4_loop>
    483c:	80 95       	com	r24
    483e:	90 95       	com	r25
    4840:	bc 01       	movw	r22, r24
    4842:	cd 01       	movw	r24, r26
    4844:	08 95       	ret

00004846 <__umulhisi3>:
    4846:	a2 9f       	mul	r26, r18
    4848:	b0 01       	movw	r22, r0
    484a:	b3 9f       	mul	r27, r19
    484c:	c0 01       	movw	r24, r0
    484e:	a3 9f       	mul	r26, r19
    4850:	70 0d       	add	r23, r0
    4852:	81 1d       	adc	r24, r1
    4854:	11 24       	eor	r1, r1
    4856:	91 1d       	adc	r25, r1
    4858:	b2 9f       	mul	r27, r18
    485a:	70 0d       	add	r23, r0
    485c:	81 1d       	adc	r24, r1
    485e:	11 24       	eor	r1, r1
    4860:	91 1d       	adc	r25, r1
    4862:	08 95       	ret

00004864 <malloc>:
    4864:	0f 93       	push	r16
    4866:	1f 93       	push	r17
    4868:	cf 93       	push	r28
    486a:	df 93       	push	r29
    486c:	82 30       	cpi	r24, 0x02	; 2
    486e:	91 05       	cpc	r25, r1
    4870:	10 f4       	brcc	.+4      	; 0x4876 <malloc+0x12>
    4872:	82 e0       	ldi	r24, 0x02	; 2
    4874:	90 e0       	ldi	r25, 0x00	; 0
    4876:	e0 91 55 05 	lds	r30, 0x0555	; 0x800555 <__flp>
    487a:	f0 91 56 05 	lds	r31, 0x0556	; 0x800556 <__flp+0x1>
    487e:	20 e0       	ldi	r18, 0x00	; 0
    4880:	30 e0       	ldi	r19, 0x00	; 0
    4882:	a0 e0       	ldi	r26, 0x00	; 0
    4884:	b0 e0       	ldi	r27, 0x00	; 0
    4886:	30 97       	sbiw	r30, 0x00	; 0
    4888:	19 f1       	breq	.+70     	; 0x48d0 <malloc+0x6c>
    488a:	40 81       	ld	r20, Z
    488c:	51 81       	ldd	r21, Z+1	; 0x01
    488e:	02 81       	ldd	r16, Z+2	; 0x02
    4890:	13 81       	ldd	r17, Z+3	; 0x03
    4892:	48 17       	cp	r20, r24
    4894:	59 07       	cpc	r21, r25
    4896:	c8 f0       	brcs	.+50     	; 0x48ca <malloc+0x66>
    4898:	84 17       	cp	r24, r20
    489a:	95 07       	cpc	r25, r21
    489c:	69 f4       	brne	.+26     	; 0x48b8 <malloc+0x54>
    489e:	10 97       	sbiw	r26, 0x00	; 0
    48a0:	31 f0       	breq	.+12     	; 0x48ae <malloc+0x4a>
    48a2:	12 96       	adiw	r26, 0x02	; 2
    48a4:	0c 93       	st	X, r16
    48a6:	12 97       	sbiw	r26, 0x02	; 2
    48a8:	13 96       	adiw	r26, 0x03	; 3
    48aa:	1c 93       	st	X, r17
    48ac:	27 c0       	rjmp	.+78     	; 0x48fc <malloc+0x98>
    48ae:	00 93 55 05 	sts	0x0555, r16	; 0x800555 <__flp>
    48b2:	10 93 56 05 	sts	0x0556, r17	; 0x800556 <__flp+0x1>
    48b6:	22 c0       	rjmp	.+68     	; 0x48fc <malloc+0x98>
    48b8:	21 15       	cp	r18, r1
    48ba:	31 05       	cpc	r19, r1
    48bc:	19 f0       	breq	.+6      	; 0x48c4 <malloc+0x60>
    48be:	42 17       	cp	r20, r18
    48c0:	53 07       	cpc	r21, r19
    48c2:	18 f4       	brcc	.+6      	; 0x48ca <malloc+0x66>
    48c4:	9a 01       	movw	r18, r20
    48c6:	bd 01       	movw	r22, r26
    48c8:	ef 01       	movw	r28, r30
    48ca:	df 01       	movw	r26, r30
    48cc:	f8 01       	movw	r30, r16
    48ce:	db cf       	rjmp	.-74     	; 0x4886 <malloc+0x22>
    48d0:	21 15       	cp	r18, r1
    48d2:	31 05       	cpc	r19, r1
    48d4:	f9 f0       	breq	.+62     	; 0x4914 <malloc+0xb0>
    48d6:	28 1b       	sub	r18, r24
    48d8:	39 0b       	sbc	r19, r25
    48da:	24 30       	cpi	r18, 0x04	; 4
    48dc:	31 05       	cpc	r19, r1
    48de:	80 f4       	brcc	.+32     	; 0x4900 <malloc+0x9c>
    48e0:	8a 81       	ldd	r24, Y+2	; 0x02
    48e2:	9b 81       	ldd	r25, Y+3	; 0x03
    48e4:	61 15       	cp	r22, r1
    48e6:	71 05       	cpc	r23, r1
    48e8:	21 f0       	breq	.+8      	; 0x48f2 <malloc+0x8e>
    48ea:	fb 01       	movw	r30, r22
    48ec:	93 83       	std	Z+3, r25	; 0x03
    48ee:	82 83       	std	Z+2, r24	; 0x02
    48f0:	04 c0       	rjmp	.+8      	; 0x48fa <malloc+0x96>
    48f2:	90 93 56 05 	sts	0x0556, r25	; 0x800556 <__flp+0x1>
    48f6:	80 93 55 05 	sts	0x0555, r24	; 0x800555 <__flp>
    48fa:	fe 01       	movw	r30, r28
    48fc:	32 96       	adiw	r30, 0x02	; 2
    48fe:	44 c0       	rjmp	.+136    	; 0x4988 <malloc+0x124>
    4900:	fe 01       	movw	r30, r28
    4902:	e2 0f       	add	r30, r18
    4904:	f3 1f       	adc	r31, r19
    4906:	81 93       	st	Z+, r24
    4908:	91 93       	st	Z+, r25
    490a:	22 50       	subi	r18, 0x02	; 2
    490c:	31 09       	sbc	r19, r1
    490e:	39 83       	std	Y+1, r19	; 0x01
    4910:	28 83       	st	Y, r18
    4912:	3a c0       	rjmp	.+116    	; 0x4988 <malloc+0x124>
    4914:	20 91 53 05 	lds	r18, 0x0553	; 0x800553 <__brkval>
    4918:	30 91 54 05 	lds	r19, 0x0554	; 0x800554 <__brkval+0x1>
    491c:	23 2b       	or	r18, r19
    491e:	41 f4       	brne	.+16     	; 0x4930 <malloc+0xcc>
    4920:	20 91 02 01 	lds	r18, 0x0102	; 0x800102 <__malloc_heap_start>
    4924:	30 91 03 01 	lds	r19, 0x0103	; 0x800103 <__malloc_heap_start+0x1>
    4928:	30 93 54 05 	sts	0x0554, r19	; 0x800554 <__brkval+0x1>
    492c:	20 93 53 05 	sts	0x0553, r18	; 0x800553 <__brkval>
    4930:	20 91 00 01 	lds	r18, 0x0100	; 0x800100 <__data_start>
    4934:	30 91 01 01 	lds	r19, 0x0101	; 0x800101 <__data_start+0x1>
    4938:	21 15       	cp	r18, r1
    493a:	31 05       	cpc	r19, r1
    493c:	41 f4       	brne	.+16     	; 0x494e <malloc+0xea>
    493e:	2d b7       	in	r18, 0x3d	; 61
    4940:	3e b7       	in	r19, 0x3e	; 62
    4942:	40 91 04 01 	lds	r20, 0x0104	; 0x800104 <__malloc_margin>
    4946:	50 91 05 01 	lds	r21, 0x0105	; 0x800105 <__malloc_margin+0x1>
    494a:	24 1b       	sub	r18, r20
    494c:	35 0b       	sbc	r19, r21
    494e:	e0 91 53 05 	lds	r30, 0x0553	; 0x800553 <__brkval>
    4952:	f0 91 54 05 	lds	r31, 0x0554	; 0x800554 <__brkval+0x1>
    4956:	e2 17       	cp	r30, r18
    4958:	f3 07       	cpc	r31, r19
    495a:	a0 f4       	brcc	.+40     	; 0x4984 <malloc+0x120>
    495c:	2e 1b       	sub	r18, r30
    495e:	3f 0b       	sbc	r19, r31
    4960:	28 17       	cp	r18, r24
    4962:	39 07       	cpc	r19, r25
    4964:	78 f0       	brcs	.+30     	; 0x4984 <malloc+0x120>
    4966:	ac 01       	movw	r20, r24
    4968:	4e 5f       	subi	r20, 0xFE	; 254
    496a:	5f 4f       	sbci	r21, 0xFF	; 255
    496c:	24 17       	cp	r18, r20
    496e:	35 07       	cpc	r19, r21
    4970:	48 f0       	brcs	.+18     	; 0x4984 <malloc+0x120>
    4972:	4e 0f       	add	r20, r30
    4974:	5f 1f       	adc	r21, r31
    4976:	50 93 54 05 	sts	0x0554, r21	; 0x800554 <__brkval+0x1>
    497a:	40 93 53 05 	sts	0x0553, r20	; 0x800553 <__brkval>
    497e:	81 93       	st	Z+, r24
    4980:	91 93       	st	Z+, r25
    4982:	02 c0       	rjmp	.+4      	; 0x4988 <malloc+0x124>
    4984:	e0 e0       	ldi	r30, 0x00	; 0
    4986:	f0 e0       	ldi	r31, 0x00	; 0
    4988:	cf 01       	movw	r24, r30
    498a:	df 91       	pop	r29
    498c:	cf 91       	pop	r28
    498e:	1f 91       	pop	r17
    4990:	0f 91       	pop	r16
    4992:	08 95       	ret

00004994 <free>:
    4994:	cf 93       	push	r28
    4996:	df 93       	push	r29
    4998:	00 97       	sbiw	r24, 0x00	; 0
    499a:	09 f4       	brne	.+2      	; 0x499e <free+0xa>
    499c:	81 c0       	rjmp	.+258    	; 0x4aa0 <free+0x10c>
    499e:	fc 01       	movw	r30, r24
    49a0:	32 97       	sbiw	r30, 0x02	; 2
    49a2:	13 82       	std	Z+3, r1	; 0x03
    49a4:	12 82       	std	Z+2, r1	; 0x02
    49a6:	a0 91 55 05 	lds	r26, 0x0555	; 0x800555 <__flp>
    49aa:	b0 91 56 05 	lds	r27, 0x0556	; 0x800556 <__flp+0x1>
    49ae:	10 97       	sbiw	r26, 0x00	; 0
    49b0:	81 f4       	brne	.+32     	; 0x49d2 <free+0x3e>
    49b2:	20 81       	ld	r18, Z
    49b4:	31 81       	ldd	r19, Z+1	; 0x01
    49b6:	82 0f       	add	r24, r18
    49b8:	93 1f       	adc	r25, r19
    49ba:	20 91 53 05 	lds	r18, 0x0553	; 0x800553 <__brkval>
    49be:	30 91 54 05 	lds	r19, 0x0554	; 0x800554 <__brkval+0x1>
    49c2:	28 17       	cp	r18, r24
    49c4:	39 07       	cpc	r19, r25
    49c6:	51 f5       	brne	.+84     	; 0x4a1c <free+0x88>
    49c8:	f0 93 54 05 	sts	0x0554, r31	; 0x800554 <__brkval+0x1>
    49cc:	e0 93 53 05 	sts	0x0553, r30	; 0x800553 <__brkval>
    49d0:	67 c0       	rjmp	.+206    	; 0x4aa0 <free+0x10c>
    49d2:	ed 01       	movw	r28, r26
    49d4:	20 e0       	ldi	r18, 0x00	; 0
    49d6:	30 e0       	ldi	r19, 0x00	; 0
    49d8:	ce 17       	cp	r28, r30
    49da:	df 07       	cpc	r29, r31
    49dc:	40 f4       	brcc	.+16     	; 0x49ee <free+0x5a>
    49de:	4a 81       	ldd	r20, Y+2	; 0x02
    49e0:	5b 81       	ldd	r21, Y+3	; 0x03
    49e2:	9e 01       	movw	r18, r28
    49e4:	41 15       	cp	r20, r1
    49e6:	51 05       	cpc	r21, r1
    49e8:	f1 f0       	breq	.+60     	; 0x4a26 <free+0x92>
    49ea:	ea 01       	movw	r28, r20
    49ec:	f5 cf       	rjmp	.-22     	; 0x49d8 <free+0x44>
    49ee:	d3 83       	std	Z+3, r29	; 0x03
    49f0:	c2 83       	std	Z+2, r28	; 0x02
    49f2:	40 81       	ld	r20, Z
    49f4:	51 81       	ldd	r21, Z+1	; 0x01
    49f6:	84 0f       	add	r24, r20
    49f8:	95 1f       	adc	r25, r21
    49fa:	c8 17       	cp	r28, r24
    49fc:	d9 07       	cpc	r29, r25
    49fe:	59 f4       	brne	.+22     	; 0x4a16 <free+0x82>
    4a00:	88 81       	ld	r24, Y
    4a02:	99 81       	ldd	r25, Y+1	; 0x01
    4a04:	84 0f       	add	r24, r20
    4a06:	95 1f       	adc	r25, r21
    4a08:	02 96       	adiw	r24, 0x02	; 2
    4a0a:	91 83       	std	Z+1, r25	; 0x01
    4a0c:	80 83       	st	Z, r24
    4a0e:	8a 81       	ldd	r24, Y+2	; 0x02
    4a10:	9b 81       	ldd	r25, Y+3	; 0x03
    4a12:	93 83       	std	Z+3, r25	; 0x03
    4a14:	82 83       	std	Z+2, r24	; 0x02
    4a16:	21 15       	cp	r18, r1
    4a18:	31 05       	cpc	r19, r1
    4a1a:	29 f4       	brne	.+10     	; 0x4a26 <free+0x92>
    4a1c:	f0 93 56 05 	sts	0x0556, r31	; 0x800556 <__flp+0x1>
    4a20:	e0 93 55 05 	sts	0x0555, r30	; 0x800555 <__flp>
    4a24:	3d c0       	rjmp	.+122    	; 0x4aa0 <free+0x10c>
    4a26:	e9 01       	movw	r28, r18
    4a28:	fb 83       	std	Y+3, r31	; 0x03
    4a2a:	ea 83       	std	Y+2, r30	; 0x02
    4a2c:	49 91       	ld	r20, Y+
    4a2e:	59 91       	ld	r21, Y+
    4a30:	c4 0f       	add	r28, r20
    4a32:	d5 1f       	adc	r29, r21
    4a34:	ec 17       	cp	r30, r28
    4a36:	fd 07       	cpc	r31, r29
    4a38:	61 f4       	brne	.+24     	; 0x4a52 <free+0xbe>
    4a3a:	80 81       	ld	r24, Z
    4a3c:	91 81       	ldd	r25, Z+1	; 0x01
    4a3e:	84 0f       	add	r24, r20
    4a40:	95 1f       	adc	r25, r21
    4a42:	02 96       	adiw	r24, 0x02	; 2
    4a44:	e9 01       	movw	r28, r18
    4a46:	99 83       	std	Y+1, r25	; 0x01
    4a48:	88 83       	st	Y, r24
    4a4a:	82 81       	ldd	r24, Z+2	; 0x02
    4a4c:	93 81       	ldd	r25, Z+3	; 0x03
    4a4e:	9b 83       	std	Y+3, r25	; 0x03
    4a50:	8a 83       	std	Y+2, r24	; 0x02
    4a52:	e0 e0       	ldi	r30, 0x00	; 0
    4a54:	f0 e0       	ldi	r31, 0x00	; 0
    4a56:	12 96       	adiw	r26, 0x02	; 2
    4a58:	8d 91       	ld	r24, X+
    4a5a:	9c 91       	ld	r25, X
    4a5c:	13 97       	sbiw	r26, 0x03	; 3
    4a5e:	00 97       	sbiw	r24, 0x00	; 0
    4a60:	19 f0       	breq	.+6      	; 0x4a68 <free+0xd4>
    4a62:	fd 01       	movw	r30, r26
    4a64:	dc 01       	movw	r26, r24
    4a66:	f7 cf       	rjmp	.-18     	; 0x4a56 <free+0xc2>
    4a68:	8d 91       	ld	r24, X+
    4a6a:	9c 91       	ld	r25, X
    4a6c:	11 97       	sbiw	r26, 0x01	; 1
    4a6e:	9d 01       	movw	r18, r26
    4a70:	2e 5f       	subi	r18, 0xFE	; 254
    4a72:	3f 4f       	sbci	r19, 0xFF	; 255
    4a74:	82 0f       	add	r24, r18
    4a76:	93 1f       	adc	r25, r19
    4a78:	20 91 53 05 	lds	r18, 0x0553	; 0x800553 <__brkval>
    4a7c:	30 91 54 05 	lds	r19, 0x0554	; 0x800554 <__brkval+0x1>
    4a80:	28 17       	cp	r18, r24
    4a82:	39 07       	cpc	r19, r25
    4a84:	69 f4       	brne	.+26     	; 0x4aa0 <free+0x10c>
    4a86:	30 97       	sbiw	r30, 0x00	; 0
    4a88:	29 f4       	brne	.+10     	; 0x4a94 <free+0x100>
    4a8a:	10 92 56 05 	sts	0x0556, r1	; 0x800556 <__flp+0x1>
    4a8e:	10 92 55 05 	sts	0x0555, r1	; 0x800555 <__flp>
    4a92:	02 c0       	rjmp	.+4      	; 0x4a98 <free+0x104>
    4a94:	13 82       	std	Z+3, r1	; 0x03
    4a96:	12 82       	std	Z+2, r1	; 0x02
    4a98:	b0 93 54 05 	sts	0x0554, r27	; 0x800554 <__brkval+0x1>
    4a9c:	a0 93 53 05 	sts	0x0553, r26	; 0x800553 <__brkval>
    4aa0:	df 91       	pop	r29
    4aa2:	cf 91       	pop	r28
    4aa4:	08 95       	ret

00004aa6 <memcpy>:
    4aa6:	fb 01       	movw	r30, r22
    4aa8:	dc 01       	movw	r26, r24
    4aaa:	02 c0       	rjmp	.+4      	; 0x4ab0 <memcpy+0xa>
    4aac:	01 90       	ld	r0, Z+
    4aae:	0d 92       	st	X+, r0
    4ab0:	41 50       	subi	r20, 0x01	; 1
    4ab2:	50 40       	sbci	r21, 0x00	; 0
    4ab4:	d8 f7       	brcc	.-10     	; 0x4aac <memcpy+0x6>
    4ab6:	08 95       	ret

00004ab8 <memset>:
    4ab8:	dc 01       	movw	r26, r24
    4aba:	01 c0       	rjmp	.+2      	; 0x4abe <memset+0x6>
    4abc:	6d 93       	st	X+, r22
    4abe:	41 50       	subi	r20, 0x01	; 1
    4ac0:	50 40       	sbci	r21, 0x00	; 0
    4ac2:	e0 f7       	brcc	.-8      	; 0x4abc <memset+0x4>
    4ac4:	08 95       	ret

00004ac6 <__do_global_dtors>:
    4ac6:	10 e0       	ldi	r17, 0x00	; 0
    4ac8:	ca e8       	ldi	r28, 0x8A	; 138
    4aca:	d0 e0       	ldi	r29, 0x00	; 0
    4acc:	04 c0       	rjmp	.+8      	; 0x4ad6 <__do_global_dtors+0x10>
    4ace:	fe 01       	movw	r30, r28
    4ad0:	0e 94 fe 23 	call	0x47fc	; 0x47fc <__tablejump2__>
    4ad4:	21 96       	adiw	r28, 0x01	; 1
    4ad6:	cc 38       	cpi	r28, 0x8C	; 140
    4ad8:	d1 07       	cpc	r29, r17
    4ada:	c9 f7       	brne	.-14     	; 0x4ace <__do_global_dtors+0x8>
    4adc:	f8 94       	cli

00004ade <__stop_program>:
    4ade:	ff cf       	rjmp	.-2      	; 0x4ade <__stop_program>
