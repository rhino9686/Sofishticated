
lil_fish_tanks_arduino.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         000001b6  00800100  00004614  000046a8  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00004614  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000280  008002b6  008002b6  0000485e  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  0000485e  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00004890  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000a00  00000000  00000000  000048d0  2**3
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   0001391a  00000000  00000000  000052d0  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00003d12  00000000  00000000  00018bea  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00006991  00000000  00000000  0001c8fc  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00001ea0  00000000  00000000  00023290  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00004b22  00000000  00000000  00025130  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    0000b72d  00000000  00000000  00029c52  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000920  00000000  00000000  0003537f  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 8b 00 	jmp	0x116	; 0x116 <__dtors_end>
       4:	0c 94 18 12 	jmp	0x2430	; 0x2430 <__vector_1>
       8:	0c 94 3f 12 	jmp	0x247e	; 0x247e <__vector_2>
       c:	0c 94 b3 00 	jmp	0x166	; 0x166 <__bad_interrupt>
      10:	0c 94 b3 00 	jmp	0x166	; 0x166 <__bad_interrupt>
      14:	0c 94 b3 00 	jmp	0x166	; 0x166 <__bad_interrupt>
      18:	0c 94 95 1e 	jmp	0x3d2a	; 0x3d2a <__vector_6>
      1c:	0c 94 11 1c 	jmp	0x3822	; 0x3822 <__vector_7>
      20:	0c 94 b3 00 	jmp	0x166	; 0x166 <__bad_interrupt>
      24:	0c 94 b3 00 	jmp	0x166	; 0x166 <__bad_interrupt>
      28:	0c 94 b3 00 	jmp	0x166	; 0x166 <__bad_interrupt>
      2c:	0c 94 b3 00 	jmp	0x166	; 0x166 <__bad_interrupt>
      30:	0c 94 b3 00 	jmp	0x166	; 0x166 <__bad_interrupt>
      34:	0c 94 b3 00 	jmp	0x166	; 0x166 <__bad_interrupt>
      38:	0c 94 b3 00 	jmp	0x166	; 0x166 <__bad_interrupt>
      3c:	0c 94 b3 00 	jmp	0x166	; 0x166 <__bad_interrupt>
      40:	0c 94 66 12 	jmp	0x24cc	; 0x24cc <__vector_16>
      44:	0c 94 b3 00 	jmp	0x166	; 0x166 <__bad_interrupt>
      48:	0c 94 27 0f 	jmp	0x1e4e	; 0x1e4e <__vector_18>
      4c:	0c 94 59 0f 	jmp	0x1eb2	; 0x1eb2 <__vector_19>
      50:	0c 94 b3 00 	jmp	0x166	; 0x166 <__bad_interrupt>
      54:	0c 94 b3 00 	jmp	0x166	; 0x166 <__bad_interrupt>
      58:	0c 94 b3 00 	jmp	0x166	; 0x166 <__bad_interrupt>
      5c:	0c 94 b3 00 	jmp	0x166	; 0x166 <__bad_interrupt>
      60:	0c 94 b3 00 	jmp	0x166	; 0x166 <__bad_interrupt>
      64:	0c 94 b3 00 	jmp	0x166	; 0x166 <__bad_interrupt>
      68:	05 1b       	sub	r16, r21
      6a:	05 1b       	sub	r16, r21
      6c:	05 1b       	sub	r16, r21
      6e:	44 1b       	sub	r20, r20
      70:	2f 1b       	sub	r18, r31
      72:	3e 1b       	sub	r19, r30
      74:	05 1b       	sub	r16, r21
      76:	05 1b       	sub	r16, r21
      78:	44 1b       	sub	r20, r20
      7a:	2f 1b       	sub	r18, r31

0000007c <__trampolines_end>:
      7c:	0a 46       	sbci	r16, 0x6A	; 106
      7e:	6f 75       	andi	r22, 0x5F	; 95
      80:	6e 64       	ori	r22, 0x4E	; 78
      82:	20 4d       	sbci	r18, 0xD0	; 208
      84:	61 74       	andi	r22, 0x41	; 65
      86:	63 68       	ori	r22, 0x83	; 131
      88:	69 6e       	ori	r22, 0xE9	; 233
      8a:	67 20       	and	r6, r7
      8c:	43 6f       	ori	r20, 0xF3	; 243
      8e:	6c 6f       	ori	r22, 0xFC	; 252
      90:	72 00       	.word	0x0072	; ????

00000092 <_ZL15dscrc2x16_table>:
      92:	00 5e bc e2 61 3f dd 83 c2 9c 7e 20 a3 fd 1f 41     .^..a?....~ ...A
      a2:	00 9d 23 be 46 db 65 f8 8c 11 af 32 ca 57 e9 74     ..#.F.e....2.W.t

000000b2 <digital_pin_to_timer_PGM>:
      b2:	00 00 00 08 00 02 01 00 00 03 04 07 00 00 00 00     ................
      c2:	00 00 00 00                                         ....

000000c6 <digital_pin_to_bit_mask_PGM>:
      c6:	01 02 04 08 10 20 40 80 01 02 04 08 10 20 01 02     ..... @...... ..
      d6:	04 08 10 20                                         ... 

000000da <digital_pin_to_port_PGM>:
      da:	04 04 04 04 04 04 04 04 02 02 02 02 02 02 03 03     ................
      ea:	03 03 03 03                                         ....

000000ee <port_to_input_PGM>:
      ee:	00 00 00 00 23 00 26 00 29 00                       ....#.&.).

000000f8 <port_to_output_PGM>:
      f8:	00 00 00 00 25 00 28 00 2b 00                       ....%.(.+.

00000102 <port_to_mode_PGM>:
     102:	00 00 00 00 24 00 27 00 2a 00                       ....$.'.*.

0000010c <__ctors_start>:
     10c:	98 07       	cpc	r25, r24
     10e:	fa 09       	sbc	r31, r10
     110:	89 0f       	add	r24, r25

00000112 <__ctors_end>:
     112:	a4 07       	cpc	r26, r20
     114:	fe 09       	sbc	r31, r14

00000116 <__dtors_end>:
     116:	11 24       	eor	r1, r1
     118:	1f be       	out	0x3f, r1	; 63
     11a:	cf ef       	ldi	r28, 0xFF	; 255
     11c:	d8 e0       	ldi	r29, 0x08	; 8
     11e:	de bf       	out	0x3e, r29	; 62
     120:	cd bf       	out	0x3d, r28	; 61

00000122 <__do_copy_data>:
     122:	12 e0       	ldi	r17, 0x02	; 2
     124:	a0 e0       	ldi	r26, 0x00	; 0
     126:	b1 e0       	ldi	r27, 0x01	; 1
     128:	e4 e1       	ldi	r30, 0x14	; 20
     12a:	f6 e4       	ldi	r31, 0x46	; 70
     12c:	02 c0       	rjmp	.+4      	; 0x132 <__do_copy_data+0x10>
     12e:	05 90       	lpm	r0, Z+
     130:	0d 92       	st	X+, r0
     132:	a6 3b       	cpi	r26, 0xB6	; 182
     134:	b1 07       	cpc	r27, r17
     136:	d9 f7       	brne	.-10     	; 0x12e <__do_copy_data+0xc>

00000138 <__do_clear_bss>:
     138:	25 e0       	ldi	r18, 0x05	; 5
     13a:	a6 eb       	ldi	r26, 0xB6	; 182
     13c:	b2 e0       	ldi	r27, 0x02	; 2
     13e:	01 c0       	rjmp	.+2      	; 0x142 <.do_clear_bss_start>

00000140 <.do_clear_bss_loop>:
     140:	1d 92       	st	X+, r1

00000142 <.do_clear_bss_start>:
     142:	a6 33       	cpi	r26, 0x36	; 54
     144:	b2 07       	cpc	r27, r18
     146:	e1 f7       	brne	.-8      	; 0x140 <.do_clear_bss_loop>

00000148 <__do_global_ctors>:
     148:	10 e0       	ldi	r17, 0x00	; 0
     14a:	c9 e8       	ldi	r28, 0x89	; 137
     14c:	d0 e0       	ldi	r29, 0x00	; 0
     14e:	04 c0       	rjmp	.+8      	; 0x158 <__do_global_ctors+0x10>
     150:	21 97       	sbiw	r28, 0x01	; 1
     152:	fe 01       	movw	r30, r28
     154:	0e 94 82 21 	call	0x4304	; 0x4304 <__tablejump2__>
     158:	c6 38       	cpi	r28, 0x86	; 134
     15a:	d1 07       	cpc	r29, r17
     15c:	c9 f7       	brne	.-14     	; 0x150 <__do_global_ctors+0x8>
     15e:	0e 94 b6 0f 	call	0x1f6c	; 0x1f6c <main>
     162:	0c 94 fd 22 	jmp	0x45fa	; 0x45fa <__do_global_dtors>

00000166 <__bad_interrupt>:
     166:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

0000016a <_ZN11EEPROMClass4readEi.isra.0>:
     16a:	0c 94 e7 22 	jmp	0x45ce	; 0x45ce <eeprom_read_byte>

0000016e <_ZN10DFRobot_PHC1Ev>:
     16e:	fc 01       	movw	r30, r24
     170:	80 e0       	ldi	r24, 0x00	; 0
     172:	90 e0       	ldi	r25, 0x00	; 0
     174:	a8 ec       	ldi	r26, 0xC8	; 200
     176:	b1 e4       	ldi	r27, 0x41	; 65
     178:	80 8b       	std	Z+16, r24	; 0x10
     17a:	91 8b       	std	Z+17, r25	; 0x11
     17c:	a2 8b       	std	Z+18, r26	; 0x12
     17e:	b3 8b       	std	Z+19, r27	; 0x13
     180:	80 e0       	ldi	r24, 0x00	; 0
     182:	90 e0       	ldi	r25, 0x00	; 0
     184:	a0 ee       	ldi	r26, 0xE0	; 224
     186:	b0 e4       	ldi	r27, 0x40	; 64
     188:	80 83       	st	Z, r24
     18a:	91 83       	std	Z+1, r25	; 0x01
     18c:	a2 83       	std	Z+2, r26	; 0x02
     18e:	b3 83       	std	Z+3, r27	; 0x03
     190:	84 e1       	ldi	r24, 0x14	; 20
     192:	9e e0       	ldi	r25, 0x0E	; 14
     194:	ae ef       	ldi	r26, 0xFE	; 254
     196:	b4 e4       	ldi	r27, 0x44	; 68
     198:	84 83       	std	Z+4, r24	; 0x04
     19a:	95 83       	std	Z+5, r25	; 0x05
     19c:	a6 83       	std	Z+6, r26	; 0x06
     19e:	b7 83       	std	Z+7, r27	; 0x07
     1a0:	80 e0       	ldi	r24, 0x00	; 0
     1a2:	90 e8       	ldi	r25, 0x80	; 128
     1a4:	ab eb       	ldi	r26, 0xBB	; 187
     1a6:	b4 e4       	ldi	r27, 0x44	; 68
     1a8:	80 87       	std	Z+8, r24	; 0x08
     1aa:	91 87       	std	Z+9, r25	; 0x09
     1ac:	a2 87       	std	Z+10, r26	; 0x0a
     1ae:	b3 87       	std	Z+11, r27	; 0x0b
     1b0:	84 87       	std	Z+12, r24	; 0x0c
     1b2:	95 87       	std	Z+13, r25	; 0x0d
     1b4:	a6 87       	std	Z+14, r26	; 0x0e
     1b6:	b7 87       	std	Z+15, r27	; 0x0f
     1b8:	08 95       	ret

000001ba <_ZN10DFRobot_PHD1Ev>:
     1ba:	08 95       	ret

000001bc <_ZN10DFRobot_PH5beginEv>:
     1bc:	cf 92       	push	r12
     1be:	df 92       	push	r13
     1c0:	ef 92       	push	r14
     1c2:	ff 92       	push	r15
     1c4:	0f 93       	push	r16
     1c6:	1f 93       	push	r17
     1c8:	cf 93       	push	r28
     1ca:	df 93       	push	r29
     1cc:	ec 01       	movw	r28, r24
     1ce:	7c 01       	movw	r14, r24
     1d0:	88 e0       	ldi	r24, 0x08	; 8
     1d2:	e8 0e       	add	r14, r24
     1d4:	f1 1c       	adc	r15, r1
     1d6:	67 01       	movw	r12, r14
     1d8:	00 e0       	ldi	r16, 0x00	; 0
     1da:	10 e0       	ldi	r17, 0x00	; 0
     1dc:	c8 01       	movw	r24, r16
     1de:	0e 94 b5 00 	call	0x16a	; 0x16a <_ZN11EEPROMClass4readEi.isra.0>
     1e2:	f6 01       	movw	r30, r12
     1e4:	81 93       	st	Z+, r24
     1e6:	6f 01       	movw	r12, r30
     1e8:	0f 5f       	subi	r16, 0xFF	; 255
     1ea:	1f 4f       	sbci	r17, 0xFF	; 255
     1ec:	04 30       	cpi	r16, 0x04	; 4
     1ee:	11 05       	cpc	r17, r1
     1f0:	a9 f7       	brne	.-22     	; 0x1dc <_ZN10DFRobot_PH5beginEv+0x20>
     1f2:	68 e3       	ldi	r22, 0x38	; 56
     1f4:	71 e0       	ldi	r23, 0x01	; 1
     1f6:	86 ef       	ldi	r24, 0xF6	; 246
     1f8:	93 e0       	ldi	r25, 0x03	; 3
     1fa:	0e 94 13 10 	call	0x2026	; 0x2026 <_ZN5Print5printEPKc>
     1fe:	48 85       	ldd	r20, Y+8	; 0x08
     200:	59 85       	ldd	r21, Y+9	; 0x09
     202:	6a 85       	ldd	r22, Y+10	; 0x0a
     204:	7b 85       	ldd	r23, Y+11	; 0x0b
     206:	22 e0       	ldi	r18, 0x02	; 2
     208:	30 e0       	ldi	r19, 0x00	; 0
     20a:	86 ef       	ldi	r24, 0xF6	; 246
     20c:	93 e0       	ldi	r25, 0x03	; 3
     20e:	0e 94 e5 11 	call	0x23ca	; 0x23ca <_ZN5Print7printlnEdi>
     212:	80 e0       	ldi	r24, 0x00	; 0
     214:	90 e0       	ldi	r25, 0x00	; 0
     216:	0e 94 b5 00 	call	0x16a	; 0x16a <_ZN11EEPROMClass4readEi.isra.0>
     21a:	8f 3f       	cpi	r24, 0xFF	; 255
     21c:	39 f5       	brne	.+78     	; 0x26c <_ZN10DFRobot_PH5beginEv+0xb0>
     21e:	81 e0       	ldi	r24, 0x01	; 1
     220:	90 e0       	ldi	r25, 0x00	; 0
     222:	0e 94 b5 00 	call	0x16a	; 0x16a <_ZN11EEPROMClass4readEi.isra.0>
     226:	8f 3f       	cpi	r24, 0xFF	; 255
     228:	09 f5       	brne	.+66     	; 0x26c <_ZN10DFRobot_PH5beginEv+0xb0>
     22a:	82 e0       	ldi	r24, 0x02	; 2
     22c:	90 e0       	ldi	r25, 0x00	; 0
     22e:	0e 94 b5 00 	call	0x16a	; 0x16a <_ZN11EEPROMClass4readEi.isra.0>
     232:	8f 3f       	cpi	r24, 0xFF	; 255
     234:	d9 f4       	brne	.+54     	; 0x26c <_ZN10DFRobot_PH5beginEv+0xb0>
     236:	83 e0       	ldi	r24, 0x03	; 3
     238:	90 e0       	ldi	r25, 0x00	; 0
     23a:	0e 94 b5 00 	call	0x16a	; 0x16a <_ZN11EEPROMClass4readEi.isra.0>
     23e:	8f 3f       	cpi	r24, 0xFF	; 255
     240:	a9 f4       	brne	.+42     	; 0x26c <_ZN10DFRobot_PH5beginEv+0xb0>
     242:	80 e0       	ldi	r24, 0x00	; 0
     244:	90 e8       	ldi	r25, 0x80	; 128
     246:	ab eb       	ldi	r26, 0xBB	; 187
     248:	b4 e4       	ldi	r27, 0x44	; 68
     24a:	88 87       	std	Y+8, r24	; 0x08
     24c:	99 87       	std	Y+9, r25	; 0x09
     24e:	aa 87       	std	Y+10, r26	; 0x0a
     250:	bb 87       	std	Y+11, r27	; 0x0b
     252:	00 e0       	ldi	r16, 0x00	; 0
     254:	10 e0       	ldi	r17, 0x00	; 0
     256:	f7 01       	movw	r30, r14
     258:	61 91       	ld	r22, Z+
     25a:	7f 01       	movw	r14, r30
     25c:	c8 01       	movw	r24, r16
     25e:	0e 94 ef 22 	call	0x45de	; 0x45de <eeprom_write_byte>
     262:	0f 5f       	subi	r16, 0xFF	; 255
     264:	1f 4f       	sbci	r17, 0xFF	; 255
     266:	04 30       	cpi	r16, 0x04	; 4
     268:	11 05       	cpc	r17, r1
     26a:	a9 f7       	brne	.-22     	; 0x256 <_ZN10DFRobot_PH5beginEv+0x9a>
     26c:	7e 01       	movw	r14, r28
     26e:	f4 e0       	ldi	r31, 0x04	; 4
     270:	ef 0e       	add	r14, r31
     272:	f1 1c       	adc	r15, r1
     274:	67 01       	movw	r12, r14
     276:	04 e0       	ldi	r16, 0x04	; 4
     278:	10 e0       	ldi	r17, 0x00	; 0
     27a:	c8 01       	movw	r24, r16
     27c:	0e 94 b5 00 	call	0x16a	; 0x16a <_ZN11EEPROMClass4readEi.isra.0>
     280:	f6 01       	movw	r30, r12
     282:	81 93       	st	Z+, r24
     284:	6f 01       	movw	r12, r30
     286:	0f 5f       	subi	r16, 0xFF	; 255
     288:	1f 4f       	sbci	r17, 0xFF	; 255
     28a:	08 30       	cpi	r16, 0x08	; 8
     28c:	11 05       	cpc	r17, r1
     28e:	a9 f7       	brne	.-22     	; 0x27a <_ZN10DFRobot_PH5beginEv+0xbe>
     290:	69 e4       	ldi	r22, 0x49	; 73
     292:	71 e0       	ldi	r23, 0x01	; 1
     294:	86 ef       	ldi	r24, 0xF6	; 246
     296:	93 e0       	ldi	r25, 0x03	; 3
     298:	0e 94 13 10 	call	0x2026	; 0x2026 <_ZN5Print5printEPKc>
     29c:	4c 81       	ldd	r20, Y+4	; 0x04
     29e:	5d 81       	ldd	r21, Y+5	; 0x05
     2a0:	6e 81       	ldd	r22, Y+6	; 0x06
     2a2:	7f 81       	ldd	r23, Y+7	; 0x07
     2a4:	22 e0       	ldi	r18, 0x02	; 2
     2a6:	30 e0       	ldi	r19, 0x00	; 0
     2a8:	86 ef       	ldi	r24, 0xF6	; 246
     2aa:	93 e0       	ldi	r25, 0x03	; 3
     2ac:	0e 94 e5 11 	call	0x23ca	; 0x23ca <_ZN5Print7printlnEdi>
     2b0:	84 e0       	ldi	r24, 0x04	; 4
     2b2:	90 e0       	ldi	r25, 0x00	; 0
     2b4:	0e 94 b5 00 	call	0x16a	; 0x16a <_ZN11EEPROMClass4readEi.isra.0>
     2b8:	8f 3f       	cpi	r24, 0xFF	; 255
     2ba:	31 f5       	brne	.+76     	; 0x308 <_ZN10DFRobot_PH5beginEv+0x14c>
     2bc:	85 e0       	ldi	r24, 0x05	; 5
     2be:	90 e0       	ldi	r25, 0x00	; 0
     2c0:	0e 94 b5 00 	call	0x16a	; 0x16a <_ZN11EEPROMClass4readEi.isra.0>
     2c4:	8f 3f       	cpi	r24, 0xFF	; 255
     2c6:	01 f5       	brne	.+64     	; 0x308 <_ZN10DFRobot_PH5beginEv+0x14c>
     2c8:	86 e0       	ldi	r24, 0x06	; 6
     2ca:	90 e0       	ldi	r25, 0x00	; 0
     2cc:	0e 94 b5 00 	call	0x16a	; 0x16a <_ZN11EEPROMClass4readEi.isra.0>
     2d0:	8f 3f       	cpi	r24, 0xFF	; 255
     2d2:	d1 f4       	brne	.+52     	; 0x308 <_ZN10DFRobot_PH5beginEv+0x14c>
     2d4:	87 e0       	ldi	r24, 0x07	; 7
     2d6:	90 e0       	ldi	r25, 0x00	; 0
     2d8:	0e 94 b5 00 	call	0x16a	; 0x16a <_ZN11EEPROMClass4readEi.isra.0>
     2dc:	8f 3f       	cpi	r24, 0xFF	; 255
     2de:	a1 f4       	brne	.+40     	; 0x308 <_ZN10DFRobot_PH5beginEv+0x14c>
     2e0:	84 e1       	ldi	r24, 0x14	; 20
     2e2:	9e e0       	ldi	r25, 0x0E	; 14
     2e4:	ae ef       	ldi	r26, 0xFE	; 254
     2e6:	b4 e4       	ldi	r27, 0x44	; 68
     2e8:	8c 83       	std	Y+4, r24	; 0x04
     2ea:	9d 83       	std	Y+5, r25	; 0x05
     2ec:	ae 83       	std	Y+6, r26	; 0x06
     2ee:	bf 83       	std	Y+7, r27	; 0x07
     2f0:	c4 e0       	ldi	r28, 0x04	; 4
     2f2:	d0 e0       	ldi	r29, 0x00	; 0
     2f4:	f7 01       	movw	r30, r14
     2f6:	61 91       	ld	r22, Z+
     2f8:	7f 01       	movw	r14, r30
     2fa:	ce 01       	movw	r24, r28
     2fc:	0e 94 ef 22 	call	0x45de	; 0x45de <eeprom_write_byte>
     300:	21 96       	adiw	r28, 0x01	; 1
     302:	c8 30       	cpi	r28, 0x08	; 8
     304:	d1 05       	cpc	r29, r1
     306:	b1 f7       	brne	.-20     	; 0x2f4 <_ZN10DFRobot_PH5beginEv+0x138>
     308:	df 91       	pop	r29
     30a:	cf 91       	pop	r28
     30c:	1f 91       	pop	r17
     30e:	0f 91       	pop	r16
     310:	ff 90       	pop	r15
     312:	ef 90       	pop	r14
     314:	df 90       	pop	r13
     316:	cf 90       	pop	r12
     318:	08 95       	ret

0000031a <_ZN5Print5writeEPKc>:
    int getWriteError() { return write_error; }
    void clearWriteError() { setWriteError(0); }
  
    virtual size_t write(uint8_t) = 0;
    size_t write(const char *str) {
      if (str == NULL) return 0;
     31a:	61 15       	cp	r22, r1
     31c:	71 05       	cpc	r23, r1
     31e:	79 f0       	breq	.+30     	; 0x33e <_ZN5Print5writeEPKc+0x24>
      return write((const uint8_t *)str, strlen(str));
     320:	fb 01       	movw	r30, r22
     322:	01 90       	ld	r0, Z+
     324:	00 20       	and	r0, r0
     326:	e9 f7       	brne	.-6      	; 0x322 <_ZN5Print5writeEPKc+0x8>
     328:	31 97       	sbiw	r30, 0x01	; 1
     32a:	af 01       	movw	r20, r30
     32c:	46 1b       	sub	r20, r22
     32e:	57 0b       	sbc	r21, r23
     330:	dc 01       	movw	r26, r24
     332:	ed 91       	ld	r30, X+
     334:	fc 91       	ld	r31, X
     336:	02 80       	ldd	r0, Z+2	; 0x02
     338:	f3 81       	ldd	r31, Z+3	; 0x03
     33a:	e0 2d       	mov	r30, r0
     33c:	09 94       	ijmp
    }
     33e:	80 e0       	ldi	r24, 0x00	; 0
     340:	90 e0       	ldi	r25, 0x00	; 0
     342:	08 95       	ret

00000344 <_ZN14HardwareSerial5writeEi>:
    virtual void flush(void);
    virtual size_t write(uint8_t);
    inline size_t write(unsigned long n) { return write((uint8_t)n); }
    inline size_t write(long n) { return write((uint8_t)n); }
    inline size_t write(unsigned int n) { return write((uint8_t)n); }
    inline size_t write(int n) { return write((uint8_t)n); }
     344:	dc 01       	movw	r26, r24
     346:	ed 91       	ld	r30, X+
     348:	fc 91       	ld	r31, X
     34a:	01 90       	ld	r0, Z+
     34c:	f0 81       	ld	r31, Z
     34e:	e0 2d       	mov	r30, r0
     350:	09 94       	ijmp

00000352 <_Z11measureTempv>:

OneWire ds(TEMP_PIN); // Temp sensor on pin 7


/* measureTemp() returns the measured temperature in degrees Celsius */
float measureTemp() {
     352:	cf 92       	push	r12
     354:	df 92       	push	r13
     356:	ff 92       	push	r15
     358:	0f 93       	push	r16
     35a:	1f 93       	push	r17
     35c:	cf 93       	push	r28
     35e:	df 93       	push	r29
     360:	cd b7       	in	r28, 0x3d	; 61
     362:	de b7       	in	r29, 0x3e	; 62
     364:	64 97       	sbiw	r28, 0x14	; 20
     366:	0f b6       	in	r0, 0x3f	; 63
     368:	f8 94       	cli
     36a:	de bf       	out	0x3e, r29	; 62
     36c:	0f be       	out	0x3f, r0	; 63
     36e:	cd bf       	out	0x3d, r28	; 61
	byte type_s;
	byte data[12];
	byte addr[8];
	float celsius, fahrenheit;
	
	ds.reset_search();
     370:	88 ec       	ldi	r24, 0xC8	; 200
     372:	93 e0       	ldi	r25, 0x03	; 3
     374:	0e 94 28 09 	call	0x1250	; 0x1250 <_ZN7OneWire12reset_searchEv>
	delay(250);
     378:	6a ef       	ldi	r22, 0xFA	; 250
     37a:	70 e0       	ldi	r23, 0x00	; 0
     37c:	80 e0       	ldi	r24, 0x00	; 0
     37e:	90 e0       	ldi	r25, 0x00	; 0
     380:	0e 94 d5 12 	call	0x25aa	; 0x25aa <delay>
	ds.search(addr);
     384:	41 e0       	ldi	r20, 0x01	; 1
     386:	be 01       	movw	r22, r28
     388:	63 5f       	subi	r22, 0xF3	; 243
     38a:	7f 4f       	sbci	r23, 0xFF	; 255
     38c:	88 ec       	ldi	r24, 0xC8	; 200
     38e:	93 e0       	ldi	r25, 0x03	; 3
     390:	0e 94 57 09 	call	0x12ae	; 0x12ae <_ZN7OneWire6searchEPhb>

	if (OneWire::crc8(addr, 7) != addr[7]) {
     394:	67 e0       	ldi	r22, 0x07	; 7
     396:	ce 01       	movw	r24, r28
     398:	0d 96       	adiw	r24, 0x0d	; 13
     39a:	0e 94 de 09 	call	0x13bc	; 0x13bc <_ZN7OneWire4crc8EPKhh>
     39e:	9c 89       	ldd	r25, Y+20	; 0x14
     3a0:	89 17       	cp	r24, r25
     3a2:	19 f0       	breq	.+6      	; 0x3aa <_Z11measureTempv+0x58>
		Serial.println("CRC is not valid!");
     3a4:	6c e6       	ldi	r22, 0x6C	; 108
     3a6:	71 e0       	ldi	r23, 0x01	; 1
     3a8:	09 c0       	rjmp	.+18     	; 0x3bc <_Z11measureTempv+0x6a>
		return -1;
	}
//	Serial.println();
	
	// the first ROM byte indicates which chip
	switch (addr[0]) {
     3aa:	8d 85       	ldd	r24, Y+13	; 0x0d
     3ac:	82 32       	cpi	r24, 0x22	; 34
     3ae:	91 f0       	breq	.+36     	; 0x3d4 <_Z11measureTempv+0x82>
     3b0:	88 32       	cpi	r24, 0x28	; 40
     3b2:	81 f0       	breq	.+32     	; 0x3d4 <_Z11measureTempv+0x82>
     3b4:	80 31       	cpi	r24, 0x10	; 16
     3b6:	59 f0       	breq	.+22     	; 0x3ce <_Z11measureTempv+0x7c>
		case 0x22:
		//Serial.println("  Chip = DS1822");
		type_s = 0;
		break;
		default:
		Serial.println("Device is not a DS18x20 family device.");
     3b8:	6e e7       	ldi	r22, 0x7E	; 126
     3ba:	71 e0       	ldi	r23, 0x01	; 1
     3bc:	86 ef       	ldi	r24, 0xF6	; 246
     3be:	93 e0       	ldi	r25, 0x03	; 3
     3c0:	0e 94 20 10 	call	0x2040	; 0x2040 <_ZN5Print7printlnEPKc>
		return -1;
     3c4:	60 e0       	ldi	r22, 0x00	; 0
     3c6:	70 e0       	ldi	r23, 0x00	; 0
     3c8:	80 e8       	ldi	r24, 0x80	; 128
     3ca:	9f eb       	ldi	r25, 0xBF	; 191
     3cc:	6a c0       	rjmp	.+212    	; 0x4a2 <__LOCK_REGION_LENGTH__+0xa2>
	
	// the first ROM byte indicates which chip
	switch (addr[0]) {
		case 0x10:
		//Serial.println("  Chip = DS18S20");  // or old DS1820
		type_s = 1;
     3ce:	ff 24       	eor	r15, r15
     3d0:	f3 94       	inc	r15
     3d2:	01 c0       	rjmp	.+2      	; 0x3d6 <_Z11measureTempv+0x84>
		break;
		case 0x28:
		//Serial.println("  Chip = DS18B20");
		type_s = 0;
     3d4:	f1 2c       	mov	r15, r1
		default:
		Serial.println("Device is not a DS18x20 family device.");
		return -1;
	}

	ds.reset();
     3d6:	88 ec       	ldi	r24, 0xC8	; 200
     3d8:	93 e0       	ldi	r25, 0x03	; 3
     3da:	0e 94 1c 08 	call	0x1038	; 0x1038 <_ZN7OneWire5resetEv>
	ds.select(addr);
     3de:	be 01       	movw	r22, r28
     3e0:	63 5f       	subi	r22, 0xF3	; 243
     3e2:	7f 4f       	sbci	r23, 0xFF	; 255
     3e4:	88 ec       	ldi	r24, 0xC8	; 200
     3e6:	93 e0       	ldi	r25, 0x03	; 3
     3e8:	0e 94 09 09 	call	0x1212	; 0x1212 <_ZN7OneWire6selectEPKh>
	ds.write(0x44, 1);        // start conversion, with parasite power on at the end
     3ec:	41 e0       	ldi	r20, 0x01	; 1
     3ee:	64 e4       	ldi	r22, 0x44	; 68
     3f0:	88 ec       	ldi	r24, 0xC8	; 200
     3f2:	93 e0       	ldi	r25, 0x03	; 3
     3f4:	0e 94 b9 08 	call	0x1172	; 0x1172 <_ZN7OneWire5writeEhh>
	
	delay(1000);     // maybe 750ms is enough, maybe not
     3f8:	68 ee       	ldi	r22, 0xE8	; 232
     3fa:	73 e0       	ldi	r23, 0x03	; 3
     3fc:	80 e0       	ldi	r24, 0x00	; 0
     3fe:	90 e0       	ldi	r25, 0x00	; 0
     400:	0e 94 d5 12 	call	0x25aa	; 0x25aa <delay>
	// we might do a ds.depower() here, but the reset will take care of it.
	
	present = ds.reset();
     404:	88 ec       	ldi	r24, 0xC8	; 200
     406:	93 e0       	ldi	r25, 0x03	; 3
     408:	0e 94 1c 08 	call	0x1038	; 0x1038 <_ZN7OneWire5resetEv>
	ds.select(addr);
     40c:	be 01       	movw	r22, r28
     40e:	63 5f       	subi	r22, 0xF3	; 243
     410:	7f 4f       	sbci	r23, 0xFF	; 255
     412:	88 ec       	ldi	r24, 0xC8	; 200
     414:	93 e0       	ldi	r25, 0x03	; 3
     416:	0e 94 09 09 	call	0x1212	; 0x1212 <_ZN7OneWire6selectEPKh>
	ds.write(0xBE);         // Read Scratchpad
     41a:	40 e0       	ldi	r20, 0x00	; 0
     41c:	6e eb       	ldi	r22, 0xBE	; 190
     41e:	88 ec       	ldi	r24, 0xC8	; 200
     420:	93 e0       	ldi	r25, 0x03	; 3
     422:	0e 94 b9 08 	call	0x1172	; 0x1172 <_ZN7OneWire5writeEhh>
     426:	8e 01       	movw	r16, r28
     428:	0f 5f       	subi	r16, 0xFF	; 255
     42a:	1f 4f       	sbci	r17, 0xFF	; 255
     42c:	6e 01       	movw	r12, r28
     42e:	8a e0       	ldi	r24, 0x0A	; 10
     430:	c8 0e       	add	r12, r24
     432:	d1 1c       	adc	r13, r1

	//Serial.print("  Data = ");
	//Serial.print(present, HEX);
	//Serial.print(" ");
	for ( i = 0; i < 9; i++) {           // we need 9 bytes
		data[i] = ds.read();
     434:	88 ec       	ldi	r24, 0xC8	; 200
     436:	93 e0       	ldi	r25, 0x03	; 3
     438:	0e 94 ed 08 	call	0x11da	; 0x11da <_ZN7OneWire4readEv>
     43c:	f8 01       	movw	r30, r16
     43e:	81 93       	st	Z+, r24
     440:	8f 01       	movw	r16, r30
	ds.write(0xBE);         // Read Scratchpad

	//Serial.print("  Data = ");
	//Serial.print(present, HEX);
	//Serial.print(" ");
	for ( i = 0; i < 9; i++) {           // we need 9 bytes
     442:	ec 15       	cp	r30, r12
     444:	fd 05       	cpc	r31, r13
     446:	b1 f7       	brne	.-20     	; 0x434 <__LOCK_REGION_LENGTH__+0x34>

	// Convert the data to actual temperature
	// because the result is a 16 bit signed integer, it should
	// be stored to an "int16_t" type, which is always 16 bits
	// even when compiled on a 32 bit processor.
	int16_t raw = (data[1] << 8) | data[0];
     448:	69 81       	ldd	r22, Y+1	; 0x01
     44a:	7a 81       	ldd	r23, Y+2	; 0x02
	if (type_s) {
     44c:	ff 20       	and	r15, r15
     44e:	89 f0       	breq	.+34     	; 0x472 <__LOCK_REGION_LENGTH__+0x72>
		raw = raw << 3; // 9 bit resolution default
     450:	83 e0       	ldi	r24, 0x03	; 3
     452:	66 0f       	add	r22, r22
     454:	77 1f       	adc	r23, r23
     456:	8a 95       	dec	r24
     458:	e1 f7       	brne	.-8      	; 0x452 <__LOCK_REGION_LENGTH__+0x52>
		if (data[7] == 0x10) {
     45a:	88 85       	ldd	r24, Y+8	; 0x08
     45c:	80 31       	cpi	r24, 0x10	; 16
     45e:	a9 f4       	brne	.+42     	; 0x48a <__LOCK_REGION_LENGTH__+0x8a>
			// "count remain" gives full 12 bit resolution
			raw = (raw & 0xFFF0) + 12 - data[6];
     460:	2f 81       	ldd	r18, Y+7	; 0x07
     462:	8c e0       	ldi	r24, 0x0C	; 12
     464:	90 e0       	ldi	r25, 0x00	; 0
     466:	82 1b       	sub	r24, r18
     468:	91 09       	sbc	r25, r1
     46a:	60 7f       	andi	r22, 0xF0	; 240
     46c:	68 0f       	add	r22, r24
     46e:	79 1f       	adc	r23, r25
     470:	0c c0       	rjmp	.+24     	; 0x48a <__LOCK_REGION_LENGTH__+0x8a>
		}
		} else {
		byte cfg = (data[4] & 0x60);
     472:	8d 81       	ldd	r24, Y+5	; 0x05
     474:	80 76       	andi	r24, 0x60	; 96
		// at lower res, the low bits are undefined, so let's zero them
		if (cfg == 0x00) raw = raw & ~7;  // 9 bit resolution, 93.75 ms
     476:	11 f4       	brne	.+4      	; 0x47c <__LOCK_REGION_LENGTH__+0x7c>
     478:	68 7f       	andi	r22, 0xF8	; 248
     47a:	07 c0       	rjmp	.+14     	; 0x48a <__LOCK_REGION_LENGTH__+0x8a>
		else if (cfg == 0x20) raw = raw & ~3; // 10 bit res, 187.5 ms
     47c:	80 32       	cpi	r24, 0x20	; 32
     47e:	11 f4       	brne	.+4      	; 0x484 <__LOCK_REGION_LENGTH__+0x84>
     480:	6c 7f       	andi	r22, 0xFC	; 252
     482:	03 c0       	rjmp	.+6      	; 0x48a <__LOCK_REGION_LENGTH__+0x8a>
		else if (cfg == 0x40) raw = raw & ~1; // 11 bit res, 375 ms
     484:	80 34       	cpi	r24, 0x40	; 64
     486:	09 f4       	brne	.+2      	; 0x48a <__LOCK_REGION_LENGTH__+0x8a>
     488:	6e 7f       	andi	r22, 0xFE	; 254
		//// default is 12 bit resolution, 750 ms conversion time
	}
	celsius = (float)raw / 16.0;
     48a:	07 2e       	mov	r0, r23
     48c:	00 0c       	add	r0, r0
     48e:	88 0b       	sbc	r24, r24
     490:	99 0b       	sbc	r25, r25
     492:	0e 94 c4 0c 	call	0x1988	; 0x1988 <__floatsisf>
     496:	20 e0       	ldi	r18, 0x00	; 0
     498:	30 e0       	ldi	r19, 0x00	; 0
     49a:	40 e8       	ldi	r20, 0x80	; 128
     49c:	5d e3       	ldi	r21, 0x3D	; 61
     49e:	0e 94 79 0d 	call	0x1af2	; 0x1af2 <__mulsf3>
	//Serial.print(celsius);
	//Serial.print(" Celsius, ");
	//Serial.print(fahrenheit);
	//Serial.println(" Fahrenheit");
	return celsius;
     4a2:	64 96       	adiw	r28, 0x14	; 20
     4a4:	0f b6       	in	r0, 0x3f	; 63
     4a6:	f8 94       	cli
     4a8:	de bf       	out	0x3e, r29	; 62
     4aa:	0f be       	out	0x3f, r0	; 63
     4ac:	cd bf       	out	0x3d, r28	; 61
     4ae:	df 91       	pop	r29
     4b0:	cf 91       	pop	r28
     4b2:	1f 91       	pop	r17
     4b4:	0f 91       	pop	r16
     4b6:	ff 90       	pop	r15
     4b8:	df 90       	pop	r13
     4ba:	cf 90       	pop	r12
     4bc:	08 95       	ret

000004be <_Z9addColorsv>:
MD_TCS230  CS(S2, S3, OE);


// add possible color strip values to specific arrays
void addColors()
{
     4be:	0f 93       	push	r16
     4c0:	1f 93       	push	r17
     4c2:	cf 93       	push	r28
     4c4:	df 93       	push	r29
	int index = 0;
	Color c;
	c.ppm = 0.0;
	c.p = {0, 0, 0};
	Ammonia[index] = c;
     4c6:	c5 e9       	ldi	r28, 0x95	; 149
     4c8:	d3 e0       	ldi	r29, 0x03	; 3
     4ca:	18 82       	st	Y, r1
     4cc:	19 82       	std	Y+1, r1	; 0x01
     4ce:	1a 82       	std	Y+2, r1	; 0x02
     4d0:	1b 82       	std	Y+3, r1	; 0x03
     4d2:	1d 82       	std	Y+5, r1	; 0x05
     4d4:	1c 82       	std	Y+4, r1	; 0x04
     4d6:	1f 82       	std	Y+7, r1	; 0x07
     4d8:	1e 82       	std	Y+6, r1	; 0x06
     4da:	19 86       	std	Y+9, r1	; 0x09
     4dc:	18 86       	std	Y+8, r1	; 0x08

	c.ppm = 0.0;
	c.p = {255, 95, 95};
	Nitrite[index] = c;
     4de:	af e4       	ldi	r26, 0x4F	; 79
     4e0:	b3 e0       	ldi	r27, 0x03	; 3
     4e2:	1d 92       	st	X+, r1
     4e4:	1d 92       	st	X+, r1
     4e6:	1d 92       	st	X+, r1
     4e8:	1c 92       	st	X, r1
     4ea:	13 97       	sbiw	r26, 0x03	; 3
     4ec:	2f ef       	ldi	r18, 0xFF	; 255
     4ee:	30 e0       	ldi	r19, 0x00	; 0
     4f0:	15 96       	adiw	r26, 0x05	; 5
     4f2:	3c 93       	st	X, r19
     4f4:	2e 93       	st	-X, r18
     4f6:	14 97       	sbiw	r26, 0x04	; 4
     4f8:	8f e5       	ldi	r24, 0x5F	; 95
     4fa:	90 e0       	ldi	r25, 0x00	; 0
     4fc:	17 96       	adiw	r26, 0x07	; 7
     4fe:	9c 93       	st	X, r25
     500:	8e 93       	st	-X, r24
     502:	16 97       	sbiw	r26, 0x06	; 6
     504:	19 96       	adiw	r26, 0x09	; 9
     506:	9c 93       	st	X, r25
     508:	8e 93       	st	-X, r24
     50a:	18 97       	sbiw	r26, 0x08	; 8

	c.ppm = 0.0;
	c.p = {255, 95, 95};
	Nitrate[index] = c;
     50c:	e9 e0       	ldi	r30, 0x09	; 9
     50e:	f3 e0       	ldi	r31, 0x03	; 3
     510:	10 82       	st	Z, r1
     512:	11 82       	std	Z+1, r1	; 0x01
     514:	12 82       	std	Z+2, r1	; 0x02
     516:	13 82       	std	Z+3, r1	; 0x03
     518:	35 83       	std	Z+5, r19	; 0x05
     51a:	24 83       	std	Z+4, r18	; 0x04
     51c:	97 83       	std	Z+7, r25	; 0x07
     51e:	86 83       	std	Z+6, r24	; 0x06
     520:	91 87       	std	Z+9, r25	; 0x09
     522:	80 87       	std	Z+8, r24	; 0x08

	++index;

	c.ppm = 0.25;
	c.p = {0, 0, 0};
	Ammonia[index] = c;
     524:	40 e0       	ldi	r20, 0x00	; 0
     526:	50 e0       	ldi	r21, 0x00	; 0
     528:	60 e8       	ldi	r22, 0x80	; 128
     52a:	7e e3       	ldi	r23, 0x3E	; 62
     52c:	4a 87       	std	Y+10, r20	; 0x0a
     52e:	5b 87       	std	Y+11, r21	; 0x0b
     530:	6c 87       	std	Y+12, r22	; 0x0c
     532:	7d 87       	std	Y+13, r23	; 0x0d
     534:	1f 86       	std	Y+15, r1	; 0x0f
     536:	1e 86       	std	Y+14, r1	; 0x0e
     538:	19 8a       	std	Y+17, r1	; 0x11
     53a:	18 8a       	std	Y+16, r1	; 0x10
     53c:	1b 8a       	std	Y+19, r1	; 0x13
     53e:	1a 8a       	std	Y+18, r1	; 0x12

	c.ppm = 0.15;
	c.p = {0, 0, 0};
	Nitrite[index] = c;
     540:	4a e9       	ldi	r20, 0x9A	; 154
     542:	59 e9       	ldi	r21, 0x99	; 153
     544:	69 e1       	ldi	r22, 0x19	; 25
     546:	7e e3       	ldi	r23, 0x3E	; 62
     548:	1a 96       	adiw	r26, 0x0a	; 10
     54a:	4d 93       	st	X+, r20
     54c:	5d 93       	st	X+, r21
     54e:	6d 93       	st	X+, r22
     550:	7c 93       	st	X, r23
     552:	1d 97       	sbiw	r26, 0x0d	; 13
     554:	1f 96       	adiw	r26, 0x0f	; 15
     556:	1c 92       	st	X, r1
     558:	1e 92       	st	-X, r1
     55a:	1e 97       	sbiw	r26, 0x0e	; 14
     55c:	51 96       	adiw	r26, 0x11	; 17
     55e:	1c 92       	st	X, r1
     560:	1e 92       	st	-X, r1
     562:	50 97       	sbiw	r26, 0x10	; 16
     564:	53 96       	adiw	r26, 0x13	; 19
     566:	1c 92       	st	X, r1
     568:	1e 92       	st	-X, r1
     56a:	52 97       	sbiw	r26, 0x12	; 18

	c.ppm = 0.5;
	c.p = {0, 0, 0};
	Nitrate[index] = c;
     56c:	40 e0       	ldi	r20, 0x00	; 0
     56e:	50 e0       	ldi	r21, 0x00	; 0
     570:	60 e0       	ldi	r22, 0x00	; 0
     572:	7f e3       	ldi	r23, 0x3F	; 63
     574:	42 87       	std	Z+10, r20	; 0x0a
     576:	53 87       	std	Z+11, r21	; 0x0b
     578:	64 87       	std	Z+12, r22	; 0x0c
     57a:	75 87       	std	Z+13, r23	; 0x0d
     57c:	17 86       	std	Z+15, r1	; 0x0f
     57e:	16 86       	std	Z+14, r1	; 0x0e
     580:	11 8a       	std	Z+17, r1	; 0x11
     582:	10 8a       	std	Z+16, r1	; 0x10
     584:	13 8a       	std	Z+19, r1	; 0x13
     586:	12 8a       	std	Z+18, r1	; 0x12

	++index;

	c.ppm = 0.5;
	c.p = {0, 0, 0};
	Ammonia[index] = c;
     588:	4c 8b       	std	Y+20, r20	; 0x14
     58a:	5d 8b       	std	Y+21, r21	; 0x15
     58c:	6e 8b       	std	Y+22, r22	; 0x16
     58e:	7f 8b       	std	Y+23, r23	; 0x17
     590:	19 8e       	std	Y+25, r1	; 0x19
     592:	18 8e       	std	Y+24, r1	; 0x18
     594:	1b 8e       	std	Y+27, r1	; 0x1b
     596:	1a 8e       	std	Y+26, r1	; 0x1a
     598:	1d 8e       	std	Y+29, r1	; 0x1d
     59a:	1c 8e       	std	Y+28, r1	; 0x1c

	c.ppm = 0.3;
	c.p = {0, 0, 0};
	Nitrite[index] = c;
     59c:	4a e9       	ldi	r20, 0x9A	; 154
     59e:	59 e9       	ldi	r21, 0x99	; 153
     5a0:	69 e9       	ldi	r22, 0x99	; 153
     5a2:	7e e3       	ldi	r23, 0x3E	; 62
     5a4:	54 96       	adiw	r26, 0x14	; 20
     5a6:	4d 93       	st	X+, r20
     5a8:	5d 93       	st	X+, r21
     5aa:	6d 93       	st	X+, r22
     5ac:	7c 93       	st	X, r23
     5ae:	57 97       	sbiw	r26, 0x17	; 23
     5b0:	59 96       	adiw	r26, 0x19	; 25
     5b2:	1c 92       	st	X, r1
     5b4:	1e 92       	st	-X, r1
     5b6:	58 97       	sbiw	r26, 0x18	; 24
     5b8:	5b 96       	adiw	r26, 0x1b	; 27
     5ba:	1c 92       	st	X, r1
     5bc:	1e 92       	st	-X, r1
     5be:	5a 97       	sbiw	r26, 0x1a	; 26
     5c0:	5d 96       	adiw	r26, 0x1d	; 29
     5c2:	1c 92       	st	X, r1
     5c4:	1e 92       	st	-X, r1
     5c6:	5c 97       	sbiw	r26, 0x1c	; 28

	c.ppm = 2.0;
	c.p = {0, 0, 0};
	Nitrate[index] = c;
     5c8:	40 e0       	ldi	r20, 0x00	; 0
     5ca:	50 e0       	ldi	r21, 0x00	; 0
     5cc:	60 e0       	ldi	r22, 0x00	; 0
     5ce:	70 e4       	ldi	r23, 0x40	; 64
     5d0:	44 8b       	std	Z+20, r20	; 0x14
     5d2:	55 8b       	std	Z+21, r21	; 0x15
     5d4:	66 8b       	std	Z+22, r22	; 0x16
     5d6:	77 8b       	std	Z+23, r23	; 0x17
     5d8:	11 8e       	std	Z+25, r1	; 0x19
     5da:	10 8e       	std	Z+24, r1	; 0x18
     5dc:	13 8e       	std	Z+27, r1	; 0x1b
     5de:	12 8e       	std	Z+26, r1	; 0x1a
     5e0:	15 8e       	std	Z+29, r1	; 0x1d
     5e2:	14 8e       	std	Z+28, r1	; 0x1c

	++index;

	c.ppm = 3.0;
	c.p = {0, 0, 0};
	Ammonia[index] = c;
     5e4:	00 e0       	ldi	r16, 0x00	; 0
     5e6:	10 e0       	ldi	r17, 0x00	; 0
     5e8:	20 e4       	ldi	r18, 0x40	; 64
     5ea:	30 e4       	ldi	r19, 0x40	; 64
     5ec:	0e 8f       	std	Y+30, r16	; 0x1e
     5ee:	1f 8f       	std	Y+31, r17	; 0x1f
     5f0:	28 a3       	std	Y+32, r18	; 0x20
     5f2:	39 a3       	std	Y+33, r19	; 0x21
     5f4:	1b a2       	std	Y+35, r1	; 0x23
     5f6:	1a a2       	std	Y+34, r1	; 0x22
     5f8:	1d a2       	std	Y+37, r1	; 0x25
     5fa:	1c a2       	std	Y+36, r1	; 0x24
     5fc:	1f a2       	std	Y+39, r1	; 0x27
     5fe:	1e a2       	std	Y+38, r1	; 0x26

	c.ppm = 1.0;
	c.p = {0, 0, 0};
	Nitrite[index] = c;
     600:	40 e0       	ldi	r20, 0x00	; 0
     602:	50 e0       	ldi	r21, 0x00	; 0
     604:	60 e8       	ldi	r22, 0x80	; 128
     606:	7f e3       	ldi	r23, 0x3F	; 63
     608:	5e 96       	adiw	r26, 0x1e	; 30
     60a:	4d 93       	st	X+, r20
     60c:	5d 93       	st	X+, r21
     60e:	6d 93       	st	X+, r22
     610:	7c 93       	st	X, r23
     612:	91 97       	sbiw	r26, 0x21	; 33
     614:	93 96       	adiw	r26, 0x23	; 35
     616:	1c 92       	st	X, r1
     618:	1e 92       	st	-X, r1
     61a:	92 97       	sbiw	r26, 0x22	; 34
     61c:	95 96       	adiw	r26, 0x25	; 37
     61e:	1c 92       	st	X, r1
     620:	1e 92       	st	-X, r1
     622:	94 97       	sbiw	r26, 0x24	; 36
     624:	97 96       	adiw	r26, 0x27	; 39
     626:	1c 92       	st	X, r1
     628:	1e 92       	st	-X, r1
     62a:	96 97       	sbiw	r26, 0x26	; 38

	c.ppm = 5.0;
	c.p = {0, 0, 0};
	Nitrate[index] = c;
     62c:	40 e0       	ldi	r20, 0x00	; 0
     62e:	50 e0       	ldi	r21, 0x00	; 0
     630:	60 ea       	ldi	r22, 0xA0	; 160
     632:	70 e4       	ldi	r23, 0x40	; 64
     634:	46 8f       	std	Z+30, r20	; 0x1e
     636:	57 8f       	std	Z+31, r21	; 0x1f
     638:	60 a3       	std	Z+32, r22	; 0x20
     63a:	71 a3       	std	Z+33, r23	; 0x21
     63c:	13 a2       	std	Z+35, r1	; 0x23
     63e:	12 a2       	std	Z+34, r1	; 0x22
     640:	15 a2       	std	Z+37, r1	; 0x25
     642:	14 a2       	std	Z+36, r1	; 0x24
     644:	17 a2       	std	Z+39, r1	; 0x27
     646:	16 a2       	std	Z+38, r1	; 0x26

	++index;

	c.ppm = 6.0;
	c.p = {0, 0, 0};
	Ammonia[index] = c;
     648:	40 e0       	ldi	r20, 0x00	; 0
     64a:	50 e0       	ldi	r21, 0x00	; 0
     64c:	60 ec       	ldi	r22, 0xC0	; 192
     64e:	70 e4       	ldi	r23, 0x40	; 64
     650:	48 a7       	std	Y+40, r20	; 0x28
     652:	59 a7       	std	Y+41, r21	; 0x29
     654:	6a a7       	std	Y+42, r22	; 0x2a
     656:	7b a7       	std	Y+43, r23	; 0x2b
     658:	1d a6       	std	Y+45, r1	; 0x2d
     65a:	1c a6       	std	Y+44, r1	; 0x2c
     65c:	1f a6       	std	Y+47, r1	; 0x2f
     65e:	1e a6       	std	Y+46, r1	; 0x2e
     660:	19 aa       	std	Y+49, r1	; 0x31
     662:	18 aa       	std	Y+48, r1	; 0x30

	c.ppm = 1.5;
	c.p = {0, 0, 0};
	Nitrite[index] = c;
     664:	40 e0       	ldi	r20, 0x00	; 0
     666:	50 e0       	ldi	r21, 0x00	; 0
     668:	60 ec       	ldi	r22, 0xC0	; 192
     66a:	7f e3       	ldi	r23, 0x3F	; 63
     66c:	98 96       	adiw	r26, 0x28	; 40
     66e:	4d 93       	st	X+, r20
     670:	5d 93       	st	X+, r21
     672:	6d 93       	st	X+, r22
     674:	7c 93       	st	X, r23
     676:	9b 97       	sbiw	r26, 0x2b	; 43
     678:	9d 96       	adiw	r26, 0x2d	; 45
     67a:	1c 92       	st	X, r1
     67c:	1e 92       	st	-X, r1
     67e:	9c 97       	sbiw	r26, 0x2c	; 44
     680:	9f 96       	adiw	r26, 0x2f	; 47
     682:	1c 92       	st	X, r1
     684:	1e 92       	st	-X, r1
     686:	9e 97       	sbiw	r26, 0x2e	; 46
     688:	d1 96       	adiw	r26, 0x31	; 49
     68a:	1c 92       	st	X, r1
     68c:	1e 92       	st	-X, r1
     68e:	d0 97       	sbiw	r26, 0x30	; 48

	c.ppm = 10.0;
	c.p = {0, 0, 0};
	Nitrate[index] = c;
     690:	40 e0       	ldi	r20, 0x00	; 0
     692:	50 e0       	ldi	r21, 0x00	; 0
     694:	60 e2       	ldi	r22, 0x20	; 32
     696:	71 e4       	ldi	r23, 0x41	; 65
     698:	40 a7       	std	Z+40, r20	; 0x28
     69a:	51 a7       	std	Z+41, r21	; 0x29
     69c:	62 a7       	std	Z+42, r22	; 0x2a
     69e:	73 a7       	std	Z+43, r23	; 0x2b
     6a0:	15 a6       	std	Z+45, r1	; 0x2d
     6a2:	14 a6       	std	Z+44, r1	; 0x2c
     6a4:	17 a6       	std	Z+47, r1	; 0x2f
     6a6:	16 a6       	std	Z+46, r1	; 0x2e
     6a8:	11 aa       	std	Z+49, r1	; 0x31
     6aa:	10 aa       	std	Z+48, r1	; 0x30

	++index;

	c.ppm = 3.0;
	c.p = {0, 0, 0};
	Nitrite[index] = c;
     6ac:	d2 96       	adiw	r26, 0x32	; 50
     6ae:	0d 93       	st	X+, r16
     6b0:	1d 93       	st	X+, r17
     6b2:	2d 93       	st	X+, r18
     6b4:	3c 93       	st	X, r19
     6b6:	d5 97       	sbiw	r26, 0x35	; 53
     6b8:	d7 96       	adiw	r26, 0x37	; 55
     6ba:	1c 92       	st	X, r1
     6bc:	1e 92       	st	-X, r1
     6be:	d6 97       	sbiw	r26, 0x36	; 54
     6c0:	d9 96       	adiw	r26, 0x39	; 57
     6c2:	1c 92       	st	X, r1
     6c4:	1e 92       	st	-X, r1
     6c6:	d8 97       	sbiw	r26, 0x38	; 56
     6c8:	db 96       	adiw	r26, 0x3b	; 59
     6ca:	1c 92       	st	X, r1
     6cc:	1e 92       	st	-X, r1
     6ce:	da 97       	sbiw	r26, 0x3a	; 58

	c.ppm = 20.0;
	c.p = {0, 0, 0};
	Nitrate[index] = c;
     6d0:	00 e0       	ldi	r16, 0x00	; 0
     6d2:	10 e0       	ldi	r17, 0x00	; 0
     6d4:	20 ea       	ldi	r18, 0xA0	; 160
     6d6:	31 e4       	ldi	r19, 0x41	; 65
     6d8:	02 ab       	std	Z+50, r16	; 0x32
     6da:	13 ab       	std	Z+51, r17	; 0x33
     6dc:	24 ab       	std	Z+52, r18	; 0x34
     6de:	35 ab       	std	Z+53, r19	; 0x35
     6e0:	17 aa       	std	Z+55, r1	; 0x37
     6e2:	16 aa       	std	Z+54, r1	; 0x36
     6e4:	11 ae       	std	Z+57, r1	; 0x39
     6e6:	10 ae       	std	Z+56, r1	; 0x38
     6e8:	13 ae       	std	Z+59, r1	; 0x3b
     6ea:	12 ae       	std	Z+58, r1	; 0x3a

	++index;

	c.ppm = 10.0;
	c.p = {0, 0, 0};
	Nitrite[index] = c;
     6ec:	dc 96       	adiw	r26, 0x3c	; 60
     6ee:	4d 93       	st	X+, r20
     6f0:	5d 93       	st	X+, r21
     6f2:	6d 93       	st	X+, r22
     6f4:	7c 93       	st	X, r23
     6f6:	df 97       	sbiw	r26, 0x3f	; 63
     6f8:	10 92 90 03 	sts	0x0390, r1	; 0x800390 <Nitrite+0x41>
     6fc:	10 92 8f 03 	sts	0x038F, r1	; 0x80038f <Nitrite+0x40>
     700:	10 92 92 03 	sts	0x0392, r1	; 0x800392 <Nitrite+0x43>
     704:	10 92 91 03 	sts	0x0391, r1	; 0x800391 <Nitrite+0x42>
     708:	10 92 94 03 	sts	0x0394, r1	; 0x800394 <Nitrite+0x45>
     70c:	10 92 93 03 	sts	0x0393, r1	; 0x800393 <Nitrite+0x44>

	c.ppm = 50.0;
	c.p = {0, 0, 0};
	Nitrate[index] = c;
     710:	80 e0       	ldi	r24, 0x00	; 0
     712:	90 e0       	ldi	r25, 0x00	; 0
     714:	a8 e4       	ldi	r26, 0x48	; 72
     716:	b2 e4       	ldi	r27, 0x42	; 66
     718:	84 af       	std	Z+60, r24	; 0x3c
     71a:	95 af       	std	Z+61, r25	; 0x3d
     71c:	a6 af       	std	Z+62, r26	; 0x3e
     71e:	b7 af       	std	Z+63, r27	; 0x3f
     720:	10 92 4a 03 	sts	0x034A, r1	; 0x80034a <Nitrate+0x41>
     724:	10 92 49 03 	sts	0x0349, r1	; 0x800349 <Nitrate+0x40>
     728:	10 92 4c 03 	sts	0x034C, r1	; 0x80034c <Nitrate+0x43>
     72c:	10 92 4b 03 	sts	0x034B, r1	; 0x80034b <Nitrate+0x42>
     730:	10 92 4e 03 	sts	0x034E, r1	; 0x80034e <Nitrate+0x45>
     734:	10 92 4d 03 	sts	0x034D, r1	; 0x80034d <Nitrate+0x44>
}
     738:	df 91       	pop	r29
     73a:	cf 91       	pop	r28
     73c:	1f 91       	pop	r17
     73e:	0f 91       	pop	r16
     740:	08 95       	ret

00000742 <_Z9SameColorv>:


bool SameColor()
{
	Serial.print("c: ");
     742:	65 ea       	ldi	r22, 0xA5	; 165
     744:	71 e0       	ldi	r23, 0x01	; 1
     746:	86 ef       	ldi	r24, 0xF6	; 246
     748:	93 e0       	ldi	r25, 0x03	; 3
     74a:	0e 94 13 10 	call	0x2026	; 0x2026 <_ZN5Print5printEPKc>
	Serial.print(c.p.R);
     74e:	60 91 00 03 	lds	r22, 0x0300	; 0x800300 <c+0x4>
     752:	70 91 01 03 	lds	r23, 0x0301	; 0x800301 <c+0x5>
     756:	4a e0       	ldi	r20, 0x0A	; 10
     758:	50 e0       	ldi	r21, 0x00	; 0
     75a:	86 ef       	ldi	r24, 0xF6	; 246
     75c:	93 e0       	ldi	r25, 0x03	; 3
     75e:	0e 94 ef 10 	call	0x21de	; 0x21de <_ZN5Print5printEii>
	Serial.print(" ");
     762:	67 ea       	ldi	r22, 0xA7	; 167
     764:	71 e0       	ldi	r23, 0x01	; 1
     766:	86 ef       	ldi	r24, 0xF6	; 246
     768:	93 e0       	ldi	r25, 0x03	; 3
     76a:	0e 94 13 10 	call	0x2026	; 0x2026 <_ZN5Print5printEPKc>
	Serial.print(c.p.G);
     76e:	60 91 02 03 	lds	r22, 0x0302	; 0x800302 <c+0x6>
     772:	70 91 03 03 	lds	r23, 0x0303	; 0x800303 <c+0x7>
     776:	4a e0       	ldi	r20, 0x0A	; 10
     778:	50 e0       	ldi	r21, 0x00	; 0
     77a:	86 ef       	ldi	r24, 0xF6	; 246
     77c:	93 e0       	ldi	r25, 0x03	; 3
     77e:	0e 94 ef 10 	call	0x21de	; 0x21de <_ZN5Print5printEii>
	Serial.print(" ");
     782:	67 ea       	ldi	r22, 0xA7	; 167
     784:	71 e0       	ldi	r23, 0x01	; 1
     786:	86 ef       	ldi	r24, 0xF6	; 246
     788:	93 e0       	ldi	r25, 0x03	; 3
     78a:	0e 94 13 10 	call	0x2026	; 0x2026 <_ZN5Print5printEPKc>
	Serial.print(c.p.B);
     78e:	60 91 04 03 	lds	r22, 0x0304	; 0x800304 <c+0x8>
     792:	70 91 05 03 	lds	r23, 0x0305	; 0x800305 <c+0x9>
     796:	4a e0       	ldi	r20, 0x0A	; 10
     798:	50 e0       	ldi	r21, 0x00	; 0
     79a:	86 ef       	ldi	r24, 0xF6	; 246
     79c:	93 e0       	ldi	r25, 0x03	; 3
     79e:	0e 94 ef 10 	call	0x21de	; 0x21de <_ZN5Print5printEii>
	Serial.print("read_in: ");
     7a2:	69 ea       	ldi	r22, 0xA9	; 169
     7a4:	71 e0       	ldi	r23, 0x01	; 1
     7a6:	86 ef       	ldi	r24, 0xF6	; 246
     7a8:	93 e0       	ldi	r25, 0x03	; 3
     7aa:	0e 94 13 10 	call	0x2026	; 0x2026 <_ZN5Print5printEPKc>
	Serial.print(redScanned);
     7ae:	4a e0       	ldi	r20, 0x0A	; 10
     7b0:	50 e0       	ldi	r21, 0x00	; 0
     7b2:	60 91 fa 02 	lds	r22, 0x02FA	; 0x8002fa <redScanned>
     7b6:	86 ef       	ldi	r24, 0xF6	; 246
     7b8:	93 e0       	ldi	r25, 0x03	; 3
     7ba:	0e 94 88 10 	call	0x2110	; 0x2110 <_ZN5Print5printEhi>
	Serial.print(" ");
     7be:	67 ea       	ldi	r22, 0xA7	; 167
     7c0:	71 e0       	ldi	r23, 0x01	; 1
     7c2:	86 ef       	ldi	r24, 0xF6	; 246
     7c4:	93 e0       	ldi	r25, 0x03	; 3
     7c6:	0e 94 13 10 	call	0x2026	; 0x2026 <_ZN5Print5printEPKc>
	Serial.print(greenScanned);
     7ca:	4a e0       	ldi	r20, 0x0A	; 10
     7cc:	50 e0       	ldi	r21, 0x00	; 0
     7ce:	60 91 fb 02 	lds	r22, 0x02FB	; 0x8002fb <greenScanned>
     7d2:	86 ef       	ldi	r24, 0xF6	; 246
     7d4:	93 e0       	ldi	r25, 0x03	; 3
     7d6:	0e 94 88 10 	call	0x2110	; 0x2110 <_ZN5Print5printEhi>
	Serial.print(" ");
     7da:	67 ea       	ldi	r22, 0xA7	; 167
     7dc:	71 e0       	ldi	r23, 0x01	; 1
     7de:	86 ef       	ldi	r24, 0xF6	; 246
     7e0:	93 e0       	ldi	r25, 0x03	; 3
     7e2:	0e 94 13 10 	call	0x2026	; 0x2026 <_ZN5Print5printEPKc>
	Serial.print(blueScanned);
     7e6:	4a e0       	ldi	r20, 0x0A	; 10
     7e8:	50 e0       	ldi	r21, 0x00	; 0
     7ea:	60 91 f9 02 	lds	r22, 0x02F9	; 0x8002f9 <blueScanned>
     7ee:	86 ef       	ldi	r24, 0xF6	; 246
     7f0:	93 e0       	ldi	r25, 0x03	; 3
     7f2:	0e 94 88 10 	call	0x2110	; 0x2110 <_ZN5Print5printEhi>
	// check if RGB values are within range specified by tolerance
	if (redScanned < (c.p.R - TOLERANCE) || redScanned > (c.p.R + TOLERANCE))
     7f6:	20 91 fa 02 	lds	r18, 0x02FA	; 0x8002fa <redScanned>
     7fa:	30 e0       	ldi	r19, 0x00	; 0
     7fc:	80 91 00 03 	lds	r24, 0x0300	; 0x800300 <c+0x4>
     800:	90 91 01 03 	lds	r25, 0x0301	; 0x800301 <c+0x5>
     804:	ac 01       	movw	r20, r24
     806:	45 50       	subi	r20, 0x05	; 5
     808:	51 09       	sbc	r21, r1
     80a:	24 17       	cp	r18, r20
     80c:	35 07       	cpc	r19, r21
     80e:	74 f1       	brlt	.+92     	; 0x86c <_Z9SameColorv+0x12a>
     810:	05 96       	adiw	r24, 0x05	; 5
     812:	82 17       	cp	r24, r18
     814:	93 07       	cpc	r25, r19
     816:	54 f1       	brlt	.+84     	; 0x86c <_Z9SameColorv+0x12a>
		return false;
	if (greenScanned < (c.p.G - TOLERANCE) || greenScanned > (c.p.G + TOLERANCE))
     818:	20 91 fb 02 	lds	r18, 0x02FB	; 0x8002fb <greenScanned>
     81c:	30 e0       	ldi	r19, 0x00	; 0
     81e:	80 91 02 03 	lds	r24, 0x0302	; 0x800302 <c+0x6>
     822:	90 91 03 03 	lds	r25, 0x0303	; 0x800303 <c+0x7>
     826:	ac 01       	movw	r20, r24
     828:	45 50       	subi	r20, 0x05	; 5
     82a:	51 09       	sbc	r21, r1
     82c:	24 17       	cp	r18, r20
     82e:	35 07       	cpc	r19, r21
     830:	ec f0       	brlt	.+58     	; 0x86c <_Z9SameColorv+0x12a>
     832:	05 96       	adiw	r24, 0x05	; 5
     834:	82 17       	cp	r24, r18
     836:	93 07       	cpc	r25, r19
     838:	cc f0       	brlt	.+50     	; 0x86c <_Z9SameColorv+0x12a>
		return false;
	if (blueScanned < (c.p.B - TOLERANCE) || blueScanned > (c.p.B + TOLERANCE))
     83a:	20 91 f9 02 	lds	r18, 0x02F9	; 0x8002f9 <blueScanned>
     83e:	30 e0       	ldi	r19, 0x00	; 0
     840:	80 91 04 03 	lds	r24, 0x0304	; 0x800304 <c+0x8>
     844:	90 91 05 03 	lds	r25, 0x0305	; 0x800305 <c+0x9>
     848:	ac 01       	movw	r20, r24
     84a:	45 50       	subi	r20, 0x05	; 5
     84c:	51 09       	sbc	r21, r1
     84e:	24 17       	cp	r18, r20
     850:	35 07       	cpc	r19, r21
     852:	64 f0       	brlt	.+24     	; 0x86c <_Z9SameColorv+0x12a>
     854:	05 96       	adiw	r24, 0x05	; 5
     856:	82 17       	cp	r24, r18
     858:	93 07       	cpc	r25, r19
     85a:	44 f0       	brlt	.+16     	; 0x86c <_Z9SameColorv+0x12a>
		return false;
	
	Serial.print(F("\nFound Matching Color"));
     85c:	6c e7       	ldi	r22, 0x7C	; 124
     85e:	70 e0       	ldi	r23, 0x00	; 0
     860:	86 ef       	ldi	r24, 0xF6	; 246
     862:	93 e0       	ldi	r25, 0x03	; 3
     864:	0e 94 ef 0f 	call	0x1fde	; 0x1fde <_ZN5Print5printEPK19__FlashStringHelper>
	return true;
     868:	81 e0       	ldi	r24, 0x01	; 1
     86a:	08 95       	ret
	Serial.print(greenScanned);
	Serial.print(" ");
	Serial.print(blueScanned);
	// check if RGB values are within range specified by tolerance
	if (redScanned < (c.p.R - TOLERANCE) || redScanned > (c.p.R + TOLERANCE))
		return false;
     86c:	80 e0       	ldi	r24, 0x00	; 0
	if (blueScanned < (c.p.B - TOLERANCE) || blueScanned > (c.p.B + TOLERANCE))
		return false;
	
	Serial.print(F("\nFound Matching Color"));
	return true;
}
     86e:	08 95       	ret

00000870 <_Z9FindMatchv>:

double FindMatch()
{
     870:	0f 93       	push	r16
     872:	1f 93       	push	r17
     874:	cf 93       	push	r28
     876:	df 93       	push	r29
	switch(typeToRead)
     878:	80 91 c7 03 	lds	r24, 0x03C7	; 0x8003c7 <typeToRead>
     87c:	81 30       	cpi	r24, 0x01	; 1
     87e:	09 f4       	brne	.+2      	; 0x882 <_Z9FindMatchv+0x12>
     880:	48 c0       	rjmp	.+144    	; 0x912 <__stack+0x13>
     882:	40 f0       	brcs	.+16     	; 0x894 <_Z9FindMatchv+0x24>
     884:	82 30       	cpi	r24, 0x02	; 2
     886:	09 f0       	breq	.+2      	; 0x88a <_Z9FindMatchv+0x1a>
     888:	6e c0       	rjmp	.+220    	; 0x966 <__stack+0x67>
     88a:	0f e4       	ldi	r16, 0x4F	; 79
     88c:	13 e0       	ldi	r17, 0x03	; 3
     88e:	c6 e0       	ldi	r28, 0x06	; 6
     890:	d0 e0       	ldi	r29, 0x00	; 0
     892:	29 c0       	rjmp	.+82     	; 0x8e6 <_Z9FindMatchv+0x76>
     894:	05 e9       	ldi	r16, 0x95	; 149
     896:	13 e0       	ldi	r17, 0x03	; 3
     898:	c4 e0       	ldi	r28, 0x04	; 4
     89a:	d0 e0       	ldi	r29, 0x00	; 0
		case AMMONIA:
		{
			// start at highest ammonia level - false positive better than false negative
			for(int i = MAX_AMMONIA_COLORS - 1; i >= 0; --i)
			{
				c = Ammonia[i];
     89c:	8a e0       	ldi	r24, 0x0A	; 10
     89e:	f8 01       	movw	r30, r16
     8a0:	b8 96       	adiw	r30, 0x28	; 40
     8a2:	ac ef       	ldi	r26, 0xFC	; 252
     8a4:	b2 e0       	ldi	r27, 0x02	; 2
     8a6:	01 90       	ld	r0, Z+
     8a8:	0d 92       	st	X+, r0
     8aa:	8a 95       	dec	r24
     8ac:	e1 f7       	brne	.-8      	; 0x8a6 <_Z9FindMatchv+0x36>
				if(SameColor())
     8ae:	0e 94 a1 03 	call	0x742	; 0x742 <_Z9SameColorv>
     8b2:	88 23       	and	r24, r24
     8b4:	49 f0       	breq	.+18     	; 0x8c8 <_Z9FindMatchv+0x58>
				return Ammonia[i].ppm;
     8b6:	8a e0       	ldi	r24, 0x0A	; 10
     8b8:	8c 9f       	mul	r24, r28
     8ba:	f0 01       	movw	r30, r0
     8bc:	8d 9f       	mul	r24, r29
     8be:	f0 0d       	add	r31, r0
     8c0:	11 24       	eor	r1, r1
     8c2:	eb 56       	subi	r30, 0x6B	; 107
     8c4:	fc 4f       	sbci	r31, 0xFC	; 252
     8c6:	3e c0       	rjmp	.+124    	; 0x944 <__stack+0x45>
	switch(typeToRead)
	{
		case AMMONIA:
		{
			// start at highest ammonia level - false positive better than false negative
			for(int i = MAX_AMMONIA_COLORS - 1; i >= 0; --i)
     8c8:	21 97       	sbiw	r28, 0x01	; 1
     8ca:	0a 50       	subi	r16, 0x0A	; 10
     8cc:	11 09       	sbc	r17, r1
     8ce:	cf 3f       	cpi	r28, 0xFF	; 255
     8d0:	8f ef       	ldi	r24, 0xFF	; 255
     8d2:	d8 07       	cpc	r29, r24
     8d4:	19 f7       	brne	.-58     	; 0x89c <_Z9FindMatchv+0x2c>
     8d6:	42 c0       	rjmp	.+132    	; 0x95c <__stack+0x5d>
			break;
		}
		case NITRITE:
		{
			// start at highest nitrite level - false positive better than false negative
			for(int i = MAX_NITRITE_NITRATE_COLORS - 1; i >= 0; --i)
     8d8:	21 97       	sbiw	r28, 0x01	; 1
     8da:	0a 50       	subi	r16, 0x0A	; 10
     8dc:	11 09       	sbc	r17, r1
     8de:	cf 3f       	cpi	r28, 0xFF	; 255
     8e0:	8f ef       	ldi	r24, 0xFF	; 255
     8e2:	d8 07       	cpc	r29, r24
     8e4:	d9 f1       	breq	.+118    	; 0x95c <__stack+0x5d>
			{
				c = Nitrite[i];
     8e6:	8a e0       	ldi	r24, 0x0A	; 10
     8e8:	f8 01       	movw	r30, r16
     8ea:	fc 96       	adiw	r30, 0x3c	; 60
     8ec:	ac ef       	ldi	r26, 0xFC	; 252
     8ee:	b2 e0       	ldi	r27, 0x02	; 2
     8f0:	01 90       	ld	r0, Z+
     8f2:	0d 92       	st	X+, r0
     8f4:	8a 95       	dec	r24
     8f6:	e1 f7       	brne	.-8      	; 0x8f0 <_Z9FindMatchv+0x80>
				if(SameColor())
     8f8:	0e 94 a1 03 	call	0x742	; 0x742 <_Z9SameColorv>
     8fc:	88 23       	and	r24, r24
     8fe:	61 f3       	breq	.-40     	; 0x8d8 <_Z9FindMatchv+0x68>
				return Nitrite[i].ppm;
     900:	8a e0       	ldi	r24, 0x0A	; 10
     902:	8c 9f       	mul	r24, r28
     904:	f0 01       	movw	r30, r0
     906:	8d 9f       	mul	r24, r29
     908:	f0 0d       	add	r31, r0
     90a:	11 24       	eor	r1, r1
     90c:	e1 5b       	subi	r30, 0xB1	; 177
     90e:	fc 4f       	sbci	r31, 0xFC	; 252
     910:	19 c0       	rjmp	.+50     	; 0x944 <__stack+0x45>
     912:	09 e0       	ldi	r16, 0x09	; 9
     914:	13 e0       	ldi	r17, 0x03	; 3
	return true;
}

double FindMatch()
{
	switch(typeToRead)
     916:	c6 e0       	ldi	r28, 0x06	; 6
     918:	d0 e0       	ldi	r29, 0x00	; 0
		case NITRATE:
		{
			// start at highest nitrate level - false positive better than false negative
			for(int i = MAX_NITRITE_NITRATE_COLORS - 1; i >= 0; --i)
			{
				c = Nitrate[i];
     91a:	8a e0       	ldi	r24, 0x0A	; 10
     91c:	f8 01       	movw	r30, r16
     91e:	fc 96       	adiw	r30, 0x3c	; 60
     920:	ac ef       	ldi	r26, 0xFC	; 252
     922:	b2 e0       	ldi	r27, 0x02	; 2
     924:	01 90       	ld	r0, Z+
     926:	0d 92       	st	X+, r0
     928:	8a 95       	dec	r24
     92a:	e1 f7       	brne	.-8      	; 0x924 <__stack+0x25>
				if(SameColor())
     92c:	0e 94 a1 03 	call	0x742	; 0x742 <_Z9SameColorv>
     930:	88 23       	and	r24, r24
     932:	69 f0       	breq	.+26     	; 0x94e <__stack+0x4f>
				return Nitrate[i].ppm;
     934:	8a e0       	ldi	r24, 0x0A	; 10
     936:	8c 9f       	mul	r24, r28
     938:	f0 01       	movw	r30, r0
     93a:	8d 9f       	mul	r24, r29
     93c:	f0 0d       	add	r31, r0
     93e:	11 24       	eor	r1, r1
     940:	e7 5f       	subi	r30, 0xF7	; 247
     942:	fc 4f       	sbci	r31, 0xFC	; 252
     944:	30 81       	ld	r19, Z
     946:	21 81       	ldd	r18, Z+1	; 0x01
     948:	92 81       	ldd	r25, Z+2	; 0x02
     94a:	83 81       	ldd	r24, Z+3	; 0x03
     94c:	0b c0       	rjmp	.+22     	; 0x964 <__stack+0x65>
			break;
		}
		case NITRATE:
		{
			// start at highest nitrate level - false positive better than false negative
			for(int i = MAX_NITRITE_NITRATE_COLORS - 1; i >= 0; --i)
     94e:	21 97       	sbiw	r28, 0x01	; 1
     950:	0a 50       	subi	r16, 0x0A	; 10
     952:	11 09       	sbc	r17, r1
     954:	cf 3f       	cpi	r28, 0xFF	; 255
     956:	8f ef       	ldi	r24, 0xFF	; 255
     958:	d8 07       	cpc	r29, r24
     95a:	f9 f6       	brne	.-66     	; 0x91a <__stack+0x1b>
			{
				c = Ammonia[i];
				if(SameColor())
				return Ammonia[i].ppm;
			}
			return -1;
     95c:	30 e0       	ldi	r19, 0x00	; 0
     95e:	20 e0       	ldi	r18, 0x00	; 0
     960:	90 e8       	ldi	r25, 0x80	; 128
     962:	8f eb       	ldi	r24, 0xBF	; 191
     964:	ac 01       	movw	r20, r24
			}
			return -1;
			break;
		}
	}
}
     966:	63 2f       	mov	r22, r19
     968:	72 2f       	mov	r23, r18
     96a:	85 2f       	mov	r24, r21
     96c:	94 2f       	mov	r25, r20
     96e:	df 91       	pop	r29
     970:	cf 91       	pop	r28
     972:	1f 91       	pop	r17
     974:	0f 91       	pop	r16
     976:	08 95       	ret

00000978 <_Z9ScanColorv>:

long ScanColor()
{
	CS.read();
     978:	8a ec       	ldi	r24, 0xCA	; 202
     97a:	92 e0       	ldi	r25, 0x02	; 2
     97c:	0e 94 90 0b 	call	0x1720	; 0x1720 <_ZN9MD_TCS2304readEv>
	while(CS.available() == 0);  // wait for read to complete
     980:	8a ec       	ldi	r24, 0xCA	; 202
     982:	92 e0       	ldi	r25, 0x02	; 2
     984:	0e 94 9a 0b 	call	0x1734	; 0x1734 <_ZN9MD_TCS2309availableEv>
     988:	88 23       	and	r24, r24
     98a:	d1 f3       	breq	.-12     	; 0x980 <_Z9ScanColorv+0x8>
	CS.getRGB(&rgb);
     98c:	66 e0       	ldi	r22, 0x06	; 6
     98e:	73 e0       	ldi	r23, 0x03	; 3
     990:	8a ec       	ldi	r24, 0xCA	; 202
     992:	92 e0       	ldi	r25, 0x02	; 2
     994:	0e 94 c6 0a 	call	0x158c	; 0x158c <_ZN9MD_TCS2306getRGBEP9colorData>
	greenScanned = rgb.value[TCS230_RGB_G];
     998:	80 91 07 03 	lds	r24, 0x0307	; 0x800307 <rgb+0x1>
     99c:	80 93 fb 02 	sts	0x02FB, r24	; 0x8002fb <greenScanned>
	redScanned = rgb.value[TCS230_RGB_R];
     9a0:	80 91 06 03 	lds	r24, 0x0306	; 0x800306 <rgb>
     9a4:	80 93 fa 02 	sts	0x02FA, r24	; 0x8002fa <redScanned>
	blueScanned = rgb.value[TCS230_RGB_B];
     9a8:	80 91 08 03 	lds	r24, 0x0308	; 0x800308 <rgb+0x2>
     9ac:	80 93 f9 02 	sts	0x02F9, r24	; 0x8002f9 <blueScanned>
	// look for match
	Serial.println("RGB");
     9b0:	63 eb       	ldi	r22, 0xB3	; 179
     9b2:	71 e0       	ldi	r23, 0x01	; 1
     9b4:	86 ef       	ldi	r24, 0xF6	; 246
     9b6:	93 e0       	ldi	r25, 0x03	; 3
     9b8:	0e 94 20 10 	call	0x2040	; 0x2040 <_ZN5Print7printlnEPKc>
	Serial.println(redScanned);
     9bc:	4a e0       	ldi	r20, 0x0A	; 10
     9be:	50 e0       	ldi	r21, 0x00	; 0
     9c0:	60 91 fa 02 	lds	r22, 0x02FA	; 0x8002fa <redScanned>
     9c4:	86 ef       	ldi	r24, 0xF6	; 246
     9c6:	93 e0       	ldi	r25, 0x03	; 3
     9c8:	0e 94 8f 10 	call	0x211e	; 0x211e <_ZN5Print7printlnEhi>
	Serial.println(greenScanned);
     9cc:	4a e0       	ldi	r20, 0x0A	; 10
     9ce:	50 e0       	ldi	r21, 0x00	; 0
     9d0:	60 91 fb 02 	lds	r22, 0x02FB	; 0x8002fb <greenScanned>
     9d4:	86 ef       	ldi	r24, 0xF6	; 246
     9d6:	93 e0       	ldi	r25, 0x03	; 3
     9d8:	0e 94 8f 10 	call	0x211e	; 0x211e <_ZN5Print7printlnEhi>
	Serial.println(blueScanned);
     9dc:	4a e0       	ldi	r20, 0x0A	; 10
     9de:	50 e0       	ldi	r21, 0x00	; 0
     9e0:	60 91 f9 02 	lds	r22, 0x02F9	; 0x8002f9 <blueScanned>
     9e4:	86 ef       	ldi	r24, 0xF6	; 246
     9e6:	93 e0       	ldi	r25, 0x03	; 3
     9e8:	0e 94 8f 10 	call	0x211e	; 0x211e <_ZN5Print7printlnEhi>
	//return FindMatch();
}
     9ec:	08 95       	ret

000009ee <_Z13findTestStripv>:

bool findTestStrip()
{
     9ee:	cf 93       	push	r28
	// Scan for color
	CS.read();
     9f0:	8a ec       	ldi	r24, 0xCA	; 202
     9f2:	92 e0       	ldi	r25, 0x02	; 2
     9f4:	0e 94 90 0b 	call	0x1720	; 0x1720 <_ZN9MD_TCS2304readEv>
	while (CS.available() == 0);
     9f8:	8a ec       	ldi	r24, 0xCA	; 202
     9fa:	92 e0       	ldi	r25, 0x02	; 2
     9fc:	0e 94 9a 0b 	call	0x1734	; 0x1734 <_ZN9MD_TCS2309availableEv>
     a00:	88 23       	and	r24, r24
     a02:	d1 f3       	breq	.-12     	; 0x9f8 <_Z13findTestStripv+0xa>
	CS.getRGB(&rgb);
     a04:	66 e0       	ldi	r22, 0x06	; 6
     a06:	73 e0       	ldi	r23, 0x03	; 3
     a08:	8a ec       	ldi	r24, 0xCA	; 202
     a0a:	92 e0       	ldi	r25, 0x02	; 2
     a0c:	0e 94 c6 0a 	call	0x158c	; 0x158c <_ZN9MD_TCS2306getRGBEP9colorData>
	greenScanned = rgb.value[TCS230_RGB_G];
     a10:	80 91 07 03 	lds	r24, 0x0307	; 0x800307 <rgb+0x1>
     a14:	80 93 fb 02 	sts	0x02FB, r24	; 0x8002fb <greenScanned>
	redScanned = rgb.value[TCS230_RGB_R];
     a18:	80 91 06 03 	lds	r24, 0x0306	; 0x800306 <rgb>
     a1c:	80 93 fa 02 	sts	0x02FA, r24	; 0x8002fa <redScanned>
	blueScanned = rgb.value[TCS230_RGB_B];
     a20:	80 91 08 03 	lds	r24, 0x0308	; 0x800308 <rgb+0x2>
     a24:	80 93 f9 02 	sts	0x02F9, r24	; 0x8002f9 <blueScanned>
	// look for match against black
	c = EmptyTestBox;
     a28:	8a e0       	ldi	r24, 0x0A	; 10
     a2a:	e9 e2       	ldi	r30, 0x29	; 41
     a2c:	f1 e0       	ldi	r31, 0x01	; 1
     a2e:	ac ef       	ldi	r26, 0xFC	; 252
     a30:	b2 e0       	ldi	r27, 0x02	; 2
     a32:	01 90       	ld	r0, Z+
     a34:	0d 92       	st	X+, r0
     a36:	8a 95       	dec	r24
     a38:	e1 f7       	brne	.-8      	; 0xa32 <_Z13findTestStripv+0x44>
	bool foundEmptyBox = SameColor();
     a3a:	0e 94 a1 03 	call	0x742	; 0x742 <_Z9SameColorv>
     a3e:	c8 2f       	mov	r28, r24
	Serial.print(" foundEmptyBox ");
     a40:	67 eb       	ldi	r22, 0xB7	; 183
     a42:	71 e0       	ldi	r23, 0x01	; 1
     a44:	86 ef       	ldi	r24, 0xF6	; 246
     a46:	93 e0       	ldi	r25, 0x03	; 3
     a48:	0e 94 13 10 	call	0x2026	; 0x2026 <_ZN5Print5printEPKc>
	Serial.println(foundEmptyBox);
     a4c:	6c 2f       	mov	r22, r28
     a4e:	70 e0       	ldi	r23, 0x00	; 0
     a50:	4a e0       	ldi	r20, 0x0A	; 10
     a52:	50 e0       	ldi	r21, 0x00	; 0
     a54:	86 ef       	ldi	r24, 0xF6	; 246
     a56:	93 e0       	ldi	r25, 0x03	; 3
     a58:	0e 94 f6 10 	call	0x21ec	; 0x21ec <_ZN5Print7printlnEii>
	Serial.print("\n");
     a5c:	6a e9       	ldi	r22, 0x9A	; 154
     a5e:	72 e0       	ldi	r23, 0x02	; 2
     a60:	86 ef       	ldi	r24, 0xF6	; 246
     a62:	93 e0       	ldi	r25, 0x03	; 3
     a64:	0e 94 13 10 	call	0x2026	; 0x2026 <_ZN5Print5printEPKc>
	c = WhiteTestStrip;
     a68:	8a e0       	ldi	r24, 0x0A	; 10
     a6a:	ef e1       	ldi	r30, 0x1F	; 31
     a6c:	f1 e0       	ldi	r31, 0x01	; 1
     a6e:	ac ef       	ldi	r26, 0xFC	; 252
     a70:	b2 e0       	ldi	r27, 0x02	; 2
     a72:	01 90       	ld	r0, Z+
     a74:	0d 92       	st	X+, r0
     a76:	8a 95       	dec	r24
     a78:	e1 f7       	brne	.-8      	; 0xa72 <_Z13findTestStripv+0x84>
	foundEmptyBox =  foundEmptyBox || SameColor();
     a7a:	c1 11       	cpse	r28, r1
     a7c:	03 c0       	rjmp	.+6      	; 0xa84 <_Z13findTestStripv+0x96>
     a7e:	0e 94 a1 03 	call	0x742	; 0x742 <_Z9SameColorv>
     a82:	c8 2f       	mov	r28, r24
	Serial.print(" foundEmptyBoxOrTestStrip ");
     a84:	67 ec       	ldi	r22, 0xC7	; 199
     a86:	71 e0       	ldi	r23, 0x01	; 1
     a88:	86 ef       	ldi	r24, 0xF6	; 246
     a8a:	93 e0       	ldi	r25, 0x03	; 3
     a8c:	0e 94 13 10 	call	0x2026	; 0x2026 <_ZN5Print5printEPKc>
	Serial.println(foundEmptyBox);
     a90:	6c 2f       	mov	r22, r28
     a92:	70 e0       	ldi	r23, 0x00	; 0
     a94:	4a e0       	ldi	r20, 0x0A	; 10
     a96:	50 e0       	ldi	r21, 0x00	; 0
     a98:	86 ef       	ldi	r24, 0xF6	; 246
     a9a:	93 e0       	ldi	r25, 0x03	; 3
     a9c:	0e 94 f6 10 	call	0x21ec	; 0x21ec <_ZN5Print7printlnEii>
	Serial.print("\n");
     aa0:	6a e9       	ldi	r22, 0x9A	; 154
     aa2:	72 e0       	ldi	r23, 0x02	; 2
     aa4:	86 ef       	ldi	r24, 0xF6	; 246
     aa6:	93 e0       	ldi	r25, 0x03	; 3
     aa8:	0e 94 13 10 	call	0x2026	; 0x2026 <_ZN5Print5printEPKc>
	return foundEmptyBox && (FindMatch() == -1);
     aac:	cc 23       	and	r28, r28
     aae:	51 f0       	breq	.+20     	; 0xac4 <_Z13findTestStripv+0xd6>
     ab0:	0e 94 38 04 	call	0x870	; 0x870 <_Z9FindMatchv>
     ab4:	c1 e0       	ldi	r28, 0x01	; 1
     ab6:	20 e0       	ldi	r18, 0x00	; 0
     ab8:	30 e0       	ldi	r19, 0x00	; 0
     aba:	40 e8       	ldi	r20, 0x80	; 128
     abc:	5f eb       	ldi	r21, 0xBF	; 191
     abe:	0e 94 15 0c 	call	0x182a	; 0x182a <__cmpsf2>
     ac2:	81 11       	cpse	r24, r1
     ac4:	c0 e0       	ldi	r28, 0x00	; 0
     ac6:	8c 2f       	mov	r24, r28
     ac8:	cf 91       	pop	r28
     aca:	08 95       	ret

00000acc <_Z6setLED8LEDColor>:
LEDColor White = {255, 255, 255};
LEDColor Off = {0, 0, 0};


void setLED(LEDColor c)
{
     acc:	cf 93       	push	r28
     ace:	df 93       	push	r29
     ad0:	00 d0       	rcall	.+0      	; 0xad2 <_Z6setLED8LEDColor+0x6>
     ad2:	00 d0       	rcall	.+0      	; 0xad4 <_Z6setLED8LEDColor+0x8>
     ad4:	00 d0       	rcall	.+0      	; 0xad6 <_Z6setLED8LEDColor+0xa>
     ad6:	cd b7       	in	r28, 0x3d	; 61
     ad8:	de b7       	in	r29, 0x3e	; 62
     ada:	49 83       	std	Y+1, r20	; 0x01
     adc:	5a 83       	std	Y+2, r21	; 0x02
     ade:	6b 83       	std	Y+3, r22	; 0x03
     ae0:	7c 83       	std	Y+4, r23	; 0x04
     ae2:	8d 83       	std	Y+5, r24	; 0x05
     ae4:	9e 83       	std	Y+6, r25	; 0x06
	analogWrite(R_LED, c.r);
     ae6:	69 81       	ldd	r22, Y+1	; 0x01
     ae8:	7a 81       	ldd	r23, Y+2	; 0x02
     aea:	8f e0       	ldi	r24, 0x0F	; 15
     aec:	0e 94 74 13 	call	0x26e8	; 0x26e8 <analogWrite>
	analogWrite(G_LED, c.g);
     af0:	6b 81       	ldd	r22, Y+3	; 0x03
     af2:	7c 81       	ldd	r23, Y+4	; 0x04
     af4:	80 e1       	ldi	r24, 0x10	; 16
     af6:	0e 94 74 13 	call	0x26e8	; 0x26e8 <analogWrite>
	analogWrite(B_LED, c.b);
     afa:	6d 81       	ldd	r22, Y+5	; 0x05
     afc:	7e 81       	ldd	r23, Y+6	; 0x06
     afe:	81 e1       	ldi	r24, 0x11	; 17
}
     b00:	26 96       	adiw	r28, 0x06	; 6
     b02:	0f b6       	in	r0, 0x3f	; 63
     b04:	f8 94       	cli
     b06:	de bf       	out	0x3e, r29	; 62
     b08:	0f be       	out	0x3f, r0	; 63
     b0a:	cd bf       	out	0x3d, r28	; 61
     b0c:	df 91       	pop	r29
     b0e:	cf 91       	pop	r28

void setLED(LEDColor c)
{
	analogWrite(R_LED, c.r);
	analogWrite(G_LED, c.g);
	analogWrite(B_LED, c.b);
     b10:	0c 94 74 13 	jmp	0x26e8	; 0x26e8 <analogWrite>

00000b14 <_Z15TaskColorSensorPv>:
/*---------------------- Tasks ---------------------*/
/*--------------------------------------------------*/

// get Ammonia, Nitrite, and Nitrate reading from color sensor
void TaskColorSensor(void *pvParameters)
{
     b14:	cf 93       	push	r28
     b16:	df 93       	push	r29
     b18:	00 d0       	rcall	.+0      	; 0xb1a <_Z15TaskColorSensorPv+0x6>
     b1a:	cd b7       	in	r28, 0x3d	; 61
     b1c:	de b7       	in	r29, 0x3e	; 62
	(void) pvParameters;
  
	TickType_t xLastWakeTime = xTaskGetTickCount();
     b1e:	0e 94 95 16 	call	0x2d2a	; 0x2d2a <xTaskGetTickCount>
     b22:	9a 83       	std	Y+2, r25	; 0x02
     b24:	89 83       	std	Y+1, r24	; 0x01
				ammoniaValue = ScanColor() * 100;
			}
			else
			{
				setLED(Red);
				typeToRead = NITRATE;
     b26:	01 e0       	ldi	r16, 0x01	; 1
				while (findTestStrip());
				setLED(Green);
				delay(250); // allow user to see LED and stop moving test strip

				nitrateValue = ScanColor() * 100;
     b28:	14 e6       	ldi	r17, 0x64	; 100
				
				setLED(Off);
				
				typeToRead = NITRITE;
     b2a:	82 e0       	ldi	r24, 0x02	; 2
     b2c:	f8 2e       	mov	r15, r24
	TickType_t xLastWakeTime = xTaskGetTickCount();
	for (;;) // A Task shall never return or exit.
	{
		//if ( xSemaphoreTake( xSerialSemaphoreColorSensor, ( TickType_t ) 1 ) == pdTRUE )
		//{
			if (colorToRead == 'a')
     b2e:	80 91 06 01 	lds	r24, 0x0106	; 0x800106 <colorToRead>
     b32:	81 36       	cpi	r24, 0x61	; 97
     b34:	41 f5       	brne	.+80     	; 0xb86 <_Z15TaskColorSensorPv+0x72>
			{
				Serial.println("c");
     b36:	63 eb       	ldi	r22, 0xB3	; 179
     b38:	72 e0       	ldi	r23, 0x02	; 2
     b3a:	86 ef       	ldi	r24, 0xF6	; 246
     b3c:	93 e0       	ldi	r25, 0x03	; 3
     b3e:	0e 94 20 10 	call	0x2040	; 0x2040 <_ZN5Print7printlnEPKc>
				setLED(White);
     b42:	40 91 07 01 	lds	r20, 0x0107	; 0x800107 <White>
     b46:	50 91 08 01 	lds	r21, 0x0108	; 0x800108 <White+0x1>
     b4a:	60 91 09 01 	lds	r22, 0x0109	; 0x800109 <White+0x2>
     b4e:	70 91 0a 01 	lds	r23, 0x010A	; 0x80010a <White+0x3>
     b52:	80 91 0b 01 	lds	r24, 0x010B	; 0x80010b <White+0x4>
     b56:	90 91 0c 01 	lds	r25, 0x010C	; 0x80010c <White+0x5>
     b5a:	0e 94 66 05 	call	0xacc	; 0xacc <_Z6setLED8LEDColor>
				//while (findTestStrip());
				//setLED(Green);
				delay(250); // let user see LED and stop moving before measuring
     b5e:	6a ef       	ldi	r22, 0xFA	; 250
     b60:	70 e0       	ldi	r23, 0x00	; 0
     b62:	80 e0       	ldi	r24, 0x00	; 0
     b64:	90 e0       	ldi	r25, 0x00	; 0
     b66:	0e 94 d5 12 	call	0x25aa	; 0x25aa <delay>
				
				typeToRead = AMMONIA;
     b6a:	10 92 c7 03 	sts	0x03C7, r1	; 0x8003c7 <typeToRead>
				ammoniaValue = ScanColor() * 100;
     b6e:	0e 94 bc 04 	call	0x978	; 0x978 <_Z9ScanColorv>
     b72:	16 9f       	mul	r17, r22
     b74:	90 01       	movw	r18, r0
     b76:	17 9f       	mul	r17, r23
     b78:	30 0d       	add	r19, r0
     b7a:	11 24       	eor	r1, r1
     b7c:	30 93 bf 02 	sts	0x02BF, r19	; 0x8002bf <ammoniaValue+0x1>
     b80:	20 93 be 02 	sts	0x02BE, r18	; 0x8002be <ammoniaValue>
     b84:	66 c0       	rjmp	.+204    	; 0xc52 <_Z15TaskColorSensorPv+0x13e>
			}
			else
			{
				setLED(Red);
     b86:	40 91 19 01 	lds	r20, 0x0119	; 0x800119 <Red>
     b8a:	50 91 1a 01 	lds	r21, 0x011A	; 0x80011a <Red+0x1>
     b8e:	60 91 1b 01 	lds	r22, 0x011B	; 0x80011b <Red+0x2>
     b92:	70 91 1c 01 	lds	r23, 0x011C	; 0x80011c <Red+0x3>
     b96:	80 91 1d 01 	lds	r24, 0x011D	; 0x80011d <Red+0x4>
     b9a:	90 91 1e 01 	lds	r25, 0x011E	; 0x80011e <Red+0x5>
     b9e:	0e 94 66 05 	call	0xacc	; 0xacc <_Z6setLED8LEDColor>
				typeToRead = NITRATE;
     ba2:	00 93 c7 03 	sts	0x03C7, r16	; 0x8003c7 <typeToRead>
				while (findTestStrip());
     ba6:	0e 94 f7 04 	call	0x9ee	; 0x9ee <_Z13findTestStripv>
     baa:	81 11       	cpse	r24, r1
     bac:	fc cf       	rjmp	.-8      	; 0xba6 <_Z15TaskColorSensorPv+0x92>
				setLED(Green);
     bae:	40 91 13 01 	lds	r20, 0x0113	; 0x800113 <Green>
     bb2:	50 91 14 01 	lds	r21, 0x0114	; 0x800114 <Green+0x1>
     bb6:	60 91 15 01 	lds	r22, 0x0115	; 0x800115 <Green+0x2>
     bba:	70 91 16 01 	lds	r23, 0x0116	; 0x800116 <Green+0x3>
     bbe:	80 91 17 01 	lds	r24, 0x0117	; 0x800117 <Green+0x4>
     bc2:	90 91 18 01 	lds	r25, 0x0118	; 0x800118 <Green+0x5>
     bc6:	0e 94 66 05 	call	0xacc	; 0xacc <_Z6setLED8LEDColor>
				delay(250); // allow user to see LED and stop moving test strip
     bca:	6a ef       	ldi	r22, 0xFA	; 250
     bcc:	70 e0       	ldi	r23, 0x00	; 0
     bce:	80 e0       	ldi	r24, 0x00	; 0
     bd0:	90 e0       	ldi	r25, 0x00	; 0
     bd2:	0e 94 d5 12 	call	0x25aa	; 0x25aa <delay>

				nitrateValue = ScanColor() * 100;
     bd6:	0e 94 bc 04 	call	0x978	; 0x978 <_Z9ScanColorv>
     bda:	16 9f       	mul	r17, r22
     bdc:	90 01       	movw	r18, r0
     bde:	17 9f       	mul	r17, r23
     be0:	30 0d       	add	r19, r0
     be2:	11 24       	eor	r1, r1
     be4:	30 93 bd 02 	sts	0x02BD, r19	; 0x8002bd <nitrateValue+0x1>
     be8:	20 93 bc 02 	sts	0x02BC, r18	; 0x8002bc <nitrateValue>
				
				setLED(Off);
     bec:	40 91 c4 02 	lds	r20, 0x02C4	; 0x8002c4 <Off>
     bf0:	50 91 c5 02 	lds	r21, 0x02C5	; 0x8002c5 <Off+0x1>
     bf4:	60 91 c6 02 	lds	r22, 0x02C6	; 0x8002c6 <Off+0x2>
     bf8:	70 91 c7 02 	lds	r23, 0x02C7	; 0x8002c7 <Off+0x3>
     bfc:	80 91 c8 02 	lds	r24, 0x02C8	; 0x8002c8 <Off+0x4>
     c00:	90 91 c9 02 	lds	r25, 0x02C9	; 0x8002c9 <Off+0x5>
     c04:	0e 94 66 05 	call	0xacc	; 0xacc <_Z6setLED8LEDColor>
				
				typeToRead = NITRITE;
     c08:	f0 92 c7 03 	sts	0x03C7, r15	; 0x8003c7 <typeToRead>
				while (findTestStrip());
     c0c:	0e 94 f7 04 	call	0x9ee	; 0x9ee <_Z13findTestStripv>
     c10:	81 11       	cpse	r24, r1
     c12:	fc cf       	rjmp	.-8      	; 0xc0c <_Z15TaskColorSensorPv+0xf8>
				setLED(Blue);
     c14:	40 91 0d 01 	lds	r20, 0x010D	; 0x80010d <Blue>
     c18:	50 91 0e 01 	lds	r21, 0x010E	; 0x80010e <Blue+0x1>
     c1c:	60 91 0f 01 	lds	r22, 0x010F	; 0x80010f <Blue+0x2>
     c20:	70 91 10 01 	lds	r23, 0x0110	; 0x800110 <Blue+0x3>
     c24:	80 91 11 01 	lds	r24, 0x0111	; 0x800111 <Blue+0x4>
     c28:	90 91 12 01 	lds	r25, 0x0112	; 0x800112 <Blue+0x5>
     c2c:	0e 94 66 05 	call	0xacc	; 0xacc <_Z6setLED8LEDColor>
				delay(250);
     c30:	6a ef       	ldi	r22, 0xFA	; 250
     c32:	70 e0       	ldi	r23, 0x00	; 0
     c34:	80 e0       	ldi	r24, 0x00	; 0
     c36:	90 e0       	ldi	r25, 0x00	; 0
     c38:	0e 94 d5 12 	call	0x25aa	; 0x25aa <delay>
				
				nitriteValue = ScanColor() * 100;
     c3c:	0e 94 bc 04 	call	0x978	; 0x978 <_Z9ScanColorv>
     c40:	16 9f       	mul	r17, r22
     c42:	90 01       	movw	r18, r0
     c44:	17 9f       	mul	r17, r23
     c46:	30 0d       	add	r19, r0
     c48:	11 24       	eor	r1, r1
     c4a:	30 93 bb 02 	sts	0x02BB, r19	; 0x8002bb <nitriteValue+0x1>
     c4e:	20 93 ba 02 	sts	0x02BA, r18	; 0x8002ba <nitriteValue>
			}
			setLED(Off);	  
     c52:	40 91 c4 02 	lds	r20, 0x02C4	; 0x8002c4 <Off>
     c56:	50 91 c5 02 	lds	r21, 0x02C5	; 0x8002c5 <Off+0x1>
     c5a:	60 91 c6 02 	lds	r22, 0x02C6	; 0x8002c6 <Off+0x2>
     c5e:	70 91 c7 02 	lds	r23, 0x02C7	; 0x8002c7 <Off+0x3>
     c62:	80 91 c8 02 	lds	r24, 0x02C8	; 0x8002c8 <Off+0x4>
     c66:	90 91 c9 02 	lds	r25, 0x02C9	; 0x8002c9 <Off+0x5>
     c6a:	0e 94 66 05 	call	0xacc	; 0xacc <_Z6setLED8LEDColor>
			//xSemaphoreGive( xSerialSemaphoreColorSensor );
			// suspend until triggered by next interrupt from Wifi module
			//vTaskSuspend(NULL);
		//}
		vTaskDelayUntil( &xLastWakeTime, 1000 / portTICK_PERIOD_MS );
     c6e:	6e e3       	ldi	r22, 0x3E	; 62
     c70:	70 e0       	ldi	r23, 0x00	; 0
     c72:	ce 01       	movw	r24, r28
     c74:	01 96       	adiw	r24, 0x01	; 1
     c76:	0e 94 ba 17 	call	0x2f74	; 0x2f74 <vTaskDelayUntil>
void TaskColorSensor(void *pvParameters)
{
	(void) pvParameters;
  
	TickType_t xLastWakeTime = xTaskGetTickCount();
	for (;;) // A Task shall never return or exit.
     c7a:	59 cf       	rjmp	.-334    	; 0xb2e <_Z15TaskColorSensorPv+0x1a>

00000c7c <_Z20TaskPHandTemperaturePv>:
}


// get pH and temp reading from sensors
void TaskPHandTemperature(void *pvParameters)
{
     c7c:	cf 93       	push	r28
     c7e:	df 93       	push	r29
     c80:	00 d0       	rcall	.+0      	; 0xc82 <_Z20TaskPHandTemperaturePv+0x6>
     c82:	cd b7       	in	r28, 0x3d	; 61
     c84:	de b7       	in	r29, 0x3e	; 62
  (void) pvParameters;
  
  TickType_t xLastWakeTime = xTaskGetTickCount();
     c86:	0e 94 95 16 	call	0x2d2a	; 0x2d2a <xTaskGetTickCount>
     c8a:	9a 83       	std	Y+2, r25	; 0x02
     c8c:	89 83       	std	Y+1, r24	; 0x01
  for (;;) // A Task shall never return or exit.
  {
	// Gets pH value
	//delay(500);
	setLED(Green);
     c8e:	40 91 13 01 	lds	r20, 0x0113	; 0x800113 <Green>
     c92:	50 91 14 01 	lds	r21, 0x0114	; 0x800114 <Green+0x1>
     c96:	60 91 15 01 	lds	r22, 0x0115	; 0x800115 <Green+0x2>
     c9a:	70 91 16 01 	lds	r23, 0x0116	; 0x800116 <Green+0x3>
     c9e:	80 91 17 01 	lds	r24, 0x0117	; 0x800117 <Green+0x4>
     ca2:	90 91 18 01 	lds	r25, 0x0118	; 0x800118 <Green+0x5>
     ca6:	0e 94 66 05 	call	0xacc	; 0xacc <_Z6setLED8LEDColor>
	Serial.write("p\n");
     caa:	62 ee       	ldi	r22, 0xE2	; 226
     cac:	71 e0       	ldi	r23, 0x01	; 1
     cae:	86 ef       	ldi	r24, 0xF6	; 246
     cb0:	93 e0       	ldi	r25, 0x03	; 3
     cb2:	0e 94 8d 01 	call	0x31a	; 0x31a <_ZN5Print5writeEPKc>
	float voltage = analogRead(PH_PIN);
     cb6:	8e e0       	ldi	r24, 0x0E	; 14
     cb8:	0e 94 57 13 	call	0x26ae	; 0x26ae <analogRead>
     cbc:	bc 01       	movw	r22, r24
     cbe:	99 0f       	add	r25, r25
     cc0:	88 0b       	sbc	r24, r24
     cc2:	99 0b       	sbc	r25, r25
     cc4:	0e 94 c4 0c 	call	0x1988	; 0x1988 <__floatsisf>
     cc8:	6b 01       	movw	r12, r22
     cca:	7c 01       	movw	r14, r24
	float neutralVoltage = 359.0; //CHANGE THESE AS NEEDED
	float acidVoltage = 178.0; //CHANGE THESE AS NEEDED
	float slope = (7.0 - 4.0)/(neutralVoltage - acidVoltage);
	float intercept = 7.0-(slope * neutralVoltage);
	phValue = (slope * voltage) + intercept;
     ccc:	2d e6       	ldi	r18, 0x6D	; 109
     cce:	37 ec       	ldi	r19, 0xC7	; 199
     cd0:	47 e8       	ldi	r20, 0x87	; 135
     cd2:	5c e3       	ldi	r21, 0x3C	; 60
     cd4:	0e 94 79 0d 	call	0x1af2	; 0x1af2 <__mulsf3>
     cd8:	28 e5       	ldi	r18, 0x58	; 88
     cda:	3d e5       	ldi	r19, 0x5D	; 93
     cdc:	46 e8       	ldi	r20, 0x86	; 134
     cde:	5f e3       	ldi	r21, 0x3F	; 63
     ce0:	0e 94 a9 0b 	call	0x1752	; 0x1752 <__addsf3>
     ce4:	0e 94 8c 0c 	call	0x1918	; 0x1918 <__fixsfsi>
     ce8:	70 93 c3 02 	sts	0x02C3, r23	; 0x8002c3 <phValue+0x1>
     cec:	60 93 c2 02 	sts	0x02C2, r22	; 0x8002c2 <phValue>
	Serial.write("Neutral Voltage:");
     cf0:	65 ee       	ldi	r22, 0xE5	; 229
     cf2:	71 e0       	ldi	r23, 0x01	; 1
     cf4:	86 ef       	ldi	r24, 0xF6	; 246
     cf6:	93 e0       	ldi	r25, 0x03	; 3
     cf8:	0e 94 8d 01 	call	0x31a	; 0x31a <_ZN5Print5writeEPKc>
	Serial.print(neutralVoltage);
     cfc:	22 e0       	ldi	r18, 0x02	; 2
     cfe:	30 e0       	ldi	r19, 0x00	; 0
     d00:	40 e0       	ldi	r20, 0x00	; 0
     d02:	50 e8       	ldi	r21, 0x80	; 128
     d04:	63 eb       	ldi	r22, 0xB3	; 179
     d06:	73 e4       	ldi	r23, 0x43	; 67
     d08:	86 ef       	ldi	r24, 0xF6	; 246
     d0a:	93 e0       	ldi	r25, 0x03	; 3
     d0c:	0e 94 e3 11 	call	0x23c6	; 0x23c6 <_ZN5Print5printEdi>
	Serial.write("\nAcid Voltage:");
     d10:	66 ef       	ldi	r22, 0xF6	; 246
     d12:	71 e0       	ldi	r23, 0x01	; 1
     d14:	86 ef       	ldi	r24, 0xF6	; 246
     d16:	93 e0       	ldi	r25, 0x03	; 3
     d18:	0e 94 8d 01 	call	0x31a	; 0x31a <_ZN5Print5writeEPKc>
	Serial.print(acidVoltage);
     d1c:	22 e0       	ldi	r18, 0x02	; 2
     d1e:	30 e0       	ldi	r19, 0x00	; 0
     d20:	40 e0       	ldi	r20, 0x00	; 0
     d22:	50 e0       	ldi	r21, 0x00	; 0
     d24:	62 e3       	ldi	r22, 0x32	; 50
     d26:	73 e4       	ldi	r23, 0x43	; 67
     d28:	86 ef       	ldi	r24, 0xF6	; 246
     d2a:	93 e0       	ldi	r25, 0x03	; 3
     d2c:	0e 94 e3 11 	call	0x23c6	; 0x23c6 <_ZN5Print5printEdi>
	Serial.write("\nVoltage Measured:");
     d30:	65 e0       	ldi	r22, 0x05	; 5
     d32:	72 e0       	ldi	r23, 0x02	; 2
     d34:	86 ef       	ldi	r24, 0xF6	; 246
     d36:	93 e0       	ldi	r25, 0x03	; 3
     d38:	0e 94 8d 01 	call	0x31a	; 0x31a <_ZN5Print5writeEPKc>
	Serial.print(voltage);
     d3c:	22 e0       	ldi	r18, 0x02	; 2
     d3e:	30 e0       	ldi	r19, 0x00	; 0
     d40:	b7 01       	movw	r22, r14
     d42:	a6 01       	movw	r20, r12
     d44:	86 ef       	ldi	r24, 0xF6	; 246
     d46:	93 e0       	ldi	r25, 0x03	; 3
     d48:	0e 94 e3 11 	call	0x23c6	; 0x23c6 <_ZN5Print5printEdi>
	Serial.write("\npH Value:");
     d4c:	68 e1       	ldi	r22, 0x18	; 24
     d4e:	72 e0       	ldi	r23, 0x02	; 2
     d50:	86 ef       	ldi	r24, 0xF6	; 246
     d52:	93 e0       	ldi	r25, 0x03	; 3
     d54:	0e 94 8d 01 	call	0x31a	; 0x31a <_ZN5Print5writeEPKc>
	Serial.print(phValue);
     d58:	60 91 c2 02 	lds	r22, 0x02C2	; 0x8002c2 <phValue>
     d5c:	70 91 c3 02 	lds	r23, 0x02C3	; 0x8002c3 <phValue+0x1>
     d60:	4a e0       	ldi	r20, 0x0A	; 10
     d62:	50 e0       	ldi	r21, 0x00	; 0
     d64:	86 ef       	ldi	r24, 0xF6	; 246
     d66:	93 e0       	ldi	r25, 0x03	; 3
     d68:	0e 94 ef 10 	call	0x21de	; 0x21de <_ZN5Print5printEii>
	delay(100);
     d6c:	64 e6       	ldi	r22, 0x64	; 100
     d6e:	70 e0       	ldi	r23, 0x00	; 0
     d70:	80 e0       	ldi	r24, 0x00	; 0
     d72:	90 e0       	ldi	r25, 0x00	; 0
     d74:	0e 94 d5 12 	call	0x25aa	; 0x25aa <delay>
	setLED(Off);
     d78:	40 91 c4 02 	lds	r20, 0x02C4	; 0x8002c4 <Off>
     d7c:	50 91 c5 02 	lds	r21, 0x02C5	; 0x8002c5 <Off+0x1>
     d80:	60 91 c6 02 	lds	r22, 0x02C6	; 0x8002c6 <Off+0x2>
     d84:	70 91 c7 02 	lds	r23, 0x02C7	; 0x8002c7 <Off+0x3>
     d88:	80 91 c8 02 	lds	r24, 0x02C8	; 0x8002c8 <Off+0x4>
     d8c:	90 91 c9 02 	lds	r25, 0x02C9	; 0x8002c9 <Off+0x5>
     d90:	0e 94 66 05 	call	0xacc	; 0xacc <_Z6setLED8LEDColor>
	
	setLED(Red);
     d94:	40 91 19 01 	lds	r20, 0x0119	; 0x800119 <Red>
     d98:	50 91 1a 01 	lds	r21, 0x011A	; 0x80011a <Red+0x1>
     d9c:	60 91 1b 01 	lds	r22, 0x011B	; 0x80011b <Red+0x2>
     da0:	70 91 1c 01 	lds	r23, 0x011C	; 0x80011c <Red+0x3>
     da4:	80 91 1d 01 	lds	r24, 0x011D	; 0x80011d <Red+0x4>
     da8:	90 91 1e 01 	lds	r25, 0x011E	; 0x80011e <Red+0x5>
     dac:	0e 94 66 05 	call	0xacc	; 0xacc <_Z6setLED8LEDColor>
	// Gets temperature value in Celsius
	tempValue = measureTemp() * 100;
     db0:	0e 94 a9 01 	call	0x352	; 0x352 <_Z11measureTempv>
     db4:	20 e0       	ldi	r18, 0x00	; 0
     db6:	30 e0       	ldi	r19, 0x00	; 0
     db8:	48 ec       	ldi	r20, 0xC8	; 200
     dba:	52 e4       	ldi	r21, 0x42	; 66
     dbc:	0e 94 79 0d 	call	0x1af2	; 0x1af2 <__mulsf3>
     dc0:	0e 94 8c 0c 	call	0x1918	; 0x1918 <__fixsfsi>
     dc4:	70 93 c1 02 	sts	0x02C1, r23	; 0x8002c1 <tempValue+0x1>
     dc8:	60 93 c0 02 	sts	0x02C0, r22	; 0x8002c0 <tempValue>
	Serial.write("t\n");
     dcc:	63 e2       	ldi	r22, 0x23	; 35
     dce:	72 e0       	ldi	r23, 0x02	; 2
     dd0:	86 ef       	ldi	r24, 0xF6	; 246
     dd2:	93 e0       	ldi	r25, 0x03	; 3
     dd4:	0e 94 8d 01 	call	0x31a	; 0x31a <_ZN5Print5writeEPKc>
	Serial.print(tempValue);
     dd8:	60 91 c0 02 	lds	r22, 0x02C0	; 0x8002c0 <tempValue>
     ddc:	70 91 c1 02 	lds	r23, 0x02C1	; 0x8002c1 <tempValue+0x1>
     de0:	4a e0       	ldi	r20, 0x0A	; 10
     de2:	50 e0       	ldi	r21, 0x00	; 0
     de4:	86 ef       	ldi	r24, 0xF6	; 246
     de6:	93 e0       	ldi	r25, 0x03	; 3
     de8:	0e 94 ef 10 	call	0x21de	; 0x21de <_ZN5Print5printEii>
	
	delay(100);
     dec:	64 e6       	ldi	r22, 0x64	; 100
     dee:	70 e0       	ldi	r23, 0x00	; 0
     df0:	80 e0       	ldi	r24, 0x00	; 0
     df2:	90 e0       	ldi	r25, 0x00	; 0
     df4:	0e 94 d5 12 	call	0x25aa	; 0x25aa <delay>
	setLED(Off);
     df8:	40 91 c4 02 	lds	r20, 0x02C4	; 0x8002c4 <Off>
     dfc:	50 91 c5 02 	lds	r21, 0x02C5	; 0x8002c5 <Off+0x1>
     e00:	60 91 c6 02 	lds	r22, 0x02C6	; 0x8002c6 <Off+0x2>
     e04:	70 91 c7 02 	lds	r23, 0x02C7	; 0x8002c7 <Off+0x3>
     e08:	80 91 c8 02 	lds	r24, 0x02C8	; 0x8002c8 <Off+0x4>
     e0c:	90 91 c9 02 	lds	r25, 0x02C9	; 0x8002c9 <Off+0x5>
     e10:	0e 94 66 05 	call	0xacc	; 0xacc <_Z6setLED8LEDColor>
    // check pH and temp every 15 min
    vTaskDelayUntil( &xLastWakeTime, 5000 / portTICK_PERIOD_MS );
     e14:	68 e3       	ldi	r22, 0x38	; 56
     e16:	71 e0       	ldi	r23, 0x01	; 1
     e18:	ce 01       	movw	r24, r28
     e1a:	01 96       	adiw	r24, 0x01	; 1
     e1c:	0e 94 ba 17 	call	0x2f74	; 0x2f74 <vTaskDelayUntil>
     e20:	36 cf       	rjmp	.-404    	; 0xc8e <_Z20TaskPHandTemperaturePv+0x12>

00000e22 <_Z8setupLEDv>:
}

void setupLED()
{
	pinMode(R_LED, OUTPUT);
     e22:	61 e0       	ldi	r22, 0x01	; 1
     e24:	8f e0       	ldi	r24, 0x0F	; 15
     e26:	0e 94 fc 13 	call	0x27f8	; 0x27f8 <pinMode>
	pinMode(G_LED, OUTPUT);
     e2a:	61 e0       	ldi	r22, 0x01	; 1
     e2c:	80 e1       	ldi	r24, 0x10	; 16
     e2e:	0e 94 fc 13 	call	0x27f8	; 0x27f8 <pinMode>
	pinMode(B_LED, OUTPUT);
     e32:	61 e0       	ldi	r22, 0x01	; 1
     e34:	81 e1       	ldi	r24, 0x11	; 17
     e36:	0e 94 fc 13 	call	0x27f8	; 0x27f8 <pinMode>
	setLED(Off);
     e3a:	40 91 c4 02 	lds	r20, 0x02C4	; 0x8002c4 <Off>
     e3e:	50 91 c5 02 	lds	r21, 0x02C5	; 0x8002c5 <Off+0x1>
     e42:	60 91 c6 02 	lds	r22, 0x02C6	; 0x8002c6 <Off+0x2>
     e46:	70 91 c7 02 	lds	r23, 0x02C7	; 0x8002c7 <Off+0x3>
     e4a:	80 91 c8 02 	lds	r24, 0x02C8	; 0x8002c8 <Off+0x4>
     e4e:	90 91 c9 02 	lds	r25, 0x02C9	; 0x8002c9 <Off+0x5>
     e52:	0c 94 66 05 	jmp	0xacc	; 0xacc <_Z6setLED8LEDColor>

00000e56 <setup>:
TaskHandle_t xColorSensor;
TaskHandle_t xPHandTemperature;


// the setup function runs once when you press reset or power the board
void setup() {  
     e56:	ef 92       	push	r14
     e58:	ff 92       	push	r15
     e5a:	0f 93       	push	r16
  public:
    inline HardwareSerial(
      volatile uint8_t *ubrrh, volatile uint8_t *ubrrl,
      volatile uint8_t *ucsra, volatile uint8_t *ucsrb,
      volatile uint8_t *ucsrc, volatile uint8_t *udr);
    void begin(unsigned long baud) { begin(baud, SERIAL_8N1); }
     e5c:	26 e0       	ldi	r18, 0x06	; 6
     e5e:	40 e0       	ldi	r20, 0x00	; 0
     e60:	52 ec       	ldi	r21, 0xC2	; 194
     e62:	61 e0       	ldi	r22, 0x01	; 1
     e64:	70 e0       	ldi	r23, 0x00	; 0
     e66:	86 ef       	ldi	r24, 0xF6	; 246
     e68:	93 e0       	ldi	r25, 0x03	; 3
     e6a:	0e 94 c2 0e 	call	0x1d84	; 0x1d84 <_ZN14HardwareSerial5beginEmh>
	}
  
	// initialize Wifi module (Maybe?)

	// load test strip color data and initialize indicator LED
	CS.begin();
     e6e:	8a ec       	ldi	r24, 0xCA	; 202
     e70:	92 e0       	ldi	r25, 0x02	; 2
     e72:	0e 94 9b 0a 	call	0x1536	; 0x1536 <_ZN9MD_TCS2305beginEv>
	addColors();
     e76:	0e 94 5f 02 	call	0x4be	; 0x4be <_Z9addColorsv>
	setupLED();
     e7a:	0e 94 11 07 	call	0xe22	; 0xe22 <_Z8setupLEDv>
	Serial.print("Starting setup");
     e7e:	66 e2       	ldi	r22, 0x26	; 38
     e80:	72 e0       	ldi	r23, 0x02	; 2
     e82:	86 ef       	ldi	r24, 0xF6	; 246
     e84:	93 e0       	ldi	r25, 0x03	; 3
     e86:	0e 94 13 10 	call	0x2026	; 0x2026 <_ZN5Print5printEPKc>
	
	setLED(Green);
     e8a:	40 91 13 01 	lds	r20, 0x0113	; 0x800113 <Green>
     e8e:	50 91 14 01 	lds	r21, 0x0114	; 0x800114 <Green+0x1>
     e92:	60 91 15 01 	lds	r22, 0x0115	; 0x800115 <Green+0x2>
     e96:	70 91 16 01 	lds	r23, 0x0116	; 0x800116 <Green+0x3>
     e9a:	80 91 17 01 	lds	r24, 0x0117	; 0x800117 <Green+0x4>
     e9e:	90 91 18 01 	lds	r25, 0x0118	; 0x800118 <Green+0x5>
     ea2:	0e 94 66 05 	call	0xacc	; 0xacc <_Z6setLED8LEDColor>
  
	// initialize pH sensor
	phInit();
     ea6:	0e 94 f6 09 	call	0x13ec	; 0x13ec <_Z6phInitv>

	// TODO: Not sure how Wifi module indicates that it is getting data - replace that with the interrupt from pin2 
	attachInterrupt(digitalPinToInterrupt(2), fromWifi, RISING);
     eaa:	43 e0       	ldi	r20, 0x03	; 3
     eac:	50 e0       	ldi	r21, 0x00	; 0
     eae:	68 ea       	ldi	r22, 0xA8	; 168
     eb0:	77 e0       	ldi	r23, 0x07	; 7
     eb2:	80 e0       	ldi	r24, 0x00	; 0
     eb4:	0e 94 f8 11 	call	0x23f0	; 0x23f0 <attachInterrupt>
	TaskColorSensor
	,  (const portCHAR *)"ColorSensor"
	,  128
	,  NULL
	,  1
	,  &xColorSensor );
     eb8:	88 eb       	ldi	r24, 0xB8	; 184
     eba:	e8 2e       	mov	r14, r24
     ebc:	82 e0       	ldi	r24, 0x02	; 2
     ebe:	f8 2e       	mov	r15, r24
     ec0:	01 e0       	ldi	r16, 0x01	; 1
     ec2:	20 e0       	ldi	r18, 0x00	; 0
     ec4:	30 e0       	ldi	r19, 0x00	; 0
     ec6:	40 e8       	ldi	r20, 0x80	; 128
     ec8:	50 e0       	ldi	r21, 0x00	; 0
     eca:	65 e3       	ldi	r22, 0x35	; 53
     ecc:	72 e0       	ldi	r23, 0x02	; 2
     ece:	8a e8       	ldi	r24, 0x8A	; 138
     ed0:	95 e0       	ldi	r25, 0x05	; 5
     ed2:	0e 94 0c 15 	call	0x2a18	; 0x2a18 <xTaskCreate>
	TaskPHandTemperature
	,  (const portCHAR *) "PHandTemperature"
	,  128
	,  NULL
	,  2
	,  &xPHandTemperature );
     ed6:	96 eb       	ldi	r25, 0xB6	; 182
     ed8:	e9 2e       	mov	r14, r25
     eda:	92 e0       	ldi	r25, 0x02	; 2
     edc:	f9 2e       	mov	r15, r25
     ede:	02 e0       	ldi	r16, 0x02	; 2
     ee0:	20 e0       	ldi	r18, 0x00	; 0
     ee2:	30 e0       	ldi	r19, 0x00	; 0
     ee4:	40 e8       	ldi	r20, 0x80	; 128
     ee6:	50 e0       	ldi	r21, 0x00	; 0
     ee8:	61 e4       	ldi	r22, 0x41	; 65
     eea:	72 e0       	ldi	r23, 0x02	; 2
     eec:	8e e3       	ldi	r24, 0x3E	; 62
     eee:	96 e0       	ldi	r25, 0x06	; 6
     ef0:	0e 94 0c 15 	call	0x2a18	; 0x2a18 <xTaskCreate>
	
	//vTaskSuspend(xColorSensor);
	
	delay(1000);
     ef4:	68 ee       	ldi	r22, 0xE8	; 232
     ef6:	73 e0       	ldi	r23, 0x03	; 3
     ef8:	80 e0       	ldi	r24, 0x00	; 0
     efa:	90 e0       	ldi	r25, 0x00	; 0
     efc:	0e 94 d5 12 	call	0x25aa	; 0x25aa <delay>
	setLED(Off);
     f00:	40 91 c4 02 	lds	r20, 0x02C4	; 0x8002c4 <Off>
     f04:	50 91 c5 02 	lds	r21, 0x02C5	; 0x8002c5 <Off+0x1>
     f08:	60 91 c6 02 	lds	r22, 0x02C6	; 0x8002c6 <Off+0x2>
     f0c:	70 91 c7 02 	lds	r23, 0x02C7	; 0x8002c7 <Off+0x3>
     f10:	80 91 c8 02 	lds	r24, 0x02C8	; 0x8002c8 <Off+0x4>
     f14:	90 91 c9 02 	lds	r25, 0x02C9	; 0x8002c9 <Off+0x5>
     f18:	0e 94 66 05 	call	0xacc	; 0xacc <_Z6setLED8LEDColor>
	//calibratePH(25);
	Serial.print("Inside setup");
     f1c:	62 e5       	ldi	r22, 0x52	; 82
     f1e:	72 e0       	ldi	r23, 0x02	; 2
     f20:	86 ef       	ldi	r24, 0xF6	; 246
     f22:	93 e0       	ldi	r25, 0x03	; 3

	// Now the task scheduler, which takes over control of scheduling individual tasks, is automatically started.
}
     f24:	0f 91       	pop	r16
     f26:	ff 90       	pop	r15
     f28:	ef 90       	pop	r14
	//vTaskSuspend(xColorSensor);
	
	delay(1000);
	setLED(Off);
	//calibratePH(25);
	Serial.print("Inside setup");
     f2a:	0c 94 13 10 	jmp	0x2026	; 0x2026 <_ZN5Print5printEPKc>

00000f2e <loop>:

	// Now the task scheduler, which takes over control of scheduling individual tasks, is automatically started.
}

void loop()
{
     f2e:	08 95       	ret

00000f30 <_GLOBAL__sub_I_ds>:
    bool LastDeviceFlag;
#endif

  public:
    OneWire() { }
    OneWire(uint8_t pin) { begin(pin); }
     f30:	66 e0       	ldi	r22, 0x06	; 6
     f32:	88 ec       	ldi	r24, 0xC8	; 200
     f34:	93 e0       	ldi	r25, 0x03	; 3
     f36:	0e 94 34 09 	call	0x1268	; 0x1268 <_ZN7OneWire5beginEh>

uint8_t greenScanned;
uint8_t redScanned;
uint8_t blueScanned;

MD_TCS230  CS(S2, S3, OE);
     f3a:	28 e0       	ldi	r18, 0x08	; 8
     f3c:	4d e0       	ldi	r20, 0x0D	; 13
     f3e:	6c e0       	ldi	r22, 0x0C	; 12
     f40:	8a ec       	ldi	r24, 0xCA	; 202
     f42:	92 e0       	ldi	r25, 0x02	; 2
     f44:	0c 94 29 0a 	jmp	0x1452	; 0x1452 <_ZN9MD_TCS230C1Ehhh>

00000f48 <_GLOBAL__sub_D_ds>:
     f48:	8a ec       	ldi	r24, 0xCA	; 202
     f4a:	92 e0       	ldi	r25, 0x02	; 2
     f4c:	0c 94 3d 0a 	jmp	0x147a	; 0x147a <_ZN9MD_TCS230D1Ev>

00000f50 <_Z8fromWifiv>:
  }
}


void fromWifi()
{
     f50:	cf 93       	push	r28
	int i = 0;
	char action = '\0';
	// check for data from Wifi
	if (Serial.available())
     f52:	86 ef       	ldi	r24, 0xF6	; 246
     f54:	93 e0       	ldi	r25, 0x03	; 3
     f56:	0e 94 e6 0d 	call	0x1bcc	; 0x1bcc <_ZN14HardwareSerial9availableEv>
     f5a:	89 2b       	or	r24, r25
     f5c:	09 f4       	brne	.+2      	; 0xf60 <_Z8fromWifiv+0x10>
     f5e:	6a c0       	rjmp	.+212    	; 0x1034 <_Z8fromWifiv+0xe4>
	{
		delay(100); // allows all serial sent to be received together
     f60:	64 e6       	ldi	r22, 0x64	; 100
     f62:	70 e0       	ldi	r23, 0x00	; 0
     f64:	80 e0       	ldi	r24, 0x00	; 0
     f66:	90 e0       	ldi	r25, 0x00	; 0
     f68:	0e 94 d5 12 	call	0x25aa	; 0x25aa <delay>


void fromWifi()
{
	int i = 0;
	char action = '\0';
     f6c:	c0 e0       	ldi	r28, 0x00	; 0
	// check for data from Wifi
	if (Serial.available())
	{
		delay(100); // allows all serial sent to be received together
		while (Serial.available())
     f6e:	86 ef       	ldi	r24, 0xF6	; 246
     f70:	93 e0       	ldi	r25, 0x03	; 3
     f72:	0e 94 e6 0d 	call	0x1bcc	; 0x1bcc <_ZN14HardwareSerial9availableEv>
     f76:	89 2b       	or	r24, r25
     f78:	31 f0       	breq	.+12     	; 0xf86 <_Z8fromWifiv+0x36>
		{
			action = Serial.read();
     f7a:	86 ef       	ldi	r24, 0xF6	; 246
     f7c:	93 e0       	ldi	r25, 0x03	; 3
     f7e:	0e 94 00 0e 	call	0x1c00	; 0x1c00 <_ZN14HardwareSerial4readEv>
     f82:	c8 2f       	mov	r28, r24
	char action = '\0';
	// check for data from Wifi
	if (Serial.available())
	{
		delay(100); // allows all serial sent to be received together
		while (Serial.available())
     f84:	f4 cf       	rjmp	.-24     	; 0xf6e <_Z8fromWifiv+0x1e>
		{
			action = Serial.read();
		}
	}

	switch(action)
     f86:	ce 36       	cpi	r28, 0x6E	; 110
     f88:	29 f0       	breq	.+10     	; 0xf94 <_Z8fromWifiv+0x44>
     f8a:	c0 37       	cpi	r28, 0x70	; 112
     f8c:	61 f0       	breq	.+24     	; 0xfa6 <_Z8fromWifiv+0x56>
     f8e:	c1 36       	cpi	r28, 0x61	; 97
     f90:	09 f0       	breq	.+2      	; 0xf94 <_Z8fromWifiv+0x44>
     f92:	50 c0       	rjmp	.+160    	; 0x1034 <_Z8fromWifiv+0xe4>
		vTaskResume(xColorSensor);
		break;
	}
	case 'n':
	{
		colorToRead = 'n';
     f94:	c0 93 06 01 	sts	0x0106, r28	; 0x800106 <colorToRead>
		vTaskResume(xColorSensor);
     f98:	80 91 b8 02 	lds	r24, 0x02B8	; 0x8002b8 <xColorSensor>
     f9c:	90 91 b9 02 	lds	r25, 0x02B9	; 0x8002b9 <xColorSensor+0x1>
		Serial.write(nitrateValue);
	}
	default:
		break;
	}
}
     fa0:	cf 91       	pop	r28
		break;
	}
	case 'n':
	{
		colorToRead = 'n';
		vTaskResume(xColorSensor);
     fa2:	0c 94 18 16 	jmp	0x2c30	; 0x2c30 <vTaskResume>
		break;
	}
	case 'p':
	{
		Serial.write("ph:");
     fa6:	6f e5       	ldi	r22, 0x5F	; 95
     fa8:	72 e0       	ldi	r23, 0x02	; 2
     faa:	86 ef       	ldi	r24, 0xF6	; 246
     fac:	93 e0       	ldi	r25, 0x03	; 3
     fae:	0e 94 8d 01 	call	0x31a	; 0x31a <_ZN5Print5writeEPKc>
		Serial.write(phValue);
     fb2:	60 91 c2 02 	lds	r22, 0x02C2	; 0x8002c2 <phValue>
     fb6:	70 91 c3 02 	lds	r23, 0x02C3	; 0x8002c3 <phValue+0x1>
     fba:	86 ef       	ldi	r24, 0xF6	; 246
     fbc:	93 e0       	ldi	r25, 0x03	; 3
     fbe:	0e 94 a2 01 	call	0x344	; 0x344 <_ZN14HardwareSerial5writeEi>
		Serial.write("temp:");
     fc2:	63 e6       	ldi	r22, 0x63	; 99
     fc4:	72 e0       	ldi	r23, 0x02	; 2
     fc6:	86 ef       	ldi	r24, 0xF6	; 246
     fc8:	93 e0       	ldi	r25, 0x03	; 3
     fca:	0e 94 8d 01 	call	0x31a	; 0x31a <_ZN5Print5writeEPKc>
		Serial.write(tempValue);
     fce:	60 91 c0 02 	lds	r22, 0x02C0	; 0x8002c0 <tempValue>
     fd2:	70 91 c1 02 	lds	r23, 0x02C1	; 0x8002c1 <tempValue+0x1>
     fd6:	86 ef       	ldi	r24, 0xF6	; 246
     fd8:	93 e0       	ldi	r25, 0x03	; 3
     fda:	0e 94 a2 01 	call	0x344	; 0x344 <_ZN14HardwareSerial5writeEi>
		Serial.write("ammonia:");
     fde:	69 e6       	ldi	r22, 0x69	; 105
     fe0:	72 e0       	ldi	r23, 0x02	; 2
     fe2:	86 ef       	ldi	r24, 0xF6	; 246
     fe4:	93 e0       	ldi	r25, 0x03	; 3
     fe6:	0e 94 8d 01 	call	0x31a	; 0x31a <_ZN5Print5writeEPKc>
		Serial.write(ammoniaValue);
     fea:	60 91 be 02 	lds	r22, 0x02BE	; 0x8002be <ammoniaValue>
     fee:	70 91 bf 02 	lds	r23, 0x02BF	; 0x8002bf <ammoniaValue+0x1>
     ff2:	86 ef       	ldi	r24, 0xF6	; 246
     ff4:	93 e0       	ldi	r25, 0x03	; 3
     ff6:	0e 94 a2 01 	call	0x344	; 0x344 <_ZN14HardwareSerial5writeEi>
		Serial.write("nitrite:");
     ffa:	62 e7       	ldi	r22, 0x72	; 114
     ffc:	72 e0       	ldi	r23, 0x02	; 2
     ffe:	86 ef       	ldi	r24, 0xF6	; 246
    1000:	93 e0       	ldi	r25, 0x03	; 3
    1002:	0e 94 8d 01 	call	0x31a	; 0x31a <_ZN5Print5writeEPKc>
		Serial.write(nitriteValue);
    1006:	60 91 ba 02 	lds	r22, 0x02BA	; 0x8002ba <nitriteValue>
    100a:	70 91 bb 02 	lds	r23, 0x02BB	; 0x8002bb <nitriteValue+0x1>
    100e:	86 ef       	ldi	r24, 0xF6	; 246
    1010:	93 e0       	ldi	r25, 0x03	; 3
    1012:	0e 94 a2 01 	call	0x344	; 0x344 <_ZN14HardwareSerial5writeEi>
		Serial.write("nitrate:");
    1016:	6b e7       	ldi	r22, 0x7B	; 123
    1018:	72 e0       	ldi	r23, 0x02	; 2
    101a:	86 ef       	ldi	r24, 0xF6	; 246
    101c:	93 e0       	ldi	r25, 0x03	; 3
    101e:	0e 94 8d 01 	call	0x31a	; 0x31a <_ZN5Print5writeEPKc>
		Serial.write(nitrateValue);
    1022:	60 91 bc 02 	lds	r22, 0x02BC	; 0x8002bc <nitrateValue>
    1026:	70 91 bd 02 	lds	r23, 0x02BD	; 0x8002bd <nitrateValue+0x1>
    102a:	86 ef       	ldi	r24, 0xF6	; 246
    102c:	93 e0       	ldi	r25, 0x03	; 3
	}
	default:
		break;
	}
}
    102e:	cf 91       	pop	r28
		Serial.write("ammonia:");
		Serial.write(ammoniaValue);
		Serial.write("nitrite:");
		Serial.write(nitriteValue);
		Serial.write("nitrate:");
		Serial.write(nitrateValue);
    1030:	0c 94 a2 01 	jmp	0x344	; 0x344 <_ZN14HardwareSerial5writeEi>
	}
	default:
		break;
	}
}
    1034:	cf 91       	pop	r28
    1036:	08 95       	ret

00001038 <_ZN7OneWire5resetEv>:
    1038:	ff 92       	push	r15
    103a:	0f 93       	push	r16
    103c:	1f 93       	push	r17
    103e:	cf 93       	push	r28
    1040:	df 93       	push	r29
    1042:	fc 01       	movw	r30, r24
    1044:	f0 80       	ld	r15, Z
    1046:	c1 81       	ldd	r28, Z+1	; 0x01
    1048:	d2 81       	ldd	r29, Z+2	; 0x02
    104a:	f8 94       	cli
    104c:	89 81       	ldd	r24, Y+1	; 0x01
    104e:	0f 2d       	mov	r16, r15
    1050:	00 95       	com	r16
    1052:	80 23       	and	r24, r16
    1054:	89 83       	std	Y+1, r24	; 0x01
    1056:	78 94       	sei
    1058:	1d e7       	ldi	r17, 0x7D	; 125
    105a:	11 50       	subi	r17, 0x01	; 1
    105c:	29 f1       	breq	.+74     	; 0x10a8 <_ZN7OneWire5resetEv+0x70>
    105e:	82 e0       	ldi	r24, 0x02	; 2
    1060:	90 e0       	ldi	r25, 0x00	; 0
    1062:	0e 94 11 13 	call	0x2622	; 0x2622 <delayMicroseconds>
    1066:	88 81       	ld	r24, Y
    1068:	8f 21       	and	r24, r15
    106a:	b9 f3       	breq	.-18     	; 0x105a <_ZN7OneWire5resetEv+0x22>
    106c:	f8 94       	cli
    106e:	8a 81       	ldd	r24, Y+2	; 0x02
    1070:	80 23       	and	r24, r16
    1072:	8a 83       	std	Y+2, r24	; 0x02
    1074:	89 81       	ldd	r24, Y+1	; 0x01
    1076:	8f 29       	or	r24, r15
    1078:	89 83       	std	Y+1, r24	; 0x01
    107a:	78 94       	sei
    107c:	80 ee       	ldi	r24, 0xE0	; 224
    107e:	91 e0       	ldi	r25, 0x01	; 1
    1080:	0e 94 11 13 	call	0x2622	; 0x2622 <delayMicroseconds>
    1084:	f8 94       	cli
    1086:	89 81       	ldd	r24, Y+1	; 0x01
    1088:	08 23       	and	r16, r24
    108a:	09 83       	std	Y+1, r16	; 0x01
    108c:	86 e4       	ldi	r24, 0x46	; 70
    108e:	90 e0       	ldi	r25, 0x00	; 0
    1090:	0e 94 11 13 	call	0x2622	; 0x2622 <delayMicroseconds>
    1094:	88 81       	ld	r24, Y
    1096:	f8 22       	and	r15, r24
    1098:	11 e0       	ldi	r17, 0x01	; 1
    109a:	09 f0       	breq	.+2      	; 0x109e <_ZN7OneWire5resetEv+0x66>
    109c:	10 e0       	ldi	r17, 0x00	; 0
    109e:	78 94       	sei
    10a0:	8a e9       	ldi	r24, 0x9A	; 154
    10a2:	91 e0       	ldi	r25, 0x01	; 1
    10a4:	0e 94 11 13 	call	0x2622	; 0x2622 <delayMicroseconds>
    10a8:	81 2f       	mov	r24, r17
    10aa:	df 91       	pop	r29
    10ac:	cf 91       	pop	r28
    10ae:	1f 91       	pop	r17
    10b0:	0f 91       	pop	r16
    10b2:	ff 90       	pop	r15
    10b4:	08 95       	ret

000010b6 <_ZN7OneWire9write_bitEh>:
    10b6:	1f 93       	push	r17
    10b8:	cf 93       	push	r28
    10ba:	df 93       	push	r29
    10bc:	fc 01       	movw	r30, r24
    10be:	10 81       	ld	r17, Z
    10c0:	c1 81       	ldd	r28, Z+1	; 0x01
    10c2:	d2 81       	ldd	r29, Z+2	; 0x02
    10c4:	81 2f       	mov	r24, r17
    10c6:	80 95       	com	r24
    10c8:	60 ff       	sbrs	r22, 0
    10ca:	12 c0       	rjmp	.+36     	; 0x10f0 <_ZN7OneWire9write_bitEh+0x3a>
    10cc:	f8 94       	cli
    10ce:	9a 81       	ldd	r25, Y+2	; 0x02
    10d0:	89 23       	and	r24, r25
    10d2:	8a 83       	std	Y+2, r24	; 0x02
    10d4:	89 81       	ldd	r24, Y+1	; 0x01
    10d6:	81 2b       	or	r24, r17
    10d8:	89 83       	std	Y+1, r24	; 0x01
    10da:	8a e0       	ldi	r24, 0x0A	; 10
    10dc:	90 e0       	ldi	r25, 0x00	; 0
    10de:	0e 94 11 13 	call	0x2622	; 0x2622 <delayMicroseconds>
    10e2:	8a 81       	ldd	r24, Y+2	; 0x02
    10e4:	18 2b       	or	r17, r24
    10e6:	1a 83       	std	Y+2, r17	; 0x02
    10e8:	78 94       	sei
    10ea:	87 e3       	ldi	r24, 0x37	; 55
    10ec:	90 e0       	ldi	r25, 0x00	; 0
    10ee:	11 c0       	rjmp	.+34     	; 0x1112 <_ZN7OneWire9write_bitEh+0x5c>
    10f0:	f8 94       	cli
    10f2:	9a 81       	ldd	r25, Y+2	; 0x02
    10f4:	89 23       	and	r24, r25
    10f6:	8a 83       	std	Y+2, r24	; 0x02
    10f8:	89 81       	ldd	r24, Y+1	; 0x01
    10fa:	81 2b       	or	r24, r17
    10fc:	89 83       	std	Y+1, r24	; 0x01
    10fe:	81 e4       	ldi	r24, 0x41	; 65
    1100:	90 e0       	ldi	r25, 0x00	; 0
    1102:	0e 94 11 13 	call	0x2622	; 0x2622 <delayMicroseconds>
    1106:	8a 81       	ldd	r24, Y+2	; 0x02
    1108:	18 2b       	or	r17, r24
    110a:	1a 83       	std	Y+2, r17	; 0x02
    110c:	78 94       	sei
    110e:	85 e0       	ldi	r24, 0x05	; 5
    1110:	90 e0       	ldi	r25, 0x00	; 0
    1112:	df 91       	pop	r29
    1114:	cf 91       	pop	r28
    1116:	1f 91       	pop	r17
    1118:	0c 94 11 13 	jmp	0x2622	; 0x2622 <delayMicroseconds>

0000111c <_ZN7OneWire8read_bitEv>:
    111c:	0f 93       	push	r16
    111e:	1f 93       	push	r17
    1120:	cf 93       	push	r28
    1122:	df 93       	push	r29
    1124:	fc 01       	movw	r30, r24
    1126:	00 81       	ld	r16, Z
    1128:	c1 81       	ldd	r28, Z+1	; 0x01
    112a:	d2 81       	ldd	r29, Z+2	; 0x02
    112c:	f8 94       	cli
    112e:	89 81       	ldd	r24, Y+1	; 0x01
    1130:	80 2b       	or	r24, r16
    1132:	89 83       	std	Y+1, r24	; 0x01
    1134:	8a 81       	ldd	r24, Y+2	; 0x02
    1136:	10 2f       	mov	r17, r16
    1138:	10 95       	com	r17
    113a:	81 23       	and	r24, r17
    113c:	8a 83       	std	Y+2, r24	; 0x02
    113e:	83 e0       	ldi	r24, 0x03	; 3
    1140:	90 e0       	ldi	r25, 0x00	; 0
    1142:	0e 94 11 13 	call	0x2622	; 0x2622 <delayMicroseconds>
    1146:	89 81       	ldd	r24, Y+1	; 0x01
    1148:	18 23       	and	r17, r24
    114a:	19 83       	std	Y+1, r17	; 0x01
    114c:	8a e0       	ldi	r24, 0x0A	; 10
    114e:	90 e0       	ldi	r25, 0x00	; 0
    1150:	0e 94 11 13 	call	0x2622	; 0x2622 <delayMicroseconds>
    1154:	c8 81       	ld	r28, Y
    1156:	78 94       	sei
    1158:	85 e3       	ldi	r24, 0x35	; 53
    115a:	90 e0       	ldi	r25, 0x00	; 0
    115c:	0e 94 11 13 	call	0x2622	; 0x2622 <delayMicroseconds>
    1160:	c0 23       	and	r28, r16
    1162:	81 e0       	ldi	r24, 0x01	; 1
    1164:	09 f4       	brne	.+2      	; 0x1168 <_ZN7OneWire8read_bitEv+0x4c>
    1166:	80 e0       	ldi	r24, 0x00	; 0
    1168:	df 91       	pop	r29
    116a:	cf 91       	pop	r28
    116c:	1f 91       	pop	r17
    116e:	0f 91       	pop	r16
    1170:	08 95       	ret

00001172 <_ZN7OneWire5writeEhh>:
    1172:	df 92       	push	r13
    1174:	ef 92       	push	r14
    1176:	ff 92       	push	r15
    1178:	0f 93       	push	r16
    117a:	1f 93       	push	r17
    117c:	cf 93       	push	r28
    117e:	df 93       	push	r29
    1180:	ec 01       	movw	r28, r24
    1182:	d6 2e       	mov	r13, r22
    1184:	e4 2e       	mov	r14, r20
    1186:	08 e0       	ldi	r16, 0x08	; 8
    1188:	10 e0       	ldi	r17, 0x00	; 0
    118a:	ff 24       	eor	r15, r15
    118c:	f3 94       	inc	r15
    118e:	61 e0       	ldi	r22, 0x01	; 1
    1190:	8d 2d       	mov	r24, r13
    1192:	8f 21       	and	r24, r15
    1194:	09 f4       	brne	.+2      	; 0x1198 <_ZN7OneWire5writeEhh+0x26>
    1196:	60 e0       	ldi	r22, 0x00	; 0
    1198:	ce 01       	movw	r24, r28
    119a:	0e 94 5b 08 	call	0x10b6	; 0x10b6 <_ZN7OneWire9write_bitEh>
    119e:	ff 0c       	add	r15, r15
    11a0:	01 50       	subi	r16, 0x01	; 1
    11a2:	11 09       	sbc	r17, r1
    11a4:	a1 f7       	brne	.-24     	; 0x118e <_ZN7OneWire5writeEhh+0x1c>
    11a6:	e1 10       	cpse	r14, r1
    11a8:	10 c0       	rjmp	.+32     	; 0x11ca <_ZN7OneWire5writeEhh+0x58>
    11aa:	f8 94       	cli
    11ac:	e9 81       	ldd	r30, Y+1	; 0x01
    11ae:	fa 81       	ldd	r31, Y+2	; 0x02
    11b0:	91 81       	ldd	r25, Z+1	; 0x01
    11b2:	88 81       	ld	r24, Y
    11b4:	80 95       	com	r24
    11b6:	89 23       	and	r24, r25
    11b8:	81 83       	std	Z+1, r24	; 0x01
    11ba:	e9 81       	ldd	r30, Y+1	; 0x01
    11bc:	fa 81       	ldd	r31, Y+2	; 0x02
    11be:	92 81       	ldd	r25, Z+2	; 0x02
    11c0:	88 81       	ld	r24, Y
    11c2:	80 95       	com	r24
    11c4:	89 23       	and	r24, r25
    11c6:	82 83       	std	Z+2, r24	; 0x02
    11c8:	78 94       	sei
    11ca:	df 91       	pop	r29
    11cc:	cf 91       	pop	r28
    11ce:	1f 91       	pop	r17
    11d0:	0f 91       	pop	r16
    11d2:	ff 90       	pop	r15
    11d4:	ef 90       	pop	r14
    11d6:	df 90       	pop	r13
    11d8:	08 95       	ret

000011da <_ZN7OneWire4readEv>:
    11da:	ef 92       	push	r14
    11dc:	ff 92       	push	r15
    11de:	0f 93       	push	r16
    11e0:	1f 93       	push	r17
    11e2:	cf 93       	push	r28
    11e4:	df 93       	push	r29
    11e6:	7c 01       	movw	r14, r24
    11e8:	08 e0       	ldi	r16, 0x08	; 8
    11ea:	10 e0       	ldi	r17, 0x00	; 0
    11ec:	c0 e0       	ldi	r28, 0x00	; 0
    11ee:	d1 e0       	ldi	r29, 0x01	; 1
    11f0:	c7 01       	movw	r24, r14
    11f2:	0e 94 8e 08 	call	0x111c	; 0x111c <_ZN7OneWire8read_bitEv>
    11f6:	81 11       	cpse	r24, r1
    11f8:	cd 2b       	or	r28, r29
    11fa:	dd 0f       	add	r29, r29
    11fc:	01 50       	subi	r16, 0x01	; 1
    11fe:	11 09       	sbc	r17, r1
    1200:	b9 f7       	brne	.-18     	; 0x11f0 <_ZN7OneWire4readEv+0x16>
    1202:	8c 2f       	mov	r24, r28
    1204:	df 91       	pop	r29
    1206:	cf 91       	pop	r28
    1208:	1f 91       	pop	r17
    120a:	0f 91       	pop	r16
    120c:	ff 90       	pop	r15
    120e:	ef 90       	pop	r14
    1210:	08 95       	ret

00001212 <_ZN7OneWire6selectEPKh>:
    1212:	ef 92       	push	r14
    1214:	ff 92       	push	r15
    1216:	0f 93       	push	r16
    1218:	1f 93       	push	r17
    121a:	cf 93       	push	r28
    121c:	df 93       	push	r29
    121e:	8c 01       	movw	r16, r24
    1220:	7b 01       	movw	r14, r22
    1222:	40 e0       	ldi	r20, 0x00	; 0
    1224:	65 e5       	ldi	r22, 0x55	; 85
    1226:	0e 94 b9 08 	call	0x1172	; 0x1172 <_ZN7OneWire5writeEhh>
    122a:	e7 01       	movw	r28, r14
    122c:	88 e0       	ldi	r24, 0x08	; 8
    122e:	e8 0e       	add	r14, r24
    1230:	f1 1c       	adc	r15, r1
    1232:	69 91       	ld	r22, Y+
    1234:	40 e0       	ldi	r20, 0x00	; 0
    1236:	c8 01       	movw	r24, r16
    1238:	0e 94 b9 08 	call	0x1172	; 0x1172 <_ZN7OneWire5writeEhh>
    123c:	ce 15       	cp	r28, r14
    123e:	df 05       	cpc	r29, r15
    1240:	c1 f7       	brne	.-16     	; 0x1232 <_ZN7OneWire6selectEPKh+0x20>
    1242:	df 91       	pop	r29
    1244:	cf 91       	pop	r28
    1246:	1f 91       	pop	r17
    1248:	0f 91       	pop	r16
    124a:	ff 90       	pop	r15
    124c:	ef 90       	pop	r14
    124e:	08 95       	ret

00001250 <_ZN7OneWire12reset_searchEv>:
    1250:	fc 01       	movw	r30, r24
    1252:	13 86       	std	Z+11, r1	; 0x0b
    1254:	15 86       	std	Z+13, r1	; 0x0d
    1256:	14 86       	std	Z+12, r1	; 0x0c
    1258:	dc 01       	movw	r26, r24
    125a:	1b 96       	adiw	r26, 0x0b	; 11
    125c:	33 96       	adiw	r30, 0x03	; 3
    125e:	1e 92       	st	-X, r1
    1260:	ae 17       	cp	r26, r30
    1262:	bf 07       	cpc	r27, r31
    1264:	e1 f7       	brne	.-8      	; 0x125e <_ZN7OneWire12reset_searchEv+0xe>
    1266:	08 95       	ret

00001268 <_ZN7OneWire5beginEh>:
    1268:	1f 93       	push	r17
    126a:	cf 93       	push	r28
    126c:	df 93       	push	r29
    126e:	ec 01       	movw	r28, r24
    1270:	16 2f       	mov	r17, r22
    1272:	60 e0       	ldi	r22, 0x00	; 0
    1274:	81 2f       	mov	r24, r17
    1276:	0e 94 fc 13 	call	0x27f8	; 0x27f8 <pinMode>
    127a:	61 2f       	mov	r22, r17
    127c:	70 e0       	ldi	r23, 0x00	; 0
    127e:	fb 01       	movw	r30, r22
    1280:	ea 53       	subi	r30, 0x3A	; 58
    1282:	ff 4f       	sbci	r31, 0xFF	; 255
    1284:	e4 91       	lpm	r30, Z
    1286:	e8 83       	st	Y, r30
    1288:	fb 01       	movw	r30, r22
    128a:	e6 52       	subi	r30, 0x26	; 38
    128c:	ff 4f       	sbci	r31, 0xFF	; 255
    128e:	e4 91       	lpm	r30, Z
    1290:	f0 e0       	ldi	r31, 0x00	; 0
    1292:	ee 0f       	add	r30, r30
    1294:	ff 1f       	adc	r31, r31
    1296:	e2 51       	subi	r30, 0x12	; 18
    1298:	ff 4f       	sbci	r31, 0xFF	; 255
    129a:	85 91       	lpm	r24, Z+
    129c:	94 91       	lpm	r25, Z
    129e:	9a 83       	std	Y+2, r25	; 0x02
    12a0:	89 83       	std	Y+1, r24	; 0x01
    12a2:	ce 01       	movw	r24, r28
    12a4:	df 91       	pop	r29
    12a6:	cf 91       	pop	r28
    12a8:	1f 91       	pop	r17
    12aa:	0c 94 28 09 	jmp	0x1250	; 0x1250 <_ZN7OneWire12reset_searchEv>

000012ae <_ZN7OneWire6searchEPhb>:
    12ae:	bf 92       	push	r11
    12b0:	cf 92       	push	r12
    12b2:	df 92       	push	r13
    12b4:	ef 92       	push	r14
    12b6:	ff 92       	push	r15
    12b8:	0f 93       	push	r16
    12ba:	1f 93       	push	r17
    12bc:	cf 93       	push	r28
    12be:	df 93       	push	r29
    12c0:	ec 01       	movw	r28, r24
    12c2:	6b 01       	movw	r12, r22
    12c4:	14 2f       	mov	r17, r20
    12c6:	8d 85       	ldd	r24, Y+13	; 0x0d
    12c8:	81 11       	cpse	r24, r1
    12ca:	05 c0       	rjmp	.+10     	; 0x12d6 <_ZN7OneWire6searchEPhb+0x28>
    12cc:	ce 01       	movw	r24, r28
    12ce:	0e 94 1c 08 	call	0x1038	; 0x1038 <_ZN7OneWire5resetEv>
    12d2:	81 11       	cpse	r24, r1
    12d4:	05 c0       	rjmp	.+10     	; 0x12e0 <_ZN7OneWire6searchEPhb+0x32>
    12d6:	1b 86       	std	Y+11, r1	; 0x0b
    12d8:	1d 86       	std	Y+13, r1	; 0x0d
    12da:	1c 86       	std	Y+12, r1	; 0x0c
    12dc:	80 e0       	ldi	r24, 0x00	; 0
    12de:	64 c0       	rjmp	.+200    	; 0x13a8 <_ZN7OneWire6searchEPhb+0xfa>
    12e0:	40 e0       	ldi	r20, 0x00	; 0
    12e2:	11 23       	and	r17, r17
    12e4:	11 f0       	breq	.+4      	; 0x12ea <_ZN7OneWire6searchEPhb+0x3c>
    12e6:	60 ef       	ldi	r22, 0xF0	; 240
    12e8:	01 c0       	rjmp	.+2      	; 0x12ec <_ZN7OneWire6searchEPhb+0x3e>
    12ea:	6c ee       	ldi	r22, 0xEC	; 236
    12ec:	ce 01       	movw	r24, r28
    12ee:	0e 94 b9 08 	call	0x1172	; 0x1172 <_ZN7OneWire5writeEhh>
    12f2:	01 e0       	ldi	r16, 0x01	; 1
    12f4:	e1 2c       	mov	r14, r1
    12f6:	b1 2c       	mov	r11, r1
    12f8:	11 e0       	ldi	r17, 0x01	; 1
    12fa:	ce 01       	movw	r24, r28
    12fc:	0e 94 8e 08 	call	0x111c	; 0x111c <_ZN7OneWire8read_bitEv>
    1300:	f8 2e       	mov	r15, r24
    1302:	ce 01       	movw	r24, r28
    1304:	0e 94 8e 08 	call	0x111c	; 0x111c <_ZN7OneWire8read_bitEv>
    1308:	91 e0       	ldi	r25, 0x01	; 1
    130a:	f9 12       	cpse	r15, r25
    130c:	03 c0       	rjmp	.+6      	; 0x1314 <_ZN7OneWire6searchEPhb+0x66>
    130e:	81 30       	cpi	r24, 0x01	; 1
    1310:	b1 f4       	brne	.+44     	; 0x133e <_ZN7OneWire6searchEPhb+0x90>
    1312:	34 c0       	rjmp	.+104    	; 0x137c <_ZN7OneWire6searchEPhb+0xce>
    1314:	2e 2d       	mov	r18, r14
    1316:	30 e0       	ldi	r19, 0x00	; 0
    1318:	f8 12       	cpse	r15, r24
    131a:	1b c0       	rjmp	.+54     	; 0x1352 <_ZN7OneWire6searchEPhb+0xa4>
    131c:	8b 85       	ldd	r24, Y+11	; 0x0b
    131e:	18 17       	cp	r17, r24
    1320:	38 f4       	brcc	.+14     	; 0x1330 <_ZN7OneWire6searchEPhb+0x82>
    1322:	fe 01       	movw	r30, r28
    1324:	e2 0f       	add	r30, r18
    1326:	f3 1f       	adc	r31, r19
    1328:	83 81       	ldd	r24, Z+3	; 0x03
    132a:	80 23       	and	r24, r16
    132c:	41 f4       	brne	.+16     	; 0x133e <_ZN7OneWire6searchEPhb+0x90>
    132e:	02 c0       	rjmp	.+4      	; 0x1334 <_ZN7OneWire6searchEPhb+0x86>
    1330:	18 17       	cp	r17, r24
    1332:	29 f0       	breq	.+10     	; 0x133e <_ZN7OneWire6searchEPhb+0x90>
    1334:	f1 2c       	mov	r15, r1
    1336:	19 30       	cpi	r17, 0x09	; 9
    1338:	58 f4       	brcc	.+22     	; 0x1350 <_ZN7OneWire6searchEPhb+0xa2>
    133a:	1c 87       	std	Y+12, r17	; 0x0c
    133c:	09 c0       	rjmp	.+18     	; 0x1350 <_ZN7OneWire6searchEPhb+0xa2>
    133e:	fe 01       	movw	r30, r28
    1340:	ee 0d       	add	r30, r14
    1342:	f1 1d       	adc	r31, r1
    1344:	83 81       	ldd	r24, Z+3	; 0x03
    1346:	80 2b       	or	r24, r16
    1348:	83 83       	std	Z+3, r24	; 0x03
    134a:	ff 24       	eor	r15, r15
    134c:	f3 94       	inc	r15
    134e:	09 c0       	rjmp	.+18     	; 0x1362 <_ZN7OneWire6searchEPhb+0xb4>
    1350:	b1 2e       	mov	r11, r17
    1352:	fe 01       	movw	r30, r28
    1354:	e2 0f       	add	r30, r18
    1356:	f3 1f       	adc	r31, r19
    1358:	93 81       	ldd	r25, Z+3	; 0x03
    135a:	80 2f       	mov	r24, r16
    135c:	80 95       	com	r24
    135e:	89 23       	and	r24, r25
    1360:	83 83       	std	Z+3, r24	; 0x03
    1362:	6f 2d       	mov	r22, r15
    1364:	ce 01       	movw	r24, r28
    1366:	0e 94 5b 08 	call	0x10b6	; 0x10b6 <_ZN7OneWire9write_bitEh>
    136a:	1f 5f       	subi	r17, 0xFF	; 255
    136c:	00 0f       	add	r16, r16
    136e:	11 f4       	brne	.+4      	; 0x1374 <_ZN7OneWire6searchEPhb+0xc6>
    1370:	e3 94       	inc	r14
    1372:	01 e0       	ldi	r16, 0x01	; 1
    1374:	87 e0       	ldi	r24, 0x07	; 7
    1376:	8e 15       	cp	r24, r14
    1378:	08 f0       	brcs	.+2      	; 0x137c <_ZN7OneWire6searchEPhb+0xce>
    137a:	bf cf       	rjmp	.-130    	; 0x12fa <_ZN7OneWire6searchEPhb+0x4c>
    137c:	11 34       	cpi	r17, 0x41	; 65
    137e:	08 f4       	brcc	.+2      	; 0x1382 <_ZN7OneWire6searchEPhb+0xd4>
    1380:	aa cf       	rjmp	.-172    	; 0x12d6 <_ZN7OneWire6searchEPhb+0x28>
    1382:	bb 86       	std	Y+11, r11	; 0x0b
    1384:	b1 10       	cpse	r11, r1
    1386:	02 c0       	rjmp	.+4      	; 0x138c <_ZN7OneWire6searchEPhb+0xde>
    1388:	81 e0       	ldi	r24, 0x01	; 1
    138a:	8d 87       	std	Y+13, r24	; 0x0d
    138c:	8b 81       	ldd	r24, Y+3	; 0x03
    138e:	88 23       	and	r24, r24
    1390:	09 f4       	brne	.+2      	; 0x1394 <_ZN7OneWire6searchEPhb+0xe6>
    1392:	a1 cf       	rjmp	.-190    	; 0x12d6 <_ZN7OneWire6searchEPhb+0x28>
    1394:	de 01       	movw	r26, r28
    1396:	13 96       	adiw	r26, 0x03	; 3
    1398:	f6 01       	movw	r30, r12
    139a:	2b 96       	adiw	r28, 0x0b	; 11
    139c:	8d 91       	ld	r24, X+
    139e:	81 93       	st	Z+, r24
    13a0:	ca 17       	cp	r28, r26
    13a2:	db 07       	cpc	r29, r27
    13a4:	d9 f7       	brne	.-10     	; 0x139c <_ZN7OneWire6searchEPhb+0xee>
    13a6:	81 e0       	ldi	r24, 0x01	; 1
    13a8:	df 91       	pop	r29
    13aa:	cf 91       	pop	r28
    13ac:	1f 91       	pop	r17
    13ae:	0f 91       	pop	r16
    13b0:	ff 90       	pop	r15
    13b2:	ef 90       	pop	r14
    13b4:	df 90       	pop	r13
    13b6:	cf 90       	pop	r12
    13b8:	bf 90       	pop	r11
    13ba:	08 95       	ret

000013bc <_ZN7OneWire4crc8EPKhh>:
    13bc:	dc 01       	movw	r26, r24
    13be:	80 e0       	ldi	r24, 0x00	; 0
    13c0:	61 50       	subi	r22, 0x01	; 1
    13c2:	98 f0       	brcs	.+38     	; 0x13ea <_ZN7OneWire4crc8EPKhh+0x2e>
    13c4:	2d 91       	ld	r18, X+
    13c6:	98 2f       	mov	r25, r24
    13c8:	92 27       	eor	r25, r18
    13ca:	e9 2f       	mov	r30, r25
    13cc:	ef 70       	andi	r30, 0x0F	; 15
    13ce:	f0 e0       	ldi	r31, 0x00	; 0
    13d0:	ee 56       	subi	r30, 0x6E	; 110
    13d2:	ff 4f       	sbci	r31, 0xFF	; 255
    13d4:	24 91       	lpm	r18, Z
    13d6:	92 95       	swap	r25
    13d8:	9f 70       	andi	r25, 0x0F	; 15
    13da:	e9 2f       	mov	r30, r25
    13dc:	f0 e0       	ldi	r31, 0x00	; 0
    13de:	ee 55       	subi	r30, 0x5E	; 94
    13e0:	ff 4f       	sbci	r31, 0xFF	; 255
    13e2:	e4 91       	lpm	r30, Z
    13e4:	82 2f       	mov	r24, r18
    13e6:	8e 27       	eor	r24, r30
    13e8:	eb cf       	rjmp	.-42     	; 0x13c0 <_ZN7OneWire4crc8EPKhh+0x4>
    13ea:	08 95       	ret

000013ec <_Z6phInitv>:
}

void calibratePH(long temperaturePH) {
	float voltage = analogRead(PH_PIN)/1024.0*5000;
	ph.calibration(voltage, temperaturePH);
    13ec:	86 ed       	ldi	r24, 0xD6	; 214
    13ee:	93 e0       	ldi	r25, 0x03	; 3
    13f0:	0c 94 de 00 	jmp	0x1bc	; 0x1bc <_ZN10DFRobot_PH5beginEv>

000013f4 <_GLOBAL__sub_I_ph>:
#include "phSensor.h"

DFRobot_PH ph;
    13f4:	86 ed       	ldi	r24, 0xD6	; 214
    13f6:	93 e0       	ldi	r25, 0x03	; 3
    13f8:	0c 94 b7 00 	jmp	0x16e	; 0x16e <_ZN10DFRobot_PHC1Ev>

000013fc <_GLOBAL__sub_D_ph>:
    13fc:	86 ed       	ldi	r24, 0xD6	; 214
    13fe:	93 e0       	ldi	r25, 0x03	; 3
    1400:	0c 94 dd 00 	jmp	0x1ba	; 0x1ba <_ZN10DFRobot_PHD1Ev>

00001404 <_ZN9MD_TCS23010initialiseEv>:
  }
  FreqCount.end();      // stop
  DUMP("VALUE ", FreqCount.read());

  return(FreqCount.read() * _readDiv);
}
    1404:	0f 93       	push	r16
    1406:	1f 93       	push	r17
    1408:	fc 01       	movw	r30, r24
    140a:	8f ef       	ldi	r24, 0xFF	; 255
    140c:	80 83       	st	Z, r24
    140e:	81 83       	std	Z+1, r24	; 0x01
    1410:	82 83       	std	Z+2, r24	; 0x02
    1412:	83 83       	std	Z+3, r24	; 0x03
    1414:	84 83       	std	Z+4, r24	; 0x04
    1416:	8a e0       	ldi	r24, 0x0A	; 10
    1418:	85 83       	std	Z+5, r24	; 0x05
    141a:	16 82       	std	Z+6, r1	; 0x06
    141c:	df 01       	movw	r26, r30
    141e:	17 96       	adiw	r26, 0x07	; 7
    1420:	73 96       	adiw	r30, 0x13	; 19
    1422:	00 e7       	ldi	r16, 0x70	; 112
    1424:	17 e1       	ldi	r17, 0x17	; 23
    1426:	20 e0       	ldi	r18, 0x00	; 0
    1428:	30 e0       	ldi	r19, 0x00	; 0
    142a:	48 ed       	ldi	r20, 0xD8	; 216
    142c:	56 ed       	ldi	r21, 0xD6	; 214
    142e:	60 e0       	ldi	r22, 0x00	; 0
    1430:	70 e0       	ldi	r23, 0x00	; 0
    1432:	0d 93       	st	X+, r16
    1434:	1d 93       	st	X+, r17
    1436:	2d 93       	st	X+, r18
    1438:	3d 93       	st	X+, r19
    143a:	18 96       	adiw	r26, 0x08	; 8
    143c:	4d 93       	st	X+, r20
    143e:	5d 93       	st	X+, r21
    1440:	6d 93       	st	X+, r22
    1442:	7c 93       	st	X, r23
    1444:	1b 97       	sbiw	r26, 0x0b	; 11
    1446:	ae 17       	cp	r26, r30
    1448:	bf 07       	cpc	r27, r31
    144a:	99 f7       	brne	.-26     	; 0x1432 <_ZN9MD_TCS23010initialiseEv+0x2e>
    144c:	1f 91       	pop	r17
    144e:	0f 91       	pop	r16
    1450:	08 95       	ret

00001452 <_ZN9MD_TCS230C1Ehhh>:
    1452:	ff 92       	push	r15
    1454:	0f 93       	push	r16
    1456:	1f 93       	push	r17
    1458:	cf 93       	push	r28
    145a:	df 93       	push	r29
    145c:	ec 01       	movw	r28, r24
    145e:	f6 2e       	mov	r15, r22
    1460:	04 2f       	mov	r16, r20
    1462:	12 2f       	mov	r17, r18
    1464:	0e 94 02 0a 	call	0x1404	; 0x1404 <_ZN9MD_TCS23010initialiseEv>
    1468:	fb 82       	std	Y+3, r15	; 0x03
    146a:	0c 83       	std	Y+4, r16	; 0x04
    146c:	18 83       	st	Y, r17
    146e:	df 91       	pop	r29
    1470:	cf 91       	pop	r28
    1472:	1f 91       	pop	r17
    1474:	0f 91       	pop	r16
    1476:	ff 90       	pop	r15
    1478:	08 95       	ret

0000147a <_ZN9MD_TCS230D1Ev>:
    147a:	08 95       	ret

0000147c <_ZN9MD_TCS2309setFilterEh>:
    147c:	cf 93       	push	r28
    147e:	df 93       	push	r29
    1480:	ec 01       	movw	r28, r24
    1482:	8b 81       	ldd	r24, Y+3	; 0x03
    1484:	8f 3f       	cpi	r24, 0xFF	; 255
    1486:	e9 f0       	breq	.+58     	; 0x14c2 <_ZN9MD_TCS2309setFilterEh+0x46>
    1488:	9c 81       	ldd	r25, Y+4	; 0x04
    148a:	9f 3f       	cpi	r25, 0xFF	; 255
    148c:	d1 f0       	breq	.+52     	; 0x14c2 <_ZN9MD_TCS2309setFilterEh+0x46>
    148e:	61 30       	cpi	r22, 0x01	; 1
    1490:	49 f0       	breq	.+18     	; 0x14a4 <_ZN9MD_TCS2309setFilterEh+0x28>
    1492:	30 f0       	brcs	.+12     	; 0x14a0 <_ZN9MD_TCS2309setFilterEh+0x24>
    1494:	62 30       	cpi	r22, 0x02	; 2
    1496:	41 f0       	breq	.+16     	; 0x14a8 <_ZN9MD_TCS2309setFilterEh+0x2c>
    1498:	63 30       	cpi	r22, 0x03	; 3
    149a:	99 f4       	brne	.+38     	; 0x14c2 <_ZN9MD_TCS2309setFilterEh+0x46>
    149c:	61 e0       	ldi	r22, 0x01	; 1
    149e:	09 c0       	rjmp	.+18     	; 0x14b2 <_ZN9MD_TCS2309setFilterEh+0x36>
    14a0:	60 e0       	ldi	r22, 0x00	; 0
    14a2:	07 c0       	rjmp	.+14     	; 0x14b2 <_ZN9MD_TCS2309setFilterEh+0x36>
    14a4:	61 e0       	ldi	r22, 0x01	; 1
    14a6:	01 c0       	rjmp	.+2      	; 0x14aa <_ZN9MD_TCS2309setFilterEh+0x2e>
    14a8:	60 e0       	ldi	r22, 0x00	; 0
    14aa:	0e 94 38 14 	call	0x2870	; 0x2870 <digitalWrite>
    14ae:	61 e0       	ldi	r22, 0x01	; 1
    14b0:	03 c0       	rjmp	.+6      	; 0x14b8 <_ZN9MD_TCS2309setFilterEh+0x3c>
    14b2:	0e 94 38 14 	call	0x2870	; 0x2870 <digitalWrite>
    14b6:	60 e0       	ldi	r22, 0x00	; 0
    14b8:	8c 81       	ldd	r24, Y+4	; 0x04
    14ba:	df 91       	pop	r29
    14bc:	cf 91       	pop	r28
    14be:	0c 94 38 14 	jmp	0x2870	; 0x2870 <digitalWrite>
    14c2:	df 91       	pop	r29
    14c4:	cf 91       	pop	r28
    14c6:	08 95       	ret

000014c8 <_ZN9MD_TCS23013setFrequency2Eh>:
    14c8:	cf 93       	push	r28
    14ca:	df 93       	push	r29
    14cc:	ec 01       	movw	r28, r24
    14ce:	89 81       	ldd	r24, Y+1	; 0x01
    14d0:	8f 3f       	cpi	r24, 0xFF	; 255
    14d2:	e9 f0       	breq	.+58     	; 0x150e <_ZN9MD_TCS23013setFrequency2Eh+0x46>
    14d4:	9a 81       	ldd	r25, Y+2	; 0x02
    14d6:	9f 3f       	cpi	r25, 0xFF	; 255
    14d8:	d1 f0       	breq	.+52     	; 0x150e <_ZN9MD_TCS23013setFrequency2Eh+0x46>
    14da:	61 30       	cpi	r22, 0x01	; 1
    14dc:	49 f0       	breq	.+18     	; 0x14f0 <_ZN9MD_TCS23013setFrequency2Eh+0x28>
    14de:	30 f0       	brcs	.+12     	; 0x14ec <_ZN9MD_TCS23013setFrequency2Eh+0x24>
    14e0:	62 30       	cpi	r22, 0x02	; 2
    14e2:	41 f0       	breq	.+16     	; 0x14f4 <_ZN9MD_TCS23013setFrequency2Eh+0x2c>
    14e4:	63 30       	cpi	r22, 0x03	; 3
    14e6:	99 f4       	brne	.+38     	; 0x150e <_ZN9MD_TCS23013setFrequency2Eh+0x46>
    14e8:	60 e0       	ldi	r22, 0x00	; 0
    14ea:	09 c0       	rjmp	.+18     	; 0x14fe <_ZN9MD_TCS23013setFrequency2Eh+0x36>
    14ec:	61 e0       	ldi	r22, 0x01	; 1
    14ee:	03 c0       	rjmp	.+6      	; 0x14f6 <_ZN9MD_TCS23013setFrequency2Eh+0x2e>
    14f0:	61 e0       	ldi	r22, 0x01	; 1
    14f2:	05 c0       	rjmp	.+10     	; 0x14fe <_ZN9MD_TCS23013setFrequency2Eh+0x36>
    14f4:	60 e0       	ldi	r22, 0x00	; 0
    14f6:	0e 94 38 14 	call	0x2870	; 0x2870 <digitalWrite>
    14fa:	61 e0       	ldi	r22, 0x01	; 1
    14fc:	03 c0       	rjmp	.+6      	; 0x1504 <_ZN9MD_TCS23013setFrequency2Eh+0x3c>
    14fe:	0e 94 38 14 	call	0x2870	; 0x2870 <digitalWrite>
    1502:	60 e0       	ldi	r22, 0x00	; 0
    1504:	8a 81       	ldd	r24, Y+2	; 0x02
    1506:	df 91       	pop	r29
    1508:	cf 91       	pop	r28
    150a:	0c 94 38 14 	jmp	0x2870	; 0x2870 <digitalWrite>
    150e:	df 91       	pop	r29
    1510:	cf 91       	pop	r28
    1512:	08 95       	ret

00001514 <_ZN9MD_TCS2309setEnableEb>:
    1514:	fc 01       	movw	r30, r24
    1516:	20 81       	ld	r18, Z
    1518:	2f 3f       	cpi	r18, 0xFF	; 255
    151a:	29 f0       	breq	.+10     	; 0x1526 <_ZN9MD_TCS2309setEnableEb+0x12>
    151c:	91 e0       	ldi	r25, 0x01	; 1
    151e:	69 27       	eor	r22, r25
    1520:	82 2f       	mov	r24, r18
    1522:	0c 94 38 14 	jmp	0x2870	; 0x2870 <digitalWrite>
    1526:	66 23       	and	r22, r22
    1528:	19 f0       	breq	.+6      	; 0x1530 <_ZN9MD_TCS2309setEnableEb+0x1c>
    152a:	fc 01       	movw	r30, r24
    152c:	66 81       	ldd	r22, Z+6	; 0x06
    152e:	01 c0       	rjmp	.+2      	; 0x1532 <_ZN9MD_TCS2309setEnableEb+0x1e>
    1530:	63 e0       	ldi	r22, 0x03	; 3
    1532:	0c 94 64 0a 	jmp	0x14c8	; 0x14c8 <_ZN9MD_TCS23013setFrequency2Eh>

00001536 <_ZN9MD_TCS2305beginEv>:
    1536:	cf 93       	push	r28
    1538:	df 93       	push	r29
    153a:	ec 01       	movw	r28, r24
    153c:	89 81       	ldd	r24, Y+1	; 0x01
    153e:	8f 3f       	cpi	r24, 0xFF	; 255
    1540:	19 f0       	breq	.+6      	; 0x1548 <_ZN9MD_TCS2305beginEv+0x12>
    1542:	61 e0       	ldi	r22, 0x01	; 1
    1544:	0e 94 fc 13 	call	0x27f8	; 0x27f8 <pinMode>
    1548:	8a 81       	ldd	r24, Y+2	; 0x02
    154a:	8f 3f       	cpi	r24, 0xFF	; 255
    154c:	19 f0       	breq	.+6      	; 0x1554 <_ZN9MD_TCS2305beginEv+0x1e>
    154e:	61 e0       	ldi	r22, 0x01	; 1
    1550:	0e 94 fc 13 	call	0x27f8	; 0x27f8 <pinMode>
    1554:	8b 81       	ldd	r24, Y+3	; 0x03
    1556:	8f 3f       	cpi	r24, 0xFF	; 255
    1558:	19 f0       	breq	.+6      	; 0x1560 <_ZN9MD_TCS2305beginEv+0x2a>
    155a:	61 e0       	ldi	r22, 0x01	; 1
    155c:	0e 94 fc 13 	call	0x27f8	; 0x27f8 <pinMode>
    1560:	8c 81       	ldd	r24, Y+4	; 0x04
    1562:	8f 3f       	cpi	r24, 0xFF	; 255
    1564:	19 f0       	breq	.+6      	; 0x156c <_ZN9MD_TCS2305beginEv+0x36>
    1566:	61 e0       	ldi	r22, 0x01	; 1
    1568:	0e 94 fc 13 	call	0x27f8	; 0x27f8 <pinMode>
    156c:	88 81       	ld	r24, Y
    156e:	8f 3f       	cpi	r24, 0xFF	; 255
    1570:	19 f0       	breq	.+6      	; 0x1578 <_ZN9MD_TCS2305beginEv+0x42>
    1572:	61 e0       	ldi	r22, 0x01	; 1
    1574:	0e 94 fc 13 	call	0x27f8	; 0x27f8 <pinMode>
    1578:	60 e0       	ldi	r22, 0x00	; 0
    157a:	ce 01       	movw	r24, r28
    157c:	0e 94 8a 0a 	call	0x1514	; 0x1514 <_ZN9MD_TCS2309setEnableEb>
    1580:	6e 81       	ldd	r22, Y+6	; 0x06
    1582:	ce 01       	movw	r24, r28
    1584:	df 91       	pop	r29
    1586:	cf 91       	pop	r28
    1588:	0c 94 64 0a 	jmp	0x14c8	; 0x14c8 <_ZN9MD_TCS23013setFrequency2Eh>

0000158c <_ZN9MD_TCS2306getRGBEP9colorData>:
    158c:	dc 01       	movw	r26, r24
    158e:	fb 01       	movw	r30, r22
    1590:	30 97       	sbiw	r30, 0x00	; 0
    1592:	59 f0       	breq	.+22     	; 0x15aa <_ZN9MD_TCS2306getRGBEP9colorData+0x1e>
    1594:	9b 96       	adiw	r26, 0x2b	; 43
    1596:	8c 91       	ld	r24, X
    1598:	9b 97       	sbiw	r26, 0x2b	; 43
    159a:	80 83       	st	Z, r24
    159c:	9c 96       	adiw	r26, 0x2c	; 44
    159e:	8c 91       	ld	r24, X
    15a0:	9c 97       	sbiw	r26, 0x2c	; 44
    15a2:	81 83       	std	Z+1, r24	; 0x01
    15a4:	9d 96       	adiw	r26, 0x2d	; 45
    15a6:	8c 91       	ld	r24, X
    15a8:	82 83       	std	Z+2, r24	; 0x02
    15aa:	08 95       	ret

000015ac <_ZN9MD_TCS23017RGBTransformationEv>:
  return(s);
}

void MD_TCS230::RGBTransformation(void)
// Exploiting linear relationship to remap the range 
{
    15ac:	4f 92       	push	r4
    15ae:	5f 92       	push	r5
    15b0:	6f 92       	push	r6
    15b2:	7f 92       	push	r7
    15b4:	8f 92       	push	r8
    15b6:	9f 92       	push	r9
    15b8:	af 92       	push	r10
    15ba:	bf 92       	push	r11
    15bc:	df 92       	push	r13
    15be:	ef 92       	push	r14
    15c0:	ff 92       	push	r15
    15c2:	0f 93       	push	r16
    15c4:	1f 93       	push	r17
    15c6:	cf 93       	push	r28
    15c8:	df 93       	push	r29
    15ca:	8c 01       	movw	r16, r24
    15cc:	09 5f       	subi	r16, 0xF9	; 249
    15ce:	1f 4f       	sbci	r17, 0xFF	; 255
    15d0:	ec 01       	movw	r28, r24
    15d2:	7c 01       	movw	r14, r24
    15d4:	83 e1       	ldi	r24, 0x13	; 19
    15d6:	e8 0e       	add	r14, r24
    15d8:	f1 1c       	adc	r15, r1
    x = (_Fo.value[i] - _Fd.value[i]) * 255;
    x /= (_Fw.value[i] - _Fd.value[i]);

    // copy results back into the global structures
    if (x < 0) _rgb.value[i] = 0; 
    else if (x > 255) _rgb.value[i] = 255;
    15da:	dd 24       	eor	r13, r13
    15dc:	da 94       	dec	r13
    15de:	f8 01       	movw	r30, r16
{
  int32_t x;

  for (uint8_t i=0; i<RGB_SIZE; i++)
  {
    x = (_Fo.value[i] - _Fd.value[i]) * 255;
    15e0:	d8 01       	movw	r26, r16
    15e2:	8d 90       	ld	r8, X+
    15e4:	9d 90       	ld	r9, X+
    15e6:	ad 90       	ld	r10, X+
    15e8:	bd 90       	ld	r11, X+
    15ea:	8d 01       	movw	r16, r26
    15ec:	80 8d       	ldd	r24, Z+24	; 0x18
    15ee:	91 8d       	ldd	r25, Z+25	; 0x19
    15f0:	a2 8d       	ldd	r26, Z+26	; 0x1a
    15f2:	b3 8d       	ldd	r27, Z+27	; 0x1b
    15f4:	9c 01       	movw	r18, r24
    15f6:	ad 01       	movw	r20, r26
    15f8:	28 19       	sub	r18, r8
    15fa:	39 09       	sbc	r19, r9
    15fc:	4a 09       	sbc	r20, r10
    15fe:	5b 09       	sbc	r21, r11
    1600:	af ef       	ldi	r26, 0xFF	; 255
    1602:	b0 e0       	ldi	r27, 0x00	; 0
    1604:	0e 94 88 21 	call	0x4310	; 0x4310 <__muluhisi3>
    x /= (_Fw.value[i] - _Fd.value[i]);
    1608:	f8 01       	movw	r30, r16
    160a:	40 84       	ldd	r4, Z+8	; 0x08
    160c:	51 84       	ldd	r5, Z+9	; 0x09
    160e:	62 84       	ldd	r6, Z+10	; 0x0a
    1610:	73 84       	ldd	r7, Z+11	; 0x0b
    1612:	a3 01       	movw	r20, r6
    1614:	92 01       	movw	r18, r4
    1616:	28 19       	sub	r18, r8
    1618:	39 09       	sbc	r19, r9
    161a:	4a 09       	sbc	r20, r10
    161c:	5b 09       	sbc	r21, r11
    161e:	0e 94 63 21 	call	0x42c6	; 0x42c6 <__divmodsi4>

    // copy results back into the global structures
    if (x < 0) _rgb.value[i] = 0; 
    1622:	57 ff       	sbrs	r21, 7
    1624:	02 c0       	rjmp	.+4      	; 0x162a <_ZN9MD_TCS23017RGBTransformationEv+0x7e>
    1626:	1b a6       	std	Y+43, r1	; 0x2b
    1628:	09 c0       	rjmp	.+18     	; 0x163c <_ZN9MD_TCS23017RGBTransformationEv+0x90>
    else if (x > 255) _rgb.value[i] = 255;
    162a:	2f 3f       	cpi	r18, 0xFF	; 255
    162c:	31 05       	cpc	r19, r1
    162e:	41 05       	cpc	r20, r1
    1630:	51 05       	cpc	r21, r1
    1632:	19 f0       	breq	.+6      	; 0x163a <_ZN9MD_TCS23017RGBTransformationEv+0x8e>
    1634:	14 f0       	brlt	.+4      	; 0x163a <_ZN9MD_TCS23017RGBTransformationEv+0x8e>
    1636:	db a6       	std	Y+43, r13	; 0x2b
    1638:	01 c0       	rjmp	.+2      	; 0x163c <_ZN9MD_TCS23017RGBTransformationEv+0x90>
    else _rgb.value[i] = x;
    163a:	2b a7       	std	Y+43, r18	; 0x2b
    163c:	21 96       	adiw	r28, 0x01	; 1
void MD_TCS230::RGBTransformation(void)
// Exploiting linear relationship to remap the range 
{
  int32_t x;

  for (uint8_t i=0; i<RGB_SIZE; i++)
    163e:	0e 15       	cp	r16, r14
    1640:	1f 05       	cpc	r17, r15
    1642:	69 f6       	brne	.-102    	; 0x15de <_ZN9MD_TCS23017RGBTransformationEv+0x32>
    // copy results back into the global structures
    if (x < 0) _rgb.value[i] = 0; 
    else if (x > 255) _rgb.value[i] = 255;
    else _rgb.value[i] = x;
  }
}
    1644:	df 91       	pop	r29
    1646:	cf 91       	pop	r28
    1648:	1f 91       	pop	r17
    164a:	0f 91       	pop	r16
    164c:	ff 90       	pop	r15
    164e:	ef 90       	pop	r14
    1650:	df 90       	pop	r13
    1652:	bf 90       	pop	r11
    1654:	af 90       	pop	r10
    1656:	9f 90       	pop	r9
    1658:	8f 90       	pop	r8
    165a:	7f 90       	pop	r7
    165c:	6f 90       	pop	r6
    165e:	5f 90       	pop	r5
    1660:	4f 90       	pop	r4
    1662:	08 95       	ret

00001664 <_ZN9MD_TCS2307readFSMEh>:
  return(_readState == 0);
}

uint8_t MD_TCS230::readFSM(uint8_t s)
// Finite State Machine to read a value (internal function)
{
    1664:	0f 93       	push	r16
    1666:	1f 93       	push	r17
    1668:	cf 93       	push	r28
    166a:	df 93       	push	r29
    166c:	8c 01       	movw	r16, r24
    166e:	c6 2f       	mov	r28, r22
  static const uint8_t seq[] = { TCS230_RGB_R, TCS230_RGB_G, TCS230_RGB_B };
  static uint8_t       currCol;  // index for seq above

  switch(s)
    1670:	61 30       	cpi	r22, 0x01	; 1
    1672:	49 f0       	breq	.+18     	; 0x1686 <_ZN9MD_TCS2307readFSMEh+0x22>
    1674:	18 f0       	brcs	.+6      	; 0x167c <_ZN9MD_TCS2307readFSMEh+0x18>
    1676:	62 30       	cpi	r22, 0x02	; 2
    1678:	d9 f0       	breq	.+54     	; 0x16b0 <_ZN9MD_TCS2307readFSMEh+0x4c>
    167a:	4c c0       	rjmp	.+152    	; 0x1714 <_ZN9MD_TCS2307readFSMEh+0xb0>
  {
  case 0: // enable the hardware for reading
    DUMPS("\n0");
    currCol = 0;  // RGB_R but we don't care
    167c:	10 92 f5 03 	sts	0x03F5, r1	; 0x8003f5 <_ZZN9MD_TCS2307readFSMEhE7currCol>
    setEnable(true);
    1680:	61 e0       	ldi	r22, 0x01	; 1
    1682:	0e 94 8a 0a 	call	0x1514	; 0x1514 <_ZN9MD_TCS2309setEnableEb>
    s++;
    // fall through to the next state

  case 1: // select a filter and start a reading
    DUMPS("\n1");
    setFilter(seq[currCol]);
    1686:	e0 91 f5 03 	lds	r30, 0x03F5	; 0x8003f5 <_ZZN9MD_TCS2307readFSMEhE7currCol>
    168a:	f0 e0       	ldi	r31, 0x00	; 0
    168c:	ec 57       	subi	r30, 0x7C	; 124
    168e:	fd 4f       	sbci	r31, 0xFD	; 253
    1690:	60 81       	ld	r22, Z
    1692:	c8 01       	movw	r24, r16
    1694:	0e 94 3e 0a 	call	0x147c	; 0x147c <_ZN9MD_TCS2309setFilterEh>
    FreqCount.begin(1000/_readDiv);
    1698:	f8 01       	movw	r30, r16
    169a:	65 81       	ldd	r22, Z+5	; 0x05
    169c:	70 e0       	ldi	r23, 0x00	; 0
    169e:	88 ee       	ldi	r24, 0xE8	; 232
    16a0:	93 e0       	ldi	r25, 0x03	; 3
    16a2:	0e 94 2d 21 	call	0x425a	; 0x425a <__divmodhi4>
    16a6:	cb 01       	movw	r24, r22
    16a8:	0e 94 71 1b 	call	0x36e2	; 0x36e2 <_ZN14FreqCountClass5beginEj>
    s++;
    16ac:	c2 e0       	ldi	r28, 0x02	; 2
    break;
    16ae:	32 c0       	rjmp	.+100    	; 0x1714 <_ZN9MD_TCS2307readFSMEh+0xb0>

  case 2: // see if a value is available
    DUMPS("2");
    if (FreqCount.available())
    16b0:	0e 94 e9 1b 	call	0x37d2	; 0x37d2 <_ZN14FreqCountClass9availableEv>
    16b4:	88 23       	and	r24, r24
    16b6:	71 f1       	breq	.+92     	; 0x1714 <_ZN9MD_TCS2307readFSMEh+0xb0>
    {
      DUMP(" VALUE ", FreqCount.read());
      // read the value and save it 
      _Fo.value[seq[currCol++]] = FreqCount.read() * _readDiv;
    16b8:	e0 91 f5 03 	lds	r30, 0x03F5	; 0x8003f5 <_ZZN9MD_TCS2307readFSMEhE7currCol>
    16bc:	81 e0       	ldi	r24, 0x01	; 1
    16be:	8e 0f       	add	r24, r30
    16c0:	80 93 f5 03 	sts	0x03F5, r24	; 0x8003f5 <_ZZN9MD_TCS2307readFSMEhE7currCol>
    16c4:	f0 e0       	ldi	r31, 0x00	; 0
    16c6:	ec 57       	subi	r30, 0x7C	; 124
    16c8:	fd 4f       	sbci	r31, 0xFD	; 253
    16ca:	c0 81       	ld	r28, Z
    16cc:	d0 e0       	ldi	r29, 0x00	; 0
    16ce:	0e 94 ec 1b 	call	0x37d8	; 0x37d8 <_ZN14FreqCountClass4readEv>
    16d2:	9b 01       	movw	r18, r22
    16d4:	ac 01       	movw	r20, r24
    16d6:	cc 0f       	add	r28, r28
    16d8:	dd 1f       	adc	r29, r29
    16da:	cc 0f       	add	r28, r28
    16dc:	dd 1f       	adc	r29, r29
    16de:	c0 0f       	add	r28, r16
    16e0:	d1 1f       	adc	r29, r17
    16e2:	f8 01       	movw	r30, r16
    16e4:	a5 81       	ldd	r26, Z+5	; 0x05
    16e6:	b0 e0       	ldi	r27, 0x00	; 0
    16e8:	0e 94 88 21 	call	0x4310	; 0x4310 <__muluhisi3>
    16ec:	6f 8f       	std	Y+31, r22	; 0x1f
    16ee:	78 a3       	std	Y+32, r23	; 0x20
    16f0:	89 a3       	std	Y+33, r24	; 0x21
    16f2:	9a a3       	std	Y+34, r25	; 0x22

      if (currCol < RGB_SIZE)
    16f4:	80 91 f5 03 	lds	r24, 0x03F5	; 0x8003f5 <_ZZN9MD_TCS2307readFSMEhE7currCol>
    16f8:	83 30       	cpi	r24, 0x03	; 3
    16fa:	58 f0       	brcs	.+22     	; 0x1712 <_ZN9MD_TCS2307readFSMEh+0xae>
        s--;
      }
      else
      {
        // end this reading session
        FreqCount.end();
    16fc:	0e 94 fa 1b 	call	0x37f4	; 0x37f4 <_ZN14FreqCountClass3endEv>
        setEnable(false);
    1700:	60 e0       	ldi	r22, 0x00	; 0
    1702:	c8 01       	movw	r24, r16
    1704:	0e 94 8a 0a 	call	0x1514	; 0x1514 <_ZN9MD_TCS2309setEnableEb>
        RGBTransformation();
    1708:	c8 01       	movw	r24, r16
    170a:	0e 94 d6 0a 	call	0x15ac	; 0x15ac <_ZN9MD_TCS23017RGBTransformationEv>
        s = 0;
    170e:	c0 e0       	ldi	r28, 0x00	; 0
    1710:	01 c0       	rjmp	.+2      	; 0x1714 <_ZN9MD_TCS2307readFSMEh+0xb0>
      _Fo.value[seq[currCol++]] = FreqCount.read() * _readDiv;

      if (currCol < RGB_SIZE)
      {
        // loop around again on next call to available()
        s--;
    1712:	c1 e0       	ldi	r28, 0x01	; 1
    }
    break;
  }

  return(s);
}
    1714:	8c 2f       	mov	r24, r28
    1716:	df 91       	pop	r29
    1718:	cf 91       	pop	r28
    171a:	1f 91       	pop	r17
    171c:	0f 91       	pop	r16
    171e:	08 95       	ret

00001720 <_ZN9MD_TCS2304readEv>:
  return(FreqCount.read() * _readDiv);
}

void MD_TCS230::read(void)
// initiate the finite state machine for reading a value
{
    1720:	cf 93       	push	r28
    1722:	df 93       	push	r29
    1724:	ec 01       	movw	r28, r24
  _readState = readFSM(0);
    1726:	60 e0       	ldi	r22, 0x00	; 0
    1728:	0e 94 32 0b 	call	0x1664	; 0x1664 <_ZN9MD_TCS2307readFSMEh>
    172c:	8e a7       	std	Y+46, r24	; 0x2e
}
    172e:	df 91       	pop	r29
    1730:	cf 91       	pop	r28
    1732:	08 95       	ret

00001734 <_ZN9MD_TCS2309availableEv>:

bool MD_TCS230::available(void)
// check if a value is ready. Called repeatedly until it is!
{
    1734:	cf 93       	push	r28
    1736:	df 93       	push	r29
    1738:	ec 01       	movw	r28, r24
  _readState = readFSM(_readState);
    173a:	6e a5       	ldd	r22, Y+46	; 0x2e
    173c:	0e 94 32 0b 	call	0x1664	; 0x1664 <_ZN9MD_TCS2307readFSMEh>
    1740:	98 2f       	mov	r25, r24
    1742:	8e a7       	std	Y+46, r24	; 0x2e

  return(_readState == 0);
    1744:	81 e0       	ldi	r24, 0x01	; 1
    1746:	91 11       	cpse	r25, r1
    1748:	80 e0       	ldi	r24, 0x00	; 0
}
    174a:	df 91       	pop	r29
    174c:	cf 91       	pop	r28
    174e:	08 95       	ret

00001750 <__subsf3>:
    1750:	50 58       	subi	r21, 0x80	; 128

00001752 <__addsf3>:
    1752:	bb 27       	eor	r27, r27
    1754:	aa 27       	eor	r26, r26
    1756:	0e 94 c0 0b 	call	0x1780	; 0x1780 <__addsf3x>
    175a:	0c 94 3a 0d 	jmp	0x1a74	; 0x1a74 <__fp_round>
    175e:	0e 94 2c 0d 	call	0x1a58	; 0x1a58 <__fp_pscA>
    1762:	38 f0       	brcs	.+14     	; 0x1772 <__addsf3+0x20>
    1764:	0e 94 33 0d 	call	0x1a66	; 0x1a66 <__fp_pscB>
    1768:	20 f0       	brcs	.+8      	; 0x1772 <__addsf3+0x20>
    176a:	39 f4       	brne	.+14     	; 0x177a <__addsf3+0x28>
    176c:	9f 3f       	cpi	r25, 0xFF	; 255
    176e:	19 f4       	brne	.+6      	; 0x1776 <__addsf3+0x24>
    1770:	26 f4       	brtc	.+8      	; 0x177a <__addsf3+0x28>
    1772:	0c 94 29 0d 	jmp	0x1a52	; 0x1a52 <__fp_nan>
    1776:	0e f4       	brtc	.+2      	; 0x177a <__addsf3+0x28>
    1778:	e0 95       	com	r30
    177a:	e7 fb       	bst	r30, 7
    177c:	0c 94 23 0d 	jmp	0x1a46	; 0x1a46 <__fp_inf>

00001780 <__addsf3x>:
    1780:	e9 2f       	mov	r30, r25
    1782:	0e 94 4b 0d 	call	0x1a96	; 0x1a96 <__fp_split3>
    1786:	58 f3       	brcs	.-42     	; 0x175e <__addsf3+0xc>
    1788:	ba 17       	cp	r27, r26
    178a:	62 07       	cpc	r22, r18
    178c:	73 07       	cpc	r23, r19
    178e:	84 07       	cpc	r24, r20
    1790:	95 07       	cpc	r25, r21
    1792:	20 f0       	brcs	.+8      	; 0x179c <__addsf3x+0x1c>
    1794:	79 f4       	brne	.+30     	; 0x17b4 <__addsf3x+0x34>
    1796:	a6 f5       	brtc	.+104    	; 0x1800 <__addsf3x+0x80>
    1798:	0c 94 6d 0d 	jmp	0x1ada	; 0x1ada <__fp_zero>
    179c:	0e f4       	brtc	.+2      	; 0x17a0 <__addsf3x+0x20>
    179e:	e0 95       	com	r30
    17a0:	0b 2e       	mov	r0, r27
    17a2:	ba 2f       	mov	r27, r26
    17a4:	a0 2d       	mov	r26, r0
    17a6:	0b 01       	movw	r0, r22
    17a8:	b9 01       	movw	r22, r18
    17aa:	90 01       	movw	r18, r0
    17ac:	0c 01       	movw	r0, r24
    17ae:	ca 01       	movw	r24, r20
    17b0:	a0 01       	movw	r20, r0
    17b2:	11 24       	eor	r1, r1
    17b4:	ff 27       	eor	r31, r31
    17b6:	59 1b       	sub	r21, r25
    17b8:	99 f0       	breq	.+38     	; 0x17e0 <__addsf3x+0x60>
    17ba:	59 3f       	cpi	r21, 0xF9	; 249
    17bc:	50 f4       	brcc	.+20     	; 0x17d2 <__addsf3x+0x52>
    17be:	50 3e       	cpi	r21, 0xE0	; 224
    17c0:	68 f1       	brcs	.+90     	; 0x181c <__addsf3x+0x9c>
    17c2:	1a 16       	cp	r1, r26
    17c4:	f0 40       	sbci	r31, 0x00	; 0
    17c6:	a2 2f       	mov	r26, r18
    17c8:	23 2f       	mov	r18, r19
    17ca:	34 2f       	mov	r19, r20
    17cc:	44 27       	eor	r20, r20
    17ce:	58 5f       	subi	r21, 0xF8	; 248
    17d0:	f3 cf       	rjmp	.-26     	; 0x17b8 <__addsf3x+0x38>
    17d2:	46 95       	lsr	r20
    17d4:	37 95       	ror	r19
    17d6:	27 95       	ror	r18
    17d8:	a7 95       	ror	r26
    17da:	f0 40       	sbci	r31, 0x00	; 0
    17dc:	53 95       	inc	r21
    17de:	c9 f7       	brne	.-14     	; 0x17d2 <__addsf3x+0x52>
    17e0:	7e f4       	brtc	.+30     	; 0x1800 <__addsf3x+0x80>
    17e2:	1f 16       	cp	r1, r31
    17e4:	ba 0b       	sbc	r27, r26
    17e6:	62 0b       	sbc	r22, r18
    17e8:	73 0b       	sbc	r23, r19
    17ea:	84 0b       	sbc	r24, r20
    17ec:	ba f0       	brmi	.+46     	; 0x181c <__addsf3x+0x9c>
    17ee:	91 50       	subi	r25, 0x01	; 1
    17f0:	a1 f0       	breq	.+40     	; 0x181a <__addsf3x+0x9a>
    17f2:	ff 0f       	add	r31, r31
    17f4:	bb 1f       	adc	r27, r27
    17f6:	66 1f       	adc	r22, r22
    17f8:	77 1f       	adc	r23, r23
    17fa:	88 1f       	adc	r24, r24
    17fc:	c2 f7       	brpl	.-16     	; 0x17ee <__addsf3x+0x6e>
    17fe:	0e c0       	rjmp	.+28     	; 0x181c <__addsf3x+0x9c>
    1800:	ba 0f       	add	r27, r26
    1802:	62 1f       	adc	r22, r18
    1804:	73 1f       	adc	r23, r19
    1806:	84 1f       	adc	r24, r20
    1808:	48 f4       	brcc	.+18     	; 0x181c <__addsf3x+0x9c>
    180a:	87 95       	ror	r24
    180c:	77 95       	ror	r23
    180e:	67 95       	ror	r22
    1810:	b7 95       	ror	r27
    1812:	f7 95       	ror	r31
    1814:	9e 3f       	cpi	r25, 0xFE	; 254
    1816:	08 f0       	brcs	.+2      	; 0x181a <__addsf3x+0x9a>
    1818:	b0 cf       	rjmp	.-160    	; 0x177a <__addsf3+0x28>
    181a:	93 95       	inc	r25
    181c:	88 0f       	add	r24, r24
    181e:	08 f0       	brcs	.+2      	; 0x1822 <__addsf3x+0xa2>
    1820:	99 27       	eor	r25, r25
    1822:	ee 0f       	add	r30, r30
    1824:	97 95       	ror	r25
    1826:	87 95       	ror	r24
    1828:	08 95       	ret

0000182a <__cmpsf2>:
    182a:	0e 94 ff 0c 	call	0x19fe	; 0x19fe <__fp_cmp>
    182e:	08 f4       	brcc	.+2      	; 0x1832 <__cmpsf2+0x8>
    1830:	81 e0       	ldi	r24, 0x01	; 1
    1832:	08 95       	ret

00001834 <__divsf3>:
    1834:	0e 94 2e 0c 	call	0x185c	; 0x185c <__divsf3x>
    1838:	0c 94 3a 0d 	jmp	0x1a74	; 0x1a74 <__fp_round>
    183c:	0e 94 33 0d 	call	0x1a66	; 0x1a66 <__fp_pscB>
    1840:	58 f0       	brcs	.+22     	; 0x1858 <__divsf3+0x24>
    1842:	0e 94 2c 0d 	call	0x1a58	; 0x1a58 <__fp_pscA>
    1846:	40 f0       	brcs	.+16     	; 0x1858 <__divsf3+0x24>
    1848:	29 f4       	brne	.+10     	; 0x1854 <__divsf3+0x20>
    184a:	5f 3f       	cpi	r21, 0xFF	; 255
    184c:	29 f0       	breq	.+10     	; 0x1858 <__divsf3+0x24>
    184e:	0c 94 23 0d 	jmp	0x1a46	; 0x1a46 <__fp_inf>
    1852:	51 11       	cpse	r21, r1
    1854:	0c 94 6e 0d 	jmp	0x1adc	; 0x1adc <__fp_szero>
    1858:	0c 94 29 0d 	jmp	0x1a52	; 0x1a52 <__fp_nan>

0000185c <__divsf3x>:
    185c:	0e 94 4b 0d 	call	0x1a96	; 0x1a96 <__fp_split3>
    1860:	68 f3       	brcs	.-38     	; 0x183c <__divsf3+0x8>

00001862 <__divsf3_pse>:
    1862:	99 23       	and	r25, r25
    1864:	b1 f3       	breq	.-20     	; 0x1852 <__divsf3+0x1e>
    1866:	55 23       	and	r21, r21
    1868:	91 f3       	breq	.-28     	; 0x184e <__divsf3+0x1a>
    186a:	95 1b       	sub	r25, r21
    186c:	55 0b       	sbc	r21, r21
    186e:	bb 27       	eor	r27, r27
    1870:	aa 27       	eor	r26, r26
    1872:	62 17       	cp	r22, r18
    1874:	73 07       	cpc	r23, r19
    1876:	84 07       	cpc	r24, r20
    1878:	38 f0       	brcs	.+14     	; 0x1888 <__divsf3_pse+0x26>
    187a:	9f 5f       	subi	r25, 0xFF	; 255
    187c:	5f 4f       	sbci	r21, 0xFF	; 255
    187e:	22 0f       	add	r18, r18
    1880:	33 1f       	adc	r19, r19
    1882:	44 1f       	adc	r20, r20
    1884:	aa 1f       	adc	r26, r26
    1886:	a9 f3       	breq	.-22     	; 0x1872 <__divsf3_pse+0x10>
    1888:	35 d0       	rcall	.+106    	; 0x18f4 <__divsf3_pse+0x92>
    188a:	0e 2e       	mov	r0, r30
    188c:	3a f0       	brmi	.+14     	; 0x189c <__divsf3_pse+0x3a>
    188e:	e0 e8       	ldi	r30, 0x80	; 128
    1890:	32 d0       	rcall	.+100    	; 0x18f6 <__divsf3_pse+0x94>
    1892:	91 50       	subi	r25, 0x01	; 1
    1894:	50 40       	sbci	r21, 0x00	; 0
    1896:	e6 95       	lsr	r30
    1898:	00 1c       	adc	r0, r0
    189a:	ca f7       	brpl	.-14     	; 0x188e <__divsf3_pse+0x2c>
    189c:	2b d0       	rcall	.+86     	; 0x18f4 <__divsf3_pse+0x92>
    189e:	fe 2f       	mov	r31, r30
    18a0:	29 d0       	rcall	.+82     	; 0x18f4 <__divsf3_pse+0x92>
    18a2:	66 0f       	add	r22, r22
    18a4:	77 1f       	adc	r23, r23
    18a6:	88 1f       	adc	r24, r24
    18a8:	bb 1f       	adc	r27, r27
    18aa:	26 17       	cp	r18, r22
    18ac:	37 07       	cpc	r19, r23
    18ae:	48 07       	cpc	r20, r24
    18b0:	ab 07       	cpc	r26, r27
    18b2:	b0 e8       	ldi	r27, 0x80	; 128
    18b4:	09 f0       	breq	.+2      	; 0x18b8 <__divsf3_pse+0x56>
    18b6:	bb 0b       	sbc	r27, r27
    18b8:	80 2d       	mov	r24, r0
    18ba:	bf 01       	movw	r22, r30
    18bc:	ff 27       	eor	r31, r31
    18be:	93 58       	subi	r25, 0x83	; 131
    18c0:	5f 4f       	sbci	r21, 0xFF	; 255
    18c2:	3a f0       	brmi	.+14     	; 0x18d2 <__divsf3_pse+0x70>
    18c4:	9e 3f       	cpi	r25, 0xFE	; 254
    18c6:	51 05       	cpc	r21, r1
    18c8:	78 f0       	brcs	.+30     	; 0x18e8 <__divsf3_pse+0x86>
    18ca:	0c 94 23 0d 	jmp	0x1a46	; 0x1a46 <__fp_inf>
    18ce:	0c 94 6e 0d 	jmp	0x1adc	; 0x1adc <__fp_szero>
    18d2:	5f 3f       	cpi	r21, 0xFF	; 255
    18d4:	e4 f3       	brlt	.-8      	; 0x18ce <__divsf3_pse+0x6c>
    18d6:	98 3e       	cpi	r25, 0xE8	; 232
    18d8:	d4 f3       	brlt	.-12     	; 0x18ce <__divsf3_pse+0x6c>
    18da:	86 95       	lsr	r24
    18dc:	77 95       	ror	r23
    18de:	67 95       	ror	r22
    18e0:	b7 95       	ror	r27
    18e2:	f7 95       	ror	r31
    18e4:	9f 5f       	subi	r25, 0xFF	; 255
    18e6:	c9 f7       	brne	.-14     	; 0x18da <__divsf3_pse+0x78>
    18e8:	88 0f       	add	r24, r24
    18ea:	91 1d       	adc	r25, r1
    18ec:	96 95       	lsr	r25
    18ee:	87 95       	ror	r24
    18f0:	97 f9       	bld	r25, 7
    18f2:	08 95       	ret
    18f4:	e1 e0       	ldi	r30, 0x01	; 1
    18f6:	66 0f       	add	r22, r22
    18f8:	77 1f       	adc	r23, r23
    18fa:	88 1f       	adc	r24, r24
    18fc:	bb 1f       	adc	r27, r27
    18fe:	62 17       	cp	r22, r18
    1900:	73 07       	cpc	r23, r19
    1902:	84 07       	cpc	r24, r20
    1904:	ba 07       	cpc	r27, r26
    1906:	20 f0       	brcs	.+8      	; 0x1910 <__divsf3_pse+0xae>
    1908:	62 1b       	sub	r22, r18
    190a:	73 0b       	sbc	r23, r19
    190c:	84 0b       	sbc	r24, r20
    190e:	ba 0b       	sbc	r27, r26
    1910:	ee 1f       	adc	r30, r30
    1912:	88 f7       	brcc	.-30     	; 0x18f6 <__divsf3_pse+0x94>
    1914:	e0 95       	com	r30
    1916:	08 95       	ret

00001918 <__fixsfsi>:
    1918:	0e 94 93 0c 	call	0x1926	; 0x1926 <__fixunssfsi>
    191c:	68 94       	set
    191e:	b1 11       	cpse	r27, r1
    1920:	0c 94 6e 0d 	jmp	0x1adc	; 0x1adc <__fp_szero>
    1924:	08 95       	ret

00001926 <__fixunssfsi>:
    1926:	0e 94 53 0d 	call	0x1aa6	; 0x1aa6 <__fp_splitA>
    192a:	88 f0       	brcs	.+34     	; 0x194e <__fixunssfsi+0x28>
    192c:	9f 57       	subi	r25, 0x7F	; 127
    192e:	98 f0       	brcs	.+38     	; 0x1956 <__fixunssfsi+0x30>
    1930:	b9 2f       	mov	r27, r25
    1932:	99 27       	eor	r25, r25
    1934:	b7 51       	subi	r27, 0x17	; 23
    1936:	b0 f0       	brcs	.+44     	; 0x1964 <__fixunssfsi+0x3e>
    1938:	e1 f0       	breq	.+56     	; 0x1972 <__fixunssfsi+0x4c>
    193a:	66 0f       	add	r22, r22
    193c:	77 1f       	adc	r23, r23
    193e:	88 1f       	adc	r24, r24
    1940:	99 1f       	adc	r25, r25
    1942:	1a f0       	brmi	.+6      	; 0x194a <__fixunssfsi+0x24>
    1944:	ba 95       	dec	r27
    1946:	c9 f7       	brne	.-14     	; 0x193a <__fixunssfsi+0x14>
    1948:	14 c0       	rjmp	.+40     	; 0x1972 <__fixunssfsi+0x4c>
    194a:	b1 30       	cpi	r27, 0x01	; 1
    194c:	91 f0       	breq	.+36     	; 0x1972 <__fixunssfsi+0x4c>
    194e:	0e 94 6d 0d 	call	0x1ada	; 0x1ada <__fp_zero>
    1952:	b1 e0       	ldi	r27, 0x01	; 1
    1954:	08 95       	ret
    1956:	0c 94 6d 0d 	jmp	0x1ada	; 0x1ada <__fp_zero>
    195a:	67 2f       	mov	r22, r23
    195c:	78 2f       	mov	r23, r24
    195e:	88 27       	eor	r24, r24
    1960:	b8 5f       	subi	r27, 0xF8	; 248
    1962:	39 f0       	breq	.+14     	; 0x1972 <__fixunssfsi+0x4c>
    1964:	b9 3f       	cpi	r27, 0xF9	; 249
    1966:	cc f3       	brlt	.-14     	; 0x195a <__fixunssfsi+0x34>
    1968:	86 95       	lsr	r24
    196a:	77 95       	ror	r23
    196c:	67 95       	ror	r22
    196e:	b3 95       	inc	r27
    1970:	d9 f7       	brne	.-10     	; 0x1968 <__fixunssfsi+0x42>
    1972:	3e f4       	brtc	.+14     	; 0x1982 <__fixunssfsi+0x5c>
    1974:	90 95       	com	r25
    1976:	80 95       	com	r24
    1978:	70 95       	com	r23
    197a:	61 95       	neg	r22
    197c:	7f 4f       	sbci	r23, 0xFF	; 255
    197e:	8f 4f       	sbci	r24, 0xFF	; 255
    1980:	9f 4f       	sbci	r25, 0xFF	; 255
    1982:	08 95       	ret

00001984 <__floatunsisf>:
    1984:	e8 94       	clt
    1986:	09 c0       	rjmp	.+18     	; 0x199a <__floatsisf+0x12>

00001988 <__floatsisf>:
    1988:	97 fb       	bst	r25, 7
    198a:	3e f4       	brtc	.+14     	; 0x199a <__floatsisf+0x12>
    198c:	90 95       	com	r25
    198e:	80 95       	com	r24
    1990:	70 95       	com	r23
    1992:	61 95       	neg	r22
    1994:	7f 4f       	sbci	r23, 0xFF	; 255
    1996:	8f 4f       	sbci	r24, 0xFF	; 255
    1998:	9f 4f       	sbci	r25, 0xFF	; 255
    199a:	99 23       	and	r25, r25
    199c:	a9 f0       	breq	.+42     	; 0x19c8 <__floatsisf+0x40>
    199e:	f9 2f       	mov	r31, r25
    19a0:	96 e9       	ldi	r25, 0x96	; 150
    19a2:	bb 27       	eor	r27, r27
    19a4:	93 95       	inc	r25
    19a6:	f6 95       	lsr	r31
    19a8:	87 95       	ror	r24
    19aa:	77 95       	ror	r23
    19ac:	67 95       	ror	r22
    19ae:	b7 95       	ror	r27
    19b0:	f1 11       	cpse	r31, r1
    19b2:	f8 cf       	rjmp	.-16     	; 0x19a4 <__floatsisf+0x1c>
    19b4:	fa f4       	brpl	.+62     	; 0x19f4 <__floatsisf+0x6c>
    19b6:	bb 0f       	add	r27, r27
    19b8:	11 f4       	brne	.+4      	; 0x19be <__floatsisf+0x36>
    19ba:	60 ff       	sbrs	r22, 0
    19bc:	1b c0       	rjmp	.+54     	; 0x19f4 <__floatsisf+0x6c>
    19be:	6f 5f       	subi	r22, 0xFF	; 255
    19c0:	7f 4f       	sbci	r23, 0xFF	; 255
    19c2:	8f 4f       	sbci	r24, 0xFF	; 255
    19c4:	9f 4f       	sbci	r25, 0xFF	; 255
    19c6:	16 c0       	rjmp	.+44     	; 0x19f4 <__floatsisf+0x6c>
    19c8:	88 23       	and	r24, r24
    19ca:	11 f0       	breq	.+4      	; 0x19d0 <__floatsisf+0x48>
    19cc:	96 e9       	ldi	r25, 0x96	; 150
    19ce:	11 c0       	rjmp	.+34     	; 0x19f2 <__floatsisf+0x6a>
    19d0:	77 23       	and	r23, r23
    19d2:	21 f0       	breq	.+8      	; 0x19dc <__floatsisf+0x54>
    19d4:	9e e8       	ldi	r25, 0x8E	; 142
    19d6:	87 2f       	mov	r24, r23
    19d8:	76 2f       	mov	r23, r22
    19da:	05 c0       	rjmp	.+10     	; 0x19e6 <__floatsisf+0x5e>
    19dc:	66 23       	and	r22, r22
    19de:	71 f0       	breq	.+28     	; 0x19fc <__floatsisf+0x74>
    19e0:	96 e8       	ldi	r25, 0x86	; 134
    19e2:	86 2f       	mov	r24, r22
    19e4:	70 e0       	ldi	r23, 0x00	; 0
    19e6:	60 e0       	ldi	r22, 0x00	; 0
    19e8:	2a f0       	brmi	.+10     	; 0x19f4 <__floatsisf+0x6c>
    19ea:	9a 95       	dec	r25
    19ec:	66 0f       	add	r22, r22
    19ee:	77 1f       	adc	r23, r23
    19f0:	88 1f       	adc	r24, r24
    19f2:	da f7       	brpl	.-10     	; 0x19ea <__floatsisf+0x62>
    19f4:	88 0f       	add	r24, r24
    19f6:	96 95       	lsr	r25
    19f8:	87 95       	ror	r24
    19fa:	97 f9       	bld	r25, 7
    19fc:	08 95       	ret

000019fe <__fp_cmp>:
    19fe:	99 0f       	add	r25, r25
    1a00:	00 08       	sbc	r0, r0
    1a02:	55 0f       	add	r21, r21
    1a04:	aa 0b       	sbc	r26, r26
    1a06:	e0 e8       	ldi	r30, 0x80	; 128
    1a08:	fe ef       	ldi	r31, 0xFE	; 254
    1a0a:	16 16       	cp	r1, r22
    1a0c:	17 06       	cpc	r1, r23
    1a0e:	e8 07       	cpc	r30, r24
    1a10:	f9 07       	cpc	r31, r25
    1a12:	c0 f0       	brcs	.+48     	; 0x1a44 <__fp_cmp+0x46>
    1a14:	12 16       	cp	r1, r18
    1a16:	13 06       	cpc	r1, r19
    1a18:	e4 07       	cpc	r30, r20
    1a1a:	f5 07       	cpc	r31, r21
    1a1c:	98 f0       	brcs	.+38     	; 0x1a44 <__fp_cmp+0x46>
    1a1e:	62 1b       	sub	r22, r18
    1a20:	73 0b       	sbc	r23, r19
    1a22:	84 0b       	sbc	r24, r20
    1a24:	95 0b       	sbc	r25, r21
    1a26:	39 f4       	brne	.+14     	; 0x1a36 <__fp_cmp+0x38>
    1a28:	0a 26       	eor	r0, r26
    1a2a:	61 f0       	breq	.+24     	; 0x1a44 <__fp_cmp+0x46>
    1a2c:	23 2b       	or	r18, r19
    1a2e:	24 2b       	or	r18, r20
    1a30:	25 2b       	or	r18, r21
    1a32:	21 f4       	brne	.+8      	; 0x1a3c <__fp_cmp+0x3e>
    1a34:	08 95       	ret
    1a36:	0a 26       	eor	r0, r26
    1a38:	09 f4       	brne	.+2      	; 0x1a3c <__fp_cmp+0x3e>
    1a3a:	a1 40       	sbci	r26, 0x01	; 1
    1a3c:	a6 95       	lsr	r26
    1a3e:	8f ef       	ldi	r24, 0xFF	; 255
    1a40:	81 1d       	adc	r24, r1
    1a42:	81 1d       	adc	r24, r1
    1a44:	08 95       	ret

00001a46 <__fp_inf>:
    1a46:	97 f9       	bld	r25, 7
    1a48:	9f 67       	ori	r25, 0x7F	; 127
    1a4a:	80 e8       	ldi	r24, 0x80	; 128
    1a4c:	70 e0       	ldi	r23, 0x00	; 0
    1a4e:	60 e0       	ldi	r22, 0x00	; 0
    1a50:	08 95       	ret

00001a52 <__fp_nan>:
    1a52:	9f ef       	ldi	r25, 0xFF	; 255
    1a54:	80 ec       	ldi	r24, 0xC0	; 192
    1a56:	08 95       	ret

00001a58 <__fp_pscA>:
    1a58:	00 24       	eor	r0, r0
    1a5a:	0a 94       	dec	r0
    1a5c:	16 16       	cp	r1, r22
    1a5e:	17 06       	cpc	r1, r23
    1a60:	18 06       	cpc	r1, r24
    1a62:	09 06       	cpc	r0, r25
    1a64:	08 95       	ret

00001a66 <__fp_pscB>:
    1a66:	00 24       	eor	r0, r0
    1a68:	0a 94       	dec	r0
    1a6a:	12 16       	cp	r1, r18
    1a6c:	13 06       	cpc	r1, r19
    1a6e:	14 06       	cpc	r1, r20
    1a70:	05 06       	cpc	r0, r21
    1a72:	08 95       	ret

00001a74 <__fp_round>:
    1a74:	09 2e       	mov	r0, r25
    1a76:	03 94       	inc	r0
    1a78:	00 0c       	add	r0, r0
    1a7a:	11 f4       	brne	.+4      	; 0x1a80 <__fp_round+0xc>
    1a7c:	88 23       	and	r24, r24
    1a7e:	52 f0       	brmi	.+20     	; 0x1a94 <__fp_round+0x20>
    1a80:	bb 0f       	add	r27, r27
    1a82:	40 f4       	brcc	.+16     	; 0x1a94 <__fp_round+0x20>
    1a84:	bf 2b       	or	r27, r31
    1a86:	11 f4       	brne	.+4      	; 0x1a8c <__fp_round+0x18>
    1a88:	60 ff       	sbrs	r22, 0
    1a8a:	04 c0       	rjmp	.+8      	; 0x1a94 <__fp_round+0x20>
    1a8c:	6f 5f       	subi	r22, 0xFF	; 255
    1a8e:	7f 4f       	sbci	r23, 0xFF	; 255
    1a90:	8f 4f       	sbci	r24, 0xFF	; 255
    1a92:	9f 4f       	sbci	r25, 0xFF	; 255
    1a94:	08 95       	ret

00001a96 <__fp_split3>:
    1a96:	57 fd       	sbrc	r21, 7
    1a98:	90 58       	subi	r25, 0x80	; 128
    1a9a:	44 0f       	add	r20, r20
    1a9c:	55 1f       	adc	r21, r21
    1a9e:	59 f0       	breq	.+22     	; 0x1ab6 <__fp_splitA+0x10>
    1aa0:	5f 3f       	cpi	r21, 0xFF	; 255
    1aa2:	71 f0       	breq	.+28     	; 0x1ac0 <__fp_splitA+0x1a>
    1aa4:	47 95       	ror	r20

00001aa6 <__fp_splitA>:
    1aa6:	88 0f       	add	r24, r24
    1aa8:	97 fb       	bst	r25, 7
    1aaa:	99 1f       	adc	r25, r25
    1aac:	61 f0       	breq	.+24     	; 0x1ac6 <__fp_splitA+0x20>
    1aae:	9f 3f       	cpi	r25, 0xFF	; 255
    1ab0:	79 f0       	breq	.+30     	; 0x1ad0 <__fp_splitA+0x2a>
    1ab2:	87 95       	ror	r24
    1ab4:	08 95       	ret
    1ab6:	12 16       	cp	r1, r18
    1ab8:	13 06       	cpc	r1, r19
    1aba:	14 06       	cpc	r1, r20
    1abc:	55 1f       	adc	r21, r21
    1abe:	f2 cf       	rjmp	.-28     	; 0x1aa4 <__fp_split3+0xe>
    1ac0:	46 95       	lsr	r20
    1ac2:	f1 df       	rcall	.-30     	; 0x1aa6 <__fp_splitA>
    1ac4:	08 c0       	rjmp	.+16     	; 0x1ad6 <__fp_splitA+0x30>
    1ac6:	16 16       	cp	r1, r22
    1ac8:	17 06       	cpc	r1, r23
    1aca:	18 06       	cpc	r1, r24
    1acc:	99 1f       	adc	r25, r25
    1ace:	f1 cf       	rjmp	.-30     	; 0x1ab2 <__fp_splitA+0xc>
    1ad0:	86 95       	lsr	r24
    1ad2:	71 05       	cpc	r23, r1
    1ad4:	61 05       	cpc	r22, r1
    1ad6:	08 94       	sec
    1ad8:	08 95       	ret

00001ada <__fp_zero>:
    1ada:	e8 94       	clt

00001adc <__fp_szero>:
    1adc:	bb 27       	eor	r27, r27
    1ade:	66 27       	eor	r22, r22
    1ae0:	77 27       	eor	r23, r23
    1ae2:	cb 01       	movw	r24, r22
    1ae4:	97 f9       	bld	r25, 7
    1ae6:	08 95       	ret

00001ae8 <__gesf2>:
    1ae8:	0e 94 ff 0c 	call	0x19fe	; 0x19fe <__fp_cmp>
    1aec:	08 f4       	brcc	.+2      	; 0x1af0 <__gesf2+0x8>
    1aee:	8f ef       	ldi	r24, 0xFF	; 255
    1af0:	08 95       	ret

00001af2 <__mulsf3>:
    1af2:	0e 94 8c 0d 	call	0x1b18	; 0x1b18 <__mulsf3x>
    1af6:	0c 94 3a 0d 	jmp	0x1a74	; 0x1a74 <__fp_round>
    1afa:	0e 94 2c 0d 	call	0x1a58	; 0x1a58 <__fp_pscA>
    1afe:	38 f0       	brcs	.+14     	; 0x1b0e <__mulsf3+0x1c>
    1b00:	0e 94 33 0d 	call	0x1a66	; 0x1a66 <__fp_pscB>
    1b04:	20 f0       	brcs	.+8      	; 0x1b0e <__mulsf3+0x1c>
    1b06:	95 23       	and	r25, r21
    1b08:	11 f0       	breq	.+4      	; 0x1b0e <__mulsf3+0x1c>
    1b0a:	0c 94 23 0d 	jmp	0x1a46	; 0x1a46 <__fp_inf>
    1b0e:	0c 94 29 0d 	jmp	0x1a52	; 0x1a52 <__fp_nan>
    1b12:	11 24       	eor	r1, r1
    1b14:	0c 94 6e 0d 	jmp	0x1adc	; 0x1adc <__fp_szero>

00001b18 <__mulsf3x>:
    1b18:	0e 94 4b 0d 	call	0x1a96	; 0x1a96 <__fp_split3>
    1b1c:	70 f3       	brcs	.-36     	; 0x1afa <__mulsf3+0x8>

00001b1e <__mulsf3_pse>:
    1b1e:	95 9f       	mul	r25, r21
    1b20:	c1 f3       	breq	.-16     	; 0x1b12 <__mulsf3+0x20>
    1b22:	95 0f       	add	r25, r21
    1b24:	50 e0       	ldi	r21, 0x00	; 0
    1b26:	55 1f       	adc	r21, r21
    1b28:	62 9f       	mul	r22, r18
    1b2a:	f0 01       	movw	r30, r0
    1b2c:	72 9f       	mul	r23, r18
    1b2e:	bb 27       	eor	r27, r27
    1b30:	f0 0d       	add	r31, r0
    1b32:	b1 1d       	adc	r27, r1
    1b34:	63 9f       	mul	r22, r19
    1b36:	aa 27       	eor	r26, r26
    1b38:	f0 0d       	add	r31, r0
    1b3a:	b1 1d       	adc	r27, r1
    1b3c:	aa 1f       	adc	r26, r26
    1b3e:	64 9f       	mul	r22, r20
    1b40:	66 27       	eor	r22, r22
    1b42:	b0 0d       	add	r27, r0
    1b44:	a1 1d       	adc	r26, r1
    1b46:	66 1f       	adc	r22, r22
    1b48:	82 9f       	mul	r24, r18
    1b4a:	22 27       	eor	r18, r18
    1b4c:	b0 0d       	add	r27, r0
    1b4e:	a1 1d       	adc	r26, r1
    1b50:	62 1f       	adc	r22, r18
    1b52:	73 9f       	mul	r23, r19
    1b54:	b0 0d       	add	r27, r0
    1b56:	a1 1d       	adc	r26, r1
    1b58:	62 1f       	adc	r22, r18
    1b5a:	83 9f       	mul	r24, r19
    1b5c:	a0 0d       	add	r26, r0
    1b5e:	61 1d       	adc	r22, r1
    1b60:	22 1f       	adc	r18, r18
    1b62:	74 9f       	mul	r23, r20
    1b64:	33 27       	eor	r19, r19
    1b66:	a0 0d       	add	r26, r0
    1b68:	61 1d       	adc	r22, r1
    1b6a:	23 1f       	adc	r18, r19
    1b6c:	84 9f       	mul	r24, r20
    1b6e:	60 0d       	add	r22, r0
    1b70:	21 1d       	adc	r18, r1
    1b72:	82 2f       	mov	r24, r18
    1b74:	76 2f       	mov	r23, r22
    1b76:	6a 2f       	mov	r22, r26
    1b78:	11 24       	eor	r1, r1
    1b7a:	9f 57       	subi	r25, 0x7F	; 127
    1b7c:	50 40       	sbci	r21, 0x00	; 0
    1b7e:	9a f0       	brmi	.+38     	; 0x1ba6 <__mulsf3_pse+0x88>
    1b80:	f1 f0       	breq	.+60     	; 0x1bbe <__mulsf3_pse+0xa0>
    1b82:	88 23       	and	r24, r24
    1b84:	4a f0       	brmi	.+18     	; 0x1b98 <__mulsf3_pse+0x7a>
    1b86:	ee 0f       	add	r30, r30
    1b88:	ff 1f       	adc	r31, r31
    1b8a:	bb 1f       	adc	r27, r27
    1b8c:	66 1f       	adc	r22, r22
    1b8e:	77 1f       	adc	r23, r23
    1b90:	88 1f       	adc	r24, r24
    1b92:	91 50       	subi	r25, 0x01	; 1
    1b94:	50 40       	sbci	r21, 0x00	; 0
    1b96:	a9 f7       	brne	.-22     	; 0x1b82 <__mulsf3_pse+0x64>
    1b98:	9e 3f       	cpi	r25, 0xFE	; 254
    1b9a:	51 05       	cpc	r21, r1
    1b9c:	80 f0       	brcs	.+32     	; 0x1bbe <__mulsf3_pse+0xa0>
    1b9e:	0c 94 23 0d 	jmp	0x1a46	; 0x1a46 <__fp_inf>
    1ba2:	0c 94 6e 0d 	jmp	0x1adc	; 0x1adc <__fp_szero>
    1ba6:	5f 3f       	cpi	r21, 0xFF	; 255
    1ba8:	e4 f3       	brlt	.-8      	; 0x1ba2 <__mulsf3_pse+0x84>
    1baa:	98 3e       	cpi	r25, 0xE8	; 232
    1bac:	d4 f3       	brlt	.-12     	; 0x1ba2 <__mulsf3_pse+0x84>
    1bae:	86 95       	lsr	r24
    1bb0:	77 95       	ror	r23
    1bb2:	67 95       	ror	r22
    1bb4:	b7 95       	ror	r27
    1bb6:	f7 95       	ror	r31
    1bb8:	e7 95       	ror	r30
    1bba:	9f 5f       	subi	r25, 0xFF	; 255
    1bbc:	c1 f7       	brne	.-16     	; 0x1bae <__mulsf3_pse+0x90>
    1bbe:	fe 2b       	or	r31, r30
    1bc0:	88 0f       	add	r24, r24
    1bc2:	91 1d       	adc	r25, r1
    1bc4:	96 95       	lsr	r25
    1bc6:	87 95       	ror	r24
    1bc8:	97 f9       	bld	r25, 7
    1bca:	08 95       	ret

00001bcc <_ZN14HardwareSerial9availableEv>:
  // clear any received data
  _rx_buffer_head = _rx_buffer_tail;
}

int HardwareSerial::available(void)
{
    1bcc:	fc 01       	movw	r30, r24
  return ((unsigned int)(SERIAL_RX_BUFFER_SIZE + _rx_buffer_head - _rx_buffer_tail)) % SERIAL_RX_BUFFER_SIZE;
    1bce:	91 8d       	ldd	r25, Z+25	; 0x19
    1bd0:	22 8d       	ldd	r18, Z+26	; 0x1a
    1bd2:	89 2f       	mov	r24, r25
    1bd4:	90 e0       	ldi	r25, 0x00	; 0
    1bd6:	80 5c       	subi	r24, 0xC0	; 192
    1bd8:	9f 4f       	sbci	r25, 0xFF	; 255
    1bda:	82 1b       	sub	r24, r18
    1bdc:	91 09       	sbc	r25, r1
}
    1bde:	8f 73       	andi	r24, 0x3F	; 63
    1be0:	99 27       	eor	r25, r25
    1be2:	08 95       	ret

00001be4 <_ZN14HardwareSerial4peekEv>:

int HardwareSerial::peek(void)
{
    1be4:	fc 01       	movw	r30, r24
  if (_rx_buffer_head == _rx_buffer_tail) {
    1be6:	91 8d       	ldd	r25, Z+25	; 0x19
    1be8:	82 8d       	ldd	r24, Z+26	; 0x1a
    1bea:	98 17       	cp	r25, r24
    1bec:	31 f0       	breq	.+12     	; 0x1bfa <_ZN14HardwareSerial4peekEv+0x16>
    return -1;
  } else {
    return _rx_buffer[_rx_buffer_tail];
    1bee:	82 8d       	ldd	r24, Z+26	; 0x1a
    1bf0:	e8 0f       	add	r30, r24
    1bf2:	f1 1d       	adc	r31, r1
    1bf4:	85 8d       	ldd	r24, Z+29	; 0x1d
    1bf6:	90 e0       	ldi	r25, 0x00	; 0
    1bf8:	08 95       	ret
}

int HardwareSerial::peek(void)
{
  if (_rx_buffer_head == _rx_buffer_tail) {
    return -1;
    1bfa:	8f ef       	ldi	r24, 0xFF	; 255
    1bfc:	9f ef       	ldi	r25, 0xFF	; 255
  } else {
    return _rx_buffer[_rx_buffer_tail];
  }
}
    1bfe:	08 95       	ret

00001c00 <_ZN14HardwareSerial4readEv>:

int HardwareSerial::read(void)
{
    1c00:	fc 01       	movw	r30, r24
  // if the head isn't ahead of the tail, we don't have any characters
  if (_rx_buffer_head == _rx_buffer_tail) {
    1c02:	91 8d       	ldd	r25, Z+25	; 0x19
    1c04:	82 8d       	ldd	r24, Z+26	; 0x1a
    1c06:	98 17       	cp	r25, r24
    1c08:	61 f0       	breq	.+24     	; 0x1c22 <_ZN14HardwareSerial4readEv+0x22>
    return -1;
  } else {
    unsigned char c = _rx_buffer[_rx_buffer_tail];
    1c0a:	82 8d       	ldd	r24, Z+26	; 0x1a
    1c0c:	df 01       	movw	r26, r30
    1c0e:	a8 0f       	add	r26, r24
    1c10:	b1 1d       	adc	r27, r1
    1c12:	5d 96       	adiw	r26, 0x1d	; 29
    1c14:	8c 91       	ld	r24, X
    _rx_buffer_tail = (rx_buffer_index_t)(_rx_buffer_tail + 1) % SERIAL_RX_BUFFER_SIZE;
    1c16:	92 8d       	ldd	r25, Z+26	; 0x1a
    1c18:	9f 5f       	subi	r25, 0xFF	; 255
    1c1a:	9f 73       	andi	r25, 0x3F	; 63
    1c1c:	92 8f       	std	Z+26, r25	; 0x1a
    return c;
    1c1e:	90 e0       	ldi	r25, 0x00	; 0
    1c20:	08 95       	ret

int HardwareSerial::read(void)
{
  // if the head isn't ahead of the tail, we don't have any characters
  if (_rx_buffer_head == _rx_buffer_tail) {
    return -1;
    1c22:	8f ef       	ldi	r24, 0xFF	; 255
    1c24:	9f ef       	ldi	r25, 0xFF	; 255
  } else {
    unsigned char c = _rx_buffer[_rx_buffer_tail];
    _rx_buffer_tail = (rx_buffer_index_t)(_rx_buffer_tail + 1) % SERIAL_RX_BUFFER_SIZE;
    return c;
  }
}
    1c26:	08 95       	ret

00001c28 <_ZN14HardwareSerial17availableForWriteEv>:
{
  tx_buffer_index_t head;
  tx_buffer_index_t tail;

  TX_BUFFER_ATOMIC {
    head = _tx_buffer_head;
    1c28:	fc 01       	movw	r30, r24
    1c2a:	53 8d       	ldd	r21, Z+27	; 0x1b
    tail = _tx_buffer_tail;
    1c2c:	44 8d       	ldd	r20, Z+28	; 0x1c
    1c2e:	25 2f       	mov	r18, r21
    1c30:	30 e0       	ldi	r19, 0x00	; 0
    1c32:	84 2f       	mov	r24, r20
    1c34:	90 e0       	ldi	r25, 0x00	; 0
  }
  if (head >= tail) return SERIAL_TX_BUFFER_SIZE - 1 - head + tail;
    1c36:	82 1b       	sub	r24, r18
    1c38:	93 0b       	sbc	r25, r19
    1c3a:	54 17       	cp	r21, r20
    1c3c:	10 f0       	brcs	.+4      	; 0x1c42 <_ZN14HardwareSerial17availableForWriteEv+0x1a>
    1c3e:	cf 96       	adiw	r24, 0x3f	; 63
    1c40:	08 95       	ret
  return tail - head - 1;
    1c42:	01 97       	sbiw	r24, 0x01	; 1
}
    1c44:	08 95       	ret

00001c46 <_Z14serialEventRunv>:
#endif

void serialEventRun(void)
{
#if defined(HAVE_HWSERIAL0)
  if (Serial0_available && serialEvent && Serial0_available()) serialEvent();
    1c46:	8f e7       	ldi	r24, 0x7F	; 127
    1c48:	9f e0       	ldi	r25, 0x0F	; 15
    1c4a:	89 2b       	or	r24, r25
    1c4c:	49 f0       	breq	.+18     	; 0x1c60 <_Z14serialEventRunv+0x1a>
    1c4e:	80 e0       	ldi	r24, 0x00	; 0
    1c50:	90 e0       	ldi	r25, 0x00	; 0
    1c52:	89 2b       	or	r24, r25
    1c54:	29 f0       	breq	.+10     	; 0x1c60 <_Z14serialEventRunv+0x1a>
    1c56:	0e 94 7f 0f 	call	0x1efe	; 0x1efe <_Z17Serial0_availablev>
    1c5a:	81 11       	cpse	r24, r1
    1c5c:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>
    1c60:	08 95       	ret

00001c62 <_ZN14HardwareSerial17_tx_udr_empty_irqEv>:
#endif

// Actual interrupt handlers //////////////////////////////////////////////////////////////

void HardwareSerial::_tx_udr_empty_irq(void)
{
    1c62:	fc 01       	movw	r30, r24
  // If interrupts are enabled, there must be more data in the output
  // buffer. Send the next byte
  unsigned char c = _tx_buffer[_tx_buffer_tail];
    1c64:	84 8d       	ldd	r24, Z+28	; 0x1c
    1c66:	df 01       	movw	r26, r30
    1c68:	a8 0f       	add	r26, r24
    1c6a:	b1 1d       	adc	r27, r1
    1c6c:	a3 5a       	subi	r26, 0xA3	; 163
    1c6e:	bf 4f       	sbci	r27, 0xFF	; 255
    1c70:	2c 91       	ld	r18, X
  _tx_buffer_tail = (_tx_buffer_tail + 1) % SERIAL_TX_BUFFER_SIZE;
    1c72:	84 8d       	ldd	r24, Z+28	; 0x1c
    1c74:	90 e0       	ldi	r25, 0x00	; 0
    1c76:	01 96       	adiw	r24, 0x01	; 1
    1c78:	8f 73       	andi	r24, 0x3F	; 63
    1c7a:	99 27       	eor	r25, r25
    1c7c:	84 8f       	std	Z+28, r24	; 0x1c

  *_udr = c;
    1c7e:	a6 89       	ldd	r26, Z+22	; 0x16
    1c80:	b7 89       	ldd	r27, Z+23	; 0x17
    1c82:	2c 93       	st	X, r18
  // location". This makes sure flush() won't return until the bytes
  // actually got written. Other r/w bits are preserved, and zeroes
  // written to the rest.

#ifdef MPCM0
  *_ucsra = ((*_ucsra) & ((1 << U2X0) | (1 << MPCM0))) | (1 << TXC0);
    1c84:	a0 89       	ldd	r26, Z+16	; 0x10
    1c86:	b1 89       	ldd	r27, Z+17	; 0x11
    1c88:	8c 91       	ld	r24, X
    1c8a:	83 70       	andi	r24, 0x03	; 3
    1c8c:	80 64       	ori	r24, 0x40	; 64
    1c8e:	8c 93       	st	X, r24
#else
  *_ucsra = ((*_ucsra) & ((1 << U2X0) | (1 << TXC0)));
#endif

  if (_tx_buffer_head == _tx_buffer_tail) {
    1c90:	93 8d       	ldd	r25, Z+27	; 0x1b
    1c92:	84 8d       	ldd	r24, Z+28	; 0x1c
    1c94:	98 13       	cpse	r25, r24
    1c96:	06 c0       	rjmp	.+12     	; 0x1ca4 <_ZN14HardwareSerial17_tx_udr_empty_irqEv+0x42>
    // Buffer empty, so disable interrupts
    cbi(*_ucsrb, UDRIE0);
    1c98:	02 88       	ldd	r0, Z+18	; 0x12
    1c9a:	f3 89       	ldd	r31, Z+19	; 0x13
    1c9c:	e0 2d       	mov	r30, r0
    1c9e:	80 81       	ld	r24, Z
    1ca0:	8f 7d       	andi	r24, 0xDF	; 223
    1ca2:	80 83       	st	Z, r24
    1ca4:	08 95       	ret

00001ca6 <_ZN14HardwareSerial5writeEh>:
  // If we get here, nothing is queued anymore (DRIE is disabled) and
  // the hardware finished tranmission (TXC is set).
}

size_t HardwareSerial::write(uint8_t c)
{
    1ca6:	ef 92       	push	r14
    1ca8:	ff 92       	push	r15
    1caa:	0f 93       	push	r16
    1cac:	1f 93       	push	r17
    1cae:	cf 93       	push	r28
    1cb0:	df 93       	push	r29
    1cb2:	ec 01       	movw	r28, r24
  _written = true;
    1cb4:	81 e0       	ldi	r24, 0x01	; 1
    1cb6:	88 8f       	std	Y+24, r24	; 0x18
  // If the buffer and the data register is empty, just write the byte
  // to the data register and be done. This shortcut helps
  // significantly improve the effective datarate at high (>
  // 500kbit/s) bitrates, where interrupt overhead becomes a slowdown.
  if (_tx_buffer_head == _tx_buffer_tail && bit_is_set(*_ucsra, UDRE0)) {
    1cb8:	9b 8d       	ldd	r25, Y+27	; 0x1b
    1cba:	8c 8d       	ldd	r24, Y+28	; 0x1c
    1cbc:	98 13       	cpse	r25, r24
    1cbe:	05 c0       	rjmp	.+10     	; 0x1cca <_ZN14HardwareSerial5writeEh+0x24>
    1cc0:	e8 89       	ldd	r30, Y+16	; 0x10
    1cc2:	f9 89       	ldd	r31, Y+17	; 0x11
    1cc4:	80 81       	ld	r24, Z
    1cc6:	85 fd       	sbrc	r24, 5
    1cc8:	26 c0       	rjmp	.+76     	; 0x1d16 <_ZN14HardwareSerial5writeEh+0x70>
    1cca:	f6 2e       	mov	r15, r22
      *_ucsra = ((*_ucsra) & ((1 << U2X0) | (1 << TXC0)));
#endif
    }
    return 1;
  }
  tx_buffer_index_t i = (_tx_buffer_head + 1) % SERIAL_TX_BUFFER_SIZE;
    1ccc:	0b 8d       	ldd	r16, Y+27	; 0x1b
    1cce:	10 e0       	ldi	r17, 0x00	; 0
    1cd0:	0f 5f       	subi	r16, 0xFF	; 255
    1cd2:	1f 4f       	sbci	r17, 0xFF	; 255
    1cd4:	0f 73       	andi	r16, 0x3F	; 63
    1cd6:	11 27       	eor	r17, r17
    1cd8:	e0 2e       	mov	r14, r16
	
  // If the output buffer is full, there's nothing for it other than to 
  // wait for the interrupt handler to empty it a bit
  while (i == _tx_buffer_tail) {
    1cda:	8c 8d       	ldd	r24, Y+28	; 0x1c
    1cdc:	e8 12       	cpse	r14, r24
    1cde:	0c c0       	rjmp	.+24     	; 0x1cf8 <_ZN14HardwareSerial5writeEh+0x52>
    if (bit_is_clear(SREG, SREG_I)) {
    1ce0:	0f b6       	in	r0, 0x3f	; 63
    1ce2:	07 fc       	sbrc	r0, 7
    1ce4:	fa cf       	rjmp	.-12     	; 0x1cda <_ZN14HardwareSerial5writeEh+0x34>
      // Interrupts are disabled, so we'll have to poll the data
      // register empty flag ourselves. If it is set, pretend an
      // interrupt has happened and call the handler to free up
      // space for us.
      if(bit_is_set(*_ucsra, UDRE0))
    1ce6:	e8 89       	ldd	r30, Y+16	; 0x10
    1ce8:	f9 89       	ldd	r31, Y+17	; 0x11
    1cea:	80 81       	ld	r24, Z
    1cec:	85 ff       	sbrs	r24, 5
    1cee:	f5 cf       	rjmp	.-22     	; 0x1cda <_ZN14HardwareSerial5writeEh+0x34>
	_tx_udr_empty_irq();
    1cf0:	ce 01       	movw	r24, r28
    1cf2:	0e 94 31 0e 	call	0x1c62	; 0x1c62 <_ZN14HardwareSerial17_tx_udr_empty_irqEv>
    1cf6:	f1 cf       	rjmp	.-30     	; 0x1cda <_ZN14HardwareSerial5writeEh+0x34>
    } else {
      // nop, the interrupt handler will free up space for us
    }
  }

  _tx_buffer[_tx_buffer_head] = c;
    1cf8:	8b 8d       	ldd	r24, Y+27	; 0x1b
    1cfa:	fe 01       	movw	r30, r28
    1cfc:	e8 0f       	add	r30, r24
    1cfe:	f1 1d       	adc	r31, r1
    1d00:	e3 5a       	subi	r30, 0xA3	; 163
    1d02:	ff 4f       	sbci	r31, 0xFF	; 255
    1d04:	f0 82       	st	Z, r15

  // make atomic to prevent execution of ISR between setting the
  // head pointer and setting the interrupt flag resulting in buffer
  // retransmission
  ATOMIC_BLOCK(ATOMIC_RESTORESTATE) {
    1d06:	9f b7       	in	r25, 0x3f	; 63
    return 1;
}

static __inline__ uint8_t __iCliRetVal(void)
{
    cli();
    1d08:	f8 94       	cli
    _tx_buffer_head = i;
    1d0a:	0b 8f       	std	Y+27, r16	; 0x1b
    sbi(*_ucsrb, UDRIE0);
    1d0c:	ea 89       	ldd	r30, Y+18	; 0x12
    1d0e:	fb 89       	ldd	r31, Y+19	; 0x13
    1d10:	80 81       	ld	r24, Z
    1d12:	80 62       	ori	r24, 0x20	; 32
    1d14:	0a c0       	rjmp	.+20     	; 0x1d2a <_ZN14HardwareSerial5writeEh+0x84>
    // So writing UDR must happen first.
    // Writing UDR and clearing TC must be done atomically, otherwise
    // interrupts might delay the TXC clear so the byte written to UDR
    // is transmitted (setting TXC) before clearing TXC. Then TXC will
    // be cleared when no bytes are left, causing flush() to hang
    ATOMIC_BLOCK(ATOMIC_RESTORESTATE) {
    1d16:	9f b7       	in	r25, 0x3f	; 63
    1d18:	f8 94       	cli
      *_udr = c;
    1d1a:	ee 89       	ldd	r30, Y+22	; 0x16
    1d1c:	ff 89       	ldd	r31, Y+23	; 0x17
    1d1e:	60 83       	st	Z, r22
#ifdef MPCM0
      *_ucsra = ((*_ucsra) & ((1 << U2X0) | (1 << MPCM0))) | (1 << TXC0);
    1d20:	e8 89       	ldd	r30, Y+16	; 0x10
    1d22:	f9 89       	ldd	r31, Y+17	; 0x11
    1d24:	80 81       	ld	r24, Z
    1d26:	83 70       	andi	r24, 0x03	; 3
    1d28:	80 64       	ori	r24, 0x40	; 64
    1d2a:	80 83       	st	Z, r24
    (void)__s;
}

static __inline__ void __iRestore(const  uint8_t *__s)
{
    SREG = *__s;
    1d2c:	9f bf       	out	0x3f, r25	; 63
    _tx_buffer_head = i;
    sbi(*_ucsrb, UDRIE0);
  }
  
  return 1;
}
    1d2e:	81 e0       	ldi	r24, 0x01	; 1
    1d30:	90 e0       	ldi	r25, 0x00	; 0
    1d32:	df 91       	pop	r29
    1d34:	cf 91       	pop	r28
    1d36:	1f 91       	pop	r17
    1d38:	0f 91       	pop	r16
    1d3a:	ff 90       	pop	r15
    1d3c:	ef 90       	pop	r14
    1d3e:	08 95       	ret

00001d40 <_ZN14HardwareSerial5flushEv>:
  if (head >= tail) return SERIAL_TX_BUFFER_SIZE - 1 - head + tail;
  return tail - head - 1;
}

void HardwareSerial::flush()
{
    1d40:	cf 93       	push	r28
    1d42:	df 93       	push	r29
    1d44:	ec 01       	movw	r28, r24
  // If we have never written a byte, no need to flush. This special
  // case is needed since there is no way to force the TXC (transmit
  // complete) bit to 1 during initialization
  if (!_written)
    1d46:	88 8d       	ldd	r24, Y+24	; 0x18
    1d48:	88 23       	and	r24, r24
    1d4a:	c9 f0       	breq	.+50     	; 0x1d7e <_ZN14HardwareSerial5flushEv+0x3e>
    return;

  while (bit_is_set(*_ucsrb, UDRIE0) || bit_is_clear(*_ucsra, TXC0)) {
    1d4c:	ea 89       	ldd	r30, Y+18	; 0x12
    1d4e:	fb 89       	ldd	r31, Y+19	; 0x13
    1d50:	80 81       	ld	r24, Z
    1d52:	85 fd       	sbrc	r24, 5
    1d54:	05 c0       	rjmp	.+10     	; 0x1d60 <_ZN14HardwareSerial5flushEv+0x20>
    1d56:	a8 89       	ldd	r26, Y+16	; 0x10
    1d58:	b9 89       	ldd	r27, Y+17	; 0x11
    1d5a:	8c 91       	ld	r24, X
    1d5c:	86 fd       	sbrc	r24, 6
    1d5e:	0f c0       	rjmp	.+30     	; 0x1d7e <_ZN14HardwareSerial5flushEv+0x3e>
    if (bit_is_clear(SREG, SREG_I) && bit_is_set(*_ucsrb, UDRIE0))
    1d60:	0f b6       	in	r0, 0x3f	; 63
    1d62:	07 fc       	sbrc	r0, 7
    1d64:	f5 cf       	rjmp	.-22     	; 0x1d50 <_ZN14HardwareSerial5flushEv+0x10>
    1d66:	80 81       	ld	r24, Z
    1d68:	85 ff       	sbrs	r24, 5
    1d6a:	f2 cf       	rjmp	.-28     	; 0x1d50 <_ZN14HardwareSerial5flushEv+0x10>
	// Interrupts are globally disabled, but the DR empty
	// interrupt should be enabled, so poll the DR empty flag to
	// prevent deadlock
	if (bit_is_set(*_ucsra, UDRE0))
    1d6c:	a8 89       	ldd	r26, Y+16	; 0x10
    1d6e:	b9 89       	ldd	r27, Y+17	; 0x11
    1d70:	8c 91       	ld	r24, X
    1d72:	85 ff       	sbrs	r24, 5
    1d74:	ed cf       	rjmp	.-38     	; 0x1d50 <_ZN14HardwareSerial5flushEv+0x10>
	  _tx_udr_empty_irq();
    1d76:	ce 01       	movw	r24, r28
    1d78:	0e 94 31 0e 	call	0x1c62	; 0x1c62 <_ZN14HardwareSerial17_tx_udr_empty_irqEv>
    1d7c:	e7 cf       	rjmp	.-50     	; 0x1d4c <_ZN14HardwareSerial5flushEv+0xc>
  }
  // If we get here, nothing is queued anymore (DRIE is disabled) and
  // the hardware finished tranmission (TXC is set).
}
    1d7e:	df 91       	pop	r29
    1d80:	cf 91       	pop	r28
    1d82:	08 95       	ret

00001d84 <_ZN14HardwareSerial5beginEmh>:
}

// Public Methods //////////////////////////////////////////////////////////////

void HardwareSerial::begin(unsigned long baud, byte config)
{
    1d84:	cf 92       	push	r12
    1d86:	df 92       	push	r13
    1d88:	ef 92       	push	r14
    1d8a:	ff 92       	push	r15
    1d8c:	1f 93       	push	r17
    1d8e:	cf 93       	push	r28
    1d90:	df 93       	push	r29
    1d92:	ec 01       	movw	r28, r24
    1d94:	6a 01       	movw	r12, r20
    1d96:	7b 01       	movw	r14, r22
    1d98:	12 2f       	mov	r17, r18
  // Try u2x mode first
  uint16_t baud_setting = (F_CPU / 4 / baud - 1) / 2;
  *_ucsra = 1 << U2X0;
    1d9a:	e8 89       	ldd	r30, Y+16	; 0x10
    1d9c:	f9 89       	ldd	r31, Y+17	; 0x11
    1d9e:	82 e0       	ldi	r24, 0x02	; 2
    1da0:	80 83       	st	Z, r24
  // hardcoded exception for 57600 for compatibility with the bootloader
  // shipped with the Duemilanove and previous boards and the firmware
  // on the 8U2 on the Uno and Mega 2560. Also, The baud_setting cannot
  // be > 4095, so switch back to non-u2x mode if the baud rate is too
  // low.
  if (((F_CPU == 16000000UL) && (baud == 57600)) || (baud_setting >4095))
    1da2:	41 15       	cp	r20, r1
    1da4:	51 4e       	sbci	r21, 0xE1	; 225
    1da6:	61 05       	cpc	r22, r1
    1da8:	71 05       	cpc	r23, r1
    1daa:	b1 f0       	breq	.+44     	; 0x1dd8 <_ZN14HardwareSerial5beginEmh+0x54>
// Public Methods //////////////////////////////////////////////////////////////

void HardwareSerial::begin(unsigned long baud, byte config)
{
  // Try u2x mode first
  uint16_t baud_setting = (F_CPU / 4 / baud - 1) / 2;
    1dac:	60 e0       	ldi	r22, 0x00	; 0
    1dae:	79 e0       	ldi	r23, 0x09	; 9
    1db0:	8d e3       	ldi	r24, 0x3D	; 61
    1db2:	90 e0       	ldi	r25, 0x00	; 0
    1db4:	a7 01       	movw	r20, r14
    1db6:	96 01       	movw	r18, r12
    1db8:	0e 94 41 21 	call	0x4282	; 0x4282 <__udivmodsi4>
    1dbc:	da 01       	movw	r26, r20
    1dbe:	c9 01       	movw	r24, r18
    1dc0:	01 97       	sbiw	r24, 0x01	; 1
    1dc2:	a1 09       	sbc	r26, r1
    1dc4:	b1 09       	sbc	r27, r1
    1dc6:	b6 95       	lsr	r27
    1dc8:	a7 95       	ror	r26
    1dca:	97 95       	ror	r25
    1dcc:	87 95       	ror	r24
    1dce:	9c 01       	movw	r18, r24
  // hardcoded exception for 57600 for compatibility with the bootloader
  // shipped with the Duemilanove and previous boards and the firmware
  // on the 8U2 on the Uno and Mega 2560. Also, The baud_setting cannot
  // be > 4095, so switch back to non-u2x mode if the baud rate is too
  // low.
  if (((F_CPU == 16000000UL) && (baud == 57600)) || (baud_setting >4095))
    1dd0:	21 15       	cp	r18, r1
    1dd2:	80 e1       	ldi	r24, 0x10	; 16
    1dd4:	38 07       	cpc	r19, r24
    1dd6:	a8 f0       	brcs	.+42     	; 0x1e02 <_ZN14HardwareSerial5beginEmh+0x7e>
  {
    *_ucsra = 0;
    1dd8:	e8 89       	ldd	r30, Y+16	; 0x10
    1dda:	f9 89       	ldd	r31, Y+17	; 0x11
    1ddc:	10 82       	st	Z, r1
    baud_setting = (F_CPU / 8 / baud - 1) / 2;
    1dde:	60 e8       	ldi	r22, 0x80	; 128
    1de0:	74 e8       	ldi	r23, 0x84	; 132
    1de2:	8e e1       	ldi	r24, 0x1E	; 30
    1de4:	90 e0       	ldi	r25, 0x00	; 0
    1de6:	a7 01       	movw	r20, r14
    1de8:	96 01       	movw	r18, r12
    1dea:	0e 94 41 21 	call	0x4282	; 0x4282 <__udivmodsi4>
    1dee:	da 01       	movw	r26, r20
    1df0:	c9 01       	movw	r24, r18
    1df2:	01 97       	sbiw	r24, 0x01	; 1
    1df4:	a1 09       	sbc	r26, r1
    1df6:	b1 09       	sbc	r27, r1
    1df8:	b6 95       	lsr	r27
    1dfa:	a7 95       	ror	r26
    1dfc:	97 95       	ror	r25
    1dfe:	87 95       	ror	r24
    1e00:	9c 01       	movw	r18, r24
  }

  // assign the baud_setting, a.k.a. ubrr (USART Baud Rate Register)
  *_ubrrh = baud_setting >> 8;
    1e02:	ec 85       	ldd	r30, Y+12	; 0x0c
    1e04:	fd 85       	ldd	r31, Y+13	; 0x0d
    1e06:	30 83       	st	Z, r19
  *_ubrrl = baud_setting;
    1e08:	ee 85       	ldd	r30, Y+14	; 0x0e
    1e0a:	ff 85       	ldd	r31, Y+15	; 0x0f
    1e0c:	20 83       	st	Z, r18

  _written = false;
    1e0e:	18 8e       	std	Y+24, r1	; 0x18

  //set the data bits, parity, and stop bits
#if defined(__AVR_ATmega8__)
  config |= 0x80; // select UCSRC register (shared with UBRRH)
#endif
  *_ucsrc = config;
    1e10:	ec 89       	ldd	r30, Y+20	; 0x14
    1e12:	fd 89       	ldd	r31, Y+21	; 0x15
    1e14:	10 83       	st	Z, r17
  
  sbi(*_ucsrb, RXEN0);
    1e16:	ea 89       	ldd	r30, Y+18	; 0x12
    1e18:	fb 89       	ldd	r31, Y+19	; 0x13
    1e1a:	80 81       	ld	r24, Z
    1e1c:	80 61       	ori	r24, 0x10	; 16
    1e1e:	80 83       	st	Z, r24
  sbi(*_ucsrb, TXEN0);
    1e20:	ea 89       	ldd	r30, Y+18	; 0x12
    1e22:	fb 89       	ldd	r31, Y+19	; 0x13
    1e24:	80 81       	ld	r24, Z
    1e26:	88 60       	ori	r24, 0x08	; 8
    1e28:	80 83       	st	Z, r24
  sbi(*_ucsrb, RXCIE0);
    1e2a:	ea 89       	ldd	r30, Y+18	; 0x12
    1e2c:	fb 89       	ldd	r31, Y+19	; 0x13
    1e2e:	80 81       	ld	r24, Z
    1e30:	80 68       	ori	r24, 0x80	; 128
    1e32:	80 83       	st	Z, r24
  cbi(*_ucsrb, UDRIE0);
    1e34:	ea 89       	ldd	r30, Y+18	; 0x12
    1e36:	fb 89       	ldd	r31, Y+19	; 0x13
    1e38:	80 81       	ld	r24, Z
    1e3a:	8f 7d       	andi	r24, 0xDF	; 223
    1e3c:	80 83       	st	Z, r24
}
    1e3e:	df 91       	pop	r29
    1e40:	cf 91       	pop	r28
    1e42:	1f 91       	pop	r17
    1e44:	ff 90       	pop	r15
    1e46:	ef 90       	pop	r14
    1e48:	df 90       	pop	r13
    1e4a:	cf 90       	pop	r12
    1e4c:	08 95       	ret

00001e4e <__vector_18>:
#elif defined(USART_RXC_vect)
  ISR(USART_RXC_vect) // ATmega8
#else
  #error "Don't know what the Data Received vector is called for Serial"
#endif
  {
    1e4e:	1f 92       	push	r1
    1e50:	0f 92       	push	r0
    1e52:	0f b6       	in	r0, 0x3f	; 63
    1e54:	0f 92       	push	r0
    1e56:	11 24       	eor	r1, r1
    1e58:	2f 93       	push	r18
    1e5a:	8f 93       	push	r24
    1e5c:	9f 93       	push	r25
    1e5e:	ef 93       	push	r30
    1e60:	ff 93       	push	r31

// Actual interrupt handlers //////////////////////////////////////////////////////////////

void HardwareSerial::_rx_complete_irq(void)
{
  if (bit_is_clear(*_ucsra, UPE0)) {
    1e62:	e0 91 06 04 	lds	r30, 0x0406	; 0x800406 <Serial+0x10>
    1e66:	f0 91 07 04 	lds	r31, 0x0407	; 0x800407 <Serial+0x11>
    1e6a:	80 81       	ld	r24, Z
    1e6c:	e0 91 0c 04 	lds	r30, 0x040C	; 0x80040c <Serial+0x16>
    1e70:	f0 91 0d 04 	lds	r31, 0x040D	; 0x80040d <Serial+0x17>
    1e74:	82 fd       	sbrc	r24, 2
    1e76:	12 c0       	rjmp	.+36     	; 0x1e9c <__vector_18+0x4e>
    // No Parity error, read byte and store it in the buffer if there is
    // room
    unsigned char c = *_udr;
    1e78:	90 81       	ld	r25, Z
    rx_buffer_index_t i = (unsigned int)(_rx_buffer_head + 1) % SERIAL_RX_BUFFER_SIZE;
    1e7a:	80 91 0f 04 	lds	r24, 0x040F	; 0x80040f <Serial+0x19>
    1e7e:	8f 5f       	subi	r24, 0xFF	; 255
    1e80:	8f 73       	andi	r24, 0x3F	; 63

    // if we should be storing the received character into the location
    // just before the tail (meaning that the head would advance to the
    // current location of the tail), we're about to overflow the buffer
    // and so we don't write the character or advance the head.
    if (i != _rx_buffer_tail) {
    1e82:	20 91 10 04 	lds	r18, 0x0410	; 0x800410 <Serial+0x1a>
    1e86:	82 17       	cp	r24, r18
    1e88:	51 f0       	breq	.+20     	; 0x1e9e <__vector_18+0x50>
      _rx_buffer[_rx_buffer_head] = c;
    1e8a:	e0 91 0f 04 	lds	r30, 0x040F	; 0x80040f <Serial+0x19>
    1e8e:	f0 e0       	ldi	r31, 0x00	; 0
    1e90:	ea 50       	subi	r30, 0x0A	; 10
    1e92:	fc 4f       	sbci	r31, 0xFC	; 252
    1e94:	95 8f       	std	Z+29, r25	; 0x1d
      _rx_buffer_head = i;
    1e96:	80 93 0f 04 	sts	0x040F, r24	; 0x80040f <Serial+0x19>
    1e9a:	01 c0       	rjmp	.+2      	; 0x1e9e <__vector_18+0x50>
    }
  } else {
    // Parity error, read byte but discard it
    *_udr;
    1e9c:	80 81       	ld	r24, Z
    Serial._rx_complete_irq();
  }
    1e9e:	ff 91       	pop	r31
    1ea0:	ef 91       	pop	r30
    1ea2:	9f 91       	pop	r25
    1ea4:	8f 91       	pop	r24
    1ea6:	2f 91       	pop	r18
    1ea8:	0f 90       	pop	r0
    1eaa:	0f be       	out	0x3f, r0	; 63
    1eac:	0f 90       	pop	r0
    1eae:	1f 90       	pop	r1
    1eb0:	18 95       	reti

00001eb2 <__vector_19>:
#elif defined(USART_UDRE_vect)
ISR(USART_UDRE_vect)
#else
  #error "Don't know what the Data Register Empty vector is called for Serial"
#endif
{
    1eb2:	1f 92       	push	r1
    1eb4:	0f 92       	push	r0
    1eb6:	0f b6       	in	r0, 0x3f	; 63
    1eb8:	0f 92       	push	r0
    1eba:	11 24       	eor	r1, r1
    1ebc:	2f 93       	push	r18
    1ebe:	3f 93       	push	r19
    1ec0:	4f 93       	push	r20
    1ec2:	5f 93       	push	r21
    1ec4:	6f 93       	push	r22
    1ec6:	7f 93       	push	r23
    1ec8:	8f 93       	push	r24
    1eca:	9f 93       	push	r25
    1ecc:	af 93       	push	r26
    1ece:	bf 93       	push	r27
    1ed0:	ef 93       	push	r30
    1ed2:	ff 93       	push	r31
  Serial._tx_udr_empty_irq();
    1ed4:	86 ef       	ldi	r24, 0xF6	; 246
    1ed6:	93 e0       	ldi	r25, 0x03	; 3
    1ed8:	0e 94 31 0e 	call	0x1c62	; 0x1c62 <_ZN14HardwareSerial17_tx_udr_empty_irqEv>
}
    1edc:	ff 91       	pop	r31
    1ede:	ef 91       	pop	r30
    1ee0:	bf 91       	pop	r27
    1ee2:	af 91       	pop	r26
    1ee4:	9f 91       	pop	r25
    1ee6:	8f 91       	pop	r24
    1ee8:	7f 91       	pop	r23
    1eea:	6f 91       	pop	r22
    1eec:	5f 91       	pop	r21
    1eee:	4f 91       	pop	r20
    1ef0:	3f 91       	pop	r19
    1ef2:	2f 91       	pop	r18
    1ef4:	0f 90       	pop	r0
    1ef6:	0f be       	out	0x3f, r0	; 63
    1ef8:	0f 90       	pop	r0
    1efa:	1f 90       	pop	r1
    1efc:	18 95       	reti

00001efe <_Z17Serial0_availablev>:
#endif

// Function that can be weakly referenced by serialEventRun to prevent
// pulling in this file if it's not otherwise used.
bool Serial0_available() {
  return Serial.available();
    1efe:	86 ef       	ldi	r24, 0xF6	; 246
    1f00:	93 e0       	ldi	r25, 0x03	; 3
    1f02:	0e 94 e6 0d 	call	0x1bcc	; 0x1bcc <_ZN14HardwareSerial9availableEv>
    1f06:	21 e0       	ldi	r18, 0x01	; 1
    1f08:	89 2b       	or	r24, r25
    1f0a:	09 f4       	brne	.+2      	; 0x1f0e <_Z17Serial0_availablev+0x10>
    1f0c:	20 e0       	ldi	r18, 0x00	; 0
}
    1f0e:	82 2f       	mov	r24, r18
    1f10:	08 95       	ret

00001f12 <_GLOBAL__sub_I___vector_18>:
    size_t printNumber(unsigned long, uint8_t);
    size_t printFloat(double, uint8_t);
  protected:
    void setWriteError(int err = 1) { write_error = err; }
  public:
    Print() : write_error(0) {}
    1f12:	e6 ef       	ldi	r30, 0xF6	; 246
    1f14:	f3 e0       	ldi	r31, 0x03	; 3
    1f16:	13 82       	std	Z+3, r1	; 0x03
    1f18:	12 82       	std	Z+2, r1	; 0x02
  public:
    virtual int available() = 0;
    virtual int read() = 0;
    virtual int peek() = 0;

    Stream() {_timeout=1000;}
    1f1a:	88 ee       	ldi	r24, 0xE8	; 232
    1f1c:	93 e0       	ldi	r25, 0x03	; 3
    1f1e:	a0 e0       	ldi	r26, 0x00	; 0
    1f20:	b0 e0       	ldi	r27, 0x00	; 0
    1f22:	84 83       	std	Z+4, r24	; 0x04
    1f24:	95 83       	std	Z+5, r25	; 0x05
    1f26:	a6 83       	std	Z+6, r26	; 0x06
    1f28:	b7 83       	std	Z+7, r27	; 0x07
  volatile uint8_t *ucsrc, volatile uint8_t *udr) :
    _ubrrh(ubrrh), _ubrrl(ubrrl),
    _ucsra(ucsra), _ucsrb(ucsrb), _ucsrc(ucsrc),
    _udr(udr),
    _rx_buffer_head(0), _rx_buffer_tail(0),
    _tx_buffer_head(0), _tx_buffer_tail(0)
    1f2a:	8b e8       	ldi	r24, 0x8B	; 139
    1f2c:	92 e0       	ldi	r25, 0x02	; 2
    1f2e:	91 83       	std	Z+1, r25	; 0x01
    1f30:	80 83       	st	Z, r24
    1f32:	85 ec       	ldi	r24, 0xC5	; 197
    1f34:	90 e0       	ldi	r25, 0x00	; 0
    1f36:	95 87       	std	Z+13, r25	; 0x0d
    1f38:	84 87       	std	Z+12, r24	; 0x0c
    1f3a:	84 ec       	ldi	r24, 0xC4	; 196
    1f3c:	90 e0       	ldi	r25, 0x00	; 0
    1f3e:	97 87       	std	Z+15, r25	; 0x0f
    1f40:	86 87       	std	Z+14, r24	; 0x0e
    1f42:	80 ec       	ldi	r24, 0xC0	; 192
    1f44:	90 e0       	ldi	r25, 0x00	; 0
    1f46:	91 8b       	std	Z+17, r25	; 0x11
    1f48:	80 8b       	std	Z+16, r24	; 0x10
    1f4a:	81 ec       	ldi	r24, 0xC1	; 193
    1f4c:	90 e0       	ldi	r25, 0x00	; 0
    1f4e:	93 8b       	std	Z+19, r25	; 0x13
    1f50:	82 8b       	std	Z+18, r24	; 0x12
    1f52:	82 ec       	ldi	r24, 0xC2	; 194
    1f54:	90 e0       	ldi	r25, 0x00	; 0
    1f56:	95 8b       	std	Z+21, r25	; 0x15
    1f58:	84 8b       	std	Z+20, r24	; 0x14
    1f5a:	86 ec       	ldi	r24, 0xC6	; 198
    1f5c:	90 e0       	ldi	r25, 0x00	; 0
    1f5e:	97 8b       	std	Z+23, r25	; 0x17
    1f60:	86 8b       	std	Z+22, r24	; 0x16
    1f62:	11 8e       	std	Z+25, r1	; 0x19
    1f64:	12 8e       	std	Z+26, r1	; 0x1a
    1f66:	13 8e       	std	Z+27, r1	; 0x1b
    1f68:	14 8e       	std	Z+28, r1	; 0x1c
    1f6a:	08 95       	ret

00001f6c <main>:
void setupUSB() __attribute__((weak));
void setupUSB() { }

int main(void)
{
	init();
    1f6c:	0e 94 1c 13 	call	0x2638	; 0x2638 <init>

	initVariant();
    1f70:	0e 94 49 1b 	call	0x3692	; 0x3692 <initVariant>

#if defined(USBCON)
	USBDevice.attach();
#endif
	
	setup();
    1f74:	0e 94 2b 07 	call	0xe56	; 0xe56 <setup>
    
	for (;;) {
		loop();
		if (serialEventRun) serialEventRun();
    1f78:	c3 e2       	ldi	r28, 0x23	; 35
    1f7a:	de e0       	ldi	r29, 0x0E	; 14
#endif
	
	setup();
    
	for (;;) {
		loop();
    1f7c:	0e 94 97 07 	call	0xf2e	; 0xf2e <loop>
		if (serialEventRun) serialEventRun();
    1f80:	20 97       	sbiw	r28, 0x00	; 0
    1f82:	e1 f3       	breq	.-8      	; 0x1f7c <main+0x10>
    1f84:	0e 94 23 0e 	call	0x1c46	; 0x1c46 <_Z14serialEventRunv>
    1f88:	f9 cf       	rjmp	.-14     	; 0x1f7c <main+0x10>

00001f8a <_ZN5Print5writeEPKhj>:
size_t Print::println(long num, int base)
{
  size_t n = print(num, base);
  n += println();
  return n;
}
    1f8a:	cf 92       	push	r12
    1f8c:	df 92       	push	r13
    1f8e:	ef 92       	push	r14
    1f90:	ff 92       	push	r15
    1f92:	0f 93       	push	r16
    1f94:	1f 93       	push	r17
    1f96:	cf 93       	push	r28
    1f98:	df 93       	push	r29
    1f9a:	6c 01       	movw	r12, r24
    1f9c:	7a 01       	movw	r14, r20
    1f9e:	8b 01       	movw	r16, r22
    1fa0:	c0 e0       	ldi	r28, 0x00	; 0
    1fa2:	d0 e0       	ldi	r29, 0x00	; 0
    1fa4:	ce 15       	cp	r28, r14
    1fa6:	df 05       	cpc	r29, r15
    1fa8:	81 f0       	breq	.+32     	; 0x1fca <_ZN5Print5writeEPKhj+0x40>
    1faa:	d8 01       	movw	r26, r16
    1fac:	6d 91       	ld	r22, X+
    1fae:	8d 01       	movw	r16, r26
    1fb0:	d6 01       	movw	r26, r12
    1fb2:	ed 91       	ld	r30, X+
    1fb4:	fc 91       	ld	r31, X
    1fb6:	01 90       	ld	r0, Z+
    1fb8:	f0 81       	ld	r31, Z
    1fba:	e0 2d       	mov	r30, r0
    1fbc:	c6 01       	movw	r24, r12
    1fbe:	09 95       	icall
    1fc0:	89 2b       	or	r24, r25
    1fc2:	11 f0       	breq	.+4      	; 0x1fc8 <_ZN5Print5writeEPKhj+0x3e>
    1fc4:	21 96       	adiw	r28, 0x01	; 1
    1fc6:	ee cf       	rjmp	.-36     	; 0x1fa4 <_ZN5Print5writeEPKhj+0x1a>
    1fc8:	7e 01       	movw	r14, r28
    1fca:	c7 01       	movw	r24, r14
    1fcc:	df 91       	pop	r29
    1fce:	cf 91       	pop	r28
    1fd0:	1f 91       	pop	r17
    1fd2:	0f 91       	pop	r16
    1fd4:	ff 90       	pop	r15
    1fd6:	ef 90       	pop	r14
    1fd8:	df 90       	pop	r13
    1fda:	cf 90       	pop	r12
    1fdc:	08 95       	ret

00001fde <_ZN5Print5printEPK19__FlashStringHelper>:
    1fde:	ef 92       	push	r14
    1fe0:	ff 92       	push	r15
    1fe2:	0f 93       	push	r16
    1fe4:	1f 93       	push	r17
    1fe6:	cf 93       	push	r28
    1fe8:	df 93       	push	r29
    1fea:	8c 01       	movw	r16, r24
    1fec:	7b 01       	movw	r14, r22
    1fee:	c0 e0       	ldi	r28, 0x00	; 0
    1ff0:	d0 e0       	ldi	r29, 0x00	; 0
    1ff2:	f7 01       	movw	r30, r14
    1ff4:	ec 0f       	add	r30, r28
    1ff6:	fd 1f       	adc	r31, r29
    1ff8:	64 91       	lpm	r22, Z
    1ffa:	66 23       	and	r22, r22
    1ffc:	61 f0       	breq	.+24     	; 0x2016 <_ZN5Print5printEPK19__FlashStringHelper+0x38>
    1ffe:	d8 01       	movw	r26, r16
    2000:	ed 91       	ld	r30, X+
    2002:	fc 91       	ld	r31, X
    2004:	01 90       	ld	r0, Z+
    2006:	f0 81       	ld	r31, Z
    2008:	e0 2d       	mov	r30, r0
    200a:	c8 01       	movw	r24, r16
    200c:	09 95       	icall
    200e:	89 2b       	or	r24, r25
    2010:	11 f0       	breq	.+4      	; 0x2016 <_ZN5Print5printEPK19__FlashStringHelper+0x38>
    2012:	21 96       	adiw	r28, 0x01	; 1
    2014:	ee cf       	rjmp	.-36     	; 0x1ff2 <_ZN5Print5printEPK19__FlashStringHelper+0x14>
    2016:	ce 01       	movw	r24, r28
    2018:	df 91       	pop	r29
    201a:	cf 91       	pop	r28
    201c:	1f 91       	pop	r17
    201e:	0f 91       	pop	r16
    2020:	ff 90       	pop	r15
    2022:	ef 90       	pop	r14
    2024:	08 95       	ret

00002026 <_ZN5Print5printEPKc>:
    2026:	0c 94 8d 01 	jmp	0x31a	; 0x31a <_ZN5Print5writeEPKc>

0000202a <_ZN5Print5printEc>:
    202a:	dc 01       	movw	r26, r24
    202c:	ed 91       	ld	r30, X+
    202e:	fc 91       	ld	r31, X
    2030:	01 90       	ld	r0, Z+
    2032:	f0 81       	ld	r31, Z
    2034:	e0 2d       	mov	r30, r0
    2036:	09 94       	ijmp

00002038 <_ZN5Print7printlnEv>:
    2038:	69 e9       	ldi	r22, 0x99	; 153
    203a:	72 e0       	ldi	r23, 0x02	; 2
    203c:	0c 94 8d 01 	jmp	0x31a	; 0x31a <_ZN5Print5writeEPKc>

00002040 <_ZN5Print7printlnEPKc>:
    2040:	0f 93       	push	r16
    2042:	1f 93       	push	r17
    2044:	cf 93       	push	r28
    2046:	df 93       	push	r29
    2048:	ec 01       	movw	r28, r24
    204a:	0e 94 8d 01 	call	0x31a	; 0x31a <_ZN5Print5writeEPKc>
    204e:	8c 01       	movw	r16, r24
    2050:	ce 01       	movw	r24, r28
    2052:	0e 94 1c 10 	call	0x2038	; 0x2038 <_ZN5Print7printlnEv>
    2056:	80 0f       	add	r24, r16
    2058:	91 1f       	adc	r25, r17
    205a:	df 91       	pop	r29
    205c:	cf 91       	pop	r28
    205e:	1f 91       	pop	r17
    2060:	0f 91       	pop	r16
    2062:	08 95       	ret

00002064 <_ZN5Print11printNumberEmh>:
    2064:	8f 92       	push	r8
    2066:	9f 92       	push	r9
    2068:	af 92       	push	r10
    206a:	bf 92       	push	r11
    206c:	ef 92       	push	r14
    206e:	ff 92       	push	r15
    2070:	0f 93       	push	r16
    2072:	1f 93       	push	r17
    2074:	cf 93       	push	r28
    2076:	df 93       	push	r29
    2078:	cd b7       	in	r28, 0x3d	; 61
    207a:	de b7       	in	r29, 0x3e	; 62
    207c:	a1 97       	sbiw	r28, 0x21	; 33
    207e:	0f b6       	in	r0, 0x3f	; 63
    2080:	f8 94       	cli
    2082:	de bf       	out	0x3e, r29	; 62
    2084:	0f be       	out	0x3f, r0	; 63
    2086:	cd bf       	out	0x3d, r28	; 61
    2088:	7c 01       	movw	r14, r24
    208a:	fa 01       	movw	r30, r20
    208c:	cb 01       	movw	r24, r22
    208e:	19 a2       	std	Y+33, r1	; 0x21
    2090:	22 30       	cpi	r18, 0x02	; 2
    2092:	08 f4       	brcc	.+2      	; 0x2096 <_ZN5Print11printNumberEmh+0x32>
    2094:	2a e0       	ldi	r18, 0x0A	; 10
    2096:	8e 01       	movw	r16, r28
    2098:	0f 5d       	subi	r16, 0xDF	; 223
    209a:	1f 4f       	sbci	r17, 0xFF	; 255
    209c:	82 2e       	mov	r8, r18
    209e:	91 2c       	mov	r9, r1
    20a0:	a1 2c       	mov	r10, r1
    20a2:	b1 2c       	mov	r11, r1
    20a4:	bf 01       	movw	r22, r30
    20a6:	a5 01       	movw	r20, r10
    20a8:	94 01       	movw	r18, r8
    20aa:	0e 94 41 21 	call	0x4282	; 0x4282 <__udivmodsi4>
    20ae:	f9 01       	movw	r30, r18
    20b0:	ca 01       	movw	r24, r20
    20b2:	01 50       	subi	r16, 0x01	; 1
    20b4:	11 09       	sbc	r17, r1
    20b6:	6a 30       	cpi	r22, 0x0A	; 10
    20b8:	10 f4       	brcc	.+4      	; 0x20be <_ZN5Print11printNumberEmh+0x5a>
    20ba:	60 5d       	subi	r22, 0xD0	; 208
    20bc:	01 c0       	rjmp	.+2      	; 0x20c0 <_ZN5Print11printNumberEmh+0x5c>
    20be:	69 5c       	subi	r22, 0xC9	; 201
    20c0:	d8 01       	movw	r26, r16
    20c2:	6c 93       	st	X, r22
    20c4:	23 2b       	or	r18, r19
    20c6:	24 2b       	or	r18, r20
    20c8:	25 2b       	or	r18, r21
    20ca:	61 f7       	brne	.-40     	; 0x20a4 <_ZN5Print11printNumberEmh+0x40>
    20cc:	b8 01       	movw	r22, r16
    20ce:	c7 01       	movw	r24, r14
    20d0:	0e 94 8d 01 	call	0x31a	; 0x31a <_ZN5Print5writeEPKc>
    20d4:	a1 96       	adiw	r28, 0x21	; 33
    20d6:	0f b6       	in	r0, 0x3f	; 63
    20d8:	f8 94       	cli
    20da:	de bf       	out	0x3e, r29	; 62
    20dc:	0f be       	out	0x3f, r0	; 63
    20de:	cd bf       	out	0x3d, r28	; 61
    20e0:	df 91       	pop	r29
    20e2:	cf 91       	pop	r28
    20e4:	1f 91       	pop	r17
    20e6:	0f 91       	pop	r16
    20e8:	ff 90       	pop	r15
    20ea:	ef 90       	pop	r14
    20ec:	bf 90       	pop	r11
    20ee:	af 90       	pop	r10
    20f0:	9f 90       	pop	r9
    20f2:	8f 90       	pop	r8
    20f4:	08 95       	ret

000020f6 <_ZN5Print5printEmi>:
    20f6:	21 15       	cp	r18, r1
    20f8:	31 05       	cpc	r19, r1
    20fa:	41 f4       	brne	.+16     	; 0x210c <_ZN5Print5printEmi+0x16>
    20fc:	dc 01       	movw	r26, r24
    20fe:	ed 91       	ld	r30, X+
    2100:	fc 91       	ld	r31, X
    2102:	01 90       	ld	r0, Z+
    2104:	f0 81       	ld	r31, Z
    2106:	e0 2d       	mov	r30, r0
    2108:	64 2f       	mov	r22, r20
    210a:	09 94       	ijmp
    210c:	0c 94 32 10 	jmp	0x2064	; 0x2064 <_ZN5Print11printNumberEmh>

00002110 <_ZN5Print5printEhi>:
    2110:	9a 01       	movw	r18, r20
    2112:	46 2f       	mov	r20, r22
    2114:	50 e0       	ldi	r21, 0x00	; 0
    2116:	60 e0       	ldi	r22, 0x00	; 0
    2118:	70 e0       	ldi	r23, 0x00	; 0
    211a:	0c 94 7b 10 	jmp	0x20f6	; 0x20f6 <_ZN5Print5printEmi>

0000211e <_ZN5Print7printlnEhi>:
    211e:	0f 93       	push	r16
    2120:	1f 93       	push	r17
    2122:	cf 93       	push	r28
    2124:	df 93       	push	r29
    2126:	ec 01       	movw	r28, r24
    2128:	0e 94 88 10 	call	0x2110	; 0x2110 <_ZN5Print5printEhi>
    212c:	8c 01       	movw	r16, r24
    212e:	ce 01       	movw	r24, r28
    2130:	0e 94 1c 10 	call	0x2038	; 0x2038 <_ZN5Print7printlnEv>
    2134:	80 0f       	add	r24, r16
    2136:	91 1f       	adc	r25, r17
    2138:	df 91       	pop	r29
    213a:	cf 91       	pop	r28
    213c:	1f 91       	pop	r17
    213e:	0f 91       	pop	r16
    2140:	08 95       	ret

00002142 <_ZN5Print5printEji>:
    2142:	9a 01       	movw	r18, r20
    2144:	ab 01       	movw	r20, r22
    2146:	60 e0       	ldi	r22, 0x00	; 0
    2148:	70 e0       	ldi	r23, 0x00	; 0
    214a:	0c 94 7b 10 	jmp	0x20f6	; 0x20f6 <_ZN5Print5printEmi>

0000214e <_ZN5Print5printEli>:
    214e:	cf 92       	push	r12
    2150:	df 92       	push	r13
    2152:	ef 92       	push	r14
    2154:	ff 92       	push	r15
    2156:	0f 93       	push	r16
    2158:	1f 93       	push	r17
    215a:	cf 93       	push	r28
    215c:	df 93       	push	r29
    215e:	21 15       	cp	r18, r1
    2160:	31 05       	cpc	r19, r1
    2162:	81 f4       	brne	.+32     	; 0x2184 <_ZN5Print5printEli+0x36>
    2164:	dc 01       	movw	r26, r24
    2166:	ed 91       	ld	r30, X+
    2168:	fc 91       	ld	r31, X
    216a:	01 90       	ld	r0, Z+
    216c:	f0 81       	ld	r31, Z
    216e:	e0 2d       	mov	r30, r0
    2170:	64 2f       	mov	r22, r20
    2172:	df 91       	pop	r29
    2174:	cf 91       	pop	r28
    2176:	1f 91       	pop	r17
    2178:	0f 91       	pop	r16
    217a:	ff 90       	pop	r15
    217c:	ef 90       	pop	r14
    217e:	df 90       	pop	r13
    2180:	cf 90       	pop	r12
    2182:	09 94       	ijmp
    2184:	2a 30       	cpi	r18, 0x0A	; 10
    2186:	31 05       	cpc	r19, r1
    2188:	01 f5       	brne	.+64     	; 0x21ca <_ZN5Print5printEli+0x7c>
    218a:	77 ff       	sbrs	r23, 7
    218c:	1d c0       	rjmp	.+58     	; 0x21c8 <_ZN5Print5printEli+0x7a>
    218e:	6a 01       	movw	r12, r20
    2190:	7b 01       	movw	r14, r22
    2192:	ec 01       	movw	r28, r24
    2194:	6d e2       	ldi	r22, 0x2D	; 45
    2196:	0e 94 15 10 	call	0x202a	; 0x202a <_ZN5Print5printEc>
    219a:	8c 01       	movw	r16, r24
    219c:	44 27       	eor	r20, r20
    219e:	55 27       	eor	r21, r21
    21a0:	ba 01       	movw	r22, r20
    21a2:	4c 19       	sub	r20, r12
    21a4:	5d 09       	sbc	r21, r13
    21a6:	6e 09       	sbc	r22, r14
    21a8:	7f 09       	sbc	r23, r15
    21aa:	2a e0       	ldi	r18, 0x0A	; 10
    21ac:	ce 01       	movw	r24, r28
    21ae:	0e 94 32 10 	call	0x2064	; 0x2064 <_ZN5Print11printNumberEmh>
    21b2:	80 0f       	add	r24, r16
    21b4:	91 1f       	adc	r25, r17
    21b6:	df 91       	pop	r29
    21b8:	cf 91       	pop	r28
    21ba:	1f 91       	pop	r17
    21bc:	0f 91       	pop	r16
    21be:	ff 90       	pop	r15
    21c0:	ef 90       	pop	r14
    21c2:	df 90       	pop	r13
    21c4:	cf 90       	pop	r12
    21c6:	08 95       	ret
    21c8:	2a e0       	ldi	r18, 0x0A	; 10
    21ca:	df 91       	pop	r29
    21cc:	cf 91       	pop	r28
    21ce:	1f 91       	pop	r17
    21d0:	0f 91       	pop	r16
    21d2:	ff 90       	pop	r15
    21d4:	ef 90       	pop	r14
    21d6:	df 90       	pop	r13
    21d8:	cf 90       	pop	r12
    21da:	0c 94 32 10 	jmp	0x2064	; 0x2064 <_ZN5Print11printNumberEmh>

000021de <_ZN5Print5printEii>:
    21de:	9a 01       	movw	r18, r20
    21e0:	ab 01       	movw	r20, r22
    21e2:	77 0f       	add	r23, r23
    21e4:	66 0b       	sbc	r22, r22
    21e6:	77 0b       	sbc	r23, r23
    21e8:	0c 94 a7 10 	jmp	0x214e	; 0x214e <_ZN5Print5printEli>

000021ec <_ZN5Print7printlnEii>:
    21ec:	0f 93       	push	r16
    21ee:	1f 93       	push	r17
    21f0:	cf 93       	push	r28
    21f2:	df 93       	push	r29
    21f4:	ec 01       	movw	r28, r24
    21f6:	0e 94 ef 10 	call	0x21de	; 0x21de <_ZN5Print5printEii>
    21fa:	8c 01       	movw	r16, r24
    21fc:	ce 01       	movw	r24, r28
    21fe:	0e 94 1c 10 	call	0x2038	; 0x2038 <_ZN5Print7printlnEv>
    2202:	80 0f       	add	r24, r16
    2204:	91 1f       	adc	r25, r17
    2206:	df 91       	pop	r29
    2208:	cf 91       	pop	r28
    220a:	1f 91       	pop	r17
    220c:	0f 91       	pop	r16
    220e:	08 95       	ret

00002210 <_ZN5Print10printFloatEdh>:

  return write(str);
}

size_t Print::printFloat(double number, uint8_t digits) 
{ 
    2210:	7f 92       	push	r7
    2212:	8f 92       	push	r8
    2214:	9f 92       	push	r9
    2216:	af 92       	push	r10
    2218:	bf 92       	push	r11
    221a:	cf 92       	push	r12
    221c:	df 92       	push	r13
    221e:	ef 92       	push	r14
    2220:	ff 92       	push	r15
    2222:	0f 93       	push	r16
    2224:	1f 93       	push	r17
    2226:	cf 93       	push	r28
    2228:	df 93       	push	r29
    222a:	8c 01       	movw	r16, r24
    222c:	6a 01       	movw	r12, r20
    222e:	7b 01       	movw	r14, r22
    2230:	72 2e       	mov	r7, r18
  size_t n = 0;
  
  if (isnan(number)) return print("nan");
    2232:	9a 01       	movw	r18, r20
    2234:	ab 01       	movw	r20, r22
    2236:	c7 01       	movw	r24, r14
    2238:	b6 01       	movw	r22, r12
    223a:	0e 94 28 21 	call	0x4250	; 0x4250 <__unordsf2>
    223e:	88 23       	and	r24, r24
    2240:	19 f0       	breq	.+6      	; 0x2248 <_ZN5Print10printFloatEdh+0x38>
  return write(s.c_str(), s.length());
}

size_t Print::print(const char str[])
{
  return write(str);
    2242:	6c e9       	ldi	r22, 0x9C	; 156
    2244:	72 e0       	ldi	r23, 0x02	; 2
    2246:	27 c0       	rjmp	.+78     	; 0x2296 <_ZN5Print10printFloatEdh+0x86>
size_t Print::printFloat(double number, uint8_t digits) 
{ 
  size_t n = 0;
  
  if (isnan(number)) return print("nan");
  if (isinf(number)) return print("inf");
    2248:	46 01       	movw	r8, r12
    224a:	57 01       	movw	r10, r14
    224c:	e8 94       	clt
    224e:	b7 f8       	bld	r11, 7
    2250:	2f ef       	ldi	r18, 0xFF	; 255
    2252:	3f ef       	ldi	r19, 0xFF	; 255
    2254:	4f e7       	ldi	r20, 0x7F	; 127
    2256:	5f e7       	ldi	r21, 0x7F	; 127
    2258:	c5 01       	movw	r24, r10
    225a:	b4 01       	movw	r22, r8
    225c:	0e 94 28 21 	call	0x4250	; 0x4250 <__unordsf2>
    2260:	81 11       	cpse	r24, r1
    2262:	0d c0       	rjmp	.+26     	; 0x227e <_ZN5Print10printFloatEdh+0x6e>
    2264:	2f ef       	ldi	r18, 0xFF	; 255
    2266:	3f ef       	ldi	r19, 0xFF	; 255
    2268:	4f e7       	ldi	r20, 0x7F	; 127
    226a:	5f e7       	ldi	r21, 0x7F	; 127
    226c:	c5 01       	movw	r24, r10
    226e:	b4 01       	movw	r22, r8
    2270:	0e 94 15 0c 	call	0x182a	; 0x182a <__cmpsf2>
    2274:	18 16       	cp	r1, r24
    2276:	1c f4       	brge	.+6      	; 0x227e <_ZN5Print10printFloatEdh+0x6e>
  return write(s.c_str(), s.length());
}

size_t Print::print(const char str[])
{
  return write(str);
    2278:	60 ea       	ldi	r22, 0xA0	; 160
    227a:	72 e0       	ldi	r23, 0x02	; 2
    227c:	0c c0       	rjmp	.+24     	; 0x2296 <_ZN5Print10printFloatEdh+0x86>
{ 
  size_t n = 0;
  
  if (isnan(number)) return print("nan");
  if (isinf(number)) return print("inf");
  if (number > 4294967040.0) return print ("ovf");  // constant determined empirically
    227e:	2f ef       	ldi	r18, 0xFF	; 255
    2280:	3f ef       	ldi	r19, 0xFF	; 255
    2282:	4f e7       	ldi	r20, 0x7F	; 127
    2284:	5f e4       	ldi	r21, 0x4F	; 79
    2286:	c7 01       	movw	r24, r14
    2288:	b6 01       	movw	r22, r12
    228a:	0e 94 74 0d 	call	0x1ae8	; 0x1ae8 <__gesf2>
    228e:	18 16       	cp	r1, r24
    2290:	94 f4       	brge	.+36     	; 0x22b6 <_ZN5Print10printFloatEdh+0xa6>
  return write(s.c_str(), s.length());
}

size_t Print::print(const char str[])
{
  return write(str);
    2292:	64 ea       	ldi	r22, 0xA4	; 164
    2294:	72 e0       	ldi	r23, 0x02	; 2
    2296:	c8 01       	movw	r24, r16
    n += print(toPrint);
    remainder -= toPrint; 
  } 
  
  return n;
}
    2298:	df 91       	pop	r29
    229a:	cf 91       	pop	r28
    229c:	1f 91       	pop	r17
    229e:	0f 91       	pop	r16
    22a0:	ff 90       	pop	r15
    22a2:	ef 90       	pop	r14
    22a4:	df 90       	pop	r13
    22a6:	cf 90       	pop	r12
    22a8:	bf 90       	pop	r11
    22aa:	af 90       	pop	r10
    22ac:	9f 90       	pop	r9
    22ae:	8f 90       	pop	r8
    22b0:	7f 90       	pop	r7
  return write(s.c_str(), s.length());
}

size_t Print::print(const char str[])
{
  return write(str);
    22b2:	0c 94 8d 01 	jmp	0x31a	; 0x31a <_ZN5Print5writeEPKc>
  size_t n = 0;
  
  if (isnan(number)) return print("nan");
  if (isinf(number)) return print("inf");
  if (number > 4294967040.0) return print ("ovf");  // constant determined empirically
  if (number <-4294967040.0) return print ("ovf");  // constant determined empirically
    22b6:	2f ef       	ldi	r18, 0xFF	; 255
    22b8:	3f ef       	ldi	r19, 0xFF	; 255
    22ba:	4f e7       	ldi	r20, 0x7F	; 127
    22bc:	5f ec       	ldi	r21, 0xCF	; 207
    22be:	c7 01       	movw	r24, r14
    22c0:	b6 01       	movw	r22, r12
    22c2:	0e 94 15 0c 	call	0x182a	; 0x182a <__cmpsf2>
    22c6:	87 fd       	sbrc	r24, 7
    22c8:	e4 cf       	rjmp	.-56     	; 0x2292 <_ZN5Print10printFloatEdh+0x82>
  
  // Handle negative numbers
  if (number < 0.0)
    22ca:	20 e0       	ldi	r18, 0x00	; 0
    22cc:	30 e0       	ldi	r19, 0x00	; 0
    22ce:	a9 01       	movw	r20, r18
    22d0:	c7 01       	movw	r24, r14
    22d2:	b6 01       	movw	r22, r12
    22d4:	0e 94 15 0c 	call	0x182a	; 0x182a <__cmpsf2>
    22d8:	87 ff       	sbrs	r24, 7
    22da:	0a c0       	rjmp	.+20     	; 0x22f0 <_ZN5Print10printFloatEdh+0xe0>
  {
     n += print('-');
    22dc:	6d e2       	ldi	r22, 0x2D	; 45
    22de:	c8 01       	movw	r24, r16
    22e0:	0e 94 15 10 	call	0x202a	; 0x202a <_ZN5Print5printEc>
    22e4:	ec 01       	movw	r28, r24
     number = -number;
    22e6:	f7 fa       	bst	r15, 7
    22e8:	f0 94       	com	r15
    22ea:	f7 f8       	bld	r15, 7
    22ec:	f0 94       	com	r15
    22ee:	02 c0       	rjmp	.+4      	; 0x22f4 <_ZN5Print10printFloatEdh+0xe4>
  return write(str);
}

size_t Print::printFloat(double number, uint8_t digits) 
{ 
  size_t n = 0;
    22f0:	c0 e0       	ldi	r28, 0x00	; 0
    22f2:	d0 e0       	ldi	r29, 0x00	; 0
     number = -number;
  }

  // Round correctly so that print(1.999, 2) prints as "2.00"
  double rounding = 0.5;
  for (uint8_t i=0; i<digits; ++i)
    22f4:	b1 2c       	mov	r11, r1
     n += print('-');
     number = -number;
  }

  // Round correctly so that print(1.999, 2) prints as "2.00"
  double rounding = 0.5;
    22f6:	60 e0       	ldi	r22, 0x00	; 0
    22f8:	70 e0       	ldi	r23, 0x00	; 0
    22fa:	80 e0       	ldi	r24, 0x00	; 0
    22fc:	9f e3       	ldi	r25, 0x3F	; 63
  for (uint8_t i=0; i<digits; ++i)
    22fe:	7b 14       	cp	r7, r11
    2300:	41 f0       	breq	.+16     	; 0x2312 <_ZN5Print10printFloatEdh+0x102>
    rounding /= 10.0;
    2302:	20 e0       	ldi	r18, 0x00	; 0
    2304:	30 e0       	ldi	r19, 0x00	; 0
    2306:	40 e2       	ldi	r20, 0x20	; 32
    2308:	51 e4       	ldi	r21, 0x41	; 65
    230a:	0e 94 1a 0c 	call	0x1834	; 0x1834 <__divsf3>
     number = -number;
  }

  // Round correctly so that print(1.999, 2) prints as "2.00"
  double rounding = 0.5;
  for (uint8_t i=0; i<digits; ++i)
    230e:	b3 94       	inc	r11
    2310:	f6 cf       	rjmp	.-20     	; 0x22fe <_ZN5Print10printFloatEdh+0xee>
    rounding /= 10.0;
  
  number += rounding;
    2312:	a7 01       	movw	r20, r14
    2314:	96 01       	movw	r18, r12
    2316:	0e 94 a9 0b 	call	0x1752	; 0x1752 <__addsf3>
    231a:	6b 01       	movw	r12, r22
    231c:	7c 01       	movw	r14, r24

  // Extract the integer part of the number and print it
  unsigned long int_part = (unsigned long)number;
    231e:	0e 94 93 0c 	call	0x1926	; 0x1926 <__fixunssfsi>
    2322:	4b 01       	movw	r8, r22
    2324:	5c 01       	movw	r10, r24
}

size_t Print::print(unsigned long n, int base)
{
  if (base == 0) return write(n);
  else return printNumber(n, base);
    2326:	2a e0       	ldi	r18, 0x0A	; 10
    2328:	ab 01       	movw	r20, r22
    232a:	bc 01       	movw	r22, r24
    232c:	c8 01       	movw	r24, r16
    232e:	0e 94 32 10 	call	0x2064	; 0x2064 <_ZN5Print11printNumberEmh>
  number += rounding;

  // Extract the integer part of the number and print it
  unsigned long int_part = (unsigned long)number;
  double remainder = number - (double)int_part;
  n += print(int_part);
    2332:	c8 0f       	add	r28, r24
    2334:	d9 1f       	adc	r29, r25

  // Print the decimal point, but only if there are digits beyond
  if (digits > 0) {
    2336:	77 20       	and	r7, r7
    2338:	b9 f1       	breq	.+110    	; 0x23a8 <_ZN5Print10printFloatEdh+0x198>
  
  number += rounding;

  // Extract the integer part of the number and print it
  unsigned long int_part = (unsigned long)number;
  double remainder = number - (double)int_part;
    233a:	c5 01       	movw	r24, r10
    233c:	b4 01       	movw	r22, r8
    233e:	0e 94 c2 0c 	call	0x1984	; 0x1984 <__floatunsisf>
    2342:	9b 01       	movw	r18, r22
    2344:	ac 01       	movw	r20, r24
    2346:	c7 01       	movw	r24, r14
    2348:	b6 01       	movw	r22, r12
    234a:	0e 94 a8 0b 	call	0x1750	; 0x1750 <__subsf3>
    234e:	6b 01       	movw	r12, r22
    2350:	7c 01       	movw	r14, r24
  n += print(int_part);

  // Print the decimal point, but only if there are digits beyond
  if (digits > 0) {
    n += print('.'); 
    2352:	6e e2       	ldi	r22, 0x2E	; 46
    2354:	c8 01       	movw	r24, r16
    2356:	0e 94 15 10 	call	0x202a	; 0x202a <_ZN5Print5printEc>
    235a:	c8 0f       	add	r28, r24
    235c:	d9 1f       	adc	r29, r25
  }

  // Extract digits from the remainder one at a time
  while (digits-- > 0)
  {
    remainder *= 10.0;
    235e:	20 e0       	ldi	r18, 0x00	; 0
    2360:	30 e0       	ldi	r19, 0x00	; 0
    2362:	40 e2       	ldi	r20, 0x20	; 32
    2364:	51 e4       	ldi	r21, 0x41	; 65
    2366:	c7 01       	movw	r24, r14
    2368:	b6 01       	movw	r22, r12
    236a:	0e 94 79 0d 	call	0x1af2	; 0x1af2 <__mulsf3>
    236e:	4b 01       	movw	r8, r22
    2370:	5c 01       	movw	r10, r24
    unsigned int toPrint = (unsigned int)(remainder);
    2372:	0e 94 93 0c 	call	0x1926	; 0x1926 <__fixunssfsi>
    2376:	6b 01       	movw	r12, r22
    2378:	7c 01       	movw	r14, r24
    n += print(toPrint);
    237a:	4a e0       	ldi	r20, 0x0A	; 10
    237c:	50 e0       	ldi	r21, 0x00	; 0
    237e:	c8 01       	movw	r24, r16
    2380:	0e 94 a1 10 	call	0x2142	; 0x2142 <_ZN5Print5printEji>
    2384:	c8 0f       	add	r28, r24
    2386:	d9 1f       	adc	r29, r25
    remainder -= toPrint; 
    2388:	b6 01       	movw	r22, r12
    238a:	80 e0       	ldi	r24, 0x00	; 0
    238c:	90 e0       	ldi	r25, 0x00	; 0
    238e:	0e 94 c2 0c 	call	0x1984	; 0x1984 <__floatunsisf>
    2392:	9b 01       	movw	r18, r22
    2394:	ac 01       	movw	r20, r24
    2396:	c5 01       	movw	r24, r10
    2398:	b4 01       	movw	r22, r8
    239a:	0e 94 a8 0b 	call	0x1750	; 0x1750 <__subsf3>
    239e:	6b 01       	movw	r12, r22
    23a0:	7c 01       	movw	r14, r24
    23a2:	7a 94       	dec	r7
  if (digits > 0) {
    n += print('.'); 
  }

  // Extract digits from the remainder one at a time
  while (digits-- > 0)
    23a4:	71 10       	cpse	r7, r1
    23a6:	db cf       	rjmp	.-74     	; 0x235e <_ZN5Print10printFloatEdh+0x14e>
  number += rounding;

  // Extract the integer part of the number and print it
  unsigned long int_part = (unsigned long)number;
  double remainder = number - (double)int_part;
  n += print(int_part);
    23a8:	ce 01       	movw	r24, r28
    n += print(toPrint);
    remainder -= toPrint; 
  } 
  
  return n;
}
    23aa:	df 91       	pop	r29
    23ac:	cf 91       	pop	r28
    23ae:	1f 91       	pop	r17
    23b0:	0f 91       	pop	r16
    23b2:	ff 90       	pop	r15
    23b4:	ef 90       	pop	r14
    23b6:	df 90       	pop	r13
    23b8:	cf 90       	pop	r12
    23ba:	bf 90       	pop	r11
    23bc:	af 90       	pop	r10
    23be:	9f 90       	pop	r9
    23c0:	8f 90       	pop	r8
    23c2:	7f 90       	pop	r7
    23c4:	08 95       	ret

000023c6 <_ZN5Print5printEdi>:
  else return printNumber(n, base);
}

size_t Print::print(double n, int digits)
{
  return printFloat(n, digits);
    23c6:	0c 94 08 11 	jmp	0x2210	; 0x2210 <_ZN5Print10printFloatEdh>

000023ca <_ZN5Print7printlnEdi>:
  n += println();
  return n;
}

size_t Print::println(double num, int digits)
{
    23ca:	0f 93       	push	r16
    23cc:	1f 93       	push	r17
    23ce:	cf 93       	push	r28
    23d0:	df 93       	push	r29
    23d2:	ec 01       	movw	r28, r24
  else return printNumber(n, base);
}

size_t Print::print(double n, int digits)
{
  return printFloat(n, digits);
    23d4:	0e 94 08 11 	call	0x2210	; 0x2210 <_ZN5Print10printFloatEdh>
    23d8:	8c 01       	movw	r16, r24
}

size_t Print::println(double num, int digits)
{
  size_t n = print(num, digits);
  n += println();
    23da:	ce 01       	movw	r24, r28
    23dc:	0e 94 1c 10 	call	0x2038	; 0x2038 <_ZN5Print7printlnEv>
  return n;
}
    23e0:	80 0f       	add	r24, r16
    23e2:	91 1f       	adc	r25, r17
    23e4:	df 91       	pop	r29
    23e6:	cf 91       	pop	r28
    23e8:	1f 91       	pop	r17
    23ea:	0f 91       	pop	r16
    23ec:	08 95       	ret

000023ee <nothing>:
    #endif
      break;       
#endif
    }
      
    intFunc[interruptNum] = nothing;
    23ee:	08 95       	ret

000023f0 <attachInterrupt>:
    23f0:	82 30       	cpi	r24, 0x02	; 2
    23f2:	e8 f4       	brcc	.+58     	; 0x242e <attachInterrupt+0x3e>
    23f4:	e8 2f       	mov	r30, r24
    23f6:	f0 e0       	ldi	r31, 0x00	; 0
    23f8:	ee 0f       	add	r30, r30
    23fa:	ff 1f       	adc	r31, r31
    23fc:	ed 5c       	subi	r30, 0xCD	; 205
    23fe:	fe 4f       	sbci	r31, 0xFE	; 254
    2400:	71 83       	std	Z+1, r23	; 0x01
    2402:	60 83       	st	Z, r22
    2404:	81 30       	cpi	r24, 0x01	; 1
    2406:	41 f0       	breq	.+16     	; 0x2418 <attachInterrupt+0x28>
    2408:	80 91 69 00 	lds	r24, 0x0069	; 0x800069 <__DATA_REGION_ORIGIN__+0x9>
    240c:	8c 7f       	andi	r24, 0xFC	; 252
    240e:	48 2b       	or	r20, r24
    2410:	40 93 69 00 	sts	0x0069, r20	; 0x800069 <__DATA_REGION_ORIGIN__+0x9>
    2414:	e8 9a       	sbi	0x1d, 0	; 29
    2416:	08 95       	ret
    2418:	80 91 69 00 	lds	r24, 0x0069	; 0x800069 <__DATA_REGION_ORIGIN__+0x9>
    241c:	83 7f       	andi	r24, 0xF3	; 243
    241e:	44 0f       	add	r20, r20
    2420:	55 1f       	adc	r21, r21
    2422:	44 0f       	add	r20, r20
    2424:	55 1f       	adc	r21, r21
    2426:	48 2b       	or	r20, r24
    2428:	40 93 69 00 	sts	0x0069, r20	; 0x800069 <__DATA_REGION_ORIGIN__+0x9>
    242c:	e9 9a       	sbi	0x1d, 1	; 29
    242e:	08 95       	ret

00002430 <__vector_1>:
IMPLEMENT_ISR(INT6_vect, EXTERNAL_INT_6)
IMPLEMENT_ISR(INT7_vect, EXTERNAL_INT_7)

#else

IMPLEMENT_ISR(INT0_vect, EXTERNAL_INT_0)
    2430:	1f 92       	push	r1
    2432:	0f 92       	push	r0
    2434:	0f b6       	in	r0, 0x3f	; 63
    2436:	0f 92       	push	r0
    2438:	11 24       	eor	r1, r1
    243a:	2f 93       	push	r18
    243c:	3f 93       	push	r19
    243e:	4f 93       	push	r20
    2440:	5f 93       	push	r21
    2442:	6f 93       	push	r22
    2444:	7f 93       	push	r23
    2446:	8f 93       	push	r24
    2448:	9f 93       	push	r25
    244a:	af 93       	push	r26
    244c:	bf 93       	push	r27
    244e:	ef 93       	push	r30
    2450:	ff 93       	push	r31
    2452:	e0 91 33 01 	lds	r30, 0x0133	; 0x800133 <intFunc>
    2456:	f0 91 34 01 	lds	r31, 0x0134	; 0x800134 <intFunc+0x1>
    245a:	09 95       	icall
    245c:	ff 91       	pop	r31
    245e:	ef 91       	pop	r30
    2460:	bf 91       	pop	r27
    2462:	af 91       	pop	r26
    2464:	9f 91       	pop	r25
    2466:	8f 91       	pop	r24
    2468:	7f 91       	pop	r23
    246a:	6f 91       	pop	r22
    246c:	5f 91       	pop	r21
    246e:	4f 91       	pop	r20
    2470:	3f 91       	pop	r19
    2472:	2f 91       	pop	r18
    2474:	0f 90       	pop	r0
    2476:	0f be       	out	0x3f, r0	; 63
    2478:	0f 90       	pop	r0
    247a:	1f 90       	pop	r1
    247c:	18 95       	reti

0000247e <__vector_2>:
IMPLEMENT_ISR(INT1_vect, EXTERNAL_INT_1)
    247e:	1f 92       	push	r1
    2480:	0f 92       	push	r0
    2482:	0f b6       	in	r0, 0x3f	; 63
    2484:	0f 92       	push	r0
    2486:	11 24       	eor	r1, r1
    2488:	2f 93       	push	r18
    248a:	3f 93       	push	r19
    248c:	4f 93       	push	r20
    248e:	5f 93       	push	r21
    2490:	6f 93       	push	r22
    2492:	7f 93       	push	r23
    2494:	8f 93       	push	r24
    2496:	9f 93       	push	r25
    2498:	af 93       	push	r26
    249a:	bf 93       	push	r27
    249c:	ef 93       	push	r30
    249e:	ff 93       	push	r31
    24a0:	e0 91 35 01 	lds	r30, 0x0135	; 0x800135 <intFunc+0x2>
    24a4:	f0 91 36 01 	lds	r31, 0x0136	; 0x800136 <intFunc+0x3>
    24a8:	09 95       	icall
    24aa:	ff 91       	pop	r31
    24ac:	ef 91       	pop	r30
    24ae:	bf 91       	pop	r27
    24b0:	af 91       	pop	r26
    24b2:	9f 91       	pop	r25
    24b4:	8f 91       	pop	r24
    24b6:	7f 91       	pop	r23
    24b8:	6f 91       	pop	r22
    24ba:	5f 91       	pop	r21
    24bc:	4f 91       	pop	r20
    24be:	3f 91       	pop	r19
    24c0:	2f 91       	pop	r18
    24c2:	0f 90       	pop	r0
    24c4:	0f be       	out	0x3f, r0	; 63
    24c6:	0f 90       	pop	r0
    24c8:	1f 90       	pop	r1
    24ca:	18 95       	reti

000024cc <__vector_16>:
	cli();
	m = timer0_millis;
	SREG = oldSREG;

	return m;
}
    24cc:	1f 92       	push	r1
    24ce:	0f 92       	push	r0
    24d0:	0f b6       	in	r0, 0x3f	; 63
    24d2:	0f 92       	push	r0
    24d4:	11 24       	eor	r1, r1
    24d6:	2f 93       	push	r18
    24d8:	3f 93       	push	r19
    24da:	8f 93       	push	r24
    24dc:	9f 93       	push	r25
    24de:	af 93       	push	r26
    24e0:	bf 93       	push	r27
    24e2:	80 91 94 04 	lds	r24, 0x0494	; 0x800494 <timer0_millis>
    24e6:	90 91 95 04 	lds	r25, 0x0495	; 0x800495 <timer0_millis+0x1>
    24ea:	a0 91 96 04 	lds	r26, 0x0496	; 0x800496 <timer0_millis+0x2>
    24ee:	b0 91 97 04 	lds	r27, 0x0497	; 0x800497 <timer0_millis+0x3>
    24f2:	30 91 93 04 	lds	r19, 0x0493	; 0x800493 <timer0_fract>
    24f6:	23 e0       	ldi	r18, 0x03	; 3
    24f8:	23 0f       	add	r18, r19
    24fa:	2d 37       	cpi	r18, 0x7D	; 125
    24fc:	20 f4       	brcc	.+8      	; 0x2506 <__vector_16+0x3a>
    24fe:	01 96       	adiw	r24, 0x01	; 1
    2500:	a1 1d       	adc	r26, r1
    2502:	b1 1d       	adc	r27, r1
    2504:	05 c0       	rjmp	.+10     	; 0x2510 <__vector_16+0x44>
    2506:	26 e8       	ldi	r18, 0x86	; 134
    2508:	23 0f       	add	r18, r19
    250a:	02 96       	adiw	r24, 0x02	; 2
    250c:	a1 1d       	adc	r26, r1
    250e:	b1 1d       	adc	r27, r1
    2510:	20 93 93 04 	sts	0x0493, r18	; 0x800493 <timer0_fract>
    2514:	80 93 94 04 	sts	0x0494, r24	; 0x800494 <timer0_millis>
    2518:	90 93 95 04 	sts	0x0495, r25	; 0x800495 <timer0_millis+0x1>
    251c:	a0 93 96 04 	sts	0x0496, r26	; 0x800496 <timer0_millis+0x2>
    2520:	b0 93 97 04 	sts	0x0497, r27	; 0x800497 <timer0_millis+0x3>
    2524:	80 91 98 04 	lds	r24, 0x0498	; 0x800498 <timer0_overflow_count>
    2528:	90 91 99 04 	lds	r25, 0x0499	; 0x800499 <timer0_overflow_count+0x1>
    252c:	a0 91 9a 04 	lds	r26, 0x049A	; 0x80049a <timer0_overflow_count+0x2>
    2530:	b0 91 9b 04 	lds	r27, 0x049B	; 0x80049b <timer0_overflow_count+0x3>
    2534:	01 96       	adiw	r24, 0x01	; 1
    2536:	a1 1d       	adc	r26, r1
    2538:	b1 1d       	adc	r27, r1
    253a:	80 93 98 04 	sts	0x0498, r24	; 0x800498 <timer0_overflow_count>
    253e:	90 93 99 04 	sts	0x0499, r25	; 0x800499 <timer0_overflow_count+0x1>
    2542:	a0 93 9a 04 	sts	0x049A, r26	; 0x80049a <timer0_overflow_count+0x2>
    2546:	b0 93 9b 04 	sts	0x049B, r27	; 0x80049b <timer0_overflow_count+0x3>
    254a:	bf 91       	pop	r27
    254c:	af 91       	pop	r26
    254e:	9f 91       	pop	r25
    2550:	8f 91       	pop	r24
    2552:	3f 91       	pop	r19
    2554:	2f 91       	pop	r18
    2556:	0f 90       	pop	r0
    2558:	0f be       	out	0x3f, r0	; 63
    255a:	0f 90       	pop	r0
    255c:	1f 90       	pop	r1
    255e:	18 95       	reti

00002560 <micros>:

unsigned long micros() {
	unsigned long m;
	uint8_t oldSREG = SREG, t;
    2560:	3f b7       	in	r19, 0x3f	; 63
	
	cli();
    2562:	f8 94       	cli
	m = timer0_overflow_count;
    2564:	80 91 98 04 	lds	r24, 0x0498	; 0x800498 <timer0_overflow_count>
    2568:	90 91 99 04 	lds	r25, 0x0499	; 0x800499 <timer0_overflow_count+0x1>
    256c:	a0 91 9a 04 	lds	r26, 0x049A	; 0x80049a <timer0_overflow_count+0x2>
    2570:	b0 91 9b 04 	lds	r27, 0x049B	; 0x80049b <timer0_overflow_count+0x3>
#if defined(TCNT0)
	t = TCNT0;
    2574:	26 b5       	in	r18, 0x26	; 38
#else
	#error TIMER 0 not defined
#endif

#ifdef TIFR0
	if ((TIFR0 & _BV(TOV0)) && (t < 255))
    2576:	a8 9b       	sbis	0x15, 0	; 21
    2578:	05 c0       	rjmp	.+10     	; 0x2584 <micros+0x24>
    257a:	2f 3f       	cpi	r18, 0xFF	; 255
    257c:	19 f0       	breq	.+6      	; 0x2584 <micros+0x24>
		m++;
    257e:	01 96       	adiw	r24, 0x01	; 1
    2580:	a1 1d       	adc	r26, r1
    2582:	b1 1d       	adc	r27, r1
#else
	if ((TIFR & _BV(TOV0)) && (t < 255))
		m++;
#endif

	SREG = oldSREG;
    2584:	3f bf       	out	0x3f, r19	; 63
	
	return ((m << 8) + t) * (64 / clockCyclesPerMicrosecond());
    2586:	ba 2f       	mov	r27, r26
    2588:	a9 2f       	mov	r26, r25
    258a:	98 2f       	mov	r25, r24
    258c:	88 27       	eor	r24, r24
    258e:	82 0f       	add	r24, r18
    2590:	91 1d       	adc	r25, r1
    2592:	a1 1d       	adc	r26, r1
    2594:	b1 1d       	adc	r27, r1
    2596:	bc 01       	movw	r22, r24
    2598:	cd 01       	movw	r24, r26
    259a:	42 e0       	ldi	r20, 0x02	; 2
    259c:	66 0f       	add	r22, r22
    259e:	77 1f       	adc	r23, r23
    25a0:	88 1f       	adc	r24, r24
    25a2:	99 1f       	adc	r25, r25
    25a4:	4a 95       	dec	r20
    25a6:	d1 f7       	brne	.-12     	; 0x259c <micros+0x3c>
}
    25a8:	08 95       	ret

000025aa <delay>:

void delay(unsigned long ms)
{
    25aa:	8f 92       	push	r8
    25ac:	9f 92       	push	r9
    25ae:	af 92       	push	r10
    25b0:	bf 92       	push	r11
    25b2:	cf 92       	push	r12
    25b4:	df 92       	push	r13
    25b6:	ef 92       	push	r14
    25b8:	ff 92       	push	r15
    25ba:	6b 01       	movw	r12, r22
    25bc:	7c 01       	movw	r14, r24
	uint32_t start = micros();
    25be:	0e 94 b0 12 	call	0x2560	; 0x2560 <micros>
    25c2:	4b 01       	movw	r8, r22
    25c4:	5c 01       	movw	r10, r24

	while (ms > 0) {
    25c6:	c1 14       	cp	r12, r1
    25c8:	d1 04       	cpc	r13, r1
    25ca:	e1 04       	cpc	r14, r1
    25cc:	f1 04       	cpc	r15, r1
    25ce:	01 f1       	breq	.+64     	; 0x2610 <delay+0x66>
		yield();
    25d0:	0e 94 87 1c 	call	0x390e	; 0x390e <yield>
		while ( ms > 0 && (micros() - start) >= 1000) {
    25d4:	0e 94 b0 12 	call	0x2560	; 0x2560 <micros>
    25d8:	dc 01       	movw	r26, r24
    25da:	cb 01       	movw	r24, r22
    25dc:	88 19       	sub	r24, r8
    25de:	99 09       	sbc	r25, r9
    25e0:	aa 09       	sbc	r26, r10
    25e2:	bb 09       	sbc	r27, r11
    25e4:	88 3e       	cpi	r24, 0xE8	; 232
    25e6:	93 40       	sbci	r25, 0x03	; 3
    25e8:	a1 05       	cpc	r26, r1
    25ea:	b1 05       	cpc	r27, r1
    25ec:	60 f3       	brcs	.-40     	; 0x25c6 <delay+0x1c>
			ms--;
    25ee:	21 e0       	ldi	r18, 0x01	; 1
    25f0:	c2 1a       	sub	r12, r18
    25f2:	d1 08       	sbc	r13, r1
    25f4:	e1 08       	sbc	r14, r1
    25f6:	f1 08       	sbc	r15, r1
			start += 1000;
    25f8:	88 ee       	ldi	r24, 0xE8	; 232
    25fa:	88 0e       	add	r8, r24
    25fc:	83 e0       	ldi	r24, 0x03	; 3
    25fe:	98 1e       	adc	r9, r24
    2600:	a1 1c       	adc	r10, r1
    2602:	b1 1c       	adc	r11, r1
{
	uint32_t start = micros();

	while (ms > 0) {
		yield();
		while ( ms > 0 && (micros() - start) >= 1000) {
    2604:	c1 14       	cp	r12, r1
    2606:	d1 04       	cpc	r13, r1
    2608:	e1 04       	cpc	r14, r1
    260a:	f1 04       	cpc	r15, r1
    260c:	19 f7       	brne	.-58     	; 0x25d4 <delay+0x2a>
    260e:	db cf       	rjmp	.-74     	; 0x25c6 <delay+0x1c>
			ms--;
			start += 1000;
		}
	}
}
    2610:	ff 90       	pop	r15
    2612:	ef 90       	pop	r14
    2614:	df 90       	pop	r13
    2616:	cf 90       	pop	r12
    2618:	bf 90       	pop	r11
    261a:	af 90       	pop	r10
    261c:	9f 90       	pop	r9
    261e:	8f 90       	pop	r8
    2620:	08 95       	ret

00002622 <delayMicroseconds>:
#elif F_CPU >= 16000000L
	// for the 16 MHz clock on most Arduino boards

	// for a one-microsecond delay, simply return.  the overhead
	// of the function call takes 14 (16) cycles, which is 1us
	if (us <= 1) return; //  = 3 cycles, (4 when true)
    2622:	82 30       	cpi	r24, 0x02	; 2
    2624:	91 05       	cpc	r25, r1
    2626:	38 f0       	brcs	.+14     	; 0x2636 <delayMicroseconds+0x14>

	// the following loop takes 1/4 of a microsecond (4 cycles)
	// per iteration, so execute it four times for each microsecond of
	// delay requested.
	us <<= 2; // x4 us, = 4 cycles
    2628:	88 0f       	add	r24, r24
    262a:	99 1f       	adc	r25, r25
    262c:	88 0f       	add	r24, r24
    262e:	99 1f       	adc	r25, r25

	// account for the time taken in the preceeding commands.
	// we just burned 19 (21) cycles above, remove 5, (5*4=20)
	// us is at least 8 so we can substract 5
	us -= 5; // = 2 cycles,
    2630:	05 97       	sbiw	r24, 0x05	; 5
	

#endif

	// busy wait
	__asm__ __volatile__ (
    2632:	01 97       	sbiw	r24, 0x01	; 1
    2634:	f1 f7       	brne	.-4      	; 0x2632 <delayMicroseconds+0x10>
    2636:	08 95       	ret

00002638 <init>:

void init()
{
	// this needs to be called before setup() or some functions won't
	// work there
	sei();
    2638:	78 94       	sei
	
	// on the ATmega168, timer 0 is also used for fast hardware pwm
	// (using phase-correct PWM would mean that timer 0 overflowed half as often
	// resulting in different millis() behavior on the ATmega8 and ATmega168)
#if defined(TCCR0A) && defined(WGM01)
	sbi(TCCR0A, WGM01);
    263a:	84 b5       	in	r24, 0x24	; 36
    263c:	82 60       	ori	r24, 0x02	; 2
    263e:	84 bd       	out	0x24, r24	; 36
	sbi(TCCR0A, WGM00);
    2640:	84 b5       	in	r24, 0x24	; 36
    2642:	81 60       	ori	r24, 0x01	; 1
    2644:	84 bd       	out	0x24, r24	; 36
	// this combination is for the standard atmega8
	sbi(TCCR0, CS01);
	sbi(TCCR0, CS00);
#elif defined(TCCR0B) && defined(CS01) && defined(CS00)
	// this combination is for the standard 168/328/1280/2560
	sbi(TCCR0B, CS01);
    2646:	85 b5       	in	r24, 0x25	; 37
    2648:	82 60       	ori	r24, 0x02	; 2
    264a:	85 bd       	out	0x25, r24	; 37
	sbi(TCCR0B, CS00);
    264c:	85 b5       	in	r24, 0x25	; 37
    264e:	81 60       	ori	r24, 0x01	; 1
    2650:	85 bd       	out	0x25, r24	; 37

	// enable timer 0 overflow interrupt
#if defined(TIMSK) && defined(TOIE0)
	sbi(TIMSK, TOIE0);
#elif defined(TIMSK0) && defined(TOIE0)
	sbi(TIMSK0, TOIE0);
    2652:	ee e6       	ldi	r30, 0x6E	; 110
    2654:	f0 e0       	ldi	r31, 0x00	; 0
    2656:	80 81       	ld	r24, Z
    2658:	81 60       	ori	r24, 0x01	; 1
    265a:	80 83       	st	Z, r24
	// this is better for motors as it ensures an even waveform
	// note, however, that fast pwm mode can achieve a frequency of up
	// 8 MHz (with a 16 MHz clock) at 50% duty cycle

#if defined(TCCR1B) && defined(CS11) && defined(CS10)
	TCCR1B = 0;
    265c:	e1 e8       	ldi	r30, 0x81	; 129
    265e:	f0 e0       	ldi	r31, 0x00	; 0
    2660:	10 82       	st	Z, r1

	// set timer 1 prescale factor to 64
	sbi(TCCR1B, CS11);
    2662:	80 81       	ld	r24, Z
    2664:	82 60       	ori	r24, 0x02	; 2
    2666:	80 83       	st	Z, r24
#if F_CPU >= 8000000L
	sbi(TCCR1B, CS10);
    2668:	80 81       	ld	r24, Z
    266a:	81 60       	ori	r24, 0x01	; 1
    266c:	80 83       	st	Z, r24
	sbi(TCCR1, CS10);
#endif
#endif
	// put timer 1 in 8-bit phase correct pwm mode
#if defined(TCCR1A) && defined(WGM10)
	sbi(TCCR1A, WGM10);
    266e:	e0 e8       	ldi	r30, 0x80	; 128
    2670:	f0 e0       	ldi	r31, 0x00	; 0
    2672:	80 81       	ld	r24, Z
    2674:	81 60       	ori	r24, 0x01	; 1
    2676:	80 83       	st	Z, r24

	// set timer 2 prescale factor to 64
#if defined(TCCR2) && defined(CS22)
	sbi(TCCR2, CS22);
#elif defined(TCCR2B) && defined(CS22)
	sbi(TCCR2B, CS22);
    2678:	e1 eb       	ldi	r30, 0xB1	; 177
    267a:	f0 e0       	ldi	r31, 0x00	; 0
    267c:	80 81       	ld	r24, Z
    267e:	84 60       	ori	r24, 0x04	; 4
    2680:	80 83       	st	Z, r24

	// configure timer 2 for phase correct pwm (8-bit)
#if defined(TCCR2) && defined(WGM20)
	sbi(TCCR2, WGM20);
#elif defined(TCCR2A) && defined(WGM20)
	sbi(TCCR2A, WGM20);
    2682:	e0 eb       	ldi	r30, 0xB0	; 176
    2684:	f0 e0       	ldi	r31, 0x00	; 0
    2686:	80 81       	ld	r24, Z
    2688:	81 60       	ori	r24, 0x01	; 1
    268a:	80 83       	st	Z, r24
#endif

#if defined(ADCSRA)
	// set a2d prescaler so we are inside the desired 50-200 KHz range.
	#if F_CPU >= 16000000 // 16 MHz / 128 = 125 KHz
		sbi(ADCSRA, ADPS2);
    268c:	ea e7       	ldi	r30, 0x7A	; 122
    268e:	f0 e0       	ldi	r31, 0x00	; 0
    2690:	80 81       	ld	r24, Z
    2692:	84 60       	ori	r24, 0x04	; 4
    2694:	80 83       	st	Z, r24
		sbi(ADCSRA, ADPS1);
    2696:	80 81       	ld	r24, Z
    2698:	82 60       	ori	r24, 0x02	; 2
    269a:	80 83       	st	Z, r24
		sbi(ADCSRA, ADPS0);
    269c:	80 81       	ld	r24, Z
    269e:	81 60       	ori	r24, 0x01	; 1
    26a0:	80 83       	st	Z, r24
		cbi(ADCSRA, ADPS2);
		cbi(ADCSRA, ADPS1);
		sbi(ADCSRA, ADPS0);
	#endif
	// enable a2d conversions
	sbi(ADCSRA, ADEN);
    26a2:	80 81       	ld	r24, Z
    26a4:	80 68       	ori	r24, 0x80	; 128
    26a6:	80 83       	st	Z, r24
	// here so they can be used as normal digital i/o; they will be
	// reconnected in Serial.begin()
#if defined(UCSRB)
	UCSRB = 0;
#elif defined(UCSR0B)
	UCSR0B = 0;
    26a8:	10 92 c1 00 	sts	0x00C1, r1	; 0x8000c1 <__DATA_REGION_ORIGIN__+0x61>
    26ac:	08 95       	ret

000026ae <analogRead>:
#elif defined(__AVR_ATmega32U4__)
	if (pin >= 18) pin -= 18; // allow for channel or pin numbers
#elif defined(__AVR_ATmega1284__) || defined(__AVR_ATmega1284P__) || defined(__AVR_ATmega644__) || defined(__AVR_ATmega644A__) || defined(__AVR_ATmega644P__) || defined(__AVR_ATmega644PA__)
	if (pin >= 24) pin -= 24; // allow for channel or pin numbers
#else
	if (pin >= 14) pin -= 14; // allow for channel or pin numbers
    26ae:	8e 30       	cpi	r24, 0x0E	; 14
    26b0:	08 f0       	brcs	.+2      	; 0x26b4 <analogRead+0x6>
    26b2:	8e 50       	subi	r24, 0x0E	; 14
	// to 0 (the default).
#if defined(ADMUX)
#if defined(__AVR_ATtiny25__) || defined(__AVR_ATtiny45__) || defined(__AVR_ATtiny85__)
	ADMUX = (analog_reference << 4) | (pin & 0x07);
#else
	ADMUX = (analog_reference << 6) | (pin & 0x07);
    26b4:	20 91 37 01 	lds	r18, 0x0137	; 0x800137 <analog_reference>
    26b8:	90 e4       	ldi	r25, 0x40	; 64
    26ba:	29 9f       	mul	r18, r25
    26bc:	90 01       	movw	r18, r0
    26be:	11 24       	eor	r1, r1
    26c0:	87 70       	andi	r24, 0x07	; 7
    26c2:	82 2b       	or	r24, r18
    26c4:	80 93 7c 00 	sts	0x007C, r24	; 0x80007c <__DATA_REGION_ORIGIN__+0x1c>
	// without a delay, we seem to read from the wrong channel
	//delay(1);

#if defined(ADCSRA) && defined(ADCL)
	// start the conversion
	sbi(ADCSRA, ADSC);
    26c8:	80 91 7a 00 	lds	r24, 0x007A	; 0x80007a <__DATA_REGION_ORIGIN__+0x1a>
    26cc:	80 64       	ori	r24, 0x40	; 64
    26ce:	80 93 7a 00 	sts	0x007A, r24	; 0x80007a <__DATA_REGION_ORIGIN__+0x1a>

	// ADSC is cleared when the conversion finishes
	while (bit_is_set(ADCSRA, ADSC));
    26d2:	80 91 7a 00 	lds	r24, 0x007A	; 0x80007a <__DATA_REGION_ORIGIN__+0x1a>
    26d6:	86 fd       	sbrc	r24, 6
    26d8:	fc cf       	rjmp	.-8      	; 0x26d2 <analogRead+0x24>

	// we have to read ADCL first; doing so locks both ADCL
	// and ADCH until ADCH is read.  reading ADCL second would
	// cause the results of each conversion to be discarded,
	// as ADCL and ADCH would be locked when it completed.
	low  = ADCL;
    26da:	80 91 78 00 	lds	r24, 0x0078	; 0x800078 <__DATA_REGION_ORIGIN__+0x18>
	high = ADCH;
    26de:	20 91 79 00 	lds	r18, 0x0079	; 0x800079 <__DATA_REGION_ORIGIN__+0x19>
	low  = 0;
	high = 0;
#endif

	// combine the two bytes
	return (high << 8) | low;
    26e2:	90 e0       	ldi	r25, 0x00	; 0
}
    26e4:	92 2b       	or	r25, r18
    26e6:	08 95       	ret

000026e8 <analogWrite>:
// Right now, PWM output only works on the pins with
// hardware support.  These are defined in the appropriate
// pins_*.c file.  For the rest of the pins, we default
// to digital output.
void analogWrite(uint8_t pin, int val)
{
    26e8:	1f 93       	push	r17
    26ea:	cf 93       	push	r28
    26ec:	df 93       	push	r29
    26ee:	18 2f       	mov	r17, r24
    26f0:	eb 01       	movw	r28, r22
	// We need to make sure the PWM output is enabled for those pins
	// that support it, as we turn it off when digitally reading or
	// writing with them.  Also, make sure the pin is in output mode
	// for consistenty with Wiring, which doesn't require a pinMode
	// call for the analog output pins.
	pinMode(pin, OUTPUT);
    26f2:	61 e0       	ldi	r22, 0x01	; 1
    26f4:	0e 94 fc 13 	call	0x27f8	; 0x27f8 <pinMode>
	if (val == 0)
    26f8:	20 97       	sbiw	r28, 0x00	; 0
    26fa:	11 f4       	brne	.+4      	; 0x2700 <analogWrite+0x18>
	{
		digitalWrite(pin, LOW);
    26fc:	60 e0       	ldi	r22, 0x00	; 0
    26fe:	04 c0       	rjmp	.+8      	; 0x2708 <analogWrite+0x20>
	}
	else if (val == 255)
    2700:	cf 3f       	cpi	r28, 0xFF	; 255
    2702:	d1 05       	cpc	r29, r1
    2704:	39 f4       	brne	.+14     	; 0x2714 <analogWrite+0x2c>
	{
		digitalWrite(pin, HIGH);
    2706:	61 e0       	ldi	r22, 0x01	; 1
    2708:	81 2f       	mov	r24, r17
				} else {
					digitalWrite(pin, HIGH);
				}
		}
	}
}
    270a:	df 91       	pop	r29
    270c:	cf 91       	pop	r28
    270e:	1f 91       	pop	r17
	{
		digitalWrite(pin, LOW);
	}
	else if (val == 255)
	{
		digitalWrite(pin, HIGH);
    2710:	0c 94 38 14 	jmp	0x2870	; 0x2870 <digitalWrite>
	}
	else
	{
		switch(digitalPinToTimer(pin))
    2714:	e1 2f       	mov	r30, r17
    2716:	f0 e0       	ldi	r31, 0x00	; 0
    2718:	ee 54       	subi	r30, 0x4E	; 78
    271a:	ff 4f       	sbci	r31, 0xFF	; 255
    271c:	e4 91       	lpm	r30, Z
    271e:	e3 30       	cpi	r30, 0x03	; 3
    2720:	f9 f0       	breq	.+62     	; 0x2760 <analogWrite+0x78>
    2722:	48 f4       	brcc	.+18     	; 0x2736 <analogWrite+0x4e>
    2724:	e1 30       	cpi	r30, 0x01	; 1
    2726:	b9 f0       	breq	.+46     	; 0x2756 <analogWrite+0x6e>
    2728:	e2 30       	cpi	r30, 0x02	; 2
    272a:	a1 f5       	brne	.+104    	; 0x2794 <analogWrite+0xac>
			#endif

			#if defined(TCCR0A) && defined(COM0B1)
			case TIMER0B:
				// connect pwm to pin on timer 0, channel B
				sbi(TCCR0A, COM0B1);
    272c:	84 b5       	in	r24, 0x24	; 36
    272e:	80 62       	ori	r24, 0x20	; 32
    2730:	84 bd       	out	0x24, r24	; 36
				OCR0B = val; // set pwm duty
    2732:	c8 bd       	out	0x28, r28	; 40
				break;
    2734:	34 c0       	rjmp	.+104    	; 0x279e <analogWrite+0xb6>
	{
		digitalWrite(pin, HIGH);
	}
	else
	{
		switch(digitalPinToTimer(pin))
    2736:	e7 30       	cpi	r30, 0x07	; 7
    2738:	e9 f0       	breq	.+58     	; 0x2774 <analogWrite+0x8c>
    273a:	e8 30       	cpi	r30, 0x08	; 8
    273c:	19 f1       	breq	.+70     	; 0x2784 <analogWrite+0x9c>
    273e:	e4 30       	cpi	r30, 0x04	; 4
    2740:	49 f5       	brne	.+82     	; 0x2794 <analogWrite+0xac>
			#endif

			#if defined(TCCR1A) && defined(COM1B1)
			case TIMER1B:
				// connect pwm to pin on timer 1, channel B
				sbi(TCCR1A, COM1B1);
    2742:	80 91 80 00 	lds	r24, 0x0080	; 0x800080 <__DATA_REGION_ORIGIN__+0x20>
    2746:	80 62       	ori	r24, 0x20	; 32
    2748:	80 93 80 00 	sts	0x0080, r24	; 0x800080 <__DATA_REGION_ORIGIN__+0x20>
				OCR1B = val; // set pwm duty
    274c:	d0 93 8b 00 	sts	0x008B, r29	; 0x80008b <__DATA_REGION_ORIGIN__+0x2b>
    2750:	c0 93 8a 00 	sts	0x008A, r28	; 0x80008a <__DATA_REGION_ORIGIN__+0x2a>
				break;
    2754:	24 c0       	rjmp	.+72     	; 0x279e <analogWrite+0xb6>
			#endif

			#if defined(TCCR0A) && defined(COM0A1)
			case TIMER0A:
				// connect pwm to pin on timer 0, channel A
				sbi(TCCR0A, COM0A1);
    2756:	84 b5       	in	r24, 0x24	; 36
    2758:	80 68       	ori	r24, 0x80	; 128
    275a:	84 bd       	out	0x24, r24	; 36
				OCR0A = val; // set pwm duty
    275c:	c7 bd       	out	0x27, r28	; 39
				break;
    275e:	1f c0       	rjmp	.+62     	; 0x279e <analogWrite+0xb6>
			#endif

			#if defined(TCCR1A) && defined(COM1A1)
			case TIMER1A:
				// connect pwm to pin on timer 1, channel A
				sbi(TCCR1A, COM1A1);
    2760:	80 91 80 00 	lds	r24, 0x0080	; 0x800080 <__DATA_REGION_ORIGIN__+0x20>
    2764:	80 68       	ori	r24, 0x80	; 128
    2766:	80 93 80 00 	sts	0x0080, r24	; 0x800080 <__DATA_REGION_ORIGIN__+0x20>
				OCR1A = val; // set pwm duty
    276a:	d0 93 89 00 	sts	0x0089, r29	; 0x800089 <__DATA_REGION_ORIGIN__+0x29>
    276e:	c0 93 88 00 	sts	0x0088, r28	; 0x800088 <__DATA_REGION_ORIGIN__+0x28>
				break;
    2772:	15 c0       	rjmp	.+42     	; 0x279e <analogWrite+0xb6>
			#endif

			#if defined(TCCR2A) && defined(COM2A1)
			case TIMER2A:
				// connect pwm to pin on timer 2, channel A
				sbi(TCCR2A, COM2A1);
    2774:	80 91 b0 00 	lds	r24, 0x00B0	; 0x8000b0 <__DATA_REGION_ORIGIN__+0x50>
    2778:	80 68       	ori	r24, 0x80	; 128
    277a:	80 93 b0 00 	sts	0x00B0, r24	; 0x8000b0 <__DATA_REGION_ORIGIN__+0x50>
				OCR2A = val; // set pwm duty
    277e:	c0 93 b3 00 	sts	0x00B3, r28	; 0x8000b3 <__DATA_REGION_ORIGIN__+0x53>
				break;
    2782:	0d c0       	rjmp	.+26     	; 0x279e <analogWrite+0xb6>
			#endif

			#if defined(TCCR2A) && defined(COM2B1)
			case TIMER2B:
				// connect pwm to pin on timer 2, channel B
				sbi(TCCR2A, COM2B1);
    2784:	80 91 b0 00 	lds	r24, 0x00B0	; 0x8000b0 <__DATA_REGION_ORIGIN__+0x50>
    2788:	80 62       	ori	r24, 0x20	; 32
    278a:	80 93 b0 00 	sts	0x00B0, r24	; 0x8000b0 <__DATA_REGION_ORIGIN__+0x50>
				OCR2B = val; // set pwm duty
    278e:	c0 93 b4 00 	sts	0x00B4, r28	; 0x8000b4 <__DATA_REGION_ORIGIN__+0x54>
				break;
    2792:	05 c0       	rjmp	.+10     	; 0x279e <analogWrite+0xb6>
				break;
			#endif

			case NOT_ON_TIMER:
			default:
				if (val < 128) {
    2794:	c0 38       	cpi	r28, 0x80	; 128
    2796:	d1 05       	cpc	r29, r1
    2798:	0c f0       	brlt	.+2      	; 0x279c <analogWrite+0xb4>
    279a:	b5 cf       	rjmp	.-150    	; 0x2706 <analogWrite+0x1e>
    279c:	af cf       	rjmp	.-162    	; 0x26fc <analogWrite+0x14>
				} else {
					digitalWrite(pin, HIGH);
				}
		}
	}
}
    279e:	df 91       	pop	r29
    27a0:	cf 91       	pop	r28
    27a2:	1f 91       	pop	r17
    27a4:	08 95       	ret

000027a6 <turnOffPWM>:
//
//static inline void turnOffPWM(uint8_t timer) __attribute__ ((always_inline));
//static inline void turnOffPWM(uint8_t timer)
static void turnOffPWM(uint8_t timer)
{
	switch (timer)
    27a6:	83 30       	cpi	r24, 0x03	; 3
    27a8:	81 f0       	breq	.+32     	; 0x27ca <turnOffPWM+0x24>
    27aa:	28 f4       	brcc	.+10     	; 0x27b6 <turnOffPWM+0x10>
    27ac:	81 30       	cpi	r24, 0x01	; 1
    27ae:	99 f0       	breq	.+38     	; 0x27d6 <turnOffPWM+0x30>
    27b0:	82 30       	cpi	r24, 0x02	; 2
    27b2:	a1 f0       	breq	.+40     	; 0x27dc <turnOffPWM+0x36>
    27b4:	08 95       	ret
    27b6:	87 30       	cpi	r24, 0x07	; 7
    27b8:	a9 f0       	breq	.+42     	; 0x27e4 <turnOffPWM+0x3e>
    27ba:	88 30       	cpi	r24, 0x08	; 8
    27bc:	b9 f0       	breq	.+46     	; 0x27ec <turnOffPWM+0x46>
    27be:	84 30       	cpi	r24, 0x04	; 4
    27c0:	d1 f4       	brne	.+52     	; 0x27f6 <turnOffPWM+0x50>
	{
		#if defined(TCCR1A) && defined(COM1A1)
		case TIMER1A:   cbi(TCCR1A, COM1A1);    break;
		#endif
		#if defined(TCCR1A) && defined(COM1B1)
		case TIMER1B:   cbi(TCCR1A, COM1B1);    break;
    27c2:	80 91 80 00 	lds	r24, 0x0080	; 0x800080 <__DATA_REGION_ORIGIN__+0x20>
    27c6:	8f 7d       	andi	r24, 0xDF	; 223
    27c8:	03 c0       	rjmp	.+6      	; 0x27d0 <turnOffPWM+0x2a>
static void turnOffPWM(uint8_t timer)
{
	switch (timer)
	{
		#if defined(TCCR1A) && defined(COM1A1)
		case TIMER1A:   cbi(TCCR1A, COM1A1);    break;
    27ca:	80 91 80 00 	lds	r24, 0x0080	; 0x800080 <__DATA_REGION_ORIGIN__+0x20>
    27ce:	8f 77       	andi	r24, 0x7F	; 127
		#endif
		#if defined(TCCR1A) && defined(COM1B1)
		case TIMER1B:   cbi(TCCR1A, COM1B1);    break;
    27d0:	80 93 80 00 	sts	0x0080, r24	; 0x800080 <__DATA_REGION_ORIGIN__+0x20>
    27d4:	08 95       	ret
		#if defined(TCCR2) && defined(COM21)
		case  TIMER2:   cbi(TCCR2, COM21);      break;
		#endif
		
		#if defined(TCCR0A) && defined(COM0A1)
		case  TIMER0A:  cbi(TCCR0A, COM0A1);    break;
    27d6:	84 b5       	in	r24, 0x24	; 36
    27d8:	8f 77       	andi	r24, 0x7F	; 127
    27da:	02 c0       	rjmp	.+4      	; 0x27e0 <turnOffPWM+0x3a>
		#endif
		
		#if defined(TCCR0A) && defined(COM0B1)
		case  TIMER0B:  cbi(TCCR0A, COM0B1);    break;
    27dc:	84 b5       	in	r24, 0x24	; 36
    27de:	8f 7d       	andi	r24, 0xDF	; 223
    27e0:	84 bd       	out	0x24, r24	; 36
    27e2:	08 95       	ret
		#endif
		#if defined(TCCR2A) && defined(COM2A1)
		case  TIMER2A:  cbi(TCCR2A, COM2A1);    break;
    27e4:	80 91 b0 00 	lds	r24, 0x00B0	; 0x8000b0 <__DATA_REGION_ORIGIN__+0x50>
    27e8:	8f 77       	andi	r24, 0x7F	; 127
    27ea:	03 c0       	rjmp	.+6      	; 0x27f2 <turnOffPWM+0x4c>
		#endif
		#if defined(TCCR2A) && defined(COM2B1)
		case  TIMER2B:  cbi(TCCR2A, COM2B1);    break;
    27ec:	80 91 b0 00 	lds	r24, 0x00B0	; 0x8000b0 <__DATA_REGION_ORIGIN__+0x50>
    27f0:	8f 7d       	andi	r24, 0xDF	; 223
    27f2:	80 93 b0 00 	sts	0x00B0, r24	; 0x8000b0 <__DATA_REGION_ORIGIN__+0x50>
    27f6:	08 95       	ret

000027f8 <pinMode>:
#define ARDUINO_MAIN
#include "wiring_private.h"
#include "pins_arduino.h"

void pinMode(uint8_t pin, uint8_t mode)
{
    27f8:	cf 93       	push	r28
    27fa:	df 93       	push	r29
	uint8_t bit = digitalPinToBitMask(pin);
    27fc:	90 e0       	ldi	r25, 0x00	; 0
    27fe:	fc 01       	movw	r30, r24
    2800:	ea 53       	subi	r30, 0x3A	; 58
    2802:	ff 4f       	sbci	r31, 0xFF	; 255
    2804:	24 91       	lpm	r18, Z
	uint8_t port = digitalPinToPort(pin);
    2806:	fc 01       	movw	r30, r24
    2808:	e6 52       	subi	r30, 0x26	; 38
    280a:	ff 4f       	sbci	r31, 0xFF	; 255
    280c:	84 91       	lpm	r24, Z
	volatile uint8_t *reg, *out;

	if (port == NOT_A_PIN) return;
    280e:	88 23       	and	r24, r24
    2810:	61 f1       	breq	.+88     	; 0x286a <pinMode+0x72>

	// JWS: can I let the optimizer do this?
	reg = portModeRegister(port);
    2812:	90 e0       	ldi	r25, 0x00	; 0
    2814:	88 0f       	add	r24, r24
    2816:	99 1f       	adc	r25, r25
    2818:	fc 01       	movw	r30, r24
    281a:	ee 5f       	subi	r30, 0xFE	; 254
    281c:	fe 4f       	sbci	r31, 0xFE	; 254
    281e:	c5 91       	lpm	r28, Z+
    2820:	d4 91       	lpm	r29, Z
	out = portOutputRegister(port);
    2822:	fc 01       	movw	r30, r24
    2824:	e8 50       	subi	r30, 0x08	; 8
    2826:	ff 4f       	sbci	r31, 0xFF	; 255
    2828:	a5 91       	lpm	r26, Z+
    282a:	b4 91       	lpm	r27, Z

	if (mode == INPUT) { 
    282c:	61 11       	cpse	r22, r1
    282e:	09 c0       	rjmp	.+18     	; 0x2842 <pinMode+0x4a>
		uint8_t oldSREG = SREG;
    2830:	9f b7       	in	r25, 0x3f	; 63
                cli();
    2832:	f8 94       	cli
		*reg &= ~bit;
    2834:	88 81       	ld	r24, Y
    2836:	20 95       	com	r18
    2838:	82 23       	and	r24, r18
    283a:	88 83       	st	Y, r24
		*out &= ~bit;
    283c:	ec 91       	ld	r30, X
    283e:	2e 23       	and	r18, r30
    2840:	0b c0       	rjmp	.+22     	; 0x2858 <pinMode+0x60>
		SREG = oldSREG;
	} else if (mode == INPUT_PULLUP) {
    2842:	62 30       	cpi	r22, 0x02	; 2
    2844:	61 f4       	brne	.+24     	; 0x285e <pinMode+0x66>
		uint8_t oldSREG = SREG;
    2846:	9f b7       	in	r25, 0x3f	; 63
                cli();
    2848:	f8 94       	cli
		*reg &= ~bit;
    284a:	88 81       	ld	r24, Y
    284c:	32 2f       	mov	r19, r18
    284e:	30 95       	com	r19
    2850:	83 23       	and	r24, r19
    2852:	88 83       	st	Y, r24
		*out |= bit;
    2854:	ec 91       	ld	r30, X
    2856:	2e 2b       	or	r18, r30
    2858:	2c 93       	st	X, r18
		SREG = oldSREG;
    285a:	9f bf       	out	0x3f, r25	; 63
    285c:	06 c0       	rjmp	.+12     	; 0x286a <pinMode+0x72>
	} else {
		uint8_t oldSREG = SREG;
    285e:	8f b7       	in	r24, 0x3f	; 63
                cli();
    2860:	f8 94       	cli
		*reg |= bit;
    2862:	e8 81       	ld	r30, Y
    2864:	2e 2b       	or	r18, r30
    2866:	28 83       	st	Y, r18
		SREG = oldSREG;
    2868:	8f bf       	out	0x3f, r24	; 63
	}
}
    286a:	df 91       	pop	r29
    286c:	cf 91       	pop	r28
    286e:	08 95       	ret

00002870 <digitalWrite>:
		#endif
	}
}

void digitalWrite(uint8_t pin, uint8_t val)
{
    2870:	1f 93       	push	r17
    2872:	cf 93       	push	r28
    2874:	df 93       	push	r29
	uint8_t timer = digitalPinToTimer(pin);
    2876:	28 2f       	mov	r18, r24
    2878:	30 e0       	ldi	r19, 0x00	; 0
    287a:	f9 01       	movw	r30, r18
    287c:	ee 54       	subi	r30, 0x4E	; 78
    287e:	ff 4f       	sbci	r31, 0xFF	; 255
    2880:	84 91       	lpm	r24, Z
	uint8_t bit = digitalPinToBitMask(pin);
    2882:	f9 01       	movw	r30, r18
    2884:	ea 53       	subi	r30, 0x3A	; 58
    2886:	ff 4f       	sbci	r31, 0xFF	; 255
    2888:	d4 91       	lpm	r29, Z
	uint8_t port = digitalPinToPort(pin);
    288a:	f9 01       	movw	r30, r18
    288c:	e6 52       	subi	r30, 0x26	; 38
    288e:	ff 4f       	sbci	r31, 0xFF	; 255
    2890:	c4 91       	lpm	r28, Z
	volatile uint8_t *out;

	if (port == NOT_A_PIN) return;
    2892:	cc 23       	and	r28, r28
    2894:	c1 f0       	breq	.+48     	; 0x28c6 <digitalWrite+0x56>
    2896:	16 2f       	mov	r17, r22

	// If the pin that support PWM output, we need to turn it off
	// before doing a digital write.
	if (timer != NOT_ON_TIMER) turnOffPWM(timer);
    2898:	81 11       	cpse	r24, r1
    289a:	0e 94 d3 13 	call	0x27a6	; 0x27a6 <turnOffPWM>

	out = portOutputRegister(port);
    289e:	ec 2f       	mov	r30, r28
    28a0:	f0 e0       	ldi	r31, 0x00	; 0
    28a2:	ee 0f       	add	r30, r30
    28a4:	ff 1f       	adc	r31, r31
    28a6:	e8 50       	subi	r30, 0x08	; 8
    28a8:	ff 4f       	sbci	r31, 0xFF	; 255
    28aa:	a5 91       	lpm	r26, Z+
    28ac:	b4 91       	lpm	r27, Z

	uint8_t oldSREG = SREG;
    28ae:	9f b7       	in	r25, 0x3f	; 63
	cli();
    28b0:	f8 94       	cli

	if (val == LOW) {
    28b2:	11 11       	cpse	r17, r1
    28b4:	04 c0       	rjmp	.+8      	; 0x28be <digitalWrite+0x4e>
		*out &= ~bit;
    28b6:	8c 91       	ld	r24, X
    28b8:	d0 95       	com	r29
    28ba:	d8 23       	and	r29, r24
    28bc:	02 c0       	rjmp	.+4      	; 0x28c2 <digitalWrite+0x52>
	} else {
		*out |= bit;
    28be:	ec 91       	ld	r30, X
    28c0:	de 2b       	or	r29, r30
    28c2:	dc 93       	st	X, r29
	}

	SREG = oldSREG;
    28c4:	9f bf       	out	0x3f, r25	; 63
}
    28c6:	df 91       	pop	r29
    28c8:	cf 91       	pop	r28
    28ca:	1f 91       	pop	r17
    28cc:	08 95       	ret

000028ce <prvResetNextTaskUnblockTime>:
        {
            mtCOVERAGE_TEST_MARKER();
        }

        return xReturn;
    }
    28ce:	e0 91 c8 04 	lds	r30, 0x04C8	; 0x8004c8 <pxDelayedTaskList>
    28d2:	f0 91 c9 04 	lds	r31, 0x04C9	; 0x8004c9 <pxDelayedTaskList+0x1>
    28d6:	80 81       	ld	r24, Z
    28d8:	81 11       	cpse	r24, r1
    28da:	03 c0       	rjmp	.+6      	; 0x28e2 <prvResetNextTaskUnblockTime+0x14>
    28dc:	8f ef       	ldi	r24, 0xFF	; 255
    28de:	9f ef       	ldi	r25, 0xFF	; 255
    28e0:	0c c0       	rjmp	.+24     	; 0x28fa <prvResetNextTaskUnblockTime+0x2c>
    28e2:	e0 91 c8 04 	lds	r30, 0x04C8	; 0x8004c8 <pxDelayedTaskList>
    28e6:	f0 91 c9 04 	lds	r31, 0x04C9	; 0x8004c9 <pxDelayedTaskList+0x1>
    28ea:	05 80       	ldd	r0, Z+5	; 0x05
    28ec:	f6 81       	ldd	r31, Z+6	; 0x06
    28ee:	e0 2d       	mov	r30, r0
    28f0:	06 80       	ldd	r0, Z+6	; 0x06
    28f2:	f7 81       	ldd	r31, Z+7	; 0x07
    28f4:	e0 2d       	mov	r30, r0
    28f6:	82 81       	ldd	r24, Z+2	; 0x02
    28f8:	93 81       	ldd	r25, Z+3	; 0x03
    28fa:	90 93 a0 04 	sts	0x04A0, r25	; 0x8004a0 <xNextTaskUnblockTime+0x1>
    28fe:	80 93 9f 04 	sts	0x049F, r24	; 0x80049f <xNextTaskUnblockTime>
    2902:	08 95       	ret

00002904 <prvAddCurrentTaskToDelayedList>:
    2904:	ff 92       	push	r15
    2906:	0f 93       	push	r16
    2908:	1f 93       	push	r17
    290a:	cf 93       	push	r28
    290c:	df 93       	push	r29
    290e:	ec 01       	movw	r28, r24
    2910:	f6 2e       	mov	r15, r22
    2912:	00 91 a7 04 	lds	r16, 0x04A7	; 0x8004a7 <xTickCount>
    2916:	10 91 a8 04 	lds	r17, 0x04A8	; 0x8004a8 <xTickCount+0x1>
    291a:	80 91 00 05 	lds	r24, 0x0500	; 0x800500 <pxCurrentTCB>
    291e:	90 91 01 05 	lds	r25, 0x0501	; 0x800501 <pxCurrentTCB+0x1>
    2922:	02 96       	adiw	r24, 0x02	; 2
    2924:	0e 94 17 1d 	call	0x3a2e	; 0x3a2e <uxListRemove>
    2928:	cf 3f       	cpi	r28, 0xFF	; 255
    292a:	8f ef       	ldi	r24, 0xFF	; 255
    292c:	d8 07       	cpc	r29, r24
    292e:	89 f4       	brne	.+34     	; 0x2952 <prvAddCurrentTaskToDelayedList+0x4e>
    2930:	ff 20       	and	r15, r15
    2932:	79 f0       	breq	.+30     	; 0x2952 <prvAddCurrentTaskToDelayedList+0x4e>
    2934:	60 91 00 05 	lds	r22, 0x0500	; 0x800500 <pxCurrentTCB>
    2938:	70 91 01 05 	lds	r23, 0x0501	; 0x800501 <pxCurrentTCB+0x1>
    293c:	6e 5f       	subi	r22, 0xFE	; 254
    293e:	7f 4f       	sbci	r23, 0xFF	; 255
    2940:	8a ea       	ldi	r24, 0xAA	; 170
    2942:	94 e0       	ldi	r25, 0x04	; 4
    2944:	df 91       	pop	r29
    2946:	cf 91       	pop	r28
    2948:	1f 91       	pop	r17
    294a:	0f 91       	pop	r16
    294c:	ff 90       	pop	r15
    294e:	0c 94 be 1c 	jmp	0x397c	; 0x397c <vListInsertEnd>
    2952:	c0 0f       	add	r28, r16
    2954:	d1 1f       	adc	r29, r17
    2956:	e0 91 00 05 	lds	r30, 0x0500	; 0x800500 <pxCurrentTCB>
    295a:	f0 91 01 05 	lds	r31, 0x0501	; 0x800501 <pxCurrentTCB+0x1>
    295e:	d3 83       	std	Z+3, r29	; 0x03
    2960:	c2 83       	std	Z+2, r28	; 0x02
    2962:	60 91 00 05 	lds	r22, 0x0500	; 0x800500 <pxCurrentTCB>
    2966:	70 91 01 05 	lds	r23, 0x0501	; 0x800501 <pxCurrentTCB+0x1>
    296a:	c0 17       	cp	r28, r16
    296c:	d1 07       	cpc	r29, r17
    296e:	68 f4       	brcc	.+26     	; 0x298a <prvAddCurrentTaskToDelayedList+0x86>
    2970:	80 91 c6 04 	lds	r24, 0x04C6	; 0x8004c6 <pxOverflowDelayedTaskList>
    2974:	90 91 c7 04 	lds	r25, 0x04C7	; 0x8004c7 <pxOverflowDelayedTaskList+0x1>
    2978:	6e 5f       	subi	r22, 0xFE	; 254
    297a:	7f 4f       	sbci	r23, 0xFF	; 255
    297c:	df 91       	pop	r29
    297e:	cf 91       	pop	r28
    2980:	1f 91       	pop	r17
    2982:	0f 91       	pop	r16
    2984:	ff 90       	pop	r15
    2986:	0c 94 df 1c 	jmp	0x39be	; 0x39be <vListInsert>
    298a:	80 91 c8 04 	lds	r24, 0x04C8	; 0x8004c8 <pxDelayedTaskList>
    298e:	90 91 c9 04 	lds	r25, 0x04C9	; 0x8004c9 <pxDelayedTaskList+0x1>
    2992:	6e 5f       	subi	r22, 0xFE	; 254
    2994:	7f 4f       	sbci	r23, 0xFF	; 255
    2996:	0e 94 df 1c 	call	0x39be	; 0x39be <vListInsert>
    299a:	80 91 9f 04 	lds	r24, 0x049F	; 0x80049f <xNextTaskUnblockTime>
    299e:	90 91 a0 04 	lds	r25, 0x04A0	; 0x8004a0 <xNextTaskUnblockTime+0x1>
    29a2:	c8 17       	cp	r28, r24
    29a4:	d9 07       	cpc	r29, r25
    29a6:	20 f4       	brcc	.+8      	; 0x29b0 <prvAddCurrentTaskToDelayedList+0xac>
    29a8:	d0 93 a0 04 	sts	0x04A0, r29	; 0x8004a0 <xNextTaskUnblockTime+0x1>
    29ac:	c0 93 9f 04 	sts	0x049F, r28	; 0x80049f <xNextTaskUnblockTime>
    29b0:	df 91       	pop	r29
    29b2:	cf 91       	pop	r28
    29b4:	1f 91       	pop	r17
    29b6:	0f 91       	pop	r16
    29b8:	ff 90       	pop	r15
    29ba:	08 95       	ret

000029bc <prvIdleTask>:
    29bc:	80 91 b3 04 	lds	r24, 0x04B3	; 0x8004b3 <uxDeletedTasksWaitingCleanUp>
    29c0:	88 23       	and	r24, r24
    29c2:	09 f1       	breq	.+66     	; 0x2a06 <prvIdleTask+0x4a>
    29c4:	0f b6       	in	r0, 0x3f	; 63
    29c6:	f8 94       	cli
    29c8:	0f 92       	push	r0
    29ca:	e0 91 b9 04 	lds	r30, 0x04B9	; 0x8004b9 <xTasksWaitingTermination+0x5>
    29ce:	f0 91 ba 04 	lds	r31, 0x04BA	; 0x8004ba <xTasksWaitingTermination+0x6>
    29d2:	c6 81       	ldd	r28, Z+6	; 0x06
    29d4:	d7 81       	ldd	r29, Z+7	; 0x07
    29d6:	ce 01       	movw	r24, r28
    29d8:	02 96       	adiw	r24, 0x02	; 2
    29da:	0e 94 17 1d 	call	0x3a2e	; 0x3a2e <uxListRemove>
    29de:	80 91 a9 04 	lds	r24, 0x04A9	; 0x8004a9 <uxCurrentNumberOfTasks>
    29e2:	81 50       	subi	r24, 0x01	; 1
    29e4:	80 93 a9 04 	sts	0x04A9, r24	; 0x8004a9 <uxCurrentNumberOfTasks>
    29e8:	80 91 b3 04 	lds	r24, 0x04B3	; 0x8004b3 <uxDeletedTasksWaitingCleanUp>
    29ec:	81 50       	subi	r24, 0x01	; 1
    29ee:	80 93 b3 04 	sts	0x04B3, r24	; 0x8004b3 <uxDeletedTasksWaitingCleanUp>
    29f2:	0f 90       	pop	r0
    29f4:	0f be       	out	0x3f, r0	; 63
    29f6:	8f 89       	ldd	r24, Y+23	; 0x17
    29f8:	98 8d       	ldd	r25, Y+24	; 0x18
    29fa:	0e 94 9b 1c 	call	0x3936	; 0x3936 <vPortFree>
    29fe:	ce 01       	movw	r24, r28
    2a00:	0e 94 9b 1c 	call	0x3936	; 0x3936 <vPortFree>
    2a04:	db cf       	rjmp	.-74     	; 0x29bc <prvIdleTask>
    2a06:	80 91 dc 04 	lds	r24, 0x04DC	; 0x8004dc <pxReadyTasksLists>
    2a0a:	82 30       	cpi	r24, 0x02	; 2
    2a0c:	10 f0       	brcs	.+4      	; 0x2a12 <prvIdleTask+0x56>
    2a0e:	0e 94 df 1d 	call	0x3bbe	; 0x3bbe <vPortYield>
    2a12:	0e 94 4e 1b 	call	0x369c	; 0x369c <vApplicationIdleHook>
    2a16:	d2 cf       	rjmp	.-92     	; 0x29bc <prvIdleTask>

00002a18 <xTaskCreate>:
    2a18:	5f 92       	push	r5
    2a1a:	6f 92       	push	r6
    2a1c:	7f 92       	push	r7
    2a1e:	8f 92       	push	r8
    2a20:	9f 92       	push	r9
    2a22:	af 92       	push	r10
    2a24:	bf 92       	push	r11
    2a26:	cf 92       	push	r12
    2a28:	df 92       	push	r13
    2a2a:	ef 92       	push	r14
    2a2c:	ff 92       	push	r15
    2a2e:	0f 93       	push	r16
    2a30:	1f 93       	push	r17
    2a32:	cf 93       	push	r28
    2a34:	df 93       	push	r29
    2a36:	3c 01       	movw	r6, r24
    2a38:	6b 01       	movw	r12, r22
    2a3a:	5a 01       	movw	r10, r20
    2a3c:	49 01       	movw	r8, r18
    2a3e:	50 2e       	mov	r5, r16
    2a40:	ca 01       	movw	r24, r20
    2a42:	0e 94 88 1c 	call	0x3910	; 0x3910 <pvPortMalloc>
    2a46:	8c 01       	movw	r16, r24
    2a48:	89 2b       	or	r24, r25
    2a4a:	09 f4       	brne	.+2      	; 0x2a4e <xTaskCreate+0x36>
    2a4c:	e0 c0       	rjmp	.+448    	; 0x2c0e <xTaskCreate+0x1f6>
    2a4e:	88 e2       	ldi	r24, 0x28	; 40
    2a50:	90 e0       	ldi	r25, 0x00	; 0
    2a52:	0e 94 88 1c 	call	0x3910	; 0x3910 <pvPortMalloc>
    2a56:	ec 01       	movw	r28, r24
    2a58:	89 2b       	or	r24, r25
    2a5a:	c9 f0       	breq	.+50     	; 0x2a8e <xTaskCreate+0x76>
    2a5c:	18 8f       	std	Y+24, r17	; 0x18
    2a5e:	0f 8b       	std	Y+23, r16	; 0x17
    2a60:	a5 01       	movw	r20, r10
    2a62:	65 ea       	ldi	r22, 0xA5	; 165
    2a64:	70 e0       	ldi	r23, 0x00	; 0
    2a66:	c8 01       	movw	r24, r16
    2a68:	0e 94 e0 22 	call	0x45c0	; 0x45c0 <memset>
    2a6c:	21 e0       	ldi	r18, 0x01	; 1
    2a6e:	a2 1a       	sub	r10, r18
    2a70:	b1 08       	sbc	r11, r1
    2a72:	8f 89       	ldd	r24, Y+23	; 0x17
    2a74:	98 8d       	ldd	r25, Y+24	; 0x18
    2a76:	a8 0e       	add	r10, r24
    2a78:	b9 1e       	adc	r11, r25
    2a7a:	c1 14       	cp	r12, r1
    2a7c:	d1 04       	cpc	r13, r1
    2a7e:	c9 f0       	breq	.+50     	; 0x2ab2 <xTaskCreate+0x9a>
    2a80:	be 01       	movw	r22, r28
    2a82:	67 5e       	subi	r22, 0xE7	; 231
    2a84:	7f 4f       	sbci	r23, 0xFF	; 255
    2a86:	f6 01       	movw	r30, r12
    2a88:	c6 01       	movw	r24, r12
    2a8a:	08 96       	adiw	r24, 0x08	; 8
    2a8c:	07 c0       	rjmp	.+14     	; 0x2a9c <xTaskCreate+0x84>
    2a8e:	c8 01       	movw	r24, r16
    2a90:	0e 94 9b 1c 	call	0x3936	; 0x3936 <vPortFree>
    2a94:	bc c0       	rjmp	.+376    	; 0x2c0e <xTaskCreate+0x1f6>
    2a96:	e8 17       	cp	r30, r24
    2a98:	f9 07       	cpc	r31, r25
    2a9a:	49 f0       	breq	.+18     	; 0x2aae <xTaskCreate+0x96>
    2a9c:	9f 01       	movw	r18, r30
    2a9e:	41 91       	ld	r20, Z+
    2aa0:	db 01       	movw	r26, r22
    2aa2:	4d 93       	st	X+, r20
    2aa4:	bd 01       	movw	r22, r26
    2aa6:	d9 01       	movw	r26, r18
    2aa8:	2c 91       	ld	r18, X
    2aaa:	21 11       	cpse	r18, r1
    2aac:	f4 cf       	rjmp	.-24     	; 0x2a96 <xTaskCreate+0x7e>
    2aae:	18 a2       	std	Y+32, r1	; 0x20
    2ab0:	01 c0       	rjmp	.+2      	; 0x2ab4 <xTaskCreate+0x9c>
    2ab2:	19 8e       	std	Y+25, r1	; 0x19
    2ab4:	05 2d       	mov	r16, r5
    2ab6:	04 30       	cpi	r16, 0x04	; 4
    2ab8:	08 f0       	brcs	.+2      	; 0x2abc <xTaskCreate+0xa4>
    2aba:	03 e0       	ldi	r16, 0x03	; 3
    2abc:	0e 8b       	std	Y+22, r16	; 0x16
    2abe:	09 a3       	std	Y+33, r16	; 0x21
    2ac0:	1a a2       	std	Y+34, r1	; 0x22
    2ac2:	6e 01       	movw	r12, r28
    2ac4:	b2 e0       	ldi	r27, 0x02	; 2
    2ac6:	cb 0e       	add	r12, r27
    2ac8:	d1 1c       	adc	r13, r1
    2aca:	c6 01       	movw	r24, r12
    2acc:	0e 94 ba 1c 	call	0x3974	; 0x3974 <vListInitialiseItem>
    2ad0:	ce 01       	movw	r24, r28
    2ad2:	0c 96       	adiw	r24, 0x0c	; 12
    2ad4:	0e 94 ba 1c 	call	0x3974	; 0x3974 <vListInitialiseItem>
    2ad8:	d9 87       	std	Y+9, r29	; 0x09
    2ada:	c8 87       	std	Y+8, r28	; 0x08
    2adc:	84 e0       	ldi	r24, 0x04	; 4
    2ade:	90 e0       	ldi	r25, 0x00	; 0
    2ae0:	80 1b       	sub	r24, r16
    2ae2:	91 09       	sbc	r25, r1
    2ae4:	9d 87       	std	Y+13, r25	; 0x0d
    2ae6:	8c 87       	std	Y+12, r24	; 0x0c
    2ae8:	db 8b       	std	Y+19, r29	; 0x13
    2aea:	ca 8b       	std	Y+18, r28	; 0x12
    2aec:	1b a2       	std	Y+35, r1	; 0x23
    2aee:	1c a2       	std	Y+36, r1	; 0x24
    2af0:	1d a2       	std	Y+37, r1	; 0x25
    2af2:	1e a2       	std	Y+38, r1	; 0x26
    2af4:	1f a2       	std	Y+39, r1	; 0x27
    2af6:	a4 01       	movw	r20, r8
    2af8:	b3 01       	movw	r22, r6
    2afa:	c5 01       	movw	r24, r10
    2afc:	0e 94 3b 1d 	call	0x3a76	; 0x3a76 <pxPortInitialiseStack>
    2b00:	99 83       	std	Y+1, r25	; 0x01
    2b02:	88 83       	st	Y, r24
    2b04:	e1 14       	cp	r14, r1
    2b06:	f1 04       	cpc	r15, r1
    2b08:	19 f0       	breq	.+6      	; 0x2b10 <xTaskCreate+0xf8>
    2b0a:	f7 01       	movw	r30, r14
    2b0c:	d1 83       	std	Z+1, r29	; 0x01
    2b0e:	c0 83       	st	Z, r28
    2b10:	0f b6       	in	r0, 0x3f	; 63
    2b12:	f8 94       	cli
    2b14:	0f 92       	push	r0
    2b16:	80 91 a9 04 	lds	r24, 0x04A9	; 0x8004a9 <uxCurrentNumberOfTasks>
    2b1a:	8f 5f       	subi	r24, 0xFF	; 255
    2b1c:	80 93 a9 04 	sts	0x04A9, r24	; 0x8004a9 <uxCurrentNumberOfTasks>
    2b20:	80 91 00 05 	lds	r24, 0x0500	; 0x800500 <pxCurrentTCB>
    2b24:	90 91 01 05 	lds	r25, 0x0501	; 0x800501 <pxCurrentTCB+0x1>
    2b28:	89 2b       	or	r24, r25
    2b2a:	d1 f5       	brne	.+116    	; 0x2ba0 <xTaskCreate+0x188>
    2b2c:	d0 93 01 05 	sts	0x0501, r29	; 0x800501 <pxCurrentTCB+0x1>
    2b30:	c0 93 00 05 	sts	0x0500, r28	; 0x800500 <pxCurrentTCB>
    2b34:	80 91 a9 04 	lds	r24, 0x04A9	; 0x8004a9 <uxCurrentNumberOfTasks>
    2b38:	81 30       	cpi	r24, 0x01	; 1
    2b3a:	09 f0       	breq	.+2      	; 0x2b3e <xTaskCreate+0x126>
    2b3c:	41 c0       	rjmp	.+130    	; 0x2bc0 <xTaskCreate+0x1a8>
    2b3e:	8c ed       	ldi	r24, 0xDC	; 220
    2b40:	94 e0       	ldi	r25, 0x04	; 4
    2b42:	0e 94 ac 1c 	call	0x3958	; 0x3958 <vListInitialise>
    2b46:	85 ee       	ldi	r24, 0xE5	; 229
    2b48:	94 e0       	ldi	r25, 0x04	; 4
    2b4a:	0e 94 ac 1c 	call	0x3958	; 0x3958 <vListInitialise>
    2b4e:	8e ee       	ldi	r24, 0xEE	; 238
    2b50:	94 e0       	ldi	r25, 0x04	; 4
    2b52:	0e 94 ac 1c 	call	0x3958	; 0x3958 <vListInitialise>
    2b56:	87 ef       	ldi	r24, 0xF7	; 247
    2b58:	94 e0       	ldi	r25, 0x04	; 4
    2b5a:	0e 94 ac 1c 	call	0x3958	; 0x3958 <vListInitialise>
    2b5e:	83 ed       	ldi	r24, 0xD3	; 211
    2b60:	94 e0       	ldi	r25, 0x04	; 4
    2b62:	0e 94 ac 1c 	call	0x3958	; 0x3958 <vListInitialise>
    2b66:	8a ec       	ldi	r24, 0xCA	; 202
    2b68:	94 e0       	ldi	r25, 0x04	; 4
    2b6a:	0e 94 ac 1c 	call	0x3958	; 0x3958 <vListInitialise>
    2b6e:	8d eb       	ldi	r24, 0xBD	; 189
    2b70:	94 e0       	ldi	r25, 0x04	; 4
    2b72:	0e 94 ac 1c 	call	0x3958	; 0x3958 <vListInitialise>
    2b76:	84 eb       	ldi	r24, 0xB4	; 180
    2b78:	94 e0       	ldi	r25, 0x04	; 4
    2b7a:	0e 94 ac 1c 	call	0x3958	; 0x3958 <vListInitialise>
    2b7e:	8a ea       	ldi	r24, 0xAA	; 170
    2b80:	94 e0       	ldi	r25, 0x04	; 4
    2b82:	0e 94 ac 1c 	call	0x3958	; 0x3958 <vListInitialise>
    2b86:	83 ed       	ldi	r24, 0xD3	; 211
    2b88:	94 e0       	ldi	r25, 0x04	; 4
    2b8a:	90 93 c9 04 	sts	0x04C9, r25	; 0x8004c9 <pxDelayedTaskList+0x1>
    2b8e:	80 93 c8 04 	sts	0x04C8, r24	; 0x8004c8 <pxDelayedTaskList>
    2b92:	8a ec       	ldi	r24, 0xCA	; 202
    2b94:	94 e0       	ldi	r25, 0x04	; 4
    2b96:	90 93 c7 04 	sts	0x04C7, r25	; 0x8004c7 <pxOverflowDelayedTaskList+0x1>
    2b9a:	80 93 c6 04 	sts	0x04C6, r24	; 0x8004c6 <pxOverflowDelayedTaskList>
    2b9e:	10 c0       	rjmp	.+32     	; 0x2bc0 <xTaskCreate+0x1a8>
    2ba0:	80 91 a5 04 	lds	r24, 0x04A5	; 0x8004a5 <xSchedulerRunning>
    2ba4:	81 11       	cpse	r24, r1
    2ba6:	0c c0       	rjmp	.+24     	; 0x2bc0 <xTaskCreate+0x1a8>
    2ba8:	e0 91 00 05 	lds	r30, 0x0500	; 0x800500 <pxCurrentTCB>
    2bac:	f0 91 01 05 	lds	r31, 0x0501	; 0x800501 <pxCurrentTCB+0x1>
    2bb0:	96 89       	ldd	r25, Z+22	; 0x16
    2bb2:	8e 89       	ldd	r24, Y+22	; 0x16
    2bb4:	89 17       	cp	r24, r25
    2bb6:	20 f0       	brcs	.+8      	; 0x2bc0 <xTaskCreate+0x1a8>
    2bb8:	d0 93 01 05 	sts	0x0501, r29	; 0x800501 <pxCurrentTCB+0x1>
    2bbc:	c0 93 00 05 	sts	0x0500, r28	; 0x800500 <pxCurrentTCB>
    2bc0:	80 91 a1 04 	lds	r24, 0x04A1	; 0x8004a1 <uxTaskNumber>
    2bc4:	8f 5f       	subi	r24, 0xFF	; 255
    2bc6:	80 93 a1 04 	sts	0x04A1, r24	; 0x8004a1 <uxTaskNumber>
    2bca:	8e 89       	ldd	r24, Y+22	; 0x16
    2bcc:	90 91 a6 04 	lds	r25, 0x04A6	; 0x8004a6 <uxTopReadyPriority>
    2bd0:	98 17       	cp	r25, r24
    2bd2:	10 f4       	brcc	.+4      	; 0x2bd8 <xTaskCreate+0x1c0>
    2bd4:	80 93 a6 04 	sts	0x04A6, r24	; 0x8004a6 <uxTopReadyPriority>
    2bd8:	f9 e0       	ldi	r31, 0x09	; 9
    2bda:	8f 9f       	mul	r24, r31
    2bdc:	c0 01       	movw	r24, r0
    2bde:	11 24       	eor	r1, r1
    2be0:	b6 01       	movw	r22, r12
    2be2:	84 52       	subi	r24, 0x24	; 36
    2be4:	9b 4f       	sbci	r25, 0xFB	; 251
    2be6:	0e 94 be 1c 	call	0x397c	; 0x397c <vListInsertEnd>
    2bea:	0f 90       	pop	r0
    2bec:	0f be       	out	0x3f, r0	; 63
    2bee:	80 91 a5 04 	lds	r24, 0x04A5	; 0x8004a5 <xSchedulerRunning>
    2bf2:	88 23       	and	r24, r24
    2bf4:	51 f0       	breq	.+20     	; 0x2c0a <xTaskCreate+0x1f2>
    2bf6:	e0 91 00 05 	lds	r30, 0x0500	; 0x800500 <pxCurrentTCB>
    2bfa:	f0 91 01 05 	lds	r31, 0x0501	; 0x800501 <pxCurrentTCB+0x1>
    2bfe:	96 89       	ldd	r25, Z+22	; 0x16
    2c00:	8e 89       	ldd	r24, Y+22	; 0x16
    2c02:	98 17       	cp	r25, r24
    2c04:	10 f4       	brcc	.+4      	; 0x2c0a <xTaskCreate+0x1f2>
    2c06:	0e 94 df 1d 	call	0x3bbe	; 0x3bbe <vPortYield>
    2c0a:	81 e0       	ldi	r24, 0x01	; 1
    2c0c:	01 c0       	rjmp	.+2      	; 0x2c10 <xTaskCreate+0x1f8>
    2c0e:	8f ef       	ldi	r24, 0xFF	; 255
    2c10:	df 91       	pop	r29
    2c12:	cf 91       	pop	r28
    2c14:	1f 91       	pop	r17
    2c16:	0f 91       	pop	r16
    2c18:	ff 90       	pop	r15
    2c1a:	ef 90       	pop	r14
    2c1c:	df 90       	pop	r13
    2c1e:	cf 90       	pop	r12
    2c20:	bf 90       	pop	r11
    2c22:	af 90       	pop	r10
    2c24:	9f 90       	pop	r9
    2c26:	8f 90       	pop	r8
    2c28:	7f 90       	pop	r7
    2c2a:	6f 90       	pop	r6
    2c2c:	5f 90       	pop	r5
    2c2e:	08 95       	ret

00002c30 <vTaskResume>:
    2c30:	0f 93       	push	r16
    2c32:	1f 93       	push	r17
    2c34:	cf 93       	push	r28
    2c36:	df 93       	push	r29
    2c38:	20 91 00 05 	lds	r18, 0x0500	; 0x800500 <pxCurrentTCB>
    2c3c:	30 91 01 05 	lds	r19, 0x0501	; 0x800501 <pxCurrentTCB+0x1>
    2c40:	82 17       	cp	r24, r18
    2c42:	93 07       	cpc	r25, r19
    2c44:	09 f4       	brne	.+2      	; 0x2c48 <vTaskResume+0x18>
    2c46:	38 c0       	rjmp	.+112    	; 0x2cb8 <vTaskResume+0x88>
    2c48:	00 97       	sbiw	r24, 0x00	; 0
    2c4a:	09 f4       	brne	.+2      	; 0x2c4e <vTaskResume+0x1e>
    2c4c:	35 c0       	rjmp	.+106    	; 0x2cb8 <vTaskResume+0x88>
    2c4e:	0f b6       	in	r0, 0x3f	; 63
    2c50:	f8 94       	cli
    2c52:	0f 92       	push	r0
    2c54:	fc 01       	movw	r30, r24
    2c56:	22 85       	ldd	r18, Z+10	; 0x0a
    2c58:	33 85       	ldd	r19, Z+11	; 0x0b
    2c5a:	2a 5a       	subi	r18, 0xAA	; 170
    2c5c:	34 40       	sbci	r19, 0x04	; 4
    2c5e:	51 f5       	brne	.+84     	; 0x2cb4 <vTaskResume+0x84>
    2c60:	fc 01       	movw	r30, r24
    2c62:	24 89       	ldd	r18, Z+20	; 0x14
    2c64:	35 89       	ldd	r19, Z+21	; 0x15
    2c66:	f4 e0       	ldi	r31, 0x04	; 4
    2c68:	2d 3b       	cpi	r18, 0xBD	; 189
    2c6a:	3f 07       	cpc	r19, r31
    2c6c:	19 f1       	breq	.+70     	; 0x2cb4 <vTaskResume+0x84>
    2c6e:	23 2b       	or	r18, r19
    2c70:	09 f5       	brne	.+66     	; 0x2cb4 <vTaskResume+0x84>
    2c72:	ec 01       	movw	r28, r24
    2c74:	8c 01       	movw	r16, r24
    2c76:	0e 5f       	subi	r16, 0xFE	; 254
    2c78:	1f 4f       	sbci	r17, 0xFF	; 255
    2c7a:	c8 01       	movw	r24, r16
    2c7c:	0e 94 17 1d 	call	0x3a2e	; 0x3a2e <uxListRemove>
    2c80:	8e 89       	ldd	r24, Y+22	; 0x16
    2c82:	90 91 a6 04 	lds	r25, 0x04A6	; 0x8004a6 <uxTopReadyPriority>
    2c86:	98 17       	cp	r25, r24
    2c88:	10 f4       	brcc	.+4      	; 0x2c8e <vTaskResume+0x5e>
    2c8a:	80 93 a6 04 	sts	0x04A6, r24	; 0x8004a6 <uxTopReadyPriority>
    2c8e:	29 e0       	ldi	r18, 0x09	; 9
    2c90:	82 9f       	mul	r24, r18
    2c92:	c0 01       	movw	r24, r0
    2c94:	11 24       	eor	r1, r1
    2c96:	b8 01       	movw	r22, r16
    2c98:	84 52       	subi	r24, 0x24	; 36
    2c9a:	9b 4f       	sbci	r25, 0xFB	; 251
    2c9c:	0e 94 be 1c 	call	0x397c	; 0x397c <vListInsertEnd>
    2ca0:	e0 91 00 05 	lds	r30, 0x0500	; 0x800500 <pxCurrentTCB>
    2ca4:	f0 91 01 05 	lds	r31, 0x0501	; 0x800501 <pxCurrentTCB+0x1>
    2ca8:	9e 89       	ldd	r25, Y+22	; 0x16
    2caa:	86 89       	ldd	r24, Z+22	; 0x16
    2cac:	98 17       	cp	r25, r24
    2cae:	10 f0       	brcs	.+4      	; 0x2cb4 <vTaskResume+0x84>
    2cb0:	0e 94 df 1d 	call	0x3bbe	; 0x3bbe <vPortYield>
    2cb4:	0f 90       	pop	r0
    2cb6:	0f be       	out	0x3f, r0	; 63
    2cb8:	df 91       	pop	r29
    2cba:	cf 91       	pop	r28
    2cbc:	1f 91       	pop	r17
    2cbe:	0f 91       	pop	r16
    2cc0:	08 95       	ret

00002cc2 <vTaskStartScheduler>:
    2cc2:	ef 92       	push	r14
    2cc4:	ff 92       	push	r15
    2cc6:	0f 93       	push	r16
    2cc8:	8d e9       	ldi	r24, 0x9D	; 157
    2cca:	e8 2e       	mov	r14, r24
    2ccc:	84 e0       	ldi	r24, 0x04	; 4
    2cce:	f8 2e       	mov	r15, r24
    2cd0:	00 e0       	ldi	r16, 0x00	; 0
    2cd2:	20 e0       	ldi	r18, 0x00	; 0
    2cd4:	30 e0       	ldi	r19, 0x00	; 0
    2cd6:	40 ec       	ldi	r20, 0xC0	; 192
    2cd8:	50 e0       	ldi	r21, 0x00	; 0
    2cda:	68 ea       	ldi	r22, 0xA8	; 168
    2cdc:	72 e0       	ldi	r23, 0x02	; 2
    2cde:	8e ed       	ldi	r24, 0xDE	; 222
    2ce0:	94 e1       	ldi	r25, 0x14	; 20
    2ce2:	0e 94 0c 15 	call	0x2a18	; 0x2a18 <xTaskCreate>
    2ce6:	81 30       	cpi	r24, 0x01	; 1
    2ce8:	b1 f4       	brne	.+44     	; 0x2d16 <vTaskStartScheduler+0x54>
    2cea:	0e 94 96 19 	call	0x332c	; 0x332c <xTimerCreateTimerTask>
    2cee:	81 30       	cpi	r24, 0x01	; 1
    2cf0:	91 f4       	brne	.+36     	; 0x2d16 <vTaskStartScheduler+0x54>
    2cf2:	f8 94       	cli
    2cf4:	2f ef       	ldi	r18, 0xFF	; 255
    2cf6:	3f ef       	ldi	r19, 0xFF	; 255
    2cf8:	30 93 a0 04 	sts	0x04A0, r19	; 0x8004a0 <xNextTaskUnblockTime+0x1>
    2cfc:	20 93 9f 04 	sts	0x049F, r18	; 0x80049f <xNextTaskUnblockTime>
    2d00:	80 93 a5 04 	sts	0x04A5, r24	; 0x8004a5 <xSchedulerRunning>
    2d04:	10 92 a8 04 	sts	0x04A8, r1	; 0x8004a8 <xTickCount+0x1>
    2d08:	10 92 a7 04 	sts	0x04A7, r1	; 0x8004a7 <xTickCount>
    2d0c:	0f 91       	pop	r16
    2d0e:	ff 90       	pop	r15
    2d10:	ef 90       	pop	r14
    2d12:	0c 94 a7 1d 	jmp	0x3b4e	; 0x3b4e <xPortStartScheduler>
    2d16:	0f 91       	pop	r16
    2d18:	ff 90       	pop	r15
    2d1a:	ef 90       	pop	r14
    2d1c:	08 95       	ret

00002d1e <vTaskSuspendAll>:
    2d1e:	80 91 9c 04 	lds	r24, 0x049C	; 0x80049c <uxSchedulerSuspended>
    2d22:	8f 5f       	subi	r24, 0xFF	; 255
    2d24:	80 93 9c 04 	sts	0x049C, r24	; 0x80049c <uxSchedulerSuspended>
    2d28:	08 95       	ret

00002d2a <xTaskGetTickCount>:
    2d2a:	0f b6       	in	r0, 0x3f	; 63
    2d2c:	f8 94       	cli
    2d2e:	0f 92       	push	r0
    2d30:	80 91 a7 04 	lds	r24, 0x04A7	; 0x8004a7 <xTickCount>
    2d34:	90 91 a8 04 	lds	r25, 0x04A8	; 0x8004a8 <xTickCount+0x1>
    2d38:	0f 90       	pop	r0
    2d3a:	0f be       	out	0x3f, r0	; 63
    2d3c:	08 95       	ret

00002d3e <xTaskIncrementTick>:
    2d3e:	cf 92       	push	r12
    2d40:	df 92       	push	r13
    2d42:	ef 92       	push	r14
    2d44:	ff 92       	push	r15
    2d46:	0f 93       	push	r16
    2d48:	1f 93       	push	r17
    2d4a:	cf 93       	push	r28
    2d4c:	df 93       	push	r29
    2d4e:	80 91 9c 04 	lds	r24, 0x049C	; 0x80049c <uxSchedulerSuspended>
    2d52:	81 11       	cpse	r24, r1
    2d54:	8c c0       	rjmp	.+280    	; 0x2e6e <xTaskIncrementTick+0x130>
    2d56:	00 91 a7 04 	lds	r16, 0x04A7	; 0x8004a7 <xTickCount>
    2d5a:	10 91 a8 04 	lds	r17, 0x04A8	; 0x8004a8 <xTickCount+0x1>
    2d5e:	0f 5f       	subi	r16, 0xFF	; 255
    2d60:	1f 4f       	sbci	r17, 0xFF	; 255
    2d62:	10 93 a8 04 	sts	0x04A8, r17	; 0x8004a8 <xTickCount+0x1>
    2d66:	00 93 a7 04 	sts	0x04A7, r16	; 0x8004a7 <xTickCount>
    2d6a:	01 15       	cp	r16, r1
    2d6c:	11 05       	cpc	r17, r1
    2d6e:	b9 f4       	brne	.+46     	; 0x2d9e <xTaskIncrementTick+0x60>
    2d70:	80 91 c8 04 	lds	r24, 0x04C8	; 0x8004c8 <pxDelayedTaskList>
    2d74:	90 91 c9 04 	lds	r25, 0x04C9	; 0x8004c9 <pxDelayedTaskList+0x1>
    2d78:	20 91 c6 04 	lds	r18, 0x04C6	; 0x8004c6 <pxOverflowDelayedTaskList>
    2d7c:	30 91 c7 04 	lds	r19, 0x04C7	; 0x8004c7 <pxOverflowDelayedTaskList+0x1>
    2d80:	30 93 c9 04 	sts	0x04C9, r19	; 0x8004c9 <pxDelayedTaskList+0x1>
    2d84:	20 93 c8 04 	sts	0x04C8, r18	; 0x8004c8 <pxDelayedTaskList>
    2d88:	90 93 c7 04 	sts	0x04C7, r25	; 0x8004c7 <pxOverflowDelayedTaskList+0x1>
    2d8c:	80 93 c6 04 	sts	0x04C6, r24	; 0x8004c6 <pxOverflowDelayedTaskList>
    2d90:	80 91 a2 04 	lds	r24, 0x04A2	; 0x8004a2 <xNumOfOverflows>
    2d94:	8f 5f       	subi	r24, 0xFF	; 255
    2d96:	80 93 a2 04 	sts	0x04A2, r24	; 0x8004a2 <xNumOfOverflows>
    2d9a:	0e 94 67 14 	call	0x28ce	; 0x28ce <prvResetNextTaskUnblockTime>
    2d9e:	80 91 9f 04 	lds	r24, 0x049F	; 0x80049f <xNextTaskUnblockTime>
    2da2:	90 91 a0 04 	lds	r25, 0x04A0	; 0x8004a0 <xNextTaskUnblockTime+0x1>
    2da6:	c0 e0       	ldi	r28, 0x00	; 0
    2da8:	08 17       	cp	r16, r24
    2daa:	19 07       	cpc	r17, r25
    2dac:	08 f4       	brcc	.+2      	; 0x2db0 <xTaskIncrementTick+0x72>
    2dae:	4f c0       	rjmp	.+158    	; 0x2e4e <xTaskIncrementTick+0x110>
    2db0:	d9 e0       	ldi	r29, 0x09	; 9
    2db2:	e0 91 c8 04 	lds	r30, 0x04C8	; 0x8004c8 <pxDelayedTaskList>
    2db6:	f0 91 c9 04 	lds	r31, 0x04C9	; 0x8004c9 <pxDelayedTaskList+0x1>
    2dba:	80 81       	ld	r24, Z
    2dbc:	81 11       	cpse	r24, r1
    2dbe:	03 c0       	rjmp	.+6      	; 0x2dc6 <xTaskIncrementTick+0x88>
    2dc0:	8f ef       	ldi	r24, 0xFF	; 255
    2dc2:	9f ef       	ldi	r25, 0xFF	; 255
    2dc4:	11 c0       	rjmp	.+34     	; 0x2de8 <xTaskIncrementTick+0xaa>
    2dc6:	e0 91 c8 04 	lds	r30, 0x04C8	; 0x8004c8 <pxDelayedTaskList>
    2dca:	f0 91 c9 04 	lds	r31, 0x04C9	; 0x8004c9 <pxDelayedTaskList+0x1>
    2dce:	05 80       	ldd	r0, Z+5	; 0x05
    2dd0:	f6 81       	ldd	r31, Z+6	; 0x06
    2dd2:	e0 2d       	mov	r30, r0
    2dd4:	e6 80       	ldd	r14, Z+6	; 0x06
    2dd6:	f7 80       	ldd	r15, Z+7	; 0x07
    2dd8:	d7 01       	movw	r26, r14
    2dda:	12 96       	adiw	r26, 0x02	; 2
    2ddc:	8d 91       	ld	r24, X+
    2dde:	9c 91       	ld	r25, X
    2de0:	13 97       	sbiw	r26, 0x03	; 3
    2de2:	08 17       	cp	r16, r24
    2de4:	19 07       	cpc	r17, r25
    2de6:	28 f4       	brcc	.+10     	; 0x2df2 <xTaskIncrementTick+0xb4>
    2de8:	90 93 a0 04 	sts	0x04A0, r25	; 0x8004a0 <xNextTaskUnblockTime+0x1>
    2dec:	80 93 9f 04 	sts	0x049F, r24	; 0x80049f <xNextTaskUnblockTime>
    2df0:	2e c0       	rjmp	.+92     	; 0x2e4e <xTaskIncrementTick+0x110>
    2df2:	67 01       	movw	r12, r14
    2df4:	b2 e0       	ldi	r27, 0x02	; 2
    2df6:	cb 0e       	add	r12, r27
    2df8:	d1 1c       	adc	r13, r1
    2dfa:	c6 01       	movw	r24, r12
    2dfc:	0e 94 17 1d 	call	0x3a2e	; 0x3a2e <uxListRemove>
    2e00:	f7 01       	movw	r30, r14
    2e02:	84 89       	ldd	r24, Z+20	; 0x14
    2e04:	95 89       	ldd	r25, Z+21	; 0x15
    2e06:	89 2b       	or	r24, r25
    2e08:	21 f0       	breq	.+8      	; 0x2e12 <xTaskIncrementTick+0xd4>
    2e0a:	c7 01       	movw	r24, r14
    2e0c:	0c 96       	adiw	r24, 0x0c	; 12
    2e0e:	0e 94 17 1d 	call	0x3a2e	; 0x3a2e <uxListRemove>
    2e12:	d7 01       	movw	r26, r14
    2e14:	56 96       	adiw	r26, 0x16	; 22
    2e16:	8c 91       	ld	r24, X
    2e18:	90 91 a6 04 	lds	r25, 0x04A6	; 0x8004a6 <uxTopReadyPriority>
    2e1c:	98 17       	cp	r25, r24
    2e1e:	10 f4       	brcc	.+4      	; 0x2e24 <xTaskIncrementTick+0xe6>
    2e20:	80 93 a6 04 	sts	0x04A6, r24	; 0x8004a6 <uxTopReadyPriority>
    2e24:	d8 9f       	mul	r29, r24
    2e26:	c0 01       	movw	r24, r0
    2e28:	11 24       	eor	r1, r1
    2e2a:	b6 01       	movw	r22, r12
    2e2c:	84 52       	subi	r24, 0x24	; 36
    2e2e:	9b 4f       	sbci	r25, 0xFB	; 251
    2e30:	0e 94 be 1c 	call	0x397c	; 0x397c <vListInsertEnd>
    2e34:	e0 91 00 05 	lds	r30, 0x0500	; 0x800500 <pxCurrentTCB>
    2e38:	f0 91 01 05 	lds	r31, 0x0501	; 0x800501 <pxCurrentTCB+0x1>
    2e3c:	d7 01       	movw	r26, r14
    2e3e:	56 96       	adiw	r26, 0x16	; 22
    2e40:	9c 91       	ld	r25, X
    2e42:	86 89       	ldd	r24, Z+22	; 0x16
    2e44:	98 17       	cp	r25, r24
    2e46:	08 f4       	brcc	.+2      	; 0x2e4a <xTaskIncrementTick+0x10c>
    2e48:	b4 cf       	rjmp	.-152    	; 0x2db2 <xTaskIncrementTick+0x74>
    2e4a:	c1 e0       	ldi	r28, 0x01	; 1
    2e4c:	b2 cf       	rjmp	.-156    	; 0x2db2 <xTaskIncrementTick+0x74>
    2e4e:	e0 91 00 05 	lds	r30, 0x0500	; 0x800500 <pxCurrentTCB>
    2e52:	f0 91 01 05 	lds	r31, 0x0501	; 0x800501 <pxCurrentTCB+0x1>
    2e56:	e6 89       	ldd	r30, Z+22	; 0x16
    2e58:	b9 e0       	ldi	r27, 0x09	; 9
    2e5a:	eb 9f       	mul	r30, r27
    2e5c:	f0 01       	movw	r30, r0
    2e5e:	11 24       	eor	r1, r1
    2e60:	e4 52       	subi	r30, 0x24	; 36
    2e62:	fb 4f       	sbci	r31, 0xFB	; 251
    2e64:	80 81       	ld	r24, Z
    2e66:	82 30       	cpi	r24, 0x02	; 2
    2e68:	40 f0       	brcs	.+16     	; 0x2e7a <xTaskIncrementTick+0x13c>
    2e6a:	c1 e0       	ldi	r28, 0x01	; 1
    2e6c:	06 c0       	rjmp	.+12     	; 0x2e7a <xTaskIncrementTick+0x13c>
    2e6e:	80 91 a4 04 	lds	r24, 0x04A4	; 0x8004a4 <uxPendedTicks>
    2e72:	8f 5f       	subi	r24, 0xFF	; 255
    2e74:	80 93 a4 04 	sts	0x04A4, r24	; 0x8004a4 <uxPendedTicks>
    2e78:	c0 e0       	ldi	r28, 0x00	; 0
    2e7a:	80 91 a3 04 	lds	r24, 0x04A3	; 0x8004a3 <xYieldPending>
    2e7e:	81 11       	cpse	r24, r1
    2e80:	c1 e0       	ldi	r28, 0x01	; 1
    2e82:	8c 2f       	mov	r24, r28
    2e84:	df 91       	pop	r29
    2e86:	cf 91       	pop	r28
    2e88:	1f 91       	pop	r17
    2e8a:	0f 91       	pop	r16
    2e8c:	ff 90       	pop	r15
    2e8e:	ef 90       	pop	r14
    2e90:	df 90       	pop	r13
    2e92:	cf 90       	pop	r12
    2e94:	08 95       	ret

00002e96 <xTaskResumeAll>:
    2e96:	ef 92       	push	r14
    2e98:	ff 92       	push	r15
    2e9a:	0f 93       	push	r16
    2e9c:	1f 93       	push	r17
    2e9e:	cf 93       	push	r28
    2ea0:	df 93       	push	r29
    2ea2:	0f b6       	in	r0, 0x3f	; 63
    2ea4:	f8 94       	cli
    2ea6:	0f 92       	push	r0
    2ea8:	80 91 9c 04 	lds	r24, 0x049C	; 0x80049c <uxSchedulerSuspended>
    2eac:	81 50       	subi	r24, 0x01	; 1
    2eae:	80 93 9c 04 	sts	0x049C, r24	; 0x80049c <uxSchedulerSuspended>
    2eb2:	80 91 9c 04 	lds	r24, 0x049C	; 0x80049c <uxSchedulerSuspended>
    2eb6:	88 23       	and	r24, r24
    2eb8:	11 f0       	breq	.+4      	; 0x2ebe <xTaskResumeAll+0x28>
    2eba:	80 e0       	ldi	r24, 0x00	; 0
    2ebc:	52 c0       	rjmp	.+164    	; 0x2f62 <xTaskResumeAll+0xcc>
    2ebe:	80 91 a9 04 	lds	r24, 0x04A9	; 0x8004a9 <uxCurrentNumberOfTasks>
    2ec2:	88 23       	and	r24, r24
    2ec4:	d1 f3       	breq	.-12     	; 0x2eba <xTaskResumeAll+0x24>
    2ec6:	c0 e0       	ldi	r28, 0x00	; 0
    2ec8:	d0 e0       	ldi	r29, 0x00	; 0
    2eca:	89 e0       	ldi	r24, 0x09	; 9
    2ecc:	f8 2e       	mov	r15, r24
    2ece:	ee 24       	eor	r14, r14
    2ed0:	e3 94       	inc	r14
    2ed2:	80 91 bd 04 	lds	r24, 0x04BD	; 0x8004bd <xPendingReadyList>
    2ed6:	88 23       	and	r24, r24
    2ed8:	51 f1       	breq	.+84     	; 0x2f2e <xTaskResumeAll+0x98>
    2eda:	e0 91 c2 04 	lds	r30, 0x04C2	; 0x8004c2 <xPendingReadyList+0x5>
    2ede:	f0 91 c3 04 	lds	r31, 0x04C3	; 0x8004c3 <xPendingReadyList+0x6>
    2ee2:	c6 81       	ldd	r28, Z+6	; 0x06
    2ee4:	d7 81       	ldd	r29, Z+7	; 0x07
    2ee6:	ce 01       	movw	r24, r28
    2ee8:	0c 96       	adiw	r24, 0x0c	; 12
    2eea:	0e 94 17 1d 	call	0x3a2e	; 0x3a2e <uxListRemove>
    2eee:	8e 01       	movw	r16, r28
    2ef0:	0e 5f       	subi	r16, 0xFE	; 254
    2ef2:	1f 4f       	sbci	r17, 0xFF	; 255
    2ef4:	c8 01       	movw	r24, r16
    2ef6:	0e 94 17 1d 	call	0x3a2e	; 0x3a2e <uxListRemove>
    2efa:	8e 89       	ldd	r24, Y+22	; 0x16
    2efc:	90 91 a6 04 	lds	r25, 0x04A6	; 0x8004a6 <uxTopReadyPriority>
    2f00:	98 17       	cp	r25, r24
    2f02:	10 f4       	brcc	.+4      	; 0x2f08 <xTaskResumeAll+0x72>
    2f04:	80 93 a6 04 	sts	0x04A6, r24	; 0x8004a6 <uxTopReadyPriority>
    2f08:	f8 9e       	mul	r15, r24
    2f0a:	c0 01       	movw	r24, r0
    2f0c:	11 24       	eor	r1, r1
    2f0e:	b8 01       	movw	r22, r16
    2f10:	84 52       	subi	r24, 0x24	; 36
    2f12:	9b 4f       	sbci	r25, 0xFB	; 251
    2f14:	0e 94 be 1c 	call	0x397c	; 0x397c <vListInsertEnd>
    2f18:	e0 91 00 05 	lds	r30, 0x0500	; 0x800500 <pxCurrentTCB>
    2f1c:	f0 91 01 05 	lds	r31, 0x0501	; 0x800501 <pxCurrentTCB+0x1>
    2f20:	9e 89       	ldd	r25, Y+22	; 0x16
    2f22:	86 89       	ldd	r24, Z+22	; 0x16
    2f24:	98 17       	cp	r25, r24
    2f26:	a8 f2       	brcs	.-86     	; 0x2ed2 <xTaskResumeAll+0x3c>
    2f28:	e0 92 a3 04 	sts	0x04A3, r14	; 0x8004a3 <xYieldPending>
    2f2c:	d2 cf       	rjmp	.-92     	; 0x2ed2 <xTaskResumeAll+0x3c>
    2f2e:	cd 2b       	or	r28, r29
    2f30:	11 f0       	breq	.+4      	; 0x2f36 <xTaskResumeAll+0xa0>
    2f32:	0e 94 67 14 	call	0x28ce	; 0x28ce <prvResetNextTaskUnblockTime>
    2f36:	c0 91 a4 04 	lds	r28, 0x04A4	; 0x8004a4 <uxPendedTicks>
    2f3a:	cc 23       	and	r28, r28
    2f3c:	51 f0       	breq	.+20     	; 0x2f52 <xTaskResumeAll+0xbc>
    2f3e:	d1 e0       	ldi	r29, 0x01	; 1
    2f40:	0e 94 9f 16 	call	0x2d3e	; 0x2d3e <xTaskIncrementTick>
    2f44:	81 11       	cpse	r24, r1
    2f46:	d0 93 a3 04 	sts	0x04A3, r29	; 0x8004a3 <xYieldPending>
    2f4a:	c1 50       	subi	r28, 0x01	; 1
    2f4c:	c9 f7       	brne	.-14     	; 0x2f40 <xTaskResumeAll+0xaa>
    2f4e:	10 92 a4 04 	sts	0x04A4, r1	; 0x8004a4 <uxPendedTicks>
    2f52:	80 91 a3 04 	lds	r24, 0x04A3	; 0x8004a3 <xYieldPending>
    2f56:	88 23       	and	r24, r24
    2f58:	09 f4       	brne	.+2      	; 0x2f5c <xTaskResumeAll+0xc6>
    2f5a:	af cf       	rjmp	.-162    	; 0x2eba <xTaskResumeAll+0x24>
    2f5c:	0e 94 df 1d 	call	0x3bbe	; 0x3bbe <vPortYield>
    2f60:	81 e0       	ldi	r24, 0x01	; 1
    2f62:	0f 90       	pop	r0
    2f64:	0f be       	out	0x3f, r0	; 63
    2f66:	df 91       	pop	r29
    2f68:	cf 91       	pop	r28
    2f6a:	1f 91       	pop	r17
    2f6c:	0f 91       	pop	r16
    2f6e:	ff 90       	pop	r15
    2f70:	ef 90       	pop	r14
    2f72:	08 95       	ret

00002f74 <vTaskDelayUntil>:
    2f74:	0f 93       	push	r16
    2f76:	1f 93       	push	r17
    2f78:	cf 93       	push	r28
    2f7a:	df 93       	push	r29
    2f7c:	8c 01       	movw	r16, r24
    2f7e:	eb 01       	movw	r28, r22
    2f80:	0e 94 8f 16 	call	0x2d1e	; 0x2d1e <vTaskSuspendAll>
    2f84:	40 91 a7 04 	lds	r20, 0x04A7	; 0x8004a7 <xTickCount>
    2f88:	50 91 a8 04 	lds	r21, 0x04A8	; 0x8004a8 <xTickCount+0x1>
    2f8c:	f8 01       	movw	r30, r16
    2f8e:	20 81       	ld	r18, Z
    2f90:	31 81       	ldd	r19, Z+1	; 0x01
    2f92:	c9 01       	movw	r24, r18
    2f94:	8c 0f       	add	r24, r28
    2f96:	9d 1f       	adc	r25, r29
    2f98:	42 17       	cp	r20, r18
    2f9a:	53 07       	cpc	r21, r19
    2f9c:	20 f4       	brcc	.+8      	; 0x2fa6 <vTaskDelayUntil+0x32>
    2f9e:	82 17       	cp	r24, r18
    2fa0:	93 07       	cpc	r25, r19
    2fa2:	40 f4       	brcc	.+16     	; 0x2fb4 <vTaskDelayUntil+0x40>
    2fa4:	03 c0       	rjmp	.+6      	; 0x2fac <vTaskDelayUntil+0x38>
    2fa6:	82 17       	cp	r24, r18
    2fa8:	93 07       	cpc	r25, r19
    2faa:	30 f0       	brcs	.+12     	; 0x2fb8 <vTaskDelayUntil+0x44>
    2fac:	21 e0       	ldi	r18, 0x01	; 1
    2fae:	48 17       	cp	r20, r24
    2fb0:	59 07       	cpc	r21, r25
    2fb2:	18 f0       	brcs	.+6      	; 0x2fba <vTaskDelayUntil+0x46>
    2fb4:	20 e0       	ldi	r18, 0x00	; 0
    2fb6:	01 c0       	rjmp	.+2      	; 0x2fba <vTaskDelayUntil+0x46>
    2fb8:	21 e0       	ldi	r18, 0x01	; 1
    2fba:	f8 01       	movw	r30, r16
    2fbc:	91 83       	std	Z+1, r25	; 0x01
    2fbe:	80 83       	st	Z, r24
    2fc0:	22 23       	and	r18, r18
    2fc2:	29 f0       	breq	.+10     	; 0x2fce <vTaskDelayUntil+0x5a>
    2fc4:	60 e0       	ldi	r22, 0x00	; 0
    2fc6:	84 1b       	sub	r24, r20
    2fc8:	95 0b       	sbc	r25, r21
    2fca:	0e 94 82 14 	call	0x2904	; 0x2904 <prvAddCurrentTaskToDelayedList>
    2fce:	0e 94 4b 17 	call	0x2e96	; 0x2e96 <xTaskResumeAll>
    2fd2:	81 11       	cpse	r24, r1
    2fd4:	02 c0       	rjmp	.+4      	; 0x2fda <vTaskDelayUntil+0x66>
    2fd6:	0e 94 df 1d 	call	0x3bbe	; 0x3bbe <vPortYield>
    2fda:	df 91       	pop	r29
    2fdc:	cf 91       	pop	r28
    2fde:	1f 91       	pop	r17
    2fe0:	0f 91       	pop	r16
    2fe2:	08 95       	ret

00002fe4 <vTaskSwitchContext>:
    2fe4:	80 91 9c 04 	lds	r24, 0x049C	; 0x80049c <uxSchedulerSuspended>
    2fe8:	88 23       	and	r24, r24
    2fea:	21 f0       	breq	.+8      	; 0x2ff4 <vTaskSwitchContext+0x10>
    2fec:	81 e0       	ldi	r24, 0x01	; 1
    2fee:	80 93 a3 04 	sts	0x04A3, r24	; 0x8004a3 <xYieldPending>
    2ff2:	08 95       	ret
    2ff4:	10 92 a3 04 	sts	0x04A3, r1	; 0x8004a3 <xYieldPending>
    2ff8:	a0 91 00 05 	lds	r26, 0x0500	; 0x800500 <pxCurrentTCB>
    2ffc:	b0 91 01 05 	lds	r27, 0x0501	; 0x800501 <pxCurrentTCB+0x1>
    3000:	e0 91 00 05 	lds	r30, 0x0500	; 0x800500 <pxCurrentTCB>
    3004:	f0 91 01 05 	lds	r31, 0x0501	; 0x800501 <pxCurrentTCB+0x1>
    3008:	2d 91       	ld	r18, X+
    300a:	3c 91       	ld	r19, X
    300c:	87 89       	ldd	r24, Z+23	; 0x17
    300e:	90 8d       	ldd	r25, Z+24	; 0x18
    3010:	82 17       	cp	r24, r18
    3012:	93 07       	cpc	r25, r19
    3014:	60 f0       	brcs	.+24     	; 0x302e <vTaskSwitchContext+0x4a>
    3016:	60 91 00 05 	lds	r22, 0x0500	; 0x800500 <pxCurrentTCB>
    301a:	70 91 01 05 	lds	r23, 0x0501	; 0x800501 <pxCurrentTCB+0x1>
    301e:	80 91 00 05 	lds	r24, 0x0500	; 0x800500 <pxCurrentTCB>
    3022:	90 91 01 05 	lds	r25, 0x0501	; 0x800501 <pxCurrentTCB+0x1>
    3026:	67 5e       	subi	r22, 0xE7	; 231
    3028:	7f 4f       	sbci	r23, 0xFF	; 255
    302a:	0e 94 64 1b 	call	0x36c8	; 0x36c8 <vApplicationStackOverflowHook>
    302e:	80 91 a6 04 	lds	r24, 0x04A6	; 0x8004a6 <uxTopReadyPriority>
    3032:	69 e0       	ldi	r22, 0x09	; 9
    3034:	48 2f       	mov	r20, r24
    3036:	50 e0       	ldi	r21, 0x00	; 0
    3038:	64 9f       	mul	r22, r20
    303a:	90 01       	movw	r18, r0
    303c:	65 9f       	mul	r22, r21
    303e:	30 0d       	add	r19, r0
    3040:	11 24       	eor	r1, r1
    3042:	f9 01       	movw	r30, r18
    3044:	e4 52       	subi	r30, 0x24	; 36
    3046:	fb 4f       	sbci	r31, 0xFB	; 251
    3048:	90 81       	ld	r25, Z
    304a:	91 11       	cpse	r25, r1
    304c:	02 c0       	rjmp	.+4      	; 0x3052 <vTaskSwitchContext+0x6e>
    304e:	81 50       	subi	r24, 0x01	; 1
    3050:	f1 cf       	rjmp	.-30     	; 0x3034 <vTaskSwitchContext+0x50>
    3052:	a1 81       	ldd	r26, Z+1	; 0x01
    3054:	b2 81       	ldd	r27, Z+2	; 0x02
    3056:	12 96       	adiw	r26, 0x02	; 2
    3058:	0d 90       	ld	r0, X+
    305a:	bc 91       	ld	r27, X
    305c:	a0 2d       	mov	r26, r0
    305e:	b2 83       	std	Z+2, r27	; 0x02
    3060:	a1 83       	std	Z+1, r26	; 0x01
    3062:	21 52       	subi	r18, 0x21	; 33
    3064:	3b 4f       	sbci	r19, 0xFB	; 251
    3066:	a2 17       	cp	r26, r18
    3068:	b3 07       	cpc	r27, r19
    306a:	31 f4       	brne	.+12     	; 0x3078 <vTaskSwitchContext+0x94>
    306c:	12 96       	adiw	r26, 0x02	; 2
    306e:	2d 91       	ld	r18, X+
    3070:	3c 91       	ld	r19, X
    3072:	13 97       	sbiw	r26, 0x03	; 3
    3074:	32 83       	std	Z+2, r19	; 0x02
    3076:	21 83       	std	Z+1, r18	; 0x01
    3078:	99 e0       	ldi	r25, 0x09	; 9
    307a:	94 9f       	mul	r25, r20
    307c:	f0 01       	movw	r30, r0
    307e:	95 9f       	mul	r25, r21
    3080:	f0 0d       	add	r31, r0
    3082:	11 24       	eor	r1, r1
    3084:	e4 52       	subi	r30, 0x24	; 36
    3086:	fb 4f       	sbci	r31, 0xFB	; 251
    3088:	01 80       	ldd	r0, Z+1	; 0x01
    308a:	f2 81       	ldd	r31, Z+2	; 0x02
    308c:	e0 2d       	mov	r30, r0
    308e:	26 81       	ldd	r18, Z+6	; 0x06
    3090:	37 81       	ldd	r19, Z+7	; 0x07
    3092:	30 93 01 05 	sts	0x0501, r19	; 0x800501 <pxCurrentTCB+0x1>
    3096:	20 93 00 05 	sts	0x0500, r18	; 0x800500 <pxCurrentTCB>
    309a:	80 93 a6 04 	sts	0x04A6, r24	; 0x8004a6 <uxTopReadyPriority>
    309e:	08 95       	ret

000030a0 <vTaskPlaceOnEventList>:
    30a0:	cf 93       	push	r28
    30a2:	df 93       	push	r29
    30a4:	eb 01       	movw	r28, r22
    30a6:	60 91 00 05 	lds	r22, 0x0500	; 0x800500 <pxCurrentTCB>
    30aa:	70 91 01 05 	lds	r23, 0x0501	; 0x800501 <pxCurrentTCB+0x1>
    30ae:	64 5f       	subi	r22, 0xF4	; 244
    30b0:	7f 4f       	sbci	r23, 0xFF	; 255
    30b2:	0e 94 df 1c 	call	0x39be	; 0x39be <vListInsert>
    30b6:	61 e0       	ldi	r22, 0x01	; 1
    30b8:	ce 01       	movw	r24, r28
    30ba:	df 91       	pop	r29
    30bc:	cf 91       	pop	r28
    30be:	0c 94 82 14 	jmp	0x2904	; 0x2904 <prvAddCurrentTaskToDelayedList>

000030c2 <vTaskPlaceOnEventListRestricted>:
    30c2:	1f 93       	push	r17
    30c4:	cf 93       	push	r28
    30c6:	df 93       	push	r29
    30c8:	eb 01       	movw	r28, r22
    30ca:	14 2f       	mov	r17, r20
    30cc:	60 91 00 05 	lds	r22, 0x0500	; 0x800500 <pxCurrentTCB>
    30d0:	70 91 01 05 	lds	r23, 0x0501	; 0x800501 <pxCurrentTCB+0x1>
    30d4:	64 5f       	subi	r22, 0xF4	; 244
    30d6:	7f 4f       	sbci	r23, 0xFF	; 255
    30d8:	0e 94 be 1c 	call	0x397c	; 0x397c <vListInsertEnd>
    30dc:	11 23       	and	r17, r17
    30de:	11 f0       	breq	.+4      	; 0x30e4 <vTaskPlaceOnEventListRestricted+0x22>
    30e0:	cf ef       	ldi	r28, 0xFF	; 255
    30e2:	df ef       	ldi	r29, 0xFF	; 255
    30e4:	61 2f       	mov	r22, r17
    30e6:	ce 01       	movw	r24, r28
    30e8:	df 91       	pop	r29
    30ea:	cf 91       	pop	r28
    30ec:	1f 91       	pop	r17
    30ee:	0c 94 82 14 	jmp	0x2904	; 0x2904 <prvAddCurrentTaskToDelayedList>

000030f2 <xTaskRemoveFromEventList>:
    30f2:	0f 93       	push	r16
    30f4:	1f 93       	push	r17
    30f6:	cf 93       	push	r28
    30f8:	df 93       	push	r29
    30fa:	dc 01       	movw	r26, r24
    30fc:	15 96       	adiw	r26, 0x05	; 5
    30fe:	ed 91       	ld	r30, X+
    3100:	fc 91       	ld	r31, X
    3102:	16 97       	sbiw	r26, 0x06	; 6
    3104:	c6 81       	ldd	r28, Z+6	; 0x06
    3106:	d7 81       	ldd	r29, Z+7	; 0x07
    3108:	8e 01       	movw	r16, r28
    310a:	04 5f       	subi	r16, 0xF4	; 244
    310c:	1f 4f       	sbci	r17, 0xFF	; 255
    310e:	c8 01       	movw	r24, r16
    3110:	0e 94 17 1d 	call	0x3a2e	; 0x3a2e <uxListRemove>
    3114:	80 91 9c 04 	lds	r24, 0x049C	; 0x80049c <uxSchedulerSuspended>
    3118:	81 11       	cpse	r24, r1
    311a:	14 c0       	rjmp	.+40     	; 0x3144 <xTaskRemoveFromEventList+0x52>
    311c:	0a 50       	subi	r16, 0x0A	; 10
    311e:	11 09       	sbc	r17, r1
    3120:	c8 01       	movw	r24, r16
    3122:	0e 94 17 1d 	call	0x3a2e	; 0x3a2e <uxListRemove>
    3126:	8e 89       	ldd	r24, Y+22	; 0x16
    3128:	90 91 a6 04 	lds	r25, 0x04A6	; 0x8004a6 <uxTopReadyPriority>
    312c:	98 17       	cp	r25, r24
    312e:	10 f4       	brcc	.+4      	; 0x3134 <xTaskRemoveFromEventList+0x42>
    3130:	80 93 a6 04 	sts	0x04A6, r24	; 0x8004a6 <uxTopReadyPriority>
    3134:	b9 e0       	ldi	r27, 0x09	; 9
    3136:	8b 9f       	mul	r24, r27
    3138:	c0 01       	movw	r24, r0
    313a:	11 24       	eor	r1, r1
    313c:	b8 01       	movw	r22, r16
    313e:	84 52       	subi	r24, 0x24	; 36
    3140:	9b 4f       	sbci	r25, 0xFB	; 251
    3142:	03 c0       	rjmp	.+6      	; 0x314a <xTaskRemoveFromEventList+0x58>
    3144:	b8 01       	movw	r22, r16
    3146:	8d eb       	ldi	r24, 0xBD	; 189
    3148:	94 e0       	ldi	r25, 0x04	; 4
    314a:	0e 94 be 1c 	call	0x397c	; 0x397c <vListInsertEnd>
    314e:	e0 91 00 05 	lds	r30, 0x0500	; 0x800500 <pxCurrentTCB>
    3152:	f0 91 01 05 	lds	r31, 0x0501	; 0x800501 <pxCurrentTCB+0x1>
    3156:	9e 89       	ldd	r25, Y+22	; 0x16
    3158:	86 89       	ldd	r24, Z+22	; 0x16
    315a:	89 17       	cp	r24, r25
    315c:	20 f4       	brcc	.+8      	; 0x3166 <xTaskRemoveFromEventList+0x74>
    315e:	81 e0       	ldi	r24, 0x01	; 1
    3160:	80 93 a3 04 	sts	0x04A3, r24	; 0x8004a3 <xYieldPending>
    3164:	01 c0       	rjmp	.+2      	; 0x3168 <xTaskRemoveFromEventList+0x76>
    3166:	80 e0       	ldi	r24, 0x00	; 0
    3168:	df 91       	pop	r29
    316a:	cf 91       	pop	r28
    316c:	1f 91       	pop	r17
    316e:	0f 91       	pop	r16
    3170:	08 95       	ret

00003172 <vTaskInternalSetTimeOutState>:
    3172:	20 91 a2 04 	lds	r18, 0x04A2	; 0x8004a2 <xNumOfOverflows>
    3176:	fc 01       	movw	r30, r24
    3178:	20 83       	st	Z, r18
    317a:	20 91 a7 04 	lds	r18, 0x04A7	; 0x8004a7 <xTickCount>
    317e:	30 91 a8 04 	lds	r19, 0x04A8	; 0x8004a8 <xTickCount+0x1>
    3182:	32 83       	std	Z+2, r19	; 0x02
    3184:	21 83       	std	Z+1, r18	; 0x01
    3186:	08 95       	ret

00003188 <xTaskCheckForTimeOut>:
    3188:	cf 93       	push	r28
    318a:	df 93       	push	r29
    318c:	0f b6       	in	r0, 0x3f	; 63
    318e:	f8 94       	cli
    3190:	0f 92       	push	r0
    3192:	40 91 a7 04 	lds	r20, 0x04A7	; 0x8004a7 <xTickCount>
    3196:	50 91 a8 04 	lds	r21, 0x04A8	; 0x8004a8 <xTickCount+0x1>
    319a:	db 01       	movw	r26, r22
    319c:	2d 91       	ld	r18, X+
    319e:	3c 91       	ld	r19, X
    31a0:	2f 3f       	cpi	r18, 0xFF	; 255
    31a2:	bf ef       	ldi	r27, 0xFF	; 255
    31a4:	3b 07       	cpc	r19, r27
    31a6:	d9 f0       	breq	.+54     	; 0x31de <xTaskCheckForTimeOut+0x56>
    31a8:	ec 01       	movw	r28, r24
    31aa:	e9 81       	ldd	r30, Y+1	; 0x01
    31ac:	fa 81       	ldd	r31, Y+2	; 0x02
    31ae:	a0 91 a2 04 	lds	r26, 0x04A2	; 0x8004a2 <xNumOfOverflows>
    31b2:	b8 81       	ld	r27, Y
    31b4:	ba 17       	cp	r27, r26
    31b6:	19 f0       	breq	.+6      	; 0x31be <xTaskCheckForTimeOut+0x36>
    31b8:	4e 17       	cp	r20, r30
    31ba:	5f 07       	cpc	r21, r31
    31bc:	90 f4       	brcc	.+36     	; 0x31e2 <xTaskCheckForTimeOut+0x5a>
    31be:	4e 1b       	sub	r20, r30
    31c0:	5f 0b       	sbc	r21, r31
    31c2:	fb 01       	movw	r30, r22
    31c4:	42 17       	cp	r20, r18
    31c6:	53 07       	cpc	r21, r19
    31c8:	38 f4       	brcc	.+14     	; 0x31d8 <xTaskCheckForTimeOut+0x50>
    31ca:	24 1b       	sub	r18, r20
    31cc:	35 0b       	sbc	r19, r21
    31ce:	31 83       	std	Z+1, r19	; 0x01
    31d0:	20 83       	st	Z, r18
    31d2:	0e 94 b9 18 	call	0x3172	; 0x3172 <vTaskInternalSetTimeOutState>
    31d6:	03 c0       	rjmp	.+6      	; 0x31de <xTaskCheckForTimeOut+0x56>
    31d8:	11 82       	std	Z+1, r1	; 0x01
    31da:	10 82       	st	Z, r1
    31dc:	02 c0       	rjmp	.+4      	; 0x31e2 <xTaskCheckForTimeOut+0x5a>
    31de:	80 e0       	ldi	r24, 0x00	; 0
    31e0:	01 c0       	rjmp	.+2      	; 0x31e4 <xTaskCheckForTimeOut+0x5c>
    31e2:	81 e0       	ldi	r24, 0x01	; 1
    31e4:	0f 90       	pop	r0
    31e6:	0f be       	out	0x3f, r0	; 63
    31e8:	df 91       	pop	r29
    31ea:	cf 91       	pop	r28
    31ec:	08 95       	ret

000031ee <vTaskMissedYield>:
    31ee:	81 e0       	ldi	r24, 0x01	; 1
    31f0:	80 93 a3 04 	sts	0x04A3, r24	; 0x8004a3 <xYieldPending>
    31f4:	08 95       	ret

000031f6 <xTaskGetSchedulerState>:
    31f6:	80 91 a5 04 	lds	r24, 0x04A5	; 0x8004a5 <xSchedulerRunning>
    31fa:	88 23       	and	r24, r24
    31fc:	31 f0       	breq	.+12     	; 0x320a <xTaskGetSchedulerState+0x14>
    31fe:	80 91 9c 04 	lds	r24, 0x049C	; 0x80049c <uxSchedulerSuspended>
    3202:	88 23       	and	r24, r24
    3204:	21 f0       	breq	.+8      	; 0x320e <xTaskGetSchedulerState+0x18>
    3206:	80 e0       	ldi	r24, 0x00	; 0
    3208:	08 95       	ret
    320a:	81 e0       	ldi	r24, 0x01	; 1
    320c:	08 95       	ret
    320e:	82 e0       	ldi	r24, 0x02	; 2
    3210:	08 95       	ret

00003212 <xTaskPriorityDisinherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

    BaseType_t xTaskPriorityDisinherit( TaskHandle_t const pxMutexHolder )
    {
    3212:	0f 93       	push	r16
    3214:	1f 93       	push	r17
    3216:	cf 93       	push	r28
    3218:	df 93       	push	r29
    321a:	fc 01       	movw	r30, r24
    TCB_t * const pxTCB = pxMutexHolder;
    BaseType_t xReturn = pdFALSE;

        if( pxMutexHolder != NULL )
    321c:	89 2b       	or	r24, r25
    321e:	11 f4       	brne	.+4      	; 0x3224 <xTaskPriorityDisinherit+0x12>
#if ( configUSE_MUTEXES == 1 )

    BaseType_t xTaskPriorityDisinherit( TaskHandle_t const pxMutexHolder )
    {
    TCB_t * const pxTCB = pxMutexHolder;
    BaseType_t xReturn = pdFALSE;
    3220:	80 e0       	ldi	r24, 0x00	; 0
    3222:	2c c0       	rjmp	.+88     	; 0x327c <xTaskPriorityDisinherit+0x6a>
            If the mutex is held by a task then it cannot be given from an
            interrupt, and if a mutex is given by the holding task then it must
            be the running state task. */
            configASSERT( pxTCB == pxCurrentTCB );
            configASSERT( pxTCB->uxMutexesHeld );
            ( pxTCB->uxMutexesHeld )--;
    3224:	82 a1       	ldd	r24, Z+34	; 0x22
    3226:	81 50       	subi	r24, 0x01	; 1
    3228:	82 a3       	std	Z+34, r24	; 0x22

            /* Has the holder of the mutex inherited the priority of another
            task? */
            if( pxTCB->uxPriority != pxTCB->uxBasePriority )
    322a:	26 89       	ldd	r18, Z+22	; 0x16
    322c:	91 a1       	ldd	r25, Z+33	; 0x21
    322e:	29 17       	cp	r18, r25
    3230:	b9 f3       	breq	.-18     	; 0x3220 <xTaskPriorityDisinherit+0xe>
            {
                /* Only disinherit if no other mutexes are held. */
                if( pxTCB->uxMutexesHeld == ( UBaseType_t ) 0 )
    3232:	81 11       	cpse	r24, r1
    3234:	f5 cf       	rjmp	.-22     	; 0x3220 <xTaskPriorityDisinherit+0xe>
    3236:	ef 01       	movw	r28, r30
                    /* A task can only have an inherited priority if it holds
                    the mutex.  If the mutex is held by a task then it cannot be
                    given from an interrupt, and if a mutex is given by the
                    holding task then it must be the running state task.  Remove
                    the holding task from the ready list. */
                    if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    3238:	8f 01       	movw	r16, r30
    323a:	0e 5f       	subi	r16, 0xFE	; 254
    323c:	1f 4f       	sbci	r17, 0xFF	; 255
    323e:	c8 01       	movw	r24, r16
    3240:	0e 94 17 1d 	call	0x3a2e	; 0x3a2e <uxListRemove>
                    }

                    /* Disinherit the priority before adding the task into the
                    new    ready list. */
                    traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
                    pxTCB->uxPriority = pxTCB->uxBasePriority;
    3244:	89 a1       	ldd	r24, Y+33	; 0x21
    3246:	8e 8b       	std	Y+22, r24	; 0x16

                    /* Reset the event list item value.  It cannot be in use for
                    any other purpose if this task is running, and it must be
                    running to give back the mutex. */
                    listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    3248:	48 2f       	mov	r20, r24
    324a:	50 e0       	ldi	r21, 0x00	; 0
    324c:	24 e0       	ldi	r18, 0x04	; 4
    324e:	30 e0       	ldi	r19, 0x00	; 0
    3250:	24 1b       	sub	r18, r20
    3252:	35 0b       	sbc	r19, r21
    3254:	3d 87       	std	Y+13, r19	; 0x0d
    3256:	2c 87       	std	Y+12, r18	; 0x0c
                    prvAddTaskToReadyList( pxTCB );
    3258:	90 91 a6 04 	lds	r25, 0x04A6	; 0x8004a6 <uxTopReadyPriority>
    325c:	98 17       	cp	r25, r24
    325e:	10 f4       	brcc	.+4      	; 0x3264 <xTaskPriorityDisinherit+0x52>
    3260:	80 93 a6 04 	sts	0x04A6, r24	; 0x8004a6 <uxTopReadyPriority>
    3264:	29 e0       	ldi	r18, 0x09	; 9
    3266:	24 9f       	mul	r18, r20
    3268:	c0 01       	movw	r24, r0
    326a:	25 9f       	mul	r18, r21
    326c:	90 0d       	add	r25, r0
    326e:	11 24       	eor	r1, r1
    3270:	b8 01       	movw	r22, r16
    3272:	84 52       	subi	r24, 0x24	; 36
    3274:	9b 4f       	sbci	r25, 0xFB	; 251
    3276:	0e 94 be 1c 	call	0x397c	; 0x397c <vListInsertEnd>
                    in an order different to that in which they were taken.
                    If a context switch did not occur when the first mutex was
                    returned, even if a task was waiting on it, then a context
                    switch should occur when the last mutex is returned whether
                    a task is waiting on it or not. */
                    xReturn = pdTRUE;
    327a:	81 e0       	ldi	r24, 0x01	; 1
        {
            mtCOVERAGE_TEST_MARKER();
        }

        return xReturn;
    }
    327c:	df 91       	pop	r29
    327e:	cf 91       	pop	r28
    3280:	1f 91       	pop	r17
    3282:	0f 91       	pop	r16
    3284:	08 95       	ret

00003286 <prvCheckForValidListAndQueue>:
            pxNewTimer->ucStatus = 0x00;
            prvInitialiseNewTimer( pcTimerName, xTimerPeriodInTicks, uxAutoReload, pvTimerID, pxCallbackFunction, pxNewTimer );
        }

        return pxNewTimer;
    }
    3286:	0f b6       	in	r0, 0x3f	; 63
    3288:	f8 94       	cli
    328a:	0f 92       	push	r0
    328c:	80 91 06 05 	lds	r24, 0x0506	; 0x800506 <xTimerQueue>
    3290:	90 91 07 05 	lds	r25, 0x0507	; 0x800507 <xTimerQueue+0x1>
    3294:	89 2b       	or	r24, r25
    3296:	e9 f4       	brne	.+58     	; 0x32d2 <prvCheckForValidListAndQueue+0x4c>
    3298:	85 e1       	ldi	r24, 0x15	; 21
    329a:	95 e0       	ldi	r25, 0x05	; 5
    329c:	0e 94 ac 1c 	call	0x3958	; 0x3958 <vListInitialise>
    32a0:	8c e0       	ldi	r24, 0x0C	; 12
    32a2:	95 e0       	ldi	r25, 0x05	; 5
    32a4:	0e 94 ac 1c 	call	0x3958	; 0x3958 <vListInitialise>
    32a8:	85 e1       	ldi	r24, 0x15	; 21
    32aa:	95 e0       	ldi	r25, 0x05	; 5
    32ac:	90 93 0b 05 	sts	0x050B, r25	; 0x80050b <pxCurrentTimerList+0x1>
    32b0:	80 93 0a 05 	sts	0x050A, r24	; 0x80050a <pxCurrentTimerList>
    32b4:	8c e0       	ldi	r24, 0x0C	; 12
    32b6:	95 e0       	ldi	r25, 0x05	; 5
    32b8:	90 93 09 05 	sts	0x0509, r25	; 0x800509 <pxOverflowTimerList+0x1>
    32bc:	80 93 08 05 	sts	0x0508, r24	; 0x800508 <pxOverflowTimerList>
    32c0:	40 e0       	ldi	r20, 0x00	; 0
    32c2:	65 e0       	ldi	r22, 0x05	; 5
    32c4:	8a e0       	ldi	r24, 0x0A	; 10
    32c6:	0e 94 8d 1f 	call	0x3f1a	; 0x3f1a <xQueueGenericCreate>
    32ca:	90 93 07 05 	sts	0x0507, r25	; 0x800507 <xTimerQueue+0x1>
    32ce:	80 93 06 05 	sts	0x0506, r24	; 0x800506 <xTimerQueue>
    32d2:	0f 90       	pop	r0
    32d4:	0f be       	out	0x3f, r0	; 63
    32d6:	08 95       	ret

000032d8 <prvInsertTimerInActiveList>:
    32d8:	fc 01       	movw	r30, r24
    32da:	73 83       	std	Z+3, r23	; 0x03
    32dc:	62 83       	std	Z+2, r22	; 0x02
    32de:	91 87       	std	Z+9, r25	; 0x09
    32e0:	80 87       	std	Z+8, r24	; 0x08
    32e2:	46 17       	cp	r20, r22
    32e4:	57 07       	cpc	r21, r23
    32e6:	78 f0       	brcs	.+30     	; 0x3306 <prvInsertTimerInActiveList+0x2e>
    32e8:	42 1b       	sub	r20, r18
    32ea:	53 0b       	sbc	r21, r19
    32ec:	84 85       	ldd	r24, Z+12	; 0x0c
    32ee:	95 85       	ldd	r25, Z+13	; 0x0d
    32f0:	48 17       	cp	r20, r24
    32f2:	59 07       	cpc	r21, r25
    32f4:	c8 f4       	brcc	.+50     	; 0x3328 <prvInsertTimerInActiveList+0x50>
    32f6:	bf 01       	movw	r22, r30
    32f8:	6e 5f       	subi	r22, 0xFE	; 254
    32fa:	7f 4f       	sbci	r23, 0xFF	; 255
    32fc:	80 91 08 05 	lds	r24, 0x0508	; 0x800508 <pxOverflowTimerList>
    3300:	90 91 09 05 	lds	r25, 0x0509	; 0x800509 <pxOverflowTimerList+0x1>
    3304:	0d c0       	rjmp	.+26     	; 0x3320 <prvInsertTimerInActiveList+0x48>
    3306:	42 17       	cp	r20, r18
    3308:	53 07       	cpc	r21, r19
    330a:	18 f4       	brcc	.+6      	; 0x3312 <prvInsertTimerInActiveList+0x3a>
    330c:	62 17       	cp	r22, r18
    330e:	73 07       	cpc	r23, r19
    3310:	58 f4       	brcc	.+22     	; 0x3328 <prvInsertTimerInActiveList+0x50>
    3312:	bf 01       	movw	r22, r30
    3314:	6e 5f       	subi	r22, 0xFE	; 254
    3316:	7f 4f       	sbci	r23, 0xFF	; 255
    3318:	80 91 0a 05 	lds	r24, 0x050A	; 0x80050a <pxCurrentTimerList>
    331c:	90 91 0b 05 	lds	r25, 0x050B	; 0x80050b <pxCurrentTimerList+0x1>
    3320:	0e 94 df 1c 	call	0x39be	; 0x39be <vListInsert>
    3324:	80 e0       	ldi	r24, 0x00	; 0
    3326:	08 95       	ret
    3328:	81 e0       	ldi	r24, 0x01	; 1
    332a:	08 95       	ret

0000332c <xTimerCreateTimerTask>:
    332c:	ef 92       	push	r14
    332e:	ff 92       	push	r15
    3330:	0f 93       	push	r16
    3332:	0e 94 43 19 	call	0x3286	; 0x3286 <prvCheckForValidListAndQueue>
    3336:	80 91 06 05 	lds	r24, 0x0506	; 0x800506 <xTimerQueue>
    333a:	90 91 07 05 	lds	r25, 0x0507	; 0x800507 <xTimerQueue+0x1>
    333e:	89 2b       	or	r24, r25
    3340:	81 f0       	breq	.+32     	; 0x3362 <xTimerCreateTimerTask+0x36>
    3342:	84 e0       	ldi	r24, 0x04	; 4
    3344:	e8 2e       	mov	r14, r24
    3346:	85 e0       	ldi	r24, 0x05	; 5
    3348:	f8 2e       	mov	r15, r24
    334a:	03 e0       	ldi	r16, 0x03	; 3
    334c:	20 e0       	ldi	r18, 0x00	; 0
    334e:	30 e0       	ldi	r19, 0x00	; 0
    3350:	45 e5       	ldi	r20, 0x55	; 85
    3352:	50 e0       	ldi	r21, 0x00	; 0
    3354:	6d ea       	ldi	r22, 0xAD	; 173
    3356:	72 e0       	ldi	r23, 0x02	; 2
    3358:	86 e4       	ldi	r24, 0x46	; 70
    335a:	9a e1       	ldi	r25, 0x1A	; 26
    335c:	0e 94 0c 15 	call	0x2a18	; 0x2a18 <xTaskCreate>
    3360:	01 c0       	rjmp	.+2      	; 0x3364 <xTimerCreateTimerTask+0x38>
    3362:	80 e0       	ldi	r24, 0x00	; 0
    3364:	0f 91       	pop	r16
    3366:	ff 90       	pop	r15
    3368:	ef 90       	pop	r14
    336a:	08 95       	ret

0000336c <xTimerGenericCommand>:
    }
}
/*-----------------------------------------------------------*/

BaseType_t xTimerGenericCommand( TimerHandle_t xTimer, const BaseType_t xCommandID, const TickType_t xOptionalValue, BaseType_t * const pxHigherPriorityTaskWoken, const TickType_t xTicksToWait )
{
    336c:	0f 93       	push	r16
    336e:	1f 93       	push	r17
    3370:	cf 93       	push	r28
    3372:	df 93       	push	r29
    3374:	00 d0       	rcall	.+0      	; 0x3376 <xTimerGenericCommand+0xa>
    3376:	00 d0       	rcall	.+0      	; 0x3378 <xTimerGenericCommand+0xc>
    3378:	1f 92       	push	r1
    337a:	cd b7       	in	r28, 0x3d	; 61
    337c:	de b7       	in	r29, 0x3e	; 62

    configASSERT( xTimer );

    /* Send a message to the timer service task to perform a particular action
    on a particular timer definition. */
    if( xTimerQueue != NULL )
    337e:	a0 91 06 05 	lds	r26, 0x0506	; 0x800506 <xTimerQueue>
    3382:	b0 91 07 05 	lds	r27, 0x0507	; 0x800507 <xTimerQueue+0x1>
    3386:	10 97       	sbiw	r26, 0x00	; 0
    3388:	29 f1       	breq	.+74     	; 0x33d4 <xTimerGenericCommand+0x68>
    338a:	f9 01       	movw	r30, r18
    {
        /* Send a command to the timer service task to start the xTimer timer. */
        xMessage.xMessageID = xCommandID;
    338c:	69 83       	std	Y+1, r22	; 0x01
        xMessage.u.xTimerParameters.xMessageValue = xOptionalValue;
    338e:	5b 83       	std	Y+3, r21	; 0x03
    3390:	4a 83       	std	Y+2, r20	; 0x02
        xMessage.u.xTimerParameters.pxTimer = xTimer;
    3392:	9d 83       	std	Y+5, r25	; 0x05
    3394:	8c 83       	std	Y+4, r24	; 0x04

        if( xCommandID < tmrFIRST_FROM_ISR_COMMAND )
    3396:	66 30       	cpi	r22, 0x06	; 6
    3398:	a4 f4       	brge	.+40     	; 0x33c2 <xTimerGenericCommand+0x56>
        {
            if( xTaskGetSchedulerState() == taskSCHEDULER_RUNNING )
    339a:	0e 94 fb 18 	call	0x31f6	; 0x31f6 <xTaskGetSchedulerState>
    339e:	e0 91 06 05 	lds	r30, 0x0506	; 0x800506 <xTimerQueue>
    33a2:	f0 91 07 05 	lds	r31, 0x0507	; 0x800507 <xTimerQueue+0x1>
            {
                xReturn = xQueueSendToBack( xTimerQueue, &xMessage, xTicksToWait );
    33a6:	20 e0       	ldi	r18, 0x00	; 0
        xMessage.u.xTimerParameters.xMessageValue = xOptionalValue;
        xMessage.u.xTimerParameters.pxTimer = xTimer;

        if( xCommandID < tmrFIRST_FROM_ISR_COMMAND )
        {
            if( xTaskGetSchedulerState() == taskSCHEDULER_RUNNING )
    33a8:	82 30       	cpi	r24, 0x02	; 2
    33aa:	11 f4       	brne	.+4      	; 0x33b0 <xTimerGenericCommand+0x44>
            {
                xReturn = xQueueSendToBack( xTimerQueue, &xMessage, xTicksToWait );
    33ac:	a8 01       	movw	r20, r16
    33ae:	02 c0       	rjmp	.+4      	; 0x33b4 <xTimerGenericCommand+0x48>
            }
            else
            {
                xReturn = xQueueSendToBack( xTimerQueue, &xMessage, tmrNO_DELAY );
    33b0:	40 e0       	ldi	r20, 0x00	; 0
    33b2:	50 e0       	ldi	r21, 0x00	; 0
    33b4:	be 01       	movw	r22, r28
    33b6:	6f 5f       	subi	r22, 0xFF	; 255
    33b8:	7f 4f       	sbci	r23, 0xFF	; 255
    33ba:	cf 01       	movw	r24, r30
    33bc:	0e 94 b5 1f 	call	0x3f6a	; 0x3f6a <xQueueGenericSend>
    33c0:	0a c0       	rjmp	.+20     	; 0x33d6 <xTimerGenericCommand+0x6a>
            }
        }
        else
        {
            xReturn = xQueueSendToBackFromISR( xTimerQueue, &xMessage, pxHigherPriorityTaskWoken );
    33c2:	20 e0       	ldi	r18, 0x00	; 0
    33c4:	af 01       	movw	r20, r30
    33c6:	be 01       	movw	r22, r28
    33c8:	6f 5f       	subi	r22, 0xFF	; 255
    33ca:	7f 4f       	sbci	r23, 0xFF	; 255
    33cc:	cd 01       	movw	r24, r26
    33ce:	0e 94 4b 20 	call	0x4096	; 0x4096 <xQueueGenericSendFromISR>
    33d2:	01 c0       	rjmp	.+2      	; 0x33d6 <xTimerGenericCommand+0x6a>
}
/*-----------------------------------------------------------*/

BaseType_t xTimerGenericCommand( TimerHandle_t xTimer, const BaseType_t xCommandID, const TickType_t xOptionalValue, BaseType_t * const pxHigherPriorityTaskWoken, const TickType_t xTicksToWait )
{
BaseType_t xReturn = pdFAIL;
    33d4:	80 e0       	ldi	r24, 0x00	; 0
    {
        mtCOVERAGE_TEST_MARKER();
    }

    return xReturn;
}
    33d6:	0f 90       	pop	r0
    33d8:	0f 90       	pop	r0
    33da:	0f 90       	pop	r0
    33dc:	0f 90       	pop	r0
    33de:	0f 90       	pop	r0
    33e0:	df 91       	pop	r29
    33e2:	cf 91       	pop	r28
    33e4:	1f 91       	pop	r17
    33e6:	0f 91       	pop	r16
    33e8:	08 95       	ret

000033ea <prvSwitchTimerLists>:
    }
}
/*-----------------------------------------------------------*/

static void prvSwitchTimerLists( void )
{
    33ea:	ef 92       	push	r14
    33ec:	ff 92       	push	r15
    33ee:	0f 93       	push	r16
    33f0:	1f 93       	push	r17
    33f2:	cf 93       	push	r28
    33f4:	df 93       	push	r29

    /* The tick count has overflowed.  The timer lists must be switched.
    If there are any timers still referenced from the current timer list
    then they must have expired and should be processed before the lists
    are switched. */
    while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
    33f6:	e0 91 0a 05 	lds	r30, 0x050A	; 0x80050a <pxCurrentTimerList>
    33fa:	f0 91 0b 05 	lds	r31, 0x050B	; 0x80050b <pxCurrentTimerList+0x1>
    33fe:	80 81       	ld	r24, Z
    3400:	88 23       	and	r24, r24
    3402:	89 f1       	breq	.+98     	; 0x3466 <prvSwitchTimerLists+0x7c>
    {
        xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
    3404:	05 80       	ldd	r0, Z+5	; 0x05
    3406:	f6 81       	ldd	r31, Z+6	; 0x06
    3408:	e0 2d       	mov	r30, r0
    340a:	e0 80       	ld	r14, Z
    340c:	f1 80       	ldd	r15, Z+1	; 0x01

        /* Remove the timer from the list. */
        pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList ); /*lint !e9087 !e9079 void * is used as this macro is used with tasks and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    340e:	c6 81       	ldd	r28, Z+6	; 0x06
    3410:	d7 81       	ldd	r29, Z+7	; 0x07
        ( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
    3412:	8e 01       	movw	r16, r28
    3414:	0e 5f       	subi	r16, 0xFE	; 254
    3416:	1f 4f       	sbci	r17, 0xFF	; 255
    3418:	c8 01       	movw	r24, r16
    341a:	0e 94 17 1d 	call	0x3a2e	; 0x3a2e <uxListRemove>
        traceTIMER_EXPIRED( pxTimer );

        /* Execute its callback, then send a command to restart the timer if
        it is an auto-reload timer.  It cannot be restarted here as the lists
        have not yet been switched. */
        pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
    341e:	e8 89       	ldd	r30, Y+16	; 0x10
    3420:	f9 89       	ldd	r31, Y+17	; 0x11
    3422:	ce 01       	movw	r24, r28
    3424:	09 95       	icall

        if( ( pxTimer->ucStatus & tmrSTATUS_IS_AUTORELOAD ) != 0 )
    3426:	8a 89       	ldd	r24, Y+18	; 0x12
    3428:	82 ff       	sbrs	r24, 2
    342a:	e5 cf       	rjmp	.-54     	; 0x33f6 <prvSwitchTimerLists+0xc>
            the timer going into the same timer list then it has already expired
            and the timer should be re-inserted into the current list so it is
            processed again within this loop.  Otherwise a command should be sent
            to restart the timer to ensure it is only inserted into a list after
            the lists have been swapped. */
            xReloadTime = ( xNextExpireTime + pxTimer->xTimerPeriodInTicks );
    342c:	8c 85       	ldd	r24, Y+12	; 0x0c
    342e:	9d 85       	ldd	r25, Y+13	; 0x0d
    3430:	8e 0d       	add	r24, r14
    3432:	9f 1d       	adc	r25, r15
            if( xReloadTime > xNextExpireTime )
    3434:	e8 16       	cp	r14, r24
    3436:	f9 06       	cpc	r15, r25
    3438:	60 f4       	brcc	.+24     	; 0x3452 <prvSwitchTimerLists+0x68>
            {
                listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xReloadTime );
    343a:	9b 83       	std	Y+3, r25	; 0x03
    343c:	8a 83       	std	Y+2, r24	; 0x02
                listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
    343e:	d9 87       	std	Y+9, r29	; 0x09
    3440:	c8 87       	std	Y+8, r28	; 0x08
                vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
    3442:	b8 01       	movw	r22, r16
    3444:	80 91 0a 05 	lds	r24, 0x050A	; 0x80050a <pxCurrentTimerList>
    3448:	90 91 0b 05 	lds	r25, 0x050B	; 0x80050b <pxCurrentTimerList+0x1>
    344c:	0e 94 df 1c 	call	0x39be	; 0x39be <vListInsert>
    3450:	d2 cf       	rjmp	.-92     	; 0x33f6 <prvSwitchTimerLists+0xc>
            }
            else
            {
                xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY );
    3452:	00 e0       	ldi	r16, 0x00	; 0
    3454:	10 e0       	ldi	r17, 0x00	; 0
    3456:	20 e0       	ldi	r18, 0x00	; 0
    3458:	30 e0       	ldi	r19, 0x00	; 0
    345a:	a7 01       	movw	r20, r14
    345c:	60 e0       	ldi	r22, 0x00	; 0
    345e:	ce 01       	movw	r24, r28
    3460:	0e 94 b6 19 	call	0x336c	; 0x336c <xTimerGenericCommand>
    3464:	c8 cf       	rjmp	.-112    	; 0x33f6 <prvSwitchTimerLists+0xc>
            mtCOVERAGE_TEST_MARKER();
        }
    }

    pxTemp = pxCurrentTimerList;
    pxCurrentTimerList = pxOverflowTimerList;
    3466:	80 91 08 05 	lds	r24, 0x0508	; 0x800508 <pxOverflowTimerList>
    346a:	90 91 09 05 	lds	r25, 0x0509	; 0x800509 <pxOverflowTimerList+0x1>
    346e:	90 93 0b 05 	sts	0x050B, r25	; 0x80050b <pxCurrentTimerList+0x1>
    3472:	80 93 0a 05 	sts	0x050A, r24	; 0x80050a <pxCurrentTimerList>
    pxOverflowTimerList = pxTemp;
    3476:	f0 93 09 05 	sts	0x0509, r31	; 0x800509 <pxOverflowTimerList+0x1>
    347a:	e0 93 08 05 	sts	0x0508, r30	; 0x800508 <pxOverflowTimerList>
}
    347e:	df 91       	pop	r29
    3480:	cf 91       	pop	r28
    3482:	1f 91       	pop	r17
    3484:	0f 91       	pop	r16
    3486:	ff 90       	pop	r15
    3488:	ef 90       	pop	r14
    348a:	08 95       	ret

0000348c <prvTimerTask>:
    pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
}
/*-----------------------------------------------------------*/

static portTASK_FUNCTION( prvTimerTask, pvParameters )
{
    348c:	cf 93       	push	r28
    348e:	df 93       	push	r29
    3490:	00 d0       	rcall	.+0      	; 0x3492 <prvTimerTask+0x6>
    3492:	00 d0       	rcall	.+0      	; 0x3494 <prvTimerTask+0x8>
    3494:	1f 92       	push	r1
    3496:	cd b7       	in	r28, 0x3d	; 61
    3498:	de b7       	in	r29, 0x3e	; 62
    the timer with the nearest expiry time will expire.  If there are no
    active timers then just set the next expire time to 0.  That will cause
    this task to unblock when the tick count overflows, at which point the
    timer lists will be switched and the next expiry time can be
    re-assessed.  */
    *pxListWasEmpty = listLIST_IS_EMPTY( pxCurrentTimerList );
    349a:	e0 91 0a 05 	lds	r30, 0x050A	; 0x80050a <pxCurrentTimerList>
    349e:	f0 91 0b 05 	lds	r31, 0x050B	; 0x80050b <pxCurrentTimerList+0x1>
    34a2:	d0 80       	ld	r13, Z
    if( *pxListWasEmpty == pdFALSE )
    34a4:	dd 20       	and	r13, r13
    34a6:	31 f0       	breq	.+12     	; 0x34b4 <prvTimerTask+0x28>
    {
        xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
    34a8:	05 80       	ldd	r0, Z+5	; 0x05
    34aa:	f6 81       	ldd	r31, Z+6	; 0x06
    34ac:	e0 2d       	mov	r30, r0
    34ae:	e0 80       	ld	r14, Z
    34b0:	f1 80       	ldd	r15, Z+1	; 0x01
    34b2:	02 c0       	rjmp	.+4      	; 0x34b8 <prvTimerTask+0x2c>
    }
    else
    {
        /* Ensure the task unblocks when the tick count rolls over. */
        xNextExpireTime = ( TickType_t ) 0U;
    34b4:	e1 2c       	mov	r14, r1
    34b6:	f1 2c       	mov	r15, r1
static void prvProcessTimerOrBlockTask( const TickType_t xNextExpireTime, BaseType_t xListWasEmpty )
{
TickType_t xTimeNow;
BaseType_t xTimerListsWereSwitched;

    vTaskSuspendAll();
    34b8:	0e 94 8f 16 	call	0x2d1e	; 0x2d1e <vTaskSuspendAll>
static TickType_t prvSampleTimeNow( BaseType_t * const pxTimerListsWereSwitched )
{
TickType_t xTimeNow;
PRIVILEGED_DATA static TickType_t xLastTime = ( TickType_t ) 0U; /*lint !e956 Variable is only accessible to one task. */

    xTimeNow = xTaskGetTickCount();
    34bc:	0e 94 95 16 	call	0x2d2a	; 0x2d2a <xTaskGetTickCount>
    34c0:	8c 01       	movw	r16, r24

    if( xTimeNow < xLastTime )
    34c2:	80 91 02 05 	lds	r24, 0x0502	; 0x800502 <xLastTime.2412>
    34c6:	90 91 03 05 	lds	r25, 0x0503	; 0x800503 <xLastTime.2412+0x1>
    34ca:	08 17       	cp	r16, r24
    34cc:	19 07       	cpc	r17, r25
    34ce:	20 f4       	brcc	.+8      	; 0x34d8 <prvTimerTask+0x4c>
    {
        prvSwitchTimerLists();
    34d0:	0e 94 f5 19 	call	0x33ea	; 0x33ea <prvSwitchTimerLists>
        *pxTimerListsWereSwitched = pdTRUE;
    34d4:	81 e0       	ldi	r24, 0x01	; 1
    34d6:	01 c0       	rjmp	.+2      	; 0x34da <prvTimerTask+0x4e>
    }
    else
    {
        *pxTimerListsWereSwitched = pdFALSE;
    34d8:	80 e0       	ldi	r24, 0x00	; 0
    }

    xLastTime = xTimeNow;
    34da:	10 93 03 05 	sts	0x0503, r17	; 0x800503 <xLastTime.2412+0x1>
    34de:	00 93 02 05 	sts	0x0502, r16	; 0x800502 <xLastTime.2412>
        has expired or not.  If obtaining the time causes the lists to switch
        then don't process this timer as any timers that remained in the list
        when the lists were switched will have been processed within the
        prvSampleTimeNow() function. */
        xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
        if( xTimerListsWereSwitched == pdFALSE )
    34e2:	81 11       	cpse	r24, r1
    34e4:	55 c0       	rjmp	.+170    	; 0x3590 <prvTimerTask+0x104>
        {
            /* The tick count has not overflowed, has the timer expired? */
            if( ( xListWasEmpty == pdFALSE ) && ( xNextExpireTime <= xTimeNow ) )
    34e6:	dd 20       	and	r13, r13
    34e8:	d9 f1       	breq	.+118    	; 0x3560 <prvTimerTask+0xd4>
    34ea:	0e 15       	cp	r16, r14
    34ec:	1f 05       	cpc	r17, r15
    34ee:	08 f4       	brcc	.+2      	; 0x34f2 <prvTimerTask+0x66>
    34f0:	3e c0       	rjmp	.+124    	; 0x356e <prvTimerTask+0xe2>
            {
                ( void ) xTaskResumeAll();
    34f2:	0e 94 4b 17 	call	0x2e96	; 0x2e96 <xTaskResumeAll>
/*-----------------------------------------------------------*/

static void prvProcessExpiredTimer( const TickType_t xNextExpireTime, const TickType_t xTimeNow )
{
BaseType_t xResult;
Timer_t * const pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList ); /*lint !e9087 !e9079 void * is used as this macro is used with tasks and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    34f6:	e0 91 0a 05 	lds	r30, 0x050A	; 0x80050a <pxCurrentTimerList>
    34fa:	f0 91 0b 05 	lds	r31, 0x050B	; 0x80050b <pxCurrentTimerList+0x1>
    34fe:	05 80       	ldd	r0, Z+5	; 0x05
    3500:	f6 81       	ldd	r31, Z+6	; 0x06
    3502:	e0 2d       	mov	r30, r0
    3504:	c6 80       	ldd	r12, Z+6	; 0x06
    3506:	d7 80       	ldd	r13, Z+7	; 0x07

    /* Remove the timer from the list of active timers.  A check has already
    been performed to ensure the list is not empty. */
    ( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
    3508:	c6 01       	movw	r24, r12
    350a:	02 96       	adiw	r24, 0x02	; 2
    350c:	0e 94 17 1d 	call	0x3a2e	; 0x3a2e <uxListRemove>
    traceTIMER_EXPIRED( pxTimer );

    /* If the timer is an auto reload timer then calculate the next
    expiry time and re-insert the timer in the list of active timers. */
    if( ( pxTimer->ucStatus & tmrSTATUS_IS_AUTORELOAD ) != 0 )
    3510:	d6 01       	movw	r26, r12
    3512:	52 96       	adiw	r26, 0x12	; 18
    3514:	8c 91       	ld	r24, X
    3516:	52 97       	sbiw	r26, 0x12	; 18
    3518:	82 ff       	sbrs	r24, 2
    351a:	17 c0       	rjmp	.+46     	; 0x354a <prvTimerTask+0xbe>
    {
        /* The timer is inserted into a list using a time relative to anything
        other than the current time.  It will therefore be inserted into the
        correct list relative to the time this task thinks it is now. */
        if( prvInsertTimerInActiveList( pxTimer, ( xNextExpireTime + pxTimer->xTimerPeriodInTicks ), xTimeNow, xNextExpireTime ) != pdFALSE )
    351c:	1c 96       	adiw	r26, 0x0c	; 12
    351e:	6d 91       	ld	r22, X+
    3520:	7c 91       	ld	r23, X
    3522:	1d 97       	sbiw	r26, 0x0d	; 13
    3524:	6e 0d       	add	r22, r14
    3526:	7f 1d       	adc	r23, r15
    3528:	97 01       	movw	r18, r14
    352a:	a8 01       	movw	r20, r16
    352c:	c6 01       	movw	r24, r12
    352e:	0e 94 6c 19 	call	0x32d8	; 0x32d8 <prvInsertTimerInActiveList>
    3532:	88 23       	and	r24, r24
    3534:	69 f0       	breq	.+26     	; 0x3550 <prvTimerTask+0xc4>
        {
            /* The timer expired before it was added to the active timer
            list.  Reload it now.  */
            xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY );
    3536:	00 e0       	ldi	r16, 0x00	; 0
    3538:	10 e0       	ldi	r17, 0x00	; 0
    353a:	20 e0       	ldi	r18, 0x00	; 0
    353c:	30 e0       	ldi	r19, 0x00	; 0
    353e:	a7 01       	movw	r20, r14
    3540:	60 e0       	ldi	r22, 0x00	; 0
    3542:	c6 01       	movw	r24, r12
    3544:	0e 94 b6 19 	call	0x336c	; 0x336c <xTimerGenericCommand>
    3548:	03 c0       	rjmp	.+6      	; 0x3550 <prvTimerTask+0xc4>
            mtCOVERAGE_TEST_MARKER();
        }
    }
    else
    {
        pxTimer->ucStatus &= ~tmrSTATUS_IS_ACTIVE;
    354a:	8e 7f       	andi	r24, 0xFE	; 254
    354c:	f6 01       	movw	r30, r12
    354e:	82 8b       	std	Z+18, r24	; 0x12
        mtCOVERAGE_TEST_MARKER();
    }

    /* Call the timer callback. */
    pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
    3550:	d6 01       	movw	r26, r12
    3552:	50 96       	adiw	r26, 0x10	; 16
    3554:	ed 91       	ld	r30, X+
    3556:	fc 91       	ld	r31, X
    3558:	51 97       	sbiw	r26, 0x11	; 17
    355a:	c6 01       	movw	r24, r12
    355c:	09 95       	icall
    355e:	1e c0       	rjmp	.+60     	; 0x359c <prvTimerTask+0x110>
                case when the current timer list is empty. */
                if( xListWasEmpty != pdFALSE )
                {
                    /* The current timer list is empty - is the overflow list
                    also empty? */
                    xListWasEmpty = listLIST_IS_EMPTY( pxOverflowTimerList );
    3560:	e0 91 08 05 	lds	r30, 0x0508	; 0x800508 <pxOverflowTimerList>
    3564:	f0 91 09 05 	lds	r31, 0x0509	; 0x800509 <pxOverflowTimerList+0x1>
    3568:	80 81       	ld	r24, Z
    356a:	41 e0       	ldi	r20, 0x01	; 1
    356c:	81 11       	cpse	r24, r1
        prvSampleTimeNow() function. */
        xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
        if( xTimerListsWereSwitched == pdFALSE )
        {
            /* The tick count has not overflowed, has the timer expired? */
            if( ( xListWasEmpty == pdFALSE ) && ( xNextExpireTime <= xTimeNow ) )
    356e:	40 e0       	ldi	r20, 0x00	; 0
                    /* The current timer list is empty - is the overflow list
                    also empty? */
                    xListWasEmpty = listLIST_IS_EMPTY( pxOverflowTimerList );
                }

                vQueueWaitForMessageRestricted( xTimerQueue, ( xNextExpireTime - xTimeNow ), xListWasEmpty );
    3570:	b7 01       	movw	r22, r14
    3572:	60 1b       	sub	r22, r16
    3574:	71 0b       	sbc	r23, r17
    3576:	80 91 06 05 	lds	r24, 0x0506	; 0x800506 <xTimerQueue>
    357a:	90 91 07 05 	lds	r25, 0x0507	; 0x800507 <xTimerQueue+0x1>
    357e:	0e 94 0c 21 	call	0x4218	; 0x4218 <vQueueWaitForMessageRestricted>

                if( xTaskResumeAll() == pdFALSE )
    3582:	0e 94 4b 17 	call	0x2e96	; 0x2e96 <xTaskResumeAll>
    3586:	81 11       	cpse	r24, r1
    3588:	09 c0       	rjmp	.+18     	; 0x359c <prvTimerTask+0x110>
                {
                    /* Yield to wait for either a command to arrive, or the
                    block time to expire.  If a command arrived between the
                    critical section being exited and this yield then the yield
                    will not cause the task to block. */
                    portYIELD_WITHIN_API();
    358a:	0e 94 df 1d 	call	0x3bbe	; 0x3bbe <vPortYield>
    358e:	06 c0       	rjmp	.+12     	; 0x359c <prvTimerTask+0x110>
                }
            }
        }
        else
        {
            ( void ) xTaskResumeAll();
    3590:	0e 94 4b 17 	call	0x2e96	; 0x2e96 <xTaskResumeAll>
    3594:	03 c0       	rjmp	.+6      	; 0x359c <prvTimerTask+0x110>
        }
        #endif /* INCLUDE_xTimerPendFunctionCall */

        /* Commands that are positive are timer commands rather than pended
        function calls. */
        if( xMessage.xMessageID >= ( BaseType_t ) 0 )
    3596:	89 81       	ldd	r24, Y+1	; 0x01
    3598:	87 ff       	sbrs	r24, 7
    359a:	0e c0       	rjmp	.+28     	; 0x35b8 <prvTimerTask+0x12c>
DaemonTaskMessage_t xMessage;
Timer_t *pxTimer;
BaseType_t xTimerListsWereSwitched, xResult;
TickType_t xTimeNow;

    while( xQueueReceive( xTimerQueue, &xMessage, tmrNO_DELAY ) != pdFAIL ) /*lint !e603 xMessage does not have to be initialised as it is passed out, not in, and it is not used unless xQueueReceive() returns pdTRUE. */
    359c:	40 e0       	ldi	r20, 0x00	; 0
    359e:	50 e0       	ldi	r21, 0x00	; 0
    35a0:	be 01       	movw	r22, r28
    35a2:	6f 5f       	subi	r22, 0xFF	; 255
    35a4:	7f 4f       	sbci	r23, 0xFF	; 255
    35a6:	80 91 06 05 	lds	r24, 0x0506	; 0x800506 <xTimerQueue>
    35aa:	90 91 07 05 	lds	r25, 0x0507	; 0x800507 <xTimerQueue+0x1>
    35ae:	0e 94 7a 20 	call	0x40f4	; 0x40f4 <xQueueReceive>
    35b2:	81 11       	cpse	r24, r1
    35b4:	f0 cf       	rjmp	.-32     	; 0x3596 <prvTimerTask+0x10a>
    35b6:	71 cf       	rjmp	.-286    	; 0x349a <prvTimerTask+0xe>
        function calls. */
        if( xMessage.xMessageID >= ( BaseType_t ) 0 )
        {
            /* The messages uses the xTimerParameters member to work on a
            software timer. */
            pxTimer = xMessage.u.xTimerParameters.pxTimer;
    35b8:	ec 80       	ldd	r14, Y+4	; 0x04
    35ba:	fd 80       	ldd	r15, Y+5	; 0x05

        if( listIS_CONTAINED_WITHIN( NULL, &( pxTimer->xTimerListItem ) ) == pdFALSE ) /*lint !e961. The cast is only redundant when NULL is passed into the macro. */
    35bc:	f7 01       	movw	r30, r14
    35be:	82 85       	ldd	r24, Z+10	; 0x0a
    35c0:	93 85       	ldd	r25, Z+11	; 0x0b
    35c2:	89 2b       	or	r24, r25
    35c4:	21 f0       	breq	.+8      	; 0x35ce <prvTimerTask+0x142>
            {
                /* The timer is in a list, remove it. */
                ( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
    35c6:	c7 01       	movw	r24, r14
    35c8:	02 96       	adiw	r24, 0x02	; 2
    35ca:	0e 94 17 1d 	call	0x3a2e	; 0x3a2e <uxListRemove>
static TickType_t prvSampleTimeNow( BaseType_t * const pxTimerListsWereSwitched )
{
TickType_t xTimeNow;
PRIVILEGED_DATA static TickType_t xLastTime = ( TickType_t ) 0U; /*lint !e956 Variable is only accessible to one task. */

    xTimeNow = xTaskGetTickCount();
    35ce:	0e 94 95 16 	call	0x2d2a	; 0x2d2a <xTaskGetTickCount>
    35d2:	6c 01       	movw	r12, r24

    if( xTimeNow < xLastTime )
    35d4:	80 91 02 05 	lds	r24, 0x0502	; 0x800502 <xLastTime.2412>
    35d8:	90 91 03 05 	lds	r25, 0x0503	; 0x800503 <xLastTime.2412+0x1>
    35dc:	c8 16       	cp	r12, r24
    35de:	d9 06       	cpc	r13, r25
    35e0:	10 f4       	brcc	.+4      	; 0x35e6 <prvTimerTask+0x15a>
    {
        prvSwitchTimerLists();
    35e2:	0e 94 f5 19 	call	0x33ea	; 0x33ea <prvSwitchTimerLists>
    else
    {
        *pxTimerListsWereSwitched = pdFALSE;
    }

    xLastTime = xTimeNow;
    35e6:	d0 92 03 05 	sts	0x0503, r13	; 0x800503 <xLastTime.2412+0x1>
    35ea:	c0 92 02 05 	sts	0x0502, r12	; 0x800502 <xLastTime.2412>
            possibility of a higher priority task adding a message to the message
            queue with a time that is ahead of the timer daemon task (because it
            pre-empted the timer daemon task after the xTimeNow value was set). */
            xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );

            switch( xMessage.xMessageID )
    35ee:	e9 81       	ldd	r30, Y+1	; 0x01
    35f0:	0e 2e       	mov	r0, r30
    35f2:	00 0c       	add	r0, r0
    35f4:	ff 0b       	sbc	r31, r31
    35f6:	ea 30       	cpi	r30, 0x0A	; 10
    35f8:	f1 05       	cpc	r31, r1
    35fa:	80 f6       	brcc	.-96     	; 0x359c <prvTimerTask+0x110>
    35fc:	ec 5c       	subi	r30, 0xCC	; 204
    35fe:	ff 4f       	sbci	r31, 0xFF	; 255
    3600:	d7 01       	movw	r26, r14
    3602:	52 96       	adiw	r26, 0x12	; 18
    3604:	8c 91       	ld	r24, X
    3606:	0c 94 82 21 	jmp	0x4304	; 0x4304 <__tablejump2__>
                case tmrCOMMAND_START_FROM_ISR :
                case tmrCOMMAND_RESET :
                case tmrCOMMAND_RESET_FROM_ISR :
                case tmrCOMMAND_START_DONT_TRACE :
                    /* Start or restart a timer. */
                    pxTimer->ucStatus |= tmrSTATUS_IS_ACTIVE;
    360a:	81 60       	ori	r24, 0x01	; 1
    360c:	f7 01       	movw	r30, r14
    360e:	82 8b       	std	Z+18, r24	; 0x12
                    if( prvInsertTimerInActiveList( pxTimer,  xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, xTimeNow, xMessage.u.xTimerParameters.xMessageValue ) != pdFALSE )
    3610:	2a 81       	ldd	r18, Y+2	; 0x02
    3612:	3b 81       	ldd	r19, Y+3	; 0x03
    3614:	64 85       	ldd	r22, Z+12	; 0x0c
    3616:	75 85       	ldd	r23, Z+13	; 0x0d
    3618:	62 0f       	add	r22, r18
    361a:	73 1f       	adc	r23, r19
    361c:	a6 01       	movw	r20, r12
    361e:	c7 01       	movw	r24, r14
    3620:	0e 94 6c 19 	call	0x32d8	; 0x32d8 <prvInsertTimerInActiveList>
    3624:	88 23       	and	r24, r24
    3626:	09 f4       	brne	.+2      	; 0x362a <prvTimerTask+0x19e>
    3628:	b9 cf       	rjmp	.-142    	; 0x359c <prvTimerTask+0x110>
                    {
                        /* The timer expired before it was added to the active
                        timer list.  Process it now. */
                        pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
    362a:	d7 01       	movw	r26, r14
    362c:	50 96       	adiw	r26, 0x10	; 16
    362e:	ed 91       	ld	r30, X+
    3630:	fc 91       	ld	r31, X
    3632:	51 97       	sbiw	r26, 0x11	; 17
    3634:	c7 01       	movw	r24, r14
    3636:	09 95       	icall
                        traceTIMER_EXPIRED( pxTimer );

                        if( ( pxTimer->ucStatus & tmrSTATUS_IS_AUTORELOAD ) != 0 )
    3638:	f7 01       	movw	r30, r14
    363a:	82 89       	ldd	r24, Z+18	; 0x12
    363c:	82 ff       	sbrs	r24, 2
    363e:	ae cf       	rjmp	.-164    	; 0x359c <prvTimerTask+0x110>
                        {
                            xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, NULL, tmrNO_DELAY );
    3640:	4a 81       	ldd	r20, Y+2	; 0x02
    3642:	5b 81       	ldd	r21, Y+3	; 0x03
    3644:	84 85       	ldd	r24, Z+12	; 0x0c
    3646:	95 85       	ldd	r25, Z+13	; 0x0d
    3648:	48 0f       	add	r20, r24
    364a:	59 1f       	adc	r21, r25
    364c:	00 e0       	ldi	r16, 0x00	; 0
    364e:	10 e0       	ldi	r17, 0x00	; 0
    3650:	20 e0       	ldi	r18, 0x00	; 0
    3652:	30 e0       	ldi	r19, 0x00	; 0
    3654:	60 e0       	ldi	r22, 0x00	; 0
    3656:	c7 01       	movw	r24, r14
    3658:	0e 94 b6 19 	call	0x336c	; 0x336c <xTimerGenericCommand>
    365c:	9f cf       	rjmp	.-194    	; 0x359c <prvTimerTask+0x110>
                    pxTimer->ucStatus &= ~tmrSTATUS_IS_ACTIVE;
                    break;

                case tmrCOMMAND_CHANGE_PERIOD :
                case tmrCOMMAND_CHANGE_PERIOD_FROM_ISR :
                    pxTimer->ucStatus |= tmrSTATUS_IS_ACTIVE;
    365e:	81 60       	ori	r24, 0x01	; 1
    3660:	f7 01       	movw	r30, r14
    3662:	82 8b       	std	Z+18, r24	; 0x12
                    pxTimer->xTimerPeriodInTicks = xMessage.u.xTimerParameters.xMessageValue;
    3664:	6a 81       	ldd	r22, Y+2	; 0x02
    3666:	7b 81       	ldd	r23, Y+3	; 0x03
    3668:	75 87       	std	Z+13, r23	; 0x0d
    366a:	64 87       	std	Z+12, r22	; 0x0c
                    be longer or shorter than the old one.  The command time is
                    therefore set to the current time, and as the period cannot
                    be zero the next expiry time can only be in the future,
                    meaning (unlike for the xTimerStart() case above) there is
                    no fail case that needs to be handled here. */
                    ( void ) prvInsertTimerInActiveList( pxTimer, ( xTimeNow + pxTimer->xTimerPeriodInTicks ), xTimeNow, xTimeNow );
    366c:	6c 0d       	add	r22, r12
    366e:	7d 1d       	adc	r23, r13
    3670:	96 01       	movw	r18, r12
    3672:	a6 01       	movw	r20, r12
    3674:	c7 01       	movw	r24, r14
    3676:	0e 94 6c 19 	call	0x32d8	; 0x32d8 <prvInsertTimerInActiveList>
    367a:	90 cf       	rjmp	.-224    	; 0x359c <prvTimerTask+0x110>
                    #if ( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
                    {
                    /* The timer has already been removed from the active list,
                    just free up the memory if the memory was dynamically
                    allocated. */
                        if( ( pxTimer->ucStatus & tmrSTATUS_IS_STATICALLY_ALLOCATED ) == ( uint8_t ) 0 )
    367c:	81 fd       	sbrc	r24, 1
    367e:	04 c0       	rjmp	.+8      	; 0x3688 <prvTimerTask+0x1fc>
                        {
                            vPortFree( pxTimer );
    3680:	c7 01       	movw	r24, r14
    3682:	0e 94 9b 1c 	call	0x3936	; 0x3936 <vPortFree>
    3686:	8a cf       	rjmp	.-236    	; 0x359c <prvTimerTask+0x110>
                        }
                        else
                        {
                            pxTimer->ucStatus &= ~tmrSTATUS_IS_ACTIVE;
    3688:	8e 7f       	andi	r24, 0xFE	; 254
    368a:	d7 01       	movw	r26, r14
    368c:	52 96       	adiw	r26, 0x12	; 18
    368e:	8c 93       	st	X, r24
    3690:	85 cf       	rjmp	.-246    	; 0x359c <prvTimerTask+0x110>

00003692 <initVariant>:
{
#if defined(USBCON)
    USBDevice.attach();
#endif

    setup();        // the normal Arduino setup() function is run here.
    3692:	0e 94 2b 07 	call	0xe56	; 0xe56 <setup>
    vTaskStartScheduler(); // initialise and run the freeRTOS scheduler. Execution should never return here.
    3696:	0e 94 61 16 	call	0x2cc2	; 0x2cc2 <vTaskStartScheduler>
    369a:	08 95       	ret

0000369c <vApplicationIdleHook>:
 */
void vApplicationIdleHook( void ) __attribute__((weak));

void vApplicationIdleHook( void )
{
    loop();        // the normal Arduino loop() function is run here.
    369c:	0e 94 97 07 	call	0xf2e	; 0xf2e <loop>
    if (serialEventRun) serialEventRun();
    36a0:	83 e2       	ldi	r24, 0x23	; 35
    36a2:	9e e0       	ldi	r25, 0x0E	; 14
    36a4:	89 2b       	or	r24, r25
    36a6:	11 f0       	breq	.+4      	; 0x36ac <vApplicationIdleHook+0x10>
    36a8:	0c 94 23 0e 	jmp	0x1c46	; 0x1c46 <_Z14serialEventRunv>
    36ac:	08 95       	ret

000036ae <vApplicationMallocFailedHook>:
#elif defined(__AVR_ATmega644P__) || defined(__AVR_ATmega644PA__) || defined(__AVR_ATmega1284P__) || defined(__AVR_ATmega1284PA__) // Seeed Goldilocks with 1284p
    DDRB  |= _BV(DDB7);
    PORTB |= _BV(PORTB7);       // Main (red PB7) LED on. Main LED on.

#elif defined(__AVR_ATmega328P__) || defined(__AVR_ATmega168__) || defined(__AVR_ATmega8__) // assume we're using an Arduino Uno with 328p
    DDRB  |= _BV(DDB5);
    36ae:	25 9a       	sbi	0x04, 5	; 4
    PORTB |= _BV(PORTB5);       // Main (red PB5) LED on. Main LED on.
    36b0:	2d 9a       	sbi	0x05, 5	; 5
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    36b2:	2f ef       	ldi	r18, 0xFF	; 255
    36b4:	80 e7       	ldi	r24, 0x70	; 112
    36b6:	92 e0       	ldi	r25, 0x02	; 2
    36b8:	21 50       	subi	r18, 0x01	; 1
    36ba:	80 40       	sbci	r24, 0x00	; 0
    36bc:	90 40       	sbci	r25, 0x00	; 0
    36be:	e1 f7       	brne	.-8      	; 0x36b8 <vApplicationMallocFailedHook+0xa>
    36c0:	00 c0       	rjmp	.+0      	; 0x36c2 <vApplicationMallocFailedHook+0x14>
    36c2:	00 00       	nop

#elif defined(__AVR_ATmega644P__) || defined(__AVR_ATmega644PA__) || defined(__AVR_ATmega1284P__) || defined(__AVR_ATmega1284PA__) // Seeed Goldilocks with 1284p
        PINB  |= _BV(PINB7);       // Main (red PB7) LED toggle. Main LED fast blink.

#elif defined(__AVR_ATmega328P__) || defined(__AVR_ATmega168__) || defined(__AVR_ATmega8__) // assume we're using an Arduino Uno with 328p
        PINB  |= _BV(PINB5);       // Main (red PB5) LED toggle. Main LED fast blink.
    36c4:	1d 9a       	sbi	0x03, 5	; 3
    36c6:	f5 cf       	rjmp	.-22     	; 0x36b2 <vApplicationMallocFailedHook+0x4>

000036c8 <vApplicationStackOverflowHook>:
#elif defined(__AVR_ATmega644P__) || defined(__AVR_ATmega644PA__) || defined(__AVR_ATmega1284P__) || defined(__AVR_ATmega1284PA__) // Seeed Goldilocks with 1284p
    DDRB  |= _BV(DDB7);
    PORTB |= _BV(PORTB7);       // Main (red PB7) LED on. Main LED on.

#elif defined(__AVR_ATmega328P__) || defined(__AVR_ATmega168__) || defined(__AVR_ATmega8__) // assume we're using an Arduino Uno with 328p
    DDRB  |= _BV(DDB5);
    36c8:	25 9a       	sbi	0x04, 5	; 4
    PORTB |= _BV(PORTB5);       // Main (red PB5) LED on. Main LED on.
    36ca:	2d 9a       	sbi	0x05, 5	; 5
    36cc:	2f ef       	ldi	r18, 0xFF	; 255
    36ce:	87 ea       	ldi	r24, 0xA7	; 167
    36d0:	91 e6       	ldi	r25, 0x61	; 97
    36d2:	21 50       	subi	r18, 0x01	; 1
    36d4:	80 40       	sbci	r24, 0x00	; 0
    36d6:	90 40       	sbci	r25, 0x00	; 0
    36d8:	e1 f7       	brne	.-8      	; 0x36d2 <vApplicationStackOverflowHook+0xa>
    36da:	00 c0       	rjmp	.+0      	; 0x36dc <vApplicationStackOverflowHook+0x14>
    36dc:	00 00       	nop

#elif defined(__AVR_ATmega644P__) || defined(__AVR_ATmega644PA__) || defined(__AVR_ATmega1284P__) || defined(__AVR_ATmega1284PA__) // Seeed Goldilocks with 1284p
        PINB  |= _BV(PINB7);       // Main (red PB7) LED toggle. Main LED slow blink.

#elif defined(__AVR_ATmega328P__) || defined(__AVR_ATmega168__) || defined(__AVR_ATmega8__) // assume we're using an Arduino Uno with 328p
        PINB  |= _BV(PINB5);       // Main (red PB5) LED toggle. Main LED slow blink.
    36de:	1d 9a       	sbi	0x03, 5	; 3
    36e0:	f5 cf       	rjmp	.-22     	; 0x36cc <vApplicationStackOverflowHook+0x4>

000036e2 <_ZN14FreqCountClass5beginEj>:
static uint16_t gate_index;


void FreqCountClass::begin(uint16_t msec)
{
	if (msec < 1) return;
    36e2:	00 97       	sbiw	r24, 0x00	; 0
    36e4:	09 f4       	brne	.+2      	; 0x36e8 <_ZN14FreqCountClass5beginEj+0x6>
    36e6:	74 c0       	rjmp	.+232    	; 0x37d0 <L_130_loop+0xc>
	gate_index = 0;
    36e8:	10 92 1f 05 	sts	0x051F, r1	; 0x80051f <_ZL10gate_index+0x1>
    36ec:	10 92 1e 05 	sts	0x051E, r1	; 0x80051e <_ZL10gate_index>
	count_msw = 0;
    36f0:	10 92 2c 05 	sts	0x052C, r1	; 0x80052c <_ZL9count_msw+0x1>
    36f4:	10 92 2b 05 	sts	0x052B, r1	; 0x80052b <_ZL9count_msw>
	count_prev = 0;
    36f8:	10 92 27 05 	sts	0x0527, r1	; 0x800527 <_ZL10count_prev>
    36fc:	10 92 28 05 	sts	0x0528, r1	; 0x800528 <_ZL10count_prev+0x1>
    3700:	10 92 29 05 	sts	0x0529, r1	; 0x800529 <_ZL10count_prev+0x2>
    3704:	10 92 2a 05 	sts	0x052A, r1	; 0x80052a <_ZL10count_prev+0x3>
	count_ready = 0;
    3708:	10 92 22 05 	sts	0x0522, r1	; 0x800522 <_ZL11count_ready>

static uint8_t saveTCCR1A, saveTCCR1B;

static inline void counter_init(void)
{
	saveTCCR1A = TCCR1A;
    370c:	20 91 80 00 	lds	r18, 0x0080	; 0x800080 <__DATA_REGION_ORIGIN__+0x20>
    3710:	20 93 31 05 	sts	0x0531, r18	; 0x800531 <_ZL10saveTCCR1A>
	saveTCCR1B = TCCR1B;
    3714:	20 91 81 00 	lds	r18, 0x0081	; 0x800081 <__DATA_REGION_ORIGIN__+0x21>
    3718:	20 93 30 05 	sts	0x0530, r18	; 0x800530 <_ZL10saveTCCR1B>
	TCCR1B = 0;
    371c:	10 92 81 00 	sts	0x0081, r1	; 0x800081 <__DATA_REGION_ORIGIN__+0x21>
	TCCR1A = 0;
    3720:	10 92 80 00 	sts	0x0080, r1	; 0x800080 <__DATA_REGION_ORIGIN__+0x20>
	TCNT1 = 0;
    3724:	10 92 85 00 	sts	0x0085, r1	; 0x800085 <__DATA_REGION_ORIGIN__+0x25>
    3728:	10 92 84 00 	sts	0x0084, r1	; 0x800084 <__DATA_REGION_ORIGIN__+0x24>
	TIFR1 = (1<<TOV1);
    372c:	21 e0       	ldi	r18, 0x01	; 1
    372e:	26 bb       	out	0x16, r18	; 22
	TIMSK1 = 0;
    3730:	10 92 6f 00 	sts	0x006F, r1	; 0x80006f <__DATA_REGION_ORIGIN__+0xf>

static inline uint16_t timer_init(uint16_t msec)
{
	uint16_t gate_len;

	saveTCCR2A = TCCR2A;
    3734:	20 91 b0 00 	lds	r18, 0x00B0	; 0x8000b0 <__DATA_REGION_ORIGIN__+0x50>
    3738:	20 93 2f 05 	sts	0x052F, r18	; 0x80052f <_ZL10saveTCCR2A>
	saveTCCR2B = TCCR2B;
    373c:	20 91 b1 00 	lds	r18, 0x00B1	; 0x8000b1 <__DATA_REGION_ORIGIN__+0x51>
    3740:	20 93 2e 05 	sts	0x052E, r18	; 0x80052e <_ZL10saveTCCR2B>
	TCCR2B = 0;
    3744:	10 92 b1 00 	sts	0x00B1, r1	; 0x8000b1 <__DATA_REGION_ORIGIN__+0x51>
	TCCR2A = (1<<WGM21);
    3748:	22 e0       	ldi	r18, 0x02	; 2
    374a:	20 93 b0 00 	sts	0x00B0, r18	; 0x8000b0 <__DATA_REGION_ORIGIN__+0x50>
	if ((msec & 7) == 0) {
    374e:	9c 01       	movw	r18, r24
    3750:	27 70       	andi	r18, 0x07	; 7
    3752:	33 27       	eor	r19, r19
    3754:	23 2b       	or	r18, r19
    3756:	51 f4       	brne	.+20     	; 0x376c <_ZN14FreqCountClass5beginEj+0x8a>
		gate_len = msec >> 3;
    3758:	43 e0       	ldi	r20, 0x03	; 3
    375a:	96 95       	lsr	r25
    375c:	87 95       	ror	r24
    375e:	4a 95       	dec	r20
    3760:	e1 f7       	brne	.-8      	; 0x375a <_ZN14FreqCountClass5beginEj+0x78>
		OCR2A = TIMER2_OCR2A_8MS_VAL;
    3762:	2c e7       	ldi	r18, 0x7C	; 124
    3764:	20 93 b3 00 	sts	0x00B3, r18	; 0x8000b3 <__DATA_REGION_ORIGIN__+0x53>
		startTCCR2B = TIMER2_TCCR2B_8MS_VAL;
    3768:	27 e0       	ldi	r18, 0x07	; 7
    376a:	18 c0       	rjmp	.+48     	; 0x379c <_ZN14FreqCountClass5beginEj+0xba>
	} else if ((msec & 3) == 0) {
    376c:	9c 01       	movw	r18, r24
    376e:	23 70       	andi	r18, 0x03	; 3
    3770:	33 27       	eor	r19, r19
    3772:	23 2b       	or	r18, r19
    3774:	31 f4       	brne	.+12     	; 0x3782 <_ZN14FreqCountClass5beginEj+0xa0>
		gate_len = msec >> 2;
    3776:	96 95       	lsr	r25
    3778:	87 95       	ror	r24
    377a:	96 95       	lsr	r25
    377c:	87 95       	ror	r24
		OCR2A = TIMER2_OCR2A_4MS_VAL;
    377e:	29 ef       	ldi	r18, 0xF9	; 249
    3780:	05 c0       	rjmp	.+10     	; 0x378c <_ZN14FreqCountClass5beginEj+0xaa>
		startTCCR2B = TIMER2_TCCR2B_4MS_VAL;
	} else if ((msec & 1) == 0) {
    3782:	80 fd       	sbrc	r24, 0
    3784:	07 c0       	rjmp	.+14     	; 0x3794 <_ZN14FreqCountClass5beginEj+0xb2>
		gate_len = msec >> 1;
    3786:	96 95       	lsr	r25
    3788:	87 95       	ror	r24
		OCR2A = TIMER2_OCR2A_2MS_VAL;
    378a:	2c e7       	ldi	r18, 0x7C	; 124
    378c:	20 93 b3 00 	sts	0x00B3, r18	; 0x8000b3 <__DATA_REGION_ORIGIN__+0x53>
		startTCCR2B = TIMER2_TCCR2B_2MS_VAL;
    3790:	26 e0       	ldi	r18, 0x06	; 6
    3792:	04 c0       	rjmp	.+8      	; 0x379c <_ZN14FreqCountClass5beginEj+0xba>
	} else {
		gate_len = msec;
		OCR2A = TIMER2_OCR2A_1MS_VAL;
    3794:	2c e7       	ldi	r18, 0x7C	; 124
    3796:	20 93 b3 00 	sts	0x00B3, r18	; 0x8000b3 <__DATA_REGION_ORIGIN__+0x53>
		startTCCR2B = TIMER2_TCCR2B_1MS_VAL;
    379a:	25 e0       	ldi	r18, 0x05	; 5
    379c:	20 93 2d 05 	sts	0x052D, r18	; 0x80052d <_ZL11startTCCR2B>
	}
	TIFR2 = (1<<OCF2A);
    37a0:	22 e0       	ldi	r18, 0x02	; 2
    37a2:	27 bb       	out	0x17, r18	; 23
	TCNT2 = 0;
    37a4:	10 92 b2 00 	sts	0x00B2, r1	; 0x8000b2 <__DATA_REGION_ORIGIN__+0x52>
	counter_init();
	gate_length = timer_init(msec);
    37a8:	90 93 21 05 	sts	0x0521, r25	; 0x800521 <_ZL11gate_length+0x1>
    37ac:	80 93 20 05 	sts	0x0520, r24	; 0x800520 <_ZL11gate_length>
	uint8_t status = SREG;
    37b0:	9f b7       	in	r25, 0x3f	; 63
	cli();
    37b2:	f8 94       	cli
	return gate_len;
}

static inline void timer_start(void)
{
	GTCCR = (1<<PSRASY);
    37b4:	23 bd       	out	0x23, r18	; 35
	TCCR2B = startTCCR2B;
    37b6:	80 91 2d 05 	lds	r24, 0x052D	; 0x80052d <_ZL11startTCCR2B>
    37ba:	80 93 b1 00 	sts	0x00B1, r24	; 0x8000b1 <__DATA_REGION_ORIGIN__+0x51>
	TIMSK2 = (1<<OCIE2A);
    37be:	20 93 70 00 	sts	0x0070, r18	; 0x800070 <__DATA_REGION_ORIGIN__+0x10>
		"L_%=_loop:"
		"subi   %0, 1"		"\n\t"
		"brne   L_%=_loop"	"\n\t"
		: "+d" (cycles_times_3)
		: "0" (cycles_times_3)
	);
    37c2:	8b e0       	ldi	r24, 0x0B	; 11

000037c4 <L_130_loop>:
    37c4:	81 50       	subi	r24, 0x01	; 1
    37c6:	f1 f7       	brne	.-4      	; 0x37c4 <L_130_loop>
	TIMSK1 = 0;
}

static inline void counter_start(void)
{
	TCCR1B = (1<<CS12) | (1<<CS11) | (1<<CS10);
    37c8:	87 e0       	ldi	r24, 0x07	; 7
    37ca:	80 93 81 00 	sts	0x0081, r24	; 0x800081 <__DATA_REGION_ORIGIN__+0x21>
	timer_start();
	timer_isr_latency_delay();
	counter_start();
	SREG = status;
    37ce:	9f bf       	out	0x3f, r25	; 63
    37d0:	08 95       	ret

000037d2 <_ZN14FreqCountClass9availableEv>:
}

uint8_t FreqCountClass::available(void)
{
	return count_ready;
    37d2:	80 91 22 05 	lds	r24, 0x0522	; 0x800522 <_ZL11count_ready>
}
    37d6:	08 95       	ret

000037d8 <_ZN14FreqCountClass4readEv>:
uint32_t FreqCountClass::read(void)
{
	uint32_t count;
	uint8_t status;

	status = SREG;
    37d8:	2f b7       	in	r18, 0x3f	; 63
	cli();
    37da:	f8 94       	cli
	count = count_output;
    37dc:	60 91 23 05 	lds	r22, 0x0523	; 0x800523 <_ZL12count_output>
    37e0:	70 91 24 05 	lds	r23, 0x0524	; 0x800524 <_ZL12count_output+0x1>
    37e4:	80 91 25 05 	lds	r24, 0x0525	; 0x800525 <_ZL12count_output+0x2>
    37e8:	90 91 26 05 	lds	r25, 0x0526	; 0x800526 <_ZL12count_output+0x3>
	count_ready = 0;
    37ec:	10 92 22 05 	sts	0x0522, r1	; 0x800522 <_ZL11count_ready>
	SREG = status;
    37f0:	2f bf       	out	0x3f, r18	; 63
	return count;
}
    37f2:	08 95       	ret

000037f4 <_ZN14FreqCountClass3endEv>:
	TIMSK2 = (1<<OCIE2A);
}

static inline void timer_shutdown(void)
{
	TCCR2B = 0;
    37f4:	e1 eb       	ldi	r30, 0xB1	; 177
    37f6:	f0 e0       	ldi	r31, 0x00	; 0
    37f8:	10 82       	st	Z, r1
	TIMSK2 = 0;
    37fa:	10 92 70 00 	sts	0x0070, r1	; 0x800070 <__DATA_REGION_ORIGIN__+0x10>
	TCCR2A = saveTCCR2A;
    37fe:	80 91 2f 05 	lds	r24, 0x052F	; 0x80052f <_ZL10saveTCCR2A>
    3802:	80 93 b0 00 	sts	0x00B0, r24	; 0x8000b0 <__DATA_REGION_ORIGIN__+0x50>
	TCCR2B = saveTCCR2B;
    3806:	80 91 2e 05 	lds	r24, 0x052E	; 0x80052e <_ZL10saveTCCR2B>
    380a:	80 83       	st	Z, r24
	TCCR1B = (1<<CS12) | (1<<CS11) | (1<<CS10);
}

static inline void counter_shutdown(void)
{
	TCCR1B = 0;
    380c:	e1 e8       	ldi	r30, 0x81	; 129
    380e:	f0 e0       	ldi	r31, 0x00	; 0
    3810:	10 82       	st	Z, r1
	TCCR1A = saveTCCR1A;
    3812:	80 91 31 05 	lds	r24, 0x0531	; 0x800531 <_ZL10saveTCCR1A>
    3816:	80 93 80 00 	sts	0x0080, r24	; 0x800080 <__DATA_REGION_ORIGIN__+0x20>
	TCCR1B = saveTCCR1B;
    381a:	80 91 30 05 	lds	r24, 0x0530	; 0x800530 <_ZL10saveTCCR1B>
    381e:	80 83       	st	Z, r24
    3820:	08 95       	ret

00003822 <__vector_7>:
	counter_shutdown();
}


ISR(TIMER_ISR_VECTOR)
{
    3822:	1f 92       	push	r1
    3824:	0f 92       	push	r0
    3826:	0f b6       	in	r0, 0x3f	; 63
    3828:	0f 92       	push	r0
    382a:	11 24       	eor	r1, r1
    382c:	0f 93       	push	r16
    382e:	1f 93       	push	r17
    3830:	2f 93       	push	r18
    3832:	3f 93       	push	r19
    3834:	4f 93       	push	r20
    3836:	5f 93       	push	r21
    3838:	6f 93       	push	r22
    383a:	7f 93       	push	r23
    383c:	8f 93       	push	r24
    383e:	9f 93       	push	r25
    3840:	af 93       	push	r26
    3842:	bf 93       	push	r27
}

static inline uint16_t counter_read(void)
{
	return TCNT1;
    3844:	20 91 84 00 	lds	r18, 0x0084	; 0x800084 <__DATA_REGION_ORIGIN__+0x24>
    3848:	30 91 85 00 	lds	r19, 0x0085	; 0x800085 <__DATA_REGION_ORIGIN__+0x25>
	uint16_t count_lsw;
	uint32_t count;
	uint16_t index, length;

	count_lsw = counter_read();
	if (counter_overflow()) {
    384c:	b0 9b       	sbis	0x16, 0	; 22
    384e:	0b c0       	rjmp	.+22     	; 0x3866 <__vector_7+0x44>
	return TIFR1 & (1<<TOV1);
}

static inline void counter_overflow_reset(void)
{
	TIFR1 = (1<<TOV1);
    3850:	81 e0       	ldi	r24, 0x01	; 1
    3852:	86 bb       	out	0x16, r24	; 22
		counter_overflow_reset();
		count_msw++;
    3854:	80 91 2b 05 	lds	r24, 0x052B	; 0x80052b <_ZL9count_msw>
    3858:	90 91 2c 05 	lds	r25, 0x052C	; 0x80052c <_ZL9count_msw+0x1>
    385c:	01 96       	adiw	r24, 0x01	; 1
    385e:	90 93 2c 05 	sts	0x052C, r25	; 0x80052c <_ZL9count_msw+0x1>
    3862:	80 93 2b 05 	sts	0x052B, r24	; 0x80052b <_ZL9count_msw>
	}
	index = gate_index + 1;
    3866:	80 91 1e 05 	lds	r24, 0x051E	; 0x80051e <_ZL10gate_index>
    386a:	90 91 1f 05 	lds	r25, 0x051F	; 0x80051f <_ZL10gate_index+0x1>
    386e:	01 96       	adiw	r24, 0x01	; 1
	length = gate_length;
	if (index >= length) {
    3870:	40 91 20 05 	lds	r20, 0x0520	; 0x800520 <_ZL11gate_length>
    3874:	50 91 21 05 	lds	r21, 0x0521	; 0x800521 <_ZL11gate_length+0x1>
    3878:	84 17       	cp	r24, r20
    387a:	95 07       	cpc	r25, r21
    387c:	98 f1       	brcs	.+102    	; 0x38e4 <__vector_7+0xc2>
		gate_index = 0;
    387e:	10 92 1f 05 	sts	0x051F, r1	; 0x80051f <_ZL10gate_index+0x1>
    3882:	10 92 1e 05 	sts	0x051E, r1	; 0x80051e <_ZL10gate_index>
		count = ((uint32_t)count_msw << 16) + count_lsw;
    3886:	80 91 2b 05 	lds	r24, 0x052B	; 0x80052b <_ZL9count_msw>
    388a:	90 91 2c 05 	lds	r25, 0x052C	; 0x80052c <_ZL9count_msw+0x1>
    388e:	a0 e0       	ldi	r26, 0x00	; 0
    3890:	b0 e0       	ldi	r27, 0x00	; 0
    3892:	dc 01       	movw	r26, r24
    3894:	99 27       	eor	r25, r25
    3896:	88 27       	eor	r24, r24
    3898:	82 0f       	add	r24, r18
    389a:	93 1f       	adc	r25, r19
    389c:	a1 1d       	adc	r26, r1
    389e:	b1 1d       	adc	r27, r1
		count_output = count - count_prev;
    38a0:	40 91 27 05 	lds	r20, 0x0527	; 0x800527 <_ZL10count_prev>
    38a4:	50 91 28 05 	lds	r21, 0x0528	; 0x800528 <_ZL10count_prev+0x1>
    38a8:	60 91 29 05 	lds	r22, 0x0529	; 0x800529 <_ZL10count_prev+0x2>
    38ac:	70 91 2a 05 	lds	r23, 0x052A	; 0x80052a <_ZL10count_prev+0x3>
    38b0:	8c 01       	movw	r16, r24
    38b2:	9d 01       	movw	r18, r26
    38b4:	04 1b       	sub	r16, r20
    38b6:	15 0b       	sbc	r17, r21
    38b8:	26 0b       	sbc	r18, r22
    38ba:	37 0b       	sbc	r19, r23
    38bc:	00 93 23 05 	sts	0x0523, r16	; 0x800523 <_ZL12count_output>
    38c0:	10 93 24 05 	sts	0x0524, r17	; 0x800524 <_ZL12count_output+0x1>
    38c4:	20 93 25 05 	sts	0x0525, r18	; 0x800525 <_ZL12count_output+0x2>
    38c8:	30 93 26 05 	sts	0x0526, r19	; 0x800526 <_ZL12count_output+0x3>
		count_prev = count;
    38cc:	80 93 27 05 	sts	0x0527, r24	; 0x800527 <_ZL10count_prev>
    38d0:	90 93 28 05 	sts	0x0528, r25	; 0x800528 <_ZL10count_prev+0x1>
    38d4:	a0 93 29 05 	sts	0x0529, r26	; 0x800529 <_ZL10count_prev+0x2>
    38d8:	b0 93 2a 05 	sts	0x052A, r27	; 0x80052a <_ZL10count_prev+0x3>
		count_ready = 1;
    38dc:	81 e0       	ldi	r24, 0x01	; 1
    38de:	80 93 22 05 	sts	0x0522, r24	; 0x800522 <_ZL11count_ready>
    38e2:	04 c0       	rjmp	.+8      	; 0x38ec <__vector_7+0xca>
		restore_other_interrupts();
	} else {
		if (index == length - 1) disable_other_interrupts();
		gate_index = index;
    38e4:	90 93 1f 05 	sts	0x051F, r25	; 0x80051f <_ZL10gate_index+0x1>
    38e8:	80 93 1e 05 	sts	0x051E, r24	; 0x80051e <_ZL10gate_index>
	}
}
    38ec:	bf 91       	pop	r27
    38ee:	af 91       	pop	r26
    38f0:	9f 91       	pop	r25
    38f2:	8f 91       	pop	r24
    38f4:	7f 91       	pop	r23
    38f6:	6f 91       	pop	r22
    38f8:	5f 91       	pop	r21
    38fa:	4f 91       	pop	r20
    38fc:	3f 91       	pop	r19
    38fe:	2f 91       	pop	r18
    3900:	1f 91       	pop	r17
    3902:	0f 91       	pop	r16
    3904:	0f 90       	pop	r0
    3906:	0f be       	out	0x3f, r0	; 63
    3908:	0f 90       	pop	r0
    390a:	1f 90       	pop	r1
    390c:	18 95       	reti

0000390e <yield>:
 * libraries or sketches that supports cooperative threads.
 *
 * Its defined as a weak symbol and it can be redefined to implement a
 * real cooperative scheduler.
 */
static void __empty() {
    390e:	08 95       	ret

00003910 <pvPortMalloc>:
#if( configSUPPORT_DYNAMIC_ALLOCATION > 0 )

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
    3910:	cf 93       	push	r28
    3912:	df 93       	push	r29
    3914:	ec 01       	movw	r28, r24
void *pvReturn;

    vTaskSuspendAll();
    3916:	0e 94 8f 16 	call	0x2d1e	; 0x2d1e <vTaskSuspendAll>
    {
        pvReturn = malloc( xWantedSize );
    391a:	ce 01       	movw	r24, r28
    391c:	0e 94 b6 21 	call	0x436c	; 0x436c <malloc>
    3920:	ec 01       	movw	r28, r24
        traceMALLOC( pvReturn, xWantedSize );
    }
    ( void ) xTaskResumeAll();
    3922:	0e 94 4b 17 	call	0x2e96	; 0x2e96 <xTaskResumeAll>

    #if( configUSE_MALLOC_FAILED_HOOK == 1 )
    {
        if( pvReturn == NULL )
    3926:	20 97       	sbiw	r28, 0x00	; 0
    3928:	11 f4       	brne	.+4      	; 0x392e <pvPortMalloc+0x1e>
        {
            extern void vApplicationMallocFailedHook( void );
            vApplicationMallocFailedHook();
    392a:	0e 94 57 1b 	call	0x36ae	; 0x36ae <vApplicationMallocFailedHook>
        }
    }
    #endif

    return pvReturn;
}
    392e:	ce 01       	movw	r24, r28
    3930:	df 91       	pop	r29
    3932:	cf 91       	pop	r28
    3934:	08 95       	ret

00003936 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
    3936:	cf 93       	push	r28
    3938:	df 93       	push	r29
    if( pv )
    393a:	00 97       	sbiw	r24, 0x00	; 0
    393c:	51 f0       	breq	.+20     	; 0x3952 <vPortFree+0x1c>
    393e:	ec 01       	movw	r28, r24
    {
        vTaskSuspendAll();
    3940:	0e 94 8f 16 	call	0x2d1e	; 0x2d1e <vTaskSuspendAll>
        {
            free( pv );
    3944:	ce 01       	movw	r24, r28
    3946:	0e 94 4e 22 	call	0x449c	; 0x449c <free>
            traceFREE( pv, 0 );
        }
        ( void ) xTaskResumeAll();
    }
}
    394a:	df 91       	pop	r29
    394c:	cf 91       	pop	r28
        vTaskSuspendAll();
        {
            free( pv );
            traceFREE( pv, 0 );
        }
        ( void ) xTaskResumeAll();
    394e:	0c 94 4b 17 	jmp	0x2e96	; 0x2e96 <xTaskResumeAll>
    }
}
    3952:	df 91       	pop	r29
    3954:	cf 91       	pop	r28
    3956:	08 95       	ret

00003958 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
    3958:	fc 01       	movw	r30, r24
    /* The list structure contains a list item which is used to mark the
    end of the list.  To initialise the list the list end is inserted
    as the only list entry. */
    pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );            /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    395a:	03 96       	adiw	r24, 0x03	; 3
    395c:	92 83       	std	Z+2, r25	; 0x02
    395e:	81 83       	std	Z+1, r24	; 0x01

    /* The list end value is the highest possible value in the list to
    ensure it remains at the end of the list. */
    pxList->xListEnd.xItemValue = portMAX_DELAY;
    3960:	2f ef       	ldi	r18, 0xFF	; 255
    3962:	3f ef       	ldi	r19, 0xFF	; 255
    3964:	34 83       	std	Z+4, r19	; 0x04
    3966:	23 83       	std	Z+3, r18	; 0x03

    /* The list end next and previous pointers point to itself so we know
    when the list is empty. */
    pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );    /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    3968:	96 83       	std	Z+6, r25	; 0x06
    396a:	85 83       	std	Z+5, r24	; 0x05
    pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    396c:	90 87       	std	Z+8, r25	; 0x08
    396e:	87 83       	std	Z+7, r24	; 0x07

    pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
    3970:	10 82       	st	Z, r1
    3972:	08 95       	ret

00003974 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
    /* Make sure the list item is not recorded as being on a list. */
    pxItem->pxContainer = NULL;
    3974:	fc 01       	movw	r30, r24
    3976:	11 86       	std	Z+9, r1	; 0x09
    3978:	10 86       	std	Z+8, r1	; 0x08
    397a:	08 95       	ret

0000397c <vListInsertEnd>:
    listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    397c:	cf 93       	push	r28
    397e:	df 93       	push	r29
    3980:	9c 01       	movw	r18, r24
    3982:	fb 01       	movw	r30, r22
ListItem_t * const pxIndex = pxList->pxIndex;
    3984:	dc 01       	movw	r26, r24
    3986:	11 96       	adiw	r26, 0x01	; 1
    3988:	cd 91       	ld	r28, X+
    398a:	dc 91       	ld	r29, X
    398c:	12 97       	sbiw	r26, 0x02	; 2
    listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

    /* Insert a new list item into pxList, but rather than sort the list,
    makes the new list item the last item to be removed by a call to
    listGET_OWNER_OF_NEXT_ENTRY(). */
    pxNewListItem->pxNext = pxIndex;
    398e:	d3 83       	std	Z+3, r29	; 0x03
    3990:	c2 83       	std	Z+2, r28	; 0x02
    pxNewListItem->pxPrevious = pxIndex->pxPrevious;
    3992:	8c 81       	ldd	r24, Y+4	; 0x04
    3994:	9d 81       	ldd	r25, Y+5	; 0x05
    3996:	95 83       	std	Z+5, r25	; 0x05
    3998:	84 83       	std	Z+4, r24	; 0x04

    /* Only used during decision coverage testing. */
    mtCOVERAGE_TEST_DELAY();

    pxIndex->pxPrevious->pxNext = pxNewListItem;
    399a:	8c 81       	ldd	r24, Y+4	; 0x04
    399c:	9d 81       	ldd	r25, Y+5	; 0x05
    399e:	dc 01       	movw	r26, r24
    39a0:	13 96       	adiw	r26, 0x03	; 3
    39a2:	7c 93       	st	X, r23
    39a4:	6e 93       	st	-X, r22
    39a6:	12 97       	sbiw	r26, 0x02	; 2
    pxIndex->pxPrevious = pxNewListItem;
    39a8:	7d 83       	std	Y+5, r23	; 0x05
    39aa:	6c 83       	std	Y+4, r22	; 0x04

    /* Remember which list the item is in. */
    pxNewListItem->pxContainer = pxList;
    39ac:	31 87       	std	Z+9, r19	; 0x09
    39ae:	20 87       	std	Z+8, r18	; 0x08

    ( pxList->uxNumberOfItems )++;
    39b0:	f9 01       	movw	r30, r18
    39b2:	80 81       	ld	r24, Z
    39b4:	8f 5f       	subi	r24, 0xFF	; 255
    39b6:	80 83       	st	Z, r24
}
    39b8:	df 91       	pop	r29
    39ba:	cf 91       	pop	r28
    39bc:	08 95       	ret

000039be <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    39be:	0f 93       	push	r16
    39c0:	1f 93       	push	r17
    39c2:	cf 93       	push	r28
    39c4:	df 93       	push	r29
    39c6:	8c 01       	movw	r16, r24
    39c8:	fb 01       	movw	r30, r22
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
    39ca:	80 81       	ld	r24, Z
    39cc:	91 81       	ldd	r25, Z+1	; 0x01
    new list item should be placed after it.  This ensures that TCBs which are
    stored in ready lists (all of which have the same xItemValue value) get a
    share of the CPU.  However, if the xItemValue is the same as the back marker
    the iteration loop below will not end.  Therefore the value is checked
    first, and the algorithm slightly modified if necessary. */
    if( xValueOfInsertion == portMAX_DELAY )
    39ce:	8f 3f       	cpi	r24, 0xFF	; 255
    39d0:	2f ef       	ldi	r18, 0xFF	; 255
    39d2:	92 07       	cpc	r25, r18
    39d4:	21 f4       	brne	.+8      	; 0x39de <vListInsert+0x20>
    {
        pxIterator = pxList->xListEnd.pxPrevious;
    39d6:	e8 01       	movw	r28, r16
    39d8:	af 81       	ldd	r26, Y+7	; 0x07
    39da:	b8 85       	ldd	r27, Y+8	; 0x08
    39dc:	0e c0       	rjmp	.+28     	; 0x39fa <vListInsert+0x3c>
            4) Using a queue or semaphore before it has been initialised or
               before the scheduler has been started (are interrupts firing
               before vTaskStartScheduler() has been called?).
        **********************************************************************/

        for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. *//*lint !e440 The iterator moves to a different value, not xValueOfInsertion. */
    39de:	d8 01       	movw	r26, r16
    39e0:	13 96       	adiw	r26, 0x03	; 3
    39e2:	12 96       	adiw	r26, 0x02	; 2
    39e4:	2d 91       	ld	r18, X+
    39e6:	3c 91       	ld	r19, X
    39e8:	13 97       	sbiw	r26, 0x03	; 3
    39ea:	e9 01       	movw	r28, r18
    39ec:	48 81       	ld	r20, Y
    39ee:	59 81       	ldd	r21, Y+1	; 0x01
    39f0:	84 17       	cp	r24, r20
    39f2:	95 07       	cpc	r25, r21
    39f4:	10 f0       	brcs	.+4      	; 0x39fa <vListInsert+0x3c>
    39f6:	d9 01       	movw	r26, r18
    39f8:	f4 cf       	rjmp	.-24     	; 0x39e2 <vListInsert+0x24>
            /* There is nothing to do here, just iterating to the wanted
            insertion position. */
        }
    }

    pxNewListItem->pxNext = pxIterator->pxNext;
    39fa:	12 96       	adiw	r26, 0x02	; 2
    39fc:	8d 91       	ld	r24, X+
    39fe:	9c 91       	ld	r25, X
    3a00:	13 97       	sbiw	r26, 0x03	; 3
    3a02:	93 83       	std	Z+3, r25	; 0x03
    3a04:	82 83       	std	Z+2, r24	; 0x02
    pxNewListItem->pxNext->pxPrevious = pxNewListItem;
    3a06:	ec 01       	movw	r28, r24
    3a08:	fd 83       	std	Y+5, r31	; 0x05
    3a0a:	ec 83       	std	Y+4, r30	; 0x04
    pxNewListItem->pxPrevious = pxIterator;
    3a0c:	b5 83       	std	Z+5, r27	; 0x05
    3a0e:	a4 83       	std	Z+4, r26	; 0x04
    pxIterator->pxNext = pxNewListItem;
    3a10:	13 96       	adiw	r26, 0x03	; 3
    3a12:	fc 93       	st	X, r31
    3a14:	ee 93       	st	-X, r30
    3a16:	12 97       	sbiw	r26, 0x02	; 2

    /* Remember which list the item is in.  This allows fast removal of the
    item later. */
    pxNewListItem->pxContainer = pxList;
    3a18:	11 87       	std	Z+9, r17	; 0x09
    3a1a:	00 87       	std	Z+8, r16	; 0x08

    ( pxList->uxNumberOfItems )++;
    3a1c:	f8 01       	movw	r30, r16
    3a1e:	80 81       	ld	r24, Z
    3a20:	8f 5f       	subi	r24, 0xFF	; 255
    3a22:	80 83       	st	Z, r24
}
    3a24:	df 91       	pop	r29
    3a26:	cf 91       	pop	r28
    3a28:	1f 91       	pop	r17
    3a2a:	0f 91       	pop	r16
    3a2c:	08 95       	ret

00003a2e <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
    3a2e:	cf 93       	push	r28
    3a30:	df 93       	push	r29
    3a32:	fc 01       	movw	r30, r24
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = pxItemToRemove->pxContainer;
    3a34:	a0 85       	ldd	r26, Z+8	; 0x08
    3a36:	b1 85       	ldd	r27, Z+9	; 0x09

    pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    3a38:	82 81       	ldd	r24, Z+2	; 0x02
    3a3a:	93 81       	ldd	r25, Z+3	; 0x03
    3a3c:	24 81       	ldd	r18, Z+4	; 0x04
    3a3e:	35 81       	ldd	r19, Z+5	; 0x05
    3a40:	ec 01       	movw	r28, r24
    3a42:	3d 83       	std	Y+5, r19	; 0x05
    3a44:	2c 83       	std	Y+4, r18	; 0x04
    pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    3a46:	c4 81       	ldd	r28, Z+4	; 0x04
    3a48:	d5 81       	ldd	r29, Z+5	; 0x05
    3a4a:	9b 83       	std	Y+3, r25	; 0x03
    3a4c:	8a 83       	std	Y+2, r24	; 0x02

    /* Only used during decision coverage testing. */
    mtCOVERAGE_TEST_DELAY();

    /* Make sure the index is left pointing to a valid item. */
    if( pxList->pxIndex == pxItemToRemove )
    3a4e:	11 96       	adiw	r26, 0x01	; 1
    3a50:	8d 91       	ld	r24, X+
    3a52:	9c 91       	ld	r25, X
    3a54:	12 97       	sbiw	r26, 0x02	; 2
    3a56:	e8 17       	cp	r30, r24
    3a58:	f9 07       	cpc	r31, r25
    3a5a:	21 f4       	brne	.+8      	; 0x3a64 <uxListRemove+0x36>
    {
        pxList->pxIndex = pxItemToRemove->pxPrevious;
    3a5c:	12 96       	adiw	r26, 0x02	; 2
    3a5e:	dc 93       	st	X, r29
    3a60:	ce 93       	st	-X, r28
    3a62:	11 97       	sbiw	r26, 0x01	; 1
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }

    pxItemToRemove->pxContainer = NULL;
    3a64:	11 86       	std	Z+9, r1	; 0x09
    3a66:	10 86       	std	Z+8, r1	; 0x08
    ( pxList->uxNumberOfItems )--;
    3a68:	8c 91       	ld	r24, X
    3a6a:	81 50       	subi	r24, 0x01	; 1
    3a6c:	8c 93       	st	X, r24

    return pxList->uxNumberOfItems;
    3a6e:	8c 91       	ld	r24, X
}
    3a70:	df 91       	pop	r29
    3a72:	cf 91       	pop	r28
    3a74:	08 95       	ret

00003a76 <pxPortInitialiseStack>:
		);
	}
	else
	{
        uint8_t register temp_reg;
		__asm__ __volatile__ (
    3a76:	31 e1       	ldi	r19, 0x11	; 17
    3a78:	fc 01       	movw	r30, r24
    3a7a:	30 83       	st	Z, r19
    3a7c:	31 97       	sbiw	r30, 0x01	; 1
    3a7e:	22 e2       	ldi	r18, 0x22	; 34
    3a80:	20 83       	st	Z, r18
    3a82:	31 97       	sbiw	r30, 0x01	; 1
    3a84:	a3 e3       	ldi	r26, 0x33	; 51
    3a86:	a0 83       	st	Z, r26
    3a88:	31 97       	sbiw	r30, 0x01	; 1
    3a8a:	60 83       	st	Z, r22
    3a8c:	31 97       	sbiw	r30, 0x01	; 1
    3a8e:	70 83       	st	Z, r23
    3a90:	31 97       	sbiw	r30, 0x01	; 1
    3a92:	10 82       	st	Z, r1
    3a94:	31 97       	sbiw	r30, 0x01	; 1
    3a96:	60 e8       	ldi	r22, 0x80	; 128
    3a98:	60 83       	st	Z, r22
    3a9a:	31 97       	sbiw	r30, 0x01	; 1
    3a9c:	10 82       	st	Z, r1
    3a9e:	31 97       	sbiw	r30, 0x01	; 1
    3aa0:	62 e0       	ldi	r22, 0x02	; 2
    3aa2:	60 83       	st	Z, r22
    3aa4:	31 97       	sbiw	r30, 0x01	; 1
    3aa6:	63 e0       	ldi	r22, 0x03	; 3
    3aa8:	60 83       	st	Z, r22
    3aaa:	31 97       	sbiw	r30, 0x01	; 1
    3aac:	64 e0       	ldi	r22, 0x04	; 4
    3aae:	60 83       	st	Z, r22
    3ab0:	31 97       	sbiw	r30, 0x01	; 1
    3ab2:	65 e0       	ldi	r22, 0x05	; 5
    3ab4:	60 83       	st	Z, r22
    3ab6:	31 97       	sbiw	r30, 0x01	; 1
    3ab8:	66 e0       	ldi	r22, 0x06	; 6
    3aba:	60 83       	st	Z, r22
    3abc:	31 97       	sbiw	r30, 0x01	; 1
    3abe:	67 e0       	ldi	r22, 0x07	; 7
    3ac0:	60 83       	st	Z, r22
    3ac2:	31 97       	sbiw	r30, 0x01	; 1
    3ac4:	68 e0       	ldi	r22, 0x08	; 8
    3ac6:	60 83       	st	Z, r22
    3ac8:	31 97       	sbiw	r30, 0x01	; 1
    3aca:	69 e0       	ldi	r22, 0x09	; 9
    3acc:	60 83       	st	Z, r22
    3ace:	31 97       	sbiw	r30, 0x01	; 1
    3ad0:	60 e1       	ldi	r22, 0x10	; 16
    3ad2:	60 83       	st	Z, r22
    3ad4:	31 97       	sbiw	r30, 0x01	; 1
    3ad6:	30 83       	st	Z, r19
    3ad8:	31 97       	sbiw	r30, 0x01	; 1
    3ada:	32 e1       	ldi	r19, 0x12	; 18
    3adc:	30 83       	st	Z, r19
    3ade:	31 97       	sbiw	r30, 0x01	; 1
    3ae0:	33 e1       	ldi	r19, 0x13	; 19
    3ae2:	30 83       	st	Z, r19
    3ae4:	31 97       	sbiw	r30, 0x01	; 1
    3ae6:	34 e1       	ldi	r19, 0x14	; 20
    3ae8:	30 83       	st	Z, r19
    3aea:	31 97       	sbiw	r30, 0x01	; 1
    3aec:	35 e1       	ldi	r19, 0x15	; 21
    3aee:	30 83       	st	Z, r19
    3af0:	31 97       	sbiw	r30, 0x01	; 1
    3af2:	36 e1       	ldi	r19, 0x16	; 22
    3af4:	30 83       	st	Z, r19
    3af6:	31 97       	sbiw	r30, 0x01	; 1
    3af8:	37 e1       	ldi	r19, 0x17	; 23
    3afa:	30 83       	st	Z, r19
    3afc:	31 97       	sbiw	r30, 0x01	; 1
    3afe:	38 e1       	ldi	r19, 0x18	; 24
    3b00:	30 83       	st	Z, r19
    3b02:	31 97       	sbiw	r30, 0x01	; 1
    3b04:	39 e1       	ldi	r19, 0x19	; 25
    3b06:	30 83       	st	Z, r19
    3b08:	31 97       	sbiw	r30, 0x01	; 1
    3b0a:	30 e2       	ldi	r19, 0x20	; 32
    3b0c:	30 83       	st	Z, r19
    3b0e:	31 97       	sbiw	r30, 0x01	; 1
    3b10:	31 e2       	ldi	r19, 0x21	; 33
    3b12:	30 83       	st	Z, r19
    3b14:	31 97       	sbiw	r30, 0x01	; 1
    3b16:	20 83       	st	Z, r18
    3b18:	31 97       	sbiw	r30, 0x01	; 1
    3b1a:	23 e2       	ldi	r18, 0x23	; 35
    3b1c:	20 83       	st	Z, r18
    3b1e:	31 97       	sbiw	r30, 0x01	; 1
    3b20:	40 83       	st	Z, r20
    3b22:	31 97       	sbiw	r30, 0x01	; 1
    3b24:	50 83       	st	Z, r21
    3b26:	31 97       	sbiw	r30, 0x01	; 1
    3b28:	26 e2       	ldi	r18, 0x26	; 38
    3b2a:	20 83       	st	Z, r18
    3b2c:	31 97       	sbiw	r30, 0x01	; 1
    3b2e:	27 e2       	ldi	r18, 0x27	; 39
    3b30:	20 83       	st	Z, r18
    3b32:	31 97       	sbiw	r30, 0x01	; 1
    3b34:	28 e2       	ldi	r18, 0x28	; 40
    3b36:	20 83       	st	Z, r18
    3b38:	31 97       	sbiw	r30, 0x01	; 1
    3b3a:	29 e2       	ldi	r18, 0x29	; 41
    3b3c:	20 83       	st	Z, r18
    3b3e:	31 97       	sbiw	r30, 0x01	; 1
    3b40:	20 e3       	ldi	r18, 0x30	; 48
    3b42:	20 83       	st	Z, r18
    3b44:	31 97       	sbiw	r30, 0x01	; 1
    3b46:	21 e3       	ldi	r18, 0x31	; 49
    3b48:	20 83       	st	Z, r18
    3b4a:	86 97       	sbiw	r24, 0x26	; 38
    3b4c:	08 95       	ret

00003b4e <xPortStartScheduler>:
    3b4e:	a8 95       	wdr
    3b50:	90 ec       	ldi	r25, 0xC0	; 192
    3b52:	88 e1       	ldi	r24, 0x18	; 24
    3b54:	0f b6       	in	r0, 0x3f	; 63
    3b56:	f8 94       	cli
    3b58:	a8 95       	wdr
    3b5a:	80 93 60 00 	sts	0x0060, r24	; 0x800060 <__DATA_REGION_ORIGIN__>
    3b5e:	0f be       	out	0x3f, r0	; 63
    3b60:	90 93 60 00 	sts	0x0060, r25	; 0x800060 <__DATA_REGION_ORIGIN__>
    3b64:	a0 91 00 05 	lds	r26, 0x0500	; 0x800500 <pxCurrentTCB>
    3b68:	b0 91 01 05 	lds	r27, 0x0501	; 0x800501 <pxCurrentTCB+0x1>
    3b6c:	cd 91       	ld	r28, X+
    3b6e:	cd bf       	out	0x3d, r28	; 61
    3b70:	dd 91       	ld	r29, X+
    3b72:	de bf       	out	0x3e, r29	; 62
    3b74:	ff 91       	pop	r31
    3b76:	ef 91       	pop	r30
    3b78:	df 91       	pop	r29
    3b7a:	cf 91       	pop	r28
    3b7c:	bf 91       	pop	r27
    3b7e:	af 91       	pop	r26
    3b80:	9f 91       	pop	r25
    3b82:	8f 91       	pop	r24
    3b84:	7f 91       	pop	r23
    3b86:	6f 91       	pop	r22
    3b88:	5f 91       	pop	r21
    3b8a:	4f 91       	pop	r20
    3b8c:	3f 91       	pop	r19
    3b8e:	2f 91       	pop	r18
    3b90:	1f 91       	pop	r17
    3b92:	0f 91       	pop	r16
    3b94:	ff 90       	pop	r15
    3b96:	ef 90       	pop	r14
    3b98:	df 90       	pop	r13
    3b9a:	cf 90       	pop	r12
    3b9c:	bf 90       	pop	r11
    3b9e:	af 90       	pop	r10
    3ba0:	9f 90       	pop	r9
    3ba2:	8f 90       	pop	r8
    3ba4:	7f 90       	pop	r7
    3ba6:	6f 90       	pop	r6
    3ba8:	5f 90       	pop	r5
    3baa:	4f 90       	pop	r4
    3bac:	3f 90       	pop	r3
    3bae:	2f 90       	pop	r2
    3bb0:	1f 90       	pop	r1
    3bb2:	0f 90       	pop	r0
    3bb4:	0f be       	out	0x3f, r0	; 63
    3bb6:	0f 90       	pop	r0
    3bb8:	08 95       	ret
    3bba:	81 e0       	ldi	r24, 0x01	; 1
    3bbc:	08 95       	ret

00003bbe <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( hot, flatten, naked ) );
void vPortYield( void )
{
    portSAVE_CONTEXT();
    3bbe:	0f 92       	push	r0
    3bc0:	0f b6       	in	r0, 0x3f	; 63
    3bc2:	f8 94       	cli
    3bc4:	0f 92       	push	r0
    3bc6:	1f 92       	push	r1
    3bc8:	11 24       	eor	r1, r1
    3bca:	2f 92       	push	r2
    3bcc:	3f 92       	push	r3
    3bce:	4f 92       	push	r4
    3bd0:	5f 92       	push	r5
    3bd2:	6f 92       	push	r6
    3bd4:	7f 92       	push	r7
    3bd6:	8f 92       	push	r8
    3bd8:	9f 92       	push	r9
    3bda:	af 92       	push	r10
    3bdc:	bf 92       	push	r11
    3bde:	cf 92       	push	r12
    3be0:	df 92       	push	r13
    3be2:	ef 92       	push	r14
    3be4:	ff 92       	push	r15
    3be6:	0f 93       	push	r16
    3be8:	1f 93       	push	r17
    3bea:	2f 93       	push	r18
    3bec:	3f 93       	push	r19
    3bee:	4f 93       	push	r20
    3bf0:	5f 93       	push	r21
    3bf2:	6f 93       	push	r22
    3bf4:	7f 93       	push	r23
    3bf6:	8f 93       	push	r24
    3bf8:	9f 93       	push	r25
    3bfa:	af 93       	push	r26
    3bfc:	bf 93       	push	r27
    3bfe:	cf 93       	push	r28
    3c00:	df 93       	push	r29
    3c02:	ef 93       	push	r30
    3c04:	ff 93       	push	r31
    3c06:	a0 91 00 05 	lds	r26, 0x0500	; 0x800500 <pxCurrentTCB>
    3c0a:	b0 91 01 05 	lds	r27, 0x0501	; 0x800501 <pxCurrentTCB+0x1>
    3c0e:	0d b6       	in	r0, 0x3d	; 61
    3c10:	0d 92       	st	X+, r0
    3c12:	0e b6       	in	r0, 0x3e	; 62
    3c14:	0d 92       	st	X+, r0
    vTaskSwitchContext();
    3c16:	0e 94 f2 17 	call	0x2fe4	; 0x2fe4 <vTaskSwitchContext>
    portRESTORE_CONTEXT();
    3c1a:	a0 91 00 05 	lds	r26, 0x0500	; 0x800500 <pxCurrentTCB>
    3c1e:	b0 91 01 05 	lds	r27, 0x0501	; 0x800501 <pxCurrentTCB+0x1>
    3c22:	cd 91       	ld	r28, X+
    3c24:	cd bf       	out	0x3d, r28	; 61
    3c26:	dd 91       	ld	r29, X+
    3c28:	de bf       	out	0x3e, r29	; 62
    3c2a:	ff 91       	pop	r31
    3c2c:	ef 91       	pop	r30
    3c2e:	df 91       	pop	r29
    3c30:	cf 91       	pop	r28
    3c32:	bf 91       	pop	r27
    3c34:	af 91       	pop	r26
    3c36:	9f 91       	pop	r25
    3c38:	8f 91       	pop	r24
    3c3a:	7f 91       	pop	r23
    3c3c:	6f 91       	pop	r22
    3c3e:	5f 91       	pop	r21
    3c40:	4f 91       	pop	r20
    3c42:	3f 91       	pop	r19
    3c44:	2f 91       	pop	r18
    3c46:	1f 91       	pop	r17
    3c48:	0f 91       	pop	r16
    3c4a:	ff 90       	pop	r15
    3c4c:	ef 90       	pop	r14
    3c4e:	df 90       	pop	r13
    3c50:	cf 90       	pop	r12
    3c52:	bf 90       	pop	r11
    3c54:	af 90       	pop	r10
    3c56:	9f 90       	pop	r9
    3c58:	8f 90       	pop	r8
    3c5a:	7f 90       	pop	r7
    3c5c:	6f 90       	pop	r6
    3c5e:	5f 90       	pop	r5
    3c60:	4f 90       	pop	r4
    3c62:	3f 90       	pop	r3
    3c64:	2f 90       	pop	r2
    3c66:	1f 90       	pop	r1
    3c68:	0f 90       	pop	r0
    3c6a:	0f be       	out	0x3f, r0	; 63
    3c6c:	0f 90       	pop	r0

    __asm__ __volatile__ ( "ret" );
    3c6e:	08 95       	ret

00003c70 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( hot, flatten, naked ) );
void vPortYieldFromTick( void )
{
    portSAVE_CONTEXT();
    3c70:	0f 92       	push	r0
    3c72:	0f b6       	in	r0, 0x3f	; 63
    3c74:	f8 94       	cli
    3c76:	0f 92       	push	r0
    3c78:	1f 92       	push	r1
    3c7a:	11 24       	eor	r1, r1
    3c7c:	2f 92       	push	r2
    3c7e:	3f 92       	push	r3
    3c80:	4f 92       	push	r4
    3c82:	5f 92       	push	r5
    3c84:	6f 92       	push	r6
    3c86:	7f 92       	push	r7
    3c88:	8f 92       	push	r8
    3c8a:	9f 92       	push	r9
    3c8c:	af 92       	push	r10
    3c8e:	bf 92       	push	r11
    3c90:	cf 92       	push	r12
    3c92:	df 92       	push	r13
    3c94:	ef 92       	push	r14
    3c96:	ff 92       	push	r15
    3c98:	0f 93       	push	r16
    3c9a:	1f 93       	push	r17
    3c9c:	2f 93       	push	r18
    3c9e:	3f 93       	push	r19
    3ca0:	4f 93       	push	r20
    3ca2:	5f 93       	push	r21
    3ca4:	6f 93       	push	r22
    3ca6:	7f 93       	push	r23
    3ca8:	8f 93       	push	r24
    3caa:	9f 93       	push	r25
    3cac:	af 93       	push	r26
    3cae:	bf 93       	push	r27
    3cb0:	cf 93       	push	r28
    3cb2:	df 93       	push	r29
    3cb4:	ef 93       	push	r30
    3cb6:	ff 93       	push	r31
    3cb8:	a0 91 00 05 	lds	r26, 0x0500	; 0x800500 <pxCurrentTCB>
    3cbc:	b0 91 01 05 	lds	r27, 0x0501	; 0x800501 <pxCurrentTCB+0x1>
    3cc0:	0d b6       	in	r0, 0x3d	; 61
    3cc2:	0d 92       	st	X+, r0
    3cc4:	0e b6       	in	r0, 0x3e	; 62
    3cc6:	0d 92       	st	X+, r0

    sleep_reset();        //     reset the sleep_mode() faster than sleep_disable();
    3cc8:	13 be       	out	0x33, r1	; 51

    if( xTaskIncrementTick() != pdFALSE )
    3cca:	0e 94 9f 16 	call	0x2d3e	; 0x2d3e <xTaskIncrementTick>
    3cce:	81 11       	cpse	r24, r1
    {
        vTaskSwitchContext();
    3cd0:	0e 94 f2 17 	call	0x2fe4	; 0x2fe4 <vTaskSwitchContext>
    }

    portRESTORE_CONTEXT();
    3cd4:	a0 91 00 05 	lds	r26, 0x0500	; 0x800500 <pxCurrentTCB>
    3cd8:	b0 91 01 05 	lds	r27, 0x0501	; 0x800501 <pxCurrentTCB+0x1>
    3cdc:	cd 91       	ld	r28, X+
    3cde:	cd bf       	out	0x3d, r28	; 61
    3ce0:	dd 91       	ld	r29, X+
    3ce2:	de bf       	out	0x3e, r29	; 62
    3ce4:	ff 91       	pop	r31
    3ce6:	ef 91       	pop	r30
    3ce8:	df 91       	pop	r29
    3cea:	cf 91       	pop	r28
    3cec:	bf 91       	pop	r27
    3cee:	af 91       	pop	r26
    3cf0:	9f 91       	pop	r25
    3cf2:	8f 91       	pop	r24
    3cf4:	7f 91       	pop	r23
    3cf6:	6f 91       	pop	r22
    3cf8:	5f 91       	pop	r21
    3cfa:	4f 91       	pop	r20
    3cfc:	3f 91       	pop	r19
    3cfe:	2f 91       	pop	r18
    3d00:	1f 91       	pop	r17
    3d02:	0f 91       	pop	r16
    3d04:	ff 90       	pop	r15
    3d06:	ef 90       	pop	r14
    3d08:	df 90       	pop	r13
    3d0a:	cf 90       	pop	r12
    3d0c:	bf 90       	pop	r11
    3d0e:	af 90       	pop	r10
    3d10:	9f 90       	pop	r9
    3d12:	8f 90       	pop	r8
    3d14:	7f 90       	pop	r7
    3d16:	6f 90       	pop	r6
    3d18:	5f 90       	pop	r5
    3d1a:	4f 90       	pop	r4
    3d1c:	3f 90       	pop	r3
    3d1e:	2f 90       	pop	r2
    3d20:	1f 90       	pop	r1
    3d22:	0f 90       	pop	r0
    3d24:	0f be       	out	0x3f, r0	; 63
    3d26:	0f 90       	pop	r0

    __asm__ __volatile__ ( "ret" );
    3d28:	08 95       	ret

00003d2a <__vector_6>:
     */
    ISR(portSCHEDULER_ISR, ISR_NAKED) __attribute__ ((hot, flatten));
//  ISR(portSCHEDULER_ISR, ISR_NAKED ISR_NOBLOCK) __attribute__ ((hot, flatten));
    ISR(portSCHEDULER_ISR)
    {
        vPortYieldFromTick();
    3d2a:	0e 94 38 1e 	call	0x3c70	; 0x3c70 <vPortYieldFromTick>
        __asm__ __volatile__ ( "reti" );
    3d2e:	18 95       	reti

00003d30 <prvIsQueueEmpty>:
    {
        xReturn = pdFALSE;
    }

    return xReturn;
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
    3d30:	0f b6       	in	r0, 0x3f	; 63
    3d32:	f8 94       	cli
    3d34:	0f 92       	push	r0
    3d36:	fc 01       	movw	r30, r24
    3d38:	92 8d       	ldd	r25, Z+26	; 0x1a
    3d3a:	0f 90       	pop	r0
    3d3c:	0f be       	out	0x3f, r0	; 63
    3d3e:	81 e0       	ldi	r24, 0x01	; 1
    3d40:	91 11       	cpse	r25, r1
    3d42:	80 e0       	ldi	r24, 0x00	; 0
    3d44:	08 95       	ret

00003d46 <prvCopyDataToQueue>:
    3d46:	0f 93       	push	r16
    3d48:	1f 93       	push	r17
    3d4a:	cf 93       	push	r28
    3d4c:	df 93       	push	r29
    3d4e:	ec 01       	movw	r28, r24
    3d50:	04 2f       	mov	r16, r20
    3d52:	1a 8d       	ldd	r17, Y+26	; 0x1a
    3d54:	4c 8d       	ldd	r20, Y+28	; 0x1c
    3d56:	41 11       	cpse	r20, r1
    3d58:	0b c0       	rjmp	.+22     	; 0x3d70 <prvCopyDataToQueue+0x2a>
    3d5a:	88 81       	ld	r24, Y
    3d5c:	99 81       	ldd	r25, Y+1	; 0x01
    3d5e:	89 2b       	or	r24, r25
    3d60:	e9 f5       	brne	.+122    	; 0x3ddc <prvCopyDataToQueue+0x96>
    3d62:	8c 81       	ldd	r24, Y+4	; 0x04
    3d64:	9d 81       	ldd	r25, Y+5	; 0x05
    3d66:	0e 94 09 19 	call	0x3212	; 0x3212 <xTaskPriorityDisinherit>
    3d6a:	1d 82       	std	Y+5, r1	; 0x05
    3d6c:	1c 82       	std	Y+4, r1	; 0x04
    3d6e:	37 c0       	rjmp	.+110    	; 0x3dde <prvCopyDataToQueue+0x98>
    3d70:	50 e0       	ldi	r21, 0x00	; 0
    3d72:	01 11       	cpse	r16, r1
    3d74:	15 c0       	rjmp	.+42     	; 0x3da0 <prvCopyDataToQueue+0x5a>
    3d76:	8a 81       	ldd	r24, Y+2	; 0x02
    3d78:	9b 81       	ldd	r25, Y+3	; 0x03
    3d7a:	0e 94 d7 22 	call	0x45ae	; 0x45ae <memcpy>
    3d7e:	2c 8d       	ldd	r18, Y+28	; 0x1c
    3d80:	8a 81       	ldd	r24, Y+2	; 0x02
    3d82:	9b 81       	ldd	r25, Y+3	; 0x03
    3d84:	82 0f       	add	r24, r18
    3d86:	91 1d       	adc	r25, r1
    3d88:	9b 83       	std	Y+3, r25	; 0x03
    3d8a:	8a 83       	std	Y+2, r24	; 0x02
    3d8c:	2c 81       	ldd	r18, Y+4	; 0x04
    3d8e:	3d 81       	ldd	r19, Y+5	; 0x05
    3d90:	82 17       	cp	r24, r18
    3d92:	93 07       	cpc	r25, r19
    3d94:	18 f1       	brcs	.+70     	; 0x3ddc <prvCopyDataToQueue+0x96>
    3d96:	88 81       	ld	r24, Y
    3d98:	99 81       	ldd	r25, Y+1	; 0x01
    3d9a:	9b 83       	std	Y+3, r25	; 0x03
    3d9c:	8a 83       	std	Y+2, r24	; 0x02
    3d9e:	1e c0       	rjmp	.+60     	; 0x3ddc <prvCopyDataToQueue+0x96>
    3da0:	8e 81       	ldd	r24, Y+6	; 0x06
    3da2:	9f 81       	ldd	r25, Y+7	; 0x07
    3da4:	0e 94 d7 22 	call	0x45ae	; 0x45ae <memcpy>
    3da8:	8c 8d       	ldd	r24, Y+28	; 0x1c
    3daa:	90 e0       	ldi	r25, 0x00	; 0
    3dac:	91 95       	neg	r25
    3dae:	81 95       	neg	r24
    3db0:	91 09       	sbc	r25, r1
    3db2:	2e 81       	ldd	r18, Y+6	; 0x06
    3db4:	3f 81       	ldd	r19, Y+7	; 0x07
    3db6:	28 0f       	add	r18, r24
    3db8:	39 1f       	adc	r19, r25
    3dba:	3f 83       	std	Y+7, r19	; 0x07
    3dbc:	2e 83       	std	Y+6, r18	; 0x06
    3dbe:	48 81       	ld	r20, Y
    3dc0:	59 81       	ldd	r21, Y+1	; 0x01
    3dc2:	24 17       	cp	r18, r20
    3dc4:	35 07       	cpc	r19, r21
    3dc6:	30 f4       	brcc	.+12     	; 0x3dd4 <prvCopyDataToQueue+0x8e>
    3dc8:	2c 81       	ldd	r18, Y+4	; 0x04
    3dca:	3d 81       	ldd	r19, Y+5	; 0x05
    3dcc:	82 0f       	add	r24, r18
    3dce:	93 1f       	adc	r25, r19
    3dd0:	9f 83       	std	Y+7, r25	; 0x07
    3dd2:	8e 83       	std	Y+6, r24	; 0x06
    3dd4:	02 30       	cpi	r16, 0x02	; 2
    3dd6:	11 f4       	brne	.+4      	; 0x3ddc <prvCopyDataToQueue+0x96>
    3dd8:	11 11       	cpse	r17, r1
    3dda:	11 50       	subi	r17, 0x01	; 1
    3ddc:	80 e0       	ldi	r24, 0x00	; 0
    3dde:	1f 5f       	subi	r17, 0xFF	; 255
    3de0:	1a 8f       	std	Y+26, r17	; 0x1a
    3de2:	df 91       	pop	r29
    3de4:	cf 91       	pop	r28
    3de6:	1f 91       	pop	r17
    3de8:	0f 91       	pop	r16
    3dea:	08 95       	ret

00003dec <prvCopyDataFromQueue>:
    3dec:	fc 01       	movw	r30, r24
    3dee:	cb 01       	movw	r24, r22
    3df0:	44 8d       	ldd	r20, Z+28	; 0x1c
    3df2:	44 23       	and	r20, r20
    3df4:	a1 f0       	breq	.+40     	; 0x3e1e <prvCopyDataFromQueue+0x32>
    3df6:	50 e0       	ldi	r21, 0x00	; 0
    3df8:	26 81       	ldd	r18, Z+6	; 0x06
    3dfa:	37 81       	ldd	r19, Z+7	; 0x07
    3dfc:	24 0f       	add	r18, r20
    3dfe:	35 1f       	adc	r19, r21
    3e00:	37 83       	std	Z+7, r19	; 0x07
    3e02:	26 83       	std	Z+6, r18	; 0x06
    3e04:	64 81       	ldd	r22, Z+4	; 0x04
    3e06:	75 81       	ldd	r23, Z+5	; 0x05
    3e08:	26 17       	cp	r18, r22
    3e0a:	37 07       	cpc	r19, r23
    3e0c:	20 f0       	brcs	.+8      	; 0x3e16 <prvCopyDataFromQueue+0x2a>
    3e0e:	20 81       	ld	r18, Z
    3e10:	31 81       	ldd	r19, Z+1	; 0x01
    3e12:	37 83       	std	Z+7, r19	; 0x07
    3e14:	26 83       	std	Z+6, r18	; 0x06
    3e16:	66 81       	ldd	r22, Z+6	; 0x06
    3e18:	77 81       	ldd	r23, Z+7	; 0x07
    3e1a:	0c 94 d7 22 	jmp	0x45ae	; 0x45ae <memcpy>
    3e1e:	08 95       	ret

00003e20 <prvUnlockQueue>:
    3e20:	ef 92       	push	r14
    3e22:	ff 92       	push	r15
    3e24:	1f 93       	push	r17
    3e26:	cf 93       	push	r28
    3e28:	df 93       	push	r29
    3e2a:	ec 01       	movw	r28, r24
    3e2c:	0f b6       	in	r0, 0x3f	; 63
    3e2e:	f8 94       	cli
    3e30:	0f 92       	push	r0
    3e32:	1e 8d       	ldd	r17, Y+30	; 0x1e
    3e34:	7c 01       	movw	r14, r24
    3e36:	81 e1       	ldi	r24, 0x11	; 17
    3e38:	e8 0e       	add	r14, r24
    3e3a:	f1 1c       	adc	r15, r1
    3e3c:	11 16       	cp	r1, r17
    3e3e:	5c f4       	brge	.+22     	; 0x3e56 <prvUnlockQueue+0x36>
    3e40:	89 89       	ldd	r24, Y+17	; 0x11
    3e42:	88 23       	and	r24, r24
    3e44:	41 f0       	breq	.+16     	; 0x3e56 <prvUnlockQueue+0x36>
    3e46:	c7 01       	movw	r24, r14
    3e48:	0e 94 79 18 	call	0x30f2	; 0x30f2 <xTaskRemoveFromEventList>
    3e4c:	81 11       	cpse	r24, r1
    3e4e:	0e 94 f7 18 	call	0x31ee	; 0x31ee <vTaskMissedYield>
    3e52:	11 50       	subi	r17, 0x01	; 1
    3e54:	f3 cf       	rjmp	.-26     	; 0x3e3c <prvUnlockQueue+0x1c>
    3e56:	8f ef       	ldi	r24, 0xFF	; 255
    3e58:	8e 8f       	std	Y+30, r24	; 0x1e
    3e5a:	0f 90       	pop	r0
    3e5c:	0f be       	out	0x3f, r0	; 63
    3e5e:	0f b6       	in	r0, 0x3f	; 63
    3e60:	f8 94       	cli
    3e62:	0f 92       	push	r0
    3e64:	1d 8d       	ldd	r17, Y+29	; 0x1d
    3e66:	7e 01       	movw	r14, r28
    3e68:	88 e0       	ldi	r24, 0x08	; 8
    3e6a:	e8 0e       	add	r14, r24
    3e6c:	f1 1c       	adc	r15, r1
    3e6e:	11 16       	cp	r1, r17
    3e70:	5c f4       	brge	.+22     	; 0x3e88 <prvUnlockQueue+0x68>
    3e72:	88 85       	ldd	r24, Y+8	; 0x08
    3e74:	88 23       	and	r24, r24
    3e76:	41 f0       	breq	.+16     	; 0x3e88 <prvUnlockQueue+0x68>
    3e78:	c7 01       	movw	r24, r14
    3e7a:	0e 94 79 18 	call	0x30f2	; 0x30f2 <xTaskRemoveFromEventList>
    3e7e:	81 11       	cpse	r24, r1
    3e80:	0e 94 f7 18 	call	0x31ee	; 0x31ee <vTaskMissedYield>
    3e84:	11 50       	subi	r17, 0x01	; 1
    3e86:	f3 cf       	rjmp	.-26     	; 0x3e6e <prvUnlockQueue+0x4e>
    3e88:	8f ef       	ldi	r24, 0xFF	; 255
    3e8a:	8d 8f       	std	Y+29, r24	; 0x1d
    3e8c:	0f 90       	pop	r0
    3e8e:	0f be       	out	0x3f, r0	; 63
    3e90:	df 91       	pop	r29
    3e92:	cf 91       	pop	r28
    3e94:	1f 91       	pop	r17
    3e96:	ff 90       	pop	r15
    3e98:	ef 90       	pop	r14
    3e9a:	08 95       	ret

00003e9c <xQueueGenericReset>:
    3e9c:	cf 93       	push	r28
    3e9e:	df 93       	push	r29
    3ea0:	ec 01       	movw	r28, r24
    3ea2:	0f b6       	in	r0, 0x3f	; 63
    3ea4:	f8 94       	cli
    3ea6:	0f 92       	push	r0
    3ea8:	48 81       	ld	r20, Y
    3eaa:	59 81       	ldd	r21, Y+1	; 0x01
    3eac:	8b 8d       	ldd	r24, Y+27	; 0x1b
    3eae:	7c 8d       	ldd	r23, Y+28	; 0x1c
    3eb0:	9a 01       	movw	r18, r20
    3eb2:	87 9f       	mul	r24, r23
    3eb4:	20 0d       	add	r18, r0
    3eb6:	31 1d       	adc	r19, r1
    3eb8:	11 24       	eor	r1, r1
    3eba:	3d 83       	std	Y+5, r19	; 0x05
    3ebc:	2c 83       	std	Y+4, r18	; 0x04
    3ebe:	1a 8e       	std	Y+26, r1	; 0x1a
    3ec0:	5b 83       	std	Y+3, r21	; 0x03
    3ec2:	4a 83       	std	Y+2, r20	; 0x02
    3ec4:	90 e0       	ldi	r25, 0x00	; 0
    3ec6:	01 97       	sbiw	r24, 0x01	; 1
    3ec8:	78 9f       	mul	r23, r24
    3eca:	90 01       	movw	r18, r0
    3ecc:	79 9f       	mul	r23, r25
    3ece:	30 0d       	add	r19, r0
    3ed0:	11 24       	eor	r1, r1
    3ed2:	ca 01       	movw	r24, r20
    3ed4:	82 0f       	add	r24, r18
    3ed6:	93 1f       	adc	r25, r19
    3ed8:	9f 83       	std	Y+7, r25	; 0x07
    3eda:	8e 83       	std	Y+6, r24	; 0x06
    3edc:	8f ef       	ldi	r24, 0xFF	; 255
    3ede:	8d 8f       	std	Y+29, r24	; 0x1d
    3ee0:	8e 8f       	std	Y+30, r24	; 0x1e
    3ee2:	61 11       	cpse	r22, r1
    3ee4:	0c c0       	rjmp	.+24     	; 0x3efe <xQueueGenericReset+0x62>
    3ee6:	88 85       	ldd	r24, Y+8	; 0x08
    3ee8:	88 23       	and	r24, r24
    3eea:	89 f0       	breq	.+34     	; 0x3f0e <xQueueGenericReset+0x72>
    3eec:	ce 01       	movw	r24, r28
    3eee:	08 96       	adiw	r24, 0x08	; 8
    3ef0:	0e 94 79 18 	call	0x30f2	; 0x30f2 <xTaskRemoveFromEventList>
    3ef4:	88 23       	and	r24, r24
    3ef6:	59 f0       	breq	.+22     	; 0x3f0e <xQueueGenericReset+0x72>
    3ef8:	0e 94 df 1d 	call	0x3bbe	; 0x3bbe <vPortYield>
    3efc:	08 c0       	rjmp	.+16     	; 0x3f0e <xQueueGenericReset+0x72>
    3efe:	ce 01       	movw	r24, r28
    3f00:	08 96       	adiw	r24, 0x08	; 8
    3f02:	0e 94 ac 1c 	call	0x3958	; 0x3958 <vListInitialise>
    3f06:	ce 01       	movw	r24, r28
    3f08:	41 96       	adiw	r24, 0x11	; 17
    3f0a:	0e 94 ac 1c 	call	0x3958	; 0x3958 <vListInitialise>
    3f0e:	0f 90       	pop	r0
    3f10:	0f be       	out	0x3f, r0	; 63
    3f12:	81 e0       	ldi	r24, 0x01	; 1
    3f14:	df 91       	pop	r29
    3f16:	cf 91       	pop	r28
    3f18:	08 95       	ret

00003f1a <xQueueGenericCreate>:
    3f1a:	0f 93       	push	r16
    3f1c:	1f 93       	push	r17
    3f1e:	cf 93       	push	r28
    3f20:	df 93       	push	r29
    3f22:	08 2f       	mov	r16, r24
    3f24:	16 2f       	mov	r17, r22
    3f26:	66 23       	and	r22, r22
    3f28:	21 f0       	breq	.+8      	; 0x3f32 <xQueueGenericCreate+0x18>
    3f2a:	86 9f       	mul	r24, r22
    3f2c:	c0 01       	movw	r24, r0
    3f2e:	11 24       	eor	r1, r1
    3f30:	02 c0       	rjmp	.+4      	; 0x3f36 <xQueueGenericCreate+0x1c>
    3f32:	80 e0       	ldi	r24, 0x00	; 0
    3f34:	90 e0       	ldi	r25, 0x00	; 0
    3f36:	4f 96       	adiw	r24, 0x1f	; 31
    3f38:	0e 94 88 1c 	call	0x3910	; 0x3910 <pvPortMalloc>
    3f3c:	ec 01       	movw	r28, r24
    3f3e:	00 97       	sbiw	r24, 0x00	; 0
    3f40:	71 f0       	breq	.+28     	; 0x3f5e <xQueueGenericCreate+0x44>
    3f42:	11 11       	cpse	r17, r1
    3f44:	03 c0       	rjmp	.+6      	; 0x3f4c <xQueueGenericCreate+0x32>
    3f46:	99 83       	std	Y+1, r25	; 0x01
    3f48:	88 83       	st	Y, r24
    3f4a:	03 c0       	rjmp	.+6      	; 0x3f52 <xQueueGenericCreate+0x38>
    3f4c:	4f 96       	adiw	r24, 0x1f	; 31
    3f4e:	99 83       	std	Y+1, r25	; 0x01
    3f50:	88 83       	st	Y, r24
    3f52:	0b 8f       	std	Y+27, r16	; 0x1b
    3f54:	1c 8f       	std	Y+28, r17	; 0x1c
    3f56:	61 e0       	ldi	r22, 0x01	; 1
    3f58:	ce 01       	movw	r24, r28
    3f5a:	0e 94 4e 1f 	call	0x3e9c	; 0x3e9c <xQueueGenericReset>
    3f5e:	ce 01       	movw	r24, r28
    3f60:	df 91       	pop	r29
    3f62:	cf 91       	pop	r28
    3f64:	1f 91       	pop	r17
    3f66:	0f 91       	pop	r16
    3f68:	08 95       	ret

00003f6a <xQueueGenericSend>:
    3f6a:	af 92       	push	r10
    3f6c:	bf 92       	push	r11
    3f6e:	cf 92       	push	r12
    3f70:	df 92       	push	r13
    3f72:	ff 92       	push	r15
    3f74:	0f 93       	push	r16
    3f76:	1f 93       	push	r17
    3f78:	cf 93       	push	r28
    3f7a:	df 93       	push	r29
    3f7c:	00 d0       	rcall	.+0      	; 0x3f7e <xQueueGenericSend+0x14>
    3f7e:	00 d0       	rcall	.+0      	; 0x3f80 <xQueueGenericSend+0x16>
    3f80:	1f 92       	push	r1
    3f82:	cd b7       	in	r28, 0x3d	; 61
    3f84:	de b7       	in	r29, 0x3e	; 62
    3f86:	8c 01       	movw	r16, r24
    3f88:	6b 01       	movw	r12, r22
    3f8a:	5d 83       	std	Y+5, r21	; 0x05
    3f8c:	4c 83       	std	Y+4, r20	; 0x04
    3f8e:	f2 2e       	mov	r15, r18
    3f90:	80 e0       	ldi	r24, 0x00	; 0
    3f92:	58 01       	movw	r10, r16
    3f94:	98 e0       	ldi	r25, 0x08	; 8
    3f96:	a9 0e       	add	r10, r25
    3f98:	b1 1c       	adc	r11, r1
    3f9a:	0f b6       	in	r0, 0x3f	; 63
    3f9c:	f8 94       	cli
    3f9e:	0f 92       	push	r0
    3fa0:	f8 01       	movw	r30, r16
    3fa2:	22 8d       	ldd	r18, Z+26	; 0x1a
    3fa4:	93 8d       	ldd	r25, Z+27	; 0x1b
    3fa6:	29 17       	cp	r18, r25
    3fa8:	18 f0       	brcs	.+6      	; 0x3fb0 <xQueueGenericSend+0x46>
    3faa:	f2 e0       	ldi	r31, 0x02	; 2
    3fac:	ff 12       	cpse	r15, r31
    3fae:	14 c0       	rjmp	.+40     	; 0x3fd8 <xQueueGenericSend+0x6e>
    3fb0:	4f 2d       	mov	r20, r15
    3fb2:	b6 01       	movw	r22, r12
    3fb4:	c8 01       	movw	r24, r16
    3fb6:	0e 94 a3 1e 	call	0x3d46	; 0x3d46 <prvCopyDataToQueue>
    3fba:	f8 01       	movw	r30, r16
    3fbc:	91 89       	ldd	r25, Z+17	; 0x11
    3fbe:	99 23       	and	r25, r25
    3fc0:	21 f0       	breq	.+8      	; 0x3fca <xQueueGenericSend+0x60>
    3fc2:	c8 01       	movw	r24, r16
    3fc4:	41 96       	adiw	r24, 0x11	; 17
    3fc6:	0e 94 79 18 	call	0x30f2	; 0x30f2 <xTaskRemoveFromEventList>
    3fca:	81 11       	cpse	r24, r1
    3fcc:	0e 94 df 1d 	call	0x3bbe	; 0x3bbe <vPortYield>
    3fd0:	0f 90       	pop	r0
    3fd2:	0f be       	out	0x3f, r0	; 63
    3fd4:	81 e0       	ldi	r24, 0x01	; 1
    3fd6:	50 c0       	rjmp	.+160    	; 0x4078 <xQueueGenericSend+0x10e>
    3fd8:	2c 81       	ldd	r18, Y+4	; 0x04
    3fda:	3d 81       	ldd	r19, Y+5	; 0x05
    3fdc:	23 2b       	or	r18, r19
    3fde:	19 f4       	brne	.+6      	; 0x3fe6 <xQueueGenericSend+0x7c>
    3fe0:	0f 90       	pop	r0
    3fe2:	0f be       	out	0x3f, r0	; 63
    3fe4:	48 c0       	rjmp	.+144    	; 0x4076 <xQueueGenericSend+0x10c>
    3fe6:	81 11       	cpse	r24, r1
    3fe8:	04 c0       	rjmp	.+8      	; 0x3ff2 <xQueueGenericSend+0x88>
    3fea:	ce 01       	movw	r24, r28
    3fec:	01 96       	adiw	r24, 0x01	; 1
    3fee:	0e 94 b9 18 	call	0x3172	; 0x3172 <vTaskInternalSetTimeOutState>
    3ff2:	0f 90       	pop	r0
    3ff4:	0f be       	out	0x3f, r0	; 63
    3ff6:	0e 94 8f 16 	call	0x2d1e	; 0x2d1e <vTaskSuspendAll>
    3ffa:	0f b6       	in	r0, 0x3f	; 63
    3ffc:	f8 94       	cli
    3ffe:	0f 92       	push	r0
    4000:	f8 01       	movw	r30, r16
    4002:	85 8d       	ldd	r24, Z+29	; 0x1d
    4004:	8f 3f       	cpi	r24, 0xFF	; 255
    4006:	09 f4       	brne	.+2      	; 0x400a <xQueueGenericSend+0xa0>
    4008:	15 8e       	std	Z+29, r1	; 0x1d
    400a:	f8 01       	movw	r30, r16
    400c:	86 8d       	ldd	r24, Z+30	; 0x1e
    400e:	8f 3f       	cpi	r24, 0xFF	; 255
    4010:	09 f4       	brne	.+2      	; 0x4014 <xQueueGenericSend+0xaa>
    4012:	16 8e       	std	Z+30, r1	; 0x1e
    4014:	0f 90       	pop	r0
    4016:	0f be       	out	0x3f, r0	; 63
    4018:	be 01       	movw	r22, r28
    401a:	6c 5f       	subi	r22, 0xFC	; 252
    401c:	7f 4f       	sbci	r23, 0xFF	; 255
    401e:	ce 01       	movw	r24, r28
    4020:	01 96       	adiw	r24, 0x01	; 1
    4022:	0e 94 c4 18 	call	0x3188	; 0x3188 <xTaskCheckForTimeOut>
    4026:	81 11       	cpse	r24, r1
    4028:	21 c0       	rjmp	.+66     	; 0x406c <xQueueGenericSend+0x102>
    402a:	0f b6       	in	r0, 0x3f	; 63
    402c:	f8 94       	cli
    402e:	0f 92       	push	r0
    4030:	f8 01       	movw	r30, r16
    4032:	92 8d       	ldd	r25, Z+26	; 0x1a
    4034:	83 8d       	ldd	r24, Z+27	; 0x1b
    4036:	0f 90       	pop	r0
    4038:	0f be       	out	0x3f, r0	; 63
    403a:	98 13       	cpse	r25, r24
    403c:	11 c0       	rjmp	.+34     	; 0x4060 <xQueueGenericSend+0xf6>
    403e:	6c 81       	ldd	r22, Y+4	; 0x04
    4040:	7d 81       	ldd	r23, Y+5	; 0x05
    4042:	c5 01       	movw	r24, r10
    4044:	0e 94 50 18 	call	0x30a0	; 0x30a0 <vTaskPlaceOnEventList>
    4048:	c8 01       	movw	r24, r16
    404a:	0e 94 10 1f 	call	0x3e20	; 0x3e20 <prvUnlockQueue>
    404e:	0e 94 4b 17 	call	0x2e96	; 0x2e96 <xTaskResumeAll>
    4052:	88 23       	and	r24, r24
    4054:	11 f0       	breq	.+4      	; 0x405a <xQueueGenericSend+0xf0>
    4056:	81 e0       	ldi	r24, 0x01	; 1
    4058:	a0 cf       	rjmp	.-192    	; 0x3f9a <xQueueGenericSend+0x30>
    405a:	0e 94 df 1d 	call	0x3bbe	; 0x3bbe <vPortYield>
    405e:	fb cf       	rjmp	.-10     	; 0x4056 <xQueueGenericSend+0xec>
    4060:	c8 01       	movw	r24, r16
    4062:	0e 94 10 1f 	call	0x3e20	; 0x3e20 <prvUnlockQueue>
    4066:	0e 94 4b 17 	call	0x2e96	; 0x2e96 <xTaskResumeAll>
    406a:	f5 cf       	rjmp	.-22     	; 0x4056 <xQueueGenericSend+0xec>
    406c:	c8 01       	movw	r24, r16
    406e:	0e 94 10 1f 	call	0x3e20	; 0x3e20 <prvUnlockQueue>
    4072:	0e 94 4b 17 	call	0x2e96	; 0x2e96 <xTaskResumeAll>
    4076:	80 e0       	ldi	r24, 0x00	; 0
    4078:	0f 90       	pop	r0
    407a:	0f 90       	pop	r0
    407c:	0f 90       	pop	r0
    407e:	0f 90       	pop	r0
    4080:	0f 90       	pop	r0
    4082:	df 91       	pop	r29
    4084:	cf 91       	pop	r28
    4086:	1f 91       	pop	r17
    4088:	0f 91       	pop	r16
    408a:	ff 90       	pop	r15
    408c:	df 90       	pop	r13
    408e:	cf 90       	pop	r12
    4090:	bf 90       	pop	r11
    4092:	af 90       	pop	r10
    4094:	08 95       	ret

00004096 <xQueueGenericSendFromISR>:
    4096:	ef 92       	push	r14
    4098:	ff 92       	push	r15
    409a:	1f 93       	push	r17
    409c:	cf 93       	push	r28
    409e:	df 93       	push	r29
    40a0:	ec 01       	movw	r28, r24
    40a2:	9a 8d       	ldd	r25, Y+26	; 0x1a
    40a4:	8b 8d       	ldd	r24, Y+27	; 0x1b
    40a6:	98 17       	cp	r25, r24
    40a8:	10 f0       	brcs	.+4      	; 0x40ae <xQueueGenericSendFromISR+0x18>
    40aa:	22 30       	cpi	r18, 0x02	; 2
    40ac:	e1 f4       	brne	.+56     	; 0x40e6 <xQueueGenericSendFromISR+0x50>
    40ae:	7a 01       	movw	r14, r20
    40b0:	1e 8d       	ldd	r17, Y+30	; 0x1e
    40b2:	42 2f       	mov	r20, r18
    40b4:	ce 01       	movw	r24, r28
    40b6:	0e 94 a3 1e 	call	0x3d46	; 0x3d46 <prvCopyDataToQueue>
    40ba:	1f 3f       	cpi	r17, 0xFF	; 255
    40bc:	81 f4       	brne	.+32     	; 0x40de <xQueueGenericSendFromISR+0x48>
    40be:	89 89       	ldd	r24, Y+17	; 0x11
    40c0:	88 23       	and	r24, r24
    40c2:	79 f0       	breq	.+30     	; 0x40e2 <xQueueGenericSendFromISR+0x4c>
    40c4:	ce 01       	movw	r24, r28
    40c6:	41 96       	adiw	r24, 0x11	; 17
    40c8:	0e 94 79 18 	call	0x30f2	; 0x30f2 <xTaskRemoveFromEventList>
    40cc:	88 23       	and	r24, r24
    40ce:	49 f0       	breq	.+18     	; 0x40e2 <xQueueGenericSendFromISR+0x4c>
    40d0:	e1 14       	cp	r14, r1
    40d2:	f1 04       	cpc	r15, r1
    40d4:	31 f0       	breq	.+12     	; 0x40e2 <xQueueGenericSendFromISR+0x4c>
    40d6:	81 e0       	ldi	r24, 0x01	; 1
    40d8:	f7 01       	movw	r30, r14
    40da:	80 83       	st	Z, r24
    40dc:	05 c0       	rjmp	.+10     	; 0x40e8 <xQueueGenericSendFromISR+0x52>
    40de:	1f 5f       	subi	r17, 0xFF	; 255
    40e0:	1e 8f       	std	Y+30, r17	; 0x1e
    40e2:	81 e0       	ldi	r24, 0x01	; 1
    40e4:	01 c0       	rjmp	.+2      	; 0x40e8 <xQueueGenericSendFromISR+0x52>
    40e6:	80 e0       	ldi	r24, 0x00	; 0
    40e8:	df 91       	pop	r29
    40ea:	cf 91       	pop	r28
    40ec:	1f 91       	pop	r17
    40ee:	ff 90       	pop	r15
    40f0:	ef 90       	pop	r14
    40f2:	08 95       	ret

000040f4 <xQueueReceive>:
    40f4:	af 92       	push	r10
    40f6:	bf 92       	push	r11
    40f8:	cf 92       	push	r12
    40fa:	df 92       	push	r13
    40fc:	ff 92       	push	r15
    40fe:	0f 93       	push	r16
    4100:	1f 93       	push	r17
    4102:	cf 93       	push	r28
    4104:	df 93       	push	r29
    4106:	00 d0       	rcall	.+0      	; 0x4108 <xQueueReceive+0x14>
    4108:	00 d0       	rcall	.+0      	; 0x410a <xQueueReceive+0x16>
    410a:	1f 92       	push	r1
    410c:	cd b7       	in	r28, 0x3d	; 61
    410e:	de b7       	in	r29, 0x3e	; 62
    4110:	8c 01       	movw	r16, r24
    4112:	6b 01       	movw	r12, r22
    4114:	5d 83       	std	Y+5, r21	; 0x05
    4116:	4c 83       	std	Y+4, r20	; 0x04
    4118:	80 e0       	ldi	r24, 0x00	; 0
    411a:	58 01       	movw	r10, r16
    411c:	91 e1       	ldi	r25, 0x11	; 17
    411e:	a9 0e       	add	r10, r25
    4120:	b1 1c       	adc	r11, r1
    4122:	0f b6       	in	r0, 0x3f	; 63
    4124:	f8 94       	cli
    4126:	0f 92       	push	r0
    4128:	f8 01       	movw	r30, r16
    412a:	f2 8c       	ldd	r15, Z+26	; 0x1a
    412c:	ff 20       	and	r15, r15
    412e:	a9 f0       	breq	.+42     	; 0x415a <xQueueReceive+0x66>
    4130:	b6 01       	movw	r22, r12
    4132:	c8 01       	movw	r24, r16
    4134:	0e 94 f6 1e 	call	0x3dec	; 0x3dec <prvCopyDataFromQueue>
    4138:	fa 94       	dec	r15
    413a:	f8 01       	movw	r30, r16
    413c:	f2 8e       	std	Z+26, r15	; 0x1a
    413e:	80 85       	ldd	r24, Z+8	; 0x08
    4140:	88 23       	and	r24, r24
    4142:	39 f0       	breq	.+14     	; 0x4152 <xQueueReceive+0x5e>
    4144:	c8 01       	movw	r24, r16
    4146:	08 96       	adiw	r24, 0x08	; 8
    4148:	0e 94 79 18 	call	0x30f2	; 0x30f2 <xTaskRemoveFromEventList>
    414c:	81 11       	cpse	r24, r1
    414e:	0e 94 df 1d 	call	0x3bbe	; 0x3bbe <vPortYield>
    4152:	0f 90       	pop	r0
    4154:	0f be       	out	0x3f, r0	; 63
    4156:	81 e0       	ldi	r24, 0x01	; 1
    4158:	50 c0       	rjmp	.+160    	; 0x41fa <xQueueReceive+0x106>
    415a:	2c 81       	ldd	r18, Y+4	; 0x04
    415c:	3d 81       	ldd	r19, Y+5	; 0x05
    415e:	23 2b       	or	r18, r19
    4160:	19 f4       	brne	.+6      	; 0x4168 <xQueueReceive+0x74>
    4162:	0f 90       	pop	r0
    4164:	0f be       	out	0x3f, r0	; 63
    4166:	48 c0       	rjmp	.+144    	; 0x41f8 <xQueueReceive+0x104>
    4168:	81 11       	cpse	r24, r1
    416a:	04 c0       	rjmp	.+8      	; 0x4174 <xQueueReceive+0x80>
    416c:	ce 01       	movw	r24, r28
    416e:	01 96       	adiw	r24, 0x01	; 1
    4170:	0e 94 b9 18 	call	0x3172	; 0x3172 <vTaskInternalSetTimeOutState>
    4174:	0f 90       	pop	r0
    4176:	0f be       	out	0x3f, r0	; 63
    4178:	0e 94 8f 16 	call	0x2d1e	; 0x2d1e <vTaskSuspendAll>
    417c:	0f b6       	in	r0, 0x3f	; 63
    417e:	f8 94       	cli
    4180:	0f 92       	push	r0
    4182:	f8 01       	movw	r30, r16
    4184:	85 8d       	ldd	r24, Z+29	; 0x1d
    4186:	8f 3f       	cpi	r24, 0xFF	; 255
    4188:	09 f4       	brne	.+2      	; 0x418c <xQueueReceive+0x98>
    418a:	15 8e       	std	Z+29, r1	; 0x1d
    418c:	f8 01       	movw	r30, r16
    418e:	86 8d       	ldd	r24, Z+30	; 0x1e
    4190:	8f 3f       	cpi	r24, 0xFF	; 255
    4192:	09 f4       	brne	.+2      	; 0x4196 <xQueueReceive+0xa2>
    4194:	16 8e       	std	Z+30, r1	; 0x1e
    4196:	0f 90       	pop	r0
    4198:	0f be       	out	0x3f, r0	; 63
    419a:	be 01       	movw	r22, r28
    419c:	6c 5f       	subi	r22, 0xFC	; 252
    419e:	7f 4f       	sbci	r23, 0xFF	; 255
    41a0:	ce 01       	movw	r24, r28
    41a2:	01 96       	adiw	r24, 0x01	; 1
    41a4:	0e 94 c4 18 	call	0x3188	; 0x3188 <xTaskCheckForTimeOut>
    41a8:	81 11       	cpse	r24, r1
    41aa:	1c c0       	rjmp	.+56     	; 0x41e4 <xQueueReceive+0xf0>
    41ac:	c8 01       	movw	r24, r16
    41ae:	0e 94 98 1e 	call	0x3d30	; 0x3d30 <prvIsQueueEmpty>
    41b2:	88 23       	and	r24, r24
    41b4:	89 f0       	breq	.+34     	; 0x41d8 <xQueueReceive+0xe4>
    41b6:	6c 81       	ldd	r22, Y+4	; 0x04
    41b8:	7d 81       	ldd	r23, Y+5	; 0x05
    41ba:	c5 01       	movw	r24, r10
    41bc:	0e 94 50 18 	call	0x30a0	; 0x30a0 <vTaskPlaceOnEventList>
    41c0:	c8 01       	movw	r24, r16
    41c2:	0e 94 10 1f 	call	0x3e20	; 0x3e20 <prvUnlockQueue>
    41c6:	0e 94 4b 17 	call	0x2e96	; 0x2e96 <xTaskResumeAll>
    41ca:	88 23       	and	r24, r24
    41cc:	11 f0       	breq	.+4      	; 0x41d2 <xQueueReceive+0xde>
    41ce:	81 e0       	ldi	r24, 0x01	; 1
    41d0:	a8 cf       	rjmp	.-176    	; 0x4122 <xQueueReceive+0x2e>
    41d2:	0e 94 df 1d 	call	0x3bbe	; 0x3bbe <vPortYield>
    41d6:	fb cf       	rjmp	.-10     	; 0x41ce <xQueueReceive+0xda>
    41d8:	c8 01       	movw	r24, r16
    41da:	0e 94 10 1f 	call	0x3e20	; 0x3e20 <prvUnlockQueue>
    41de:	0e 94 4b 17 	call	0x2e96	; 0x2e96 <xTaskResumeAll>
    41e2:	f5 cf       	rjmp	.-22     	; 0x41ce <xQueueReceive+0xda>
    41e4:	c8 01       	movw	r24, r16
    41e6:	0e 94 10 1f 	call	0x3e20	; 0x3e20 <prvUnlockQueue>
    41ea:	0e 94 4b 17 	call	0x2e96	; 0x2e96 <xTaskResumeAll>
    41ee:	c8 01       	movw	r24, r16
    41f0:	0e 94 98 1e 	call	0x3d30	; 0x3d30 <prvIsQueueEmpty>
    41f4:	88 23       	and	r24, r24
    41f6:	59 f3       	breq	.-42     	; 0x41ce <xQueueReceive+0xda>
    41f8:	80 e0       	ldi	r24, 0x00	; 0
    41fa:	0f 90       	pop	r0
    41fc:	0f 90       	pop	r0
    41fe:	0f 90       	pop	r0
    4200:	0f 90       	pop	r0
    4202:	0f 90       	pop	r0
    4204:	df 91       	pop	r29
    4206:	cf 91       	pop	r28
    4208:	1f 91       	pop	r17
    420a:	0f 91       	pop	r16
    420c:	ff 90       	pop	r15
    420e:	df 90       	pop	r13
    4210:	cf 90       	pop	r12
    4212:	bf 90       	pop	r11
    4214:	af 90       	pop	r10
    4216:	08 95       	ret

00004218 <vQueueWaitForMessageRestricted>:
/*-----------------------------------------------------------*/

#if ( configUSE_TIMERS == 1 )

    void vQueueWaitForMessageRestricted( QueueHandle_t xQueue, TickType_t xTicksToWait, const BaseType_t xWaitIndefinitely )
    {
    4218:	cf 93       	push	r28
    421a:	df 93       	push	r29
    421c:	ec 01       	movw	r28, r24
        will not actually cause the task to block, just place it on a blocked
        list.  It will not block until the scheduler is unlocked - at which
        time a yield will be performed.  If an item is added to the queue while
        the queue is locked, and the calling task blocks on the queue, then the
        calling task will be immediately unblocked when the queue is unlocked. */
        prvLockQueue( pxQueue );
    421e:	0f b6       	in	r0, 0x3f	; 63
    4220:	f8 94       	cli
    4222:	0f 92       	push	r0
    4224:	8d 8d       	ldd	r24, Y+29	; 0x1d
    4226:	8f 3f       	cpi	r24, 0xFF	; 255
    4228:	09 f4       	brne	.+2      	; 0x422c <vQueueWaitForMessageRestricted+0x14>
    422a:	1d 8e       	std	Y+29, r1	; 0x1d
    422c:	8e 8d       	ldd	r24, Y+30	; 0x1e
    422e:	8f 3f       	cpi	r24, 0xFF	; 255
    4230:	09 f4       	brne	.+2      	; 0x4234 <vQueueWaitForMessageRestricted+0x1c>
    4232:	1e 8e       	std	Y+30, r1	; 0x1e
    4234:	0f 90       	pop	r0
    4236:	0f be       	out	0x3f, r0	; 63
        if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0U )
    4238:	8a 8d       	ldd	r24, Y+26	; 0x1a
    423a:	81 11       	cpse	r24, r1
    423c:	04 c0       	rjmp	.+8      	; 0x4246 <vQueueWaitForMessageRestricted+0x2e>
        {
            /* There is nothing in the queue, block for the specified period. */
            vTaskPlaceOnEventListRestricted( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait, xWaitIndefinitely );
    423e:	ce 01       	movw	r24, r28
    4240:	41 96       	adiw	r24, 0x11	; 17
    4242:	0e 94 61 18 	call	0x30c2	; 0x30c2 <vTaskPlaceOnEventListRestricted>
        }
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }
        prvUnlockQueue( pxQueue );
    4246:	ce 01       	movw	r24, r28
    }
    4248:	df 91       	pop	r29
    424a:	cf 91       	pop	r28
        }
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }
        prvUnlockQueue( pxQueue );
    424c:	0c 94 10 1f 	jmp	0x3e20	; 0x3e20 <prvUnlockQueue>

00004250 <__unordsf2>:
    4250:	0e 94 ff 0c 	call	0x19fe	; 0x19fe <__fp_cmp>
    4254:	88 0b       	sbc	r24, r24
    4256:	99 0b       	sbc	r25, r25
    4258:	08 95       	ret

0000425a <__divmodhi4>:
    425a:	97 fb       	bst	r25, 7
    425c:	07 2e       	mov	r0, r23
    425e:	16 f4       	brtc	.+4      	; 0x4264 <__divmodhi4+0xa>
    4260:	00 94       	com	r0
    4262:	07 d0       	rcall	.+14     	; 0x4272 <__divmodhi4_neg1>
    4264:	77 fd       	sbrc	r23, 7
    4266:	09 d0       	rcall	.+18     	; 0x427a <__divmodhi4_neg2>
    4268:	0e 94 93 21 	call	0x4326	; 0x4326 <__udivmodhi4>
    426c:	07 fc       	sbrc	r0, 7
    426e:	05 d0       	rcall	.+10     	; 0x427a <__divmodhi4_neg2>
    4270:	3e f4       	brtc	.+14     	; 0x4280 <__divmodhi4_exit>

00004272 <__divmodhi4_neg1>:
    4272:	90 95       	com	r25
    4274:	81 95       	neg	r24
    4276:	9f 4f       	sbci	r25, 0xFF	; 255
    4278:	08 95       	ret

0000427a <__divmodhi4_neg2>:
    427a:	70 95       	com	r23
    427c:	61 95       	neg	r22
    427e:	7f 4f       	sbci	r23, 0xFF	; 255

00004280 <__divmodhi4_exit>:
    4280:	08 95       	ret

00004282 <__udivmodsi4>:
    4282:	a1 e2       	ldi	r26, 0x21	; 33
    4284:	1a 2e       	mov	r1, r26
    4286:	aa 1b       	sub	r26, r26
    4288:	bb 1b       	sub	r27, r27
    428a:	fd 01       	movw	r30, r26
    428c:	0d c0       	rjmp	.+26     	; 0x42a8 <__udivmodsi4_ep>

0000428e <__udivmodsi4_loop>:
    428e:	aa 1f       	adc	r26, r26
    4290:	bb 1f       	adc	r27, r27
    4292:	ee 1f       	adc	r30, r30
    4294:	ff 1f       	adc	r31, r31
    4296:	a2 17       	cp	r26, r18
    4298:	b3 07       	cpc	r27, r19
    429a:	e4 07       	cpc	r30, r20
    429c:	f5 07       	cpc	r31, r21
    429e:	20 f0       	brcs	.+8      	; 0x42a8 <__udivmodsi4_ep>
    42a0:	a2 1b       	sub	r26, r18
    42a2:	b3 0b       	sbc	r27, r19
    42a4:	e4 0b       	sbc	r30, r20
    42a6:	f5 0b       	sbc	r31, r21

000042a8 <__udivmodsi4_ep>:
    42a8:	66 1f       	adc	r22, r22
    42aa:	77 1f       	adc	r23, r23
    42ac:	88 1f       	adc	r24, r24
    42ae:	99 1f       	adc	r25, r25
    42b0:	1a 94       	dec	r1
    42b2:	69 f7       	brne	.-38     	; 0x428e <__udivmodsi4_loop>
    42b4:	60 95       	com	r22
    42b6:	70 95       	com	r23
    42b8:	80 95       	com	r24
    42ba:	90 95       	com	r25
    42bc:	9b 01       	movw	r18, r22
    42be:	ac 01       	movw	r20, r24
    42c0:	bd 01       	movw	r22, r26
    42c2:	cf 01       	movw	r24, r30
    42c4:	08 95       	ret

000042c6 <__divmodsi4>:
    42c6:	05 2e       	mov	r0, r21
    42c8:	97 fb       	bst	r25, 7
    42ca:	1e f4       	brtc	.+6      	; 0x42d2 <__divmodsi4+0xc>
    42cc:	00 94       	com	r0
    42ce:	0e 94 7a 21 	call	0x42f4	; 0x42f4 <__negsi2>
    42d2:	57 fd       	sbrc	r21, 7
    42d4:	07 d0       	rcall	.+14     	; 0x42e4 <__divmodsi4_neg2>
    42d6:	0e 94 41 21 	call	0x4282	; 0x4282 <__udivmodsi4>
    42da:	07 fc       	sbrc	r0, 7
    42dc:	03 d0       	rcall	.+6      	; 0x42e4 <__divmodsi4_neg2>
    42de:	4e f4       	brtc	.+18     	; 0x42f2 <__divmodsi4_exit>
    42e0:	0c 94 7a 21 	jmp	0x42f4	; 0x42f4 <__negsi2>

000042e4 <__divmodsi4_neg2>:
    42e4:	50 95       	com	r21
    42e6:	40 95       	com	r20
    42e8:	30 95       	com	r19
    42ea:	21 95       	neg	r18
    42ec:	3f 4f       	sbci	r19, 0xFF	; 255
    42ee:	4f 4f       	sbci	r20, 0xFF	; 255
    42f0:	5f 4f       	sbci	r21, 0xFF	; 255

000042f2 <__divmodsi4_exit>:
    42f2:	08 95       	ret

000042f4 <__negsi2>:
    42f4:	90 95       	com	r25
    42f6:	80 95       	com	r24
    42f8:	70 95       	com	r23
    42fa:	61 95       	neg	r22
    42fc:	7f 4f       	sbci	r23, 0xFF	; 255
    42fe:	8f 4f       	sbci	r24, 0xFF	; 255
    4300:	9f 4f       	sbci	r25, 0xFF	; 255
    4302:	08 95       	ret

00004304 <__tablejump2__>:
    4304:	ee 0f       	add	r30, r30
    4306:	ff 1f       	adc	r31, r31
    4308:	05 90       	lpm	r0, Z+
    430a:	f4 91       	lpm	r31, Z
    430c:	e0 2d       	mov	r30, r0
    430e:	09 94       	ijmp

00004310 <__muluhisi3>:
    4310:	0e 94 a7 21 	call	0x434e	; 0x434e <__umulhisi3>
    4314:	a5 9f       	mul	r26, r21
    4316:	90 0d       	add	r25, r0
    4318:	b4 9f       	mul	r27, r20
    431a:	90 0d       	add	r25, r0
    431c:	a4 9f       	mul	r26, r20
    431e:	80 0d       	add	r24, r0
    4320:	91 1d       	adc	r25, r1
    4322:	11 24       	eor	r1, r1
    4324:	08 95       	ret

00004326 <__udivmodhi4>:
    4326:	aa 1b       	sub	r26, r26
    4328:	bb 1b       	sub	r27, r27
    432a:	51 e1       	ldi	r21, 0x11	; 17
    432c:	07 c0       	rjmp	.+14     	; 0x433c <__udivmodhi4_ep>

0000432e <__udivmodhi4_loop>:
    432e:	aa 1f       	adc	r26, r26
    4330:	bb 1f       	adc	r27, r27
    4332:	a6 17       	cp	r26, r22
    4334:	b7 07       	cpc	r27, r23
    4336:	10 f0       	brcs	.+4      	; 0x433c <__udivmodhi4_ep>
    4338:	a6 1b       	sub	r26, r22
    433a:	b7 0b       	sbc	r27, r23

0000433c <__udivmodhi4_ep>:
    433c:	88 1f       	adc	r24, r24
    433e:	99 1f       	adc	r25, r25
    4340:	5a 95       	dec	r21
    4342:	a9 f7       	brne	.-22     	; 0x432e <__udivmodhi4_loop>
    4344:	80 95       	com	r24
    4346:	90 95       	com	r25
    4348:	bc 01       	movw	r22, r24
    434a:	cd 01       	movw	r24, r26
    434c:	08 95       	ret

0000434e <__umulhisi3>:
    434e:	a2 9f       	mul	r26, r18
    4350:	b0 01       	movw	r22, r0
    4352:	b3 9f       	mul	r27, r19
    4354:	c0 01       	movw	r24, r0
    4356:	a3 9f       	mul	r26, r19
    4358:	70 0d       	add	r23, r0
    435a:	81 1d       	adc	r24, r1
    435c:	11 24       	eor	r1, r1
    435e:	91 1d       	adc	r25, r1
    4360:	b2 9f       	mul	r27, r18
    4362:	70 0d       	add	r23, r0
    4364:	81 1d       	adc	r24, r1
    4366:	11 24       	eor	r1, r1
    4368:	91 1d       	adc	r25, r1
    436a:	08 95       	ret

0000436c <malloc>:
    436c:	0f 93       	push	r16
    436e:	1f 93       	push	r17
    4370:	cf 93       	push	r28
    4372:	df 93       	push	r29
    4374:	82 30       	cpi	r24, 0x02	; 2
    4376:	91 05       	cpc	r25, r1
    4378:	10 f4       	brcc	.+4      	; 0x437e <malloc+0x12>
    437a:	82 e0       	ldi	r24, 0x02	; 2
    437c:	90 e0       	ldi	r25, 0x00	; 0
    437e:	e0 91 34 05 	lds	r30, 0x0534	; 0x800534 <__flp>
    4382:	f0 91 35 05 	lds	r31, 0x0535	; 0x800535 <__flp+0x1>
    4386:	20 e0       	ldi	r18, 0x00	; 0
    4388:	30 e0       	ldi	r19, 0x00	; 0
    438a:	a0 e0       	ldi	r26, 0x00	; 0
    438c:	b0 e0       	ldi	r27, 0x00	; 0
    438e:	30 97       	sbiw	r30, 0x00	; 0
    4390:	19 f1       	breq	.+70     	; 0x43d8 <malloc+0x6c>
    4392:	40 81       	ld	r20, Z
    4394:	51 81       	ldd	r21, Z+1	; 0x01
    4396:	02 81       	ldd	r16, Z+2	; 0x02
    4398:	13 81       	ldd	r17, Z+3	; 0x03
    439a:	48 17       	cp	r20, r24
    439c:	59 07       	cpc	r21, r25
    439e:	c8 f0       	brcs	.+50     	; 0x43d2 <malloc+0x66>
    43a0:	84 17       	cp	r24, r20
    43a2:	95 07       	cpc	r25, r21
    43a4:	69 f4       	brne	.+26     	; 0x43c0 <malloc+0x54>
    43a6:	10 97       	sbiw	r26, 0x00	; 0
    43a8:	31 f0       	breq	.+12     	; 0x43b6 <malloc+0x4a>
    43aa:	12 96       	adiw	r26, 0x02	; 2
    43ac:	0c 93       	st	X, r16
    43ae:	12 97       	sbiw	r26, 0x02	; 2
    43b0:	13 96       	adiw	r26, 0x03	; 3
    43b2:	1c 93       	st	X, r17
    43b4:	27 c0       	rjmp	.+78     	; 0x4404 <malloc+0x98>
    43b6:	00 93 34 05 	sts	0x0534, r16	; 0x800534 <__flp>
    43ba:	10 93 35 05 	sts	0x0535, r17	; 0x800535 <__flp+0x1>
    43be:	22 c0       	rjmp	.+68     	; 0x4404 <malloc+0x98>
    43c0:	21 15       	cp	r18, r1
    43c2:	31 05       	cpc	r19, r1
    43c4:	19 f0       	breq	.+6      	; 0x43cc <malloc+0x60>
    43c6:	42 17       	cp	r20, r18
    43c8:	53 07       	cpc	r21, r19
    43ca:	18 f4       	brcc	.+6      	; 0x43d2 <malloc+0x66>
    43cc:	9a 01       	movw	r18, r20
    43ce:	bd 01       	movw	r22, r26
    43d0:	ef 01       	movw	r28, r30
    43d2:	df 01       	movw	r26, r30
    43d4:	f8 01       	movw	r30, r16
    43d6:	db cf       	rjmp	.-74     	; 0x438e <malloc+0x22>
    43d8:	21 15       	cp	r18, r1
    43da:	31 05       	cpc	r19, r1
    43dc:	f9 f0       	breq	.+62     	; 0x441c <malloc+0xb0>
    43de:	28 1b       	sub	r18, r24
    43e0:	39 0b       	sbc	r19, r25
    43e2:	24 30       	cpi	r18, 0x04	; 4
    43e4:	31 05       	cpc	r19, r1
    43e6:	80 f4       	brcc	.+32     	; 0x4408 <malloc+0x9c>
    43e8:	8a 81       	ldd	r24, Y+2	; 0x02
    43ea:	9b 81       	ldd	r25, Y+3	; 0x03
    43ec:	61 15       	cp	r22, r1
    43ee:	71 05       	cpc	r23, r1
    43f0:	21 f0       	breq	.+8      	; 0x43fa <malloc+0x8e>
    43f2:	fb 01       	movw	r30, r22
    43f4:	93 83       	std	Z+3, r25	; 0x03
    43f6:	82 83       	std	Z+2, r24	; 0x02
    43f8:	04 c0       	rjmp	.+8      	; 0x4402 <malloc+0x96>
    43fa:	90 93 35 05 	sts	0x0535, r25	; 0x800535 <__flp+0x1>
    43fe:	80 93 34 05 	sts	0x0534, r24	; 0x800534 <__flp>
    4402:	fe 01       	movw	r30, r28
    4404:	32 96       	adiw	r30, 0x02	; 2
    4406:	44 c0       	rjmp	.+136    	; 0x4490 <malloc+0x124>
    4408:	fe 01       	movw	r30, r28
    440a:	e2 0f       	add	r30, r18
    440c:	f3 1f       	adc	r31, r19
    440e:	81 93       	st	Z+, r24
    4410:	91 93       	st	Z+, r25
    4412:	22 50       	subi	r18, 0x02	; 2
    4414:	31 09       	sbc	r19, r1
    4416:	39 83       	std	Y+1, r19	; 0x01
    4418:	28 83       	st	Y, r18
    441a:	3a c0       	rjmp	.+116    	; 0x4490 <malloc+0x124>
    441c:	20 91 32 05 	lds	r18, 0x0532	; 0x800532 <__brkval>
    4420:	30 91 33 05 	lds	r19, 0x0533	; 0x800533 <__brkval+0x1>
    4424:	23 2b       	or	r18, r19
    4426:	41 f4       	brne	.+16     	; 0x4438 <malloc+0xcc>
    4428:	20 91 02 01 	lds	r18, 0x0102	; 0x800102 <__malloc_heap_start>
    442c:	30 91 03 01 	lds	r19, 0x0103	; 0x800103 <__malloc_heap_start+0x1>
    4430:	30 93 33 05 	sts	0x0533, r19	; 0x800533 <__brkval+0x1>
    4434:	20 93 32 05 	sts	0x0532, r18	; 0x800532 <__brkval>
    4438:	20 91 00 01 	lds	r18, 0x0100	; 0x800100 <__data_start>
    443c:	30 91 01 01 	lds	r19, 0x0101	; 0x800101 <__data_start+0x1>
    4440:	21 15       	cp	r18, r1
    4442:	31 05       	cpc	r19, r1
    4444:	41 f4       	brne	.+16     	; 0x4456 <malloc+0xea>
    4446:	2d b7       	in	r18, 0x3d	; 61
    4448:	3e b7       	in	r19, 0x3e	; 62
    444a:	40 91 04 01 	lds	r20, 0x0104	; 0x800104 <__malloc_margin>
    444e:	50 91 05 01 	lds	r21, 0x0105	; 0x800105 <__malloc_margin+0x1>
    4452:	24 1b       	sub	r18, r20
    4454:	35 0b       	sbc	r19, r21
    4456:	e0 91 32 05 	lds	r30, 0x0532	; 0x800532 <__brkval>
    445a:	f0 91 33 05 	lds	r31, 0x0533	; 0x800533 <__brkval+0x1>
    445e:	e2 17       	cp	r30, r18
    4460:	f3 07       	cpc	r31, r19
    4462:	a0 f4       	brcc	.+40     	; 0x448c <malloc+0x120>
    4464:	2e 1b       	sub	r18, r30
    4466:	3f 0b       	sbc	r19, r31
    4468:	28 17       	cp	r18, r24
    446a:	39 07       	cpc	r19, r25
    446c:	78 f0       	brcs	.+30     	; 0x448c <malloc+0x120>
    446e:	ac 01       	movw	r20, r24
    4470:	4e 5f       	subi	r20, 0xFE	; 254
    4472:	5f 4f       	sbci	r21, 0xFF	; 255
    4474:	24 17       	cp	r18, r20
    4476:	35 07       	cpc	r19, r21
    4478:	48 f0       	brcs	.+18     	; 0x448c <malloc+0x120>
    447a:	4e 0f       	add	r20, r30
    447c:	5f 1f       	adc	r21, r31
    447e:	50 93 33 05 	sts	0x0533, r21	; 0x800533 <__brkval+0x1>
    4482:	40 93 32 05 	sts	0x0532, r20	; 0x800532 <__brkval>
    4486:	81 93       	st	Z+, r24
    4488:	91 93       	st	Z+, r25
    448a:	02 c0       	rjmp	.+4      	; 0x4490 <malloc+0x124>
    448c:	e0 e0       	ldi	r30, 0x00	; 0
    448e:	f0 e0       	ldi	r31, 0x00	; 0
    4490:	cf 01       	movw	r24, r30
    4492:	df 91       	pop	r29
    4494:	cf 91       	pop	r28
    4496:	1f 91       	pop	r17
    4498:	0f 91       	pop	r16
    449a:	08 95       	ret

0000449c <free>:
    449c:	cf 93       	push	r28
    449e:	df 93       	push	r29
    44a0:	00 97       	sbiw	r24, 0x00	; 0
    44a2:	09 f4       	brne	.+2      	; 0x44a6 <free+0xa>
    44a4:	81 c0       	rjmp	.+258    	; 0x45a8 <free+0x10c>
    44a6:	fc 01       	movw	r30, r24
    44a8:	32 97       	sbiw	r30, 0x02	; 2
    44aa:	13 82       	std	Z+3, r1	; 0x03
    44ac:	12 82       	std	Z+2, r1	; 0x02
    44ae:	a0 91 34 05 	lds	r26, 0x0534	; 0x800534 <__flp>
    44b2:	b0 91 35 05 	lds	r27, 0x0535	; 0x800535 <__flp+0x1>
    44b6:	10 97       	sbiw	r26, 0x00	; 0
    44b8:	81 f4       	brne	.+32     	; 0x44da <free+0x3e>
    44ba:	20 81       	ld	r18, Z
    44bc:	31 81       	ldd	r19, Z+1	; 0x01
    44be:	82 0f       	add	r24, r18
    44c0:	93 1f       	adc	r25, r19
    44c2:	20 91 32 05 	lds	r18, 0x0532	; 0x800532 <__brkval>
    44c6:	30 91 33 05 	lds	r19, 0x0533	; 0x800533 <__brkval+0x1>
    44ca:	28 17       	cp	r18, r24
    44cc:	39 07       	cpc	r19, r25
    44ce:	51 f5       	brne	.+84     	; 0x4524 <free+0x88>
    44d0:	f0 93 33 05 	sts	0x0533, r31	; 0x800533 <__brkval+0x1>
    44d4:	e0 93 32 05 	sts	0x0532, r30	; 0x800532 <__brkval>
    44d8:	67 c0       	rjmp	.+206    	; 0x45a8 <free+0x10c>
    44da:	ed 01       	movw	r28, r26
    44dc:	20 e0       	ldi	r18, 0x00	; 0
    44de:	30 e0       	ldi	r19, 0x00	; 0
    44e0:	ce 17       	cp	r28, r30
    44e2:	df 07       	cpc	r29, r31
    44e4:	40 f4       	brcc	.+16     	; 0x44f6 <free+0x5a>
    44e6:	4a 81       	ldd	r20, Y+2	; 0x02
    44e8:	5b 81       	ldd	r21, Y+3	; 0x03
    44ea:	9e 01       	movw	r18, r28
    44ec:	41 15       	cp	r20, r1
    44ee:	51 05       	cpc	r21, r1
    44f0:	f1 f0       	breq	.+60     	; 0x452e <free+0x92>
    44f2:	ea 01       	movw	r28, r20
    44f4:	f5 cf       	rjmp	.-22     	; 0x44e0 <free+0x44>
    44f6:	d3 83       	std	Z+3, r29	; 0x03
    44f8:	c2 83       	std	Z+2, r28	; 0x02
    44fa:	40 81       	ld	r20, Z
    44fc:	51 81       	ldd	r21, Z+1	; 0x01
    44fe:	84 0f       	add	r24, r20
    4500:	95 1f       	adc	r25, r21
    4502:	c8 17       	cp	r28, r24
    4504:	d9 07       	cpc	r29, r25
    4506:	59 f4       	brne	.+22     	; 0x451e <free+0x82>
    4508:	88 81       	ld	r24, Y
    450a:	99 81       	ldd	r25, Y+1	; 0x01
    450c:	84 0f       	add	r24, r20
    450e:	95 1f       	adc	r25, r21
    4510:	02 96       	adiw	r24, 0x02	; 2
    4512:	91 83       	std	Z+1, r25	; 0x01
    4514:	80 83       	st	Z, r24
    4516:	8a 81       	ldd	r24, Y+2	; 0x02
    4518:	9b 81       	ldd	r25, Y+3	; 0x03
    451a:	93 83       	std	Z+3, r25	; 0x03
    451c:	82 83       	std	Z+2, r24	; 0x02
    451e:	21 15       	cp	r18, r1
    4520:	31 05       	cpc	r19, r1
    4522:	29 f4       	brne	.+10     	; 0x452e <free+0x92>
    4524:	f0 93 35 05 	sts	0x0535, r31	; 0x800535 <__flp+0x1>
    4528:	e0 93 34 05 	sts	0x0534, r30	; 0x800534 <__flp>
    452c:	3d c0       	rjmp	.+122    	; 0x45a8 <free+0x10c>
    452e:	e9 01       	movw	r28, r18
    4530:	fb 83       	std	Y+3, r31	; 0x03
    4532:	ea 83       	std	Y+2, r30	; 0x02
    4534:	49 91       	ld	r20, Y+
    4536:	59 91       	ld	r21, Y+
    4538:	c4 0f       	add	r28, r20
    453a:	d5 1f       	adc	r29, r21
    453c:	ec 17       	cp	r30, r28
    453e:	fd 07       	cpc	r31, r29
    4540:	61 f4       	brne	.+24     	; 0x455a <free+0xbe>
    4542:	80 81       	ld	r24, Z
    4544:	91 81       	ldd	r25, Z+1	; 0x01
    4546:	84 0f       	add	r24, r20
    4548:	95 1f       	adc	r25, r21
    454a:	02 96       	adiw	r24, 0x02	; 2
    454c:	e9 01       	movw	r28, r18
    454e:	99 83       	std	Y+1, r25	; 0x01
    4550:	88 83       	st	Y, r24
    4552:	82 81       	ldd	r24, Z+2	; 0x02
    4554:	93 81       	ldd	r25, Z+3	; 0x03
    4556:	9b 83       	std	Y+3, r25	; 0x03
    4558:	8a 83       	std	Y+2, r24	; 0x02
    455a:	e0 e0       	ldi	r30, 0x00	; 0
    455c:	f0 e0       	ldi	r31, 0x00	; 0
    455e:	12 96       	adiw	r26, 0x02	; 2
    4560:	8d 91       	ld	r24, X+
    4562:	9c 91       	ld	r25, X
    4564:	13 97       	sbiw	r26, 0x03	; 3
    4566:	00 97       	sbiw	r24, 0x00	; 0
    4568:	19 f0       	breq	.+6      	; 0x4570 <free+0xd4>
    456a:	fd 01       	movw	r30, r26
    456c:	dc 01       	movw	r26, r24
    456e:	f7 cf       	rjmp	.-18     	; 0x455e <free+0xc2>
    4570:	8d 91       	ld	r24, X+
    4572:	9c 91       	ld	r25, X
    4574:	11 97       	sbiw	r26, 0x01	; 1
    4576:	9d 01       	movw	r18, r26
    4578:	2e 5f       	subi	r18, 0xFE	; 254
    457a:	3f 4f       	sbci	r19, 0xFF	; 255
    457c:	82 0f       	add	r24, r18
    457e:	93 1f       	adc	r25, r19
    4580:	20 91 32 05 	lds	r18, 0x0532	; 0x800532 <__brkval>
    4584:	30 91 33 05 	lds	r19, 0x0533	; 0x800533 <__brkval+0x1>
    4588:	28 17       	cp	r18, r24
    458a:	39 07       	cpc	r19, r25
    458c:	69 f4       	brne	.+26     	; 0x45a8 <free+0x10c>
    458e:	30 97       	sbiw	r30, 0x00	; 0
    4590:	29 f4       	brne	.+10     	; 0x459c <free+0x100>
    4592:	10 92 35 05 	sts	0x0535, r1	; 0x800535 <__flp+0x1>
    4596:	10 92 34 05 	sts	0x0534, r1	; 0x800534 <__flp>
    459a:	02 c0       	rjmp	.+4      	; 0x45a0 <free+0x104>
    459c:	13 82       	std	Z+3, r1	; 0x03
    459e:	12 82       	std	Z+2, r1	; 0x02
    45a0:	b0 93 33 05 	sts	0x0533, r27	; 0x800533 <__brkval+0x1>
    45a4:	a0 93 32 05 	sts	0x0532, r26	; 0x800532 <__brkval>
    45a8:	df 91       	pop	r29
    45aa:	cf 91       	pop	r28
    45ac:	08 95       	ret

000045ae <memcpy>:
    45ae:	fb 01       	movw	r30, r22
    45b0:	dc 01       	movw	r26, r24
    45b2:	02 c0       	rjmp	.+4      	; 0x45b8 <memcpy+0xa>
    45b4:	01 90       	ld	r0, Z+
    45b6:	0d 92       	st	X+, r0
    45b8:	41 50       	subi	r20, 0x01	; 1
    45ba:	50 40       	sbci	r21, 0x00	; 0
    45bc:	d8 f7       	brcc	.-10     	; 0x45b4 <memcpy+0x6>
    45be:	08 95       	ret

000045c0 <memset>:
    45c0:	dc 01       	movw	r26, r24
    45c2:	01 c0       	rjmp	.+2      	; 0x45c6 <memset+0x6>
    45c4:	6d 93       	st	X+, r22
    45c6:	41 50       	subi	r20, 0x01	; 1
    45c8:	50 40       	sbci	r21, 0x00	; 0
    45ca:	e0 f7       	brcc	.-8      	; 0x45c4 <memset+0x4>
    45cc:	08 95       	ret

000045ce <eeprom_read_byte>:
    45ce:	f9 99       	sbic	0x1f, 1	; 31
    45d0:	fe cf       	rjmp	.-4      	; 0x45ce <eeprom_read_byte>
    45d2:	92 bd       	out	0x22, r25	; 34
    45d4:	81 bd       	out	0x21, r24	; 33
    45d6:	f8 9a       	sbi	0x1f, 0	; 31
    45d8:	99 27       	eor	r25, r25
    45da:	80 b5       	in	r24, 0x20	; 32
    45dc:	08 95       	ret

000045de <eeprom_write_byte>:
    45de:	26 2f       	mov	r18, r22

000045e0 <eeprom_write_r18>:
    45e0:	f9 99       	sbic	0x1f, 1	; 31
    45e2:	fe cf       	rjmp	.-4      	; 0x45e0 <eeprom_write_r18>
    45e4:	1f ba       	out	0x1f, r1	; 31
    45e6:	92 bd       	out	0x22, r25	; 34
    45e8:	81 bd       	out	0x21, r24	; 33
    45ea:	20 bd       	out	0x20, r18	; 32
    45ec:	0f b6       	in	r0, 0x3f	; 63
    45ee:	f8 94       	cli
    45f0:	fa 9a       	sbi	0x1f, 2	; 31
    45f2:	f9 9a       	sbi	0x1f, 1	; 31
    45f4:	0f be       	out	0x3f, r0	; 63
    45f6:	01 96       	adiw	r24, 0x01	; 1
    45f8:	08 95       	ret

000045fa <__do_global_dtors>:
    45fa:	10 e0       	ldi	r17, 0x00	; 0
    45fc:	c9 e8       	ldi	r28, 0x89	; 137
    45fe:	d0 e0       	ldi	r29, 0x00	; 0
    4600:	04 c0       	rjmp	.+8      	; 0x460a <__do_global_dtors+0x10>
    4602:	fe 01       	movw	r30, r28
    4604:	0e 94 82 21 	call	0x4304	; 0x4304 <__tablejump2__>
    4608:	21 96       	adiw	r28, 0x01	; 1
    460a:	cb 38       	cpi	r28, 0x8B	; 139
    460c:	d1 07       	cpc	r29, r17
    460e:	c9 f7       	brne	.-14     	; 0x4602 <__do_global_dtors+0x8>
    4610:	f8 94       	cli

00004612 <__stop_program>:
    4612:	ff cf       	rjmp	.-2      	; 0x4612 <__stop_program>
