
lil_fish_tanks_arduino.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         000001da  00800100  000042ba  0000434e  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         000042ba  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          000002d2  008002da  008002da  00004528  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00004528  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00004558  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000ab0  00000000  00000000  00004598  2**3
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   0001653d  00000000  00000000  00005048  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 0000435a  00000000  00000000  0001b585  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   000072ec  00000000  00000000  0001f8df  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  000020b0  00000000  00000000  00026bcc  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00005128  00000000  00000000  00028c7c  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    0000c4fd  00000000  00000000  0002dda4  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000a08  00000000  00000000  0003a2a1  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 80 00 	jmp	0x100	; 0x100 <__dtors_end>
       4:	0c 94 02 11 	jmp	0x2204	; 0x2204 <__vector_1>
       8:	0c 94 29 11 	jmp	0x2252	; 0x2252 <__vector_2>
       c:	0c 94 ba 09 	jmp	0x1374	; 0x1374 <__vector_3>
      10:	0c 94 ba 09 	jmp	0x1374	; 0x1374 <__vector_3>
      14:	0c 94 ba 09 	jmp	0x1374	; 0x1374 <__vector_3>
      18:	0c 94 92 1f 	jmp	0x3f24	; 0x3f24 <__vector_6>
      1c:	0c 94 0e 1d 	jmp	0x3a1c	; 0x3a1c <__vector_7>
      20:	0c 94 a8 00 	jmp	0x150	; 0x150 <__bad_interrupt>
      24:	0c 94 a8 00 	jmp	0x150	; 0x150 <__bad_interrupt>
      28:	0c 94 a8 00 	jmp	0x150	; 0x150 <__bad_interrupt>
      2c:	0c 94 a8 00 	jmp	0x150	; 0x150 <__bad_interrupt>
      30:	0c 94 a8 00 	jmp	0x150	; 0x150 <__bad_interrupt>
      34:	0c 94 a8 00 	jmp	0x150	; 0x150 <__bad_interrupt>
      38:	0c 94 a8 00 	jmp	0x150	; 0x150 <__bad_interrupt>
      3c:	0c 94 a8 00 	jmp	0x150	; 0x150 <__bad_interrupt>
      40:	0c 94 50 11 	jmp	0x22a0	; 0x22a0 <__vector_16>
      44:	0c 94 a8 00 	jmp	0x150	; 0x150 <__bad_interrupt>
      48:	0c 94 60 0e 	jmp	0x1cc0	; 0x1cc0 <__vector_18>
      4c:	0c 94 92 0e 	jmp	0x1d24	; 0x1d24 <__vector_19>
      50:	0c 94 a8 00 	jmp	0x150	; 0x150 <__bad_interrupt>
      54:	0c 94 a8 00 	jmp	0x150	; 0x150 <__bad_interrupt>
      58:	0c 94 a8 00 	jmp	0x150	; 0x150 <__bad_interrupt>
      5c:	0c 94 a8 00 	jmp	0x150	; 0x150 <__bad_interrupt>
      60:	0c 94 a8 00 	jmp	0x150	; 0x150 <__bad_interrupt>
      64:	0c 94 a8 00 	jmp	0x150	; 0x150 <__bad_interrupt>
      68:	a2 1c       	adc	r10, r2
      6a:	a2 1c       	adc	r10, r2
      6c:	a2 1c       	adc	r10, r2
      6e:	e1 1c       	adc	r14, r1
      70:	cc 1c       	adc	r12, r12
      72:	db 1c       	adc	r13, r11
      74:	a2 1c       	adc	r10, r2
      76:	a2 1c       	adc	r10, r2
      78:	e1 1c       	adc	r14, r1
      7a:	cc 1c       	adc	r12, r12

0000007c <__trampolines_end>:
      7c:	00 5e       	subi	r16, 0xE0	; 224
      7e:	bc e2       	ldi	r27, 0x2C	; 44
      80:	61 3f       	cpi	r22, 0xF1	; 241
      82:	dd 83       	std	Y+5, r29	; 0x05
      84:	c2 9c       	mul	r12, r2
      86:	7e 20       	and	r7, r14
      88:	a3 fd       	sbrc	r26, 3
      8a:	1f 41       	sbci	r17, 0x1F	; 31
      8c:	00 9d       	mul	r16, r0
      8e:	23 be       	out	0x33, r2	; 51
      90:	46 db       	rcall	.-2420   	; 0xfffff71e <__eeprom_end+0xff7ef71e>
      92:	65 f8       	bld	r6, 5
      94:	8c 11       	cpse	r24, r12
      96:	af 32       	cpi	r26, 0x2F	; 47
      98:	ca 57       	subi	r28, 0x7A	; 122
      9a:	e9 74       	andi	r30, 0x49	; 73

0000009c <digital_pin_to_timer_PGM>:
      9c:	00 00 00 08 00 02 01 00 00 03 04 07 00 00 00 00     ................
      ac:	00 00 00 00                                         ....

000000b0 <digital_pin_to_bit_mask_PGM>:
      b0:	01 02 04 08 10 20 40 80 01 02 04 08 10 20 01 02     ..... @...... ..
      c0:	04 08 10 20                                         ... 

000000c4 <digital_pin_to_port_PGM>:
      c4:	04 04 04 04 04 04 04 04 02 02 02 02 02 02 03 03     ................
      d4:	03 03 03 03                                         ....

000000d8 <port_to_input_PGM>:
      d8:	00 00 00 00 23 00 26 00 29 00                       ....#.&.).

000000e2 <port_to_output_PGM>:
      e2:	00 00 00 00 25 00 28 00 2b 00                       ....%.(.+.

000000ec <port_to_mode_PGM>:
      ec:	00 00 00 00 24 00 27 00 2a 00                       ....$.'.*.

000000f6 <__ctors_start>:
      f6:	f4 04       	cpc	r15, r4
      f8:	30 08       	sbc	r3, r0
      fa:	c2 0e       	add	r12, r18

000000fc <__ctors_end>:
      fc:	07 05       	cpc	r16, r7
      fe:	34 08       	sbc	r3, r4

00000100 <__dtors_end>:
     100:	11 24       	eor	r1, r1
     102:	1f be       	out	0x3f, r1	; 63
     104:	cf ef       	ldi	r28, 0xFF	; 255
     106:	d8 e0       	ldi	r29, 0x08	; 8
     108:	de bf       	out	0x3e, r29	; 62
     10a:	cd bf       	out	0x3d, r28	; 61

0000010c <__do_copy_data>:
     10c:	12 e0       	ldi	r17, 0x02	; 2
     10e:	a0 e0       	ldi	r26, 0x00	; 0
     110:	b1 e0       	ldi	r27, 0x01	; 1
     112:	ea eb       	ldi	r30, 0xBA	; 186
     114:	f2 e4       	ldi	r31, 0x42	; 66
     116:	02 c0       	rjmp	.+4      	; 0x11c <__do_copy_data+0x10>
     118:	05 90       	lpm	r0, Z+
     11a:	0d 92       	st	X+, r0
     11c:	aa 3d       	cpi	r26, 0xDA	; 218
     11e:	b1 07       	cpc	r27, r17
     120:	d9 f7       	brne	.-10     	; 0x118 <__do_copy_data+0xc>

00000122 <__do_clear_bss>:
     122:	25 e0       	ldi	r18, 0x05	; 5
     124:	aa ed       	ldi	r26, 0xDA	; 218
     126:	b2 e0       	ldi	r27, 0x02	; 2
     128:	01 c0       	rjmp	.+2      	; 0x12c <.do_clear_bss_start>

0000012a <.do_clear_bss_loop>:
     12a:	1d 92       	st	X+, r1

0000012c <.do_clear_bss_start>:
     12c:	ac 3a       	cpi	r26, 0xAC	; 172
     12e:	b2 07       	cpc	r27, r18
     130:	e1 f7       	brne	.-8      	; 0x12a <.do_clear_bss_loop>

00000132 <__do_global_ctors>:
     132:	10 e0       	ldi	r17, 0x00	; 0
     134:	ce e7       	ldi	r28, 0x7E	; 126
     136:	d0 e0       	ldi	r29, 0x00	; 0
     138:	04 c0       	rjmp	.+8      	; 0x142 <__do_global_ctors+0x10>
     13a:	21 97       	sbiw	r28, 0x01	; 1
     13c:	fe 01       	movw	r30, r28
     13e:	0e 94 ef 1f 	call	0x3fde	; 0x3fde <__tablejump2__>
     142:	cb 37       	cpi	r28, 0x7B	; 123
     144:	d1 07       	cpc	r29, r17
     146:	c9 f7       	brne	.-14     	; 0x13a <__do_global_ctors+0x8>
     148:	0e 94 ef 0e 	call	0x1dde	; 0x1dde <main>
     14c:	0c 94 50 21 	jmp	0x42a0	; 0x42a0 <__do_global_dtors>

00000150 <__bad_interrupt>:
     150:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000154 <_ZN11EEPROMClass4readEi.isra.0>:
     154:	0c 94 3a 21 	jmp	0x4274	; 0x4274 <eeprom_read_byte>

00000158 <_ZN10DFRobot_PHC1Ev>:
     158:	fc 01       	movw	r30, r24
     15a:	80 e0       	ldi	r24, 0x00	; 0
     15c:	90 e0       	ldi	r25, 0x00	; 0
     15e:	a8 ec       	ldi	r26, 0xC8	; 200
     160:	b1 e4       	ldi	r27, 0x41	; 65
     162:	80 8b       	std	Z+16, r24	; 0x10
     164:	91 8b       	std	Z+17, r25	; 0x11
     166:	a2 8b       	std	Z+18, r26	; 0x12
     168:	b3 8b       	std	Z+19, r27	; 0x13
     16a:	80 e0       	ldi	r24, 0x00	; 0
     16c:	90 e0       	ldi	r25, 0x00	; 0
     16e:	a0 ee       	ldi	r26, 0xE0	; 224
     170:	b0 e4       	ldi	r27, 0x40	; 64
     172:	80 83       	st	Z, r24
     174:	91 83       	std	Z+1, r25	; 0x01
     176:	a2 83       	std	Z+2, r26	; 0x02
     178:	b3 83       	std	Z+3, r27	; 0x03
     17a:	84 e1       	ldi	r24, 0x14	; 20
     17c:	9e e0       	ldi	r25, 0x0E	; 14
     17e:	ae ef       	ldi	r26, 0xFE	; 254
     180:	b4 e4       	ldi	r27, 0x44	; 68
     182:	84 83       	std	Z+4, r24	; 0x04
     184:	95 83       	std	Z+5, r25	; 0x05
     186:	a6 83       	std	Z+6, r26	; 0x06
     188:	b7 83       	std	Z+7, r27	; 0x07
     18a:	80 e0       	ldi	r24, 0x00	; 0
     18c:	90 e8       	ldi	r25, 0x80	; 128
     18e:	ab eb       	ldi	r26, 0xBB	; 187
     190:	b4 e4       	ldi	r27, 0x44	; 68
     192:	80 87       	std	Z+8, r24	; 0x08
     194:	91 87       	std	Z+9, r25	; 0x09
     196:	a2 87       	std	Z+10, r26	; 0x0a
     198:	b3 87       	std	Z+11, r27	; 0x0b
     19a:	84 87       	std	Z+12, r24	; 0x0c
     19c:	95 87       	std	Z+13, r25	; 0x0d
     19e:	a6 87       	std	Z+14, r26	; 0x0e
     1a0:	b7 87       	std	Z+15, r27	; 0x0f
     1a2:	08 95       	ret

000001a4 <_ZN10DFRobot_PHD1Ev>:
     1a4:	08 95       	ret

000001a6 <_ZN10DFRobot_PH5beginEv>:
     1a6:	cf 92       	push	r12
     1a8:	df 92       	push	r13
     1aa:	ef 92       	push	r14
     1ac:	ff 92       	push	r15
     1ae:	0f 93       	push	r16
     1b0:	1f 93       	push	r17
     1b2:	cf 93       	push	r28
     1b4:	df 93       	push	r29
     1b6:	ec 01       	movw	r28, r24
     1b8:	7c 01       	movw	r14, r24
     1ba:	88 e0       	ldi	r24, 0x08	; 8
     1bc:	e8 0e       	add	r14, r24
     1be:	f1 1c       	adc	r15, r1
     1c0:	67 01       	movw	r12, r14
     1c2:	00 e0       	ldi	r16, 0x00	; 0
     1c4:	10 e0       	ldi	r17, 0x00	; 0
     1c6:	c8 01       	movw	r24, r16
     1c8:	0e 94 aa 00 	call	0x154	; 0x154 <_ZN11EEPROMClass4readEi.isra.0>
     1cc:	f6 01       	movw	r30, r12
     1ce:	81 93       	st	Z+, r24
     1d0:	6f 01       	movw	r12, r30
     1d2:	0f 5f       	subi	r16, 0xFF	; 255
     1d4:	1f 4f       	sbci	r17, 0xFF	; 255
     1d6:	04 30       	cpi	r16, 0x04	; 4
     1d8:	11 05       	cpc	r17, r1
     1da:	a9 f7       	brne	.-22     	; 0x1c6 <_ZN10DFRobot_PH5beginEv+0x20>
     1dc:	66 e2       	ldi	r22, 0x26	; 38
     1de:	71 e0       	ldi	r23, 0x01	; 1
     1e0:	81 e7       	ldi	r24, 0x71	; 113
     1e2:	94 e0       	ldi	r25, 0x04	; 4
     1e4:	0e 94 28 0f 	call	0x1e50	; 0x1e50 <_ZN5Print5printEPKc>
     1e8:	48 85       	ldd	r20, Y+8	; 0x08
     1ea:	59 85       	ldd	r21, Y+9	; 0x09
     1ec:	6a 85       	ldd	r22, Y+10	; 0x0a
     1ee:	7b 85       	ldd	r23, Y+11	; 0x0b
     1f0:	22 e0       	ldi	r18, 0x02	; 2
     1f2:	30 e0       	ldi	r19, 0x00	; 0
     1f4:	81 e7       	ldi	r24, 0x71	; 113
     1f6:	94 e0       	ldi	r25, 0x04	; 4
     1f8:	0e 94 cf 10 	call	0x219e	; 0x219e <_ZN5Print7printlnEdi>
     1fc:	80 e0       	ldi	r24, 0x00	; 0
     1fe:	90 e0       	ldi	r25, 0x00	; 0
     200:	0e 94 aa 00 	call	0x154	; 0x154 <_ZN11EEPROMClass4readEi.isra.0>
     204:	8f 3f       	cpi	r24, 0xFF	; 255
     206:	39 f5       	brne	.+78     	; 0x256 <_ZN10DFRobot_PH5beginEv+0xb0>
     208:	81 e0       	ldi	r24, 0x01	; 1
     20a:	90 e0       	ldi	r25, 0x00	; 0
     20c:	0e 94 aa 00 	call	0x154	; 0x154 <_ZN11EEPROMClass4readEi.isra.0>
     210:	8f 3f       	cpi	r24, 0xFF	; 255
     212:	09 f5       	brne	.+66     	; 0x256 <_ZN10DFRobot_PH5beginEv+0xb0>
     214:	82 e0       	ldi	r24, 0x02	; 2
     216:	90 e0       	ldi	r25, 0x00	; 0
     218:	0e 94 aa 00 	call	0x154	; 0x154 <_ZN11EEPROMClass4readEi.isra.0>
     21c:	8f 3f       	cpi	r24, 0xFF	; 255
     21e:	d9 f4       	brne	.+54     	; 0x256 <_ZN10DFRobot_PH5beginEv+0xb0>
     220:	83 e0       	ldi	r24, 0x03	; 3
     222:	90 e0       	ldi	r25, 0x00	; 0
     224:	0e 94 aa 00 	call	0x154	; 0x154 <_ZN11EEPROMClass4readEi.isra.0>
     228:	8f 3f       	cpi	r24, 0xFF	; 255
     22a:	a9 f4       	brne	.+42     	; 0x256 <_ZN10DFRobot_PH5beginEv+0xb0>
     22c:	80 e0       	ldi	r24, 0x00	; 0
     22e:	90 e8       	ldi	r25, 0x80	; 128
     230:	ab eb       	ldi	r26, 0xBB	; 187
     232:	b4 e4       	ldi	r27, 0x44	; 68
     234:	88 87       	std	Y+8, r24	; 0x08
     236:	99 87       	std	Y+9, r25	; 0x09
     238:	aa 87       	std	Y+10, r26	; 0x0a
     23a:	bb 87       	std	Y+11, r27	; 0x0b
     23c:	00 e0       	ldi	r16, 0x00	; 0
     23e:	10 e0       	ldi	r17, 0x00	; 0
     240:	f7 01       	movw	r30, r14
     242:	61 91       	ld	r22, Z+
     244:	7f 01       	movw	r14, r30
     246:	c8 01       	movw	r24, r16
     248:	0e 94 42 21 	call	0x4284	; 0x4284 <eeprom_write_byte>
     24c:	0f 5f       	subi	r16, 0xFF	; 255
     24e:	1f 4f       	sbci	r17, 0xFF	; 255
     250:	04 30       	cpi	r16, 0x04	; 4
     252:	11 05       	cpc	r17, r1
     254:	a9 f7       	brne	.-22     	; 0x240 <_ZN10DFRobot_PH5beginEv+0x9a>
     256:	7e 01       	movw	r14, r28
     258:	f4 e0       	ldi	r31, 0x04	; 4
     25a:	ef 0e       	add	r14, r31
     25c:	f1 1c       	adc	r15, r1
     25e:	67 01       	movw	r12, r14
     260:	04 e0       	ldi	r16, 0x04	; 4
     262:	10 e0       	ldi	r17, 0x00	; 0
     264:	c8 01       	movw	r24, r16
     266:	0e 94 aa 00 	call	0x154	; 0x154 <_ZN11EEPROMClass4readEi.isra.0>
     26a:	f6 01       	movw	r30, r12
     26c:	81 93       	st	Z+, r24
     26e:	6f 01       	movw	r12, r30
     270:	0f 5f       	subi	r16, 0xFF	; 255
     272:	1f 4f       	sbci	r17, 0xFF	; 255
     274:	08 30       	cpi	r16, 0x08	; 8
     276:	11 05       	cpc	r17, r1
     278:	a9 f7       	brne	.-22     	; 0x264 <_ZN10DFRobot_PH5beginEv+0xbe>
     27a:	67 e3       	ldi	r22, 0x37	; 55
     27c:	71 e0       	ldi	r23, 0x01	; 1
     27e:	81 e7       	ldi	r24, 0x71	; 113
     280:	94 e0       	ldi	r25, 0x04	; 4
     282:	0e 94 28 0f 	call	0x1e50	; 0x1e50 <_ZN5Print5printEPKc>
     286:	4c 81       	ldd	r20, Y+4	; 0x04
     288:	5d 81       	ldd	r21, Y+5	; 0x05
     28a:	6e 81       	ldd	r22, Y+6	; 0x06
     28c:	7f 81       	ldd	r23, Y+7	; 0x07
     28e:	22 e0       	ldi	r18, 0x02	; 2
     290:	30 e0       	ldi	r19, 0x00	; 0
     292:	81 e7       	ldi	r24, 0x71	; 113
     294:	94 e0       	ldi	r25, 0x04	; 4
     296:	0e 94 cf 10 	call	0x219e	; 0x219e <_ZN5Print7printlnEdi>
     29a:	84 e0       	ldi	r24, 0x04	; 4
     29c:	90 e0       	ldi	r25, 0x00	; 0
     29e:	0e 94 aa 00 	call	0x154	; 0x154 <_ZN11EEPROMClass4readEi.isra.0>
     2a2:	8f 3f       	cpi	r24, 0xFF	; 255
     2a4:	31 f5       	brne	.+76     	; 0x2f2 <_ZN10DFRobot_PH5beginEv+0x14c>
     2a6:	85 e0       	ldi	r24, 0x05	; 5
     2a8:	90 e0       	ldi	r25, 0x00	; 0
     2aa:	0e 94 aa 00 	call	0x154	; 0x154 <_ZN11EEPROMClass4readEi.isra.0>
     2ae:	8f 3f       	cpi	r24, 0xFF	; 255
     2b0:	01 f5       	brne	.+64     	; 0x2f2 <_ZN10DFRobot_PH5beginEv+0x14c>
     2b2:	86 e0       	ldi	r24, 0x06	; 6
     2b4:	90 e0       	ldi	r25, 0x00	; 0
     2b6:	0e 94 aa 00 	call	0x154	; 0x154 <_ZN11EEPROMClass4readEi.isra.0>
     2ba:	8f 3f       	cpi	r24, 0xFF	; 255
     2bc:	d1 f4       	brne	.+52     	; 0x2f2 <_ZN10DFRobot_PH5beginEv+0x14c>
     2be:	87 e0       	ldi	r24, 0x07	; 7
     2c0:	90 e0       	ldi	r25, 0x00	; 0
     2c2:	0e 94 aa 00 	call	0x154	; 0x154 <_ZN11EEPROMClass4readEi.isra.0>
     2c6:	8f 3f       	cpi	r24, 0xFF	; 255
     2c8:	a1 f4       	brne	.+40     	; 0x2f2 <_ZN10DFRobot_PH5beginEv+0x14c>
     2ca:	84 e1       	ldi	r24, 0x14	; 20
     2cc:	9e e0       	ldi	r25, 0x0E	; 14
     2ce:	ae ef       	ldi	r26, 0xFE	; 254
     2d0:	b4 e4       	ldi	r27, 0x44	; 68
     2d2:	8c 83       	std	Y+4, r24	; 0x04
     2d4:	9d 83       	std	Y+5, r25	; 0x05
     2d6:	ae 83       	std	Y+6, r26	; 0x06
     2d8:	bf 83       	std	Y+7, r27	; 0x07
     2da:	c4 e0       	ldi	r28, 0x04	; 4
     2dc:	d0 e0       	ldi	r29, 0x00	; 0
     2de:	f7 01       	movw	r30, r14
     2e0:	61 91       	ld	r22, Z+
     2e2:	7f 01       	movw	r14, r30
     2e4:	ce 01       	movw	r24, r28
     2e6:	0e 94 42 21 	call	0x4284	; 0x4284 <eeprom_write_byte>
     2ea:	21 96       	adiw	r28, 0x01	; 1
     2ec:	c8 30       	cpi	r28, 0x08	; 8
     2ee:	d1 05       	cpc	r29, r1
     2f0:	b1 f7       	brne	.-20     	; 0x2de <_ZN10DFRobot_PH5beginEv+0x138>
     2f2:	df 91       	pop	r29
     2f4:	cf 91       	pop	r28
     2f6:	1f 91       	pop	r17
     2f8:	0f 91       	pop	r16
     2fa:	ff 90       	pop	r15
     2fc:	ef 90       	pop	r14
     2fe:	df 90       	pop	r13
     300:	cf 90       	pop	r12
     302:	08 95       	ret

00000304 <_ZN5Print5writeEPKc>:
void TaskColorSensor(void *pvParameters)
{
	(void) pvParameters;
  
	TickType_t xLastWakeTime = xTaskGetTickCount();
	for (;;) // A Task shall never return or exit.
     304:	61 15       	cp	r22, r1
     306:	71 05       	cpc	r23, r1
     308:	79 f0       	breq	.+30     	; 0x328 <_ZN5Print5writeEPKc+0x24>
     30a:	fb 01       	movw	r30, r22
     30c:	01 90       	ld	r0, Z+
     30e:	00 20       	and	r0, r0
     310:	e9 f7       	brne	.-6      	; 0x30c <_ZN5Print5writeEPKc+0x8>
     312:	31 97       	sbiw	r30, 0x01	; 1
     314:	af 01       	movw	r20, r30
     316:	46 1b       	sub	r20, r22
     318:	57 0b       	sbc	r21, r23
     31a:	dc 01       	movw	r26, r24
     31c:	ed 91       	ld	r30, X+
     31e:	fc 91       	ld	r31, X
     320:	02 80       	ldd	r0, Z+2	; 0x02
     322:	f3 81       	ldd	r31, Z+3	; 0x03
     324:	e0 2d       	mov	r30, r0
     326:	09 94       	ijmp
     328:	80 e0       	ldi	r24, 0x00	; 0
     32a:	90 e0       	ldi	r25, 0x00	; 0
     32c:	08 95       	ret

0000032e <_Z11measureTempv>:
     32e:	cf 92       	push	r12
     330:	df 92       	push	r13
     332:	ff 92       	push	r15
     334:	0f 93       	push	r16
     336:	1f 93       	push	r17
     338:	cf 93       	push	r28
     33a:	df 93       	push	r29
     33c:	cd b7       	in	r28, 0x3d	; 61
     33e:	de b7       	in	r29, 0x3e	; 62
     340:	64 97       	sbiw	r28, 0x14	; 20
     342:	0f b6       	in	r0, 0x3f	; 63
     344:	f8 94       	cli
     346:	de bf       	out	0x3e, r29	; 62
     348:	0f be       	out	0x3f, r0	; 63
     34a:	cd bf       	out	0x3d, r28	; 61
     34c:	80 e0       	ldi	r24, 0x00	; 0
     34e:	94 e0       	ldi	r25, 0x04	; 4
     350:	0e 94 ca 06 	call	0xd94	; 0xd94 <_ZN7OneWire12reset_searchEv>
     354:	6a ef       	ldi	r22, 0xFA	; 250
     356:	70 e0       	ldi	r23, 0x00	; 0
     358:	80 e0       	ldi	r24, 0x00	; 0
     35a:	90 e0       	ldi	r25, 0x00	; 0
     35c:	0e 94 bf 11 	call	0x237e	; 0x237e <delay>
     360:	41 e0       	ldi	r20, 0x01	; 1
     362:	be 01       	movw	r22, r28
     364:	63 5f       	subi	r22, 0xF3	; 243
     366:	7f 4f       	sbci	r23, 0xFF	; 255
     368:	80 e0       	ldi	r24, 0x00	; 0
     36a:	94 e0       	ldi	r25, 0x04	; 4
     36c:	0e 94 f9 06 	call	0xdf2	; 0xdf2 <_ZN7OneWire6searchEPhb>
     370:	67 e0       	ldi	r22, 0x07	; 7
     372:	ce 01       	movw	r24, r28
     374:	0d 96       	adiw	r24, 0x0d	; 13
     376:	0e 94 80 07 	call	0xf00	; 0xf00 <_ZN7OneWire4crc8EPKhh>
     37a:	9c 89       	ldd	r25, Y+20	; 0x14
     37c:	89 17       	cp	r24, r25
     37e:	19 f0       	breq	.+6      	; 0x386 <_Z11measureTempv+0x58>
     380:	6a e5       	ldi	r22, 0x5A	; 90
     382:	71 e0       	ldi	r23, 0x01	; 1
     384:	09 c0       	rjmp	.+18     	; 0x398 <_Z11measureTempv+0x6a>
     386:	8d 85       	ldd	r24, Y+13	; 0x0d
     388:	82 32       	cpi	r24, 0x22	; 34
     38a:	91 f0       	breq	.+36     	; 0x3b0 <_Z11measureTempv+0x82>
     38c:	88 32       	cpi	r24, 0x28	; 40
     38e:	81 f0       	breq	.+32     	; 0x3b0 <_Z11measureTempv+0x82>
     390:	80 31       	cpi	r24, 0x10	; 16
     392:	59 f0       	breq	.+22     	; 0x3aa <_Z11measureTempv+0x7c>
     394:	6c e6       	ldi	r22, 0x6C	; 108
     396:	71 e0       	ldi	r23, 0x01	; 1
     398:	81 e7       	ldi	r24, 0x71	; 113
     39a:	94 e0       	ldi	r25, 0x04	; 4
     39c:	0e 94 35 0f 	call	0x1e6a	; 0x1e6a <_ZN5Print7printlnEPKc>
     3a0:	60 e0       	ldi	r22, 0x00	; 0
     3a2:	70 e0       	ldi	r23, 0x00	; 0
     3a4:	80 e8       	ldi	r24, 0x80	; 128
     3a6:	9f eb       	ldi	r25, 0xBF	; 191
     3a8:	6a c0       	rjmp	.+212    	; 0x47e <__LOCK_REGION_LENGTH__+0x7e>
     3aa:	ff 24       	eor	r15, r15
     3ac:	f3 94       	inc	r15
     3ae:	01 c0       	rjmp	.+2      	; 0x3b2 <_Z11measureTempv+0x84>
     3b0:	f1 2c       	mov	r15, r1
     3b2:	80 e0       	ldi	r24, 0x00	; 0
     3b4:	94 e0       	ldi	r25, 0x04	; 4
     3b6:	0e 94 be 05 	call	0xb7c	; 0xb7c <_ZN7OneWire5resetEv>
     3ba:	be 01       	movw	r22, r28
     3bc:	63 5f       	subi	r22, 0xF3	; 243
     3be:	7f 4f       	sbci	r23, 0xFF	; 255
     3c0:	80 e0       	ldi	r24, 0x00	; 0
     3c2:	94 e0       	ldi	r25, 0x04	; 4
     3c4:	0e 94 ab 06 	call	0xd56	; 0xd56 <_ZN7OneWire6selectEPKh>
     3c8:	41 e0       	ldi	r20, 0x01	; 1
     3ca:	64 e4       	ldi	r22, 0x44	; 68
     3cc:	80 e0       	ldi	r24, 0x00	; 0
     3ce:	94 e0       	ldi	r25, 0x04	; 4
     3d0:	0e 94 5b 06 	call	0xcb6	; 0xcb6 <_ZN7OneWire5writeEhh>
     3d4:	68 ee       	ldi	r22, 0xE8	; 232
     3d6:	73 e0       	ldi	r23, 0x03	; 3
     3d8:	80 e0       	ldi	r24, 0x00	; 0
     3da:	90 e0       	ldi	r25, 0x00	; 0
     3dc:	0e 94 bf 11 	call	0x237e	; 0x237e <delay>
     3e0:	80 e0       	ldi	r24, 0x00	; 0
     3e2:	94 e0       	ldi	r25, 0x04	; 4
     3e4:	0e 94 be 05 	call	0xb7c	; 0xb7c <_ZN7OneWire5resetEv>
     3e8:	be 01       	movw	r22, r28
     3ea:	63 5f       	subi	r22, 0xF3	; 243
     3ec:	7f 4f       	sbci	r23, 0xFF	; 255
     3ee:	80 e0       	ldi	r24, 0x00	; 0
     3f0:	94 e0       	ldi	r25, 0x04	; 4
     3f2:	0e 94 ab 06 	call	0xd56	; 0xd56 <_ZN7OneWire6selectEPKh>
     3f6:	40 e0       	ldi	r20, 0x00	; 0
     3f8:	6e eb       	ldi	r22, 0xBE	; 190
     3fa:	80 e0       	ldi	r24, 0x00	; 0
     3fc:	94 e0       	ldi	r25, 0x04	; 4
     3fe:	0e 94 5b 06 	call	0xcb6	; 0xcb6 <_ZN7OneWire5writeEhh>
     402:	8e 01       	movw	r16, r28
     404:	0f 5f       	subi	r16, 0xFF	; 255
     406:	1f 4f       	sbci	r17, 0xFF	; 255
     408:	6e 01       	movw	r12, r28
     40a:	8a e0       	ldi	r24, 0x0A	; 10
     40c:	c8 0e       	add	r12, r24
     40e:	d1 1c       	adc	r13, r1
     410:	80 e0       	ldi	r24, 0x00	; 0
     412:	94 e0       	ldi	r25, 0x04	; 4
     414:	0e 94 8f 06 	call	0xd1e	; 0xd1e <_ZN7OneWire4readEv>
     418:	f8 01       	movw	r30, r16
     41a:	81 93       	st	Z+, r24
     41c:	8f 01       	movw	r16, r30
     41e:	ec 15       	cp	r30, r12
     420:	fd 05       	cpc	r31, r13
     422:	b1 f7       	brne	.-20     	; 0x410 <__LOCK_REGION_LENGTH__+0x10>
     424:	69 81       	ldd	r22, Y+1	; 0x01
     426:	7a 81       	ldd	r23, Y+2	; 0x02
     428:	ff 20       	and	r15, r15
     42a:	89 f0       	breq	.+34     	; 0x44e <__LOCK_REGION_LENGTH__+0x4e>
     42c:	83 e0       	ldi	r24, 0x03	; 3
     42e:	66 0f       	add	r22, r22
     430:	77 1f       	adc	r23, r23
     432:	8a 95       	dec	r24
     434:	e1 f7       	brne	.-8      	; 0x42e <__LOCK_REGION_LENGTH__+0x2e>
     436:	88 85       	ldd	r24, Y+8	; 0x08
     438:	80 31       	cpi	r24, 0x10	; 16
     43a:	a9 f4       	brne	.+42     	; 0x466 <__LOCK_REGION_LENGTH__+0x66>
     43c:	2f 81       	ldd	r18, Y+7	; 0x07
     43e:	8c e0       	ldi	r24, 0x0C	; 12
     440:	90 e0       	ldi	r25, 0x00	; 0
     442:	82 1b       	sub	r24, r18
     444:	91 09       	sbc	r25, r1
     446:	60 7f       	andi	r22, 0xF0	; 240
     448:	68 0f       	add	r22, r24
     44a:	79 1f       	adc	r23, r25
     44c:	0c c0       	rjmp	.+24     	; 0x466 <__LOCK_REGION_LENGTH__+0x66>
     44e:	8d 81       	ldd	r24, Y+5	; 0x05
     450:	80 76       	andi	r24, 0x60	; 96
     452:	11 f4       	brne	.+4      	; 0x458 <__LOCK_REGION_LENGTH__+0x58>
     454:	68 7f       	andi	r22, 0xF8	; 248
     456:	07 c0       	rjmp	.+14     	; 0x466 <__LOCK_REGION_LENGTH__+0x66>
     458:	80 32       	cpi	r24, 0x20	; 32
     45a:	11 f4       	brne	.+4      	; 0x460 <__LOCK_REGION_LENGTH__+0x60>
     45c:	6c 7f       	andi	r22, 0xFC	; 252
     45e:	03 c0       	rjmp	.+6      	; 0x466 <__LOCK_REGION_LENGTH__+0x66>
     460:	80 34       	cpi	r24, 0x40	; 64
     462:	09 f4       	brne	.+2      	; 0x466 <__LOCK_REGION_LENGTH__+0x66>
     464:	6e 7f       	andi	r22, 0xFE	; 254
     466:	07 2e       	mov	r0, r23
     468:	00 0c       	add	r0, r0
     46a:	88 0b       	sbc	r24, r24
     46c:	99 0b       	sbc	r25, r25
     46e:	0e 94 62 0c 	call	0x18c4	; 0x18c4 <__floatsisf>
     472:	20 e0       	ldi	r18, 0x00	; 0
     474:	30 e0       	ldi	r19, 0x00	; 0
     476:	40 e8       	ldi	r20, 0x80	; 128
     478:	5d e3       	ldi	r21, 0x3D	; 61
     47a:	0e 94 17 0d 	call	0x1a2e	; 0x1a2e <__mulsf3>
     47e:	64 96       	adiw	r28, 0x14	; 20
     480:	0f b6       	in	r0, 0x3f	; 63
     482:	f8 94       	cli
     484:	de bf       	out	0x3e, r29	; 62
     486:	0f be       	out	0x3f, r0	; 63
     488:	cd bf       	out	0x3d, r28	; 61
     48a:	df 91       	pop	r29
     48c:	cf 91       	pop	r28
     48e:	1f 91       	pop	r17
     490:	0f 91       	pop	r16
     492:	ff 90       	pop	r15
     494:	df 90       	pop	r13
     496:	cf 90       	pop	r12
     498:	08 95       	ret

0000049a <_Z9addColorsv>:
     49a:	0f 93       	push	r16
     49c:	1f 93       	push	r17
     49e:	cf 93       	push	r28
     4a0:	df 93       	push	r29
     4a2:	ce ec       	ldi	r28, 0xCE	; 206
     4a4:	d3 e0       	ldi	r29, 0x03	; 3
     4a6:	18 82       	st	Y, r1
     4a8:	19 82       	std	Y+1, r1	; 0x01
     4aa:	1a 82       	std	Y+2, r1	; 0x02
     4ac:	1b 82       	std	Y+3, r1	; 0x03
     4ae:	87 e3       	ldi	r24, 0x37	; 55
     4b0:	90 e0       	ldi	r25, 0x00	; 0
     4b2:	9d 83       	std	Y+5, r25	; 0x05
     4b4:	8c 83       	std	Y+4, r24	; 0x04
     4b6:	9f 83       	std	Y+7, r25	; 0x07
     4b8:	8e 83       	std	Y+6, r24	; 0x06
     4ba:	80 e5       	ldi	r24, 0x50	; 80
     4bc:	90 e0       	ldi	r25, 0x00	; 0
     4be:	99 87       	std	Y+9, r25	; 0x09
     4c0:	88 87       	std	Y+8, r24	; 0x08
     4c2:	a8 e8       	ldi	r26, 0x88	; 136
     4c4:	b3 e0       	ldi	r27, 0x03	; 3
     4c6:	1d 92       	st	X+, r1
     4c8:	1d 92       	st	X+, r1
     4ca:	1d 92       	st	X+, r1
     4cc:	1c 92       	st	X, r1
     4ce:	13 97       	sbiw	r26, 0x03	; 3
     4d0:	81 e4       	ldi	r24, 0x41	; 65
     4d2:	90 e0       	ldi	r25, 0x00	; 0
     4d4:	15 96       	adiw	r26, 0x05	; 5
     4d6:	9c 93       	st	X, r25
     4d8:	8e 93       	st	-X, r24
     4da:	14 97       	sbiw	r26, 0x04	; 4
     4dc:	17 96       	adiw	r26, 0x07	; 7
     4de:	9c 93       	st	X, r25
     4e0:	8e 93       	st	-X, r24
     4e2:	16 97       	sbiw	r26, 0x06	; 6
     4e4:	8e e6       	ldi	r24, 0x6E	; 110
     4e6:	90 e0       	ldi	r25, 0x00	; 0
     4e8:	19 96       	adiw	r26, 0x09	; 9
     4ea:	9c 93       	st	X, r25
     4ec:	8e 93       	st	-X, r24
     4ee:	18 97       	sbiw	r26, 0x08	; 8
     4f0:	e2 e4       	ldi	r30, 0x42	; 66
     4f2:	f3 e0       	ldi	r31, 0x03	; 3
     4f4:	10 82       	st	Z, r1
     4f6:	11 82       	std	Z+1, r1	; 0x01
     4f8:	12 82       	std	Z+2, r1	; 0x02
     4fa:	13 82       	std	Z+3, r1	; 0x03
     4fc:	81 e3       	ldi	r24, 0x31	; 49
     4fe:	90 e0       	ldi	r25, 0x00	; 0
     500:	95 83       	std	Z+5, r25	; 0x05
     502:	84 83       	std	Z+4, r24	; 0x04
     504:	82 e3       	ldi	r24, 0x32	; 50
     506:	90 e0       	ldi	r25, 0x00	; 0
     508:	97 83       	std	Z+7, r25	; 0x07
     50a:	86 83       	std	Z+6, r24	; 0x06
     50c:	8a e5       	ldi	r24, 0x5A	; 90
     50e:	90 e0       	ldi	r25, 0x00	; 0
     510:	91 87       	std	Z+9, r25	; 0x09
     512:	80 87       	std	Z+8, r24	; 0x08
     514:	40 e0       	ldi	r20, 0x00	; 0
     516:	50 e0       	ldi	r21, 0x00	; 0
     518:	60 e0       	ldi	r22, 0x00	; 0
     51a:	7f e3       	ldi	r23, 0x3F	; 63
     51c:	4a 87       	std	Y+10, r20	; 0x0a
     51e:	5b 87       	std	Y+11, r21	; 0x0b
     520:	6c 87       	std	Y+12, r22	; 0x0c
     522:	7d 87       	std	Y+13, r23	; 0x0d
     524:	1f 86       	std	Y+15, r1	; 0x0f
     526:	1e 86       	std	Y+14, r1	; 0x0e
     528:	19 8a       	std	Y+17, r1	; 0x11
     52a:	18 8a       	std	Y+16, r1	; 0x10
     52c:	1b 8a       	std	Y+19, r1	; 0x13
     52e:	1a 8a       	std	Y+18, r1	; 0x12
     530:	0a e9       	ldi	r16, 0x9A	; 154
     532:	19 e9       	ldi	r17, 0x99	; 153
     534:	29 e1       	ldi	r18, 0x19	; 25
     536:	3e e3       	ldi	r19, 0x3E	; 62
     538:	1a 96       	adiw	r26, 0x0a	; 10
     53a:	0d 93       	st	X+, r16
     53c:	1d 93       	st	X+, r17
     53e:	2d 93       	st	X+, r18
     540:	3c 93       	st	X, r19
     542:	1d 97       	sbiw	r26, 0x0d	; 13
     544:	1f 96       	adiw	r26, 0x0f	; 15
     546:	1c 92       	st	X, r1
     548:	1e 92       	st	-X, r1
     54a:	1e 97       	sbiw	r26, 0x0e	; 14
     54c:	51 96       	adiw	r26, 0x11	; 17
     54e:	1c 92       	st	X, r1
     550:	1e 92       	st	-X, r1
     552:	50 97       	sbiw	r26, 0x10	; 16
     554:	53 96       	adiw	r26, 0x13	; 19
     556:	1c 92       	st	X, r1
     558:	1e 92       	st	-X, r1
     55a:	52 97       	sbiw	r26, 0x12	; 18
     55c:	42 87       	std	Z+10, r20	; 0x0a
     55e:	53 87       	std	Z+11, r21	; 0x0b
     560:	64 87       	std	Z+12, r22	; 0x0c
     562:	75 87       	std	Z+13, r23	; 0x0d
     564:	17 86       	std	Z+15, r1	; 0x0f
     566:	16 86       	std	Z+14, r1	; 0x0e
     568:	11 8a       	std	Z+17, r1	; 0x11
     56a:	10 8a       	std	Z+16, r1	; 0x10
     56c:	13 8a       	std	Z+19, r1	; 0x13
     56e:	12 8a       	std	Z+18, r1	; 0x12
     570:	40 e0       	ldi	r20, 0x00	; 0
     572:	50 e0       	ldi	r21, 0x00	; 0
     574:	60 e8       	ldi	r22, 0x80	; 128
     576:	7f e3       	ldi	r23, 0x3F	; 63
     578:	4c 8b       	std	Y+20, r20	; 0x14
     57a:	5d 8b       	std	Y+21, r21	; 0x15
     57c:	6e 8b       	std	Y+22, r22	; 0x16
     57e:	7f 8b       	std	Y+23, r23	; 0x17
     580:	89 e3       	ldi	r24, 0x39	; 57
     582:	90 e0       	ldi	r25, 0x00	; 0
     584:	99 8f       	std	Y+25, r25	; 0x19
     586:	88 8f       	std	Y+24, r24	; 0x18
     588:	8a e3       	ldi	r24, 0x3A	; 58
     58a:	90 e0       	ldi	r25, 0x00	; 0
     58c:	9b 8f       	std	Y+27, r25	; 0x1b
     58e:	8a 8f       	std	Y+26, r24	; 0x1a
     590:	85 e5       	ldi	r24, 0x55	; 85
     592:	90 e0       	ldi	r25, 0x00	; 0
     594:	9d 8f       	std	Y+29, r25	; 0x1d
     596:	8c 8f       	std	Y+28, r24	; 0x1c
     598:	0a e9       	ldi	r16, 0x9A	; 154
     59a:	19 e9       	ldi	r17, 0x99	; 153
     59c:	29 e9       	ldi	r18, 0x99	; 153
     59e:	3e e3       	ldi	r19, 0x3E	; 62
     5a0:	54 96       	adiw	r26, 0x14	; 20
     5a2:	0d 93       	st	X+, r16
     5a4:	1d 93       	st	X+, r17
     5a6:	2d 93       	st	X+, r18
     5a8:	3c 93       	st	X, r19
     5aa:	57 97       	sbiw	r26, 0x17	; 23
     5ac:	59 96       	adiw	r26, 0x19	; 25
     5ae:	1c 92       	st	X, r1
     5b0:	1e 92       	st	-X, r1
     5b2:	58 97       	sbiw	r26, 0x18	; 24
     5b4:	5b 96       	adiw	r26, 0x1b	; 27
     5b6:	1c 92       	st	X, r1
     5b8:	1e 92       	st	-X, r1
     5ba:	5a 97       	sbiw	r26, 0x1a	; 26
     5bc:	5d 96       	adiw	r26, 0x1d	; 29
     5be:	1c 92       	st	X, r1
     5c0:	1e 92       	st	-X, r1
     5c2:	5c 97       	sbiw	r26, 0x1c	; 28
     5c4:	00 e0       	ldi	r16, 0x00	; 0
     5c6:	10 e0       	ldi	r17, 0x00	; 0
     5c8:	20 e0       	ldi	r18, 0x00	; 0
     5ca:	30 e4       	ldi	r19, 0x40	; 64
     5cc:	04 8b       	std	Z+20, r16	; 0x14
     5ce:	15 8b       	std	Z+21, r17	; 0x15
     5d0:	26 8b       	std	Z+22, r18	; 0x16
     5d2:	37 8b       	std	Z+23, r19	; 0x17
     5d4:	11 8e       	std	Z+25, r1	; 0x19
     5d6:	10 8e       	std	Z+24, r1	; 0x18
     5d8:	13 8e       	std	Z+27, r1	; 0x1b
     5da:	12 8e       	std	Z+26, r1	; 0x1a
     5dc:	15 8e       	std	Z+29, r1	; 0x1d
     5de:	14 8e       	std	Z+28, r1	; 0x1c
     5e0:	00 e0       	ldi	r16, 0x00	; 0
     5e2:	10 e0       	ldi	r17, 0x00	; 0
     5e4:	20 e4       	ldi	r18, 0x40	; 64
     5e6:	30 e4       	ldi	r19, 0x40	; 64
     5e8:	0e 8f       	std	Y+30, r16	; 0x1e
     5ea:	1f 8f       	std	Y+31, r17	; 0x1f
     5ec:	28 a3       	std	Y+32, r18	; 0x20
     5ee:	39 a3       	std	Y+33, r19	; 0x21
     5f0:	1b a2       	std	Y+35, r1	; 0x23
     5f2:	1a a2       	std	Y+34, r1	; 0x22
     5f4:	1d a2       	std	Y+37, r1	; 0x25
     5f6:	1c a2       	std	Y+36, r1	; 0x24
     5f8:	1f a2       	std	Y+39, r1	; 0x27
     5fa:	1e a2       	std	Y+38, r1	; 0x26
     5fc:	5e 96       	adiw	r26, 0x1e	; 30
     5fe:	4d 93       	st	X+, r20
     600:	5d 93       	st	X+, r21
     602:	6d 93       	st	X+, r22
     604:	7c 93       	st	X, r23
     606:	91 97       	sbiw	r26, 0x21	; 33
     608:	93 96       	adiw	r26, 0x23	; 35
     60a:	1c 92       	st	X, r1
     60c:	1e 92       	st	-X, r1
     60e:	92 97       	sbiw	r26, 0x22	; 34
     610:	95 96       	adiw	r26, 0x25	; 37
     612:	1c 92       	st	X, r1
     614:	1e 92       	st	-X, r1
     616:	94 97       	sbiw	r26, 0x24	; 36
     618:	97 96       	adiw	r26, 0x27	; 39
     61a:	1c 92       	st	X, r1
     61c:	1e 92       	st	-X, r1
     61e:	96 97       	sbiw	r26, 0x26	; 38
     620:	40 e0       	ldi	r20, 0x00	; 0
     622:	50 e0       	ldi	r21, 0x00	; 0
     624:	60 ea       	ldi	r22, 0xA0	; 160
     626:	70 e4       	ldi	r23, 0x40	; 64
     628:	46 8f       	std	Z+30, r20	; 0x1e
     62a:	57 8f       	std	Z+31, r21	; 0x1f
     62c:	60 a3       	std	Z+32, r22	; 0x20
     62e:	71 a3       	std	Z+33, r23	; 0x21
     630:	13 a2       	std	Z+35, r1	; 0x23
     632:	12 a2       	std	Z+34, r1	; 0x22
     634:	15 a2       	std	Z+37, r1	; 0x25
     636:	14 a2       	std	Z+36, r1	; 0x24
     638:	17 a2       	std	Z+39, r1	; 0x27
     63a:	16 a2       	std	Z+38, r1	; 0x26
     63c:	40 e0       	ldi	r20, 0x00	; 0
     63e:	50 e0       	ldi	r21, 0x00	; 0
     640:	60 ec       	ldi	r22, 0xC0	; 192
     642:	70 e4       	ldi	r23, 0x40	; 64
     644:	48 a7       	std	Y+40, r20	; 0x28
     646:	59 a7       	std	Y+41, r21	; 0x29
     648:	6a a7       	std	Y+42, r22	; 0x2a
     64a:	7b a7       	std	Y+43, r23	; 0x2b
     64c:	1d a6       	std	Y+45, r1	; 0x2d
     64e:	1c a6       	std	Y+44, r1	; 0x2c
     650:	1f a6       	std	Y+47, r1	; 0x2f
     652:	1e a6       	std	Y+46, r1	; 0x2e
     654:	19 aa       	std	Y+49, r1	; 0x31
     656:	18 aa       	std	Y+48, r1	; 0x30
     658:	40 e0       	ldi	r20, 0x00	; 0
     65a:	50 e0       	ldi	r21, 0x00	; 0
     65c:	60 ec       	ldi	r22, 0xC0	; 192
     65e:	7f e3       	ldi	r23, 0x3F	; 63
     660:	98 96       	adiw	r26, 0x28	; 40
     662:	4d 93       	st	X+, r20
     664:	5d 93       	st	X+, r21
     666:	6d 93       	st	X+, r22
     668:	7c 93       	st	X, r23
     66a:	9b 97       	sbiw	r26, 0x2b	; 43
     66c:	9d 96       	adiw	r26, 0x2d	; 45
     66e:	1c 92       	st	X, r1
     670:	1e 92       	st	-X, r1
     672:	9c 97       	sbiw	r26, 0x2c	; 44
     674:	9f 96       	adiw	r26, 0x2f	; 47
     676:	1c 92       	st	X, r1
     678:	1e 92       	st	-X, r1
     67a:	9e 97       	sbiw	r26, 0x2e	; 46
     67c:	d1 96       	adiw	r26, 0x31	; 49
     67e:	1c 92       	st	X, r1
     680:	1e 92       	st	-X, r1
     682:	d0 97       	sbiw	r26, 0x30	; 48
     684:	40 e0       	ldi	r20, 0x00	; 0
     686:	50 e0       	ldi	r21, 0x00	; 0
     688:	60 e2       	ldi	r22, 0x20	; 32
     68a:	71 e4       	ldi	r23, 0x41	; 65
     68c:	40 a7       	std	Z+40, r20	; 0x28
     68e:	51 a7       	std	Z+41, r21	; 0x29
     690:	62 a7       	std	Z+42, r22	; 0x2a
     692:	73 a7       	std	Z+43, r23	; 0x2b
     694:	15 a6       	std	Z+45, r1	; 0x2d
     696:	14 a6       	std	Z+44, r1	; 0x2c
     698:	17 a6       	std	Z+47, r1	; 0x2f
     69a:	16 a6       	std	Z+46, r1	; 0x2e
     69c:	11 aa       	std	Z+49, r1	; 0x31
     69e:	10 aa       	std	Z+48, r1	; 0x30
     6a0:	d2 96       	adiw	r26, 0x32	; 50
     6a2:	0d 93       	st	X+, r16
     6a4:	1d 93       	st	X+, r17
     6a6:	2d 93       	st	X+, r18
     6a8:	3c 93       	st	X, r19
     6aa:	d5 97       	sbiw	r26, 0x35	; 53
     6ac:	d7 96       	adiw	r26, 0x37	; 55
     6ae:	1c 92       	st	X, r1
     6b0:	1e 92       	st	-X, r1
     6b2:	d6 97       	sbiw	r26, 0x36	; 54
     6b4:	d9 96       	adiw	r26, 0x39	; 57
     6b6:	1c 92       	st	X, r1
     6b8:	1e 92       	st	-X, r1
     6ba:	d8 97       	sbiw	r26, 0x38	; 56
     6bc:	db 96       	adiw	r26, 0x3b	; 59
     6be:	1c 92       	st	X, r1
     6c0:	1e 92       	st	-X, r1
     6c2:	da 97       	sbiw	r26, 0x3a	; 58
     6c4:	00 e0       	ldi	r16, 0x00	; 0
     6c6:	10 e0       	ldi	r17, 0x00	; 0
     6c8:	20 ea       	ldi	r18, 0xA0	; 160
     6ca:	31 e4       	ldi	r19, 0x41	; 65
     6cc:	02 ab       	std	Z+50, r16	; 0x32
     6ce:	13 ab       	std	Z+51, r17	; 0x33
     6d0:	24 ab       	std	Z+52, r18	; 0x34
     6d2:	35 ab       	std	Z+53, r19	; 0x35
     6d4:	17 aa       	std	Z+55, r1	; 0x37
     6d6:	16 aa       	std	Z+54, r1	; 0x36
     6d8:	11 ae       	std	Z+57, r1	; 0x39
     6da:	10 ae       	std	Z+56, r1	; 0x38
     6dc:	13 ae       	std	Z+59, r1	; 0x3b
     6de:	12 ae       	std	Z+58, r1	; 0x3a
     6e0:	dc 96       	adiw	r26, 0x3c	; 60
     6e2:	4d 93       	st	X+, r20
     6e4:	5d 93       	st	X+, r21
     6e6:	6d 93       	st	X+, r22
     6e8:	7c 93       	st	X, r23
     6ea:	df 97       	sbiw	r26, 0x3f	; 63
     6ec:	10 92 c9 03 	sts	0x03C9, r1	; 0x8003c9 <Nitrite+0x41>
     6f0:	10 92 c8 03 	sts	0x03C8, r1	; 0x8003c8 <Nitrite+0x40>
     6f4:	10 92 cb 03 	sts	0x03CB, r1	; 0x8003cb <Nitrite+0x43>
     6f8:	10 92 ca 03 	sts	0x03CA, r1	; 0x8003ca <Nitrite+0x42>
     6fc:	10 92 cd 03 	sts	0x03CD, r1	; 0x8003cd <Nitrite+0x45>
     700:	10 92 cc 03 	sts	0x03CC, r1	; 0x8003cc <Nitrite+0x44>
     704:	80 e0       	ldi	r24, 0x00	; 0
     706:	90 e0       	ldi	r25, 0x00	; 0
     708:	a8 e4       	ldi	r26, 0x48	; 72
     70a:	b2 e4       	ldi	r27, 0x42	; 66
     70c:	84 af       	std	Z+60, r24	; 0x3c
     70e:	95 af       	std	Z+61, r25	; 0x3d
     710:	a6 af       	std	Z+62, r26	; 0x3e
     712:	b7 af       	std	Z+63, r27	; 0x3f
     714:	10 92 83 03 	sts	0x0383, r1	; 0x800383 <Nitrate+0x41>
     718:	10 92 82 03 	sts	0x0382, r1	; 0x800382 <Nitrate+0x40>
     71c:	10 92 85 03 	sts	0x0385, r1	; 0x800385 <Nitrate+0x43>
     720:	10 92 84 03 	sts	0x0384, r1	; 0x800384 <Nitrate+0x42>
     724:	10 92 87 03 	sts	0x0387, r1	; 0x800387 <Nitrate+0x45>
     728:	10 92 86 03 	sts	0x0386, r1	; 0x800386 <Nitrate+0x44>
     72c:	df 91       	pop	r29
     72e:	cf 91       	pop	r28
     730:	1f 91       	pop	r17
     732:	0f 91       	pop	r16
     734:	08 95       	ret

00000736 <_Z6setLED8LEDColor>:
     736:	cf 93       	push	r28
     738:	df 93       	push	r29
     73a:	00 d0       	rcall	.+0      	; 0x73c <_Z6setLED8LEDColor+0x6>
     73c:	00 d0       	rcall	.+0      	; 0x73e <_Z6setLED8LEDColor+0x8>
     73e:	00 d0       	rcall	.+0      	; 0x740 <_Z6setLED8LEDColor+0xa>
     740:	cd b7       	in	r28, 0x3d	; 61
     742:	de b7       	in	r29, 0x3e	; 62
     744:	49 83       	std	Y+1, r20	; 0x01
     746:	5a 83       	std	Y+2, r21	; 0x02
     748:	6b 83       	std	Y+3, r22	; 0x03
     74a:	7c 83       	std	Y+4, r23	; 0x04
     74c:	8d 83       	std	Y+5, r24	; 0x05
     74e:	9e 83       	std	Y+6, r25	; 0x06
     750:	69 81       	ldd	r22, Y+1	; 0x01
     752:	7a 81       	ldd	r23, Y+2	; 0x02
     754:	8f e0       	ldi	r24, 0x0F	; 15
     756:	0e 94 5e 12 	call	0x24bc	; 0x24bc <analogWrite>
     75a:	6b 81       	ldd	r22, Y+3	; 0x03
     75c:	7c 81       	ldd	r23, Y+4	; 0x04
     75e:	80 e1       	ldi	r24, 0x10	; 16
     760:	0e 94 5e 12 	call	0x24bc	; 0x24bc <analogWrite>
     764:	6d 81       	ldd	r22, Y+5	; 0x05
     766:	7e 81       	ldd	r23, Y+6	; 0x06
     768:	81 e1       	ldi	r24, 0x11	; 17
     76a:	26 96       	adiw	r28, 0x06	; 6
     76c:	0f b6       	in	r0, 0x3f	; 63
     76e:	f8 94       	cli
     770:	de bf       	out	0x3e, r29	; 62
     772:	0f be       	out	0x3f, r0	; 63
     774:	cd bf       	out	0x3d, r28	; 61
     776:	df 91       	pop	r29
     778:	cf 91       	pop	r28
     77a:	0c 94 5e 12 	jmp	0x24bc	; 0x24bc <analogWrite>

0000077e <_Z20TaskPHandTemperaturePv>:
     77e:	cf 93       	push	r28
     780:	df 93       	push	r29
     782:	00 d0       	rcall	.+0      	; 0x784 <_Z20TaskPHandTemperaturePv+0x6>
     784:	cd b7       	in	r28, 0x3d	; 61
     786:	de b7       	in	r29, 0x3e	; 62
     788:	0e 94 32 18 	call	0x3064	; 0x3064 <xTaskGetTickCount>
     78c:	9a 83       	std	Y+2, r25	; 0x02
     78e:	89 83       	std	Y+1, r24	; 0x01
     790:	40 91 0d 01 	lds	r20, 0x010D	; 0x80010d <Green>
     794:	50 91 0e 01 	lds	r21, 0x010E	; 0x80010e <Green+0x1>
     798:	60 91 0f 01 	lds	r22, 0x010F	; 0x80010f <Green+0x2>
     79c:	70 91 10 01 	lds	r23, 0x0110	; 0x800110 <Green+0x3>
     7a0:	80 91 11 01 	lds	r24, 0x0111	; 0x800111 <Green+0x4>
     7a4:	90 91 12 01 	lds	r25, 0x0112	; 0x800112 <Green+0x5>
     7a8:	0e 94 9b 03 	call	0x736	; 0x736 <_Z6setLED8LEDColor>
     7ac:	60 ed       	ldi	r22, 0xD0	; 208
     7ae:	71 e0       	ldi	r23, 0x01	; 1
     7b0:	8b ed       	ldi	r24, 0xDB	; 219
     7b2:	92 e0       	ldi	r25, 0x02	; 2
     7b4:	0e 94 28 0f 	call	0x1e50	; 0x1e50 <_ZN5Print5printEPKc>
     7b8:	0e 94 9c 07 	call	0xf38	; 0xf38 <_Z6calcPHv>
     7bc:	20 e0       	ldi	r18, 0x00	; 0
     7be:	30 e0       	ldi	r19, 0x00	; 0
     7c0:	48 ec       	ldi	r20, 0xC8	; 200
     7c2:	52 e4       	ldi	r21, 0x42	; 66
     7c4:	0e 94 17 0d 	call	0x1a2e	; 0x1a2e <__mulsf3>
     7c8:	0e 94 2a 0c 	call	0x1854	; 0x1854 <__fixsfsi>
     7cc:	60 93 09 03 	sts	0x0309, r22	; 0x800309 <phValue>
     7d0:	70 93 0a 03 	sts	0x030A, r23	; 0x80030a <phValue+0x1>
     7d4:	80 93 0b 03 	sts	0x030B, r24	; 0x80030b <phValue+0x2>
     7d8:	90 93 0c 03 	sts	0x030C, r25	; 0x80030c <phValue+0x3>
     7dc:	63 ed       	ldi	r22, 0xD3	; 211
     7de:	71 e0       	ldi	r23, 0x01	; 1
     7e0:	8b ed       	ldi	r24, 0xDB	; 219
     7e2:	92 e0       	ldi	r25, 0x02	; 2
     7e4:	0e 94 28 0f 	call	0x1e50	; 0x1e50 <_ZN5Print5printEPKc>
     7e8:	40 91 09 03 	lds	r20, 0x0309	; 0x800309 <phValue>
     7ec:	50 91 0a 03 	lds	r21, 0x030A	; 0x80030a <phValue+0x1>
     7f0:	60 91 0b 03 	lds	r22, 0x030B	; 0x80030b <phValue+0x2>
     7f4:	70 91 0c 03 	lds	r23, 0x030C	; 0x80030c <phValue+0x3>
     7f8:	2a e0       	ldi	r18, 0x0A	; 10
     7fa:	30 e0       	ldi	r19, 0x00	; 0
     7fc:	8b ed       	ldi	r24, 0xDB	; 219
     7fe:	92 e0       	ldi	r25, 0x02	; 2
     800:	0e 94 a3 0f 	call	0x1f46	; 0x1f46 <_ZN5Print5printEli>
     804:	6a ef       	ldi	r22, 0xFA	; 250
     806:	70 e0       	ldi	r23, 0x00	; 0
     808:	80 e0       	ldi	r24, 0x00	; 0
     80a:	90 e0       	ldi	r25, 0x00	; 0
     80c:	0e 94 bf 11 	call	0x237e	; 0x237e <delay>
     810:	40 91 0d 03 	lds	r20, 0x030D	; 0x80030d <Off>
     814:	50 91 0e 03 	lds	r21, 0x030E	; 0x80030e <Off+0x1>
     818:	60 91 0f 03 	lds	r22, 0x030F	; 0x80030f <Off+0x2>
     81c:	70 91 10 03 	lds	r23, 0x0310	; 0x800310 <Off+0x3>
     820:	80 91 11 03 	lds	r24, 0x0311	; 0x800311 <Off+0x4>
     824:	90 91 12 03 	lds	r25, 0x0312	; 0x800312 <Off+0x5>
     828:	0e 94 9b 03 	call	0x736	; 0x736 <_Z6setLED8LEDColor>
     82c:	40 91 13 01 	lds	r20, 0x0113	; 0x800113 <Red>
     830:	50 91 14 01 	lds	r21, 0x0114	; 0x800114 <Red+0x1>
     834:	60 91 15 01 	lds	r22, 0x0115	; 0x800115 <Red+0x2>
     838:	70 91 16 01 	lds	r23, 0x0116	; 0x800116 <Red+0x3>
     83c:	80 91 17 01 	lds	r24, 0x0117	; 0x800117 <Red+0x4>
     840:	90 91 18 01 	lds	r25, 0x0118	; 0x800118 <Red+0x5>
     844:	0e 94 9b 03 	call	0x736	; 0x736 <_Z6setLED8LEDColor>
     848:	0e 94 97 01 	call	0x32e	; 0x32e <_Z11measureTempv>
     84c:	20 e0       	ldi	r18, 0x00	; 0
     84e:	30 e0       	ldi	r19, 0x00	; 0
     850:	48 ec       	ldi	r20, 0xC8	; 200
     852:	52 e4       	ldi	r21, 0x42	; 66
     854:	0e 94 17 0d 	call	0x1a2e	; 0x1a2e <__mulsf3>
     858:	0e 94 2a 0c 	call	0x1854	; 0x1854 <__fixsfsi>
     85c:	70 93 08 03 	sts	0x0308, r23	; 0x800308 <tempValue+0x1>
     860:	60 93 07 03 	sts	0x0307, r22	; 0x800307 <tempValue>
     864:	6e ed       	ldi	r22, 0xDE	; 222
     866:	71 e0       	ldi	r23, 0x01	; 1
     868:	8b ed       	ldi	r24, 0xDB	; 219
     86a:	92 e0       	ldi	r25, 0x02	; 2
     86c:	0e 94 82 01 	call	0x304	; 0x304 <_ZN5Print5writeEPKc>
     870:	60 91 07 03 	lds	r22, 0x0307	; 0x800307 <tempValue>
     874:	70 91 08 03 	lds	r23, 0x0308	; 0x800308 <tempValue+0x1>
     878:	4a e0       	ldi	r20, 0x0A	; 10
     87a:	50 e0       	ldi	r21, 0x00	; 0
     87c:	8b ed       	ldi	r24, 0xDB	; 219
     87e:	92 e0       	ldi	r25, 0x02	; 2
     880:	0e 94 eb 0f 	call	0x1fd6	; 0x1fd6 <_ZN5Print5printEii>
     884:	64 e6       	ldi	r22, 0x64	; 100
     886:	70 e0       	ldi	r23, 0x00	; 0
     888:	80 e0       	ldi	r24, 0x00	; 0
     88a:	90 e0       	ldi	r25, 0x00	; 0
     88c:	0e 94 bf 11 	call	0x237e	; 0x237e <delay>
     890:	40 91 0d 03 	lds	r20, 0x030D	; 0x80030d <Off>
     894:	50 91 0e 03 	lds	r21, 0x030E	; 0x80030e <Off+0x1>
     898:	60 91 0f 03 	lds	r22, 0x030F	; 0x80030f <Off+0x2>
     89c:	70 91 10 03 	lds	r23, 0x0310	; 0x800310 <Off+0x3>
     8a0:	80 91 11 03 	lds	r24, 0x0311	; 0x800311 <Off+0x4>
     8a4:	90 91 12 03 	lds	r25, 0x0312	; 0x800312 <Off+0x5>
     8a8:	0e 94 9b 03 	call	0x736	; 0x736 <_Z6setLED8LEDColor>
     8ac:	6e e3       	ldi	r22, 0x3E	; 62
     8ae:	70 e0       	ldi	r23, 0x00	; 0
     8b0:	ce 01       	movw	r24, r28
     8b2:	01 96       	adiw	r24, 0x01	; 1
     8b4:	0e 94 57 19 	call	0x32ae	; 0x32ae <vTaskDelayUntil>
     8b8:	6b cf       	rjmp	.-298    	; 0x790 <_Z20TaskPHandTemperaturePv+0x12>

000008ba <_Z8setupLEDv>:
     8ba:	61 e0       	ldi	r22, 0x01	; 1
     8bc:	8f e0       	ldi	r24, 0x0F	; 15
     8be:	0e 94 e6 12 	call	0x25cc	; 0x25cc <pinMode>
     8c2:	61 e0       	ldi	r22, 0x01	; 1
     8c4:	80 e1       	ldi	r24, 0x10	; 16
     8c6:	0e 94 e6 12 	call	0x25cc	; 0x25cc <pinMode>
     8ca:	61 e0       	ldi	r22, 0x01	; 1
     8cc:	81 e1       	ldi	r24, 0x11	; 17
     8ce:	0e 94 e6 12 	call	0x25cc	; 0x25cc <pinMode>
     8d2:	40 91 0d 03 	lds	r20, 0x030D	; 0x80030d <Off>
     8d6:	50 91 0e 03 	lds	r21, 0x030E	; 0x80030e <Off+0x1>
     8da:	60 91 0f 03 	lds	r22, 0x030F	; 0x80030f <Off+0x2>
     8de:	70 91 10 03 	lds	r23, 0x0310	; 0x800310 <Off+0x3>
     8e2:	80 91 11 03 	lds	r24, 0x0311	; 0x800311 <Off+0x4>
     8e6:	90 91 12 03 	lds	r25, 0x0312	; 0x800312 <Off+0x5>
     8ea:	0c 94 9b 03 	jmp	0x736	; 0x736 <_Z6setLED8LEDColor>

000008ee <setup>:
     8ee:	ef 92       	push	r14
     8f0:	ff 92       	push	r15
     8f2:	0f 93       	push	r16
     8f4:	40 e0       	ldi	r20, 0x00	; 0
     8f6:	52 ec       	ldi	r21, 0xC2	; 194
     8f8:	61 e0       	ldi	r22, 0x01	; 1
     8fa:	70 e0       	ldi	r23, 0x00	; 0
     8fc:	8b ed       	ldi	r24, 0xDB	; 219
     8fe:	92 e0       	ldi	r25, 0x02	; 2
     900:	0e 94 b8 0a 	call	0x1570	; 0x1570 <_ZN14SoftwareSerial5beginEl>
     904:	61 e0       	ldi	r22, 0x01	; 1
     906:	8a e0       	ldi	r24, 0x0A	; 10
     908:	0e 94 e6 12 	call	0x25cc	; 0x25cc <pinMode>
     90c:	61 e0       	ldi	r22, 0x01	; 1
     90e:	8a e0       	ldi	r24, 0x0A	; 10
     910:	0e 94 22 13 	call	0x2644	; 0x2644 <digitalWrite>
     914:	83 e1       	ldi	r24, 0x13	; 19
     916:	93 e0       	ldi	r25, 0x03	; 3
     918:	0e 94 ab 08 	call	0x1156	; 0x1156 <_ZN9MD_TCS2305beginEv>
     91c:	0e 94 4d 02 	call	0x49a	; 0x49a <_Z9addColorsv>
     920:	0e 94 5d 04 	call	0x8ba	; 0x8ba <_Z8setupLEDv>
     924:	61 ee       	ldi	r22, 0xE1	; 225
     926:	71 e0       	ldi	r23, 0x01	; 1
     928:	8b ed       	ldi	r24, 0xDB	; 219
     92a:	92 e0       	ldi	r25, 0x02	; 2
     92c:	0e 94 28 0f 	call	0x1e50	; 0x1e50 <_ZN5Print5printEPKc>
     930:	40 91 0d 01 	lds	r20, 0x010D	; 0x80010d <Green>
     934:	50 91 0e 01 	lds	r21, 0x010E	; 0x80010e <Green+0x1>
     938:	60 91 0f 01 	lds	r22, 0x010F	; 0x80010f <Green+0x2>
     93c:	70 91 10 01 	lds	r23, 0x0110	; 0x800110 <Green+0x3>
     940:	80 91 11 01 	lds	r24, 0x0111	; 0x800111 <Green+0x4>
     944:	90 91 12 01 	lds	r25, 0x0112	; 0x800112 <Green+0x5>
     948:	0e 94 9b 03 	call	0x736	; 0x736 <_Z6setLED8LEDColor>
     94c:	0e 94 98 07 	call	0xf30	; 0xf30 <_Z6phInitv>
     950:	43 e0       	ldi	r20, 0x03	; 3
     952:	50 e0       	ldi	r21, 0x00	; 0
     954:	6f e0       	ldi	r22, 0x0F	; 15
     956:	75 e0       	ldi	r23, 0x05	; 5
     958:	80 e0       	ldi	r24, 0x00	; 0
     95a:	0e 94 e2 10 	call	0x21c4	; 0x21c4 <attachInterrupt>
     95e:	80 91 fe 02 	lds	r24, 0x02FE	; 0x8002fe <xSerialSemaphoreColorSensor>
     962:	90 91 ff 02 	lds	r25, 0x02FF	; 0x8002ff <xSerialSemaphoreColorSensor+0x1>
     966:	89 2b       	or	r24, r25
     968:	91 f4       	brne	.+36     	; 0x98e <__stack+0x8f>
     96a:	43 e0       	ldi	r20, 0x03	; 3
     96c:	60 e0       	ldi	r22, 0x00	; 0
     96e:	81 e0       	ldi	r24, 0x01	; 1
     970:	0e 94 46 14 	call	0x288c	; 0x288c <xQueueGenericCreate>
     974:	90 93 ff 02 	sts	0x02FF, r25	; 0x8002ff <xSerialSemaphoreColorSensor+0x1>
     978:	80 93 fe 02 	sts	0x02FE, r24	; 0x8002fe <xSerialSemaphoreColorSensor>
     97c:	00 97       	sbiw	r24, 0x00	; 0
     97e:	39 f0       	breq	.+14     	; 0x98e <__stack+0x8f>
     980:	20 e0       	ldi	r18, 0x00	; 0
     982:	40 e0       	ldi	r20, 0x00	; 0
     984:	50 e0       	ldi	r21, 0x00	; 0
     986:	60 e0       	ldi	r22, 0x00	; 0
     988:	70 e0       	ldi	r23, 0x00	; 0
     98a:	0e 94 6e 14 	call	0x28dc	; 0x28dc <xQueueGenericSend>
     98e:	8a ef       	ldi	r24, 0xFA	; 250
     990:	e8 2e       	mov	r14, r24
     992:	82 e0       	ldi	r24, 0x02	; 2
     994:	f8 2e       	mov	r15, r24
     996:	02 e0       	ldi	r16, 0x02	; 2
     998:	20 e0       	ldi	r18, 0x00	; 0
     99a:	30 e0       	ldi	r19, 0x00	; 0
     99c:	40 e8       	ldi	r20, 0x80	; 128
     99e:	50 e0       	ldi	r21, 0x00	; 0
     9a0:	60 ef       	ldi	r22, 0xF0	; 240
     9a2:	71 e0       	ldi	r23, 0x01	; 1
     9a4:	8f eb       	ldi	r24, 0xBF	; 191
     9a6:	93 e0       	ldi	r25, 0x03	; 3
     9a8:	0e 94 a9 16 	call	0x2d52	; 0x2d52 <xTaskCreate>
     9ac:	68 ee       	ldi	r22, 0xE8	; 232
     9ae:	73 e0       	ldi	r23, 0x03	; 3
     9b0:	80 e0       	ldi	r24, 0x00	; 0
     9b2:	90 e0       	ldi	r25, 0x00	; 0
     9b4:	0e 94 bf 11 	call	0x237e	; 0x237e <delay>
     9b8:	40 91 0d 03 	lds	r20, 0x030D	; 0x80030d <Off>
     9bc:	50 91 0e 03 	lds	r21, 0x030E	; 0x80030e <Off+0x1>
     9c0:	60 91 0f 03 	lds	r22, 0x030F	; 0x80030f <Off+0x2>
     9c4:	70 91 10 03 	lds	r23, 0x0310	; 0x800310 <Off+0x3>
     9c8:	80 91 11 03 	lds	r24, 0x0311	; 0x800311 <Off+0x4>
     9cc:	90 91 12 03 	lds	r25, 0x0312	; 0x800312 <Off+0x5>
     9d0:	0e 94 9b 03 	call	0x736	; 0x736 <_Z6setLED8LEDColor>
     9d4:	61 e0       	ldi	r22, 0x01	; 1
     9d6:	72 e0       	ldi	r23, 0x02	; 2
     9d8:	8b ed       	ldi	r24, 0xDB	; 219
     9da:	92 e0       	ldi	r25, 0x02	; 2
     9dc:	0f 91       	pop	r16
     9de:	ff 90       	pop	r15
     9e0:	ef 90       	pop	r14
     9e2:	0c 94 28 0f 	jmp	0x1e50	; 0x1e50 <_ZN5Print5printEPKc>

000009e6 <loop>:
     9e6:	08 95       	ret

000009e8 <_GLOBAL__sub_I_ds>:
    bool LastDeviceFlag;
#endif

  public:
    OneWire() { }
    OneWire(uint8_t pin) { begin(pin); }
     9e8:	66 e0       	ldi	r22, 0x06	; 6
     9ea:	80 e0       	ldi	r24, 0x00	; 0
     9ec:	94 e0       	ldi	r25, 0x04	; 4
     9ee:	0e 94 d6 06 	call	0xdac	; 0xdac <_ZN7OneWire5beginEh>

uint8_t greenScanned;
uint8_t redScanned;
uint8_t blueScanned;

MD_TCS230  CS(S2, S3, OE);
     9f2:	28 e0       	ldi	r18, 0x08	; 8
     9f4:	4d e0       	ldi	r20, 0x0D	; 13
     9f6:	6c e0       	ldi	r22, 0x0C	; 12
     9f8:	83 e1       	ldi	r24, 0x13	; 19
     9fa:	93 e0       	ldi	r25, 0x03	; 3
     9fc:	0e 94 5f 08 	call	0x10be	; 0x10be <_ZN9MD_TCS230C1Ehhh>
SemaphoreHandle_t xSerialSemaphoreColorSensor;

TaskHandle_t xColorSensor;
TaskHandle_t xPHandTemperature;

SoftwareSerial serial(rxPin, txPin);
     a00:	20 e0       	ldi	r18, 0x00	; 0
     a02:	43 e0       	ldi	r20, 0x03	; 3
     a04:	62 e0       	ldi	r22, 0x02	; 2
     a06:	8b ed       	ldi	r24, 0xDB	; 219
     a08:	92 e0       	ldi	r25, 0x02	; 2
     a0a:	0c 94 8d 0a 	jmp	0x151a	; 0x151a <_ZN14SoftwareSerialC1Ehhb>

00000a0e <_GLOBAL__sub_D_ds>:
     a0e:	8b ed       	ldi	r24, 0xDB	; 219
     a10:	92 e0       	ldi	r25, 0x02	; 2
     a12:	0e 94 34 0a 	call	0x1468	; 0x1468 <_ZN14SoftwareSerialD1Ev>
     a16:	83 e1       	ldi	r24, 0x13	; 19
     a18:	93 e0       	ldi	r25, 0x03	; 3
     a1a:	0c 94 73 08 	jmp	0x10e6	; 0x10e6 <_ZN9MD_TCS230D1Ev>

00000a1e <_Z8fromWifiv>:
  }
}


void fromWifi()
{
     a1e:	cf 93       	push	r28
	int i = 0;
	char action = '\0';
	// check for data from Wifi
	if (serial.available())
     a20:	8b ed       	ldi	r24, 0xDB	; 219
     a22:	92 e0       	ldi	r25, 0x02	; 2
     a24:	0e 94 63 09 	call	0x12c6	; 0x12c6 <_ZN14SoftwareSerial9availableEv>
     a28:	89 2b       	or	r24, r25
     a2a:	99 f0       	breq	.+38     	; 0xa52 <_Z8fromWifiv+0x34>
	{
		delay(100); // allows all serial sent to be received together
     a2c:	64 e6       	ldi	r22, 0x64	; 100
     a2e:	70 e0       	ldi	r23, 0x00	; 0
     a30:	80 e0       	ldi	r24, 0x00	; 0
     a32:	90 e0       	ldi	r25, 0x00	; 0
     a34:	0e 94 bf 11 	call	0x237e	; 0x237e <delay>


void fromWifi()
{
	int i = 0;
	char action = '\0';
     a38:	c0 e0       	ldi	r28, 0x00	; 0
	// check for data from Wifi
	if (serial.available())
	{
		delay(100); // allows all serial sent to be received together
		while (serial.available())
     a3a:	8b ed       	ldi	r24, 0xDB	; 219
     a3c:	92 e0       	ldi	r25, 0x02	; 2
     a3e:	0e 94 63 09 	call	0x12c6	; 0x12c6 <_ZN14SoftwareSerial9availableEv>
     a42:	89 2b       	or	r24, r25
     a44:	39 f0       	breq	.+14     	; 0xa54 <_Z8fromWifiv+0x36>
		{
			action = serial.read();
     a46:	8b ed       	ldi	r24, 0xDB	; 219
     a48:	92 e0       	ldi	r25, 0x02	; 2
     a4a:	0e 94 d9 08 	call	0x11b2	; 0x11b2 <_ZN14SoftwareSerial4readEv>
     a4e:	c8 2f       	mov	r28, r24
	char action = '\0';
	// check for data from Wifi
	if (serial.available())
	{
		delay(100); // allows all serial sent to be received together
		while (serial.available())
     a50:	f4 cf       	rjmp	.-24     	; 0xa3a <_Z8fromWifiv+0x1c>


void fromWifi()
{
	int i = 0;
	char action = '\0';
     a52:	c0 e0       	ldi	r28, 0x00	; 0
		while (serial.available())
		{
			action = serial.read();
		}
	}
	if (alreadyStarted)
     a54:	80 91 00 03 	lds	r24, 0x0300	; 0x800300 <alreadyStarted>
     a58:	81 11       	cpse	r24, r1
     a5a:	6e c0       	rjmp	.+220    	; 0xb38 <_Z8fromWifiv+0x11a>
		action = 'p';

	switch(action)
     a5c:	ce 36       	cpi	r28, 0x6E	; 110
     a5e:	09 f4       	brne	.+2      	; 0xa62 <_Z8fromWifiv+0x44>
     a60:	82 c0       	rjmp	.+260    	; 0xb66 <_Z8fromWifiv+0x148>
     a62:	c0 37       	cpi	r28, 0x70	; 112
     a64:	09 f4       	brne	.+2      	; 0xa68 <_Z8fromWifiv+0x4a>
     a66:	68 c0       	rjmp	.+208    	; 0xb38 <_Z8fromWifiv+0x11a>
     a68:	c1 36       	cpi	r28, 0x61	; 97
     a6a:	09 f0       	breq	.+2      	; 0xa6e <_Z8fromWifiv+0x50>
     a6c:	85 c0       	rjmp	.+266    	; 0xb78 <_Z8fromWifiv+0x15a>
		vTaskResume(xColorSensor);
		break;
	}
	case 'a':
	{
		serial.print("inside case print");
     a6e:	6f e2       	ldi	r22, 0x2F	; 47
     a70:	72 e0       	ldi	r23, 0x02	; 2
     a72:	8b ed       	ldi	r24, 0xDB	; 219
     a74:	92 e0       	ldi	r25, 0x02	; 2
     a76:	0e 94 28 0f 	call	0x1e50	; 0x1e50 <_ZN5Print5printEPKc>
		setLED(Blue);
     a7a:	40 91 07 01 	lds	r20, 0x0107	; 0x800107 <Blue>
     a7e:	50 91 08 01 	lds	r21, 0x0108	; 0x800108 <Blue+0x1>
     a82:	60 91 09 01 	lds	r22, 0x0109	; 0x800109 <Blue+0x2>
     a86:	70 91 0a 01 	lds	r23, 0x010A	; 0x80010a <Blue+0x3>
     a8a:	80 91 0b 01 	lds	r24, 0x010B	; 0x80010b <Blue+0x4>
     a8e:	90 91 0c 01 	lds	r25, 0x010C	; 0x80010c <Blue+0x5>
     a92:	0e 94 9b 03 	call	0x736	; 0x736 <_Z6setLED8LEDColor>
		serial.write("ph:");
     a96:	61 e4       	ldi	r22, 0x41	; 65
     a98:	72 e0       	ldi	r23, 0x02	; 2
     a9a:	8b ed       	ldi	r24, 0xDB	; 219
     a9c:	92 e0       	ldi	r25, 0x02	; 2
     a9e:	0e 94 82 01 	call	0x304	; 0x304 <_ZN5Print5writeEPKc>
		serial.write(phValue);
     aa2:	60 91 09 03 	lds	r22, 0x0309	; 0x800309 <phValue>
     aa6:	8b ed       	ldi	r24, 0xDB	; 219
     aa8:	92 e0       	ldi	r25, 0x02	; 2
     aaa:	0e 94 fa 08 	call	0x11f4	; 0x11f4 <_ZN14SoftwareSerial5writeEh>
		serial.write("temp:");
     aae:	65 e4       	ldi	r22, 0x45	; 69
     ab0:	72 e0       	ldi	r23, 0x02	; 2
     ab2:	8b ed       	ldi	r24, 0xDB	; 219
     ab4:	92 e0       	ldi	r25, 0x02	; 2
     ab6:	0e 94 82 01 	call	0x304	; 0x304 <_ZN5Print5writeEPKc>
		serial.write(tempValue);
     aba:	60 91 07 03 	lds	r22, 0x0307	; 0x800307 <tempValue>
     abe:	8b ed       	ldi	r24, 0xDB	; 219
     ac0:	92 e0       	ldi	r25, 0x02	; 2
     ac2:	0e 94 fa 08 	call	0x11f4	; 0x11f4 <_ZN14SoftwareSerial5writeEh>
		serial.write("ammonia:");
     ac6:	6b e4       	ldi	r22, 0x4B	; 75
     ac8:	72 e0       	ldi	r23, 0x02	; 2
     aca:	8b ed       	ldi	r24, 0xDB	; 219
     acc:	92 e0       	ldi	r25, 0x02	; 2
     ace:	0e 94 82 01 	call	0x304	; 0x304 <_ZN5Print5writeEPKc>
		serial.write(ammoniaValue);
     ad2:	60 91 05 03 	lds	r22, 0x0305	; 0x800305 <ammoniaValue>
     ad6:	8b ed       	ldi	r24, 0xDB	; 219
     ad8:	92 e0       	ldi	r25, 0x02	; 2
     ada:	0e 94 fa 08 	call	0x11f4	; 0x11f4 <_ZN14SoftwareSerial5writeEh>
		serial.write("nitrite:");
     ade:	64 e5       	ldi	r22, 0x54	; 84
     ae0:	72 e0       	ldi	r23, 0x02	; 2
     ae2:	8b ed       	ldi	r24, 0xDB	; 219
     ae4:	92 e0       	ldi	r25, 0x02	; 2
     ae6:	0e 94 82 01 	call	0x304	; 0x304 <_ZN5Print5writeEPKc>
		serial.write(nitriteValue);
     aea:	60 91 01 03 	lds	r22, 0x0301	; 0x800301 <nitriteValue>
     aee:	8b ed       	ldi	r24, 0xDB	; 219
     af0:	92 e0       	ldi	r25, 0x02	; 2
     af2:	0e 94 fa 08 	call	0x11f4	; 0x11f4 <_ZN14SoftwareSerial5writeEh>
		serial.write("nitrate:");
     af6:	6d e5       	ldi	r22, 0x5D	; 93
     af8:	72 e0       	ldi	r23, 0x02	; 2
     afa:	8b ed       	ldi	r24, 0xDB	; 219
     afc:	92 e0       	ldi	r25, 0x02	; 2
     afe:	0e 94 82 01 	call	0x304	; 0x304 <_ZN5Print5writeEPKc>
		serial.write(nitrateValue);
     b02:	60 91 03 03 	lds	r22, 0x0303	; 0x800303 <nitrateValue>
     b06:	8b ed       	ldi	r24, 0xDB	; 219
     b08:	92 e0       	ldi	r25, 0x02	; 2
     b0a:	0e 94 fa 08 	call	0x11f4	; 0x11f4 <_ZN14SoftwareSerial5writeEh>
		delay(200);
     b0e:	68 ec       	ldi	r22, 0xC8	; 200
     b10:	70 e0       	ldi	r23, 0x00	; 0
     b12:	80 e0       	ldi	r24, 0x00	; 0
     b14:	90 e0       	ldi	r25, 0x00	; 0
     b16:	0e 94 bf 11 	call	0x237e	; 0x237e <delay>
		setLED(Off);
     b1a:	40 91 0d 03 	lds	r20, 0x030D	; 0x80030d <Off>
     b1e:	50 91 0e 03 	lds	r21, 0x030E	; 0x80030e <Off+0x1>
     b22:	60 91 0f 03 	lds	r22, 0x030F	; 0x80030f <Off+0x2>
     b26:	70 91 10 03 	lds	r23, 0x0310	; 0x800310 <Off+0x3>
     b2a:	80 91 11 03 	lds	r24, 0x0311	; 0x800311 <Off+0x4>
     b2e:	90 91 12 03 	lds	r25, 0x0312	; 0x800312 <Off+0x5>
	}
	default:
		break;
	}
}
     b32:	cf 91       	pop	r28
		serial.write("nitrite:");
		serial.write(nitriteValue);
		serial.write("nitrate:");
		serial.write(nitrateValue);
		delay(200);
		setLED(Off);
     b34:	0c 94 9b 03 	jmp	0x736	; 0x736 <_Z6setLED8LEDColor>

	switch(action)
	{
	case 'p':
	{
		serial.print("inside case color");
     b38:	6d e1       	ldi	r22, 0x1D	; 29
     b3a:	72 e0       	ldi	r23, 0x02	; 2
     b3c:	8b ed       	ldi	r24, 0xDB	; 219
     b3e:	92 e0       	ldi	r25, 0x02	; 2
     b40:	0e 94 28 0f 	call	0x1e50	; 0x1e50 <_ZN5Print5printEPKc>
		colorToRead = 'a';
     b44:	81 e6       	ldi	r24, 0x61	; 97
     b46:	80 93 06 01 	sts	0x0106, r24	; 0x800106 <colorToRead>
		alreadyStarted = true;
     b4a:	81 e0       	ldi	r24, 0x01	; 1
     b4c:	80 93 00 03 	sts	0x0300, r24	; 0x800300 <alreadyStarted>
		static BaseType_t xHigherPriorityTaskWoken;
		xHigherPriorityTaskWoken = pdFALSE;
     b50:	10 92 da 02 	sts	0x02DA, r1	; 0x8002da <__data_end>
		xSemaphoreGiveFromISR(xSerialSemaphoreColorSensor, &xHigherPriorityTaskWoken);
     b54:	6a ed       	ldi	r22, 0xDA	; 218
     b56:	72 e0       	ldi	r23, 0x02	; 2
     b58:	80 91 fe 02 	lds	r24, 0x02FE	; 0x8002fe <xSerialSemaphoreColorSensor>
     b5c:	90 91 ff 02 	lds	r25, 0x02FF	; 0x8002ff <xSerialSemaphoreColorSensor+0x1>
		setLED(Off);
	}
	default:
		break;
	}
}
     b60:	cf 91       	pop	r28
		serial.print("inside case color");
		colorToRead = 'a';
		alreadyStarted = true;
		static BaseType_t xHigherPriorityTaskWoken;
		xHigherPriorityTaskWoken = pdFALSE;
		xSemaphoreGiveFromISR(xSerialSemaphoreColorSensor, &xHigherPriorityTaskWoken);
     b62:	0c 94 33 15 	jmp	0x2a66	; 0x2a66 <xQueueGiveFromISR>
		break;
	}
	case 'n':
	{
		colorToRead = 'n';
     b66:	c0 93 06 01 	sts	0x0106, r28	; 0x800106 <colorToRead>
		vTaskResume(xColorSensor);
     b6a:	80 91 fc 02 	lds	r24, 0x02FC	; 0x8002fc <xColorSensor>
     b6e:	90 91 fd 02 	lds	r25, 0x02FD	; 0x8002fd <xColorSensor+0x1>
		setLED(Off);
	}
	default:
		break;
	}
}
     b72:	cf 91       	pop	r28
		break;
	}
	case 'n':
	{
		colorToRead = 'n';
		vTaskResume(xColorSensor);
     b74:	0c 94 b5 17 	jmp	0x2f6a	; 0x2f6a <vTaskResume>
		setLED(Off);
	}
	default:
		break;
	}
}
     b78:	cf 91       	pop	r28
     b7a:	08 95       	ret

00000b7c <_ZN7OneWire5resetEv>:
     b7c:	ff 92       	push	r15
     b7e:	0f 93       	push	r16
     b80:	1f 93       	push	r17
     b82:	cf 93       	push	r28
     b84:	df 93       	push	r29
     b86:	fc 01       	movw	r30, r24
     b88:	f0 80       	ld	r15, Z
     b8a:	c1 81       	ldd	r28, Z+1	; 0x01
     b8c:	d2 81       	ldd	r29, Z+2	; 0x02
     b8e:	f8 94       	cli
     b90:	89 81       	ldd	r24, Y+1	; 0x01
     b92:	0f 2d       	mov	r16, r15
     b94:	00 95       	com	r16
     b96:	80 23       	and	r24, r16
     b98:	89 83       	std	Y+1, r24	; 0x01
     b9a:	78 94       	sei
     b9c:	1d e7       	ldi	r17, 0x7D	; 125
     b9e:	11 50       	subi	r17, 0x01	; 1
     ba0:	29 f1       	breq	.+74     	; 0xbec <_ZN7OneWire5resetEv+0x70>
     ba2:	82 e0       	ldi	r24, 0x02	; 2
     ba4:	90 e0       	ldi	r25, 0x00	; 0
     ba6:	0e 94 fb 11 	call	0x23f6	; 0x23f6 <delayMicroseconds>
     baa:	88 81       	ld	r24, Y
     bac:	8f 21       	and	r24, r15
     bae:	b9 f3       	breq	.-18     	; 0xb9e <_ZN7OneWire5resetEv+0x22>
     bb0:	f8 94       	cli
     bb2:	8a 81       	ldd	r24, Y+2	; 0x02
     bb4:	80 23       	and	r24, r16
     bb6:	8a 83       	std	Y+2, r24	; 0x02
     bb8:	89 81       	ldd	r24, Y+1	; 0x01
     bba:	8f 29       	or	r24, r15
     bbc:	89 83       	std	Y+1, r24	; 0x01
     bbe:	78 94       	sei
     bc0:	80 ee       	ldi	r24, 0xE0	; 224
     bc2:	91 e0       	ldi	r25, 0x01	; 1
     bc4:	0e 94 fb 11 	call	0x23f6	; 0x23f6 <delayMicroseconds>
     bc8:	f8 94       	cli
     bca:	89 81       	ldd	r24, Y+1	; 0x01
     bcc:	08 23       	and	r16, r24
     bce:	09 83       	std	Y+1, r16	; 0x01
     bd0:	86 e4       	ldi	r24, 0x46	; 70
     bd2:	90 e0       	ldi	r25, 0x00	; 0
     bd4:	0e 94 fb 11 	call	0x23f6	; 0x23f6 <delayMicroseconds>
     bd8:	88 81       	ld	r24, Y
     bda:	f8 22       	and	r15, r24
     bdc:	11 e0       	ldi	r17, 0x01	; 1
     bde:	09 f0       	breq	.+2      	; 0xbe2 <_ZN7OneWire5resetEv+0x66>
     be0:	10 e0       	ldi	r17, 0x00	; 0
     be2:	78 94       	sei
     be4:	8a e9       	ldi	r24, 0x9A	; 154
     be6:	91 e0       	ldi	r25, 0x01	; 1
     be8:	0e 94 fb 11 	call	0x23f6	; 0x23f6 <delayMicroseconds>
     bec:	81 2f       	mov	r24, r17
     bee:	df 91       	pop	r29
     bf0:	cf 91       	pop	r28
     bf2:	1f 91       	pop	r17
     bf4:	0f 91       	pop	r16
     bf6:	ff 90       	pop	r15
     bf8:	08 95       	ret

00000bfa <_ZN7OneWire9write_bitEh>:
     bfa:	1f 93       	push	r17
     bfc:	cf 93       	push	r28
     bfe:	df 93       	push	r29
     c00:	fc 01       	movw	r30, r24
     c02:	10 81       	ld	r17, Z
     c04:	c1 81       	ldd	r28, Z+1	; 0x01
     c06:	d2 81       	ldd	r29, Z+2	; 0x02
     c08:	81 2f       	mov	r24, r17
     c0a:	80 95       	com	r24
     c0c:	60 ff       	sbrs	r22, 0
     c0e:	12 c0       	rjmp	.+36     	; 0xc34 <_ZN7OneWire9write_bitEh+0x3a>
     c10:	f8 94       	cli
     c12:	9a 81       	ldd	r25, Y+2	; 0x02
     c14:	89 23       	and	r24, r25
     c16:	8a 83       	std	Y+2, r24	; 0x02
     c18:	89 81       	ldd	r24, Y+1	; 0x01
     c1a:	81 2b       	or	r24, r17
     c1c:	89 83       	std	Y+1, r24	; 0x01
     c1e:	8a e0       	ldi	r24, 0x0A	; 10
     c20:	90 e0       	ldi	r25, 0x00	; 0
     c22:	0e 94 fb 11 	call	0x23f6	; 0x23f6 <delayMicroseconds>
     c26:	8a 81       	ldd	r24, Y+2	; 0x02
     c28:	18 2b       	or	r17, r24
     c2a:	1a 83       	std	Y+2, r17	; 0x02
     c2c:	78 94       	sei
     c2e:	87 e3       	ldi	r24, 0x37	; 55
     c30:	90 e0       	ldi	r25, 0x00	; 0
     c32:	11 c0       	rjmp	.+34     	; 0xc56 <_ZN7OneWire9write_bitEh+0x5c>
     c34:	f8 94       	cli
     c36:	9a 81       	ldd	r25, Y+2	; 0x02
     c38:	89 23       	and	r24, r25
     c3a:	8a 83       	std	Y+2, r24	; 0x02
     c3c:	89 81       	ldd	r24, Y+1	; 0x01
     c3e:	81 2b       	or	r24, r17
     c40:	89 83       	std	Y+1, r24	; 0x01
     c42:	81 e4       	ldi	r24, 0x41	; 65
     c44:	90 e0       	ldi	r25, 0x00	; 0
     c46:	0e 94 fb 11 	call	0x23f6	; 0x23f6 <delayMicroseconds>
     c4a:	8a 81       	ldd	r24, Y+2	; 0x02
     c4c:	18 2b       	or	r17, r24
     c4e:	1a 83       	std	Y+2, r17	; 0x02
     c50:	78 94       	sei
     c52:	85 e0       	ldi	r24, 0x05	; 5
     c54:	90 e0       	ldi	r25, 0x00	; 0
     c56:	df 91       	pop	r29
     c58:	cf 91       	pop	r28
     c5a:	1f 91       	pop	r17
     c5c:	0c 94 fb 11 	jmp	0x23f6	; 0x23f6 <delayMicroseconds>

00000c60 <_ZN7OneWire8read_bitEv>:
     c60:	0f 93       	push	r16
     c62:	1f 93       	push	r17
     c64:	cf 93       	push	r28
     c66:	df 93       	push	r29
     c68:	fc 01       	movw	r30, r24
     c6a:	00 81       	ld	r16, Z
     c6c:	c1 81       	ldd	r28, Z+1	; 0x01
     c6e:	d2 81       	ldd	r29, Z+2	; 0x02
     c70:	f8 94       	cli
     c72:	89 81       	ldd	r24, Y+1	; 0x01
     c74:	80 2b       	or	r24, r16
     c76:	89 83       	std	Y+1, r24	; 0x01
     c78:	8a 81       	ldd	r24, Y+2	; 0x02
     c7a:	10 2f       	mov	r17, r16
     c7c:	10 95       	com	r17
     c7e:	81 23       	and	r24, r17
     c80:	8a 83       	std	Y+2, r24	; 0x02
     c82:	83 e0       	ldi	r24, 0x03	; 3
     c84:	90 e0       	ldi	r25, 0x00	; 0
     c86:	0e 94 fb 11 	call	0x23f6	; 0x23f6 <delayMicroseconds>
     c8a:	89 81       	ldd	r24, Y+1	; 0x01
     c8c:	18 23       	and	r17, r24
     c8e:	19 83       	std	Y+1, r17	; 0x01
     c90:	8a e0       	ldi	r24, 0x0A	; 10
     c92:	90 e0       	ldi	r25, 0x00	; 0
     c94:	0e 94 fb 11 	call	0x23f6	; 0x23f6 <delayMicroseconds>
     c98:	c8 81       	ld	r28, Y
     c9a:	78 94       	sei
     c9c:	85 e3       	ldi	r24, 0x35	; 53
     c9e:	90 e0       	ldi	r25, 0x00	; 0
     ca0:	0e 94 fb 11 	call	0x23f6	; 0x23f6 <delayMicroseconds>
     ca4:	c0 23       	and	r28, r16
     ca6:	81 e0       	ldi	r24, 0x01	; 1
     ca8:	09 f4       	brne	.+2      	; 0xcac <_ZN7OneWire8read_bitEv+0x4c>
     caa:	80 e0       	ldi	r24, 0x00	; 0
     cac:	df 91       	pop	r29
     cae:	cf 91       	pop	r28
     cb0:	1f 91       	pop	r17
     cb2:	0f 91       	pop	r16
     cb4:	08 95       	ret

00000cb6 <_ZN7OneWire5writeEhh>:
     cb6:	df 92       	push	r13
     cb8:	ef 92       	push	r14
     cba:	ff 92       	push	r15
     cbc:	0f 93       	push	r16
     cbe:	1f 93       	push	r17
     cc0:	cf 93       	push	r28
     cc2:	df 93       	push	r29
     cc4:	ec 01       	movw	r28, r24
     cc6:	d6 2e       	mov	r13, r22
     cc8:	e4 2e       	mov	r14, r20
     cca:	08 e0       	ldi	r16, 0x08	; 8
     ccc:	10 e0       	ldi	r17, 0x00	; 0
     cce:	ff 24       	eor	r15, r15
     cd0:	f3 94       	inc	r15
     cd2:	61 e0       	ldi	r22, 0x01	; 1
     cd4:	8d 2d       	mov	r24, r13
     cd6:	8f 21       	and	r24, r15
     cd8:	09 f4       	brne	.+2      	; 0xcdc <_ZN7OneWire5writeEhh+0x26>
     cda:	60 e0       	ldi	r22, 0x00	; 0
     cdc:	ce 01       	movw	r24, r28
     cde:	0e 94 fd 05 	call	0xbfa	; 0xbfa <_ZN7OneWire9write_bitEh>
     ce2:	ff 0c       	add	r15, r15
     ce4:	01 50       	subi	r16, 0x01	; 1
     ce6:	11 09       	sbc	r17, r1
     ce8:	a1 f7       	brne	.-24     	; 0xcd2 <_ZN7OneWire5writeEhh+0x1c>
     cea:	e1 10       	cpse	r14, r1
     cec:	10 c0       	rjmp	.+32     	; 0xd0e <_ZN7OneWire5writeEhh+0x58>
     cee:	f8 94       	cli
     cf0:	e9 81       	ldd	r30, Y+1	; 0x01
     cf2:	fa 81       	ldd	r31, Y+2	; 0x02
     cf4:	91 81       	ldd	r25, Z+1	; 0x01
     cf6:	88 81       	ld	r24, Y
     cf8:	80 95       	com	r24
     cfa:	89 23       	and	r24, r25
     cfc:	81 83       	std	Z+1, r24	; 0x01
     cfe:	e9 81       	ldd	r30, Y+1	; 0x01
     d00:	fa 81       	ldd	r31, Y+2	; 0x02
     d02:	92 81       	ldd	r25, Z+2	; 0x02
     d04:	88 81       	ld	r24, Y
     d06:	80 95       	com	r24
     d08:	89 23       	and	r24, r25
     d0a:	82 83       	std	Z+2, r24	; 0x02
     d0c:	78 94       	sei
     d0e:	df 91       	pop	r29
     d10:	cf 91       	pop	r28
     d12:	1f 91       	pop	r17
     d14:	0f 91       	pop	r16
     d16:	ff 90       	pop	r15
     d18:	ef 90       	pop	r14
     d1a:	df 90       	pop	r13
     d1c:	08 95       	ret

00000d1e <_ZN7OneWire4readEv>:
     d1e:	ef 92       	push	r14
     d20:	ff 92       	push	r15
     d22:	0f 93       	push	r16
     d24:	1f 93       	push	r17
     d26:	cf 93       	push	r28
     d28:	df 93       	push	r29
     d2a:	7c 01       	movw	r14, r24
     d2c:	08 e0       	ldi	r16, 0x08	; 8
     d2e:	10 e0       	ldi	r17, 0x00	; 0
     d30:	c0 e0       	ldi	r28, 0x00	; 0
     d32:	d1 e0       	ldi	r29, 0x01	; 1
     d34:	c7 01       	movw	r24, r14
     d36:	0e 94 30 06 	call	0xc60	; 0xc60 <_ZN7OneWire8read_bitEv>
     d3a:	81 11       	cpse	r24, r1
     d3c:	cd 2b       	or	r28, r29
     d3e:	dd 0f       	add	r29, r29
     d40:	01 50       	subi	r16, 0x01	; 1
     d42:	11 09       	sbc	r17, r1
     d44:	b9 f7       	brne	.-18     	; 0xd34 <_ZN7OneWire4readEv+0x16>
     d46:	8c 2f       	mov	r24, r28
     d48:	df 91       	pop	r29
     d4a:	cf 91       	pop	r28
     d4c:	1f 91       	pop	r17
     d4e:	0f 91       	pop	r16
     d50:	ff 90       	pop	r15
     d52:	ef 90       	pop	r14
     d54:	08 95       	ret

00000d56 <_ZN7OneWire6selectEPKh>:
     d56:	ef 92       	push	r14
     d58:	ff 92       	push	r15
     d5a:	0f 93       	push	r16
     d5c:	1f 93       	push	r17
     d5e:	cf 93       	push	r28
     d60:	df 93       	push	r29
     d62:	8c 01       	movw	r16, r24
     d64:	7b 01       	movw	r14, r22
     d66:	40 e0       	ldi	r20, 0x00	; 0
     d68:	65 e5       	ldi	r22, 0x55	; 85
     d6a:	0e 94 5b 06 	call	0xcb6	; 0xcb6 <_ZN7OneWire5writeEhh>
     d6e:	e7 01       	movw	r28, r14
     d70:	88 e0       	ldi	r24, 0x08	; 8
     d72:	e8 0e       	add	r14, r24
     d74:	f1 1c       	adc	r15, r1
     d76:	69 91       	ld	r22, Y+
     d78:	40 e0       	ldi	r20, 0x00	; 0
     d7a:	c8 01       	movw	r24, r16
     d7c:	0e 94 5b 06 	call	0xcb6	; 0xcb6 <_ZN7OneWire5writeEhh>
     d80:	ce 15       	cp	r28, r14
     d82:	df 05       	cpc	r29, r15
     d84:	c1 f7       	brne	.-16     	; 0xd76 <_ZN7OneWire6selectEPKh+0x20>
     d86:	df 91       	pop	r29
     d88:	cf 91       	pop	r28
     d8a:	1f 91       	pop	r17
     d8c:	0f 91       	pop	r16
     d8e:	ff 90       	pop	r15
     d90:	ef 90       	pop	r14
     d92:	08 95       	ret

00000d94 <_ZN7OneWire12reset_searchEv>:
     d94:	fc 01       	movw	r30, r24
     d96:	13 86       	std	Z+11, r1	; 0x0b
     d98:	15 86       	std	Z+13, r1	; 0x0d
     d9a:	14 86       	std	Z+12, r1	; 0x0c
     d9c:	dc 01       	movw	r26, r24
     d9e:	1b 96       	adiw	r26, 0x0b	; 11
     da0:	33 96       	adiw	r30, 0x03	; 3
     da2:	1e 92       	st	-X, r1
     da4:	ae 17       	cp	r26, r30
     da6:	bf 07       	cpc	r27, r31
     da8:	e1 f7       	brne	.-8      	; 0xda2 <_ZN7OneWire12reset_searchEv+0xe>
     daa:	08 95       	ret

00000dac <_ZN7OneWire5beginEh>:
     dac:	1f 93       	push	r17
     dae:	cf 93       	push	r28
     db0:	df 93       	push	r29
     db2:	ec 01       	movw	r28, r24
     db4:	16 2f       	mov	r17, r22
     db6:	60 e0       	ldi	r22, 0x00	; 0
     db8:	81 2f       	mov	r24, r17
     dba:	0e 94 e6 12 	call	0x25cc	; 0x25cc <pinMode>
     dbe:	61 2f       	mov	r22, r17
     dc0:	70 e0       	ldi	r23, 0x00	; 0
     dc2:	fb 01       	movw	r30, r22
     dc4:	e0 55       	subi	r30, 0x50	; 80
     dc6:	ff 4f       	sbci	r31, 0xFF	; 255
     dc8:	e4 91       	lpm	r30, Z
     dca:	e8 83       	st	Y, r30
     dcc:	fb 01       	movw	r30, r22
     dce:	ec 53       	subi	r30, 0x3C	; 60
     dd0:	ff 4f       	sbci	r31, 0xFF	; 255
     dd2:	e4 91       	lpm	r30, Z
     dd4:	f0 e0       	ldi	r31, 0x00	; 0
     dd6:	ee 0f       	add	r30, r30
     dd8:	ff 1f       	adc	r31, r31
     dda:	e8 52       	subi	r30, 0x28	; 40
     ddc:	ff 4f       	sbci	r31, 0xFF	; 255
     dde:	85 91       	lpm	r24, Z+
     de0:	94 91       	lpm	r25, Z
     de2:	9a 83       	std	Y+2, r25	; 0x02
     de4:	89 83       	std	Y+1, r24	; 0x01
     de6:	ce 01       	movw	r24, r28
     de8:	df 91       	pop	r29
     dea:	cf 91       	pop	r28
     dec:	1f 91       	pop	r17
     dee:	0c 94 ca 06 	jmp	0xd94	; 0xd94 <_ZN7OneWire12reset_searchEv>

00000df2 <_ZN7OneWire6searchEPhb>:
     df2:	bf 92       	push	r11
     df4:	cf 92       	push	r12
     df6:	df 92       	push	r13
     df8:	ef 92       	push	r14
     dfa:	ff 92       	push	r15
     dfc:	0f 93       	push	r16
     dfe:	1f 93       	push	r17
     e00:	cf 93       	push	r28
     e02:	df 93       	push	r29
     e04:	ec 01       	movw	r28, r24
     e06:	6b 01       	movw	r12, r22
     e08:	14 2f       	mov	r17, r20
     e0a:	8d 85       	ldd	r24, Y+13	; 0x0d
     e0c:	81 11       	cpse	r24, r1
     e0e:	05 c0       	rjmp	.+10     	; 0xe1a <_ZN7OneWire6searchEPhb+0x28>
     e10:	ce 01       	movw	r24, r28
     e12:	0e 94 be 05 	call	0xb7c	; 0xb7c <_ZN7OneWire5resetEv>
     e16:	81 11       	cpse	r24, r1
     e18:	05 c0       	rjmp	.+10     	; 0xe24 <_ZN7OneWire6searchEPhb+0x32>
     e1a:	1b 86       	std	Y+11, r1	; 0x0b
     e1c:	1d 86       	std	Y+13, r1	; 0x0d
     e1e:	1c 86       	std	Y+12, r1	; 0x0c
     e20:	80 e0       	ldi	r24, 0x00	; 0
     e22:	64 c0       	rjmp	.+200    	; 0xeec <_ZN7OneWire6searchEPhb+0xfa>
     e24:	40 e0       	ldi	r20, 0x00	; 0
     e26:	11 23       	and	r17, r17
     e28:	11 f0       	breq	.+4      	; 0xe2e <_ZN7OneWire6searchEPhb+0x3c>
     e2a:	60 ef       	ldi	r22, 0xF0	; 240
     e2c:	01 c0       	rjmp	.+2      	; 0xe30 <_ZN7OneWire6searchEPhb+0x3e>
     e2e:	6c ee       	ldi	r22, 0xEC	; 236
     e30:	ce 01       	movw	r24, r28
     e32:	0e 94 5b 06 	call	0xcb6	; 0xcb6 <_ZN7OneWire5writeEhh>
     e36:	01 e0       	ldi	r16, 0x01	; 1
     e38:	e1 2c       	mov	r14, r1
     e3a:	b1 2c       	mov	r11, r1
     e3c:	11 e0       	ldi	r17, 0x01	; 1
     e3e:	ce 01       	movw	r24, r28
     e40:	0e 94 30 06 	call	0xc60	; 0xc60 <_ZN7OneWire8read_bitEv>
     e44:	f8 2e       	mov	r15, r24
     e46:	ce 01       	movw	r24, r28
     e48:	0e 94 30 06 	call	0xc60	; 0xc60 <_ZN7OneWire8read_bitEv>
     e4c:	91 e0       	ldi	r25, 0x01	; 1
     e4e:	f9 12       	cpse	r15, r25
     e50:	03 c0       	rjmp	.+6      	; 0xe58 <_ZN7OneWire6searchEPhb+0x66>
     e52:	81 30       	cpi	r24, 0x01	; 1
     e54:	b1 f4       	brne	.+44     	; 0xe82 <_ZN7OneWire6searchEPhb+0x90>
     e56:	34 c0       	rjmp	.+104    	; 0xec0 <_ZN7OneWire6searchEPhb+0xce>
     e58:	2e 2d       	mov	r18, r14
     e5a:	30 e0       	ldi	r19, 0x00	; 0
     e5c:	f8 12       	cpse	r15, r24
     e5e:	1b c0       	rjmp	.+54     	; 0xe96 <_ZN7OneWire6searchEPhb+0xa4>
     e60:	8b 85       	ldd	r24, Y+11	; 0x0b
     e62:	18 17       	cp	r17, r24
     e64:	38 f4       	brcc	.+14     	; 0xe74 <_ZN7OneWire6searchEPhb+0x82>
     e66:	fe 01       	movw	r30, r28
     e68:	e2 0f       	add	r30, r18
     e6a:	f3 1f       	adc	r31, r19
     e6c:	83 81       	ldd	r24, Z+3	; 0x03
     e6e:	80 23       	and	r24, r16
     e70:	41 f4       	brne	.+16     	; 0xe82 <_ZN7OneWire6searchEPhb+0x90>
     e72:	02 c0       	rjmp	.+4      	; 0xe78 <_ZN7OneWire6searchEPhb+0x86>
     e74:	18 17       	cp	r17, r24
     e76:	29 f0       	breq	.+10     	; 0xe82 <_ZN7OneWire6searchEPhb+0x90>
     e78:	f1 2c       	mov	r15, r1
     e7a:	19 30       	cpi	r17, 0x09	; 9
     e7c:	58 f4       	brcc	.+22     	; 0xe94 <_ZN7OneWire6searchEPhb+0xa2>
     e7e:	1c 87       	std	Y+12, r17	; 0x0c
     e80:	09 c0       	rjmp	.+18     	; 0xe94 <_ZN7OneWire6searchEPhb+0xa2>
     e82:	fe 01       	movw	r30, r28
     e84:	ee 0d       	add	r30, r14
     e86:	f1 1d       	adc	r31, r1
     e88:	83 81       	ldd	r24, Z+3	; 0x03
     e8a:	80 2b       	or	r24, r16
     e8c:	83 83       	std	Z+3, r24	; 0x03
     e8e:	ff 24       	eor	r15, r15
     e90:	f3 94       	inc	r15
     e92:	09 c0       	rjmp	.+18     	; 0xea6 <_ZN7OneWire6searchEPhb+0xb4>
     e94:	b1 2e       	mov	r11, r17
     e96:	fe 01       	movw	r30, r28
     e98:	e2 0f       	add	r30, r18
     e9a:	f3 1f       	adc	r31, r19
     e9c:	93 81       	ldd	r25, Z+3	; 0x03
     e9e:	80 2f       	mov	r24, r16
     ea0:	80 95       	com	r24
     ea2:	89 23       	and	r24, r25
     ea4:	83 83       	std	Z+3, r24	; 0x03
     ea6:	6f 2d       	mov	r22, r15
     ea8:	ce 01       	movw	r24, r28
     eaa:	0e 94 fd 05 	call	0xbfa	; 0xbfa <_ZN7OneWire9write_bitEh>
     eae:	1f 5f       	subi	r17, 0xFF	; 255
     eb0:	00 0f       	add	r16, r16
     eb2:	11 f4       	brne	.+4      	; 0xeb8 <_ZN7OneWire6searchEPhb+0xc6>
     eb4:	e3 94       	inc	r14
     eb6:	01 e0       	ldi	r16, 0x01	; 1
     eb8:	87 e0       	ldi	r24, 0x07	; 7
     eba:	8e 15       	cp	r24, r14
     ebc:	08 f0       	brcs	.+2      	; 0xec0 <_ZN7OneWire6searchEPhb+0xce>
     ebe:	bf cf       	rjmp	.-130    	; 0xe3e <_ZN7OneWire6searchEPhb+0x4c>
     ec0:	11 34       	cpi	r17, 0x41	; 65
     ec2:	08 f4       	brcc	.+2      	; 0xec6 <_ZN7OneWire6searchEPhb+0xd4>
     ec4:	aa cf       	rjmp	.-172    	; 0xe1a <_ZN7OneWire6searchEPhb+0x28>
     ec6:	bb 86       	std	Y+11, r11	; 0x0b
     ec8:	b1 10       	cpse	r11, r1
     eca:	02 c0       	rjmp	.+4      	; 0xed0 <_ZN7OneWire6searchEPhb+0xde>
     ecc:	81 e0       	ldi	r24, 0x01	; 1
     ece:	8d 87       	std	Y+13, r24	; 0x0d
     ed0:	8b 81       	ldd	r24, Y+3	; 0x03
     ed2:	88 23       	and	r24, r24
     ed4:	09 f4       	brne	.+2      	; 0xed8 <_ZN7OneWire6searchEPhb+0xe6>
     ed6:	a1 cf       	rjmp	.-190    	; 0xe1a <_ZN7OneWire6searchEPhb+0x28>
     ed8:	de 01       	movw	r26, r28
     eda:	13 96       	adiw	r26, 0x03	; 3
     edc:	f6 01       	movw	r30, r12
     ede:	2b 96       	adiw	r28, 0x0b	; 11
     ee0:	8d 91       	ld	r24, X+
     ee2:	81 93       	st	Z+, r24
     ee4:	ca 17       	cp	r28, r26
     ee6:	db 07       	cpc	r29, r27
     ee8:	d9 f7       	brne	.-10     	; 0xee0 <_ZN7OneWire6searchEPhb+0xee>
     eea:	81 e0       	ldi	r24, 0x01	; 1
     eec:	df 91       	pop	r29
     eee:	cf 91       	pop	r28
     ef0:	1f 91       	pop	r17
     ef2:	0f 91       	pop	r16
     ef4:	ff 90       	pop	r15
     ef6:	ef 90       	pop	r14
     ef8:	df 90       	pop	r13
     efa:	cf 90       	pop	r12
     efc:	bf 90       	pop	r11
     efe:	08 95       	ret

00000f00 <_ZN7OneWire4crc8EPKhh>:
     f00:	dc 01       	movw	r26, r24
     f02:	80 e0       	ldi	r24, 0x00	; 0
     f04:	61 50       	subi	r22, 0x01	; 1
     f06:	98 f0       	brcs	.+38     	; 0xf2e <_ZN7OneWire4crc8EPKhh+0x2e>
     f08:	2d 91       	ld	r18, X+
     f0a:	98 2f       	mov	r25, r24
     f0c:	92 27       	eor	r25, r18
     f0e:	e9 2f       	mov	r30, r25
     f10:	ef 70       	andi	r30, 0x0F	; 15
     f12:	f0 e0       	ldi	r31, 0x00	; 0
     f14:	e4 58       	subi	r30, 0x84	; 132
     f16:	ff 4f       	sbci	r31, 0xFF	; 255
     f18:	24 91       	lpm	r18, Z
     f1a:	92 95       	swap	r25
     f1c:	9f 70       	andi	r25, 0x0F	; 15
     f1e:	e9 2f       	mov	r30, r25
     f20:	f0 e0       	ldi	r31, 0x00	; 0
     f22:	e4 57       	subi	r30, 0x74	; 116
     f24:	ff 4f       	sbci	r31, 0xFF	; 255
     f26:	e4 91       	lpm	r30, Z
     f28:	82 2f       	mov	r24, r18
     f2a:	8e 27       	eor	r24, r30
     f2c:	eb cf       	rjmp	.-42     	; 0xf04 <_ZN7OneWire4crc8EPKhh+0x4>
     f2e:	08 95       	ret

00000f30 <_Z6phInitv>:
}

void calibratePH(long temperaturePH) {
	float voltage = analogRead(PH_PIN)/1024.0*5000;
	ph.calibration(voltage, temperaturePH);
}
     f30:	8e e0       	ldi	r24, 0x0E	; 14
     f32:	94 e0       	ldi	r25, 0x04	; 4
     f34:	0c 94 d3 00 	jmp	0x1a6	; 0x1a6 <_ZN10DFRobot_PH5beginEv>

00000f38 <_Z6calcPHv>:

float calcPH()
{
     f38:	4f 92       	push	r4
     f3a:	5f 92       	push	r5
     f3c:	6f 92       	push	r6
     f3e:	7f 92       	push	r7
     f40:	8f 92       	push	r8
     f42:	9f 92       	push	r9
     f44:	af 92       	push	r10
     f46:	bf 92       	push	r11
     f48:	cf 92       	push	r12
     f4a:	df 92       	push	r13
     f4c:	ef 92       	push	r14
     f4e:	ff 92       	push	r15
	float voltage = analogRead(PH_PIN);
     f50:	8e e0       	ldi	r24, 0x0E	; 14
     f52:	0e 94 41 12 	call	0x2482	; 0x2482 <analogRead>
     f56:	bc 01       	movw	r22, r24
     f58:	99 0f       	add	r25, r25
     f5a:	88 0b       	sbc	r24, r24
     f5c:	99 0b       	sbc	r25, r25
     f5e:	0e 94 62 0c 	call	0x18c4	; 0x18c4 <__floatsisf>
     f62:	6b 01       	movw	r12, r22
     f64:	7c 01       	movw	r14, r24
	float slope = (7.0 - 4.0)/(neutralVoltage - acidVoltage);
     f66:	40 90 1d 01 	lds	r4, 0x011D	; 0x80011d <neutralVoltage>
     f6a:	50 90 1e 01 	lds	r5, 0x011E	; 0x80011e <neutralVoltage+0x1>
     f6e:	60 90 1f 01 	lds	r6, 0x011F	; 0x80011f <neutralVoltage+0x2>
     f72:	70 90 20 01 	lds	r7, 0x0120	; 0x800120 <neutralVoltage+0x3>
     f76:	20 91 19 01 	lds	r18, 0x0119	; 0x800119 <acidVoltage>
     f7a:	30 91 1a 01 	lds	r19, 0x011A	; 0x80011a <acidVoltage+0x1>
     f7e:	40 91 1b 01 	lds	r20, 0x011B	; 0x80011b <acidVoltage+0x2>
     f82:	50 91 1c 01 	lds	r21, 0x011C	; 0x80011c <acidVoltage+0x3>
     f86:	c3 01       	movw	r24, r6
     f88:	b2 01       	movw	r22, r4
     f8a:	0e 94 46 0b 	call	0x168c	; 0x168c <__subsf3>
     f8e:	9b 01       	movw	r18, r22
     f90:	ac 01       	movw	r20, r24
     f92:	60 e0       	ldi	r22, 0x00	; 0
     f94:	70 e0       	ldi	r23, 0x00	; 0
     f96:	80 e4       	ldi	r24, 0x40	; 64
     f98:	90 e4       	ldi	r25, 0x40	; 64
     f9a:	0e 94 b8 0b 	call	0x1770	; 0x1770 <__divsf3>
     f9e:	4b 01       	movw	r8, r22
     fa0:	5c 01       	movw	r10, r24
	float intercept = 7.0-(slope * neutralVoltage);
	Serial.write("Neutral Voltage:");
     fa2:	66 e6       	ldi	r22, 0x66	; 102
     fa4:	72 e0       	ldi	r23, 0x02	; 2
     fa6:	81 e7       	ldi	r24, 0x71	; 113
     fa8:	94 e0       	ldi	r25, 0x04	; 4
     faa:	0e 94 82 01 	call	0x304	; 0x304 <_ZN5Print5writeEPKc>
	Serial.print(neutralVoltage);
     fae:	40 91 1d 01 	lds	r20, 0x011D	; 0x80011d <neutralVoltage>
     fb2:	50 91 1e 01 	lds	r21, 0x011E	; 0x80011e <neutralVoltage+0x1>
     fb6:	60 91 1f 01 	lds	r22, 0x011F	; 0x80011f <neutralVoltage+0x2>
     fba:	70 91 20 01 	lds	r23, 0x0120	; 0x800120 <neutralVoltage+0x3>
     fbe:	22 e0       	ldi	r18, 0x02	; 2
     fc0:	30 e0       	ldi	r19, 0x00	; 0
     fc2:	81 e7       	ldi	r24, 0x71	; 113
     fc4:	94 e0       	ldi	r25, 0x04	; 4
     fc6:	0e 94 cd 10 	call	0x219a	; 0x219a <_ZN5Print5printEdi>
	Serial.write("\nAcid Voltage:");
     fca:	67 e7       	ldi	r22, 0x77	; 119
     fcc:	72 e0       	ldi	r23, 0x02	; 2
     fce:	81 e7       	ldi	r24, 0x71	; 113
     fd0:	94 e0       	ldi	r25, 0x04	; 4
     fd2:	0e 94 82 01 	call	0x304	; 0x304 <_ZN5Print5writeEPKc>
	Serial.print(acidVoltage);
     fd6:	40 91 19 01 	lds	r20, 0x0119	; 0x800119 <acidVoltage>
     fda:	50 91 1a 01 	lds	r21, 0x011A	; 0x80011a <acidVoltage+0x1>
     fde:	60 91 1b 01 	lds	r22, 0x011B	; 0x80011b <acidVoltage+0x2>
     fe2:	70 91 1c 01 	lds	r23, 0x011C	; 0x80011c <acidVoltage+0x3>
     fe6:	22 e0       	ldi	r18, 0x02	; 2
     fe8:	30 e0       	ldi	r19, 0x00	; 0
     fea:	81 e7       	ldi	r24, 0x71	; 113
     fec:	94 e0       	ldi	r25, 0x04	; 4
     fee:	0e 94 cd 10 	call	0x219a	; 0x219a <_ZN5Print5printEdi>
	Serial.write("\nVoltage Measured:");
     ff2:	66 e8       	ldi	r22, 0x86	; 134
     ff4:	72 e0       	ldi	r23, 0x02	; 2
     ff6:	81 e7       	ldi	r24, 0x71	; 113
     ff8:	94 e0       	ldi	r25, 0x04	; 4
     ffa:	0e 94 82 01 	call	0x304	; 0x304 <_ZN5Print5writeEPKc>
	Serial.print(voltage);
     ffe:	22 e0       	ldi	r18, 0x02	; 2
    1000:	30 e0       	ldi	r19, 0x00	; 0
    1002:	b7 01       	movw	r22, r14
    1004:	a6 01       	movw	r20, r12
    1006:	81 e7       	ldi	r24, 0x71	; 113
    1008:	94 e0       	ldi	r25, 0x04	; 4
    100a:	0e 94 cd 10 	call	0x219a	; 0x219a <_ZN5Print5printEdi>
	return (slope * voltage) + intercept;
    100e:	a5 01       	movw	r20, r10
    1010:	94 01       	movw	r18, r8
    1012:	c3 01       	movw	r24, r6
    1014:	b2 01       	movw	r22, r4
    1016:	0e 94 17 0d 	call	0x1a2e	; 0x1a2e <__mulsf3>
    101a:	9b 01       	movw	r18, r22
    101c:	ac 01       	movw	r20, r24
    101e:	60 e0       	ldi	r22, 0x00	; 0
    1020:	70 e0       	ldi	r23, 0x00	; 0
    1022:	80 ee       	ldi	r24, 0xE0	; 224
    1024:	90 e4       	ldi	r25, 0x40	; 64
    1026:	0e 94 46 0b 	call	0x168c	; 0x168c <__subsf3>
    102a:	2b 01       	movw	r4, r22
    102c:	3c 01       	movw	r6, r24
    102e:	a5 01       	movw	r20, r10
    1030:	94 01       	movw	r18, r8
    1032:	c7 01       	movw	r24, r14
    1034:	b6 01       	movw	r22, r12
    1036:	0e 94 17 0d 	call	0x1a2e	; 0x1a2e <__mulsf3>
    103a:	9b 01       	movw	r18, r22
    103c:	ac 01       	movw	r20, r24
    103e:	c3 01       	movw	r24, r6
    1040:	b2 01       	movw	r22, r4
    1042:	0e 94 47 0b 	call	0x168e	; 0x168e <__addsf3>
    1046:	ff 90       	pop	r15
    1048:	ef 90       	pop	r14
    104a:	df 90       	pop	r13
    104c:	cf 90       	pop	r12
    104e:	bf 90       	pop	r11
    1050:	af 90       	pop	r10
    1052:	9f 90       	pop	r9
    1054:	8f 90       	pop	r8
    1056:	7f 90       	pop	r7
    1058:	6f 90       	pop	r6
    105a:	5f 90       	pop	r5
    105c:	4f 90       	pop	r4
    105e:	08 95       	ret

00001060 <_GLOBAL__sub_I_ph>:
#include "phSensor.h"

DFRobot_PH ph;
    1060:	8e e0       	ldi	r24, 0x0E	; 14
    1062:	94 e0       	ldi	r25, 0x04	; 4
    1064:	0c 94 ac 00 	jmp	0x158	; 0x158 <_ZN10DFRobot_PHC1Ev>

00001068 <_GLOBAL__sub_D_ph>:
    1068:	8e e0       	ldi	r24, 0x0E	; 14
    106a:	94 e0       	ldi	r25, 0x04	; 4
    106c:	0c 94 d2 00 	jmp	0x1a4	; 0x1a4 <_ZN10DFRobot_PHD1Ev>

00001070 <_ZN9MD_TCS23010initialiseEv>:
}

void MD_TCS230::setSampling(uint8_t t)
// set sampling rate divisor for frequency counter
{
  _readDiv = (t > 0 ? t : _readDiv);
    1070:	0f 93       	push	r16
    1072:	1f 93       	push	r17
    1074:	fc 01       	movw	r30, r24
    1076:	8f ef       	ldi	r24, 0xFF	; 255
    1078:	80 83       	st	Z, r24
    107a:	81 83       	std	Z+1, r24	; 0x01
    107c:	82 83       	std	Z+2, r24	; 0x02
    107e:	83 83       	std	Z+3, r24	; 0x03
    1080:	84 83       	std	Z+4, r24	; 0x04
    1082:	8a e0       	ldi	r24, 0x0A	; 10
    1084:	85 83       	std	Z+5, r24	; 0x05
    1086:	16 82       	std	Z+6, r1	; 0x06
    1088:	df 01       	movw	r26, r30
    108a:	17 96       	adiw	r26, 0x07	; 7
    108c:	73 96       	adiw	r30, 0x13	; 19
    108e:	00 e7       	ldi	r16, 0x70	; 112
    1090:	17 e1       	ldi	r17, 0x17	; 23
    1092:	20 e0       	ldi	r18, 0x00	; 0
    1094:	30 e0       	ldi	r19, 0x00	; 0
    1096:	48 ed       	ldi	r20, 0xD8	; 216
    1098:	56 ed       	ldi	r21, 0xD6	; 214
    109a:	60 e0       	ldi	r22, 0x00	; 0
    109c:	70 e0       	ldi	r23, 0x00	; 0
    109e:	0d 93       	st	X+, r16
    10a0:	1d 93       	st	X+, r17
    10a2:	2d 93       	st	X+, r18
    10a4:	3d 93       	st	X+, r19
    10a6:	18 96       	adiw	r26, 0x08	; 8
    10a8:	4d 93       	st	X+, r20
    10aa:	5d 93       	st	X+, r21
    10ac:	6d 93       	st	X+, r22
    10ae:	7c 93       	st	X, r23
    10b0:	1b 97       	sbiw	r26, 0x0b	; 11
    10b2:	ae 17       	cp	r26, r30
    10b4:	bf 07       	cpc	r27, r31
    10b6:	99 f7       	brne	.-26     	; 0x109e <_ZN9MD_TCS23010initialiseEv+0x2e>
    10b8:	1f 91       	pop	r17
    10ba:	0f 91       	pop	r16
    10bc:	08 95       	ret

000010be <_ZN9MD_TCS230C1Ehhh>:
    10be:	ff 92       	push	r15
    10c0:	0f 93       	push	r16
    10c2:	1f 93       	push	r17
    10c4:	cf 93       	push	r28
    10c6:	df 93       	push	r29
    10c8:	ec 01       	movw	r28, r24
    10ca:	f6 2e       	mov	r15, r22
    10cc:	04 2f       	mov	r16, r20
    10ce:	12 2f       	mov	r17, r18
    10d0:	0e 94 38 08 	call	0x1070	; 0x1070 <_ZN9MD_TCS23010initialiseEv>
    10d4:	fb 82       	std	Y+3, r15	; 0x03
    10d6:	0c 83       	std	Y+4, r16	; 0x04
    10d8:	18 83       	st	Y, r17
    10da:	df 91       	pop	r29
    10dc:	cf 91       	pop	r28
    10de:	1f 91       	pop	r17
    10e0:	0f 91       	pop	r16
    10e2:	ff 90       	pop	r15
    10e4:	08 95       	ret

000010e6 <_ZN9MD_TCS230D1Ev>:
    10e6:	08 95       	ret

000010e8 <_ZN9MD_TCS23013setFrequency2Eh>:
    10e8:	cf 93       	push	r28
    10ea:	df 93       	push	r29
    10ec:	ec 01       	movw	r28, r24
    10ee:	89 81       	ldd	r24, Y+1	; 0x01
    10f0:	8f 3f       	cpi	r24, 0xFF	; 255
    10f2:	e9 f0       	breq	.+58     	; 0x112e <_ZN9MD_TCS23013setFrequency2Eh+0x46>
    10f4:	9a 81       	ldd	r25, Y+2	; 0x02
    10f6:	9f 3f       	cpi	r25, 0xFF	; 255
    10f8:	d1 f0       	breq	.+52     	; 0x112e <_ZN9MD_TCS23013setFrequency2Eh+0x46>
    10fa:	61 30       	cpi	r22, 0x01	; 1
    10fc:	49 f0       	breq	.+18     	; 0x1110 <_ZN9MD_TCS23013setFrequency2Eh+0x28>
    10fe:	30 f0       	brcs	.+12     	; 0x110c <_ZN9MD_TCS23013setFrequency2Eh+0x24>
    1100:	62 30       	cpi	r22, 0x02	; 2
    1102:	41 f0       	breq	.+16     	; 0x1114 <_ZN9MD_TCS23013setFrequency2Eh+0x2c>
    1104:	63 30       	cpi	r22, 0x03	; 3
    1106:	99 f4       	brne	.+38     	; 0x112e <_ZN9MD_TCS23013setFrequency2Eh+0x46>
    1108:	60 e0       	ldi	r22, 0x00	; 0
    110a:	09 c0       	rjmp	.+18     	; 0x111e <_ZN9MD_TCS23013setFrequency2Eh+0x36>
    110c:	61 e0       	ldi	r22, 0x01	; 1
    110e:	03 c0       	rjmp	.+6      	; 0x1116 <_ZN9MD_TCS23013setFrequency2Eh+0x2e>
    1110:	61 e0       	ldi	r22, 0x01	; 1
    1112:	05 c0       	rjmp	.+10     	; 0x111e <_ZN9MD_TCS23013setFrequency2Eh+0x36>
    1114:	60 e0       	ldi	r22, 0x00	; 0
    1116:	0e 94 22 13 	call	0x2644	; 0x2644 <digitalWrite>
    111a:	61 e0       	ldi	r22, 0x01	; 1
    111c:	03 c0       	rjmp	.+6      	; 0x1124 <_ZN9MD_TCS23013setFrequency2Eh+0x3c>
    111e:	0e 94 22 13 	call	0x2644	; 0x2644 <digitalWrite>
    1122:	60 e0       	ldi	r22, 0x00	; 0
    1124:	8a 81       	ldd	r24, Y+2	; 0x02
    1126:	df 91       	pop	r29
    1128:	cf 91       	pop	r28
    112a:	0c 94 22 13 	jmp	0x2644	; 0x2644 <digitalWrite>
    112e:	df 91       	pop	r29
    1130:	cf 91       	pop	r28
    1132:	08 95       	ret

00001134 <_ZN9MD_TCS2309setEnableEb>:
  if (b)
    DUMPS("\nEn");
  else
    DUMPS("\nDis");
  DUMPS("abling using ");
  if (_OE != NO_PIN)
    1134:	fc 01       	movw	r30, r24
    1136:	20 81       	ld	r18, Z
    1138:	2f 3f       	cpi	r18, 0xFF	; 255
    113a:	29 f0       	breq	.+10     	; 0x1146 <_ZN9MD_TCS2309setEnableEb+0x12>
  {
    DUMPS("OE");
    digitalWrite(_OE, (b) ? LOW : HIGH);	// reverse logic
    113c:	91 e0       	ldi	r25, 0x01	; 1
    113e:	69 27       	eor	r22, r25
    1140:	82 2f       	mov	r24, r18
    1142:	0c 94 22 13 	jmp	0x2644	; 0x2644 <digitalWrite>
  }
  else
  {
    DUMPS("FREQ");
    setFrequency2((b) ? _freqSet : TCS230_FREQ_OFF);
    1146:	66 23       	and	r22, r22
    1148:	19 f0       	breq	.+6      	; 0x1150 <_ZN9MD_TCS2309setEnableEb+0x1c>
    114a:	fc 01       	movw	r30, r24
    114c:	66 81       	ldd	r22, Z+6	; 0x06
    114e:	01 c0       	rjmp	.+2      	; 0x1152 <_ZN9MD_TCS2309setEnableEb+0x1e>
    1150:	63 e0       	ldi	r22, 0x03	; 3
    1152:	0c 94 74 08 	jmp	0x10e8	; 0x10e8 <_ZN9MD_TCS23013setFrequency2Eh>

00001156 <_ZN9MD_TCS2305beginEv>:
MD_TCS230::~MD_TCS230(void)
{
}

void MD_TCS230::begin()
{
    1156:	cf 93       	push	r28
    1158:	df 93       	push	r29
    115a:	ec 01       	movw	r28, r24
  if (_S0 != NO_PIN) pinMode(_S0, OUTPUT);
    115c:	89 81       	ldd	r24, Y+1	; 0x01
    115e:	8f 3f       	cpi	r24, 0xFF	; 255
    1160:	19 f0       	breq	.+6      	; 0x1168 <_ZN9MD_TCS2305beginEv+0x12>
    1162:	61 e0       	ldi	r22, 0x01	; 1
    1164:	0e 94 e6 12 	call	0x25cc	; 0x25cc <pinMode>
  if (_S1 != NO_PIN) pinMode(_S1, OUTPUT);
    1168:	8a 81       	ldd	r24, Y+2	; 0x02
    116a:	8f 3f       	cpi	r24, 0xFF	; 255
    116c:	19 f0       	breq	.+6      	; 0x1174 <_ZN9MD_TCS2305beginEv+0x1e>
    116e:	61 e0       	ldi	r22, 0x01	; 1
    1170:	0e 94 e6 12 	call	0x25cc	; 0x25cc <pinMode>
  if (_S2 != NO_PIN) pinMode(_S2, OUTPUT);
    1174:	8b 81       	ldd	r24, Y+3	; 0x03
    1176:	8f 3f       	cpi	r24, 0xFF	; 255
    1178:	19 f0       	breq	.+6      	; 0x1180 <_ZN9MD_TCS2305beginEv+0x2a>
    117a:	61 e0       	ldi	r22, 0x01	; 1
    117c:	0e 94 e6 12 	call	0x25cc	; 0x25cc <pinMode>
  if (_S3 != NO_PIN) pinMode(_S3, OUTPUT);
    1180:	8c 81       	ldd	r24, Y+4	; 0x04
    1182:	8f 3f       	cpi	r24, 0xFF	; 255
    1184:	19 f0       	breq	.+6      	; 0x118c <_ZN9MD_TCS2305beginEv+0x36>
    1186:	61 e0       	ldi	r22, 0x01	; 1
    1188:	0e 94 e6 12 	call	0x25cc	; 0x25cc <pinMode>
  if (_OE != NO_PIN) pinMode(_OE, OUTPUT);
    118c:	88 81       	ld	r24, Y
    118e:	8f 3f       	cpi	r24, 0xFF	; 255
    1190:	19 f0       	breq	.+6      	; 0x1198 <_ZN9MD_TCS2305beginEv+0x42>
    1192:	61 e0       	ldi	r22, 0x01	; 1
    1194:	0e 94 e6 12 	call	0x25cc	; 0x25cc <pinMode>

  setEnable(false);
    1198:	60 e0       	ldi	r22, 0x00	; 0
    119a:	ce 01       	movw	r24, r28
    119c:	0e 94 9a 08 	call	0x1134	; 0x1134 <_ZN9MD_TCS2309setEnableEb>
  setFrequency2(_freqSet);
    11a0:	6e 81       	ldd	r22, Y+6	; 0x06
    11a2:	ce 01       	movw	r24, r28

#undef SET_OUTPUT
  DUMPS("\nLibrary begin initialised");
}
    11a4:	df 91       	pop	r29
    11a6:	cf 91       	pop	r28
  if (_S2 != NO_PIN) pinMode(_S2, OUTPUT);
  if (_S3 != NO_PIN) pinMode(_S3, OUTPUT);
  if (_OE != NO_PIN) pinMode(_OE, OUTPUT);

  setEnable(false);
  setFrequency2(_freqSet);
    11a8:	0c 94 74 08 	jmp	0x10e8	; 0x10e8 <_ZN9MD_TCS23013setFrequency2Eh>

000011ac <_ZN5Print17availableForWriteEv>:
uint16_t SoftwareSerial::subtract_cap(uint16_t num, uint16_t sub) {
  if (num > sub)
    return num - sub;
  else
    return 1;
}
    11ac:	80 e0       	ldi	r24, 0x00	; 0
    11ae:	90 e0       	ldi	r25, 0x00	; 0
    11b0:	08 95       	ret

000011b2 <_ZN14SoftwareSerial4readEv>:
    11b2:	20 91 6f 04 	lds	r18, 0x046F	; 0x80046f <_ZN14SoftwareSerial13active_objectE>
    11b6:	30 91 70 04 	lds	r19, 0x0470	; 0x800470 <_ZN14SoftwareSerial13active_objectE+0x1>
    11ba:	28 17       	cp	r18, r24
    11bc:	39 07       	cpc	r19, r25
    11be:	b9 f4       	brne	.+46     	; 0x11ee <_ZN14SoftwareSerial4readEv+0x3c>
    11c0:	90 91 2d 04 	lds	r25, 0x042D	; 0x80042d <_ZN14SoftwareSerial20_receive_buffer_headE>
    11c4:	80 91 2e 04 	lds	r24, 0x042E	; 0x80042e <_ZN14SoftwareSerial20_receive_buffer_tailE>
    11c8:	98 17       	cp	r25, r24
    11ca:	89 f0       	breq	.+34     	; 0x11ee <_ZN14SoftwareSerial4readEv+0x3c>
    11cc:	e0 91 2d 04 	lds	r30, 0x042D	; 0x80042d <_ZN14SoftwareSerial20_receive_buffer_headE>
    11d0:	f0 e0       	ldi	r31, 0x00	; 0
    11d2:	e1 5d       	subi	r30, 0xD1	; 209
    11d4:	fb 4f       	sbci	r31, 0xFB	; 251
    11d6:	80 81       	ld	r24, Z
    11d8:	20 91 2d 04 	lds	r18, 0x042D	; 0x80042d <_ZN14SoftwareSerial20_receive_buffer_headE>
    11dc:	30 e0       	ldi	r19, 0x00	; 0
    11de:	2f 5f       	subi	r18, 0xFF	; 255
    11e0:	3f 4f       	sbci	r19, 0xFF	; 255
    11e2:	2f 73       	andi	r18, 0x3F	; 63
    11e4:	33 27       	eor	r19, r19
    11e6:	20 93 2d 04 	sts	0x042D, r18	; 0x80042d <_ZN14SoftwareSerial20_receive_buffer_headE>
    11ea:	90 e0       	ldi	r25, 0x00	; 0
    11ec:	08 95       	ret
    11ee:	8f ef       	ldi	r24, 0xFF	; 255
    11f0:	9f ef       	ldi	r25, 0xFF	; 255
    11f2:	08 95       	ret

000011f4 <_ZN14SoftwareSerial5writeEh>:
    11f4:	1f 93       	push	r17
    11f6:	cf 93       	push	r28
    11f8:	df 93       	push	r29
    11fa:	dc 01       	movw	r26, r24
    11fc:	5c 96       	adiw	r26, 0x1c	; 28
    11fe:	8d 91       	ld	r24, X+
    1200:	9c 91       	ld	r25, X
    1202:	5d 97       	sbiw	r26, 0x1d	; 29
    1204:	00 97       	sbiw	r24, 0x00	; 0
    1206:	39 f4       	brne	.+14     	; 0x1216 <_ZN14SoftwareSerial5writeEh+0x22>
    1208:	21 e0       	ldi	r18, 0x01	; 1
    120a:	30 e0       	ldi	r19, 0x00	; 0
    120c:	13 96       	adiw	r26, 0x03	; 3
    120e:	3c 93       	st	X, r19
    1210:	2e 93       	st	-X, r18
    1212:	12 97       	sbiw	r26, 0x02	; 2
    1214:	3b c0       	rjmp	.+118    	; 0x128c <_ZN14SoftwareSerial5writeEh+0x98>
    1216:	51 96       	adiw	r26, 0x11	; 17
    1218:	ed 91       	ld	r30, X+
    121a:	fc 91       	ld	r31, X
    121c:	52 97       	sbiw	r26, 0x12	; 18
    121e:	50 96       	adiw	r26, 0x10	; 16
    1220:	2c 91       	ld	r18, X
    1222:	50 97       	sbiw	r26, 0x10	; 16
    1224:	32 2f       	mov	r19, r18
    1226:	30 95       	com	r19
    1228:	1f b7       	in	r17, 0x3f	; 63
    122a:	5e 96       	adiw	r26, 0x1e	; 30
    122c:	4c 91       	ld	r20, X
    122e:	5e 97       	sbiw	r26, 0x1e	; 30
    1230:	74 2f       	mov	r23, r20
    1232:	72 70       	andi	r23, 0x02	; 2
    1234:	41 fd       	sbrc	r20, 1
    1236:	60 95       	com	r22
    1238:	f8 94       	cli
    123a:	40 81       	ld	r20, Z
    123c:	77 23       	and	r23, r23
    123e:	11 f0       	breq	.+4      	; 0x1244 <_ZN14SoftwareSerial5writeEh+0x50>
    1240:	42 2b       	or	r20, r18
    1242:	01 c0       	rjmp	.+2      	; 0x1246 <_ZN14SoftwareSerial5writeEh+0x52>
    1244:	43 23       	and	r20, r19
    1246:	40 83       	st	Z, r20
    1248:	ec 01       	movw	r28, r24
    124a:	21 97       	sbiw	r28, 0x01	; 1
    124c:	f1 f7       	brne	.-4      	; 0x124a <_ZN14SoftwareSerial5writeEh+0x56>
    124e:	48 e0       	ldi	r20, 0x08	; 8
    1250:	50 81       	ld	r21, Z
    1252:	60 ff       	sbrs	r22, 0
    1254:	02 c0       	rjmp	.+4      	; 0x125a <_ZN14SoftwareSerial5writeEh+0x66>
    1256:	52 2b       	or	r21, r18
    1258:	01 c0       	rjmp	.+2      	; 0x125c <_ZN14SoftwareSerial5writeEh+0x68>
    125a:	53 23       	and	r21, r19
    125c:	50 83       	st	Z, r21
    125e:	ec 01       	movw	r28, r24
    1260:	21 97       	sbiw	r28, 0x01	; 1
    1262:	f1 f7       	brne	.-4      	; 0x1260 <_ZN14SoftwareSerial5writeEh+0x6c>
    1264:	66 95       	lsr	r22
    1266:	41 50       	subi	r20, 0x01	; 1
    1268:	99 f7       	brne	.-26     	; 0x1250 <_ZN14SoftwareSerial5writeEh+0x5c>
    126a:	80 81       	ld	r24, Z
    126c:	77 23       	and	r23, r23
    126e:	19 f0       	breq	.+6      	; 0x1276 <_ZN14SoftwareSerial5writeEh+0x82>
    1270:	83 23       	and	r24, r19
    1272:	80 83       	st	Z, r24
    1274:	02 c0       	rjmp	.+4      	; 0x127a <_ZN14SoftwareSerial5writeEh+0x86>
    1276:	28 2b       	or	r18, r24
    1278:	20 83       	st	Z, r18
    127a:	1f bf       	out	0x3f, r17	; 63
    127c:	5c 96       	adiw	r26, 0x1c	; 28
    127e:	8d 91       	ld	r24, X+
    1280:	9c 91       	ld	r25, X
    1282:	5d 97       	sbiw	r26, 0x1d	; 29
    1284:	01 97       	sbiw	r24, 0x01	; 1
    1286:	f1 f7       	brne	.-4      	; 0x1284 <_ZN14SoftwareSerial5writeEh+0x90>
    1288:	81 e0       	ldi	r24, 0x01	; 1
    128a:	90 e0       	ldi	r25, 0x00	; 0
    128c:	df 91       	pop	r29
    128e:	cf 91       	pop	r28
    1290:	1f 91       	pop	r17
    1292:	08 95       	ret

00001294 <_ZN14SoftwareSerial5flushEv>:
    1294:	08 95       	ret

00001296 <_ZN14SoftwareSerial4peekEv>:
    1296:	20 91 6f 04 	lds	r18, 0x046F	; 0x80046f <_ZN14SoftwareSerial13active_objectE>
    129a:	30 91 70 04 	lds	r19, 0x0470	; 0x800470 <_ZN14SoftwareSerial13active_objectE+0x1>
    129e:	28 17       	cp	r18, r24
    12a0:	39 07       	cpc	r19, r25
    12a2:	71 f4       	brne	.+28     	; 0x12c0 <_ZN14SoftwareSerial4peekEv+0x2a>
    12a4:	90 91 2d 04 	lds	r25, 0x042D	; 0x80042d <_ZN14SoftwareSerial20_receive_buffer_headE>
    12a8:	80 91 2e 04 	lds	r24, 0x042E	; 0x80042e <_ZN14SoftwareSerial20_receive_buffer_tailE>
    12ac:	98 17       	cp	r25, r24
    12ae:	41 f0       	breq	.+16     	; 0x12c0 <_ZN14SoftwareSerial4peekEv+0x2a>
    12b0:	e0 91 2d 04 	lds	r30, 0x042D	; 0x80042d <_ZN14SoftwareSerial20_receive_buffer_headE>
    12b4:	f0 e0       	ldi	r31, 0x00	; 0
    12b6:	e1 5d       	subi	r30, 0xD1	; 209
    12b8:	fb 4f       	sbci	r31, 0xFB	; 251
    12ba:	80 81       	ld	r24, Z
    12bc:	90 e0       	ldi	r25, 0x00	; 0
    12be:	08 95       	ret
    12c0:	8f ef       	ldi	r24, 0xFF	; 255
    12c2:	9f ef       	ldi	r25, 0xFF	; 255
    12c4:	08 95       	ret

000012c6 <_ZN14SoftwareSerial9availableEv>:
    12c6:	20 91 6f 04 	lds	r18, 0x046F	; 0x80046f <_ZN14SoftwareSerial13active_objectE>
    12ca:	30 91 70 04 	lds	r19, 0x0470	; 0x800470 <_ZN14SoftwareSerial13active_objectE+0x1>
    12ce:	28 17       	cp	r18, r24
    12d0:	39 07       	cpc	r19, r25
    12d2:	71 f4       	brne	.+28     	; 0x12f0 <_ZN14SoftwareSerial9availableEv+0x2a>
    12d4:	80 91 2e 04 	lds	r24, 0x042E	; 0x80042e <_ZN14SoftwareSerial20_receive_buffer_tailE>
    12d8:	20 91 2d 04 	lds	r18, 0x042D	; 0x80042d <_ZN14SoftwareSerial20_receive_buffer_headE>
    12dc:	90 e0       	ldi	r25, 0x00	; 0
    12de:	80 5c       	subi	r24, 0xC0	; 192
    12e0:	9f 4f       	sbci	r25, 0xFF	; 255
    12e2:	82 1b       	sub	r24, r18
    12e4:	91 09       	sbc	r25, r1
    12e6:	60 e4       	ldi	r22, 0x40	; 64
    12e8:	70 e0       	ldi	r23, 0x00	; 0
    12ea:	0e 94 9a 1f 	call	0x3f34	; 0x3f34 <__divmodhi4>
    12ee:	08 95       	ret
    12f0:	80 e0       	ldi	r24, 0x00	; 0
    12f2:	90 e0       	ldi	r25, 0x00	; 0
    12f4:	08 95       	ret

000012f6 <_ZN14SoftwareSerial13stopListeningEv>:
    12f6:	e0 91 6f 04 	lds	r30, 0x046F	; 0x80046f <_ZN14SoftwareSerial13active_objectE>
    12fa:	f0 91 70 04 	lds	r31, 0x0470	; 0x800470 <_ZN14SoftwareSerial13active_objectE+0x1>
    12fe:	e8 17       	cp	r30, r24
    1300:	f9 07       	cpc	r31, r25
    1302:	69 f4       	brne	.+26     	; 0x131e <_ZN14SoftwareSerial13stopListeningEv+0x28>
    1304:	a3 89       	ldd	r26, Z+19	; 0x13
    1306:	b4 89       	ldd	r27, Z+20	; 0x14
    1308:	9c 91       	ld	r25, X
    130a:	85 89       	ldd	r24, Z+21	; 0x15
    130c:	80 95       	com	r24
    130e:	89 23       	and	r24, r25
    1310:	8c 93       	st	X, r24
    1312:	10 92 70 04 	sts	0x0470, r1	; 0x800470 <_ZN14SoftwareSerial13active_objectE+0x1>
    1316:	10 92 6f 04 	sts	0x046F, r1	; 0x80046f <_ZN14SoftwareSerial13active_objectE>
    131a:	81 e0       	ldi	r24, 0x01	; 1
    131c:	08 95       	ret
    131e:	80 e0       	ldi	r24, 0x00	; 0
    1320:	08 95       	ret

00001322 <_ZN14SoftwareSerial6listenEv>:
    1322:	cf 93       	push	r28
    1324:	df 93       	push	r29
    1326:	ec 01       	movw	r28, r24
    1328:	8a 8d       	ldd	r24, Y+26	; 0x1a
    132a:	9b 8d       	ldd	r25, Y+27	; 0x1b
    132c:	89 2b       	or	r24, r25
    132e:	f1 f0       	breq	.+60     	; 0x136c <_ZN14SoftwareSerial6listenEv+0x4a>
    1330:	80 91 6f 04 	lds	r24, 0x046F	; 0x80046f <_ZN14SoftwareSerial13active_objectE>
    1334:	90 91 70 04 	lds	r25, 0x0470	; 0x800470 <_ZN14SoftwareSerial13active_objectE+0x1>
    1338:	c8 17       	cp	r28, r24
    133a:	d9 07       	cpc	r29, r25
    133c:	b9 f0       	breq	.+46     	; 0x136c <_ZN14SoftwareSerial6listenEv+0x4a>
    133e:	00 97       	sbiw	r24, 0x00	; 0
    1340:	11 f0       	breq	.+4      	; 0x1346 <_ZN14SoftwareSerial6listenEv+0x24>
    1342:	0e 94 7b 09 	call	0x12f6	; 0x12f6 <_ZN14SoftwareSerial13stopListeningEv>
    1346:	8e 8d       	ldd	r24, Y+30	; 0x1e
    1348:	8e 7f       	andi	r24, 0xFE	; 254
    134a:	8e 8f       	std	Y+30, r24	; 0x1e
    134c:	10 92 2e 04 	sts	0x042E, r1	; 0x80042e <_ZN14SoftwareSerial20_receive_buffer_tailE>
    1350:	10 92 2d 04 	sts	0x042D, r1	; 0x80042d <_ZN14SoftwareSerial20_receive_buffer_headE>
    1354:	d0 93 70 04 	sts	0x0470, r29	; 0x800470 <_ZN14SoftwareSerial13active_objectE+0x1>
    1358:	c0 93 6f 04 	sts	0x046F, r28	; 0x80046f <_ZN14SoftwareSerial13active_objectE>
    135c:	eb 89       	ldd	r30, Y+19	; 0x13
    135e:	fc 89       	ldd	r31, Y+20	; 0x14
    1360:	90 81       	ld	r25, Z
    1362:	8d 89       	ldd	r24, Y+21	; 0x15
    1364:	89 2b       	or	r24, r25
    1366:	80 83       	st	Z, r24
    1368:	81 e0       	ldi	r24, 0x01	; 1
    136a:	01 c0       	rjmp	.+2      	; 0x136e <_ZN14SoftwareSerial6listenEv+0x4c>
    136c:	80 e0       	ldi	r24, 0x00	; 0
    136e:	df 91       	pop	r29
    1370:	cf 91       	pop	r28
    1372:	08 95       	ret

00001374 <__vector_3>:
    1374:	1f 92       	push	r1
    1376:	0f 92       	push	r0
    1378:	0f b6       	in	r0, 0x3f	; 63
    137a:	0f 92       	push	r0
    137c:	11 24       	eor	r1, r1
    137e:	2f 93       	push	r18
    1380:	3f 93       	push	r19
    1382:	4f 93       	push	r20
    1384:	5f 93       	push	r21
    1386:	6f 93       	push	r22
    1388:	7f 93       	push	r23
    138a:	8f 93       	push	r24
    138c:	9f 93       	push	r25
    138e:	af 93       	push	r26
    1390:	bf 93       	push	r27
    1392:	ef 93       	push	r30
    1394:	ff 93       	push	r31
    1396:	e0 91 6f 04 	lds	r30, 0x046F	; 0x80046f <_ZN14SoftwareSerial13active_objectE>
    139a:	f0 91 70 04 	lds	r31, 0x0470	; 0x800470 <_ZN14SoftwareSerial13active_objectE+0x1>
    139e:	30 97       	sbiw	r30, 0x00	; 0
    13a0:	09 f4       	brne	.+2      	; 0x13a4 <__vector_3+0x30>
    13a2:	51 c0       	rjmp	.+162    	; 0x1446 <__vector_3+0xd2>
    13a4:	96 8d       	ldd	r25, Z+30	; 0x1e
    13a6:	a6 85       	ldd	r26, Z+14	; 0x0e
    13a8:	b7 85       	ldd	r27, Z+15	; 0x0f
    13aa:	85 85       	ldd	r24, Z+13	; 0x0d
    13ac:	91 ff       	sbrs	r25, 1
    13ae:	04 c0       	rjmp	.+8      	; 0x13b8 <__vector_3+0x44>
    13b0:	9c 91       	ld	r25, X
    13b2:	89 23       	and	r24, r25
    13b4:	29 f4       	brne	.+10     	; 0x13c0 <__vector_3+0x4c>
    13b6:	47 c0       	rjmp	.+142    	; 0x1446 <__vector_3+0xd2>
    13b8:	9c 91       	ld	r25, X
    13ba:	89 23       	and	r24, r25
    13bc:	09 f0       	breq	.+2      	; 0x13c0 <__vector_3+0x4c>
    13be:	43 c0       	rjmp	.+134    	; 0x1446 <__vector_3+0xd2>
    13c0:	a3 89       	ldd	r26, Z+19	; 0x13
    13c2:	b4 89       	ldd	r27, Z+20	; 0x14
    13c4:	9c 91       	ld	r25, X
    13c6:	85 89       	ldd	r24, Z+21	; 0x15
    13c8:	80 95       	com	r24
    13ca:	89 23       	and	r24, r25
    13cc:	8c 93       	st	X, r24
    13ce:	86 89       	ldd	r24, Z+22	; 0x16
    13d0:	97 89       	ldd	r25, Z+23	; 0x17
    13d2:	01 97       	sbiw	r24, 0x01	; 1
    13d4:	f1 f7       	brne	.-4      	; 0x13d2 <__vector_3+0x5e>
    13d6:	60 8d       	ldd	r22, Z+24	; 0x18
    13d8:	71 8d       	ldd	r23, Z+25	; 0x19
    13da:	a6 85       	ldd	r26, Z+14	; 0x0e
    13dc:	b7 85       	ldd	r27, Z+15	; 0x0f
    13de:	55 85       	ldd	r21, Z+13	; 0x0d
    13e0:	38 e0       	ldi	r19, 0x08	; 8
    13e2:	20 e0       	ldi	r18, 0x00	; 0
    13e4:	cb 01       	movw	r24, r22
    13e6:	01 97       	sbiw	r24, 0x01	; 1
    13e8:	f1 f7       	brne	.-4      	; 0x13e6 <__vector_3+0x72>
    13ea:	82 2f       	mov	r24, r18
    13ec:	90 e0       	ldi	r25, 0x00	; 0
    13ee:	95 95       	asr	r25
    13f0:	87 95       	ror	r24
    13f2:	28 2f       	mov	r18, r24
    13f4:	4c 91       	ld	r20, X
    13f6:	45 23       	and	r20, r21
    13f8:	09 f0       	breq	.+2      	; 0x13fc <__vector_3+0x88>
    13fa:	20 68       	ori	r18, 0x80	; 128
    13fc:	31 50       	subi	r19, 0x01	; 1
    13fe:	91 f7       	brne	.-28     	; 0x13e4 <__vector_3+0x70>
    1400:	86 8d       	ldd	r24, Z+30	; 0x1e
    1402:	81 fd       	sbrc	r24, 1
    1404:	20 95       	com	r18
    1406:	80 91 2e 04 	lds	r24, 0x042E	; 0x80042e <_ZN14SoftwareSerial20_receive_buffer_tailE>
    140a:	90 e0       	ldi	r25, 0x00	; 0
    140c:	01 96       	adiw	r24, 0x01	; 1
    140e:	8f 73       	andi	r24, 0x3F	; 63
    1410:	99 27       	eor	r25, r25
    1412:	30 91 2d 04 	lds	r19, 0x042D	; 0x80042d <_ZN14SoftwareSerial20_receive_buffer_headE>
    1416:	38 17       	cp	r19, r24
    1418:	49 f0       	breq	.+18     	; 0x142c <__vector_3+0xb8>
    141a:	a0 91 2e 04 	lds	r26, 0x042E	; 0x80042e <_ZN14SoftwareSerial20_receive_buffer_tailE>
    141e:	b0 e0       	ldi	r27, 0x00	; 0
    1420:	a1 5d       	subi	r26, 0xD1	; 209
    1422:	bb 4f       	sbci	r27, 0xFB	; 251
    1424:	2c 93       	st	X, r18
    1426:	80 93 2e 04 	sts	0x042E, r24	; 0x80042e <_ZN14SoftwareSerial20_receive_buffer_tailE>
    142a:	03 c0       	rjmp	.+6      	; 0x1432 <__vector_3+0xbe>
    142c:	86 8d       	ldd	r24, Z+30	; 0x1e
    142e:	81 60       	ori	r24, 0x01	; 1
    1430:	86 8f       	std	Z+30, r24	; 0x1e
    1432:	82 8d       	ldd	r24, Z+26	; 0x1a
    1434:	93 8d       	ldd	r25, Z+27	; 0x1b
    1436:	01 97       	sbiw	r24, 0x01	; 1
    1438:	f1 f7       	brne	.-4      	; 0x1436 <__vector_3+0xc2>
    143a:	a3 89       	ldd	r26, Z+19	; 0x13
    143c:	b4 89       	ldd	r27, Z+20	; 0x14
    143e:	9c 91       	ld	r25, X
    1440:	85 89       	ldd	r24, Z+21	; 0x15
    1442:	89 2b       	or	r24, r25
    1444:	8c 93       	st	X, r24
    1446:	ff 91       	pop	r31
    1448:	ef 91       	pop	r30
    144a:	bf 91       	pop	r27
    144c:	af 91       	pop	r26
    144e:	9f 91       	pop	r25
    1450:	8f 91       	pop	r24
    1452:	7f 91       	pop	r23
    1454:	6f 91       	pop	r22
    1456:	5f 91       	pop	r21
    1458:	4f 91       	pop	r20
    145a:	3f 91       	pop	r19
    145c:	2f 91       	pop	r18
    145e:	0f 90       	pop	r0
    1460:	0f be       	out	0x3f, r0	; 63
    1462:	0f 90       	pop	r0
    1464:	1f 90       	pop	r1
    1466:	18 95       	reti

00001468 <_ZN14SoftwareSerialD1Ev>:
    1468:	2d e9       	ldi	r18, 0x9D	; 157
    146a:	32 e0       	ldi	r19, 0x02	; 2
    146c:	fc 01       	movw	r30, r24
    146e:	31 83       	std	Z+1, r19	; 0x01
    1470:	20 83       	st	Z, r18
    1472:	0c 94 7b 09 	jmp	0x12f6	; 0x12f6 <_ZN14SoftwareSerial13stopListeningEv>

00001476 <_ZN14SoftwareSerial5setTXEh>:
    1476:	1f 93       	push	r17
    1478:	cf 93       	push	r28
    147a:	df 93       	push	r29
    147c:	ec 01       	movw	r28, r24
    147e:	16 2f       	mov	r17, r22
    1480:	6e 8d       	ldd	r22, Y+30	; 0x1e
    1482:	66 95       	lsr	r22
    1484:	61 70       	andi	r22, 0x01	; 1
    1486:	81 e0       	ldi	r24, 0x01	; 1
    1488:	68 27       	eor	r22, r24
    148a:	81 2f       	mov	r24, r17
    148c:	0e 94 22 13 	call	0x2644	; 0x2644 <digitalWrite>
    1490:	61 e0       	ldi	r22, 0x01	; 1
    1492:	81 2f       	mov	r24, r17
    1494:	0e 94 e6 12 	call	0x25cc	; 0x25cc <pinMode>
    1498:	81 2f       	mov	r24, r17
    149a:	90 e0       	ldi	r25, 0x00	; 0
    149c:	fc 01       	movw	r30, r24
    149e:	e0 55       	subi	r30, 0x50	; 80
    14a0:	ff 4f       	sbci	r31, 0xFF	; 255
    14a2:	e4 91       	lpm	r30, Z
    14a4:	e8 8b       	std	Y+16, r30	; 0x10
    14a6:	fc 01       	movw	r30, r24
    14a8:	ec 53       	subi	r30, 0x3C	; 60
    14aa:	ff 4f       	sbci	r31, 0xFF	; 255
    14ac:	e4 91       	lpm	r30, Z
    14ae:	f0 e0       	ldi	r31, 0x00	; 0
    14b0:	ee 0f       	add	r30, r30
    14b2:	ff 1f       	adc	r31, r31
    14b4:	ee 51       	subi	r30, 0x1E	; 30
    14b6:	ff 4f       	sbci	r31, 0xFF	; 255
    14b8:	85 91       	lpm	r24, Z+
    14ba:	94 91       	lpm	r25, Z
    14bc:	9a 8b       	std	Y+18, r25	; 0x12
    14be:	89 8b       	std	Y+17, r24	; 0x11
    14c0:	df 91       	pop	r29
    14c2:	cf 91       	pop	r28
    14c4:	1f 91       	pop	r17
    14c6:	08 95       	ret

000014c8 <_ZN14SoftwareSerial5setRXEh>:
    14c8:	1f 93       	push	r17
    14ca:	cf 93       	push	r28
    14cc:	df 93       	push	r29
    14ce:	ec 01       	movw	r28, r24
    14d0:	16 2f       	mov	r17, r22
    14d2:	60 e0       	ldi	r22, 0x00	; 0
    14d4:	81 2f       	mov	r24, r17
    14d6:	0e 94 e6 12 	call	0x25cc	; 0x25cc <pinMode>
    14da:	8e 8d       	ldd	r24, Y+30	; 0x1e
    14dc:	81 fd       	sbrc	r24, 1
    14de:	04 c0       	rjmp	.+8      	; 0x14e8 <_ZN14SoftwareSerial5setRXEh+0x20>
    14e0:	61 e0       	ldi	r22, 0x01	; 1
    14e2:	81 2f       	mov	r24, r17
    14e4:	0e 94 22 13 	call	0x2644	; 0x2644 <digitalWrite>
    14e8:	1c 87       	std	Y+12, r17	; 0x0c
    14ea:	81 2f       	mov	r24, r17
    14ec:	90 e0       	ldi	r25, 0x00	; 0
    14ee:	fc 01       	movw	r30, r24
    14f0:	e0 55       	subi	r30, 0x50	; 80
    14f2:	ff 4f       	sbci	r31, 0xFF	; 255
    14f4:	e4 91       	lpm	r30, Z
    14f6:	ed 87       	std	Y+13, r30	; 0x0d
    14f8:	fc 01       	movw	r30, r24
    14fa:	ec 53       	subi	r30, 0x3C	; 60
    14fc:	ff 4f       	sbci	r31, 0xFF	; 255
    14fe:	e4 91       	lpm	r30, Z
    1500:	f0 e0       	ldi	r31, 0x00	; 0
    1502:	ee 0f       	add	r30, r30
    1504:	ff 1f       	adc	r31, r31
    1506:	e8 52       	subi	r30, 0x28	; 40
    1508:	ff 4f       	sbci	r31, 0xFF	; 255
    150a:	85 91       	lpm	r24, Z+
    150c:	94 91       	lpm	r25, Z
    150e:	9f 87       	std	Y+15, r25	; 0x0f
    1510:	8e 87       	std	Y+14, r24	; 0x0e
    1512:	df 91       	pop	r29
    1514:	cf 91       	pop	r28
    1516:	1f 91       	pop	r17
    1518:	08 95       	ret

0000151a <_ZN14SoftwareSerialC1Ehhb>:
    151a:	1f 93       	push	r17
    151c:	cf 93       	push	r28
    151e:	df 93       	push	r29
    1520:	ec 01       	movw	r28, r24
    1522:	16 2f       	mov	r17, r22
    1524:	1b 82       	std	Y+3, r1	; 0x03
    1526:	1a 82       	std	Y+2, r1	; 0x02
    1528:	88 ee       	ldi	r24, 0xE8	; 232
    152a:	93 e0       	ldi	r25, 0x03	; 3
    152c:	a0 e0       	ldi	r26, 0x00	; 0
    152e:	b0 e0       	ldi	r27, 0x00	; 0
    1530:	8c 83       	std	Y+4, r24	; 0x04
    1532:	9d 83       	std	Y+5, r25	; 0x05
    1534:	ae 83       	std	Y+6, r26	; 0x06
    1536:	bf 83       	std	Y+7, r27	; 0x07
    1538:	8d e9       	ldi	r24, 0x9D	; 157
    153a:	92 e0       	ldi	r25, 0x02	; 2
    153c:	99 83       	std	Y+1, r25	; 0x01
    153e:	88 83       	st	Y, r24
    1540:	1f 8a       	std	Y+23, r1	; 0x17
    1542:	1e 8a       	std	Y+22, r1	; 0x16
    1544:	19 8e       	std	Y+25, r1	; 0x19
    1546:	18 8e       	std	Y+24, r1	; 0x18
    1548:	1b 8e       	std	Y+27, r1	; 0x1b
    154a:	1a 8e       	std	Y+26, r1	; 0x1a
    154c:	1d 8e       	std	Y+29, r1	; 0x1d
    154e:	1c 8e       	std	Y+28, r1	; 0x1c
    1550:	8e 8d       	ldd	r24, Y+30	; 0x1e
    1552:	8e 7f       	andi	r24, 0xFE	; 254
    1554:	20 fb       	bst	r18, 0
    1556:	81 f9       	bld	r24, 1
    1558:	8e 8f       	std	Y+30, r24	; 0x1e
    155a:	64 2f       	mov	r22, r20
    155c:	ce 01       	movw	r24, r28
    155e:	0e 94 3b 0a 	call	0x1476	; 0x1476 <_ZN14SoftwareSerial5setTXEh>
    1562:	61 2f       	mov	r22, r17
    1564:	ce 01       	movw	r24, r28
    1566:	df 91       	pop	r29
    1568:	cf 91       	pop	r28
    156a:	1f 91       	pop	r17
    156c:	0c 94 64 0a 	jmp	0x14c8	; 0x14c8 <_ZN14SoftwareSerial5setRXEh>

00001570 <_ZN14SoftwareSerial5beginEl>:
//
// Public methods
//

void SoftwareSerial::begin(long speed)
{
    1570:	cf 93       	push	r28
    1572:	df 93       	push	r29
    1574:	ec 01       	movw	r28, r24
    1576:	9a 01       	movw	r18, r20
    1578:	ab 01       	movw	r20, r22
  _rx_delay_centering = _rx_delay_intrabit = _rx_delay_stopbit = _tx_delay = 0;
    157a:	1b 8e       	std	Y+27, r1	; 0x1b
    157c:	1a 8e       	std	Y+26, r1	; 0x1a
    157e:	19 8e       	std	Y+25, r1	; 0x19
    1580:	18 8e       	std	Y+24, r1	; 0x18
    1582:	1f 8a       	std	Y+23, r1	; 0x17
    1584:	1e 8a       	std	Y+22, r1	; 0x16

  // Precalculate the various delays, in number of 4-cycle delays
  uint16_t bit_delay = (F_CPU / speed) / 4;
    1586:	60 e0       	ldi	r22, 0x00	; 0
    1588:	79 e0       	ldi	r23, 0x09	; 9
    158a:	8d e3       	ldi	r24, 0x3D	; 61
    158c:	90 e0       	ldi	r25, 0x00	; 0
    158e:	0e 94 d0 1f 	call	0x3fa0	; 0x3fa0 <__divmodsi4>
    1592:	f9 01       	movw	r30, r18
  uint8_t port = digitalPinToPort(rx);
  _receivePortRegister = portInputRegister(port);
}

uint16_t SoftwareSerial::subtract_cap(uint16_t num, uint16_t sub) {
  if (num > sub)
    1594:	24 30       	cpi	r18, 0x04	; 4
    1596:	31 05       	cpc	r19, r1
    1598:	18 f0       	brcs	.+6      	; 0x15a0 <_ZN14SoftwareSerial5beginEl+0x30>
    return num - sub;
    159a:	c9 01       	movw	r24, r18
    159c:	03 97       	sbiw	r24, 0x03	; 3
    159e:	02 c0       	rjmp	.+4      	; 0x15a4 <_ZN14SoftwareSerial5beginEl+0x34>
  else
    return 1;
    15a0:	81 e0       	ldi	r24, 0x01	; 1
    15a2:	90 e0       	ldi	r25, 0x00	; 0
  // 12 (gcc 4.8.2) or 13 (gcc 4.3.2) cycles from start bit to first bit,
  // 15 (gcc 4.8.2) or 16 (gcc 4.3.2) cycles between bits,
  // 12 (gcc 4.8.2) or 14 (gcc 4.3.2) cycles from last bit to stop bit
  // These are all close enough to just use 15 cycles, since the inter-bit
  // timings are the most critical (deviations stack 8 times)
  _tx_delay = subtract_cap(bit_delay, 15 / 4);
    15a4:	9d 8f       	std	Y+29, r25	; 0x1d
    15a6:	8c 8f       	std	Y+28, r24	; 0x1c

  // Only setup rx when we have a valid PCINT for this pin
  if (digitalPinToPCICR(_receivePin)) {
    15a8:	6c 85       	ldd	r22, Y+12	; 0x0c
    15aa:	66 31       	cpi	r22, 0x16	; 22
    15ac:	08 f0       	brcs	.+2      	; 0x15b0 <_ZN14SoftwareSerial5beginEl+0x40>
    15ae:	69 c0       	rjmp	.+210    	; 0x1682 <_ZN14SoftwareSerial5beginEl+0x112>
    // are 17 more cycles until the pin value is read (excluding the
    // delay in the loop).
    // We want to have a total delay of 1.5 bit time. Inside the loop,
    // we already wait for 1 bit time - 23 cycles, so here we wait for
    // 0.5 bit time - (71 + 18 - 22) cycles.
    _rx_delay_centering = subtract_cap(bit_delay / 2, (4 + 4 + 75 + 17 - 23) / 4);
    15b0:	c9 01       	movw	r24, r18
    15b2:	96 95       	lsr	r25
    15b4:	87 95       	ror	r24
  uint8_t port = digitalPinToPort(rx);
  _receivePortRegister = portInputRegister(port);
}

uint16_t SoftwareSerial::subtract_cap(uint16_t num, uint16_t sub) {
  if (num > sub)
    15b6:	84 31       	cpi	r24, 0x14	; 20
    15b8:	91 05       	cpc	r25, r1
    15ba:	10 f0       	brcs	.+4      	; 0x15c0 <_ZN14SoftwareSerial5beginEl+0x50>
    return num - sub;
    15bc:	43 97       	sbiw	r24, 0x13	; 19
    15be:	02 c0       	rjmp	.+4      	; 0x15c4 <_ZN14SoftwareSerial5beginEl+0x54>
  else
    return 1;
    15c0:	81 e0       	ldi	r24, 0x01	; 1
    15c2:	90 e0       	ldi	r25, 0x00	; 0
    // are 17 more cycles until the pin value is read (excluding the
    // delay in the loop).
    // We want to have a total delay of 1.5 bit time. Inside the loop,
    // we already wait for 1 bit time - 23 cycles, so here we wait for
    // 0.5 bit time - (71 + 18 - 22) cycles.
    _rx_delay_centering = subtract_cap(bit_delay / 2, (4 + 4 + 75 + 17 - 23) / 4);
    15c4:	9f 8b       	std	Y+23, r25	; 0x17
    15c6:	8e 8b       	std	Y+22, r24	; 0x16
  uint8_t port = digitalPinToPort(rx);
  _receivePortRegister = portInputRegister(port);
}

uint16_t SoftwareSerial::subtract_cap(uint16_t num, uint16_t sub) {
  if (num > sub)
    15c8:	36 97       	sbiw	r30, 0x06	; 6
    15ca:	18 f0       	brcs	.+6      	; 0x15d2 <_ZN14SoftwareSerial5beginEl+0x62>
    return num - sub;
    15cc:	c9 01       	movw	r24, r18
    15ce:	05 97       	sbiw	r24, 0x05	; 5
    15d0:	02 c0       	rjmp	.+4      	; 0x15d6 <_ZN14SoftwareSerial5beginEl+0x66>
  else
    return 1;
    15d2:	81 e0       	ldi	r24, 0x01	; 1
    15d4:	90 e0       	ldi	r25, 0x00	; 0
    // we already wait for 1 bit time - 23 cycles, so here we wait for
    // 0.5 bit time - (71 + 18 - 22) cycles.
    _rx_delay_centering = subtract_cap(bit_delay / 2, (4 + 4 + 75 + 17 - 23) / 4);

    // There are 23 cycles in each loop iteration (excluding the delay)
    _rx_delay_intrabit = subtract_cap(bit_delay, 23 / 4);
    15d6:	99 8f       	std	Y+25, r25	; 0x19
    15d8:	88 8f       	std	Y+24, r24	; 0x18
    // mask is enabled again (which _must_ happen during the stopbit).
    // This delay aims at 3/4 of a bit time, meaning the end of the
    // delay will be at 1/4th of the stopbit. This allows some extra
    // time for ISR cleanup, which makes 115200 baud at 16Mhz work more
    // reliably
    _rx_delay_stopbit = subtract_cap(bit_delay * 3 / 4, (37 + 11) / 4);
    15da:	c9 01       	movw	r24, r18
    15dc:	88 0f       	add	r24, r24
    15de:	99 1f       	adc	r25, r25
    15e0:	28 0f       	add	r18, r24
    15e2:	39 1f       	adc	r19, r25
    15e4:	36 95       	lsr	r19
    15e6:	27 95       	ror	r18
    15e8:	36 95       	lsr	r19
    15ea:	27 95       	ror	r18
  uint8_t port = digitalPinToPort(rx);
  _receivePortRegister = portInputRegister(port);
}

uint16_t SoftwareSerial::subtract_cap(uint16_t num, uint16_t sub) {
  if (num > sub)
    15ec:	2d 30       	cpi	r18, 0x0D	; 13
    15ee:	31 05       	cpc	r19, r1
    15f0:	18 f0       	brcs	.+6      	; 0x15f8 <_ZN14SoftwareSerial5beginEl+0x88>
    return num - sub;
    15f2:	2c 50       	subi	r18, 0x0C	; 12
    15f4:	31 09       	sbc	r19, r1
    15f6:	02 c0       	rjmp	.+4      	; 0x15fc <_ZN14SoftwareSerial5beginEl+0x8c>
  else
    return 1;
    15f8:	21 e0       	ldi	r18, 0x01	; 1
    15fa:	30 e0       	ldi	r19, 0x00	; 0
    // mask is enabled again (which _must_ happen during the stopbit).
    // This delay aims at 3/4 of a bit time, meaning the end of the
    // delay will be at 1/4th of the stopbit. This allows some extra
    // time for ISR cleanup, which makes 115200 baud at 16Mhz work more
    // reliably
    _rx_delay_stopbit = subtract_cap(bit_delay * 3 / 4, (37 + 11) / 4);
    15fc:	3b 8f       	std	Y+27, r19	; 0x1b
    15fe:	2a 8f       	std	Y+26, r18	; 0x1a


    // Enable the PCINT for the entire port here, but never disable it
    // (others might also need it, so we disable the interrupt by using
    // the per-pin PCMSK register).
    *digitalPinToPCICR(_receivePin) |= _BV(digitalPinToPCICRbit(_receivePin));
    1600:	90 91 68 00 	lds	r25, 0x0068	; 0x800068 <__DATA_REGION_ORIGIN__+0x8>
    1604:	68 30       	cpi	r22, 0x08	; 8
    1606:	50 f0       	brcs	.+20     	; 0x161c <_ZN14SoftwareSerial5beginEl+0xac>
    1608:	21 e0       	ldi	r18, 0x01	; 1
    160a:	6e 30       	cpi	r22, 0x0E	; 14
    160c:	08 f4       	brcc	.+2      	; 0x1610 <_ZN14SoftwareSerial5beginEl+0xa0>
    160e:	20 e0       	ldi	r18, 0x00	; 0
    1610:	81 e0       	ldi	r24, 0x01	; 1
    1612:	01 c0       	rjmp	.+2      	; 0x1616 <_ZN14SoftwareSerial5beginEl+0xa6>
    1614:	88 0f       	add	r24, r24
    1616:	2a 95       	dec	r18
    1618:	ea f7       	brpl	.-6      	; 0x1614 <_ZN14SoftwareSerial5beginEl+0xa4>
    161a:	01 c0       	rjmp	.+2      	; 0x161e <_ZN14SoftwareSerial5beginEl+0xae>
    161c:	84 e0       	ldi	r24, 0x04	; 4
    161e:	89 2b       	or	r24, r25
    1620:	80 93 68 00 	sts	0x0068, r24	; 0x800068 <__DATA_REGION_ORIGIN__+0x8>
    // Precalculate the pcint mask register and value, so setRxIntMask
    // can be used inside the ISR without costing too much time.
    _pcint_maskreg = digitalPinToPCMSK(_receivePin);
    1624:	9c 85       	ldd	r25, Y+12	; 0x0c
    1626:	98 30       	cpi	r25, 0x08	; 8
    1628:	38 f0       	brcs	.+14     	; 0x1638 <_ZN14SoftwareSerial5beginEl+0xc8>
    162a:	9e 30       	cpi	r25, 0x0E	; 14
    162c:	40 f0       	brcs	.+16     	; 0x163e <_ZN14SoftwareSerial5beginEl+0xce>
    162e:	96 31       	cpi	r25, 0x16	; 22
    1630:	48 f0       	brcs	.+18     	; 0x1644 <_ZN14SoftwareSerial5beginEl+0xd4>
    1632:	20 e0       	ldi	r18, 0x00	; 0
    1634:	30 e0       	ldi	r19, 0x00	; 0
    1636:	08 c0       	rjmp	.+16     	; 0x1648 <_ZN14SoftwareSerial5beginEl+0xd8>
    1638:	2d e6       	ldi	r18, 0x6D	; 109
    163a:	30 e0       	ldi	r19, 0x00	; 0
    163c:	05 c0       	rjmp	.+10     	; 0x1648 <_ZN14SoftwareSerial5beginEl+0xd8>
    163e:	2b e6       	ldi	r18, 0x6B	; 107
    1640:	30 e0       	ldi	r19, 0x00	; 0
    1642:	02 c0       	rjmp	.+4      	; 0x1648 <_ZN14SoftwareSerial5beginEl+0xd8>
    1644:	2c e6       	ldi	r18, 0x6C	; 108
    1646:	30 e0       	ldi	r19, 0x00	; 0
    1648:	3c 8b       	std	Y+20, r19	; 0x14
    164a:	2b 8b       	std	Y+19, r18	; 0x13
    _pcint_maskvalue = _BV(digitalPinToPCMSKbit(_receivePin));
    164c:	98 30       	cpi	r25, 0x08	; 8
    164e:	30 f4       	brcc	.+12     	; 0x165c <_ZN14SoftwareSerial5beginEl+0xec>
    1650:	81 e0       	ldi	r24, 0x01	; 1
    1652:	01 c0       	rjmp	.+2      	; 0x1656 <_ZN14SoftwareSerial5beginEl+0xe6>
    1654:	88 0f       	add	r24, r24
    1656:	9a 95       	dec	r25
    1658:	ea f7       	brpl	.-6      	; 0x1654 <_ZN14SoftwareSerial5beginEl+0xe4>
    165a:	0e c0       	rjmp	.+28     	; 0x1678 <_ZN14SoftwareSerial5beginEl+0x108>
    165c:	29 2f       	mov	r18, r25
    165e:	30 e0       	ldi	r19, 0x00	; 0
    1660:	9e 30       	cpi	r25, 0x0E	; 14
    1662:	18 f4       	brcc	.+6      	; 0x166a <_ZN14SoftwareSerial5beginEl+0xfa>
    1664:	28 50       	subi	r18, 0x08	; 8
    1666:	31 09       	sbc	r19, r1
    1668:	02 c0       	rjmp	.+4      	; 0x166e <_ZN14SoftwareSerial5beginEl+0xfe>
    166a:	2e 50       	subi	r18, 0x0E	; 14
    166c:	31 09       	sbc	r19, r1
    166e:	81 e0       	ldi	r24, 0x01	; 1
    1670:	01 c0       	rjmp	.+2      	; 0x1674 <_ZN14SoftwareSerial5beginEl+0x104>
    1672:	88 0f       	add	r24, r24
    1674:	2a 95       	dec	r18
    1676:	ea f7       	brpl	.-6      	; 0x1672 <_ZN14SoftwareSerial5beginEl+0x102>
    1678:	8d 8b       	std	Y+21, r24	; 0x15
	__asm__ volatile (
		"1: sbiw %0,1" "\n\t"
		"brne 1b"
		: "=w" (__count)
		: "0" (__count)
	);
    167a:	8c 8d       	ldd	r24, Y+28	; 0x1c
    167c:	9d 8d       	ldd	r25, Y+29	; 0x1d
    167e:	01 97       	sbiw	r24, 0x01	; 1
    1680:	f1 f7       	brne	.-4      	; 0x167e <_ZN14SoftwareSerial5beginEl+0x10e>
#if _DEBUG
  pinMode(_DEBUG_PIN1, OUTPUT);
  pinMode(_DEBUG_PIN2, OUTPUT);
#endif

  listen();
    1682:	ce 01       	movw	r24, r28
}
    1684:	df 91       	pop	r29
    1686:	cf 91       	pop	r28
#if _DEBUG
  pinMode(_DEBUG_PIN1, OUTPUT);
  pinMode(_DEBUG_PIN2, OUTPUT);
#endif

  listen();
    1688:	0c 94 91 09 	jmp	0x1322	; 0x1322 <_ZN14SoftwareSerial6listenEv>

0000168c <__subsf3>:
    168c:	50 58       	subi	r21, 0x80	; 128

0000168e <__addsf3>:
    168e:	bb 27       	eor	r27, r27
    1690:	aa 27       	eor	r26, r26
    1692:	0e 94 5e 0b 	call	0x16bc	; 0x16bc <__addsf3x>
    1696:	0c 94 d8 0c 	jmp	0x19b0	; 0x19b0 <__fp_round>
    169a:	0e 94 ca 0c 	call	0x1994	; 0x1994 <__fp_pscA>
    169e:	38 f0       	brcs	.+14     	; 0x16ae <__addsf3+0x20>
    16a0:	0e 94 d1 0c 	call	0x19a2	; 0x19a2 <__fp_pscB>
    16a4:	20 f0       	brcs	.+8      	; 0x16ae <__addsf3+0x20>
    16a6:	39 f4       	brne	.+14     	; 0x16b6 <__addsf3+0x28>
    16a8:	9f 3f       	cpi	r25, 0xFF	; 255
    16aa:	19 f4       	brne	.+6      	; 0x16b2 <__addsf3+0x24>
    16ac:	26 f4       	brtc	.+8      	; 0x16b6 <__addsf3+0x28>
    16ae:	0c 94 c7 0c 	jmp	0x198e	; 0x198e <__fp_nan>
    16b2:	0e f4       	brtc	.+2      	; 0x16b6 <__addsf3+0x28>
    16b4:	e0 95       	com	r30
    16b6:	e7 fb       	bst	r30, 7
    16b8:	0c 94 c1 0c 	jmp	0x1982	; 0x1982 <__fp_inf>

000016bc <__addsf3x>:
    16bc:	e9 2f       	mov	r30, r25
    16be:	0e 94 e9 0c 	call	0x19d2	; 0x19d2 <__fp_split3>
    16c2:	58 f3       	brcs	.-42     	; 0x169a <__addsf3+0xc>
    16c4:	ba 17       	cp	r27, r26
    16c6:	62 07       	cpc	r22, r18
    16c8:	73 07       	cpc	r23, r19
    16ca:	84 07       	cpc	r24, r20
    16cc:	95 07       	cpc	r25, r21
    16ce:	20 f0       	brcs	.+8      	; 0x16d8 <__addsf3x+0x1c>
    16d0:	79 f4       	brne	.+30     	; 0x16f0 <__addsf3x+0x34>
    16d2:	a6 f5       	brtc	.+104    	; 0x173c <__addsf3x+0x80>
    16d4:	0c 94 0b 0d 	jmp	0x1a16	; 0x1a16 <__fp_zero>
    16d8:	0e f4       	brtc	.+2      	; 0x16dc <__addsf3x+0x20>
    16da:	e0 95       	com	r30
    16dc:	0b 2e       	mov	r0, r27
    16de:	ba 2f       	mov	r27, r26
    16e0:	a0 2d       	mov	r26, r0
    16e2:	0b 01       	movw	r0, r22
    16e4:	b9 01       	movw	r22, r18
    16e6:	90 01       	movw	r18, r0
    16e8:	0c 01       	movw	r0, r24
    16ea:	ca 01       	movw	r24, r20
    16ec:	a0 01       	movw	r20, r0
    16ee:	11 24       	eor	r1, r1
    16f0:	ff 27       	eor	r31, r31
    16f2:	59 1b       	sub	r21, r25
    16f4:	99 f0       	breq	.+38     	; 0x171c <__addsf3x+0x60>
    16f6:	59 3f       	cpi	r21, 0xF9	; 249
    16f8:	50 f4       	brcc	.+20     	; 0x170e <__addsf3x+0x52>
    16fa:	50 3e       	cpi	r21, 0xE0	; 224
    16fc:	68 f1       	brcs	.+90     	; 0x1758 <__addsf3x+0x9c>
    16fe:	1a 16       	cp	r1, r26
    1700:	f0 40       	sbci	r31, 0x00	; 0
    1702:	a2 2f       	mov	r26, r18
    1704:	23 2f       	mov	r18, r19
    1706:	34 2f       	mov	r19, r20
    1708:	44 27       	eor	r20, r20
    170a:	58 5f       	subi	r21, 0xF8	; 248
    170c:	f3 cf       	rjmp	.-26     	; 0x16f4 <__addsf3x+0x38>
    170e:	46 95       	lsr	r20
    1710:	37 95       	ror	r19
    1712:	27 95       	ror	r18
    1714:	a7 95       	ror	r26
    1716:	f0 40       	sbci	r31, 0x00	; 0
    1718:	53 95       	inc	r21
    171a:	c9 f7       	brne	.-14     	; 0x170e <__addsf3x+0x52>
    171c:	7e f4       	brtc	.+30     	; 0x173c <__addsf3x+0x80>
    171e:	1f 16       	cp	r1, r31
    1720:	ba 0b       	sbc	r27, r26
    1722:	62 0b       	sbc	r22, r18
    1724:	73 0b       	sbc	r23, r19
    1726:	84 0b       	sbc	r24, r20
    1728:	ba f0       	brmi	.+46     	; 0x1758 <__addsf3x+0x9c>
    172a:	91 50       	subi	r25, 0x01	; 1
    172c:	a1 f0       	breq	.+40     	; 0x1756 <__addsf3x+0x9a>
    172e:	ff 0f       	add	r31, r31
    1730:	bb 1f       	adc	r27, r27
    1732:	66 1f       	adc	r22, r22
    1734:	77 1f       	adc	r23, r23
    1736:	88 1f       	adc	r24, r24
    1738:	c2 f7       	brpl	.-16     	; 0x172a <__addsf3x+0x6e>
    173a:	0e c0       	rjmp	.+28     	; 0x1758 <__addsf3x+0x9c>
    173c:	ba 0f       	add	r27, r26
    173e:	62 1f       	adc	r22, r18
    1740:	73 1f       	adc	r23, r19
    1742:	84 1f       	adc	r24, r20
    1744:	48 f4       	brcc	.+18     	; 0x1758 <__addsf3x+0x9c>
    1746:	87 95       	ror	r24
    1748:	77 95       	ror	r23
    174a:	67 95       	ror	r22
    174c:	b7 95       	ror	r27
    174e:	f7 95       	ror	r31
    1750:	9e 3f       	cpi	r25, 0xFE	; 254
    1752:	08 f0       	brcs	.+2      	; 0x1756 <__addsf3x+0x9a>
    1754:	b0 cf       	rjmp	.-160    	; 0x16b6 <__addsf3+0x28>
    1756:	93 95       	inc	r25
    1758:	88 0f       	add	r24, r24
    175a:	08 f0       	brcs	.+2      	; 0x175e <__addsf3x+0xa2>
    175c:	99 27       	eor	r25, r25
    175e:	ee 0f       	add	r30, r30
    1760:	97 95       	ror	r25
    1762:	87 95       	ror	r24
    1764:	08 95       	ret

00001766 <__cmpsf2>:
    1766:	0e 94 9d 0c 	call	0x193a	; 0x193a <__fp_cmp>
    176a:	08 f4       	brcc	.+2      	; 0x176e <__cmpsf2+0x8>
    176c:	81 e0       	ldi	r24, 0x01	; 1
    176e:	08 95       	ret

00001770 <__divsf3>:
    1770:	0e 94 cc 0b 	call	0x1798	; 0x1798 <__divsf3x>
    1774:	0c 94 d8 0c 	jmp	0x19b0	; 0x19b0 <__fp_round>
    1778:	0e 94 d1 0c 	call	0x19a2	; 0x19a2 <__fp_pscB>
    177c:	58 f0       	brcs	.+22     	; 0x1794 <__divsf3+0x24>
    177e:	0e 94 ca 0c 	call	0x1994	; 0x1994 <__fp_pscA>
    1782:	40 f0       	brcs	.+16     	; 0x1794 <__divsf3+0x24>
    1784:	29 f4       	brne	.+10     	; 0x1790 <__divsf3+0x20>
    1786:	5f 3f       	cpi	r21, 0xFF	; 255
    1788:	29 f0       	breq	.+10     	; 0x1794 <__divsf3+0x24>
    178a:	0c 94 c1 0c 	jmp	0x1982	; 0x1982 <__fp_inf>
    178e:	51 11       	cpse	r21, r1
    1790:	0c 94 0c 0d 	jmp	0x1a18	; 0x1a18 <__fp_szero>
    1794:	0c 94 c7 0c 	jmp	0x198e	; 0x198e <__fp_nan>

00001798 <__divsf3x>:
    1798:	0e 94 e9 0c 	call	0x19d2	; 0x19d2 <__fp_split3>
    179c:	68 f3       	brcs	.-38     	; 0x1778 <__divsf3+0x8>

0000179e <__divsf3_pse>:
    179e:	99 23       	and	r25, r25
    17a0:	b1 f3       	breq	.-20     	; 0x178e <__divsf3+0x1e>
    17a2:	55 23       	and	r21, r21
    17a4:	91 f3       	breq	.-28     	; 0x178a <__divsf3+0x1a>
    17a6:	95 1b       	sub	r25, r21
    17a8:	55 0b       	sbc	r21, r21
    17aa:	bb 27       	eor	r27, r27
    17ac:	aa 27       	eor	r26, r26
    17ae:	62 17       	cp	r22, r18
    17b0:	73 07       	cpc	r23, r19
    17b2:	84 07       	cpc	r24, r20
    17b4:	38 f0       	brcs	.+14     	; 0x17c4 <__divsf3_pse+0x26>
    17b6:	9f 5f       	subi	r25, 0xFF	; 255
    17b8:	5f 4f       	sbci	r21, 0xFF	; 255
    17ba:	22 0f       	add	r18, r18
    17bc:	33 1f       	adc	r19, r19
    17be:	44 1f       	adc	r20, r20
    17c0:	aa 1f       	adc	r26, r26
    17c2:	a9 f3       	breq	.-22     	; 0x17ae <__divsf3_pse+0x10>
    17c4:	35 d0       	rcall	.+106    	; 0x1830 <__divsf3_pse+0x92>
    17c6:	0e 2e       	mov	r0, r30
    17c8:	3a f0       	brmi	.+14     	; 0x17d8 <__divsf3_pse+0x3a>
    17ca:	e0 e8       	ldi	r30, 0x80	; 128
    17cc:	32 d0       	rcall	.+100    	; 0x1832 <__divsf3_pse+0x94>
    17ce:	91 50       	subi	r25, 0x01	; 1
    17d0:	50 40       	sbci	r21, 0x00	; 0
    17d2:	e6 95       	lsr	r30
    17d4:	00 1c       	adc	r0, r0
    17d6:	ca f7       	brpl	.-14     	; 0x17ca <__divsf3_pse+0x2c>
    17d8:	2b d0       	rcall	.+86     	; 0x1830 <__divsf3_pse+0x92>
    17da:	fe 2f       	mov	r31, r30
    17dc:	29 d0       	rcall	.+82     	; 0x1830 <__divsf3_pse+0x92>
    17de:	66 0f       	add	r22, r22
    17e0:	77 1f       	adc	r23, r23
    17e2:	88 1f       	adc	r24, r24
    17e4:	bb 1f       	adc	r27, r27
    17e6:	26 17       	cp	r18, r22
    17e8:	37 07       	cpc	r19, r23
    17ea:	48 07       	cpc	r20, r24
    17ec:	ab 07       	cpc	r26, r27
    17ee:	b0 e8       	ldi	r27, 0x80	; 128
    17f0:	09 f0       	breq	.+2      	; 0x17f4 <__divsf3_pse+0x56>
    17f2:	bb 0b       	sbc	r27, r27
    17f4:	80 2d       	mov	r24, r0
    17f6:	bf 01       	movw	r22, r30
    17f8:	ff 27       	eor	r31, r31
    17fa:	93 58       	subi	r25, 0x83	; 131
    17fc:	5f 4f       	sbci	r21, 0xFF	; 255
    17fe:	3a f0       	brmi	.+14     	; 0x180e <__divsf3_pse+0x70>
    1800:	9e 3f       	cpi	r25, 0xFE	; 254
    1802:	51 05       	cpc	r21, r1
    1804:	78 f0       	brcs	.+30     	; 0x1824 <__divsf3_pse+0x86>
    1806:	0c 94 c1 0c 	jmp	0x1982	; 0x1982 <__fp_inf>
    180a:	0c 94 0c 0d 	jmp	0x1a18	; 0x1a18 <__fp_szero>
    180e:	5f 3f       	cpi	r21, 0xFF	; 255
    1810:	e4 f3       	brlt	.-8      	; 0x180a <__divsf3_pse+0x6c>
    1812:	98 3e       	cpi	r25, 0xE8	; 232
    1814:	d4 f3       	brlt	.-12     	; 0x180a <__divsf3_pse+0x6c>
    1816:	86 95       	lsr	r24
    1818:	77 95       	ror	r23
    181a:	67 95       	ror	r22
    181c:	b7 95       	ror	r27
    181e:	f7 95       	ror	r31
    1820:	9f 5f       	subi	r25, 0xFF	; 255
    1822:	c9 f7       	brne	.-14     	; 0x1816 <__divsf3_pse+0x78>
    1824:	88 0f       	add	r24, r24
    1826:	91 1d       	adc	r25, r1
    1828:	96 95       	lsr	r25
    182a:	87 95       	ror	r24
    182c:	97 f9       	bld	r25, 7
    182e:	08 95       	ret
    1830:	e1 e0       	ldi	r30, 0x01	; 1
    1832:	66 0f       	add	r22, r22
    1834:	77 1f       	adc	r23, r23
    1836:	88 1f       	adc	r24, r24
    1838:	bb 1f       	adc	r27, r27
    183a:	62 17       	cp	r22, r18
    183c:	73 07       	cpc	r23, r19
    183e:	84 07       	cpc	r24, r20
    1840:	ba 07       	cpc	r27, r26
    1842:	20 f0       	brcs	.+8      	; 0x184c <__divsf3_pse+0xae>
    1844:	62 1b       	sub	r22, r18
    1846:	73 0b       	sbc	r23, r19
    1848:	84 0b       	sbc	r24, r20
    184a:	ba 0b       	sbc	r27, r26
    184c:	ee 1f       	adc	r30, r30
    184e:	88 f7       	brcc	.-30     	; 0x1832 <__divsf3_pse+0x94>
    1850:	e0 95       	com	r30
    1852:	08 95       	ret

00001854 <__fixsfsi>:
    1854:	0e 94 31 0c 	call	0x1862	; 0x1862 <__fixunssfsi>
    1858:	68 94       	set
    185a:	b1 11       	cpse	r27, r1
    185c:	0c 94 0c 0d 	jmp	0x1a18	; 0x1a18 <__fp_szero>
    1860:	08 95       	ret

00001862 <__fixunssfsi>:
    1862:	0e 94 f1 0c 	call	0x19e2	; 0x19e2 <__fp_splitA>
    1866:	88 f0       	brcs	.+34     	; 0x188a <__fixunssfsi+0x28>
    1868:	9f 57       	subi	r25, 0x7F	; 127
    186a:	98 f0       	brcs	.+38     	; 0x1892 <__fixunssfsi+0x30>
    186c:	b9 2f       	mov	r27, r25
    186e:	99 27       	eor	r25, r25
    1870:	b7 51       	subi	r27, 0x17	; 23
    1872:	b0 f0       	brcs	.+44     	; 0x18a0 <__fixunssfsi+0x3e>
    1874:	e1 f0       	breq	.+56     	; 0x18ae <__fixunssfsi+0x4c>
    1876:	66 0f       	add	r22, r22
    1878:	77 1f       	adc	r23, r23
    187a:	88 1f       	adc	r24, r24
    187c:	99 1f       	adc	r25, r25
    187e:	1a f0       	brmi	.+6      	; 0x1886 <__fixunssfsi+0x24>
    1880:	ba 95       	dec	r27
    1882:	c9 f7       	brne	.-14     	; 0x1876 <__fixunssfsi+0x14>
    1884:	14 c0       	rjmp	.+40     	; 0x18ae <__fixunssfsi+0x4c>
    1886:	b1 30       	cpi	r27, 0x01	; 1
    1888:	91 f0       	breq	.+36     	; 0x18ae <__fixunssfsi+0x4c>
    188a:	0e 94 0b 0d 	call	0x1a16	; 0x1a16 <__fp_zero>
    188e:	b1 e0       	ldi	r27, 0x01	; 1
    1890:	08 95       	ret
    1892:	0c 94 0b 0d 	jmp	0x1a16	; 0x1a16 <__fp_zero>
    1896:	67 2f       	mov	r22, r23
    1898:	78 2f       	mov	r23, r24
    189a:	88 27       	eor	r24, r24
    189c:	b8 5f       	subi	r27, 0xF8	; 248
    189e:	39 f0       	breq	.+14     	; 0x18ae <__fixunssfsi+0x4c>
    18a0:	b9 3f       	cpi	r27, 0xF9	; 249
    18a2:	cc f3       	brlt	.-14     	; 0x1896 <__fixunssfsi+0x34>
    18a4:	86 95       	lsr	r24
    18a6:	77 95       	ror	r23
    18a8:	67 95       	ror	r22
    18aa:	b3 95       	inc	r27
    18ac:	d9 f7       	brne	.-10     	; 0x18a4 <__fixunssfsi+0x42>
    18ae:	3e f4       	brtc	.+14     	; 0x18be <__fixunssfsi+0x5c>
    18b0:	90 95       	com	r25
    18b2:	80 95       	com	r24
    18b4:	70 95       	com	r23
    18b6:	61 95       	neg	r22
    18b8:	7f 4f       	sbci	r23, 0xFF	; 255
    18ba:	8f 4f       	sbci	r24, 0xFF	; 255
    18bc:	9f 4f       	sbci	r25, 0xFF	; 255
    18be:	08 95       	ret

000018c0 <__floatunsisf>:
    18c0:	e8 94       	clt
    18c2:	09 c0       	rjmp	.+18     	; 0x18d6 <__floatsisf+0x12>

000018c4 <__floatsisf>:
    18c4:	97 fb       	bst	r25, 7
    18c6:	3e f4       	brtc	.+14     	; 0x18d6 <__floatsisf+0x12>
    18c8:	90 95       	com	r25
    18ca:	80 95       	com	r24
    18cc:	70 95       	com	r23
    18ce:	61 95       	neg	r22
    18d0:	7f 4f       	sbci	r23, 0xFF	; 255
    18d2:	8f 4f       	sbci	r24, 0xFF	; 255
    18d4:	9f 4f       	sbci	r25, 0xFF	; 255
    18d6:	99 23       	and	r25, r25
    18d8:	a9 f0       	breq	.+42     	; 0x1904 <__floatsisf+0x40>
    18da:	f9 2f       	mov	r31, r25
    18dc:	96 e9       	ldi	r25, 0x96	; 150
    18de:	bb 27       	eor	r27, r27
    18e0:	93 95       	inc	r25
    18e2:	f6 95       	lsr	r31
    18e4:	87 95       	ror	r24
    18e6:	77 95       	ror	r23
    18e8:	67 95       	ror	r22
    18ea:	b7 95       	ror	r27
    18ec:	f1 11       	cpse	r31, r1
    18ee:	f8 cf       	rjmp	.-16     	; 0x18e0 <__floatsisf+0x1c>
    18f0:	fa f4       	brpl	.+62     	; 0x1930 <__floatsisf+0x6c>
    18f2:	bb 0f       	add	r27, r27
    18f4:	11 f4       	brne	.+4      	; 0x18fa <__floatsisf+0x36>
    18f6:	60 ff       	sbrs	r22, 0
    18f8:	1b c0       	rjmp	.+54     	; 0x1930 <__floatsisf+0x6c>
    18fa:	6f 5f       	subi	r22, 0xFF	; 255
    18fc:	7f 4f       	sbci	r23, 0xFF	; 255
    18fe:	8f 4f       	sbci	r24, 0xFF	; 255
    1900:	9f 4f       	sbci	r25, 0xFF	; 255
    1902:	16 c0       	rjmp	.+44     	; 0x1930 <__floatsisf+0x6c>
    1904:	88 23       	and	r24, r24
    1906:	11 f0       	breq	.+4      	; 0x190c <__floatsisf+0x48>
    1908:	96 e9       	ldi	r25, 0x96	; 150
    190a:	11 c0       	rjmp	.+34     	; 0x192e <__floatsisf+0x6a>
    190c:	77 23       	and	r23, r23
    190e:	21 f0       	breq	.+8      	; 0x1918 <__floatsisf+0x54>
    1910:	9e e8       	ldi	r25, 0x8E	; 142
    1912:	87 2f       	mov	r24, r23
    1914:	76 2f       	mov	r23, r22
    1916:	05 c0       	rjmp	.+10     	; 0x1922 <__floatsisf+0x5e>
    1918:	66 23       	and	r22, r22
    191a:	71 f0       	breq	.+28     	; 0x1938 <__floatsisf+0x74>
    191c:	96 e8       	ldi	r25, 0x86	; 134
    191e:	86 2f       	mov	r24, r22
    1920:	70 e0       	ldi	r23, 0x00	; 0
    1922:	60 e0       	ldi	r22, 0x00	; 0
    1924:	2a f0       	brmi	.+10     	; 0x1930 <__floatsisf+0x6c>
    1926:	9a 95       	dec	r25
    1928:	66 0f       	add	r22, r22
    192a:	77 1f       	adc	r23, r23
    192c:	88 1f       	adc	r24, r24
    192e:	da f7       	brpl	.-10     	; 0x1926 <__floatsisf+0x62>
    1930:	88 0f       	add	r24, r24
    1932:	96 95       	lsr	r25
    1934:	87 95       	ror	r24
    1936:	97 f9       	bld	r25, 7
    1938:	08 95       	ret

0000193a <__fp_cmp>:
    193a:	99 0f       	add	r25, r25
    193c:	00 08       	sbc	r0, r0
    193e:	55 0f       	add	r21, r21
    1940:	aa 0b       	sbc	r26, r26
    1942:	e0 e8       	ldi	r30, 0x80	; 128
    1944:	fe ef       	ldi	r31, 0xFE	; 254
    1946:	16 16       	cp	r1, r22
    1948:	17 06       	cpc	r1, r23
    194a:	e8 07       	cpc	r30, r24
    194c:	f9 07       	cpc	r31, r25
    194e:	c0 f0       	brcs	.+48     	; 0x1980 <__fp_cmp+0x46>
    1950:	12 16       	cp	r1, r18
    1952:	13 06       	cpc	r1, r19
    1954:	e4 07       	cpc	r30, r20
    1956:	f5 07       	cpc	r31, r21
    1958:	98 f0       	brcs	.+38     	; 0x1980 <__fp_cmp+0x46>
    195a:	62 1b       	sub	r22, r18
    195c:	73 0b       	sbc	r23, r19
    195e:	84 0b       	sbc	r24, r20
    1960:	95 0b       	sbc	r25, r21
    1962:	39 f4       	brne	.+14     	; 0x1972 <__fp_cmp+0x38>
    1964:	0a 26       	eor	r0, r26
    1966:	61 f0       	breq	.+24     	; 0x1980 <__fp_cmp+0x46>
    1968:	23 2b       	or	r18, r19
    196a:	24 2b       	or	r18, r20
    196c:	25 2b       	or	r18, r21
    196e:	21 f4       	brne	.+8      	; 0x1978 <__fp_cmp+0x3e>
    1970:	08 95       	ret
    1972:	0a 26       	eor	r0, r26
    1974:	09 f4       	brne	.+2      	; 0x1978 <__fp_cmp+0x3e>
    1976:	a1 40       	sbci	r26, 0x01	; 1
    1978:	a6 95       	lsr	r26
    197a:	8f ef       	ldi	r24, 0xFF	; 255
    197c:	81 1d       	adc	r24, r1
    197e:	81 1d       	adc	r24, r1
    1980:	08 95       	ret

00001982 <__fp_inf>:
    1982:	97 f9       	bld	r25, 7
    1984:	9f 67       	ori	r25, 0x7F	; 127
    1986:	80 e8       	ldi	r24, 0x80	; 128
    1988:	70 e0       	ldi	r23, 0x00	; 0
    198a:	60 e0       	ldi	r22, 0x00	; 0
    198c:	08 95       	ret

0000198e <__fp_nan>:
    198e:	9f ef       	ldi	r25, 0xFF	; 255
    1990:	80 ec       	ldi	r24, 0xC0	; 192
    1992:	08 95       	ret

00001994 <__fp_pscA>:
    1994:	00 24       	eor	r0, r0
    1996:	0a 94       	dec	r0
    1998:	16 16       	cp	r1, r22
    199a:	17 06       	cpc	r1, r23
    199c:	18 06       	cpc	r1, r24
    199e:	09 06       	cpc	r0, r25
    19a0:	08 95       	ret

000019a2 <__fp_pscB>:
    19a2:	00 24       	eor	r0, r0
    19a4:	0a 94       	dec	r0
    19a6:	12 16       	cp	r1, r18
    19a8:	13 06       	cpc	r1, r19
    19aa:	14 06       	cpc	r1, r20
    19ac:	05 06       	cpc	r0, r21
    19ae:	08 95       	ret

000019b0 <__fp_round>:
    19b0:	09 2e       	mov	r0, r25
    19b2:	03 94       	inc	r0
    19b4:	00 0c       	add	r0, r0
    19b6:	11 f4       	brne	.+4      	; 0x19bc <__fp_round+0xc>
    19b8:	88 23       	and	r24, r24
    19ba:	52 f0       	brmi	.+20     	; 0x19d0 <__fp_round+0x20>
    19bc:	bb 0f       	add	r27, r27
    19be:	40 f4       	brcc	.+16     	; 0x19d0 <__fp_round+0x20>
    19c0:	bf 2b       	or	r27, r31
    19c2:	11 f4       	brne	.+4      	; 0x19c8 <__fp_round+0x18>
    19c4:	60 ff       	sbrs	r22, 0
    19c6:	04 c0       	rjmp	.+8      	; 0x19d0 <__fp_round+0x20>
    19c8:	6f 5f       	subi	r22, 0xFF	; 255
    19ca:	7f 4f       	sbci	r23, 0xFF	; 255
    19cc:	8f 4f       	sbci	r24, 0xFF	; 255
    19ce:	9f 4f       	sbci	r25, 0xFF	; 255
    19d0:	08 95       	ret

000019d2 <__fp_split3>:
    19d2:	57 fd       	sbrc	r21, 7
    19d4:	90 58       	subi	r25, 0x80	; 128
    19d6:	44 0f       	add	r20, r20
    19d8:	55 1f       	adc	r21, r21
    19da:	59 f0       	breq	.+22     	; 0x19f2 <__fp_splitA+0x10>
    19dc:	5f 3f       	cpi	r21, 0xFF	; 255
    19de:	71 f0       	breq	.+28     	; 0x19fc <__fp_splitA+0x1a>
    19e0:	47 95       	ror	r20

000019e2 <__fp_splitA>:
    19e2:	88 0f       	add	r24, r24
    19e4:	97 fb       	bst	r25, 7
    19e6:	99 1f       	adc	r25, r25
    19e8:	61 f0       	breq	.+24     	; 0x1a02 <__fp_splitA+0x20>
    19ea:	9f 3f       	cpi	r25, 0xFF	; 255
    19ec:	79 f0       	breq	.+30     	; 0x1a0c <__fp_splitA+0x2a>
    19ee:	87 95       	ror	r24
    19f0:	08 95       	ret
    19f2:	12 16       	cp	r1, r18
    19f4:	13 06       	cpc	r1, r19
    19f6:	14 06       	cpc	r1, r20
    19f8:	55 1f       	adc	r21, r21
    19fa:	f2 cf       	rjmp	.-28     	; 0x19e0 <__fp_split3+0xe>
    19fc:	46 95       	lsr	r20
    19fe:	f1 df       	rcall	.-30     	; 0x19e2 <__fp_splitA>
    1a00:	08 c0       	rjmp	.+16     	; 0x1a12 <__fp_splitA+0x30>
    1a02:	16 16       	cp	r1, r22
    1a04:	17 06       	cpc	r1, r23
    1a06:	18 06       	cpc	r1, r24
    1a08:	99 1f       	adc	r25, r25
    1a0a:	f1 cf       	rjmp	.-30     	; 0x19ee <__fp_splitA+0xc>
    1a0c:	86 95       	lsr	r24
    1a0e:	71 05       	cpc	r23, r1
    1a10:	61 05       	cpc	r22, r1
    1a12:	08 94       	sec
    1a14:	08 95       	ret

00001a16 <__fp_zero>:
    1a16:	e8 94       	clt

00001a18 <__fp_szero>:
    1a18:	bb 27       	eor	r27, r27
    1a1a:	66 27       	eor	r22, r22
    1a1c:	77 27       	eor	r23, r23
    1a1e:	cb 01       	movw	r24, r22
    1a20:	97 f9       	bld	r25, 7
    1a22:	08 95       	ret

00001a24 <__gesf2>:
    1a24:	0e 94 9d 0c 	call	0x193a	; 0x193a <__fp_cmp>
    1a28:	08 f4       	brcc	.+2      	; 0x1a2c <__gesf2+0x8>
    1a2a:	8f ef       	ldi	r24, 0xFF	; 255
    1a2c:	08 95       	ret

00001a2e <__mulsf3>:
    1a2e:	0e 94 2a 0d 	call	0x1a54	; 0x1a54 <__mulsf3x>
    1a32:	0c 94 d8 0c 	jmp	0x19b0	; 0x19b0 <__fp_round>
    1a36:	0e 94 ca 0c 	call	0x1994	; 0x1994 <__fp_pscA>
    1a3a:	38 f0       	brcs	.+14     	; 0x1a4a <__mulsf3+0x1c>
    1a3c:	0e 94 d1 0c 	call	0x19a2	; 0x19a2 <__fp_pscB>
    1a40:	20 f0       	brcs	.+8      	; 0x1a4a <__mulsf3+0x1c>
    1a42:	95 23       	and	r25, r21
    1a44:	11 f0       	breq	.+4      	; 0x1a4a <__mulsf3+0x1c>
    1a46:	0c 94 c1 0c 	jmp	0x1982	; 0x1982 <__fp_inf>
    1a4a:	0c 94 c7 0c 	jmp	0x198e	; 0x198e <__fp_nan>
    1a4e:	11 24       	eor	r1, r1
    1a50:	0c 94 0c 0d 	jmp	0x1a18	; 0x1a18 <__fp_szero>

00001a54 <__mulsf3x>:
    1a54:	0e 94 e9 0c 	call	0x19d2	; 0x19d2 <__fp_split3>
    1a58:	70 f3       	brcs	.-36     	; 0x1a36 <__mulsf3+0x8>

00001a5a <__mulsf3_pse>:
    1a5a:	95 9f       	mul	r25, r21
    1a5c:	c1 f3       	breq	.-16     	; 0x1a4e <__mulsf3+0x20>
    1a5e:	95 0f       	add	r25, r21
    1a60:	50 e0       	ldi	r21, 0x00	; 0
    1a62:	55 1f       	adc	r21, r21
    1a64:	62 9f       	mul	r22, r18
    1a66:	f0 01       	movw	r30, r0
    1a68:	72 9f       	mul	r23, r18
    1a6a:	bb 27       	eor	r27, r27
    1a6c:	f0 0d       	add	r31, r0
    1a6e:	b1 1d       	adc	r27, r1
    1a70:	63 9f       	mul	r22, r19
    1a72:	aa 27       	eor	r26, r26
    1a74:	f0 0d       	add	r31, r0
    1a76:	b1 1d       	adc	r27, r1
    1a78:	aa 1f       	adc	r26, r26
    1a7a:	64 9f       	mul	r22, r20
    1a7c:	66 27       	eor	r22, r22
    1a7e:	b0 0d       	add	r27, r0
    1a80:	a1 1d       	adc	r26, r1
    1a82:	66 1f       	adc	r22, r22
    1a84:	82 9f       	mul	r24, r18
    1a86:	22 27       	eor	r18, r18
    1a88:	b0 0d       	add	r27, r0
    1a8a:	a1 1d       	adc	r26, r1
    1a8c:	62 1f       	adc	r22, r18
    1a8e:	73 9f       	mul	r23, r19
    1a90:	b0 0d       	add	r27, r0
    1a92:	a1 1d       	adc	r26, r1
    1a94:	62 1f       	adc	r22, r18
    1a96:	83 9f       	mul	r24, r19
    1a98:	a0 0d       	add	r26, r0
    1a9a:	61 1d       	adc	r22, r1
    1a9c:	22 1f       	adc	r18, r18
    1a9e:	74 9f       	mul	r23, r20
    1aa0:	33 27       	eor	r19, r19
    1aa2:	a0 0d       	add	r26, r0
    1aa4:	61 1d       	adc	r22, r1
    1aa6:	23 1f       	adc	r18, r19
    1aa8:	84 9f       	mul	r24, r20
    1aaa:	60 0d       	add	r22, r0
    1aac:	21 1d       	adc	r18, r1
    1aae:	82 2f       	mov	r24, r18
    1ab0:	76 2f       	mov	r23, r22
    1ab2:	6a 2f       	mov	r22, r26
    1ab4:	11 24       	eor	r1, r1
    1ab6:	9f 57       	subi	r25, 0x7F	; 127
    1ab8:	50 40       	sbci	r21, 0x00	; 0
    1aba:	9a f0       	brmi	.+38     	; 0x1ae2 <__mulsf3_pse+0x88>
    1abc:	f1 f0       	breq	.+60     	; 0x1afa <__mulsf3_pse+0xa0>
    1abe:	88 23       	and	r24, r24
    1ac0:	4a f0       	brmi	.+18     	; 0x1ad4 <__mulsf3_pse+0x7a>
    1ac2:	ee 0f       	add	r30, r30
    1ac4:	ff 1f       	adc	r31, r31
    1ac6:	bb 1f       	adc	r27, r27
    1ac8:	66 1f       	adc	r22, r22
    1aca:	77 1f       	adc	r23, r23
    1acc:	88 1f       	adc	r24, r24
    1ace:	91 50       	subi	r25, 0x01	; 1
    1ad0:	50 40       	sbci	r21, 0x00	; 0
    1ad2:	a9 f7       	brne	.-22     	; 0x1abe <__mulsf3_pse+0x64>
    1ad4:	9e 3f       	cpi	r25, 0xFE	; 254
    1ad6:	51 05       	cpc	r21, r1
    1ad8:	80 f0       	brcs	.+32     	; 0x1afa <__mulsf3_pse+0xa0>
    1ada:	0c 94 c1 0c 	jmp	0x1982	; 0x1982 <__fp_inf>
    1ade:	0c 94 0c 0d 	jmp	0x1a18	; 0x1a18 <__fp_szero>
    1ae2:	5f 3f       	cpi	r21, 0xFF	; 255
    1ae4:	e4 f3       	brlt	.-8      	; 0x1ade <__mulsf3_pse+0x84>
    1ae6:	98 3e       	cpi	r25, 0xE8	; 232
    1ae8:	d4 f3       	brlt	.-12     	; 0x1ade <__mulsf3_pse+0x84>
    1aea:	86 95       	lsr	r24
    1aec:	77 95       	ror	r23
    1aee:	67 95       	ror	r22
    1af0:	b7 95       	ror	r27
    1af2:	f7 95       	ror	r31
    1af4:	e7 95       	ror	r30
    1af6:	9f 5f       	subi	r25, 0xFF	; 255
    1af8:	c1 f7       	brne	.-16     	; 0x1aea <__mulsf3_pse+0x90>
    1afa:	fe 2b       	or	r31, r30
    1afc:	88 0f       	add	r24, r24
    1afe:	91 1d       	adc	r25, r1
    1b00:	96 95       	lsr	r25
    1b02:	87 95       	ror	r24
    1b04:	97 f9       	bld	r25, 7
    1b06:	08 95       	ret

00001b08 <_ZN14HardwareSerial9availableEv>:
  // clear any received data
  _rx_buffer_head = _rx_buffer_tail;
}

int HardwareSerial::available(void)
{
    1b08:	fc 01       	movw	r30, r24
  return ((unsigned int)(SERIAL_RX_BUFFER_SIZE + _rx_buffer_head - _rx_buffer_tail)) % SERIAL_RX_BUFFER_SIZE;
    1b0a:	91 8d       	ldd	r25, Z+25	; 0x19
    1b0c:	22 8d       	ldd	r18, Z+26	; 0x1a
    1b0e:	89 2f       	mov	r24, r25
    1b10:	90 e0       	ldi	r25, 0x00	; 0
    1b12:	80 5c       	subi	r24, 0xC0	; 192
    1b14:	9f 4f       	sbci	r25, 0xFF	; 255
    1b16:	82 1b       	sub	r24, r18
    1b18:	91 09       	sbc	r25, r1
}
    1b1a:	8f 73       	andi	r24, 0x3F	; 63
    1b1c:	99 27       	eor	r25, r25
    1b1e:	08 95       	ret

00001b20 <_ZN14HardwareSerial4peekEv>:

int HardwareSerial::peek(void)
{
    1b20:	fc 01       	movw	r30, r24
  if (_rx_buffer_head == _rx_buffer_tail) {
    1b22:	91 8d       	ldd	r25, Z+25	; 0x19
    1b24:	82 8d       	ldd	r24, Z+26	; 0x1a
    1b26:	98 17       	cp	r25, r24
    1b28:	31 f0       	breq	.+12     	; 0x1b36 <_ZN14HardwareSerial4peekEv+0x16>
    return -1;
  } else {
    return _rx_buffer[_rx_buffer_tail];
    1b2a:	82 8d       	ldd	r24, Z+26	; 0x1a
    1b2c:	e8 0f       	add	r30, r24
    1b2e:	f1 1d       	adc	r31, r1
    1b30:	85 8d       	ldd	r24, Z+29	; 0x1d
    1b32:	90 e0       	ldi	r25, 0x00	; 0
    1b34:	08 95       	ret
}

int HardwareSerial::peek(void)
{
  if (_rx_buffer_head == _rx_buffer_tail) {
    return -1;
    1b36:	8f ef       	ldi	r24, 0xFF	; 255
    1b38:	9f ef       	ldi	r25, 0xFF	; 255
  } else {
    return _rx_buffer[_rx_buffer_tail];
  }
}
    1b3a:	08 95       	ret

00001b3c <_ZN14HardwareSerial4readEv>:

int HardwareSerial::read(void)
{
    1b3c:	fc 01       	movw	r30, r24
  // if the head isn't ahead of the tail, we don't have any characters
  if (_rx_buffer_head == _rx_buffer_tail) {
    1b3e:	91 8d       	ldd	r25, Z+25	; 0x19
    1b40:	82 8d       	ldd	r24, Z+26	; 0x1a
    1b42:	98 17       	cp	r25, r24
    1b44:	61 f0       	breq	.+24     	; 0x1b5e <_ZN14HardwareSerial4readEv+0x22>
    return -1;
  } else {
    unsigned char c = _rx_buffer[_rx_buffer_tail];
    1b46:	82 8d       	ldd	r24, Z+26	; 0x1a
    1b48:	df 01       	movw	r26, r30
    1b4a:	a8 0f       	add	r26, r24
    1b4c:	b1 1d       	adc	r27, r1
    1b4e:	5d 96       	adiw	r26, 0x1d	; 29
    1b50:	8c 91       	ld	r24, X
    _rx_buffer_tail = (rx_buffer_index_t)(_rx_buffer_tail + 1) % SERIAL_RX_BUFFER_SIZE;
    1b52:	92 8d       	ldd	r25, Z+26	; 0x1a
    1b54:	9f 5f       	subi	r25, 0xFF	; 255
    1b56:	9f 73       	andi	r25, 0x3F	; 63
    1b58:	92 8f       	std	Z+26, r25	; 0x1a
    return c;
    1b5a:	90 e0       	ldi	r25, 0x00	; 0
    1b5c:	08 95       	ret

int HardwareSerial::read(void)
{
  // if the head isn't ahead of the tail, we don't have any characters
  if (_rx_buffer_head == _rx_buffer_tail) {
    return -1;
    1b5e:	8f ef       	ldi	r24, 0xFF	; 255
    1b60:	9f ef       	ldi	r25, 0xFF	; 255
  } else {
    unsigned char c = _rx_buffer[_rx_buffer_tail];
    _rx_buffer_tail = (rx_buffer_index_t)(_rx_buffer_tail + 1) % SERIAL_RX_BUFFER_SIZE;
    return c;
  }
}
    1b62:	08 95       	ret

00001b64 <_ZN14HardwareSerial17availableForWriteEv>:
{
  tx_buffer_index_t head;
  tx_buffer_index_t tail;

  TX_BUFFER_ATOMIC {
    head = _tx_buffer_head;
    1b64:	fc 01       	movw	r30, r24
    1b66:	53 8d       	ldd	r21, Z+27	; 0x1b
    tail = _tx_buffer_tail;
    1b68:	44 8d       	ldd	r20, Z+28	; 0x1c
    1b6a:	25 2f       	mov	r18, r21
    1b6c:	30 e0       	ldi	r19, 0x00	; 0
    1b6e:	84 2f       	mov	r24, r20
    1b70:	90 e0       	ldi	r25, 0x00	; 0
  }
  if (head >= tail) return SERIAL_TX_BUFFER_SIZE - 1 - head + tail;
    1b72:	82 1b       	sub	r24, r18
    1b74:	93 0b       	sbc	r25, r19
    1b76:	54 17       	cp	r21, r20
    1b78:	10 f0       	brcs	.+4      	; 0x1b7e <_ZN14HardwareSerial17availableForWriteEv+0x1a>
    1b7a:	cf 96       	adiw	r24, 0x3f	; 63
    1b7c:	08 95       	ret
  return tail - head - 1;
    1b7e:	01 97       	sbiw	r24, 0x01	; 1
}
    1b80:	08 95       	ret

00001b82 <_Z14serialEventRunv>:
#endif

void serialEventRun(void)
{
#if defined(HAVE_HWSERIAL0)
  if (Serial0_available && serialEvent && Serial0_available()) serialEvent();
    1b82:	88 eb       	ldi	r24, 0xB8	; 184
    1b84:	9e e0       	ldi	r25, 0x0E	; 14
    1b86:	89 2b       	or	r24, r25
    1b88:	49 f0       	breq	.+18     	; 0x1b9c <_Z14serialEventRunv+0x1a>
    1b8a:	80 e0       	ldi	r24, 0x00	; 0
    1b8c:	90 e0       	ldi	r25, 0x00	; 0
    1b8e:	89 2b       	or	r24, r25
    1b90:	29 f0       	breq	.+10     	; 0x1b9c <_Z14serialEventRunv+0x1a>
    1b92:	0e 94 b8 0e 	call	0x1d70	; 0x1d70 <_Z17Serial0_availablev>
    1b96:	81 11       	cpse	r24, r1
    1b98:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>
    1b9c:	08 95       	ret

00001b9e <_ZN14HardwareSerial17_tx_udr_empty_irqEv>:
#endif

// Actual interrupt handlers //////////////////////////////////////////////////////////////

void HardwareSerial::_tx_udr_empty_irq(void)
{
    1b9e:	fc 01       	movw	r30, r24
  // If interrupts are enabled, there must be more data in the output
  // buffer. Send the next byte
  unsigned char c = _tx_buffer[_tx_buffer_tail];
    1ba0:	84 8d       	ldd	r24, Z+28	; 0x1c
    1ba2:	df 01       	movw	r26, r30
    1ba4:	a8 0f       	add	r26, r24
    1ba6:	b1 1d       	adc	r27, r1
    1ba8:	a3 5a       	subi	r26, 0xA3	; 163
    1baa:	bf 4f       	sbci	r27, 0xFF	; 255
    1bac:	2c 91       	ld	r18, X
  _tx_buffer_tail = (_tx_buffer_tail + 1) % SERIAL_TX_BUFFER_SIZE;
    1bae:	84 8d       	ldd	r24, Z+28	; 0x1c
    1bb0:	90 e0       	ldi	r25, 0x00	; 0
    1bb2:	01 96       	adiw	r24, 0x01	; 1
    1bb4:	8f 73       	andi	r24, 0x3F	; 63
    1bb6:	99 27       	eor	r25, r25
    1bb8:	84 8f       	std	Z+28, r24	; 0x1c

  *_udr = c;
    1bba:	a6 89       	ldd	r26, Z+22	; 0x16
    1bbc:	b7 89       	ldd	r27, Z+23	; 0x17
    1bbe:	2c 93       	st	X, r18
  // location". This makes sure flush() won't return until the bytes
  // actually got written. Other r/w bits are preserved, and zeroes
  // written to the rest.

#ifdef MPCM0
  *_ucsra = ((*_ucsra) & ((1 << U2X0) | (1 << MPCM0))) | (1 << TXC0);
    1bc0:	a0 89       	ldd	r26, Z+16	; 0x10
    1bc2:	b1 89       	ldd	r27, Z+17	; 0x11
    1bc4:	8c 91       	ld	r24, X
    1bc6:	83 70       	andi	r24, 0x03	; 3
    1bc8:	80 64       	ori	r24, 0x40	; 64
    1bca:	8c 93       	st	X, r24
#else
  *_ucsra = ((*_ucsra) & ((1 << U2X0) | (1 << TXC0)));
#endif

  if (_tx_buffer_head == _tx_buffer_tail) {
    1bcc:	93 8d       	ldd	r25, Z+27	; 0x1b
    1bce:	84 8d       	ldd	r24, Z+28	; 0x1c
    1bd0:	98 13       	cpse	r25, r24
    1bd2:	06 c0       	rjmp	.+12     	; 0x1be0 <_ZN14HardwareSerial17_tx_udr_empty_irqEv+0x42>
    // Buffer empty, so disable interrupts
    cbi(*_ucsrb, UDRIE0);
    1bd4:	02 88       	ldd	r0, Z+18	; 0x12
    1bd6:	f3 89       	ldd	r31, Z+19	; 0x13
    1bd8:	e0 2d       	mov	r30, r0
    1bda:	80 81       	ld	r24, Z
    1bdc:	8f 7d       	andi	r24, 0xDF	; 223
    1bde:	80 83       	st	Z, r24
    1be0:	08 95       	ret

00001be2 <_ZN14HardwareSerial5writeEh>:
  // If we get here, nothing is queued anymore (DRIE is disabled) and
  // the hardware finished tranmission (TXC is set).
}

size_t HardwareSerial::write(uint8_t c)
{
    1be2:	ef 92       	push	r14
    1be4:	ff 92       	push	r15
    1be6:	0f 93       	push	r16
    1be8:	1f 93       	push	r17
    1bea:	cf 93       	push	r28
    1bec:	df 93       	push	r29
    1bee:	ec 01       	movw	r28, r24
  _written = true;
    1bf0:	81 e0       	ldi	r24, 0x01	; 1
    1bf2:	88 8f       	std	Y+24, r24	; 0x18
  // If the buffer and the data register is empty, just write the byte
  // to the data register and be done. This shortcut helps
  // significantly improve the effective datarate at high (>
  // 500kbit/s) bitrates, where interrupt overhead becomes a slowdown.
  if (_tx_buffer_head == _tx_buffer_tail && bit_is_set(*_ucsra, UDRE0)) {
    1bf4:	9b 8d       	ldd	r25, Y+27	; 0x1b
    1bf6:	8c 8d       	ldd	r24, Y+28	; 0x1c
    1bf8:	98 13       	cpse	r25, r24
    1bfa:	05 c0       	rjmp	.+10     	; 0x1c06 <_ZN14HardwareSerial5writeEh+0x24>
    1bfc:	e8 89       	ldd	r30, Y+16	; 0x10
    1bfe:	f9 89       	ldd	r31, Y+17	; 0x11
    1c00:	80 81       	ld	r24, Z
    1c02:	85 fd       	sbrc	r24, 5
    1c04:	26 c0       	rjmp	.+76     	; 0x1c52 <_ZN14HardwareSerial5writeEh+0x70>
    1c06:	f6 2e       	mov	r15, r22
      *_ucsra = ((*_ucsra) & ((1 << U2X0) | (1 << TXC0)));
#endif
    }
    return 1;
  }
  tx_buffer_index_t i = (_tx_buffer_head + 1) % SERIAL_TX_BUFFER_SIZE;
    1c08:	0b 8d       	ldd	r16, Y+27	; 0x1b
    1c0a:	10 e0       	ldi	r17, 0x00	; 0
    1c0c:	0f 5f       	subi	r16, 0xFF	; 255
    1c0e:	1f 4f       	sbci	r17, 0xFF	; 255
    1c10:	0f 73       	andi	r16, 0x3F	; 63
    1c12:	11 27       	eor	r17, r17
    1c14:	e0 2e       	mov	r14, r16
	
  // If the output buffer is full, there's nothing for it other than to 
  // wait for the interrupt handler to empty it a bit
  while (i == _tx_buffer_tail) {
    1c16:	8c 8d       	ldd	r24, Y+28	; 0x1c
    1c18:	e8 12       	cpse	r14, r24
    1c1a:	0c c0       	rjmp	.+24     	; 0x1c34 <_ZN14HardwareSerial5writeEh+0x52>
    if (bit_is_clear(SREG, SREG_I)) {
    1c1c:	0f b6       	in	r0, 0x3f	; 63
    1c1e:	07 fc       	sbrc	r0, 7
    1c20:	fa cf       	rjmp	.-12     	; 0x1c16 <_ZN14HardwareSerial5writeEh+0x34>
      // Interrupts are disabled, so we'll have to poll the data
      // register empty flag ourselves. If it is set, pretend an
      // interrupt has happened and call the handler to free up
      // space for us.
      if(bit_is_set(*_ucsra, UDRE0))
    1c22:	e8 89       	ldd	r30, Y+16	; 0x10
    1c24:	f9 89       	ldd	r31, Y+17	; 0x11
    1c26:	80 81       	ld	r24, Z
    1c28:	85 ff       	sbrs	r24, 5
    1c2a:	f5 cf       	rjmp	.-22     	; 0x1c16 <_ZN14HardwareSerial5writeEh+0x34>
	_tx_udr_empty_irq();
    1c2c:	ce 01       	movw	r24, r28
    1c2e:	0e 94 cf 0d 	call	0x1b9e	; 0x1b9e <_ZN14HardwareSerial17_tx_udr_empty_irqEv>
    1c32:	f1 cf       	rjmp	.-30     	; 0x1c16 <_ZN14HardwareSerial5writeEh+0x34>
    } else {
      // nop, the interrupt handler will free up space for us
    }
  }

  _tx_buffer[_tx_buffer_head] = c;
    1c34:	8b 8d       	ldd	r24, Y+27	; 0x1b
    1c36:	fe 01       	movw	r30, r28
    1c38:	e8 0f       	add	r30, r24
    1c3a:	f1 1d       	adc	r31, r1
    1c3c:	e3 5a       	subi	r30, 0xA3	; 163
    1c3e:	ff 4f       	sbci	r31, 0xFF	; 255
    1c40:	f0 82       	st	Z, r15

  // make atomic to prevent execution of ISR between setting the
  // head pointer and setting the interrupt flag resulting in buffer
  // retransmission
  ATOMIC_BLOCK(ATOMIC_RESTORESTATE) {
    1c42:	9f b7       	in	r25, 0x3f	; 63
    return 1;
}

static __inline__ uint8_t __iCliRetVal(void)
{
    cli();
    1c44:	f8 94       	cli
    _tx_buffer_head = i;
    1c46:	0b 8f       	std	Y+27, r16	; 0x1b
    sbi(*_ucsrb, UDRIE0);
    1c48:	ea 89       	ldd	r30, Y+18	; 0x12
    1c4a:	fb 89       	ldd	r31, Y+19	; 0x13
    1c4c:	80 81       	ld	r24, Z
    1c4e:	80 62       	ori	r24, 0x20	; 32
    1c50:	0a c0       	rjmp	.+20     	; 0x1c66 <_ZN14HardwareSerial5writeEh+0x84>
    // So writing UDR must happen first.
    // Writing UDR and clearing TC must be done atomically, otherwise
    // interrupts might delay the TXC clear so the byte written to UDR
    // is transmitted (setting TXC) before clearing TXC. Then TXC will
    // be cleared when no bytes are left, causing flush() to hang
    ATOMIC_BLOCK(ATOMIC_RESTORESTATE) {
    1c52:	9f b7       	in	r25, 0x3f	; 63
    1c54:	f8 94       	cli
      *_udr = c;
    1c56:	ee 89       	ldd	r30, Y+22	; 0x16
    1c58:	ff 89       	ldd	r31, Y+23	; 0x17
    1c5a:	60 83       	st	Z, r22
#ifdef MPCM0
      *_ucsra = ((*_ucsra) & ((1 << U2X0) | (1 << MPCM0))) | (1 << TXC0);
    1c5c:	e8 89       	ldd	r30, Y+16	; 0x10
    1c5e:	f9 89       	ldd	r31, Y+17	; 0x11
    1c60:	80 81       	ld	r24, Z
    1c62:	83 70       	andi	r24, 0x03	; 3
    1c64:	80 64       	ori	r24, 0x40	; 64
    1c66:	80 83       	st	Z, r24
    (void)__s;
}

static __inline__ void __iRestore(const  uint8_t *__s)
{
    SREG = *__s;
    1c68:	9f bf       	out	0x3f, r25	; 63
    _tx_buffer_head = i;
    sbi(*_ucsrb, UDRIE0);
  }
  
  return 1;
}
    1c6a:	81 e0       	ldi	r24, 0x01	; 1
    1c6c:	90 e0       	ldi	r25, 0x00	; 0
    1c6e:	df 91       	pop	r29
    1c70:	cf 91       	pop	r28
    1c72:	1f 91       	pop	r17
    1c74:	0f 91       	pop	r16
    1c76:	ff 90       	pop	r15
    1c78:	ef 90       	pop	r14
    1c7a:	08 95       	ret

00001c7c <_ZN14HardwareSerial5flushEv>:
  if (head >= tail) return SERIAL_TX_BUFFER_SIZE - 1 - head + tail;
  return tail - head - 1;
}

void HardwareSerial::flush()
{
    1c7c:	cf 93       	push	r28
    1c7e:	df 93       	push	r29
    1c80:	ec 01       	movw	r28, r24
  // If we have never written a byte, no need to flush. This special
  // case is needed since there is no way to force the TXC (transmit
  // complete) bit to 1 during initialization
  if (!_written)
    1c82:	88 8d       	ldd	r24, Y+24	; 0x18
    1c84:	88 23       	and	r24, r24
    1c86:	c9 f0       	breq	.+50     	; 0x1cba <_ZN14HardwareSerial5flushEv+0x3e>
    return;

  while (bit_is_set(*_ucsrb, UDRIE0) || bit_is_clear(*_ucsra, TXC0)) {
    1c88:	ea 89       	ldd	r30, Y+18	; 0x12
    1c8a:	fb 89       	ldd	r31, Y+19	; 0x13
    1c8c:	80 81       	ld	r24, Z
    1c8e:	85 fd       	sbrc	r24, 5
    1c90:	05 c0       	rjmp	.+10     	; 0x1c9c <_ZN14HardwareSerial5flushEv+0x20>
    1c92:	a8 89       	ldd	r26, Y+16	; 0x10
    1c94:	b9 89       	ldd	r27, Y+17	; 0x11
    1c96:	8c 91       	ld	r24, X
    1c98:	86 fd       	sbrc	r24, 6
    1c9a:	0f c0       	rjmp	.+30     	; 0x1cba <_ZN14HardwareSerial5flushEv+0x3e>
    if (bit_is_clear(SREG, SREG_I) && bit_is_set(*_ucsrb, UDRIE0))
    1c9c:	0f b6       	in	r0, 0x3f	; 63
    1c9e:	07 fc       	sbrc	r0, 7
    1ca0:	f5 cf       	rjmp	.-22     	; 0x1c8c <_ZN14HardwareSerial5flushEv+0x10>
    1ca2:	80 81       	ld	r24, Z
    1ca4:	85 ff       	sbrs	r24, 5
    1ca6:	f2 cf       	rjmp	.-28     	; 0x1c8c <_ZN14HardwareSerial5flushEv+0x10>
	// Interrupts are globally disabled, but the DR empty
	// interrupt should be enabled, so poll the DR empty flag to
	// prevent deadlock
	if (bit_is_set(*_ucsra, UDRE0))
    1ca8:	a8 89       	ldd	r26, Y+16	; 0x10
    1caa:	b9 89       	ldd	r27, Y+17	; 0x11
    1cac:	8c 91       	ld	r24, X
    1cae:	85 ff       	sbrs	r24, 5
    1cb0:	ed cf       	rjmp	.-38     	; 0x1c8c <_ZN14HardwareSerial5flushEv+0x10>
	  _tx_udr_empty_irq();
    1cb2:	ce 01       	movw	r24, r28
    1cb4:	0e 94 cf 0d 	call	0x1b9e	; 0x1b9e <_ZN14HardwareSerial17_tx_udr_empty_irqEv>
    1cb8:	e7 cf       	rjmp	.-50     	; 0x1c88 <_ZN14HardwareSerial5flushEv+0xc>
  }
  // If we get here, nothing is queued anymore (DRIE is disabled) and
  // the hardware finished tranmission (TXC is set).
}
    1cba:	df 91       	pop	r29
    1cbc:	cf 91       	pop	r28
    1cbe:	08 95       	ret

00001cc0 <__vector_18>:
#elif defined(USART_RXC_vect)
  ISR(USART_RXC_vect) // ATmega8
#else
  #error "Don't know what the Data Received vector is called for Serial"
#endif
  {
    1cc0:	1f 92       	push	r1
    1cc2:	0f 92       	push	r0
    1cc4:	0f b6       	in	r0, 0x3f	; 63
    1cc6:	0f 92       	push	r0
    1cc8:	11 24       	eor	r1, r1
    1cca:	2f 93       	push	r18
    1ccc:	8f 93       	push	r24
    1cce:	9f 93       	push	r25
    1cd0:	ef 93       	push	r30
    1cd2:	ff 93       	push	r31

// Actual interrupt handlers //////////////////////////////////////////////////////////////

void HardwareSerial::_rx_complete_irq(void)
{
  if (bit_is_clear(*_ucsra, UPE0)) {
    1cd4:	e0 91 81 04 	lds	r30, 0x0481	; 0x800481 <Serial+0x10>
    1cd8:	f0 91 82 04 	lds	r31, 0x0482	; 0x800482 <Serial+0x11>
    1cdc:	80 81       	ld	r24, Z
    1cde:	e0 91 87 04 	lds	r30, 0x0487	; 0x800487 <Serial+0x16>
    1ce2:	f0 91 88 04 	lds	r31, 0x0488	; 0x800488 <Serial+0x17>
    1ce6:	82 fd       	sbrc	r24, 2
    1ce8:	12 c0       	rjmp	.+36     	; 0x1d0e <__vector_18+0x4e>
    // No Parity error, read byte and store it in the buffer if there is
    // room
    unsigned char c = *_udr;
    1cea:	90 81       	ld	r25, Z
    rx_buffer_index_t i = (unsigned int)(_rx_buffer_head + 1) % SERIAL_RX_BUFFER_SIZE;
    1cec:	80 91 8a 04 	lds	r24, 0x048A	; 0x80048a <Serial+0x19>
    1cf0:	8f 5f       	subi	r24, 0xFF	; 255
    1cf2:	8f 73       	andi	r24, 0x3F	; 63

    // if we should be storing the received character into the location
    // just before the tail (meaning that the head would advance to the
    // current location of the tail), we're about to overflow the buffer
    // and so we don't write the character or advance the head.
    if (i != _rx_buffer_tail) {
    1cf4:	20 91 8b 04 	lds	r18, 0x048B	; 0x80048b <Serial+0x1a>
    1cf8:	82 17       	cp	r24, r18
    1cfa:	51 f0       	breq	.+20     	; 0x1d10 <__vector_18+0x50>
      _rx_buffer[_rx_buffer_head] = c;
    1cfc:	e0 91 8a 04 	lds	r30, 0x048A	; 0x80048a <Serial+0x19>
    1d00:	f0 e0       	ldi	r31, 0x00	; 0
    1d02:	ef 58       	subi	r30, 0x8F	; 143
    1d04:	fb 4f       	sbci	r31, 0xFB	; 251
    1d06:	95 8f       	std	Z+29, r25	; 0x1d
      _rx_buffer_head = i;
    1d08:	80 93 8a 04 	sts	0x048A, r24	; 0x80048a <Serial+0x19>
    1d0c:	01 c0       	rjmp	.+2      	; 0x1d10 <__vector_18+0x50>
    }
  } else {
    // Parity error, read byte but discard it
    *_udr;
    1d0e:	80 81       	ld	r24, Z
    Serial._rx_complete_irq();
  }
    1d10:	ff 91       	pop	r31
    1d12:	ef 91       	pop	r30
    1d14:	9f 91       	pop	r25
    1d16:	8f 91       	pop	r24
    1d18:	2f 91       	pop	r18
    1d1a:	0f 90       	pop	r0
    1d1c:	0f be       	out	0x3f, r0	; 63
    1d1e:	0f 90       	pop	r0
    1d20:	1f 90       	pop	r1
    1d22:	18 95       	reti

00001d24 <__vector_19>:
#elif defined(USART_UDRE_vect)
ISR(USART_UDRE_vect)
#else
  #error "Don't know what the Data Register Empty vector is called for Serial"
#endif
{
    1d24:	1f 92       	push	r1
    1d26:	0f 92       	push	r0
    1d28:	0f b6       	in	r0, 0x3f	; 63
    1d2a:	0f 92       	push	r0
    1d2c:	11 24       	eor	r1, r1
    1d2e:	2f 93       	push	r18
    1d30:	3f 93       	push	r19
    1d32:	4f 93       	push	r20
    1d34:	5f 93       	push	r21
    1d36:	6f 93       	push	r22
    1d38:	7f 93       	push	r23
    1d3a:	8f 93       	push	r24
    1d3c:	9f 93       	push	r25
    1d3e:	af 93       	push	r26
    1d40:	bf 93       	push	r27
    1d42:	ef 93       	push	r30
    1d44:	ff 93       	push	r31
  Serial._tx_udr_empty_irq();
    1d46:	81 e7       	ldi	r24, 0x71	; 113
    1d48:	94 e0       	ldi	r25, 0x04	; 4
    1d4a:	0e 94 cf 0d 	call	0x1b9e	; 0x1b9e <_ZN14HardwareSerial17_tx_udr_empty_irqEv>
}
    1d4e:	ff 91       	pop	r31
    1d50:	ef 91       	pop	r30
    1d52:	bf 91       	pop	r27
    1d54:	af 91       	pop	r26
    1d56:	9f 91       	pop	r25
    1d58:	8f 91       	pop	r24
    1d5a:	7f 91       	pop	r23
    1d5c:	6f 91       	pop	r22
    1d5e:	5f 91       	pop	r21
    1d60:	4f 91       	pop	r20
    1d62:	3f 91       	pop	r19
    1d64:	2f 91       	pop	r18
    1d66:	0f 90       	pop	r0
    1d68:	0f be       	out	0x3f, r0	; 63
    1d6a:	0f 90       	pop	r0
    1d6c:	1f 90       	pop	r1
    1d6e:	18 95       	reti

00001d70 <_Z17Serial0_availablev>:
#endif

// Function that can be weakly referenced by serialEventRun to prevent
// pulling in this file if it's not otherwise used.
bool Serial0_available() {
  return Serial.available();
    1d70:	81 e7       	ldi	r24, 0x71	; 113
    1d72:	94 e0       	ldi	r25, 0x04	; 4
    1d74:	0e 94 84 0d 	call	0x1b08	; 0x1b08 <_ZN14HardwareSerial9availableEv>
    1d78:	21 e0       	ldi	r18, 0x01	; 1
    1d7a:	89 2b       	or	r24, r25
    1d7c:	09 f4       	brne	.+2      	; 0x1d80 <_Z17Serial0_availablev+0x10>
    1d7e:	20 e0       	ldi	r18, 0x00	; 0
}
    1d80:	82 2f       	mov	r24, r18
    1d82:	08 95       	ret

00001d84 <_GLOBAL__sub_I___vector_18>:
    size_t printNumber(unsigned long, uint8_t);
    size_t printFloat(double, uint8_t);
  protected:
    void setWriteError(int err = 1) { write_error = err; }
  public:
    Print() : write_error(0) {}
    1d84:	e1 e7       	ldi	r30, 0x71	; 113
    1d86:	f4 e0       	ldi	r31, 0x04	; 4
    1d88:	13 82       	std	Z+3, r1	; 0x03
    1d8a:	12 82       	std	Z+2, r1	; 0x02
  public:
    virtual int available() = 0;
    virtual int read() = 0;
    virtual int peek() = 0;

    Stream() {_timeout=1000;}
    1d8c:	88 ee       	ldi	r24, 0xE8	; 232
    1d8e:	93 e0       	ldi	r25, 0x03	; 3
    1d90:	a0 e0       	ldi	r26, 0x00	; 0
    1d92:	b0 e0       	ldi	r27, 0x00	; 0
    1d94:	84 83       	std	Z+4, r24	; 0x04
    1d96:	95 83       	std	Z+5, r25	; 0x05
    1d98:	a6 83       	std	Z+6, r26	; 0x06
    1d9a:	b7 83       	std	Z+7, r27	; 0x07
  volatile uint8_t *ucsrc, volatile uint8_t *udr) :
    _ubrrh(ubrrh), _ubrrl(ubrrl),
    _ucsra(ucsra), _ucsrb(ucsrb), _ucsrc(ucsrc),
    _udr(udr),
    _rx_buffer_head(0), _rx_buffer_tail(0),
    _tx_buffer_head(0), _tx_buffer_tail(0)
    1d9c:	8f ea       	ldi	r24, 0xAF	; 175
    1d9e:	92 e0       	ldi	r25, 0x02	; 2
    1da0:	91 83       	std	Z+1, r25	; 0x01
    1da2:	80 83       	st	Z, r24
    1da4:	85 ec       	ldi	r24, 0xC5	; 197
    1da6:	90 e0       	ldi	r25, 0x00	; 0
    1da8:	95 87       	std	Z+13, r25	; 0x0d
    1daa:	84 87       	std	Z+12, r24	; 0x0c
    1dac:	84 ec       	ldi	r24, 0xC4	; 196
    1dae:	90 e0       	ldi	r25, 0x00	; 0
    1db0:	97 87       	std	Z+15, r25	; 0x0f
    1db2:	86 87       	std	Z+14, r24	; 0x0e
    1db4:	80 ec       	ldi	r24, 0xC0	; 192
    1db6:	90 e0       	ldi	r25, 0x00	; 0
    1db8:	91 8b       	std	Z+17, r25	; 0x11
    1dba:	80 8b       	std	Z+16, r24	; 0x10
    1dbc:	81 ec       	ldi	r24, 0xC1	; 193
    1dbe:	90 e0       	ldi	r25, 0x00	; 0
    1dc0:	93 8b       	std	Z+19, r25	; 0x13
    1dc2:	82 8b       	std	Z+18, r24	; 0x12
    1dc4:	82 ec       	ldi	r24, 0xC2	; 194
    1dc6:	90 e0       	ldi	r25, 0x00	; 0
    1dc8:	95 8b       	std	Z+21, r25	; 0x15
    1dca:	84 8b       	std	Z+20, r24	; 0x14
    1dcc:	86 ec       	ldi	r24, 0xC6	; 198
    1dce:	90 e0       	ldi	r25, 0x00	; 0
    1dd0:	97 8b       	std	Z+23, r25	; 0x17
    1dd2:	86 8b       	std	Z+22, r24	; 0x16
    1dd4:	11 8e       	std	Z+25, r1	; 0x19
    1dd6:	12 8e       	std	Z+26, r1	; 0x1a
    1dd8:	13 8e       	std	Z+27, r1	; 0x1b
    1dda:	14 8e       	std	Z+28, r1	; 0x1c
    1ddc:	08 95       	ret

00001dde <main>:
void setupUSB() __attribute__((weak));
void setupUSB() { }

int main(void)
{
	init();
    1dde:	0e 94 06 12 	call	0x240c	; 0x240c <init>

	initVariant();
    1de2:	0e 94 e6 1c 	call	0x39cc	; 0x39cc <initVariant>

#if defined(USBCON)
	USBDevice.attach();
#endif
	
	setup();
    1de6:	0e 94 77 04 	call	0x8ee	; 0x8ee <setup>
    
	for (;;) {
		loop();
		if (serialEventRun) serialEventRun();
    1dea:	c1 ec       	ldi	r28, 0xC1	; 193
    1dec:	dd e0       	ldi	r29, 0x0D	; 13
#endif
	
	setup();
    
	for (;;) {
		loop();
    1dee:	0e 94 f3 04 	call	0x9e6	; 0x9e6 <loop>
		if (serialEventRun) serialEventRun();
    1df2:	20 97       	sbiw	r28, 0x00	; 0
    1df4:	e1 f3       	breq	.-8      	; 0x1dee <main+0x10>
    1df6:	0e 94 c1 0d 	call	0x1b82	; 0x1b82 <_Z14serialEventRunv>
    1dfa:	f9 cf       	rjmp	.-14     	; 0x1dee <main+0x10>

00001dfc <_ZN5Print5writeEPKhj>:
size_t Print::println(long num, int base)
{
  size_t n = print(num, base);
  n += println();
  return n;
}
    1dfc:	cf 92       	push	r12
    1dfe:	df 92       	push	r13
    1e00:	ef 92       	push	r14
    1e02:	ff 92       	push	r15
    1e04:	0f 93       	push	r16
    1e06:	1f 93       	push	r17
    1e08:	cf 93       	push	r28
    1e0a:	df 93       	push	r29
    1e0c:	6c 01       	movw	r12, r24
    1e0e:	7a 01       	movw	r14, r20
    1e10:	8b 01       	movw	r16, r22
    1e12:	c0 e0       	ldi	r28, 0x00	; 0
    1e14:	d0 e0       	ldi	r29, 0x00	; 0
    1e16:	ce 15       	cp	r28, r14
    1e18:	df 05       	cpc	r29, r15
    1e1a:	81 f0       	breq	.+32     	; 0x1e3c <_ZN5Print5writeEPKhj+0x40>
    1e1c:	d8 01       	movw	r26, r16
    1e1e:	6d 91       	ld	r22, X+
    1e20:	8d 01       	movw	r16, r26
    1e22:	d6 01       	movw	r26, r12
    1e24:	ed 91       	ld	r30, X+
    1e26:	fc 91       	ld	r31, X
    1e28:	01 90       	ld	r0, Z+
    1e2a:	f0 81       	ld	r31, Z
    1e2c:	e0 2d       	mov	r30, r0
    1e2e:	c6 01       	movw	r24, r12
    1e30:	09 95       	icall
    1e32:	89 2b       	or	r24, r25
    1e34:	11 f0       	breq	.+4      	; 0x1e3a <_ZN5Print5writeEPKhj+0x3e>
    1e36:	21 96       	adiw	r28, 0x01	; 1
    1e38:	ee cf       	rjmp	.-36     	; 0x1e16 <_ZN5Print5writeEPKhj+0x1a>
    1e3a:	7e 01       	movw	r14, r28
    1e3c:	c7 01       	movw	r24, r14
    1e3e:	df 91       	pop	r29
    1e40:	cf 91       	pop	r28
    1e42:	1f 91       	pop	r17
    1e44:	0f 91       	pop	r16
    1e46:	ff 90       	pop	r15
    1e48:	ef 90       	pop	r14
    1e4a:	df 90       	pop	r13
    1e4c:	cf 90       	pop	r12
    1e4e:	08 95       	ret

00001e50 <_ZN5Print5printEPKc>:
    1e50:	0c 94 82 01 	jmp	0x304	; 0x304 <_ZN5Print5writeEPKc>

00001e54 <_ZN5Print5printEc>:
    1e54:	dc 01       	movw	r26, r24
    1e56:	ed 91       	ld	r30, X+
    1e58:	fc 91       	ld	r31, X
    1e5a:	01 90       	ld	r0, Z+
    1e5c:	f0 81       	ld	r31, Z
    1e5e:	e0 2d       	mov	r30, r0
    1e60:	09 94       	ijmp

00001e62 <_ZN5Print7printlnEv>:
    1e62:	6d eb       	ldi	r22, 0xBD	; 189
    1e64:	72 e0       	ldi	r23, 0x02	; 2
    1e66:	0c 94 82 01 	jmp	0x304	; 0x304 <_ZN5Print5writeEPKc>

00001e6a <_ZN5Print7printlnEPKc>:
    1e6a:	0f 93       	push	r16
    1e6c:	1f 93       	push	r17
    1e6e:	cf 93       	push	r28
    1e70:	df 93       	push	r29
    1e72:	ec 01       	movw	r28, r24
    1e74:	0e 94 82 01 	call	0x304	; 0x304 <_ZN5Print5writeEPKc>
    1e78:	8c 01       	movw	r16, r24
    1e7a:	ce 01       	movw	r24, r28
    1e7c:	0e 94 31 0f 	call	0x1e62	; 0x1e62 <_ZN5Print7printlnEv>
    1e80:	80 0f       	add	r24, r16
    1e82:	91 1f       	adc	r25, r17
    1e84:	df 91       	pop	r29
    1e86:	cf 91       	pop	r28
    1e88:	1f 91       	pop	r17
    1e8a:	0f 91       	pop	r16
    1e8c:	08 95       	ret

00001e8e <_ZN5Print11printNumberEmh>:
    1e8e:	8f 92       	push	r8
    1e90:	9f 92       	push	r9
    1e92:	af 92       	push	r10
    1e94:	bf 92       	push	r11
    1e96:	ef 92       	push	r14
    1e98:	ff 92       	push	r15
    1e9a:	0f 93       	push	r16
    1e9c:	1f 93       	push	r17
    1e9e:	cf 93       	push	r28
    1ea0:	df 93       	push	r29
    1ea2:	cd b7       	in	r28, 0x3d	; 61
    1ea4:	de b7       	in	r29, 0x3e	; 62
    1ea6:	a1 97       	sbiw	r28, 0x21	; 33
    1ea8:	0f b6       	in	r0, 0x3f	; 63
    1eaa:	f8 94       	cli
    1eac:	de bf       	out	0x3e, r29	; 62
    1eae:	0f be       	out	0x3f, r0	; 63
    1eb0:	cd bf       	out	0x3d, r28	; 61
    1eb2:	7c 01       	movw	r14, r24
    1eb4:	fa 01       	movw	r30, r20
    1eb6:	cb 01       	movw	r24, r22
    1eb8:	19 a2       	std	Y+33, r1	; 0x21
    1eba:	22 30       	cpi	r18, 0x02	; 2
    1ebc:	08 f4       	brcc	.+2      	; 0x1ec0 <_ZN5Print11printNumberEmh+0x32>
    1ebe:	2a e0       	ldi	r18, 0x0A	; 10
    1ec0:	8e 01       	movw	r16, r28
    1ec2:	0f 5d       	subi	r16, 0xDF	; 223
    1ec4:	1f 4f       	sbci	r17, 0xFF	; 255
    1ec6:	82 2e       	mov	r8, r18
    1ec8:	91 2c       	mov	r9, r1
    1eca:	a1 2c       	mov	r10, r1
    1ecc:	b1 2c       	mov	r11, r1
    1ece:	bf 01       	movw	r22, r30
    1ed0:	a5 01       	movw	r20, r10
    1ed2:	94 01       	movw	r18, r8
    1ed4:	0e 94 ae 1f 	call	0x3f5c	; 0x3f5c <__udivmodsi4>
    1ed8:	f9 01       	movw	r30, r18
    1eda:	ca 01       	movw	r24, r20
    1edc:	01 50       	subi	r16, 0x01	; 1
    1ede:	11 09       	sbc	r17, r1
    1ee0:	6a 30       	cpi	r22, 0x0A	; 10
    1ee2:	10 f4       	brcc	.+4      	; 0x1ee8 <_ZN5Print11printNumberEmh+0x5a>
    1ee4:	60 5d       	subi	r22, 0xD0	; 208
    1ee6:	01 c0       	rjmp	.+2      	; 0x1eea <_ZN5Print11printNumberEmh+0x5c>
    1ee8:	69 5c       	subi	r22, 0xC9	; 201
    1eea:	d8 01       	movw	r26, r16
    1eec:	6c 93       	st	X, r22
    1eee:	23 2b       	or	r18, r19
    1ef0:	24 2b       	or	r18, r20
    1ef2:	25 2b       	or	r18, r21
    1ef4:	61 f7       	brne	.-40     	; 0x1ece <_ZN5Print11printNumberEmh+0x40>
    1ef6:	b8 01       	movw	r22, r16
    1ef8:	c7 01       	movw	r24, r14
    1efa:	0e 94 82 01 	call	0x304	; 0x304 <_ZN5Print5writeEPKc>
    1efe:	a1 96       	adiw	r28, 0x21	; 33
    1f00:	0f b6       	in	r0, 0x3f	; 63
    1f02:	f8 94       	cli
    1f04:	de bf       	out	0x3e, r29	; 62
    1f06:	0f be       	out	0x3f, r0	; 63
    1f08:	cd bf       	out	0x3d, r28	; 61
    1f0a:	df 91       	pop	r29
    1f0c:	cf 91       	pop	r28
    1f0e:	1f 91       	pop	r17
    1f10:	0f 91       	pop	r16
    1f12:	ff 90       	pop	r15
    1f14:	ef 90       	pop	r14
    1f16:	bf 90       	pop	r11
    1f18:	af 90       	pop	r10
    1f1a:	9f 90       	pop	r9
    1f1c:	8f 90       	pop	r8
    1f1e:	08 95       	ret

00001f20 <_ZN5Print5printEmi>:
    1f20:	21 15       	cp	r18, r1
    1f22:	31 05       	cpc	r19, r1
    1f24:	41 f4       	brne	.+16     	; 0x1f36 <_ZN5Print5printEmi+0x16>
    1f26:	dc 01       	movw	r26, r24
    1f28:	ed 91       	ld	r30, X+
    1f2a:	fc 91       	ld	r31, X
    1f2c:	01 90       	ld	r0, Z+
    1f2e:	f0 81       	ld	r31, Z
    1f30:	e0 2d       	mov	r30, r0
    1f32:	64 2f       	mov	r22, r20
    1f34:	09 94       	ijmp
    1f36:	0c 94 47 0f 	jmp	0x1e8e	; 0x1e8e <_ZN5Print11printNumberEmh>

00001f3a <_ZN5Print5printEji>:
    1f3a:	9a 01       	movw	r18, r20
    1f3c:	ab 01       	movw	r20, r22
    1f3e:	60 e0       	ldi	r22, 0x00	; 0
    1f40:	70 e0       	ldi	r23, 0x00	; 0
    1f42:	0c 94 90 0f 	jmp	0x1f20	; 0x1f20 <_ZN5Print5printEmi>

00001f46 <_ZN5Print5printEli>:
    1f46:	cf 92       	push	r12
    1f48:	df 92       	push	r13
    1f4a:	ef 92       	push	r14
    1f4c:	ff 92       	push	r15
    1f4e:	0f 93       	push	r16
    1f50:	1f 93       	push	r17
    1f52:	cf 93       	push	r28
    1f54:	df 93       	push	r29
    1f56:	21 15       	cp	r18, r1
    1f58:	31 05       	cpc	r19, r1
    1f5a:	81 f4       	brne	.+32     	; 0x1f7c <_ZN5Print5printEli+0x36>
    1f5c:	dc 01       	movw	r26, r24
    1f5e:	ed 91       	ld	r30, X+
    1f60:	fc 91       	ld	r31, X
    1f62:	01 90       	ld	r0, Z+
    1f64:	f0 81       	ld	r31, Z
    1f66:	e0 2d       	mov	r30, r0
    1f68:	64 2f       	mov	r22, r20
    1f6a:	df 91       	pop	r29
    1f6c:	cf 91       	pop	r28
    1f6e:	1f 91       	pop	r17
    1f70:	0f 91       	pop	r16
    1f72:	ff 90       	pop	r15
    1f74:	ef 90       	pop	r14
    1f76:	df 90       	pop	r13
    1f78:	cf 90       	pop	r12
    1f7a:	09 94       	ijmp
    1f7c:	2a 30       	cpi	r18, 0x0A	; 10
    1f7e:	31 05       	cpc	r19, r1
    1f80:	01 f5       	brne	.+64     	; 0x1fc2 <_ZN5Print5printEli+0x7c>
    1f82:	77 ff       	sbrs	r23, 7
    1f84:	1d c0       	rjmp	.+58     	; 0x1fc0 <_ZN5Print5printEli+0x7a>
    1f86:	6a 01       	movw	r12, r20
    1f88:	7b 01       	movw	r14, r22
    1f8a:	ec 01       	movw	r28, r24
    1f8c:	6d e2       	ldi	r22, 0x2D	; 45
    1f8e:	0e 94 2a 0f 	call	0x1e54	; 0x1e54 <_ZN5Print5printEc>
    1f92:	8c 01       	movw	r16, r24
    1f94:	44 27       	eor	r20, r20
    1f96:	55 27       	eor	r21, r21
    1f98:	ba 01       	movw	r22, r20
    1f9a:	4c 19       	sub	r20, r12
    1f9c:	5d 09       	sbc	r21, r13
    1f9e:	6e 09       	sbc	r22, r14
    1fa0:	7f 09       	sbc	r23, r15
    1fa2:	2a e0       	ldi	r18, 0x0A	; 10
    1fa4:	ce 01       	movw	r24, r28
    1fa6:	0e 94 47 0f 	call	0x1e8e	; 0x1e8e <_ZN5Print11printNumberEmh>
    1faa:	80 0f       	add	r24, r16
    1fac:	91 1f       	adc	r25, r17
    1fae:	df 91       	pop	r29
    1fb0:	cf 91       	pop	r28
    1fb2:	1f 91       	pop	r17
    1fb4:	0f 91       	pop	r16
    1fb6:	ff 90       	pop	r15
    1fb8:	ef 90       	pop	r14
    1fba:	df 90       	pop	r13
    1fbc:	cf 90       	pop	r12
    1fbe:	08 95       	ret
    1fc0:	2a e0       	ldi	r18, 0x0A	; 10
    1fc2:	df 91       	pop	r29
    1fc4:	cf 91       	pop	r28
    1fc6:	1f 91       	pop	r17
    1fc8:	0f 91       	pop	r16
    1fca:	ff 90       	pop	r15
    1fcc:	ef 90       	pop	r14
    1fce:	df 90       	pop	r13
    1fd0:	cf 90       	pop	r12
    1fd2:	0c 94 47 0f 	jmp	0x1e8e	; 0x1e8e <_ZN5Print11printNumberEmh>

00001fd6 <_ZN5Print5printEii>:
    1fd6:	9a 01       	movw	r18, r20
    1fd8:	ab 01       	movw	r20, r22
    1fda:	77 0f       	add	r23, r23
    1fdc:	66 0b       	sbc	r22, r22
    1fde:	77 0b       	sbc	r23, r23
    1fe0:	0c 94 a3 0f 	jmp	0x1f46	; 0x1f46 <_ZN5Print5printEli>

00001fe4 <_ZN5Print10printFloatEdh>:

  return write(str);
}

size_t Print::printFloat(double number, uint8_t digits) 
{ 
    1fe4:	7f 92       	push	r7
    1fe6:	8f 92       	push	r8
    1fe8:	9f 92       	push	r9
    1fea:	af 92       	push	r10
    1fec:	bf 92       	push	r11
    1fee:	cf 92       	push	r12
    1ff0:	df 92       	push	r13
    1ff2:	ef 92       	push	r14
    1ff4:	ff 92       	push	r15
    1ff6:	0f 93       	push	r16
    1ff8:	1f 93       	push	r17
    1ffa:	cf 93       	push	r28
    1ffc:	df 93       	push	r29
    1ffe:	8c 01       	movw	r16, r24
    2000:	6a 01       	movw	r12, r20
    2002:	7b 01       	movw	r14, r22
    2004:	72 2e       	mov	r7, r18
  size_t n = 0;
  
  if (isnan(number)) return print("nan");
    2006:	9a 01       	movw	r18, r20
    2008:	ab 01       	movw	r20, r22
    200a:	c7 01       	movw	r24, r14
    200c:	b6 01       	movw	r22, r12
    200e:	0e 94 95 1f 	call	0x3f2a	; 0x3f2a <__unordsf2>
    2012:	88 23       	and	r24, r24
    2014:	19 f0       	breq	.+6      	; 0x201c <_ZN5Print10printFloatEdh+0x38>
  return write(s.c_str(), s.length());
}

size_t Print::print(const char str[])
{
  return write(str);
    2016:	60 ec       	ldi	r22, 0xC0	; 192
    2018:	72 e0       	ldi	r23, 0x02	; 2
    201a:	27 c0       	rjmp	.+78     	; 0x206a <_ZN5Print10printFloatEdh+0x86>
size_t Print::printFloat(double number, uint8_t digits) 
{ 
  size_t n = 0;
  
  if (isnan(number)) return print("nan");
  if (isinf(number)) return print("inf");
    201c:	46 01       	movw	r8, r12
    201e:	57 01       	movw	r10, r14
    2020:	e8 94       	clt
    2022:	b7 f8       	bld	r11, 7
    2024:	2f ef       	ldi	r18, 0xFF	; 255
    2026:	3f ef       	ldi	r19, 0xFF	; 255
    2028:	4f e7       	ldi	r20, 0x7F	; 127
    202a:	5f e7       	ldi	r21, 0x7F	; 127
    202c:	c5 01       	movw	r24, r10
    202e:	b4 01       	movw	r22, r8
    2030:	0e 94 95 1f 	call	0x3f2a	; 0x3f2a <__unordsf2>
    2034:	81 11       	cpse	r24, r1
    2036:	0d c0       	rjmp	.+26     	; 0x2052 <_ZN5Print10printFloatEdh+0x6e>
    2038:	2f ef       	ldi	r18, 0xFF	; 255
    203a:	3f ef       	ldi	r19, 0xFF	; 255
    203c:	4f e7       	ldi	r20, 0x7F	; 127
    203e:	5f e7       	ldi	r21, 0x7F	; 127
    2040:	c5 01       	movw	r24, r10
    2042:	b4 01       	movw	r22, r8
    2044:	0e 94 b3 0b 	call	0x1766	; 0x1766 <__cmpsf2>
    2048:	18 16       	cp	r1, r24
    204a:	1c f4       	brge	.+6      	; 0x2052 <_ZN5Print10printFloatEdh+0x6e>
  return write(s.c_str(), s.length());
}

size_t Print::print(const char str[])
{
  return write(str);
    204c:	64 ec       	ldi	r22, 0xC4	; 196
    204e:	72 e0       	ldi	r23, 0x02	; 2
    2050:	0c c0       	rjmp	.+24     	; 0x206a <_ZN5Print10printFloatEdh+0x86>
{ 
  size_t n = 0;
  
  if (isnan(number)) return print("nan");
  if (isinf(number)) return print("inf");
  if (number > 4294967040.0) return print ("ovf");  // constant determined empirically
    2052:	2f ef       	ldi	r18, 0xFF	; 255
    2054:	3f ef       	ldi	r19, 0xFF	; 255
    2056:	4f e7       	ldi	r20, 0x7F	; 127
    2058:	5f e4       	ldi	r21, 0x4F	; 79
    205a:	c7 01       	movw	r24, r14
    205c:	b6 01       	movw	r22, r12
    205e:	0e 94 12 0d 	call	0x1a24	; 0x1a24 <__gesf2>
    2062:	18 16       	cp	r1, r24
    2064:	94 f4       	brge	.+36     	; 0x208a <_ZN5Print10printFloatEdh+0xa6>
  return write(s.c_str(), s.length());
}

size_t Print::print(const char str[])
{
  return write(str);
    2066:	68 ec       	ldi	r22, 0xC8	; 200
    2068:	72 e0       	ldi	r23, 0x02	; 2
    206a:	c8 01       	movw	r24, r16
    n += print(toPrint);
    remainder -= toPrint; 
  } 
  
  return n;
}
    206c:	df 91       	pop	r29
    206e:	cf 91       	pop	r28
    2070:	1f 91       	pop	r17
    2072:	0f 91       	pop	r16
    2074:	ff 90       	pop	r15
    2076:	ef 90       	pop	r14
    2078:	df 90       	pop	r13
    207a:	cf 90       	pop	r12
    207c:	bf 90       	pop	r11
    207e:	af 90       	pop	r10
    2080:	9f 90       	pop	r9
    2082:	8f 90       	pop	r8
    2084:	7f 90       	pop	r7
  return write(s.c_str(), s.length());
}

size_t Print::print(const char str[])
{
  return write(str);
    2086:	0c 94 82 01 	jmp	0x304	; 0x304 <_ZN5Print5writeEPKc>
  size_t n = 0;
  
  if (isnan(number)) return print("nan");
  if (isinf(number)) return print("inf");
  if (number > 4294967040.0) return print ("ovf");  // constant determined empirically
  if (number <-4294967040.0) return print ("ovf");  // constant determined empirically
    208a:	2f ef       	ldi	r18, 0xFF	; 255
    208c:	3f ef       	ldi	r19, 0xFF	; 255
    208e:	4f e7       	ldi	r20, 0x7F	; 127
    2090:	5f ec       	ldi	r21, 0xCF	; 207
    2092:	c7 01       	movw	r24, r14
    2094:	b6 01       	movw	r22, r12
    2096:	0e 94 b3 0b 	call	0x1766	; 0x1766 <__cmpsf2>
    209a:	87 fd       	sbrc	r24, 7
    209c:	e4 cf       	rjmp	.-56     	; 0x2066 <_ZN5Print10printFloatEdh+0x82>
  
  // Handle negative numbers
  if (number < 0.0)
    209e:	20 e0       	ldi	r18, 0x00	; 0
    20a0:	30 e0       	ldi	r19, 0x00	; 0
    20a2:	a9 01       	movw	r20, r18
    20a4:	c7 01       	movw	r24, r14
    20a6:	b6 01       	movw	r22, r12
    20a8:	0e 94 b3 0b 	call	0x1766	; 0x1766 <__cmpsf2>
    20ac:	87 ff       	sbrs	r24, 7
    20ae:	0a c0       	rjmp	.+20     	; 0x20c4 <_ZN5Print10printFloatEdh+0xe0>
  {
     n += print('-');
    20b0:	6d e2       	ldi	r22, 0x2D	; 45
    20b2:	c8 01       	movw	r24, r16
    20b4:	0e 94 2a 0f 	call	0x1e54	; 0x1e54 <_ZN5Print5printEc>
    20b8:	ec 01       	movw	r28, r24
     number = -number;
    20ba:	f7 fa       	bst	r15, 7
    20bc:	f0 94       	com	r15
    20be:	f7 f8       	bld	r15, 7
    20c0:	f0 94       	com	r15
    20c2:	02 c0       	rjmp	.+4      	; 0x20c8 <_ZN5Print10printFloatEdh+0xe4>
  return write(str);
}

size_t Print::printFloat(double number, uint8_t digits) 
{ 
  size_t n = 0;
    20c4:	c0 e0       	ldi	r28, 0x00	; 0
    20c6:	d0 e0       	ldi	r29, 0x00	; 0
     number = -number;
  }

  // Round correctly so that print(1.999, 2) prints as "2.00"
  double rounding = 0.5;
  for (uint8_t i=0; i<digits; ++i)
    20c8:	b1 2c       	mov	r11, r1
     n += print('-');
     number = -number;
  }

  // Round correctly so that print(1.999, 2) prints as "2.00"
  double rounding = 0.5;
    20ca:	60 e0       	ldi	r22, 0x00	; 0
    20cc:	70 e0       	ldi	r23, 0x00	; 0
    20ce:	80 e0       	ldi	r24, 0x00	; 0
    20d0:	9f e3       	ldi	r25, 0x3F	; 63
  for (uint8_t i=0; i<digits; ++i)
    20d2:	7b 14       	cp	r7, r11
    20d4:	41 f0       	breq	.+16     	; 0x20e6 <_ZN5Print10printFloatEdh+0x102>
    rounding /= 10.0;
    20d6:	20 e0       	ldi	r18, 0x00	; 0
    20d8:	30 e0       	ldi	r19, 0x00	; 0
    20da:	40 e2       	ldi	r20, 0x20	; 32
    20dc:	51 e4       	ldi	r21, 0x41	; 65
    20de:	0e 94 b8 0b 	call	0x1770	; 0x1770 <__divsf3>
     number = -number;
  }

  // Round correctly so that print(1.999, 2) prints as "2.00"
  double rounding = 0.5;
  for (uint8_t i=0; i<digits; ++i)
    20e2:	b3 94       	inc	r11
    20e4:	f6 cf       	rjmp	.-20     	; 0x20d2 <_ZN5Print10printFloatEdh+0xee>
    rounding /= 10.0;
  
  number += rounding;
    20e6:	a7 01       	movw	r20, r14
    20e8:	96 01       	movw	r18, r12
    20ea:	0e 94 47 0b 	call	0x168e	; 0x168e <__addsf3>
    20ee:	6b 01       	movw	r12, r22
    20f0:	7c 01       	movw	r14, r24

  // Extract the integer part of the number and print it
  unsigned long int_part = (unsigned long)number;
    20f2:	0e 94 31 0c 	call	0x1862	; 0x1862 <__fixunssfsi>
    20f6:	4b 01       	movw	r8, r22
    20f8:	5c 01       	movw	r10, r24
}

size_t Print::print(unsigned long n, int base)
{
  if (base == 0) return write(n);
  else return printNumber(n, base);
    20fa:	2a e0       	ldi	r18, 0x0A	; 10
    20fc:	ab 01       	movw	r20, r22
    20fe:	bc 01       	movw	r22, r24
    2100:	c8 01       	movw	r24, r16
    2102:	0e 94 47 0f 	call	0x1e8e	; 0x1e8e <_ZN5Print11printNumberEmh>
  number += rounding;

  // Extract the integer part of the number and print it
  unsigned long int_part = (unsigned long)number;
  double remainder = number - (double)int_part;
  n += print(int_part);
    2106:	c8 0f       	add	r28, r24
    2108:	d9 1f       	adc	r29, r25

  // Print the decimal point, but only if there are digits beyond
  if (digits > 0) {
    210a:	77 20       	and	r7, r7
    210c:	b9 f1       	breq	.+110    	; 0x217c <_ZN5Print10printFloatEdh+0x198>
  
  number += rounding;

  // Extract the integer part of the number and print it
  unsigned long int_part = (unsigned long)number;
  double remainder = number - (double)int_part;
    210e:	c5 01       	movw	r24, r10
    2110:	b4 01       	movw	r22, r8
    2112:	0e 94 60 0c 	call	0x18c0	; 0x18c0 <__floatunsisf>
    2116:	9b 01       	movw	r18, r22
    2118:	ac 01       	movw	r20, r24
    211a:	c7 01       	movw	r24, r14
    211c:	b6 01       	movw	r22, r12
    211e:	0e 94 46 0b 	call	0x168c	; 0x168c <__subsf3>
    2122:	6b 01       	movw	r12, r22
    2124:	7c 01       	movw	r14, r24
  n += print(int_part);

  // Print the decimal point, but only if there are digits beyond
  if (digits > 0) {
    n += print('.'); 
    2126:	6e e2       	ldi	r22, 0x2E	; 46
    2128:	c8 01       	movw	r24, r16
    212a:	0e 94 2a 0f 	call	0x1e54	; 0x1e54 <_ZN5Print5printEc>
    212e:	c8 0f       	add	r28, r24
    2130:	d9 1f       	adc	r29, r25
  }

  // Extract digits from the remainder one at a time
  while (digits-- > 0)
  {
    remainder *= 10.0;
    2132:	20 e0       	ldi	r18, 0x00	; 0
    2134:	30 e0       	ldi	r19, 0x00	; 0
    2136:	40 e2       	ldi	r20, 0x20	; 32
    2138:	51 e4       	ldi	r21, 0x41	; 65
    213a:	c7 01       	movw	r24, r14
    213c:	b6 01       	movw	r22, r12
    213e:	0e 94 17 0d 	call	0x1a2e	; 0x1a2e <__mulsf3>
    2142:	4b 01       	movw	r8, r22
    2144:	5c 01       	movw	r10, r24
    unsigned int toPrint = (unsigned int)(remainder);
    2146:	0e 94 31 0c 	call	0x1862	; 0x1862 <__fixunssfsi>
    214a:	6b 01       	movw	r12, r22
    214c:	7c 01       	movw	r14, r24
    n += print(toPrint);
    214e:	4a e0       	ldi	r20, 0x0A	; 10
    2150:	50 e0       	ldi	r21, 0x00	; 0
    2152:	c8 01       	movw	r24, r16
    2154:	0e 94 9d 0f 	call	0x1f3a	; 0x1f3a <_ZN5Print5printEji>
    2158:	c8 0f       	add	r28, r24
    215a:	d9 1f       	adc	r29, r25
    remainder -= toPrint; 
    215c:	b6 01       	movw	r22, r12
    215e:	80 e0       	ldi	r24, 0x00	; 0
    2160:	90 e0       	ldi	r25, 0x00	; 0
    2162:	0e 94 60 0c 	call	0x18c0	; 0x18c0 <__floatunsisf>
    2166:	9b 01       	movw	r18, r22
    2168:	ac 01       	movw	r20, r24
    216a:	c5 01       	movw	r24, r10
    216c:	b4 01       	movw	r22, r8
    216e:	0e 94 46 0b 	call	0x168c	; 0x168c <__subsf3>
    2172:	6b 01       	movw	r12, r22
    2174:	7c 01       	movw	r14, r24
    2176:	7a 94       	dec	r7
  if (digits > 0) {
    n += print('.'); 
  }

  // Extract digits from the remainder one at a time
  while (digits-- > 0)
    2178:	71 10       	cpse	r7, r1
    217a:	db cf       	rjmp	.-74     	; 0x2132 <_ZN5Print10printFloatEdh+0x14e>
  number += rounding;

  // Extract the integer part of the number and print it
  unsigned long int_part = (unsigned long)number;
  double remainder = number - (double)int_part;
  n += print(int_part);
    217c:	ce 01       	movw	r24, r28
    n += print(toPrint);
    remainder -= toPrint; 
  } 
  
  return n;
}
    217e:	df 91       	pop	r29
    2180:	cf 91       	pop	r28
    2182:	1f 91       	pop	r17
    2184:	0f 91       	pop	r16
    2186:	ff 90       	pop	r15
    2188:	ef 90       	pop	r14
    218a:	df 90       	pop	r13
    218c:	cf 90       	pop	r12
    218e:	bf 90       	pop	r11
    2190:	af 90       	pop	r10
    2192:	9f 90       	pop	r9
    2194:	8f 90       	pop	r8
    2196:	7f 90       	pop	r7
    2198:	08 95       	ret

0000219a <_ZN5Print5printEdi>:
  else return printNumber(n, base);
}

size_t Print::print(double n, int digits)
{
  return printFloat(n, digits);
    219a:	0c 94 f2 0f 	jmp	0x1fe4	; 0x1fe4 <_ZN5Print10printFloatEdh>

0000219e <_ZN5Print7printlnEdi>:
  n += println();
  return n;
}

size_t Print::println(double num, int digits)
{
    219e:	0f 93       	push	r16
    21a0:	1f 93       	push	r17
    21a2:	cf 93       	push	r28
    21a4:	df 93       	push	r29
    21a6:	ec 01       	movw	r28, r24
  else return printNumber(n, base);
}

size_t Print::print(double n, int digits)
{
  return printFloat(n, digits);
    21a8:	0e 94 f2 0f 	call	0x1fe4	; 0x1fe4 <_ZN5Print10printFloatEdh>
    21ac:	8c 01       	movw	r16, r24
}

size_t Print::println(double num, int digits)
{
  size_t n = print(num, digits);
  n += println();
    21ae:	ce 01       	movw	r24, r28
    21b0:	0e 94 31 0f 	call	0x1e62	; 0x1e62 <_ZN5Print7printlnEv>
  return n;
}
    21b4:	80 0f       	add	r24, r16
    21b6:	91 1f       	adc	r25, r17
    21b8:	df 91       	pop	r29
    21ba:	cf 91       	pop	r28
    21bc:	1f 91       	pop	r17
    21be:	0f 91       	pop	r16
    21c0:	08 95       	ret

000021c2 <nothing>:
    #endif
      break;       
#endif
    }
      
    intFunc[interruptNum] = nothing;
    21c2:	08 95       	ret

000021c4 <attachInterrupt>:
    21c4:	82 30       	cpi	r24, 0x02	; 2
    21c6:	e8 f4       	brcc	.+58     	; 0x2202 <attachInterrupt+0x3e>
    21c8:	e8 2f       	mov	r30, r24
    21ca:	f0 e0       	ldi	r31, 0x00	; 0
    21cc:	ee 0f       	add	r30, r30
    21ce:	ff 1f       	adc	r31, r31
    21d0:	ef 5d       	subi	r30, 0xDF	; 223
    21d2:	fe 4f       	sbci	r31, 0xFE	; 254
    21d4:	71 83       	std	Z+1, r23	; 0x01
    21d6:	60 83       	st	Z, r22
    21d8:	81 30       	cpi	r24, 0x01	; 1
    21da:	41 f0       	breq	.+16     	; 0x21ec <attachInterrupt+0x28>
    21dc:	80 91 69 00 	lds	r24, 0x0069	; 0x800069 <__DATA_REGION_ORIGIN__+0x9>
    21e0:	8c 7f       	andi	r24, 0xFC	; 252
    21e2:	48 2b       	or	r20, r24
    21e4:	40 93 69 00 	sts	0x0069, r20	; 0x800069 <__DATA_REGION_ORIGIN__+0x9>
    21e8:	e8 9a       	sbi	0x1d, 0	; 29
    21ea:	08 95       	ret
    21ec:	80 91 69 00 	lds	r24, 0x0069	; 0x800069 <__DATA_REGION_ORIGIN__+0x9>
    21f0:	83 7f       	andi	r24, 0xF3	; 243
    21f2:	44 0f       	add	r20, r20
    21f4:	55 1f       	adc	r21, r21
    21f6:	44 0f       	add	r20, r20
    21f8:	55 1f       	adc	r21, r21
    21fa:	48 2b       	or	r20, r24
    21fc:	40 93 69 00 	sts	0x0069, r20	; 0x800069 <__DATA_REGION_ORIGIN__+0x9>
    2200:	e9 9a       	sbi	0x1d, 1	; 29
    2202:	08 95       	ret

00002204 <__vector_1>:
IMPLEMENT_ISR(INT6_vect, EXTERNAL_INT_6)
IMPLEMENT_ISR(INT7_vect, EXTERNAL_INT_7)

#else

IMPLEMENT_ISR(INT0_vect, EXTERNAL_INT_0)
    2204:	1f 92       	push	r1
    2206:	0f 92       	push	r0
    2208:	0f b6       	in	r0, 0x3f	; 63
    220a:	0f 92       	push	r0
    220c:	11 24       	eor	r1, r1
    220e:	2f 93       	push	r18
    2210:	3f 93       	push	r19
    2212:	4f 93       	push	r20
    2214:	5f 93       	push	r21
    2216:	6f 93       	push	r22
    2218:	7f 93       	push	r23
    221a:	8f 93       	push	r24
    221c:	9f 93       	push	r25
    221e:	af 93       	push	r26
    2220:	bf 93       	push	r27
    2222:	ef 93       	push	r30
    2224:	ff 93       	push	r31
    2226:	e0 91 21 01 	lds	r30, 0x0121	; 0x800121 <intFunc>
    222a:	f0 91 22 01 	lds	r31, 0x0122	; 0x800122 <intFunc+0x1>
    222e:	09 95       	icall
    2230:	ff 91       	pop	r31
    2232:	ef 91       	pop	r30
    2234:	bf 91       	pop	r27
    2236:	af 91       	pop	r26
    2238:	9f 91       	pop	r25
    223a:	8f 91       	pop	r24
    223c:	7f 91       	pop	r23
    223e:	6f 91       	pop	r22
    2240:	5f 91       	pop	r21
    2242:	4f 91       	pop	r20
    2244:	3f 91       	pop	r19
    2246:	2f 91       	pop	r18
    2248:	0f 90       	pop	r0
    224a:	0f be       	out	0x3f, r0	; 63
    224c:	0f 90       	pop	r0
    224e:	1f 90       	pop	r1
    2250:	18 95       	reti

00002252 <__vector_2>:
IMPLEMENT_ISR(INT1_vect, EXTERNAL_INT_1)
    2252:	1f 92       	push	r1
    2254:	0f 92       	push	r0
    2256:	0f b6       	in	r0, 0x3f	; 63
    2258:	0f 92       	push	r0
    225a:	11 24       	eor	r1, r1
    225c:	2f 93       	push	r18
    225e:	3f 93       	push	r19
    2260:	4f 93       	push	r20
    2262:	5f 93       	push	r21
    2264:	6f 93       	push	r22
    2266:	7f 93       	push	r23
    2268:	8f 93       	push	r24
    226a:	9f 93       	push	r25
    226c:	af 93       	push	r26
    226e:	bf 93       	push	r27
    2270:	ef 93       	push	r30
    2272:	ff 93       	push	r31
    2274:	e0 91 23 01 	lds	r30, 0x0123	; 0x800123 <intFunc+0x2>
    2278:	f0 91 24 01 	lds	r31, 0x0124	; 0x800124 <intFunc+0x3>
    227c:	09 95       	icall
    227e:	ff 91       	pop	r31
    2280:	ef 91       	pop	r30
    2282:	bf 91       	pop	r27
    2284:	af 91       	pop	r26
    2286:	9f 91       	pop	r25
    2288:	8f 91       	pop	r24
    228a:	7f 91       	pop	r23
    228c:	6f 91       	pop	r22
    228e:	5f 91       	pop	r21
    2290:	4f 91       	pop	r20
    2292:	3f 91       	pop	r19
    2294:	2f 91       	pop	r18
    2296:	0f 90       	pop	r0
    2298:	0f be       	out	0x3f, r0	; 63
    229a:	0f 90       	pop	r0
    229c:	1f 90       	pop	r1
    229e:	18 95       	reti

000022a0 <__vector_16>:
	cli();
	m = timer0_millis;
	SREG = oldSREG;

	return m;
}
    22a0:	1f 92       	push	r1
    22a2:	0f 92       	push	r0
    22a4:	0f b6       	in	r0, 0x3f	; 63
    22a6:	0f 92       	push	r0
    22a8:	11 24       	eor	r1, r1
    22aa:	2f 93       	push	r18
    22ac:	3f 93       	push	r19
    22ae:	8f 93       	push	r24
    22b0:	9f 93       	push	r25
    22b2:	af 93       	push	r26
    22b4:	bf 93       	push	r27
    22b6:	80 91 0f 05 	lds	r24, 0x050F	; 0x80050f <timer0_millis>
    22ba:	90 91 10 05 	lds	r25, 0x0510	; 0x800510 <timer0_millis+0x1>
    22be:	a0 91 11 05 	lds	r26, 0x0511	; 0x800511 <timer0_millis+0x2>
    22c2:	b0 91 12 05 	lds	r27, 0x0512	; 0x800512 <timer0_millis+0x3>
    22c6:	30 91 0e 05 	lds	r19, 0x050E	; 0x80050e <timer0_fract>
    22ca:	23 e0       	ldi	r18, 0x03	; 3
    22cc:	23 0f       	add	r18, r19
    22ce:	2d 37       	cpi	r18, 0x7D	; 125
    22d0:	20 f4       	brcc	.+8      	; 0x22da <__vector_16+0x3a>
    22d2:	01 96       	adiw	r24, 0x01	; 1
    22d4:	a1 1d       	adc	r26, r1
    22d6:	b1 1d       	adc	r27, r1
    22d8:	05 c0       	rjmp	.+10     	; 0x22e4 <__vector_16+0x44>
    22da:	26 e8       	ldi	r18, 0x86	; 134
    22dc:	23 0f       	add	r18, r19
    22de:	02 96       	adiw	r24, 0x02	; 2
    22e0:	a1 1d       	adc	r26, r1
    22e2:	b1 1d       	adc	r27, r1
    22e4:	20 93 0e 05 	sts	0x050E, r18	; 0x80050e <timer0_fract>
    22e8:	80 93 0f 05 	sts	0x050F, r24	; 0x80050f <timer0_millis>
    22ec:	90 93 10 05 	sts	0x0510, r25	; 0x800510 <timer0_millis+0x1>
    22f0:	a0 93 11 05 	sts	0x0511, r26	; 0x800511 <timer0_millis+0x2>
    22f4:	b0 93 12 05 	sts	0x0512, r27	; 0x800512 <timer0_millis+0x3>
    22f8:	80 91 13 05 	lds	r24, 0x0513	; 0x800513 <timer0_overflow_count>
    22fc:	90 91 14 05 	lds	r25, 0x0514	; 0x800514 <timer0_overflow_count+0x1>
    2300:	a0 91 15 05 	lds	r26, 0x0515	; 0x800515 <timer0_overflow_count+0x2>
    2304:	b0 91 16 05 	lds	r27, 0x0516	; 0x800516 <timer0_overflow_count+0x3>
    2308:	01 96       	adiw	r24, 0x01	; 1
    230a:	a1 1d       	adc	r26, r1
    230c:	b1 1d       	adc	r27, r1
    230e:	80 93 13 05 	sts	0x0513, r24	; 0x800513 <timer0_overflow_count>
    2312:	90 93 14 05 	sts	0x0514, r25	; 0x800514 <timer0_overflow_count+0x1>
    2316:	a0 93 15 05 	sts	0x0515, r26	; 0x800515 <timer0_overflow_count+0x2>
    231a:	b0 93 16 05 	sts	0x0516, r27	; 0x800516 <timer0_overflow_count+0x3>
    231e:	bf 91       	pop	r27
    2320:	af 91       	pop	r26
    2322:	9f 91       	pop	r25
    2324:	8f 91       	pop	r24
    2326:	3f 91       	pop	r19
    2328:	2f 91       	pop	r18
    232a:	0f 90       	pop	r0
    232c:	0f be       	out	0x3f, r0	; 63
    232e:	0f 90       	pop	r0
    2330:	1f 90       	pop	r1
    2332:	18 95       	reti

00002334 <micros>:

unsigned long micros() {
	unsigned long m;
	uint8_t oldSREG = SREG, t;
    2334:	3f b7       	in	r19, 0x3f	; 63
	
	cli();
    2336:	f8 94       	cli
	m = timer0_overflow_count;
    2338:	80 91 13 05 	lds	r24, 0x0513	; 0x800513 <timer0_overflow_count>
    233c:	90 91 14 05 	lds	r25, 0x0514	; 0x800514 <timer0_overflow_count+0x1>
    2340:	a0 91 15 05 	lds	r26, 0x0515	; 0x800515 <timer0_overflow_count+0x2>
    2344:	b0 91 16 05 	lds	r27, 0x0516	; 0x800516 <timer0_overflow_count+0x3>
#if defined(TCNT0)
	t = TCNT0;
    2348:	26 b5       	in	r18, 0x26	; 38
#else
	#error TIMER 0 not defined
#endif

#ifdef TIFR0
	if ((TIFR0 & _BV(TOV0)) && (t < 255))
    234a:	a8 9b       	sbis	0x15, 0	; 21
    234c:	05 c0       	rjmp	.+10     	; 0x2358 <micros+0x24>
    234e:	2f 3f       	cpi	r18, 0xFF	; 255
    2350:	19 f0       	breq	.+6      	; 0x2358 <micros+0x24>
		m++;
    2352:	01 96       	adiw	r24, 0x01	; 1
    2354:	a1 1d       	adc	r26, r1
    2356:	b1 1d       	adc	r27, r1
#else
	if ((TIFR & _BV(TOV0)) && (t < 255))
		m++;
#endif

	SREG = oldSREG;
    2358:	3f bf       	out	0x3f, r19	; 63
	
	return ((m << 8) + t) * (64 / clockCyclesPerMicrosecond());
    235a:	ba 2f       	mov	r27, r26
    235c:	a9 2f       	mov	r26, r25
    235e:	98 2f       	mov	r25, r24
    2360:	88 27       	eor	r24, r24
    2362:	82 0f       	add	r24, r18
    2364:	91 1d       	adc	r25, r1
    2366:	a1 1d       	adc	r26, r1
    2368:	b1 1d       	adc	r27, r1
    236a:	bc 01       	movw	r22, r24
    236c:	cd 01       	movw	r24, r26
    236e:	42 e0       	ldi	r20, 0x02	; 2
    2370:	66 0f       	add	r22, r22
    2372:	77 1f       	adc	r23, r23
    2374:	88 1f       	adc	r24, r24
    2376:	99 1f       	adc	r25, r25
    2378:	4a 95       	dec	r20
    237a:	d1 f7       	brne	.-12     	; 0x2370 <micros+0x3c>
}
    237c:	08 95       	ret

0000237e <delay>:

void delay(unsigned long ms)
{
    237e:	8f 92       	push	r8
    2380:	9f 92       	push	r9
    2382:	af 92       	push	r10
    2384:	bf 92       	push	r11
    2386:	cf 92       	push	r12
    2388:	df 92       	push	r13
    238a:	ef 92       	push	r14
    238c:	ff 92       	push	r15
    238e:	6b 01       	movw	r12, r22
    2390:	7c 01       	movw	r14, r24
	uint32_t start = micros();
    2392:	0e 94 9a 11 	call	0x2334	; 0x2334 <micros>
    2396:	4b 01       	movw	r8, r22
    2398:	5c 01       	movw	r10, r24

	while (ms > 0) {
    239a:	c1 14       	cp	r12, r1
    239c:	d1 04       	cpc	r13, r1
    239e:	e1 04       	cpc	r14, r1
    23a0:	f1 04       	cpc	r15, r1
    23a2:	01 f1       	breq	.+64     	; 0x23e4 <delay+0x66>
		yield();
    23a4:	0e 94 84 1d 	call	0x3b08	; 0x3b08 <yield>
		while ( ms > 0 && (micros() - start) >= 1000) {
    23a8:	0e 94 9a 11 	call	0x2334	; 0x2334 <micros>
    23ac:	dc 01       	movw	r26, r24
    23ae:	cb 01       	movw	r24, r22
    23b0:	88 19       	sub	r24, r8
    23b2:	99 09       	sbc	r25, r9
    23b4:	aa 09       	sbc	r26, r10
    23b6:	bb 09       	sbc	r27, r11
    23b8:	88 3e       	cpi	r24, 0xE8	; 232
    23ba:	93 40       	sbci	r25, 0x03	; 3
    23bc:	a1 05       	cpc	r26, r1
    23be:	b1 05       	cpc	r27, r1
    23c0:	60 f3       	brcs	.-40     	; 0x239a <delay+0x1c>
			ms--;
    23c2:	21 e0       	ldi	r18, 0x01	; 1
    23c4:	c2 1a       	sub	r12, r18
    23c6:	d1 08       	sbc	r13, r1
    23c8:	e1 08       	sbc	r14, r1
    23ca:	f1 08       	sbc	r15, r1
			start += 1000;
    23cc:	88 ee       	ldi	r24, 0xE8	; 232
    23ce:	88 0e       	add	r8, r24
    23d0:	83 e0       	ldi	r24, 0x03	; 3
    23d2:	98 1e       	adc	r9, r24
    23d4:	a1 1c       	adc	r10, r1
    23d6:	b1 1c       	adc	r11, r1
{
	uint32_t start = micros();

	while (ms > 0) {
		yield();
		while ( ms > 0 && (micros() - start) >= 1000) {
    23d8:	c1 14       	cp	r12, r1
    23da:	d1 04       	cpc	r13, r1
    23dc:	e1 04       	cpc	r14, r1
    23de:	f1 04       	cpc	r15, r1
    23e0:	19 f7       	brne	.-58     	; 0x23a8 <delay+0x2a>
    23e2:	db cf       	rjmp	.-74     	; 0x239a <delay+0x1c>
			ms--;
			start += 1000;
		}
	}
}
    23e4:	ff 90       	pop	r15
    23e6:	ef 90       	pop	r14
    23e8:	df 90       	pop	r13
    23ea:	cf 90       	pop	r12
    23ec:	bf 90       	pop	r11
    23ee:	af 90       	pop	r10
    23f0:	9f 90       	pop	r9
    23f2:	8f 90       	pop	r8
    23f4:	08 95       	ret

000023f6 <delayMicroseconds>:
#elif F_CPU >= 16000000L
	// for the 16 MHz clock on most Arduino boards

	// for a one-microsecond delay, simply return.  the overhead
	// of the function call takes 14 (16) cycles, which is 1us
	if (us <= 1) return; //  = 3 cycles, (4 when true)
    23f6:	82 30       	cpi	r24, 0x02	; 2
    23f8:	91 05       	cpc	r25, r1
    23fa:	38 f0       	brcs	.+14     	; 0x240a <delayMicroseconds+0x14>

	// the following loop takes 1/4 of a microsecond (4 cycles)
	// per iteration, so execute it four times for each microsecond of
	// delay requested.
	us <<= 2; // x4 us, = 4 cycles
    23fc:	88 0f       	add	r24, r24
    23fe:	99 1f       	adc	r25, r25
    2400:	88 0f       	add	r24, r24
    2402:	99 1f       	adc	r25, r25

	// account for the time taken in the preceeding commands.
	// we just burned 19 (21) cycles above, remove 5, (5*4=20)
	// us is at least 8 so we can substract 5
	us -= 5; // = 2 cycles,
    2404:	05 97       	sbiw	r24, 0x05	; 5
	

#endif

	// busy wait
	__asm__ __volatile__ (
    2406:	01 97       	sbiw	r24, 0x01	; 1
    2408:	f1 f7       	brne	.-4      	; 0x2406 <delayMicroseconds+0x10>
    240a:	08 95       	ret

0000240c <init>:

void init()
{
	// this needs to be called before setup() or some functions won't
	// work there
	sei();
    240c:	78 94       	sei
	
	// on the ATmega168, timer 0 is also used for fast hardware pwm
	// (using phase-correct PWM would mean that timer 0 overflowed half as often
	// resulting in different millis() behavior on the ATmega8 and ATmega168)
#if defined(TCCR0A) && defined(WGM01)
	sbi(TCCR0A, WGM01);
    240e:	84 b5       	in	r24, 0x24	; 36
    2410:	82 60       	ori	r24, 0x02	; 2
    2412:	84 bd       	out	0x24, r24	; 36
	sbi(TCCR0A, WGM00);
    2414:	84 b5       	in	r24, 0x24	; 36
    2416:	81 60       	ori	r24, 0x01	; 1
    2418:	84 bd       	out	0x24, r24	; 36
	// this combination is for the standard atmega8
	sbi(TCCR0, CS01);
	sbi(TCCR0, CS00);
#elif defined(TCCR0B) && defined(CS01) && defined(CS00)
	// this combination is for the standard 168/328/1280/2560
	sbi(TCCR0B, CS01);
    241a:	85 b5       	in	r24, 0x25	; 37
    241c:	82 60       	ori	r24, 0x02	; 2
    241e:	85 bd       	out	0x25, r24	; 37
	sbi(TCCR0B, CS00);
    2420:	85 b5       	in	r24, 0x25	; 37
    2422:	81 60       	ori	r24, 0x01	; 1
    2424:	85 bd       	out	0x25, r24	; 37

	// enable timer 0 overflow interrupt
#if defined(TIMSK) && defined(TOIE0)
	sbi(TIMSK, TOIE0);
#elif defined(TIMSK0) && defined(TOIE0)
	sbi(TIMSK0, TOIE0);
    2426:	ee e6       	ldi	r30, 0x6E	; 110
    2428:	f0 e0       	ldi	r31, 0x00	; 0
    242a:	80 81       	ld	r24, Z
    242c:	81 60       	ori	r24, 0x01	; 1
    242e:	80 83       	st	Z, r24
	// this is better for motors as it ensures an even waveform
	// note, however, that fast pwm mode can achieve a frequency of up
	// 8 MHz (with a 16 MHz clock) at 50% duty cycle

#if defined(TCCR1B) && defined(CS11) && defined(CS10)
	TCCR1B = 0;
    2430:	e1 e8       	ldi	r30, 0x81	; 129
    2432:	f0 e0       	ldi	r31, 0x00	; 0
    2434:	10 82       	st	Z, r1

	// set timer 1 prescale factor to 64
	sbi(TCCR1B, CS11);
    2436:	80 81       	ld	r24, Z
    2438:	82 60       	ori	r24, 0x02	; 2
    243a:	80 83       	st	Z, r24
#if F_CPU >= 8000000L
	sbi(TCCR1B, CS10);
    243c:	80 81       	ld	r24, Z
    243e:	81 60       	ori	r24, 0x01	; 1
    2440:	80 83       	st	Z, r24
	sbi(TCCR1, CS10);
#endif
#endif
	// put timer 1 in 8-bit phase correct pwm mode
#if defined(TCCR1A) && defined(WGM10)
	sbi(TCCR1A, WGM10);
    2442:	e0 e8       	ldi	r30, 0x80	; 128
    2444:	f0 e0       	ldi	r31, 0x00	; 0
    2446:	80 81       	ld	r24, Z
    2448:	81 60       	ori	r24, 0x01	; 1
    244a:	80 83       	st	Z, r24

	// set timer 2 prescale factor to 64
#if defined(TCCR2) && defined(CS22)
	sbi(TCCR2, CS22);
#elif defined(TCCR2B) && defined(CS22)
	sbi(TCCR2B, CS22);
    244c:	e1 eb       	ldi	r30, 0xB1	; 177
    244e:	f0 e0       	ldi	r31, 0x00	; 0
    2450:	80 81       	ld	r24, Z
    2452:	84 60       	ori	r24, 0x04	; 4
    2454:	80 83       	st	Z, r24

	// configure timer 2 for phase correct pwm (8-bit)
#if defined(TCCR2) && defined(WGM20)
	sbi(TCCR2, WGM20);
#elif defined(TCCR2A) && defined(WGM20)
	sbi(TCCR2A, WGM20);
    2456:	e0 eb       	ldi	r30, 0xB0	; 176
    2458:	f0 e0       	ldi	r31, 0x00	; 0
    245a:	80 81       	ld	r24, Z
    245c:	81 60       	ori	r24, 0x01	; 1
    245e:	80 83       	st	Z, r24
#endif

#if defined(ADCSRA)
	// set a2d prescaler so we are inside the desired 50-200 KHz range.
	#if F_CPU >= 16000000 // 16 MHz / 128 = 125 KHz
		sbi(ADCSRA, ADPS2);
    2460:	ea e7       	ldi	r30, 0x7A	; 122
    2462:	f0 e0       	ldi	r31, 0x00	; 0
    2464:	80 81       	ld	r24, Z
    2466:	84 60       	ori	r24, 0x04	; 4
    2468:	80 83       	st	Z, r24
		sbi(ADCSRA, ADPS1);
    246a:	80 81       	ld	r24, Z
    246c:	82 60       	ori	r24, 0x02	; 2
    246e:	80 83       	st	Z, r24
		sbi(ADCSRA, ADPS0);
    2470:	80 81       	ld	r24, Z
    2472:	81 60       	ori	r24, 0x01	; 1
    2474:	80 83       	st	Z, r24
		cbi(ADCSRA, ADPS2);
		cbi(ADCSRA, ADPS1);
		sbi(ADCSRA, ADPS0);
	#endif
	// enable a2d conversions
	sbi(ADCSRA, ADEN);
    2476:	80 81       	ld	r24, Z
    2478:	80 68       	ori	r24, 0x80	; 128
    247a:	80 83       	st	Z, r24
	// here so they can be used as normal digital i/o; they will be
	// reconnected in Serial.begin()
#if defined(UCSRB)
	UCSRB = 0;
#elif defined(UCSR0B)
	UCSR0B = 0;
    247c:	10 92 c1 00 	sts	0x00C1, r1	; 0x8000c1 <__DATA_REGION_ORIGIN__+0x61>
    2480:	08 95       	ret

00002482 <analogRead>:
#elif defined(__AVR_ATmega32U4__)
	if (pin >= 18) pin -= 18; // allow for channel or pin numbers
#elif defined(__AVR_ATmega1284__) || defined(__AVR_ATmega1284P__) || defined(__AVR_ATmega644__) || defined(__AVR_ATmega644A__) || defined(__AVR_ATmega644P__) || defined(__AVR_ATmega644PA__)
	if (pin >= 24) pin -= 24; // allow for channel or pin numbers
#else
	if (pin >= 14) pin -= 14; // allow for channel or pin numbers
    2482:	8e 30       	cpi	r24, 0x0E	; 14
    2484:	08 f0       	brcs	.+2      	; 0x2488 <analogRead+0x6>
    2486:	8e 50       	subi	r24, 0x0E	; 14
	// to 0 (the default).
#if defined(ADMUX)
#if defined(__AVR_ATtiny25__) || defined(__AVR_ATtiny45__) || defined(__AVR_ATtiny85__)
	ADMUX = (analog_reference << 4) | (pin & 0x07);
#else
	ADMUX = (analog_reference << 6) | (pin & 0x07);
    2488:	20 91 25 01 	lds	r18, 0x0125	; 0x800125 <analog_reference>
    248c:	90 e4       	ldi	r25, 0x40	; 64
    248e:	29 9f       	mul	r18, r25
    2490:	90 01       	movw	r18, r0
    2492:	11 24       	eor	r1, r1
    2494:	87 70       	andi	r24, 0x07	; 7
    2496:	82 2b       	or	r24, r18
    2498:	80 93 7c 00 	sts	0x007C, r24	; 0x80007c <__DATA_REGION_ORIGIN__+0x1c>
	// without a delay, we seem to read from the wrong channel
	//delay(1);

#if defined(ADCSRA) && defined(ADCL)
	// start the conversion
	sbi(ADCSRA, ADSC);
    249c:	80 91 7a 00 	lds	r24, 0x007A	; 0x80007a <__DATA_REGION_ORIGIN__+0x1a>
    24a0:	80 64       	ori	r24, 0x40	; 64
    24a2:	80 93 7a 00 	sts	0x007A, r24	; 0x80007a <__DATA_REGION_ORIGIN__+0x1a>

	// ADSC is cleared when the conversion finishes
	while (bit_is_set(ADCSRA, ADSC));
    24a6:	80 91 7a 00 	lds	r24, 0x007A	; 0x80007a <__DATA_REGION_ORIGIN__+0x1a>
    24aa:	86 fd       	sbrc	r24, 6
    24ac:	fc cf       	rjmp	.-8      	; 0x24a6 <analogRead+0x24>

	// we have to read ADCL first; doing so locks both ADCL
	// and ADCH until ADCH is read.  reading ADCL second would
	// cause the results of each conversion to be discarded,
	// as ADCL and ADCH would be locked when it completed.
	low  = ADCL;
    24ae:	80 91 78 00 	lds	r24, 0x0078	; 0x800078 <__DATA_REGION_ORIGIN__+0x18>
	high = ADCH;
    24b2:	20 91 79 00 	lds	r18, 0x0079	; 0x800079 <__DATA_REGION_ORIGIN__+0x19>
	low  = 0;
	high = 0;
#endif

	// combine the two bytes
	return (high << 8) | low;
    24b6:	90 e0       	ldi	r25, 0x00	; 0
}
    24b8:	92 2b       	or	r25, r18
    24ba:	08 95       	ret

000024bc <analogWrite>:
// Right now, PWM output only works on the pins with
// hardware support.  These are defined in the appropriate
// pins_*.c file.  For the rest of the pins, we default
// to digital output.
void analogWrite(uint8_t pin, int val)
{
    24bc:	1f 93       	push	r17
    24be:	cf 93       	push	r28
    24c0:	df 93       	push	r29
    24c2:	18 2f       	mov	r17, r24
    24c4:	eb 01       	movw	r28, r22
	// We need to make sure the PWM output is enabled for those pins
	// that support it, as we turn it off when digitally reading or
	// writing with them.  Also, make sure the pin is in output mode
	// for consistenty with Wiring, which doesn't require a pinMode
	// call for the analog output pins.
	pinMode(pin, OUTPUT);
    24c6:	61 e0       	ldi	r22, 0x01	; 1
    24c8:	0e 94 e6 12 	call	0x25cc	; 0x25cc <pinMode>
	if (val == 0)
    24cc:	20 97       	sbiw	r28, 0x00	; 0
    24ce:	11 f4       	brne	.+4      	; 0x24d4 <analogWrite+0x18>
	{
		digitalWrite(pin, LOW);
    24d0:	60 e0       	ldi	r22, 0x00	; 0
    24d2:	04 c0       	rjmp	.+8      	; 0x24dc <analogWrite+0x20>
	}
	else if (val == 255)
    24d4:	cf 3f       	cpi	r28, 0xFF	; 255
    24d6:	d1 05       	cpc	r29, r1
    24d8:	39 f4       	brne	.+14     	; 0x24e8 <analogWrite+0x2c>
	{
		digitalWrite(pin, HIGH);
    24da:	61 e0       	ldi	r22, 0x01	; 1
    24dc:	81 2f       	mov	r24, r17
				} else {
					digitalWrite(pin, HIGH);
				}
		}
	}
}
    24de:	df 91       	pop	r29
    24e0:	cf 91       	pop	r28
    24e2:	1f 91       	pop	r17
	{
		digitalWrite(pin, LOW);
	}
	else if (val == 255)
	{
		digitalWrite(pin, HIGH);
    24e4:	0c 94 22 13 	jmp	0x2644	; 0x2644 <digitalWrite>
	}
	else
	{
		switch(digitalPinToTimer(pin))
    24e8:	e1 2f       	mov	r30, r17
    24ea:	f0 e0       	ldi	r31, 0x00	; 0
    24ec:	e4 56       	subi	r30, 0x64	; 100
    24ee:	ff 4f       	sbci	r31, 0xFF	; 255
    24f0:	e4 91       	lpm	r30, Z
    24f2:	e3 30       	cpi	r30, 0x03	; 3
    24f4:	f9 f0       	breq	.+62     	; 0x2534 <analogWrite+0x78>
    24f6:	48 f4       	brcc	.+18     	; 0x250a <analogWrite+0x4e>
    24f8:	e1 30       	cpi	r30, 0x01	; 1
    24fa:	b9 f0       	breq	.+46     	; 0x252a <analogWrite+0x6e>
    24fc:	e2 30       	cpi	r30, 0x02	; 2
    24fe:	a1 f5       	brne	.+104    	; 0x2568 <analogWrite+0xac>
			#endif

			#if defined(TCCR0A) && defined(COM0B1)
			case TIMER0B:
				// connect pwm to pin on timer 0, channel B
				sbi(TCCR0A, COM0B1);
    2500:	84 b5       	in	r24, 0x24	; 36
    2502:	80 62       	ori	r24, 0x20	; 32
    2504:	84 bd       	out	0x24, r24	; 36
				OCR0B = val; // set pwm duty
    2506:	c8 bd       	out	0x28, r28	; 40
				break;
    2508:	34 c0       	rjmp	.+104    	; 0x2572 <analogWrite+0xb6>
	{
		digitalWrite(pin, HIGH);
	}
	else
	{
		switch(digitalPinToTimer(pin))
    250a:	e7 30       	cpi	r30, 0x07	; 7
    250c:	e9 f0       	breq	.+58     	; 0x2548 <analogWrite+0x8c>
    250e:	e8 30       	cpi	r30, 0x08	; 8
    2510:	19 f1       	breq	.+70     	; 0x2558 <analogWrite+0x9c>
    2512:	e4 30       	cpi	r30, 0x04	; 4
    2514:	49 f5       	brne	.+82     	; 0x2568 <analogWrite+0xac>
			#endif

			#if defined(TCCR1A) && defined(COM1B1)
			case TIMER1B:
				// connect pwm to pin on timer 1, channel B
				sbi(TCCR1A, COM1B1);
    2516:	80 91 80 00 	lds	r24, 0x0080	; 0x800080 <__DATA_REGION_ORIGIN__+0x20>
    251a:	80 62       	ori	r24, 0x20	; 32
    251c:	80 93 80 00 	sts	0x0080, r24	; 0x800080 <__DATA_REGION_ORIGIN__+0x20>
				OCR1B = val; // set pwm duty
    2520:	d0 93 8b 00 	sts	0x008B, r29	; 0x80008b <__DATA_REGION_ORIGIN__+0x2b>
    2524:	c0 93 8a 00 	sts	0x008A, r28	; 0x80008a <__DATA_REGION_ORIGIN__+0x2a>
				break;
    2528:	24 c0       	rjmp	.+72     	; 0x2572 <analogWrite+0xb6>
			#endif

			#if defined(TCCR0A) && defined(COM0A1)
			case TIMER0A:
				// connect pwm to pin on timer 0, channel A
				sbi(TCCR0A, COM0A1);
    252a:	84 b5       	in	r24, 0x24	; 36
    252c:	80 68       	ori	r24, 0x80	; 128
    252e:	84 bd       	out	0x24, r24	; 36
				OCR0A = val; // set pwm duty
    2530:	c7 bd       	out	0x27, r28	; 39
				break;
    2532:	1f c0       	rjmp	.+62     	; 0x2572 <analogWrite+0xb6>
			#endif

			#if defined(TCCR1A) && defined(COM1A1)
			case TIMER1A:
				// connect pwm to pin on timer 1, channel A
				sbi(TCCR1A, COM1A1);
    2534:	80 91 80 00 	lds	r24, 0x0080	; 0x800080 <__DATA_REGION_ORIGIN__+0x20>
    2538:	80 68       	ori	r24, 0x80	; 128
    253a:	80 93 80 00 	sts	0x0080, r24	; 0x800080 <__DATA_REGION_ORIGIN__+0x20>
				OCR1A = val; // set pwm duty
    253e:	d0 93 89 00 	sts	0x0089, r29	; 0x800089 <__DATA_REGION_ORIGIN__+0x29>
    2542:	c0 93 88 00 	sts	0x0088, r28	; 0x800088 <__DATA_REGION_ORIGIN__+0x28>
				break;
    2546:	15 c0       	rjmp	.+42     	; 0x2572 <analogWrite+0xb6>
			#endif

			#if defined(TCCR2A) && defined(COM2A1)
			case TIMER2A:
				// connect pwm to pin on timer 2, channel A
				sbi(TCCR2A, COM2A1);
    2548:	80 91 b0 00 	lds	r24, 0x00B0	; 0x8000b0 <__DATA_REGION_ORIGIN__+0x50>
    254c:	80 68       	ori	r24, 0x80	; 128
    254e:	80 93 b0 00 	sts	0x00B0, r24	; 0x8000b0 <__DATA_REGION_ORIGIN__+0x50>
				OCR2A = val; // set pwm duty
    2552:	c0 93 b3 00 	sts	0x00B3, r28	; 0x8000b3 <__DATA_REGION_ORIGIN__+0x53>
				break;
    2556:	0d c0       	rjmp	.+26     	; 0x2572 <analogWrite+0xb6>
			#endif

			#if defined(TCCR2A) && defined(COM2B1)
			case TIMER2B:
				// connect pwm to pin on timer 2, channel B
				sbi(TCCR2A, COM2B1);
    2558:	80 91 b0 00 	lds	r24, 0x00B0	; 0x8000b0 <__DATA_REGION_ORIGIN__+0x50>
    255c:	80 62       	ori	r24, 0x20	; 32
    255e:	80 93 b0 00 	sts	0x00B0, r24	; 0x8000b0 <__DATA_REGION_ORIGIN__+0x50>
				OCR2B = val; // set pwm duty
    2562:	c0 93 b4 00 	sts	0x00B4, r28	; 0x8000b4 <__DATA_REGION_ORIGIN__+0x54>
				break;
    2566:	05 c0       	rjmp	.+10     	; 0x2572 <analogWrite+0xb6>
				break;
			#endif

			case NOT_ON_TIMER:
			default:
				if (val < 128) {
    2568:	c0 38       	cpi	r28, 0x80	; 128
    256a:	d1 05       	cpc	r29, r1
    256c:	0c f0       	brlt	.+2      	; 0x2570 <analogWrite+0xb4>
    256e:	b5 cf       	rjmp	.-150    	; 0x24da <analogWrite+0x1e>
    2570:	af cf       	rjmp	.-162    	; 0x24d0 <analogWrite+0x14>
				} else {
					digitalWrite(pin, HIGH);
				}
		}
	}
}
    2572:	df 91       	pop	r29
    2574:	cf 91       	pop	r28
    2576:	1f 91       	pop	r17
    2578:	08 95       	ret

0000257a <turnOffPWM>:
//
//static inline void turnOffPWM(uint8_t timer) __attribute__ ((always_inline));
//static inline void turnOffPWM(uint8_t timer)
static void turnOffPWM(uint8_t timer)
{
	switch (timer)
    257a:	83 30       	cpi	r24, 0x03	; 3
    257c:	81 f0       	breq	.+32     	; 0x259e <turnOffPWM+0x24>
    257e:	28 f4       	brcc	.+10     	; 0x258a <turnOffPWM+0x10>
    2580:	81 30       	cpi	r24, 0x01	; 1
    2582:	99 f0       	breq	.+38     	; 0x25aa <turnOffPWM+0x30>
    2584:	82 30       	cpi	r24, 0x02	; 2
    2586:	a1 f0       	breq	.+40     	; 0x25b0 <turnOffPWM+0x36>
    2588:	08 95       	ret
    258a:	87 30       	cpi	r24, 0x07	; 7
    258c:	a9 f0       	breq	.+42     	; 0x25b8 <turnOffPWM+0x3e>
    258e:	88 30       	cpi	r24, 0x08	; 8
    2590:	b9 f0       	breq	.+46     	; 0x25c0 <turnOffPWM+0x46>
    2592:	84 30       	cpi	r24, 0x04	; 4
    2594:	d1 f4       	brne	.+52     	; 0x25ca <turnOffPWM+0x50>
	{
		#if defined(TCCR1A) && defined(COM1A1)
		case TIMER1A:   cbi(TCCR1A, COM1A1);    break;
		#endif
		#if defined(TCCR1A) && defined(COM1B1)
		case TIMER1B:   cbi(TCCR1A, COM1B1);    break;
    2596:	80 91 80 00 	lds	r24, 0x0080	; 0x800080 <__DATA_REGION_ORIGIN__+0x20>
    259a:	8f 7d       	andi	r24, 0xDF	; 223
    259c:	03 c0       	rjmp	.+6      	; 0x25a4 <turnOffPWM+0x2a>
static void turnOffPWM(uint8_t timer)
{
	switch (timer)
	{
		#if defined(TCCR1A) && defined(COM1A1)
		case TIMER1A:   cbi(TCCR1A, COM1A1);    break;
    259e:	80 91 80 00 	lds	r24, 0x0080	; 0x800080 <__DATA_REGION_ORIGIN__+0x20>
    25a2:	8f 77       	andi	r24, 0x7F	; 127
		#endif
		#if defined(TCCR1A) && defined(COM1B1)
		case TIMER1B:   cbi(TCCR1A, COM1B1);    break;
    25a4:	80 93 80 00 	sts	0x0080, r24	; 0x800080 <__DATA_REGION_ORIGIN__+0x20>
    25a8:	08 95       	ret
		#if defined(TCCR2) && defined(COM21)
		case  TIMER2:   cbi(TCCR2, COM21);      break;
		#endif
		
		#if defined(TCCR0A) && defined(COM0A1)
		case  TIMER0A:  cbi(TCCR0A, COM0A1);    break;
    25aa:	84 b5       	in	r24, 0x24	; 36
    25ac:	8f 77       	andi	r24, 0x7F	; 127
    25ae:	02 c0       	rjmp	.+4      	; 0x25b4 <turnOffPWM+0x3a>
		#endif
		
		#if defined(TCCR0A) && defined(COM0B1)
		case  TIMER0B:  cbi(TCCR0A, COM0B1);    break;
    25b0:	84 b5       	in	r24, 0x24	; 36
    25b2:	8f 7d       	andi	r24, 0xDF	; 223
    25b4:	84 bd       	out	0x24, r24	; 36
    25b6:	08 95       	ret
		#endif
		#if defined(TCCR2A) && defined(COM2A1)
		case  TIMER2A:  cbi(TCCR2A, COM2A1);    break;
    25b8:	80 91 b0 00 	lds	r24, 0x00B0	; 0x8000b0 <__DATA_REGION_ORIGIN__+0x50>
    25bc:	8f 77       	andi	r24, 0x7F	; 127
    25be:	03 c0       	rjmp	.+6      	; 0x25c6 <turnOffPWM+0x4c>
		#endif
		#if defined(TCCR2A) && defined(COM2B1)
		case  TIMER2B:  cbi(TCCR2A, COM2B1);    break;
    25c0:	80 91 b0 00 	lds	r24, 0x00B0	; 0x8000b0 <__DATA_REGION_ORIGIN__+0x50>
    25c4:	8f 7d       	andi	r24, 0xDF	; 223
    25c6:	80 93 b0 00 	sts	0x00B0, r24	; 0x8000b0 <__DATA_REGION_ORIGIN__+0x50>
    25ca:	08 95       	ret

000025cc <pinMode>:
#define ARDUINO_MAIN
#include "wiring_private.h"
#include "pins_arduino.h"

void pinMode(uint8_t pin, uint8_t mode)
{
    25cc:	cf 93       	push	r28
    25ce:	df 93       	push	r29
	uint8_t bit = digitalPinToBitMask(pin);
    25d0:	90 e0       	ldi	r25, 0x00	; 0
    25d2:	fc 01       	movw	r30, r24
    25d4:	e0 55       	subi	r30, 0x50	; 80
    25d6:	ff 4f       	sbci	r31, 0xFF	; 255
    25d8:	24 91       	lpm	r18, Z
	uint8_t port = digitalPinToPort(pin);
    25da:	fc 01       	movw	r30, r24
    25dc:	ec 53       	subi	r30, 0x3C	; 60
    25de:	ff 4f       	sbci	r31, 0xFF	; 255
    25e0:	84 91       	lpm	r24, Z
	volatile uint8_t *reg, *out;

	if (port == NOT_A_PIN) return;
    25e2:	88 23       	and	r24, r24
    25e4:	61 f1       	breq	.+88     	; 0x263e <pinMode+0x72>

	// JWS: can I let the optimizer do this?
	reg = portModeRegister(port);
    25e6:	90 e0       	ldi	r25, 0x00	; 0
    25e8:	88 0f       	add	r24, r24
    25ea:	99 1f       	adc	r25, r25
    25ec:	fc 01       	movw	r30, r24
    25ee:	e4 51       	subi	r30, 0x14	; 20
    25f0:	ff 4f       	sbci	r31, 0xFF	; 255
    25f2:	c5 91       	lpm	r28, Z+
    25f4:	d4 91       	lpm	r29, Z
	out = portOutputRegister(port);
    25f6:	fc 01       	movw	r30, r24
    25f8:	ee 51       	subi	r30, 0x1E	; 30
    25fa:	ff 4f       	sbci	r31, 0xFF	; 255
    25fc:	a5 91       	lpm	r26, Z+
    25fe:	b4 91       	lpm	r27, Z

	if (mode == INPUT) { 
    2600:	61 11       	cpse	r22, r1
    2602:	09 c0       	rjmp	.+18     	; 0x2616 <pinMode+0x4a>
		uint8_t oldSREG = SREG;
    2604:	9f b7       	in	r25, 0x3f	; 63
                cli();
    2606:	f8 94       	cli
		*reg &= ~bit;
    2608:	88 81       	ld	r24, Y
    260a:	20 95       	com	r18
    260c:	82 23       	and	r24, r18
    260e:	88 83       	st	Y, r24
		*out &= ~bit;
    2610:	ec 91       	ld	r30, X
    2612:	2e 23       	and	r18, r30
    2614:	0b c0       	rjmp	.+22     	; 0x262c <pinMode+0x60>
		SREG = oldSREG;
	} else if (mode == INPUT_PULLUP) {
    2616:	62 30       	cpi	r22, 0x02	; 2
    2618:	61 f4       	brne	.+24     	; 0x2632 <pinMode+0x66>
		uint8_t oldSREG = SREG;
    261a:	9f b7       	in	r25, 0x3f	; 63
                cli();
    261c:	f8 94       	cli
		*reg &= ~bit;
    261e:	88 81       	ld	r24, Y
    2620:	32 2f       	mov	r19, r18
    2622:	30 95       	com	r19
    2624:	83 23       	and	r24, r19
    2626:	88 83       	st	Y, r24
		*out |= bit;
    2628:	ec 91       	ld	r30, X
    262a:	2e 2b       	or	r18, r30
    262c:	2c 93       	st	X, r18
		SREG = oldSREG;
    262e:	9f bf       	out	0x3f, r25	; 63
    2630:	06 c0       	rjmp	.+12     	; 0x263e <pinMode+0x72>
	} else {
		uint8_t oldSREG = SREG;
    2632:	8f b7       	in	r24, 0x3f	; 63
                cli();
    2634:	f8 94       	cli
		*reg |= bit;
    2636:	e8 81       	ld	r30, Y
    2638:	2e 2b       	or	r18, r30
    263a:	28 83       	st	Y, r18
		SREG = oldSREG;
    263c:	8f bf       	out	0x3f, r24	; 63
	}
}
    263e:	df 91       	pop	r29
    2640:	cf 91       	pop	r28
    2642:	08 95       	ret

00002644 <digitalWrite>:
		#endif
	}
}

void digitalWrite(uint8_t pin, uint8_t val)
{
    2644:	1f 93       	push	r17
    2646:	cf 93       	push	r28
    2648:	df 93       	push	r29
	uint8_t timer = digitalPinToTimer(pin);
    264a:	28 2f       	mov	r18, r24
    264c:	30 e0       	ldi	r19, 0x00	; 0
    264e:	f9 01       	movw	r30, r18
    2650:	e4 56       	subi	r30, 0x64	; 100
    2652:	ff 4f       	sbci	r31, 0xFF	; 255
    2654:	84 91       	lpm	r24, Z
	uint8_t bit = digitalPinToBitMask(pin);
    2656:	f9 01       	movw	r30, r18
    2658:	e0 55       	subi	r30, 0x50	; 80
    265a:	ff 4f       	sbci	r31, 0xFF	; 255
    265c:	d4 91       	lpm	r29, Z
	uint8_t port = digitalPinToPort(pin);
    265e:	f9 01       	movw	r30, r18
    2660:	ec 53       	subi	r30, 0x3C	; 60
    2662:	ff 4f       	sbci	r31, 0xFF	; 255
    2664:	c4 91       	lpm	r28, Z
	volatile uint8_t *out;

	if (port == NOT_A_PIN) return;
    2666:	cc 23       	and	r28, r28
    2668:	c1 f0       	breq	.+48     	; 0x269a <digitalWrite+0x56>
    266a:	16 2f       	mov	r17, r22

	// If the pin that support PWM output, we need to turn it off
	// before doing a digital write.
	if (timer != NOT_ON_TIMER) turnOffPWM(timer);
    266c:	81 11       	cpse	r24, r1
    266e:	0e 94 bd 12 	call	0x257a	; 0x257a <turnOffPWM>

	out = portOutputRegister(port);
    2672:	ec 2f       	mov	r30, r28
    2674:	f0 e0       	ldi	r31, 0x00	; 0
    2676:	ee 0f       	add	r30, r30
    2678:	ff 1f       	adc	r31, r31
    267a:	ee 51       	subi	r30, 0x1E	; 30
    267c:	ff 4f       	sbci	r31, 0xFF	; 255
    267e:	a5 91       	lpm	r26, Z+
    2680:	b4 91       	lpm	r27, Z

	uint8_t oldSREG = SREG;
    2682:	9f b7       	in	r25, 0x3f	; 63
	cli();
    2684:	f8 94       	cli

	if (val == LOW) {
    2686:	11 11       	cpse	r17, r1
    2688:	04 c0       	rjmp	.+8      	; 0x2692 <digitalWrite+0x4e>
		*out &= ~bit;
    268a:	8c 91       	ld	r24, X
    268c:	d0 95       	com	r29
    268e:	d8 23       	and	r29, r24
    2690:	02 c0       	rjmp	.+4      	; 0x2696 <digitalWrite+0x52>
	} else {
		*out |= bit;
    2692:	ec 91       	ld	r30, X
    2694:	de 2b       	or	r29, r30
    2696:	dc 93       	st	X, r29
	}

	SREG = oldSREG;
    2698:	9f bf       	out	0x3f, r25	; 63
}
    269a:	df 91       	pop	r29
    269c:	cf 91       	pop	r28
    269e:	1f 91       	pop	r17
    26a0:	08 95       	ret

000026a2 <prvIsQueueEmpty>:
    {
        xReturn = pdFALSE;
    }

    return xReturn;
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
    26a2:	0f b6       	in	r0, 0x3f	; 63
    26a4:	f8 94       	cli
    26a6:	0f 92       	push	r0
    26a8:	fc 01       	movw	r30, r24
    26aa:	92 8d       	ldd	r25, Z+26	; 0x1a
    26ac:	0f 90       	pop	r0
    26ae:	0f be       	out	0x3f, r0	; 63
    26b0:	81 e0       	ldi	r24, 0x01	; 1
    26b2:	91 11       	cpse	r25, r1
    26b4:	80 e0       	ldi	r24, 0x00	; 0
    26b6:	08 95       	ret

000026b8 <prvCopyDataToQueue>:
    26b8:	0f 93       	push	r16
    26ba:	1f 93       	push	r17
    26bc:	cf 93       	push	r28
    26be:	df 93       	push	r29
    26c0:	ec 01       	movw	r28, r24
    26c2:	04 2f       	mov	r16, r20
    26c4:	1a 8d       	ldd	r17, Y+26	; 0x1a
    26c6:	4c 8d       	ldd	r20, Y+28	; 0x1c
    26c8:	41 11       	cpse	r20, r1
    26ca:	0b c0       	rjmp	.+22     	; 0x26e2 <prvCopyDataToQueue+0x2a>
    26cc:	88 81       	ld	r24, Y
    26ce:	99 81       	ldd	r25, Y+1	; 0x01
    26d0:	89 2b       	or	r24, r25
    26d2:	e9 f5       	brne	.+122    	; 0x274e <prvCopyDataToQueue+0x96>
    26d4:	8c 81       	ldd	r24, Y+4	; 0x04
    26d6:	9d 81       	ldd	r25, Y+5	; 0x05
    26d8:	0e 94 a6 1a 	call	0x354c	; 0x354c <xTaskPriorityDisinherit>
    26dc:	1d 82       	std	Y+5, r1	; 0x05
    26de:	1c 82       	std	Y+4, r1	; 0x04
    26e0:	37 c0       	rjmp	.+110    	; 0x2750 <prvCopyDataToQueue+0x98>
    26e2:	50 e0       	ldi	r21, 0x00	; 0
    26e4:	01 11       	cpse	r16, r1
    26e6:	15 c0       	rjmp	.+42     	; 0x2712 <prvCopyDataToQueue+0x5a>
    26e8:	8a 81       	ldd	r24, Y+2	; 0x02
    26ea:	9b 81       	ldd	r25, Y+3	; 0x03
    26ec:	0e 94 2a 21 	call	0x4254	; 0x4254 <memcpy>
    26f0:	2c 8d       	ldd	r18, Y+28	; 0x1c
    26f2:	8a 81       	ldd	r24, Y+2	; 0x02
    26f4:	9b 81       	ldd	r25, Y+3	; 0x03
    26f6:	82 0f       	add	r24, r18
    26f8:	91 1d       	adc	r25, r1
    26fa:	9b 83       	std	Y+3, r25	; 0x03
    26fc:	8a 83       	std	Y+2, r24	; 0x02
    26fe:	2c 81       	ldd	r18, Y+4	; 0x04
    2700:	3d 81       	ldd	r19, Y+5	; 0x05
    2702:	82 17       	cp	r24, r18
    2704:	93 07       	cpc	r25, r19
    2706:	18 f1       	brcs	.+70     	; 0x274e <prvCopyDataToQueue+0x96>
    2708:	88 81       	ld	r24, Y
    270a:	99 81       	ldd	r25, Y+1	; 0x01
    270c:	9b 83       	std	Y+3, r25	; 0x03
    270e:	8a 83       	std	Y+2, r24	; 0x02
    2710:	1e c0       	rjmp	.+60     	; 0x274e <prvCopyDataToQueue+0x96>
    2712:	8e 81       	ldd	r24, Y+6	; 0x06
    2714:	9f 81       	ldd	r25, Y+7	; 0x07
    2716:	0e 94 2a 21 	call	0x4254	; 0x4254 <memcpy>
    271a:	8c 8d       	ldd	r24, Y+28	; 0x1c
    271c:	90 e0       	ldi	r25, 0x00	; 0
    271e:	91 95       	neg	r25
    2720:	81 95       	neg	r24
    2722:	91 09       	sbc	r25, r1
    2724:	2e 81       	ldd	r18, Y+6	; 0x06
    2726:	3f 81       	ldd	r19, Y+7	; 0x07
    2728:	28 0f       	add	r18, r24
    272a:	39 1f       	adc	r19, r25
    272c:	3f 83       	std	Y+7, r19	; 0x07
    272e:	2e 83       	std	Y+6, r18	; 0x06
    2730:	48 81       	ld	r20, Y
    2732:	59 81       	ldd	r21, Y+1	; 0x01
    2734:	24 17       	cp	r18, r20
    2736:	35 07       	cpc	r19, r21
    2738:	30 f4       	brcc	.+12     	; 0x2746 <prvCopyDataToQueue+0x8e>
    273a:	2c 81       	ldd	r18, Y+4	; 0x04
    273c:	3d 81       	ldd	r19, Y+5	; 0x05
    273e:	82 0f       	add	r24, r18
    2740:	93 1f       	adc	r25, r19
    2742:	9f 83       	std	Y+7, r25	; 0x07
    2744:	8e 83       	std	Y+6, r24	; 0x06
    2746:	02 30       	cpi	r16, 0x02	; 2
    2748:	11 f4       	brne	.+4      	; 0x274e <prvCopyDataToQueue+0x96>
    274a:	11 11       	cpse	r17, r1
    274c:	11 50       	subi	r17, 0x01	; 1
    274e:	80 e0       	ldi	r24, 0x00	; 0
    2750:	1f 5f       	subi	r17, 0xFF	; 255
    2752:	1a 8f       	std	Y+26, r17	; 0x1a
    2754:	df 91       	pop	r29
    2756:	cf 91       	pop	r28
    2758:	1f 91       	pop	r17
    275a:	0f 91       	pop	r16
    275c:	08 95       	ret

0000275e <prvCopyDataFromQueue>:
    275e:	fc 01       	movw	r30, r24
    2760:	cb 01       	movw	r24, r22
    2762:	44 8d       	ldd	r20, Z+28	; 0x1c
    2764:	44 23       	and	r20, r20
    2766:	a1 f0       	breq	.+40     	; 0x2790 <prvCopyDataFromQueue+0x32>
    2768:	50 e0       	ldi	r21, 0x00	; 0
    276a:	26 81       	ldd	r18, Z+6	; 0x06
    276c:	37 81       	ldd	r19, Z+7	; 0x07
    276e:	24 0f       	add	r18, r20
    2770:	35 1f       	adc	r19, r21
    2772:	37 83       	std	Z+7, r19	; 0x07
    2774:	26 83       	std	Z+6, r18	; 0x06
    2776:	64 81       	ldd	r22, Z+4	; 0x04
    2778:	75 81       	ldd	r23, Z+5	; 0x05
    277a:	26 17       	cp	r18, r22
    277c:	37 07       	cpc	r19, r23
    277e:	20 f0       	brcs	.+8      	; 0x2788 <prvCopyDataFromQueue+0x2a>
    2780:	20 81       	ld	r18, Z
    2782:	31 81       	ldd	r19, Z+1	; 0x01
    2784:	37 83       	std	Z+7, r19	; 0x07
    2786:	26 83       	std	Z+6, r18	; 0x06
    2788:	66 81       	ldd	r22, Z+6	; 0x06
    278a:	77 81       	ldd	r23, Z+7	; 0x07
    278c:	0c 94 2a 21 	jmp	0x4254	; 0x4254 <memcpy>
    2790:	08 95       	ret

00002792 <prvUnlockQueue>:
    2792:	ef 92       	push	r14
    2794:	ff 92       	push	r15
    2796:	1f 93       	push	r17
    2798:	cf 93       	push	r28
    279a:	df 93       	push	r29
    279c:	ec 01       	movw	r28, r24
    279e:	0f b6       	in	r0, 0x3f	; 63
    27a0:	f8 94       	cli
    27a2:	0f 92       	push	r0
    27a4:	1e 8d       	ldd	r17, Y+30	; 0x1e
    27a6:	7c 01       	movw	r14, r24
    27a8:	81 e1       	ldi	r24, 0x11	; 17
    27aa:	e8 0e       	add	r14, r24
    27ac:	f1 1c       	adc	r15, r1
    27ae:	11 16       	cp	r1, r17
    27b0:	5c f4       	brge	.+22     	; 0x27c8 <prvUnlockQueue+0x36>
    27b2:	89 89       	ldd	r24, Y+17	; 0x11
    27b4:	88 23       	and	r24, r24
    27b6:	41 f0       	breq	.+16     	; 0x27c8 <prvUnlockQueue+0x36>
    27b8:	c7 01       	movw	r24, r14
    27ba:	0e 94 16 1a 	call	0x342c	; 0x342c <xTaskRemoveFromEventList>
    27be:	81 11       	cpse	r24, r1
    27c0:	0e 94 94 1a 	call	0x3528	; 0x3528 <vTaskMissedYield>
    27c4:	11 50       	subi	r17, 0x01	; 1
    27c6:	f3 cf       	rjmp	.-26     	; 0x27ae <prvUnlockQueue+0x1c>
    27c8:	8f ef       	ldi	r24, 0xFF	; 255
    27ca:	8e 8f       	std	Y+30, r24	; 0x1e
    27cc:	0f 90       	pop	r0
    27ce:	0f be       	out	0x3f, r0	; 63
    27d0:	0f b6       	in	r0, 0x3f	; 63
    27d2:	f8 94       	cli
    27d4:	0f 92       	push	r0
    27d6:	1d 8d       	ldd	r17, Y+29	; 0x1d
    27d8:	7e 01       	movw	r14, r28
    27da:	88 e0       	ldi	r24, 0x08	; 8
    27dc:	e8 0e       	add	r14, r24
    27de:	f1 1c       	adc	r15, r1
    27e0:	11 16       	cp	r1, r17
    27e2:	5c f4       	brge	.+22     	; 0x27fa <prvUnlockQueue+0x68>
    27e4:	88 85       	ldd	r24, Y+8	; 0x08
    27e6:	88 23       	and	r24, r24
    27e8:	41 f0       	breq	.+16     	; 0x27fa <prvUnlockQueue+0x68>
    27ea:	c7 01       	movw	r24, r14
    27ec:	0e 94 16 1a 	call	0x342c	; 0x342c <xTaskRemoveFromEventList>
    27f0:	81 11       	cpse	r24, r1
    27f2:	0e 94 94 1a 	call	0x3528	; 0x3528 <vTaskMissedYield>
    27f6:	11 50       	subi	r17, 0x01	; 1
    27f8:	f3 cf       	rjmp	.-26     	; 0x27e0 <prvUnlockQueue+0x4e>
    27fa:	8f ef       	ldi	r24, 0xFF	; 255
    27fc:	8d 8f       	std	Y+29, r24	; 0x1d
    27fe:	0f 90       	pop	r0
    2800:	0f be       	out	0x3f, r0	; 63
    2802:	df 91       	pop	r29
    2804:	cf 91       	pop	r28
    2806:	1f 91       	pop	r17
    2808:	ff 90       	pop	r15
    280a:	ef 90       	pop	r14
    280c:	08 95       	ret

0000280e <xQueueGenericReset>:
    280e:	cf 93       	push	r28
    2810:	df 93       	push	r29
    2812:	ec 01       	movw	r28, r24
    2814:	0f b6       	in	r0, 0x3f	; 63
    2816:	f8 94       	cli
    2818:	0f 92       	push	r0
    281a:	48 81       	ld	r20, Y
    281c:	59 81       	ldd	r21, Y+1	; 0x01
    281e:	8b 8d       	ldd	r24, Y+27	; 0x1b
    2820:	7c 8d       	ldd	r23, Y+28	; 0x1c
    2822:	9a 01       	movw	r18, r20
    2824:	87 9f       	mul	r24, r23
    2826:	20 0d       	add	r18, r0
    2828:	31 1d       	adc	r19, r1
    282a:	11 24       	eor	r1, r1
    282c:	3d 83       	std	Y+5, r19	; 0x05
    282e:	2c 83       	std	Y+4, r18	; 0x04
    2830:	1a 8e       	std	Y+26, r1	; 0x1a
    2832:	5b 83       	std	Y+3, r21	; 0x03
    2834:	4a 83       	std	Y+2, r20	; 0x02
    2836:	90 e0       	ldi	r25, 0x00	; 0
    2838:	01 97       	sbiw	r24, 0x01	; 1
    283a:	78 9f       	mul	r23, r24
    283c:	90 01       	movw	r18, r0
    283e:	79 9f       	mul	r23, r25
    2840:	30 0d       	add	r19, r0
    2842:	11 24       	eor	r1, r1
    2844:	ca 01       	movw	r24, r20
    2846:	82 0f       	add	r24, r18
    2848:	93 1f       	adc	r25, r19
    284a:	9f 83       	std	Y+7, r25	; 0x07
    284c:	8e 83       	std	Y+6, r24	; 0x06
    284e:	8f ef       	ldi	r24, 0xFF	; 255
    2850:	8d 8f       	std	Y+29, r24	; 0x1d
    2852:	8e 8f       	std	Y+30, r24	; 0x1e
    2854:	61 11       	cpse	r22, r1
    2856:	0c c0       	rjmp	.+24     	; 0x2870 <xQueueGenericReset+0x62>
    2858:	88 85       	ldd	r24, Y+8	; 0x08
    285a:	88 23       	and	r24, r24
    285c:	89 f0       	breq	.+34     	; 0x2880 <xQueueGenericReset+0x72>
    285e:	ce 01       	movw	r24, r28
    2860:	08 96       	adiw	r24, 0x08	; 8
    2862:	0e 94 16 1a 	call	0x342c	; 0x342c <xTaskRemoveFromEventList>
    2866:	88 23       	and	r24, r24
    2868:	59 f0       	breq	.+22     	; 0x2880 <xQueueGenericReset+0x72>
    286a:	0e 94 dc 1e 	call	0x3db8	; 0x3db8 <vPortYield>
    286e:	08 c0       	rjmp	.+16     	; 0x2880 <xQueueGenericReset+0x72>
    2870:	ce 01       	movw	r24, r28
    2872:	08 96       	adiw	r24, 0x08	; 8
    2874:	0e 94 a9 1d 	call	0x3b52	; 0x3b52 <vListInitialise>
    2878:	ce 01       	movw	r24, r28
    287a:	41 96       	adiw	r24, 0x11	; 17
    287c:	0e 94 a9 1d 	call	0x3b52	; 0x3b52 <vListInitialise>
    2880:	0f 90       	pop	r0
    2882:	0f be       	out	0x3f, r0	; 63
    2884:	81 e0       	ldi	r24, 0x01	; 1
    2886:	df 91       	pop	r29
    2888:	cf 91       	pop	r28
    288a:	08 95       	ret

0000288c <xQueueGenericCreate>:
    288c:	0f 93       	push	r16
    288e:	1f 93       	push	r17
    2890:	cf 93       	push	r28
    2892:	df 93       	push	r29
    2894:	08 2f       	mov	r16, r24
    2896:	16 2f       	mov	r17, r22
    2898:	66 23       	and	r22, r22
    289a:	21 f0       	breq	.+8      	; 0x28a4 <xQueueGenericCreate+0x18>
    289c:	86 9f       	mul	r24, r22
    289e:	c0 01       	movw	r24, r0
    28a0:	11 24       	eor	r1, r1
    28a2:	02 c0       	rjmp	.+4      	; 0x28a8 <xQueueGenericCreate+0x1c>
    28a4:	80 e0       	ldi	r24, 0x00	; 0
    28a6:	90 e0       	ldi	r25, 0x00	; 0
    28a8:	4f 96       	adiw	r24, 0x1f	; 31
    28aa:	0e 94 85 1d 	call	0x3b0a	; 0x3b0a <pvPortMalloc>
    28ae:	ec 01       	movw	r28, r24
    28b0:	00 97       	sbiw	r24, 0x00	; 0
    28b2:	71 f0       	breq	.+28     	; 0x28d0 <xQueueGenericCreate+0x44>
    28b4:	11 11       	cpse	r17, r1
    28b6:	03 c0       	rjmp	.+6      	; 0x28be <xQueueGenericCreate+0x32>
    28b8:	99 83       	std	Y+1, r25	; 0x01
    28ba:	88 83       	st	Y, r24
    28bc:	03 c0       	rjmp	.+6      	; 0x28c4 <xQueueGenericCreate+0x38>
    28be:	4f 96       	adiw	r24, 0x1f	; 31
    28c0:	99 83       	std	Y+1, r25	; 0x01
    28c2:	88 83       	st	Y, r24
    28c4:	0b 8f       	std	Y+27, r16	; 0x1b
    28c6:	1c 8f       	std	Y+28, r17	; 0x1c
    28c8:	61 e0       	ldi	r22, 0x01	; 1
    28ca:	ce 01       	movw	r24, r28
    28cc:	0e 94 07 14 	call	0x280e	; 0x280e <xQueueGenericReset>
    28d0:	ce 01       	movw	r24, r28
    28d2:	df 91       	pop	r29
    28d4:	cf 91       	pop	r28
    28d6:	1f 91       	pop	r17
    28d8:	0f 91       	pop	r16
    28da:	08 95       	ret

000028dc <xQueueGenericSend>:
    28dc:	af 92       	push	r10
    28de:	bf 92       	push	r11
    28e0:	cf 92       	push	r12
    28e2:	df 92       	push	r13
    28e4:	ff 92       	push	r15
    28e6:	0f 93       	push	r16
    28e8:	1f 93       	push	r17
    28ea:	cf 93       	push	r28
    28ec:	df 93       	push	r29
    28ee:	00 d0       	rcall	.+0      	; 0x28f0 <xQueueGenericSend+0x14>
    28f0:	00 d0       	rcall	.+0      	; 0x28f2 <xQueueGenericSend+0x16>
    28f2:	1f 92       	push	r1
    28f4:	cd b7       	in	r28, 0x3d	; 61
    28f6:	de b7       	in	r29, 0x3e	; 62
    28f8:	8c 01       	movw	r16, r24
    28fa:	6b 01       	movw	r12, r22
    28fc:	5d 83       	std	Y+5, r21	; 0x05
    28fe:	4c 83       	std	Y+4, r20	; 0x04
    2900:	f2 2e       	mov	r15, r18
    2902:	80 e0       	ldi	r24, 0x00	; 0
    2904:	58 01       	movw	r10, r16
    2906:	98 e0       	ldi	r25, 0x08	; 8
    2908:	a9 0e       	add	r10, r25
    290a:	b1 1c       	adc	r11, r1
    290c:	0f b6       	in	r0, 0x3f	; 63
    290e:	f8 94       	cli
    2910:	0f 92       	push	r0
    2912:	f8 01       	movw	r30, r16
    2914:	22 8d       	ldd	r18, Z+26	; 0x1a
    2916:	93 8d       	ldd	r25, Z+27	; 0x1b
    2918:	29 17       	cp	r18, r25
    291a:	18 f0       	brcs	.+6      	; 0x2922 <xQueueGenericSend+0x46>
    291c:	f2 e0       	ldi	r31, 0x02	; 2
    291e:	ff 12       	cpse	r15, r31
    2920:	14 c0       	rjmp	.+40     	; 0x294a <xQueueGenericSend+0x6e>
    2922:	4f 2d       	mov	r20, r15
    2924:	b6 01       	movw	r22, r12
    2926:	c8 01       	movw	r24, r16
    2928:	0e 94 5c 13 	call	0x26b8	; 0x26b8 <prvCopyDataToQueue>
    292c:	f8 01       	movw	r30, r16
    292e:	91 89       	ldd	r25, Z+17	; 0x11
    2930:	99 23       	and	r25, r25
    2932:	21 f0       	breq	.+8      	; 0x293c <xQueueGenericSend+0x60>
    2934:	c8 01       	movw	r24, r16
    2936:	41 96       	adiw	r24, 0x11	; 17
    2938:	0e 94 16 1a 	call	0x342c	; 0x342c <xTaskRemoveFromEventList>
    293c:	81 11       	cpse	r24, r1
    293e:	0e 94 dc 1e 	call	0x3db8	; 0x3db8 <vPortYield>
    2942:	0f 90       	pop	r0
    2944:	0f be       	out	0x3f, r0	; 63
    2946:	81 e0       	ldi	r24, 0x01	; 1
    2948:	50 c0       	rjmp	.+160    	; 0x29ea <xQueueGenericSend+0x10e>
    294a:	2c 81       	ldd	r18, Y+4	; 0x04
    294c:	3d 81       	ldd	r19, Y+5	; 0x05
    294e:	23 2b       	or	r18, r19
    2950:	19 f4       	brne	.+6      	; 0x2958 <xQueueGenericSend+0x7c>
    2952:	0f 90       	pop	r0
    2954:	0f be       	out	0x3f, r0	; 63
    2956:	48 c0       	rjmp	.+144    	; 0x29e8 <xQueueGenericSend+0x10c>
    2958:	81 11       	cpse	r24, r1
    295a:	04 c0       	rjmp	.+8      	; 0x2964 <xQueueGenericSend+0x88>
    295c:	ce 01       	movw	r24, r28
    295e:	01 96       	adiw	r24, 0x01	; 1
    2960:	0e 94 56 1a 	call	0x34ac	; 0x34ac <vTaskInternalSetTimeOutState>
    2964:	0f 90       	pop	r0
    2966:	0f be       	out	0x3f, r0	; 63
    2968:	0e 94 2c 18 	call	0x3058	; 0x3058 <vTaskSuspendAll>
    296c:	0f b6       	in	r0, 0x3f	; 63
    296e:	f8 94       	cli
    2970:	0f 92       	push	r0
    2972:	f8 01       	movw	r30, r16
    2974:	85 8d       	ldd	r24, Z+29	; 0x1d
    2976:	8f 3f       	cpi	r24, 0xFF	; 255
    2978:	09 f4       	brne	.+2      	; 0x297c <xQueueGenericSend+0xa0>
    297a:	15 8e       	std	Z+29, r1	; 0x1d
    297c:	f8 01       	movw	r30, r16
    297e:	86 8d       	ldd	r24, Z+30	; 0x1e
    2980:	8f 3f       	cpi	r24, 0xFF	; 255
    2982:	09 f4       	brne	.+2      	; 0x2986 <xQueueGenericSend+0xaa>
    2984:	16 8e       	std	Z+30, r1	; 0x1e
    2986:	0f 90       	pop	r0
    2988:	0f be       	out	0x3f, r0	; 63
    298a:	be 01       	movw	r22, r28
    298c:	6c 5f       	subi	r22, 0xFC	; 252
    298e:	7f 4f       	sbci	r23, 0xFF	; 255
    2990:	ce 01       	movw	r24, r28
    2992:	01 96       	adiw	r24, 0x01	; 1
    2994:	0e 94 61 1a 	call	0x34c2	; 0x34c2 <xTaskCheckForTimeOut>
    2998:	81 11       	cpse	r24, r1
    299a:	21 c0       	rjmp	.+66     	; 0x29de <xQueueGenericSend+0x102>
    299c:	0f b6       	in	r0, 0x3f	; 63
    299e:	f8 94       	cli
    29a0:	0f 92       	push	r0
    29a2:	f8 01       	movw	r30, r16
    29a4:	92 8d       	ldd	r25, Z+26	; 0x1a
    29a6:	83 8d       	ldd	r24, Z+27	; 0x1b
    29a8:	0f 90       	pop	r0
    29aa:	0f be       	out	0x3f, r0	; 63
    29ac:	98 13       	cpse	r25, r24
    29ae:	11 c0       	rjmp	.+34     	; 0x29d2 <xQueueGenericSend+0xf6>
    29b0:	6c 81       	ldd	r22, Y+4	; 0x04
    29b2:	7d 81       	ldd	r23, Y+5	; 0x05
    29b4:	c5 01       	movw	r24, r10
    29b6:	0e 94 ed 19 	call	0x33da	; 0x33da <vTaskPlaceOnEventList>
    29ba:	c8 01       	movw	r24, r16
    29bc:	0e 94 c9 13 	call	0x2792	; 0x2792 <prvUnlockQueue>
    29c0:	0e 94 e8 18 	call	0x31d0	; 0x31d0 <xTaskResumeAll>
    29c4:	88 23       	and	r24, r24
    29c6:	11 f0       	breq	.+4      	; 0x29cc <xQueueGenericSend+0xf0>
    29c8:	81 e0       	ldi	r24, 0x01	; 1
    29ca:	a0 cf       	rjmp	.-192    	; 0x290c <xQueueGenericSend+0x30>
    29cc:	0e 94 dc 1e 	call	0x3db8	; 0x3db8 <vPortYield>
    29d0:	fb cf       	rjmp	.-10     	; 0x29c8 <xQueueGenericSend+0xec>
    29d2:	c8 01       	movw	r24, r16
    29d4:	0e 94 c9 13 	call	0x2792	; 0x2792 <prvUnlockQueue>
    29d8:	0e 94 e8 18 	call	0x31d0	; 0x31d0 <xTaskResumeAll>
    29dc:	f5 cf       	rjmp	.-22     	; 0x29c8 <xQueueGenericSend+0xec>
    29de:	c8 01       	movw	r24, r16
    29e0:	0e 94 c9 13 	call	0x2792	; 0x2792 <prvUnlockQueue>
    29e4:	0e 94 e8 18 	call	0x31d0	; 0x31d0 <xTaskResumeAll>
    29e8:	80 e0       	ldi	r24, 0x00	; 0
    29ea:	0f 90       	pop	r0
    29ec:	0f 90       	pop	r0
    29ee:	0f 90       	pop	r0
    29f0:	0f 90       	pop	r0
    29f2:	0f 90       	pop	r0
    29f4:	df 91       	pop	r29
    29f6:	cf 91       	pop	r28
    29f8:	1f 91       	pop	r17
    29fa:	0f 91       	pop	r16
    29fc:	ff 90       	pop	r15
    29fe:	df 90       	pop	r13
    2a00:	cf 90       	pop	r12
    2a02:	bf 90       	pop	r11
    2a04:	af 90       	pop	r10
    2a06:	08 95       	ret

00002a08 <xQueueGenericSendFromISR>:
    2a08:	ef 92       	push	r14
    2a0a:	ff 92       	push	r15
    2a0c:	1f 93       	push	r17
    2a0e:	cf 93       	push	r28
    2a10:	df 93       	push	r29
    2a12:	ec 01       	movw	r28, r24
    2a14:	9a 8d       	ldd	r25, Y+26	; 0x1a
    2a16:	8b 8d       	ldd	r24, Y+27	; 0x1b
    2a18:	98 17       	cp	r25, r24
    2a1a:	10 f0       	brcs	.+4      	; 0x2a20 <xQueueGenericSendFromISR+0x18>
    2a1c:	22 30       	cpi	r18, 0x02	; 2
    2a1e:	e1 f4       	brne	.+56     	; 0x2a58 <xQueueGenericSendFromISR+0x50>
    2a20:	7a 01       	movw	r14, r20
    2a22:	1e 8d       	ldd	r17, Y+30	; 0x1e
    2a24:	42 2f       	mov	r20, r18
    2a26:	ce 01       	movw	r24, r28
    2a28:	0e 94 5c 13 	call	0x26b8	; 0x26b8 <prvCopyDataToQueue>
    2a2c:	1f 3f       	cpi	r17, 0xFF	; 255
    2a2e:	81 f4       	brne	.+32     	; 0x2a50 <xQueueGenericSendFromISR+0x48>
    2a30:	89 89       	ldd	r24, Y+17	; 0x11
    2a32:	88 23       	and	r24, r24
    2a34:	79 f0       	breq	.+30     	; 0x2a54 <xQueueGenericSendFromISR+0x4c>
    2a36:	ce 01       	movw	r24, r28
    2a38:	41 96       	adiw	r24, 0x11	; 17
    2a3a:	0e 94 16 1a 	call	0x342c	; 0x342c <xTaskRemoveFromEventList>
    2a3e:	88 23       	and	r24, r24
    2a40:	49 f0       	breq	.+18     	; 0x2a54 <xQueueGenericSendFromISR+0x4c>
    2a42:	e1 14       	cp	r14, r1
    2a44:	f1 04       	cpc	r15, r1
    2a46:	31 f0       	breq	.+12     	; 0x2a54 <xQueueGenericSendFromISR+0x4c>
    2a48:	81 e0       	ldi	r24, 0x01	; 1
    2a4a:	f7 01       	movw	r30, r14
    2a4c:	80 83       	st	Z, r24
    2a4e:	05 c0       	rjmp	.+10     	; 0x2a5a <xQueueGenericSendFromISR+0x52>
    2a50:	1f 5f       	subi	r17, 0xFF	; 255
    2a52:	1e 8f       	std	Y+30, r17	; 0x1e
    2a54:	81 e0       	ldi	r24, 0x01	; 1
    2a56:	01 c0       	rjmp	.+2      	; 0x2a5a <xQueueGenericSendFromISR+0x52>
    2a58:	80 e0       	ldi	r24, 0x00	; 0
    2a5a:	df 91       	pop	r29
    2a5c:	cf 91       	pop	r28
    2a5e:	1f 91       	pop	r17
    2a60:	ff 90       	pop	r15
    2a62:	ef 90       	pop	r14
    2a64:	08 95       	ret

00002a66 <xQueueGiveFromISR>:
    2a66:	cf 93       	push	r28
    2a68:	df 93       	push	r29
    2a6a:	fc 01       	movw	r30, r24
    2a6c:	92 8d       	ldd	r25, Z+26	; 0x1a
    2a6e:	83 8d       	ldd	r24, Z+27	; 0x1b
    2a70:	98 17       	cp	r25, r24
    2a72:	c0 f4       	brcc	.+48     	; 0x2aa4 <xQueueGiveFromISR+0x3e>
    2a74:	86 8d       	ldd	r24, Z+30	; 0x1e
    2a76:	9f 5f       	subi	r25, 0xFF	; 255
    2a78:	92 8f       	std	Z+26, r25	; 0x1a
    2a7a:	8f 3f       	cpi	r24, 0xFF	; 255
    2a7c:	79 f4       	brne	.+30     	; 0x2a9c <xQueueGiveFromISR+0x36>
    2a7e:	81 89       	ldd	r24, Z+17	; 0x11
    2a80:	88 23       	and	r24, r24
    2a82:	71 f0       	breq	.+28     	; 0x2aa0 <xQueueGiveFromISR+0x3a>
    2a84:	eb 01       	movw	r28, r22
    2a86:	cf 01       	movw	r24, r30
    2a88:	41 96       	adiw	r24, 0x11	; 17
    2a8a:	0e 94 16 1a 	call	0x342c	; 0x342c <xTaskRemoveFromEventList>
    2a8e:	88 23       	and	r24, r24
    2a90:	39 f0       	breq	.+14     	; 0x2aa0 <xQueueGiveFromISR+0x3a>
    2a92:	20 97       	sbiw	r28, 0x00	; 0
    2a94:	29 f0       	breq	.+10     	; 0x2aa0 <xQueueGiveFromISR+0x3a>
    2a96:	81 e0       	ldi	r24, 0x01	; 1
    2a98:	88 83       	st	Y, r24
    2a9a:	05 c0       	rjmp	.+10     	; 0x2aa6 <xQueueGiveFromISR+0x40>
    2a9c:	8f 5f       	subi	r24, 0xFF	; 255
    2a9e:	86 8f       	std	Z+30, r24	; 0x1e
    2aa0:	81 e0       	ldi	r24, 0x01	; 1
    2aa2:	01 c0       	rjmp	.+2      	; 0x2aa6 <xQueueGiveFromISR+0x40>
    2aa4:	80 e0       	ldi	r24, 0x00	; 0
    2aa6:	df 91       	pop	r29
    2aa8:	cf 91       	pop	r28
    2aaa:	08 95       	ret

00002aac <xQueueReceive>:
    2aac:	af 92       	push	r10
    2aae:	bf 92       	push	r11
    2ab0:	cf 92       	push	r12
    2ab2:	df 92       	push	r13
    2ab4:	ff 92       	push	r15
    2ab6:	0f 93       	push	r16
    2ab8:	1f 93       	push	r17
    2aba:	cf 93       	push	r28
    2abc:	df 93       	push	r29
    2abe:	00 d0       	rcall	.+0      	; 0x2ac0 <xQueueReceive+0x14>
    2ac0:	00 d0       	rcall	.+0      	; 0x2ac2 <xQueueReceive+0x16>
    2ac2:	1f 92       	push	r1
    2ac4:	cd b7       	in	r28, 0x3d	; 61
    2ac6:	de b7       	in	r29, 0x3e	; 62
    2ac8:	8c 01       	movw	r16, r24
    2aca:	6b 01       	movw	r12, r22
    2acc:	5d 83       	std	Y+5, r21	; 0x05
    2ace:	4c 83       	std	Y+4, r20	; 0x04
    2ad0:	80 e0       	ldi	r24, 0x00	; 0
    2ad2:	58 01       	movw	r10, r16
    2ad4:	91 e1       	ldi	r25, 0x11	; 17
    2ad6:	a9 0e       	add	r10, r25
    2ad8:	b1 1c       	adc	r11, r1
    2ada:	0f b6       	in	r0, 0x3f	; 63
    2adc:	f8 94       	cli
    2ade:	0f 92       	push	r0
    2ae0:	f8 01       	movw	r30, r16
    2ae2:	f2 8c       	ldd	r15, Z+26	; 0x1a
    2ae4:	ff 20       	and	r15, r15
    2ae6:	a9 f0       	breq	.+42     	; 0x2b12 <xQueueReceive+0x66>
    2ae8:	b6 01       	movw	r22, r12
    2aea:	c8 01       	movw	r24, r16
    2aec:	0e 94 af 13 	call	0x275e	; 0x275e <prvCopyDataFromQueue>
    2af0:	fa 94       	dec	r15
    2af2:	f8 01       	movw	r30, r16
    2af4:	f2 8e       	std	Z+26, r15	; 0x1a
    2af6:	80 85       	ldd	r24, Z+8	; 0x08
    2af8:	88 23       	and	r24, r24
    2afa:	39 f0       	breq	.+14     	; 0x2b0a <xQueueReceive+0x5e>
    2afc:	c8 01       	movw	r24, r16
    2afe:	08 96       	adiw	r24, 0x08	; 8
    2b00:	0e 94 16 1a 	call	0x342c	; 0x342c <xTaskRemoveFromEventList>
    2b04:	81 11       	cpse	r24, r1
    2b06:	0e 94 dc 1e 	call	0x3db8	; 0x3db8 <vPortYield>
    2b0a:	0f 90       	pop	r0
    2b0c:	0f be       	out	0x3f, r0	; 63
    2b0e:	81 e0       	ldi	r24, 0x01	; 1
    2b10:	50 c0       	rjmp	.+160    	; 0x2bb2 <xQueueReceive+0x106>
    2b12:	2c 81       	ldd	r18, Y+4	; 0x04
    2b14:	3d 81       	ldd	r19, Y+5	; 0x05
    2b16:	23 2b       	or	r18, r19
    2b18:	19 f4       	brne	.+6      	; 0x2b20 <xQueueReceive+0x74>
    2b1a:	0f 90       	pop	r0
    2b1c:	0f be       	out	0x3f, r0	; 63
    2b1e:	48 c0       	rjmp	.+144    	; 0x2bb0 <xQueueReceive+0x104>
    2b20:	81 11       	cpse	r24, r1
    2b22:	04 c0       	rjmp	.+8      	; 0x2b2c <xQueueReceive+0x80>
    2b24:	ce 01       	movw	r24, r28
    2b26:	01 96       	adiw	r24, 0x01	; 1
    2b28:	0e 94 56 1a 	call	0x34ac	; 0x34ac <vTaskInternalSetTimeOutState>
    2b2c:	0f 90       	pop	r0
    2b2e:	0f be       	out	0x3f, r0	; 63
    2b30:	0e 94 2c 18 	call	0x3058	; 0x3058 <vTaskSuspendAll>
    2b34:	0f b6       	in	r0, 0x3f	; 63
    2b36:	f8 94       	cli
    2b38:	0f 92       	push	r0
    2b3a:	f8 01       	movw	r30, r16
    2b3c:	85 8d       	ldd	r24, Z+29	; 0x1d
    2b3e:	8f 3f       	cpi	r24, 0xFF	; 255
    2b40:	09 f4       	brne	.+2      	; 0x2b44 <xQueueReceive+0x98>
    2b42:	15 8e       	std	Z+29, r1	; 0x1d
    2b44:	f8 01       	movw	r30, r16
    2b46:	86 8d       	ldd	r24, Z+30	; 0x1e
    2b48:	8f 3f       	cpi	r24, 0xFF	; 255
    2b4a:	09 f4       	brne	.+2      	; 0x2b4e <xQueueReceive+0xa2>
    2b4c:	16 8e       	std	Z+30, r1	; 0x1e
    2b4e:	0f 90       	pop	r0
    2b50:	0f be       	out	0x3f, r0	; 63
    2b52:	be 01       	movw	r22, r28
    2b54:	6c 5f       	subi	r22, 0xFC	; 252
    2b56:	7f 4f       	sbci	r23, 0xFF	; 255
    2b58:	ce 01       	movw	r24, r28
    2b5a:	01 96       	adiw	r24, 0x01	; 1
    2b5c:	0e 94 61 1a 	call	0x34c2	; 0x34c2 <xTaskCheckForTimeOut>
    2b60:	81 11       	cpse	r24, r1
    2b62:	1c c0       	rjmp	.+56     	; 0x2b9c <xQueueReceive+0xf0>
    2b64:	c8 01       	movw	r24, r16
    2b66:	0e 94 51 13 	call	0x26a2	; 0x26a2 <prvIsQueueEmpty>
    2b6a:	88 23       	and	r24, r24
    2b6c:	89 f0       	breq	.+34     	; 0x2b90 <xQueueReceive+0xe4>
    2b6e:	6c 81       	ldd	r22, Y+4	; 0x04
    2b70:	7d 81       	ldd	r23, Y+5	; 0x05
    2b72:	c5 01       	movw	r24, r10
    2b74:	0e 94 ed 19 	call	0x33da	; 0x33da <vTaskPlaceOnEventList>
    2b78:	c8 01       	movw	r24, r16
    2b7a:	0e 94 c9 13 	call	0x2792	; 0x2792 <prvUnlockQueue>
    2b7e:	0e 94 e8 18 	call	0x31d0	; 0x31d0 <xTaskResumeAll>
    2b82:	88 23       	and	r24, r24
    2b84:	11 f0       	breq	.+4      	; 0x2b8a <xQueueReceive+0xde>
    2b86:	81 e0       	ldi	r24, 0x01	; 1
    2b88:	a8 cf       	rjmp	.-176    	; 0x2ada <xQueueReceive+0x2e>
    2b8a:	0e 94 dc 1e 	call	0x3db8	; 0x3db8 <vPortYield>
    2b8e:	fb cf       	rjmp	.-10     	; 0x2b86 <xQueueReceive+0xda>
    2b90:	c8 01       	movw	r24, r16
    2b92:	0e 94 c9 13 	call	0x2792	; 0x2792 <prvUnlockQueue>
    2b96:	0e 94 e8 18 	call	0x31d0	; 0x31d0 <xTaskResumeAll>
    2b9a:	f5 cf       	rjmp	.-22     	; 0x2b86 <xQueueReceive+0xda>
    2b9c:	c8 01       	movw	r24, r16
    2b9e:	0e 94 c9 13 	call	0x2792	; 0x2792 <prvUnlockQueue>
    2ba2:	0e 94 e8 18 	call	0x31d0	; 0x31d0 <xTaskResumeAll>
    2ba6:	c8 01       	movw	r24, r16
    2ba8:	0e 94 51 13 	call	0x26a2	; 0x26a2 <prvIsQueueEmpty>
    2bac:	88 23       	and	r24, r24
    2bae:	59 f3       	breq	.-42     	; 0x2b86 <xQueueReceive+0xda>
    2bb0:	80 e0       	ldi	r24, 0x00	; 0
    2bb2:	0f 90       	pop	r0
    2bb4:	0f 90       	pop	r0
    2bb6:	0f 90       	pop	r0
    2bb8:	0f 90       	pop	r0
    2bba:	0f 90       	pop	r0
    2bbc:	df 91       	pop	r29
    2bbe:	cf 91       	pop	r28
    2bc0:	1f 91       	pop	r17
    2bc2:	0f 91       	pop	r16
    2bc4:	ff 90       	pop	r15
    2bc6:	df 90       	pop	r13
    2bc8:	cf 90       	pop	r12
    2bca:	bf 90       	pop	r11
    2bcc:	af 90       	pop	r10
    2bce:	08 95       	ret

00002bd0 <vQueueWaitForMessageRestricted>:
/*-----------------------------------------------------------*/

#if ( configUSE_TIMERS == 1 )

    void vQueueWaitForMessageRestricted( QueueHandle_t xQueue, TickType_t xTicksToWait, const BaseType_t xWaitIndefinitely )
    {
    2bd0:	cf 93       	push	r28
    2bd2:	df 93       	push	r29
    2bd4:	ec 01       	movw	r28, r24
        will not actually cause the task to block, just place it on a blocked
        list.  It will not block until the scheduler is unlocked - at which
        time a yield will be performed.  If an item is added to the queue while
        the queue is locked, and the calling task blocks on the queue, then the
        calling task will be immediately unblocked when the queue is unlocked. */
        prvLockQueue( pxQueue );
    2bd6:	0f b6       	in	r0, 0x3f	; 63
    2bd8:	f8 94       	cli
    2bda:	0f 92       	push	r0
    2bdc:	8d 8d       	ldd	r24, Y+29	; 0x1d
    2bde:	8f 3f       	cpi	r24, 0xFF	; 255
    2be0:	09 f4       	brne	.+2      	; 0x2be4 <vQueueWaitForMessageRestricted+0x14>
    2be2:	1d 8e       	std	Y+29, r1	; 0x1d
    2be4:	8e 8d       	ldd	r24, Y+30	; 0x1e
    2be6:	8f 3f       	cpi	r24, 0xFF	; 255
    2be8:	09 f4       	brne	.+2      	; 0x2bec <vQueueWaitForMessageRestricted+0x1c>
    2bea:	1e 8e       	std	Y+30, r1	; 0x1e
    2bec:	0f 90       	pop	r0
    2bee:	0f be       	out	0x3f, r0	; 63
        if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0U )
    2bf0:	8a 8d       	ldd	r24, Y+26	; 0x1a
    2bf2:	81 11       	cpse	r24, r1
    2bf4:	04 c0       	rjmp	.+8      	; 0x2bfe <vQueueWaitForMessageRestricted+0x2e>
        {
            /* There is nothing in the queue, block for the specified period. */
            vTaskPlaceOnEventListRestricted( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait, xWaitIndefinitely );
    2bf6:	ce 01       	movw	r24, r28
    2bf8:	41 96       	adiw	r24, 0x11	; 17
    2bfa:	0e 94 fe 19 	call	0x33fc	; 0x33fc <vTaskPlaceOnEventListRestricted>
        }
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }
        prvUnlockQueue( pxQueue );
    2bfe:	ce 01       	movw	r24, r28
    }
    2c00:	df 91       	pop	r29
    2c02:	cf 91       	pop	r28
        }
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }
        prvUnlockQueue( pxQueue );
    2c04:	0c 94 c9 13 	jmp	0x2792	; 0x2792 <prvUnlockQueue>

00002c08 <prvResetNextTaskUnblockTime>:
        {
            mtCOVERAGE_TEST_MARKER();
        }

        return xReturn;
    }
    2c08:	e0 91 43 05 	lds	r30, 0x0543	; 0x800543 <pxDelayedTaskList>
    2c0c:	f0 91 44 05 	lds	r31, 0x0544	; 0x800544 <pxDelayedTaskList+0x1>
    2c10:	80 81       	ld	r24, Z
    2c12:	81 11       	cpse	r24, r1
    2c14:	03 c0       	rjmp	.+6      	; 0x2c1c <prvResetNextTaskUnblockTime+0x14>
    2c16:	8f ef       	ldi	r24, 0xFF	; 255
    2c18:	9f ef       	ldi	r25, 0xFF	; 255
    2c1a:	0c c0       	rjmp	.+24     	; 0x2c34 <prvResetNextTaskUnblockTime+0x2c>
    2c1c:	e0 91 43 05 	lds	r30, 0x0543	; 0x800543 <pxDelayedTaskList>
    2c20:	f0 91 44 05 	lds	r31, 0x0544	; 0x800544 <pxDelayedTaskList+0x1>
    2c24:	05 80       	ldd	r0, Z+5	; 0x05
    2c26:	f6 81       	ldd	r31, Z+6	; 0x06
    2c28:	e0 2d       	mov	r30, r0
    2c2a:	06 80       	ldd	r0, Z+6	; 0x06
    2c2c:	f7 81       	ldd	r31, Z+7	; 0x07
    2c2e:	e0 2d       	mov	r30, r0
    2c30:	82 81       	ldd	r24, Z+2	; 0x02
    2c32:	93 81       	ldd	r25, Z+3	; 0x03
    2c34:	90 93 1b 05 	sts	0x051B, r25	; 0x80051b <xNextTaskUnblockTime+0x1>
    2c38:	80 93 1a 05 	sts	0x051A, r24	; 0x80051a <xNextTaskUnblockTime>
    2c3c:	08 95       	ret

00002c3e <prvAddCurrentTaskToDelayedList>:
    2c3e:	ff 92       	push	r15
    2c40:	0f 93       	push	r16
    2c42:	1f 93       	push	r17
    2c44:	cf 93       	push	r28
    2c46:	df 93       	push	r29
    2c48:	ec 01       	movw	r28, r24
    2c4a:	f6 2e       	mov	r15, r22
    2c4c:	00 91 22 05 	lds	r16, 0x0522	; 0x800522 <xTickCount>
    2c50:	10 91 23 05 	lds	r17, 0x0523	; 0x800523 <xTickCount+0x1>
    2c54:	80 91 7b 05 	lds	r24, 0x057B	; 0x80057b <pxCurrentTCB>
    2c58:	90 91 7c 05 	lds	r25, 0x057C	; 0x80057c <pxCurrentTCB+0x1>
    2c5c:	02 96       	adiw	r24, 0x02	; 2
    2c5e:	0e 94 14 1e 	call	0x3c28	; 0x3c28 <uxListRemove>
    2c62:	cf 3f       	cpi	r28, 0xFF	; 255
    2c64:	8f ef       	ldi	r24, 0xFF	; 255
    2c66:	d8 07       	cpc	r29, r24
    2c68:	89 f4       	brne	.+34     	; 0x2c8c <prvAddCurrentTaskToDelayedList+0x4e>
    2c6a:	ff 20       	and	r15, r15
    2c6c:	79 f0       	breq	.+30     	; 0x2c8c <prvAddCurrentTaskToDelayedList+0x4e>
    2c6e:	60 91 7b 05 	lds	r22, 0x057B	; 0x80057b <pxCurrentTCB>
    2c72:	70 91 7c 05 	lds	r23, 0x057C	; 0x80057c <pxCurrentTCB+0x1>
    2c76:	6e 5f       	subi	r22, 0xFE	; 254
    2c78:	7f 4f       	sbci	r23, 0xFF	; 255
    2c7a:	85 e2       	ldi	r24, 0x25	; 37
    2c7c:	95 e0       	ldi	r25, 0x05	; 5
    2c7e:	df 91       	pop	r29
    2c80:	cf 91       	pop	r28
    2c82:	1f 91       	pop	r17
    2c84:	0f 91       	pop	r16
    2c86:	ff 90       	pop	r15
    2c88:	0c 94 bb 1d 	jmp	0x3b76	; 0x3b76 <vListInsertEnd>
    2c8c:	c0 0f       	add	r28, r16
    2c8e:	d1 1f       	adc	r29, r17
    2c90:	e0 91 7b 05 	lds	r30, 0x057B	; 0x80057b <pxCurrentTCB>
    2c94:	f0 91 7c 05 	lds	r31, 0x057C	; 0x80057c <pxCurrentTCB+0x1>
    2c98:	d3 83       	std	Z+3, r29	; 0x03
    2c9a:	c2 83       	std	Z+2, r28	; 0x02
    2c9c:	60 91 7b 05 	lds	r22, 0x057B	; 0x80057b <pxCurrentTCB>
    2ca0:	70 91 7c 05 	lds	r23, 0x057C	; 0x80057c <pxCurrentTCB+0x1>
    2ca4:	c0 17       	cp	r28, r16
    2ca6:	d1 07       	cpc	r29, r17
    2ca8:	68 f4       	brcc	.+26     	; 0x2cc4 <prvAddCurrentTaskToDelayedList+0x86>
    2caa:	80 91 41 05 	lds	r24, 0x0541	; 0x800541 <pxOverflowDelayedTaskList>
    2cae:	90 91 42 05 	lds	r25, 0x0542	; 0x800542 <pxOverflowDelayedTaskList+0x1>
    2cb2:	6e 5f       	subi	r22, 0xFE	; 254
    2cb4:	7f 4f       	sbci	r23, 0xFF	; 255
    2cb6:	df 91       	pop	r29
    2cb8:	cf 91       	pop	r28
    2cba:	1f 91       	pop	r17
    2cbc:	0f 91       	pop	r16
    2cbe:	ff 90       	pop	r15
    2cc0:	0c 94 dc 1d 	jmp	0x3bb8	; 0x3bb8 <vListInsert>
    2cc4:	80 91 43 05 	lds	r24, 0x0543	; 0x800543 <pxDelayedTaskList>
    2cc8:	90 91 44 05 	lds	r25, 0x0544	; 0x800544 <pxDelayedTaskList+0x1>
    2ccc:	6e 5f       	subi	r22, 0xFE	; 254
    2cce:	7f 4f       	sbci	r23, 0xFF	; 255
    2cd0:	0e 94 dc 1d 	call	0x3bb8	; 0x3bb8 <vListInsert>
    2cd4:	80 91 1a 05 	lds	r24, 0x051A	; 0x80051a <xNextTaskUnblockTime>
    2cd8:	90 91 1b 05 	lds	r25, 0x051B	; 0x80051b <xNextTaskUnblockTime+0x1>
    2cdc:	c8 17       	cp	r28, r24
    2cde:	d9 07       	cpc	r29, r25
    2ce0:	20 f4       	brcc	.+8      	; 0x2cea <prvAddCurrentTaskToDelayedList+0xac>
    2ce2:	d0 93 1b 05 	sts	0x051B, r29	; 0x80051b <xNextTaskUnblockTime+0x1>
    2ce6:	c0 93 1a 05 	sts	0x051A, r28	; 0x80051a <xNextTaskUnblockTime>
    2cea:	df 91       	pop	r29
    2cec:	cf 91       	pop	r28
    2cee:	1f 91       	pop	r17
    2cf0:	0f 91       	pop	r16
    2cf2:	ff 90       	pop	r15
    2cf4:	08 95       	ret

00002cf6 <prvIdleTask>:
    2cf6:	80 91 2e 05 	lds	r24, 0x052E	; 0x80052e <uxDeletedTasksWaitingCleanUp>
    2cfa:	88 23       	and	r24, r24
    2cfc:	09 f1       	breq	.+66     	; 0x2d40 <prvIdleTask+0x4a>
    2cfe:	0f b6       	in	r0, 0x3f	; 63
    2d00:	f8 94       	cli
    2d02:	0f 92       	push	r0
    2d04:	e0 91 34 05 	lds	r30, 0x0534	; 0x800534 <xTasksWaitingTermination+0x5>
    2d08:	f0 91 35 05 	lds	r31, 0x0535	; 0x800535 <xTasksWaitingTermination+0x6>
    2d0c:	c6 81       	ldd	r28, Z+6	; 0x06
    2d0e:	d7 81       	ldd	r29, Z+7	; 0x07
    2d10:	ce 01       	movw	r24, r28
    2d12:	02 96       	adiw	r24, 0x02	; 2
    2d14:	0e 94 14 1e 	call	0x3c28	; 0x3c28 <uxListRemove>
    2d18:	80 91 24 05 	lds	r24, 0x0524	; 0x800524 <uxCurrentNumberOfTasks>
    2d1c:	81 50       	subi	r24, 0x01	; 1
    2d1e:	80 93 24 05 	sts	0x0524, r24	; 0x800524 <uxCurrentNumberOfTasks>
    2d22:	80 91 2e 05 	lds	r24, 0x052E	; 0x80052e <uxDeletedTasksWaitingCleanUp>
    2d26:	81 50       	subi	r24, 0x01	; 1
    2d28:	80 93 2e 05 	sts	0x052E, r24	; 0x80052e <uxDeletedTasksWaitingCleanUp>
    2d2c:	0f 90       	pop	r0
    2d2e:	0f be       	out	0x3f, r0	; 63
    2d30:	8f 89       	ldd	r24, Y+23	; 0x17
    2d32:	98 8d       	ldd	r25, Y+24	; 0x18
    2d34:	0e 94 98 1d 	call	0x3b30	; 0x3b30 <vPortFree>
    2d38:	ce 01       	movw	r24, r28
    2d3a:	0e 94 98 1d 	call	0x3b30	; 0x3b30 <vPortFree>
    2d3e:	db cf       	rjmp	.-74     	; 0x2cf6 <prvIdleTask>
    2d40:	80 91 57 05 	lds	r24, 0x0557	; 0x800557 <pxReadyTasksLists>
    2d44:	82 30       	cpi	r24, 0x02	; 2
    2d46:	10 f0       	brcs	.+4      	; 0x2d4c <prvIdleTask+0x56>
    2d48:	0e 94 dc 1e 	call	0x3db8	; 0x3db8 <vPortYield>
    2d4c:	0e 94 eb 1c 	call	0x39d6	; 0x39d6 <vApplicationIdleHook>
    2d50:	d2 cf       	rjmp	.-92     	; 0x2cf6 <prvIdleTask>

00002d52 <xTaskCreate>:
    2d52:	5f 92       	push	r5
    2d54:	6f 92       	push	r6
    2d56:	7f 92       	push	r7
    2d58:	8f 92       	push	r8
    2d5a:	9f 92       	push	r9
    2d5c:	af 92       	push	r10
    2d5e:	bf 92       	push	r11
    2d60:	cf 92       	push	r12
    2d62:	df 92       	push	r13
    2d64:	ef 92       	push	r14
    2d66:	ff 92       	push	r15
    2d68:	0f 93       	push	r16
    2d6a:	1f 93       	push	r17
    2d6c:	cf 93       	push	r28
    2d6e:	df 93       	push	r29
    2d70:	3c 01       	movw	r6, r24
    2d72:	6b 01       	movw	r12, r22
    2d74:	5a 01       	movw	r10, r20
    2d76:	49 01       	movw	r8, r18
    2d78:	50 2e       	mov	r5, r16
    2d7a:	ca 01       	movw	r24, r20
    2d7c:	0e 94 85 1d 	call	0x3b0a	; 0x3b0a <pvPortMalloc>
    2d80:	8c 01       	movw	r16, r24
    2d82:	89 2b       	or	r24, r25
    2d84:	09 f4       	brne	.+2      	; 0x2d88 <xTaskCreate+0x36>
    2d86:	e0 c0       	rjmp	.+448    	; 0x2f48 <xTaskCreate+0x1f6>
    2d88:	88 e2       	ldi	r24, 0x28	; 40
    2d8a:	90 e0       	ldi	r25, 0x00	; 0
    2d8c:	0e 94 85 1d 	call	0x3b0a	; 0x3b0a <pvPortMalloc>
    2d90:	ec 01       	movw	r28, r24
    2d92:	89 2b       	or	r24, r25
    2d94:	c9 f0       	breq	.+50     	; 0x2dc8 <xTaskCreate+0x76>
    2d96:	18 8f       	std	Y+24, r17	; 0x18
    2d98:	0f 8b       	std	Y+23, r16	; 0x17
    2d9a:	a5 01       	movw	r20, r10
    2d9c:	65 ea       	ldi	r22, 0xA5	; 165
    2d9e:	70 e0       	ldi	r23, 0x00	; 0
    2da0:	c8 01       	movw	r24, r16
    2da2:	0e 94 33 21 	call	0x4266	; 0x4266 <memset>
    2da6:	21 e0       	ldi	r18, 0x01	; 1
    2da8:	a2 1a       	sub	r10, r18
    2daa:	b1 08       	sbc	r11, r1
    2dac:	8f 89       	ldd	r24, Y+23	; 0x17
    2dae:	98 8d       	ldd	r25, Y+24	; 0x18
    2db0:	a8 0e       	add	r10, r24
    2db2:	b9 1e       	adc	r11, r25
    2db4:	c1 14       	cp	r12, r1
    2db6:	d1 04       	cpc	r13, r1
    2db8:	c9 f0       	breq	.+50     	; 0x2dec <xTaskCreate+0x9a>
    2dba:	be 01       	movw	r22, r28
    2dbc:	67 5e       	subi	r22, 0xE7	; 231
    2dbe:	7f 4f       	sbci	r23, 0xFF	; 255
    2dc0:	f6 01       	movw	r30, r12
    2dc2:	c6 01       	movw	r24, r12
    2dc4:	08 96       	adiw	r24, 0x08	; 8
    2dc6:	07 c0       	rjmp	.+14     	; 0x2dd6 <xTaskCreate+0x84>
    2dc8:	c8 01       	movw	r24, r16
    2dca:	0e 94 98 1d 	call	0x3b30	; 0x3b30 <vPortFree>
    2dce:	bc c0       	rjmp	.+376    	; 0x2f48 <xTaskCreate+0x1f6>
    2dd0:	e8 17       	cp	r30, r24
    2dd2:	f9 07       	cpc	r31, r25
    2dd4:	49 f0       	breq	.+18     	; 0x2de8 <xTaskCreate+0x96>
    2dd6:	9f 01       	movw	r18, r30
    2dd8:	41 91       	ld	r20, Z+
    2dda:	db 01       	movw	r26, r22
    2ddc:	4d 93       	st	X+, r20
    2dde:	bd 01       	movw	r22, r26
    2de0:	d9 01       	movw	r26, r18
    2de2:	2c 91       	ld	r18, X
    2de4:	21 11       	cpse	r18, r1
    2de6:	f4 cf       	rjmp	.-24     	; 0x2dd0 <xTaskCreate+0x7e>
    2de8:	18 a2       	std	Y+32, r1	; 0x20
    2dea:	01 c0       	rjmp	.+2      	; 0x2dee <xTaskCreate+0x9c>
    2dec:	19 8e       	std	Y+25, r1	; 0x19
    2dee:	05 2d       	mov	r16, r5
    2df0:	04 30       	cpi	r16, 0x04	; 4
    2df2:	08 f0       	brcs	.+2      	; 0x2df6 <xTaskCreate+0xa4>
    2df4:	03 e0       	ldi	r16, 0x03	; 3
    2df6:	0e 8b       	std	Y+22, r16	; 0x16
    2df8:	09 a3       	std	Y+33, r16	; 0x21
    2dfa:	1a a2       	std	Y+34, r1	; 0x22
    2dfc:	6e 01       	movw	r12, r28
    2dfe:	b2 e0       	ldi	r27, 0x02	; 2
    2e00:	cb 0e       	add	r12, r27
    2e02:	d1 1c       	adc	r13, r1
    2e04:	c6 01       	movw	r24, r12
    2e06:	0e 94 b7 1d 	call	0x3b6e	; 0x3b6e <vListInitialiseItem>
    2e0a:	ce 01       	movw	r24, r28
    2e0c:	0c 96       	adiw	r24, 0x0c	; 12
    2e0e:	0e 94 b7 1d 	call	0x3b6e	; 0x3b6e <vListInitialiseItem>
    2e12:	d9 87       	std	Y+9, r29	; 0x09
    2e14:	c8 87       	std	Y+8, r28	; 0x08
    2e16:	84 e0       	ldi	r24, 0x04	; 4
    2e18:	90 e0       	ldi	r25, 0x00	; 0
    2e1a:	80 1b       	sub	r24, r16
    2e1c:	91 09       	sbc	r25, r1
    2e1e:	9d 87       	std	Y+13, r25	; 0x0d
    2e20:	8c 87       	std	Y+12, r24	; 0x0c
    2e22:	db 8b       	std	Y+19, r29	; 0x13
    2e24:	ca 8b       	std	Y+18, r28	; 0x12
    2e26:	1b a2       	std	Y+35, r1	; 0x23
    2e28:	1c a2       	std	Y+36, r1	; 0x24
    2e2a:	1d a2       	std	Y+37, r1	; 0x25
    2e2c:	1e a2       	std	Y+38, r1	; 0x26
    2e2e:	1f a2       	std	Y+39, r1	; 0x27
    2e30:	a4 01       	movw	r20, r8
    2e32:	b3 01       	movw	r22, r6
    2e34:	c5 01       	movw	r24, r10
    2e36:	0e 94 38 1e 	call	0x3c70	; 0x3c70 <pxPortInitialiseStack>
    2e3a:	99 83       	std	Y+1, r25	; 0x01
    2e3c:	88 83       	st	Y, r24
    2e3e:	e1 14       	cp	r14, r1
    2e40:	f1 04       	cpc	r15, r1
    2e42:	19 f0       	breq	.+6      	; 0x2e4a <xTaskCreate+0xf8>
    2e44:	f7 01       	movw	r30, r14
    2e46:	d1 83       	std	Z+1, r29	; 0x01
    2e48:	c0 83       	st	Z, r28
    2e4a:	0f b6       	in	r0, 0x3f	; 63
    2e4c:	f8 94       	cli
    2e4e:	0f 92       	push	r0
    2e50:	80 91 24 05 	lds	r24, 0x0524	; 0x800524 <uxCurrentNumberOfTasks>
    2e54:	8f 5f       	subi	r24, 0xFF	; 255
    2e56:	80 93 24 05 	sts	0x0524, r24	; 0x800524 <uxCurrentNumberOfTasks>
    2e5a:	80 91 7b 05 	lds	r24, 0x057B	; 0x80057b <pxCurrentTCB>
    2e5e:	90 91 7c 05 	lds	r25, 0x057C	; 0x80057c <pxCurrentTCB+0x1>
    2e62:	89 2b       	or	r24, r25
    2e64:	d1 f5       	brne	.+116    	; 0x2eda <xTaskCreate+0x188>
    2e66:	d0 93 7c 05 	sts	0x057C, r29	; 0x80057c <pxCurrentTCB+0x1>
    2e6a:	c0 93 7b 05 	sts	0x057B, r28	; 0x80057b <pxCurrentTCB>
    2e6e:	80 91 24 05 	lds	r24, 0x0524	; 0x800524 <uxCurrentNumberOfTasks>
    2e72:	81 30       	cpi	r24, 0x01	; 1
    2e74:	09 f0       	breq	.+2      	; 0x2e78 <xTaskCreate+0x126>
    2e76:	41 c0       	rjmp	.+130    	; 0x2efa <xTaskCreate+0x1a8>
    2e78:	87 e5       	ldi	r24, 0x57	; 87
    2e7a:	95 e0       	ldi	r25, 0x05	; 5
    2e7c:	0e 94 a9 1d 	call	0x3b52	; 0x3b52 <vListInitialise>
    2e80:	80 e6       	ldi	r24, 0x60	; 96
    2e82:	95 e0       	ldi	r25, 0x05	; 5
    2e84:	0e 94 a9 1d 	call	0x3b52	; 0x3b52 <vListInitialise>
    2e88:	89 e6       	ldi	r24, 0x69	; 105
    2e8a:	95 e0       	ldi	r25, 0x05	; 5
    2e8c:	0e 94 a9 1d 	call	0x3b52	; 0x3b52 <vListInitialise>
    2e90:	82 e7       	ldi	r24, 0x72	; 114
    2e92:	95 e0       	ldi	r25, 0x05	; 5
    2e94:	0e 94 a9 1d 	call	0x3b52	; 0x3b52 <vListInitialise>
    2e98:	8e e4       	ldi	r24, 0x4E	; 78
    2e9a:	95 e0       	ldi	r25, 0x05	; 5
    2e9c:	0e 94 a9 1d 	call	0x3b52	; 0x3b52 <vListInitialise>
    2ea0:	85 e4       	ldi	r24, 0x45	; 69
    2ea2:	95 e0       	ldi	r25, 0x05	; 5
    2ea4:	0e 94 a9 1d 	call	0x3b52	; 0x3b52 <vListInitialise>
    2ea8:	88 e3       	ldi	r24, 0x38	; 56
    2eaa:	95 e0       	ldi	r25, 0x05	; 5
    2eac:	0e 94 a9 1d 	call	0x3b52	; 0x3b52 <vListInitialise>
    2eb0:	8f e2       	ldi	r24, 0x2F	; 47
    2eb2:	95 e0       	ldi	r25, 0x05	; 5
    2eb4:	0e 94 a9 1d 	call	0x3b52	; 0x3b52 <vListInitialise>
    2eb8:	85 e2       	ldi	r24, 0x25	; 37
    2eba:	95 e0       	ldi	r25, 0x05	; 5
    2ebc:	0e 94 a9 1d 	call	0x3b52	; 0x3b52 <vListInitialise>
    2ec0:	8e e4       	ldi	r24, 0x4E	; 78
    2ec2:	95 e0       	ldi	r25, 0x05	; 5
    2ec4:	90 93 44 05 	sts	0x0544, r25	; 0x800544 <pxDelayedTaskList+0x1>
    2ec8:	80 93 43 05 	sts	0x0543, r24	; 0x800543 <pxDelayedTaskList>
    2ecc:	85 e4       	ldi	r24, 0x45	; 69
    2ece:	95 e0       	ldi	r25, 0x05	; 5
    2ed0:	90 93 42 05 	sts	0x0542, r25	; 0x800542 <pxOverflowDelayedTaskList+0x1>
    2ed4:	80 93 41 05 	sts	0x0541, r24	; 0x800541 <pxOverflowDelayedTaskList>
    2ed8:	10 c0       	rjmp	.+32     	; 0x2efa <xTaskCreate+0x1a8>
    2eda:	80 91 20 05 	lds	r24, 0x0520	; 0x800520 <xSchedulerRunning>
    2ede:	81 11       	cpse	r24, r1
    2ee0:	0c c0       	rjmp	.+24     	; 0x2efa <xTaskCreate+0x1a8>
    2ee2:	e0 91 7b 05 	lds	r30, 0x057B	; 0x80057b <pxCurrentTCB>
    2ee6:	f0 91 7c 05 	lds	r31, 0x057C	; 0x80057c <pxCurrentTCB+0x1>
    2eea:	96 89       	ldd	r25, Z+22	; 0x16
    2eec:	8e 89       	ldd	r24, Y+22	; 0x16
    2eee:	89 17       	cp	r24, r25
    2ef0:	20 f0       	brcs	.+8      	; 0x2efa <xTaskCreate+0x1a8>
    2ef2:	d0 93 7c 05 	sts	0x057C, r29	; 0x80057c <pxCurrentTCB+0x1>
    2ef6:	c0 93 7b 05 	sts	0x057B, r28	; 0x80057b <pxCurrentTCB>
    2efa:	80 91 1c 05 	lds	r24, 0x051C	; 0x80051c <uxTaskNumber>
    2efe:	8f 5f       	subi	r24, 0xFF	; 255
    2f00:	80 93 1c 05 	sts	0x051C, r24	; 0x80051c <uxTaskNumber>
    2f04:	8e 89       	ldd	r24, Y+22	; 0x16
    2f06:	90 91 21 05 	lds	r25, 0x0521	; 0x800521 <uxTopReadyPriority>
    2f0a:	98 17       	cp	r25, r24
    2f0c:	10 f4       	brcc	.+4      	; 0x2f12 <xTaskCreate+0x1c0>
    2f0e:	80 93 21 05 	sts	0x0521, r24	; 0x800521 <uxTopReadyPriority>
    2f12:	f9 e0       	ldi	r31, 0x09	; 9
    2f14:	8f 9f       	mul	r24, r31
    2f16:	c0 01       	movw	r24, r0
    2f18:	11 24       	eor	r1, r1
    2f1a:	b6 01       	movw	r22, r12
    2f1c:	89 5a       	subi	r24, 0xA9	; 169
    2f1e:	9a 4f       	sbci	r25, 0xFA	; 250
    2f20:	0e 94 bb 1d 	call	0x3b76	; 0x3b76 <vListInsertEnd>
    2f24:	0f 90       	pop	r0
    2f26:	0f be       	out	0x3f, r0	; 63
    2f28:	80 91 20 05 	lds	r24, 0x0520	; 0x800520 <xSchedulerRunning>
    2f2c:	88 23       	and	r24, r24
    2f2e:	51 f0       	breq	.+20     	; 0x2f44 <xTaskCreate+0x1f2>
    2f30:	e0 91 7b 05 	lds	r30, 0x057B	; 0x80057b <pxCurrentTCB>
    2f34:	f0 91 7c 05 	lds	r31, 0x057C	; 0x80057c <pxCurrentTCB+0x1>
    2f38:	96 89       	ldd	r25, Z+22	; 0x16
    2f3a:	8e 89       	ldd	r24, Y+22	; 0x16
    2f3c:	98 17       	cp	r25, r24
    2f3e:	10 f4       	brcc	.+4      	; 0x2f44 <xTaskCreate+0x1f2>
    2f40:	0e 94 dc 1e 	call	0x3db8	; 0x3db8 <vPortYield>
    2f44:	81 e0       	ldi	r24, 0x01	; 1
    2f46:	01 c0       	rjmp	.+2      	; 0x2f4a <xTaskCreate+0x1f8>
    2f48:	8f ef       	ldi	r24, 0xFF	; 255
    2f4a:	df 91       	pop	r29
    2f4c:	cf 91       	pop	r28
    2f4e:	1f 91       	pop	r17
    2f50:	0f 91       	pop	r16
    2f52:	ff 90       	pop	r15
    2f54:	ef 90       	pop	r14
    2f56:	df 90       	pop	r13
    2f58:	cf 90       	pop	r12
    2f5a:	bf 90       	pop	r11
    2f5c:	af 90       	pop	r10
    2f5e:	9f 90       	pop	r9
    2f60:	8f 90       	pop	r8
    2f62:	7f 90       	pop	r7
    2f64:	6f 90       	pop	r6
    2f66:	5f 90       	pop	r5
    2f68:	08 95       	ret

00002f6a <vTaskResume>:
    2f6a:	0f 93       	push	r16
    2f6c:	1f 93       	push	r17
    2f6e:	cf 93       	push	r28
    2f70:	df 93       	push	r29
    2f72:	20 91 7b 05 	lds	r18, 0x057B	; 0x80057b <pxCurrentTCB>
    2f76:	30 91 7c 05 	lds	r19, 0x057C	; 0x80057c <pxCurrentTCB+0x1>
    2f7a:	82 17       	cp	r24, r18
    2f7c:	93 07       	cpc	r25, r19
    2f7e:	09 f4       	brne	.+2      	; 0x2f82 <vTaskResume+0x18>
    2f80:	38 c0       	rjmp	.+112    	; 0x2ff2 <vTaskResume+0x88>
    2f82:	00 97       	sbiw	r24, 0x00	; 0
    2f84:	09 f4       	brne	.+2      	; 0x2f88 <vTaskResume+0x1e>
    2f86:	35 c0       	rjmp	.+106    	; 0x2ff2 <vTaskResume+0x88>
    2f88:	0f b6       	in	r0, 0x3f	; 63
    2f8a:	f8 94       	cli
    2f8c:	0f 92       	push	r0
    2f8e:	fc 01       	movw	r30, r24
    2f90:	22 85       	ldd	r18, Z+10	; 0x0a
    2f92:	33 85       	ldd	r19, Z+11	; 0x0b
    2f94:	25 52       	subi	r18, 0x25	; 37
    2f96:	35 40       	sbci	r19, 0x05	; 5
    2f98:	51 f5       	brne	.+84     	; 0x2fee <vTaskResume+0x84>
    2f9a:	fc 01       	movw	r30, r24
    2f9c:	24 89       	ldd	r18, Z+20	; 0x14
    2f9e:	35 89       	ldd	r19, Z+21	; 0x15
    2fa0:	f5 e0       	ldi	r31, 0x05	; 5
    2fa2:	28 33       	cpi	r18, 0x38	; 56
    2fa4:	3f 07       	cpc	r19, r31
    2fa6:	19 f1       	breq	.+70     	; 0x2fee <vTaskResume+0x84>
    2fa8:	23 2b       	or	r18, r19
    2faa:	09 f5       	brne	.+66     	; 0x2fee <vTaskResume+0x84>
    2fac:	ec 01       	movw	r28, r24
    2fae:	8c 01       	movw	r16, r24
    2fb0:	0e 5f       	subi	r16, 0xFE	; 254
    2fb2:	1f 4f       	sbci	r17, 0xFF	; 255
    2fb4:	c8 01       	movw	r24, r16
    2fb6:	0e 94 14 1e 	call	0x3c28	; 0x3c28 <uxListRemove>
    2fba:	8e 89       	ldd	r24, Y+22	; 0x16
    2fbc:	90 91 21 05 	lds	r25, 0x0521	; 0x800521 <uxTopReadyPriority>
    2fc0:	98 17       	cp	r25, r24
    2fc2:	10 f4       	brcc	.+4      	; 0x2fc8 <vTaskResume+0x5e>
    2fc4:	80 93 21 05 	sts	0x0521, r24	; 0x800521 <uxTopReadyPriority>
    2fc8:	29 e0       	ldi	r18, 0x09	; 9
    2fca:	82 9f       	mul	r24, r18
    2fcc:	c0 01       	movw	r24, r0
    2fce:	11 24       	eor	r1, r1
    2fd0:	b8 01       	movw	r22, r16
    2fd2:	89 5a       	subi	r24, 0xA9	; 169
    2fd4:	9a 4f       	sbci	r25, 0xFA	; 250
    2fd6:	0e 94 bb 1d 	call	0x3b76	; 0x3b76 <vListInsertEnd>
    2fda:	e0 91 7b 05 	lds	r30, 0x057B	; 0x80057b <pxCurrentTCB>
    2fde:	f0 91 7c 05 	lds	r31, 0x057C	; 0x80057c <pxCurrentTCB+0x1>
    2fe2:	9e 89       	ldd	r25, Y+22	; 0x16
    2fe4:	86 89       	ldd	r24, Z+22	; 0x16
    2fe6:	98 17       	cp	r25, r24
    2fe8:	10 f0       	brcs	.+4      	; 0x2fee <vTaskResume+0x84>
    2fea:	0e 94 dc 1e 	call	0x3db8	; 0x3db8 <vPortYield>
    2fee:	0f 90       	pop	r0
    2ff0:	0f be       	out	0x3f, r0	; 63
    2ff2:	df 91       	pop	r29
    2ff4:	cf 91       	pop	r28
    2ff6:	1f 91       	pop	r17
    2ff8:	0f 91       	pop	r16
    2ffa:	08 95       	ret

00002ffc <vTaskStartScheduler>:
    2ffc:	ef 92       	push	r14
    2ffe:	ff 92       	push	r15
    3000:	0f 93       	push	r16
    3002:	88 e1       	ldi	r24, 0x18	; 24
    3004:	e8 2e       	mov	r14, r24
    3006:	85 e0       	ldi	r24, 0x05	; 5
    3008:	f8 2e       	mov	r15, r24
    300a:	00 e0       	ldi	r16, 0x00	; 0
    300c:	20 e0       	ldi	r18, 0x00	; 0
    300e:	30 e0       	ldi	r19, 0x00	; 0
    3010:	40 ec       	ldi	r20, 0xC0	; 192
    3012:	50 e0       	ldi	r21, 0x00	; 0
    3014:	6c ec       	ldi	r22, 0xCC	; 204
    3016:	72 e0       	ldi	r23, 0x02	; 2
    3018:	8b e7       	ldi	r24, 0x7B	; 123
    301a:	96 e1       	ldi	r25, 0x16	; 22
    301c:	0e 94 a9 16 	call	0x2d52	; 0x2d52 <xTaskCreate>
    3020:	81 30       	cpi	r24, 0x01	; 1
    3022:	b1 f4       	brne	.+44     	; 0x3050 <vTaskStartScheduler+0x54>
    3024:	0e 94 33 1b 	call	0x3666	; 0x3666 <xTimerCreateTimerTask>
    3028:	81 30       	cpi	r24, 0x01	; 1
    302a:	91 f4       	brne	.+36     	; 0x3050 <vTaskStartScheduler+0x54>
    302c:	f8 94       	cli
    302e:	2f ef       	ldi	r18, 0xFF	; 255
    3030:	3f ef       	ldi	r19, 0xFF	; 255
    3032:	30 93 1b 05 	sts	0x051B, r19	; 0x80051b <xNextTaskUnblockTime+0x1>
    3036:	20 93 1a 05 	sts	0x051A, r18	; 0x80051a <xNextTaskUnblockTime>
    303a:	80 93 20 05 	sts	0x0520, r24	; 0x800520 <xSchedulerRunning>
    303e:	10 92 23 05 	sts	0x0523, r1	; 0x800523 <xTickCount+0x1>
    3042:	10 92 22 05 	sts	0x0522, r1	; 0x800522 <xTickCount>
    3046:	0f 91       	pop	r16
    3048:	ff 90       	pop	r15
    304a:	ef 90       	pop	r14
    304c:	0c 94 a4 1e 	jmp	0x3d48	; 0x3d48 <xPortStartScheduler>
    3050:	0f 91       	pop	r16
    3052:	ff 90       	pop	r15
    3054:	ef 90       	pop	r14
    3056:	08 95       	ret

00003058 <vTaskSuspendAll>:
    3058:	80 91 17 05 	lds	r24, 0x0517	; 0x800517 <uxSchedulerSuspended>
    305c:	8f 5f       	subi	r24, 0xFF	; 255
    305e:	80 93 17 05 	sts	0x0517, r24	; 0x800517 <uxSchedulerSuspended>
    3062:	08 95       	ret

00003064 <xTaskGetTickCount>:
    3064:	0f b6       	in	r0, 0x3f	; 63
    3066:	f8 94       	cli
    3068:	0f 92       	push	r0
    306a:	80 91 22 05 	lds	r24, 0x0522	; 0x800522 <xTickCount>
    306e:	90 91 23 05 	lds	r25, 0x0523	; 0x800523 <xTickCount+0x1>
    3072:	0f 90       	pop	r0
    3074:	0f be       	out	0x3f, r0	; 63
    3076:	08 95       	ret

00003078 <xTaskIncrementTick>:
    3078:	cf 92       	push	r12
    307a:	df 92       	push	r13
    307c:	ef 92       	push	r14
    307e:	ff 92       	push	r15
    3080:	0f 93       	push	r16
    3082:	1f 93       	push	r17
    3084:	cf 93       	push	r28
    3086:	df 93       	push	r29
    3088:	80 91 17 05 	lds	r24, 0x0517	; 0x800517 <uxSchedulerSuspended>
    308c:	81 11       	cpse	r24, r1
    308e:	8c c0       	rjmp	.+280    	; 0x31a8 <xTaskIncrementTick+0x130>
    3090:	00 91 22 05 	lds	r16, 0x0522	; 0x800522 <xTickCount>
    3094:	10 91 23 05 	lds	r17, 0x0523	; 0x800523 <xTickCount+0x1>
    3098:	0f 5f       	subi	r16, 0xFF	; 255
    309a:	1f 4f       	sbci	r17, 0xFF	; 255
    309c:	10 93 23 05 	sts	0x0523, r17	; 0x800523 <xTickCount+0x1>
    30a0:	00 93 22 05 	sts	0x0522, r16	; 0x800522 <xTickCount>
    30a4:	01 15       	cp	r16, r1
    30a6:	11 05       	cpc	r17, r1
    30a8:	b9 f4       	brne	.+46     	; 0x30d8 <xTaskIncrementTick+0x60>
    30aa:	80 91 43 05 	lds	r24, 0x0543	; 0x800543 <pxDelayedTaskList>
    30ae:	90 91 44 05 	lds	r25, 0x0544	; 0x800544 <pxDelayedTaskList+0x1>
    30b2:	20 91 41 05 	lds	r18, 0x0541	; 0x800541 <pxOverflowDelayedTaskList>
    30b6:	30 91 42 05 	lds	r19, 0x0542	; 0x800542 <pxOverflowDelayedTaskList+0x1>
    30ba:	30 93 44 05 	sts	0x0544, r19	; 0x800544 <pxDelayedTaskList+0x1>
    30be:	20 93 43 05 	sts	0x0543, r18	; 0x800543 <pxDelayedTaskList>
    30c2:	90 93 42 05 	sts	0x0542, r25	; 0x800542 <pxOverflowDelayedTaskList+0x1>
    30c6:	80 93 41 05 	sts	0x0541, r24	; 0x800541 <pxOverflowDelayedTaskList>
    30ca:	80 91 1d 05 	lds	r24, 0x051D	; 0x80051d <xNumOfOverflows>
    30ce:	8f 5f       	subi	r24, 0xFF	; 255
    30d0:	80 93 1d 05 	sts	0x051D, r24	; 0x80051d <xNumOfOverflows>
    30d4:	0e 94 04 16 	call	0x2c08	; 0x2c08 <prvResetNextTaskUnblockTime>
    30d8:	80 91 1a 05 	lds	r24, 0x051A	; 0x80051a <xNextTaskUnblockTime>
    30dc:	90 91 1b 05 	lds	r25, 0x051B	; 0x80051b <xNextTaskUnblockTime+0x1>
    30e0:	c0 e0       	ldi	r28, 0x00	; 0
    30e2:	08 17       	cp	r16, r24
    30e4:	19 07       	cpc	r17, r25
    30e6:	08 f4       	brcc	.+2      	; 0x30ea <xTaskIncrementTick+0x72>
    30e8:	4f c0       	rjmp	.+158    	; 0x3188 <xTaskIncrementTick+0x110>
    30ea:	d9 e0       	ldi	r29, 0x09	; 9
    30ec:	e0 91 43 05 	lds	r30, 0x0543	; 0x800543 <pxDelayedTaskList>
    30f0:	f0 91 44 05 	lds	r31, 0x0544	; 0x800544 <pxDelayedTaskList+0x1>
    30f4:	80 81       	ld	r24, Z
    30f6:	81 11       	cpse	r24, r1
    30f8:	03 c0       	rjmp	.+6      	; 0x3100 <xTaskIncrementTick+0x88>
    30fa:	8f ef       	ldi	r24, 0xFF	; 255
    30fc:	9f ef       	ldi	r25, 0xFF	; 255
    30fe:	11 c0       	rjmp	.+34     	; 0x3122 <xTaskIncrementTick+0xaa>
    3100:	e0 91 43 05 	lds	r30, 0x0543	; 0x800543 <pxDelayedTaskList>
    3104:	f0 91 44 05 	lds	r31, 0x0544	; 0x800544 <pxDelayedTaskList+0x1>
    3108:	05 80       	ldd	r0, Z+5	; 0x05
    310a:	f6 81       	ldd	r31, Z+6	; 0x06
    310c:	e0 2d       	mov	r30, r0
    310e:	e6 80       	ldd	r14, Z+6	; 0x06
    3110:	f7 80       	ldd	r15, Z+7	; 0x07
    3112:	d7 01       	movw	r26, r14
    3114:	12 96       	adiw	r26, 0x02	; 2
    3116:	8d 91       	ld	r24, X+
    3118:	9c 91       	ld	r25, X
    311a:	13 97       	sbiw	r26, 0x03	; 3
    311c:	08 17       	cp	r16, r24
    311e:	19 07       	cpc	r17, r25
    3120:	28 f4       	brcc	.+10     	; 0x312c <xTaskIncrementTick+0xb4>
    3122:	90 93 1b 05 	sts	0x051B, r25	; 0x80051b <xNextTaskUnblockTime+0x1>
    3126:	80 93 1a 05 	sts	0x051A, r24	; 0x80051a <xNextTaskUnblockTime>
    312a:	2e c0       	rjmp	.+92     	; 0x3188 <xTaskIncrementTick+0x110>
    312c:	67 01       	movw	r12, r14
    312e:	b2 e0       	ldi	r27, 0x02	; 2
    3130:	cb 0e       	add	r12, r27
    3132:	d1 1c       	adc	r13, r1
    3134:	c6 01       	movw	r24, r12
    3136:	0e 94 14 1e 	call	0x3c28	; 0x3c28 <uxListRemove>
    313a:	f7 01       	movw	r30, r14
    313c:	84 89       	ldd	r24, Z+20	; 0x14
    313e:	95 89       	ldd	r25, Z+21	; 0x15
    3140:	89 2b       	or	r24, r25
    3142:	21 f0       	breq	.+8      	; 0x314c <xTaskIncrementTick+0xd4>
    3144:	c7 01       	movw	r24, r14
    3146:	0c 96       	adiw	r24, 0x0c	; 12
    3148:	0e 94 14 1e 	call	0x3c28	; 0x3c28 <uxListRemove>
    314c:	d7 01       	movw	r26, r14
    314e:	56 96       	adiw	r26, 0x16	; 22
    3150:	8c 91       	ld	r24, X
    3152:	90 91 21 05 	lds	r25, 0x0521	; 0x800521 <uxTopReadyPriority>
    3156:	98 17       	cp	r25, r24
    3158:	10 f4       	brcc	.+4      	; 0x315e <xTaskIncrementTick+0xe6>
    315a:	80 93 21 05 	sts	0x0521, r24	; 0x800521 <uxTopReadyPriority>
    315e:	d8 9f       	mul	r29, r24
    3160:	c0 01       	movw	r24, r0
    3162:	11 24       	eor	r1, r1
    3164:	b6 01       	movw	r22, r12
    3166:	89 5a       	subi	r24, 0xA9	; 169
    3168:	9a 4f       	sbci	r25, 0xFA	; 250
    316a:	0e 94 bb 1d 	call	0x3b76	; 0x3b76 <vListInsertEnd>
    316e:	e0 91 7b 05 	lds	r30, 0x057B	; 0x80057b <pxCurrentTCB>
    3172:	f0 91 7c 05 	lds	r31, 0x057C	; 0x80057c <pxCurrentTCB+0x1>
    3176:	d7 01       	movw	r26, r14
    3178:	56 96       	adiw	r26, 0x16	; 22
    317a:	9c 91       	ld	r25, X
    317c:	86 89       	ldd	r24, Z+22	; 0x16
    317e:	98 17       	cp	r25, r24
    3180:	08 f4       	brcc	.+2      	; 0x3184 <xTaskIncrementTick+0x10c>
    3182:	b4 cf       	rjmp	.-152    	; 0x30ec <xTaskIncrementTick+0x74>
    3184:	c1 e0       	ldi	r28, 0x01	; 1
    3186:	b2 cf       	rjmp	.-156    	; 0x30ec <xTaskIncrementTick+0x74>
    3188:	e0 91 7b 05 	lds	r30, 0x057B	; 0x80057b <pxCurrentTCB>
    318c:	f0 91 7c 05 	lds	r31, 0x057C	; 0x80057c <pxCurrentTCB+0x1>
    3190:	e6 89       	ldd	r30, Z+22	; 0x16
    3192:	b9 e0       	ldi	r27, 0x09	; 9
    3194:	eb 9f       	mul	r30, r27
    3196:	f0 01       	movw	r30, r0
    3198:	11 24       	eor	r1, r1
    319a:	e9 5a       	subi	r30, 0xA9	; 169
    319c:	fa 4f       	sbci	r31, 0xFA	; 250
    319e:	80 81       	ld	r24, Z
    31a0:	82 30       	cpi	r24, 0x02	; 2
    31a2:	40 f0       	brcs	.+16     	; 0x31b4 <xTaskIncrementTick+0x13c>
    31a4:	c1 e0       	ldi	r28, 0x01	; 1
    31a6:	06 c0       	rjmp	.+12     	; 0x31b4 <xTaskIncrementTick+0x13c>
    31a8:	80 91 1f 05 	lds	r24, 0x051F	; 0x80051f <uxPendedTicks>
    31ac:	8f 5f       	subi	r24, 0xFF	; 255
    31ae:	80 93 1f 05 	sts	0x051F, r24	; 0x80051f <uxPendedTicks>
    31b2:	c0 e0       	ldi	r28, 0x00	; 0
    31b4:	80 91 1e 05 	lds	r24, 0x051E	; 0x80051e <xYieldPending>
    31b8:	81 11       	cpse	r24, r1
    31ba:	c1 e0       	ldi	r28, 0x01	; 1
    31bc:	8c 2f       	mov	r24, r28
    31be:	df 91       	pop	r29
    31c0:	cf 91       	pop	r28
    31c2:	1f 91       	pop	r17
    31c4:	0f 91       	pop	r16
    31c6:	ff 90       	pop	r15
    31c8:	ef 90       	pop	r14
    31ca:	df 90       	pop	r13
    31cc:	cf 90       	pop	r12
    31ce:	08 95       	ret

000031d0 <xTaskResumeAll>:
    31d0:	ef 92       	push	r14
    31d2:	ff 92       	push	r15
    31d4:	0f 93       	push	r16
    31d6:	1f 93       	push	r17
    31d8:	cf 93       	push	r28
    31da:	df 93       	push	r29
    31dc:	0f b6       	in	r0, 0x3f	; 63
    31de:	f8 94       	cli
    31e0:	0f 92       	push	r0
    31e2:	80 91 17 05 	lds	r24, 0x0517	; 0x800517 <uxSchedulerSuspended>
    31e6:	81 50       	subi	r24, 0x01	; 1
    31e8:	80 93 17 05 	sts	0x0517, r24	; 0x800517 <uxSchedulerSuspended>
    31ec:	80 91 17 05 	lds	r24, 0x0517	; 0x800517 <uxSchedulerSuspended>
    31f0:	88 23       	and	r24, r24
    31f2:	11 f0       	breq	.+4      	; 0x31f8 <xTaskResumeAll+0x28>
    31f4:	80 e0       	ldi	r24, 0x00	; 0
    31f6:	52 c0       	rjmp	.+164    	; 0x329c <xTaskResumeAll+0xcc>
    31f8:	80 91 24 05 	lds	r24, 0x0524	; 0x800524 <uxCurrentNumberOfTasks>
    31fc:	88 23       	and	r24, r24
    31fe:	d1 f3       	breq	.-12     	; 0x31f4 <xTaskResumeAll+0x24>
    3200:	c0 e0       	ldi	r28, 0x00	; 0
    3202:	d0 e0       	ldi	r29, 0x00	; 0
    3204:	89 e0       	ldi	r24, 0x09	; 9
    3206:	f8 2e       	mov	r15, r24
    3208:	ee 24       	eor	r14, r14
    320a:	e3 94       	inc	r14
    320c:	80 91 38 05 	lds	r24, 0x0538	; 0x800538 <xPendingReadyList>
    3210:	88 23       	and	r24, r24
    3212:	51 f1       	breq	.+84     	; 0x3268 <xTaskResumeAll+0x98>
    3214:	e0 91 3d 05 	lds	r30, 0x053D	; 0x80053d <xPendingReadyList+0x5>
    3218:	f0 91 3e 05 	lds	r31, 0x053E	; 0x80053e <xPendingReadyList+0x6>
    321c:	c6 81       	ldd	r28, Z+6	; 0x06
    321e:	d7 81       	ldd	r29, Z+7	; 0x07
    3220:	ce 01       	movw	r24, r28
    3222:	0c 96       	adiw	r24, 0x0c	; 12
    3224:	0e 94 14 1e 	call	0x3c28	; 0x3c28 <uxListRemove>
    3228:	8e 01       	movw	r16, r28
    322a:	0e 5f       	subi	r16, 0xFE	; 254
    322c:	1f 4f       	sbci	r17, 0xFF	; 255
    322e:	c8 01       	movw	r24, r16
    3230:	0e 94 14 1e 	call	0x3c28	; 0x3c28 <uxListRemove>
    3234:	8e 89       	ldd	r24, Y+22	; 0x16
    3236:	90 91 21 05 	lds	r25, 0x0521	; 0x800521 <uxTopReadyPriority>
    323a:	98 17       	cp	r25, r24
    323c:	10 f4       	brcc	.+4      	; 0x3242 <xTaskResumeAll+0x72>
    323e:	80 93 21 05 	sts	0x0521, r24	; 0x800521 <uxTopReadyPriority>
    3242:	f8 9e       	mul	r15, r24
    3244:	c0 01       	movw	r24, r0
    3246:	11 24       	eor	r1, r1
    3248:	b8 01       	movw	r22, r16
    324a:	89 5a       	subi	r24, 0xA9	; 169
    324c:	9a 4f       	sbci	r25, 0xFA	; 250
    324e:	0e 94 bb 1d 	call	0x3b76	; 0x3b76 <vListInsertEnd>
    3252:	e0 91 7b 05 	lds	r30, 0x057B	; 0x80057b <pxCurrentTCB>
    3256:	f0 91 7c 05 	lds	r31, 0x057C	; 0x80057c <pxCurrentTCB+0x1>
    325a:	9e 89       	ldd	r25, Y+22	; 0x16
    325c:	86 89       	ldd	r24, Z+22	; 0x16
    325e:	98 17       	cp	r25, r24
    3260:	a8 f2       	brcs	.-86     	; 0x320c <xTaskResumeAll+0x3c>
    3262:	e0 92 1e 05 	sts	0x051E, r14	; 0x80051e <xYieldPending>
    3266:	d2 cf       	rjmp	.-92     	; 0x320c <xTaskResumeAll+0x3c>
    3268:	cd 2b       	or	r28, r29
    326a:	11 f0       	breq	.+4      	; 0x3270 <xTaskResumeAll+0xa0>
    326c:	0e 94 04 16 	call	0x2c08	; 0x2c08 <prvResetNextTaskUnblockTime>
    3270:	c0 91 1f 05 	lds	r28, 0x051F	; 0x80051f <uxPendedTicks>
    3274:	cc 23       	and	r28, r28
    3276:	51 f0       	breq	.+20     	; 0x328c <xTaskResumeAll+0xbc>
    3278:	d1 e0       	ldi	r29, 0x01	; 1
    327a:	0e 94 3c 18 	call	0x3078	; 0x3078 <xTaskIncrementTick>
    327e:	81 11       	cpse	r24, r1
    3280:	d0 93 1e 05 	sts	0x051E, r29	; 0x80051e <xYieldPending>
    3284:	c1 50       	subi	r28, 0x01	; 1
    3286:	c9 f7       	brne	.-14     	; 0x327a <xTaskResumeAll+0xaa>
    3288:	10 92 1f 05 	sts	0x051F, r1	; 0x80051f <uxPendedTicks>
    328c:	80 91 1e 05 	lds	r24, 0x051E	; 0x80051e <xYieldPending>
    3290:	88 23       	and	r24, r24
    3292:	09 f4       	brne	.+2      	; 0x3296 <xTaskResumeAll+0xc6>
    3294:	af cf       	rjmp	.-162    	; 0x31f4 <xTaskResumeAll+0x24>
    3296:	0e 94 dc 1e 	call	0x3db8	; 0x3db8 <vPortYield>
    329a:	81 e0       	ldi	r24, 0x01	; 1
    329c:	0f 90       	pop	r0
    329e:	0f be       	out	0x3f, r0	; 63
    32a0:	df 91       	pop	r29
    32a2:	cf 91       	pop	r28
    32a4:	1f 91       	pop	r17
    32a6:	0f 91       	pop	r16
    32a8:	ff 90       	pop	r15
    32aa:	ef 90       	pop	r14
    32ac:	08 95       	ret

000032ae <vTaskDelayUntil>:
    32ae:	0f 93       	push	r16
    32b0:	1f 93       	push	r17
    32b2:	cf 93       	push	r28
    32b4:	df 93       	push	r29
    32b6:	8c 01       	movw	r16, r24
    32b8:	eb 01       	movw	r28, r22
    32ba:	0e 94 2c 18 	call	0x3058	; 0x3058 <vTaskSuspendAll>
    32be:	40 91 22 05 	lds	r20, 0x0522	; 0x800522 <xTickCount>
    32c2:	50 91 23 05 	lds	r21, 0x0523	; 0x800523 <xTickCount+0x1>
    32c6:	f8 01       	movw	r30, r16
    32c8:	20 81       	ld	r18, Z
    32ca:	31 81       	ldd	r19, Z+1	; 0x01
    32cc:	c9 01       	movw	r24, r18
    32ce:	8c 0f       	add	r24, r28
    32d0:	9d 1f       	adc	r25, r29
    32d2:	42 17       	cp	r20, r18
    32d4:	53 07       	cpc	r21, r19
    32d6:	20 f4       	brcc	.+8      	; 0x32e0 <vTaskDelayUntil+0x32>
    32d8:	82 17       	cp	r24, r18
    32da:	93 07       	cpc	r25, r19
    32dc:	40 f4       	brcc	.+16     	; 0x32ee <vTaskDelayUntil+0x40>
    32de:	03 c0       	rjmp	.+6      	; 0x32e6 <vTaskDelayUntil+0x38>
    32e0:	82 17       	cp	r24, r18
    32e2:	93 07       	cpc	r25, r19
    32e4:	30 f0       	brcs	.+12     	; 0x32f2 <vTaskDelayUntil+0x44>
    32e6:	21 e0       	ldi	r18, 0x01	; 1
    32e8:	48 17       	cp	r20, r24
    32ea:	59 07       	cpc	r21, r25
    32ec:	18 f0       	brcs	.+6      	; 0x32f4 <vTaskDelayUntil+0x46>
    32ee:	20 e0       	ldi	r18, 0x00	; 0
    32f0:	01 c0       	rjmp	.+2      	; 0x32f4 <vTaskDelayUntil+0x46>
    32f2:	21 e0       	ldi	r18, 0x01	; 1
    32f4:	f8 01       	movw	r30, r16
    32f6:	91 83       	std	Z+1, r25	; 0x01
    32f8:	80 83       	st	Z, r24
    32fa:	22 23       	and	r18, r18
    32fc:	29 f0       	breq	.+10     	; 0x3308 <vTaskDelayUntil+0x5a>
    32fe:	60 e0       	ldi	r22, 0x00	; 0
    3300:	84 1b       	sub	r24, r20
    3302:	95 0b       	sbc	r25, r21
    3304:	0e 94 1f 16 	call	0x2c3e	; 0x2c3e <prvAddCurrentTaskToDelayedList>
    3308:	0e 94 e8 18 	call	0x31d0	; 0x31d0 <xTaskResumeAll>
    330c:	81 11       	cpse	r24, r1
    330e:	02 c0       	rjmp	.+4      	; 0x3314 <vTaskDelayUntil+0x66>
    3310:	0e 94 dc 1e 	call	0x3db8	; 0x3db8 <vPortYield>
    3314:	df 91       	pop	r29
    3316:	cf 91       	pop	r28
    3318:	1f 91       	pop	r17
    331a:	0f 91       	pop	r16
    331c:	08 95       	ret

0000331e <vTaskSwitchContext>:
    331e:	80 91 17 05 	lds	r24, 0x0517	; 0x800517 <uxSchedulerSuspended>
    3322:	88 23       	and	r24, r24
    3324:	21 f0       	breq	.+8      	; 0x332e <vTaskSwitchContext+0x10>
    3326:	81 e0       	ldi	r24, 0x01	; 1
    3328:	80 93 1e 05 	sts	0x051E, r24	; 0x80051e <xYieldPending>
    332c:	08 95       	ret
    332e:	10 92 1e 05 	sts	0x051E, r1	; 0x80051e <xYieldPending>
    3332:	a0 91 7b 05 	lds	r26, 0x057B	; 0x80057b <pxCurrentTCB>
    3336:	b0 91 7c 05 	lds	r27, 0x057C	; 0x80057c <pxCurrentTCB+0x1>
    333a:	e0 91 7b 05 	lds	r30, 0x057B	; 0x80057b <pxCurrentTCB>
    333e:	f0 91 7c 05 	lds	r31, 0x057C	; 0x80057c <pxCurrentTCB+0x1>
    3342:	2d 91       	ld	r18, X+
    3344:	3c 91       	ld	r19, X
    3346:	87 89       	ldd	r24, Z+23	; 0x17
    3348:	90 8d       	ldd	r25, Z+24	; 0x18
    334a:	82 17       	cp	r24, r18
    334c:	93 07       	cpc	r25, r19
    334e:	60 f0       	brcs	.+24     	; 0x3368 <vTaskSwitchContext+0x4a>
    3350:	60 91 7b 05 	lds	r22, 0x057B	; 0x80057b <pxCurrentTCB>
    3354:	70 91 7c 05 	lds	r23, 0x057C	; 0x80057c <pxCurrentTCB+0x1>
    3358:	80 91 7b 05 	lds	r24, 0x057B	; 0x80057b <pxCurrentTCB>
    335c:	90 91 7c 05 	lds	r25, 0x057C	; 0x80057c <pxCurrentTCB+0x1>
    3360:	67 5e       	subi	r22, 0xE7	; 231
    3362:	7f 4f       	sbci	r23, 0xFF	; 255
    3364:	0e 94 01 1d 	call	0x3a02	; 0x3a02 <vApplicationStackOverflowHook>
    3368:	80 91 21 05 	lds	r24, 0x0521	; 0x800521 <uxTopReadyPriority>
    336c:	69 e0       	ldi	r22, 0x09	; 9
    336e:	48 2f       	mov	r20, r24
    3370:	50 e0       	ldi	r21, 0x00	; 0
    3372:	64 9f       	mul	r22, r20
    3374:	90 01       	movw	r18, r0
    3376:	65 9f       	mul	r22, r21
    3378:	30 0d       	add	r19, r0
    337a:	11 24       	eor	r1, r1
    337c:	f9 01       	movw	r30, r18
    337e:	e9 5a       	subi	r30, 0xA9	; 169
    3380:	fa 4f       	sbci	r31, 0xFA	; 250
    3382:	90 81       	ld	r25, Z
    3384:	91 11       	cpse	r25, r1
    3386:	02 c0       	rjmp	.+4      	; 0x338c <vTaskSwitchContext+0x6e>
    3388:	81 50       	subi	r24, 0x01	; 1
    338a:	f1 cf       	rjmp	.-30     	; 0x336e <vTaskSwitchContext+0x50>
    338c:	a1 81       	ldd	r26, Z+1	; 0x01
    338e:	b2 81       	ldd	r27, Z+2	; 0x02
    3390:	12 96       	adiw	r26, 0x02	; 2
    3392:	0d 90       	ld	r0, X+
    3394:	bc 91       	ld	r27, X
    3396:	a0 2d       	mov	r26, r0
    3398:	b2 83       	std	Z+2, r27	; 0x02
    339a:	a1 83       	std	Z+1, r26	; 0x01
    339c:	26 5a       	subi	r18, 0xA6	; 166
    339e:	3a 4f       	sbci	r19, 0xFA	; 250
    33a0:	a2 17       	cp	r26, r18
    33a2:	b3 07       	cpc	r27, r19
    33a4:	31 f4       	brne	.+12     	; 0x33b2 <vTaskSwitchContext+0x94>
    33a6:	12 96       	adiw	r26, 0x02	; 2
    33a8:	2d 91       	ld	r18, X+
    33aa:	3c 91       	ld	r19, X
    33ac:	13 97       	sbiw	r26, 0x03	; 3
    33ae:	32 83       	std	Z+2, r19	; 0x02
    33b0:	21 83       	std	Z+1, r18	; 0x01
    33b2:	99 e0       	ldi	r25, 0x09	; 9
    33b4:	94 9f       	mul	r25, r20
    33b6:	f0 01       	movw	r30, r0
    33b8:	95 9f       	mul	r25, r21
    33ba:	f0 0d       	add	r31, r0
    33bc:	11 24       	eor	r1, r1
    33be:	e9 5a       	subi	r30, 0xA9	; 169
    33c0:	fa 4f       	sbci	r31, 0xFA	; 250
    33c2:	01 80       	ldd	r0, Z+1	; 0x01
    33c4:	f2 81       	ldd	r31, Z+2	; 0x02
    33c6:	e0 2d       	mov	r30, r0
    33c8:	26 81       	ldd	r18, Z+6	; 0x06
    33ca:	37 81       	ldd	r19, Z+7	; 0x07
    33cc:	30 93 7c 05 	sts	0x057C, r19	; 0x80057c <pxCurrentTCB+0x1>
    33d0:	20 93 7b 05 	sts	0x057B, r18	; 0x80057b <pxCurrentTCB>
    33d4:	80 93 21 05 	sts	0x0521, r24	; 0x800521 <uxTopReadyPriority>
    33d8:	08 95       	ret

000033da <vTaskPlaceOnEventList>:
    33da:	cf 93       	push	r28
    33dc:	df 93       	push	r29
    33de:	eb 01       	movw	r28, r22
    33e0:	60 91 7b 05 	lds	r22, 0x057B	; 0x80057b <pxCurrentTCB>
    33e4:	70 91 7c 05 	lds	r23, 0x057C	; 0x80057c <pxCurrentTCB+0x1>
    33e8:	64 5f       	subi	r22, 0xF4	; 244
    33ea:	7f 4f       	sbci	r23, 0xFF	; 255
    33ec:	0e 94 dc 1d 	call	0x3bb8	; 0x3bb8 <vListInsert>
    33f0:	61 e0       	ldi	r22, 0x01	; 1
    33f2:	ce 01       	movw	r24, r28
    33f4:	df 91       	pop	r29
    33f6:	cf 91       	pop	r28
    33f8:	0c 94 1f 16 	jmp	0x2c3e	; 0x2c3e <prvAddCurrentTaskToDelayedList>

000033fc <vTaskPlaceOnEventListRestricted>:
    33fc:	1f 93       	push	r17
    33fe:	cf 93       	push	r28
    3400:	df 93       	push	r29
    3402:	eb 01       	movw	r28, r22
    3404:	14 2f       	mov	r17, r20
    3406:	60 91 7b 05 	lds	r22, 0x057B	; 0x80057b <pxCurrentTCB>
    340a:	70 91 7c 05 	lds	r23, 0x057C	; 0x80057c <pxCurrentTCB+0x1>
    340e:	64 5f       	subi	r22, 0xF4	; 244
    3410:	7f 4f       	sbci	r23, 0xFF	; 255
    3412:	0e 94 bb 1d 	call	0x3b76	; 0x3b76 <vListInsertEnd>
    3416:	11 23       	and	r17, r17
    3418:	11 f0       	breq	.+4      	; 0x341e <vTaskPlaceOnEventListRestricted+0x22>
    341a:	cf ef       	ldi	r28, 0xFF	; 255
    341c:	df ef       	ldi	r29, 0xFF	; 255
    341e:	61 2f       	mov	r22, r17
    3420:	ce 01       	movw	r24, r28
    3422:	df 91       	pop	r29
    3424:	cf 91       	pop	r28
    3426:	1f 91       	pop	r17
    3428:	0c 94 1f 16 	jmp	0x2c3e	; 0x2c3e <prvAddCurrentTaskToDelayedList>

0000342c <xTaskRemoveFromEventList>:
    342c:	0f 93       	push	r16
    342e:	1f 93       	push	r17
    3430:	cf 93       	push	r28
    3432:	df 93       	push	r29
    3434:	dc 01       	movw	r26, r24
    3436:	15 96       	adiw	r26, 0x05	; 5
    3438:	ed 91       	ld	r30, X+
    343a:	fc 91       	ld	r31, X
    343c:	16 97       	sbiw	r26, 0x06	; 6
    343e:	c6 81       	ldd	r28, Z+6	; 0x06
    3440:	d7 81       	ldd	r29, Z+7	; 0x07
    3442:	8e 01       	movw	r16, r28
    3444:	04 5f       	subi	r16, 0xF4	; 244
    3446:	1f 4f       	sbci	r17, 0xFF	; 255
    3448:	c8 01       	movw	r24, r16
    344a:	0e 94 14 1e 	call	0x3c28	; 0x3c28 <uxListRemove>
    344e:	80 91 17 05 	lds	r24, 0x0517	; 0x800517 <uxSchedulerSuspended>
    3452:	81 11       	cpse	r24, r1
    3454:	14 c0       	rjmp	.+40     	; 0x347e <xTaskRemoveFromEventList+0x52>
    3456:	0a 50       	subi	r16, 0x0A	; 10
    3458:	11 09       	sbc	r17, r1
    345a:	c8 01       	movw	r24, r16
    345c:	0e 94 14 1e 	call	0x3c28	; 0x3c28 <uxListRemove>
    3460:	8e 89       	ldd	r24, Y+22	; 0x16
    3462:	90 91 21 05 	lds	r25, 0x0521	; 0x800521 <uxTopReadyPriority>
    3466:	98 17       	cp	r25, r24
    3468:	10 f4       	brcc	.+4      	; 0x346e <xTaskRemoveFromEventList+0x42>
    346a:	80 93 21 05 	sts	0x0521, r24	; 0x800521 <uxTopReadyPriority>
    346e:	b9 e0       	ldi	r27, 0x09	; 9
    3470:	8b 9f       	mul	r24, r27
    3472:	c0 01       	movw	r24, r0
    3474:	11 24       	eor	r1, r1
    3476:	b8 01       	movw	r22, r16
    3478:	89 5a       	subi	r24, 0xA9	; 169
    347a:	9a 4f       	sbci	r25, 0xFA	; 250
    347c:	03 c0       	rjmp	.+6      	; 0x3484 <xTaskRemoveFromEventList+0x58>
    347e:	b8 01       	movw	r22, r16
    3480:	88 e3       	ldi	r24, 0x38	; 56
    3482:	95 e0       	ldi	r25, 0x05	; 5
    3484:	0e 94 bb 1d 	call	0x3b76	; 0x3b76 <vListInsertEnd>
    3488:	e0 91 7b 05 	lds	r30, 0x057B	; 0x80057b <pxCurrentTCB>
    348c:	f0 91 7c 05 	lds	r31, 0x057C	; 0x80057c <pxCurrentTCB+0x1>
    3490:	9e 89       	ldd	r25, Y+22	; 0x16
    3492:	86 89       	ldd	r24, Z+22	; 0x16
    3494:	89 17       	cp	r24, r25
    3496:	20 f4       	brcc	.+8      	; 0x34a0 <xTaskRemoveFromEventList+0x74>
    3498:	81 e0       	ldi	r24, 0x01	; 1
    349a:	80 93 1e 05 	sts	0x051E, r24	; 0x80051e <xYieldPending>
    349e:	01 c0       	rjmp	.+2      	; 0x34a2 <xTaskRemoveFromEventList+0x76>
    34a0:	80 e0       	ldi	r24, 0x00	; 0
    34a2:	df 91       	pop	r29
    34a4:	cf 91       	pop	r28
    34a6:	1f 91       	pop	r17
    34a8:	0f 91       	pop	r16
    34aa:	08 95       	ret

000034ac <vTaskInternalSetTimeOutState>:
    34ac:	20 91 1d 05 	lds	r18, 0x051D	; 0x80051d <xNumOfOverflows>
    34b0:	fc 01       	movw	r30, r24
    34b2:	20 83       	st	Z, r18
    34b4:	20 91 22 05 	lds	r18, 0x0522	; 0x800522 <xTickCount>
    34b8:	30 91 23 05 	lds	r19, 0x0523	; 0x800523 <xTickCount+0x1>
    34bc:	32 83       	std	Z+2, r19	; 0x02
    34be:	21 83       	std	Z+1, r18	; 0x01
    34c0:	08 95       	ret

000034c2 <xTaskCheckForTimeOut>:
    34c2:	cf 93       	push	r28
    34c4:	df 93       	push	r29
    34c6:	0f b6       	in	r0, 0x3f	; 63
    34c8:	f8 94       	cli
    34ca:	0f 92       	push	r0
    34cc:	40 91 22 05 	lds	r20, 0x0522	; 0x800522 <xTickCount>
    34d0:	50 91 23 05 	lds	r21, 0x0523	; 0x800523 <xTickCount+0x1>
    34d4:	db 01       	movw	r26, r22
    34d6:	2d 91       	ld	r18, X+
    34d8:	3c 91       	ld	r19, X
    34da:	2f 3f       	cpi	r18, 0xFF	; 255
    34dc:	bf ef       	ldi	r27, 0xFF	; 255
    34de:	3b 07       	cpc	r19, r27
    34e0:	d9 f0       	breq	.+54     	; 0x3518 <xTaskCheckForTimeOut+0x56>
    34e2:	ec 01       	movw	r28, r24
    34e4:	e9 81       	ldd	r30, Y+1	; 0x01
    34e6:	fa 81       	ldd	r31, Y+2	; 0x02
    34e8:	a0 91 1d 05 	lds	r26, 0x051D	; 0x80051d <xNumOfOverflows>
    34ec:	b8 81       	ld	r27, Y
    34ee:	ba 17       	cp	r27, r26
    34f0:	19 f0       	breq	.+6      	; 0x34f8 <xTaskCheckForTimeOut+0x36>
    34f2:	4e 17       	cp	r20, r30
    34f4:	5f 07       	cpc	r21, r31
    34f6:	90 f4       	brcc	.+36     	; 0x351c <xTaskCheckForTimeOut+0x5a>
    34f8:	4e 1b       	sub	r20, r30
    34fa:	5f 0b       	sbc	r21, r31
    34fc:	fb 01       	movw	r30, r22
    34fe:	42 17       	cp	r20, r18
    3500:	53 07       	cpc	r21, r19
    3502:	38 f4       	brcc	.+14     	; 0x3512 <xTaskCheckForTimeOut+0x50>
    3504:	24 1b       	sub	r18, r20
    3506:	35 0b       	sbc	r19, r21
    3508:	31 83       	std	Z+1, r19	; 0x01
    350a:	20 83       	st	Z, r18
    350c:	0e 94 56 1a 	call	0x34ac	; 0x34ac <vTaskInternalSetTimeOutState>
    3510:	03 c0       	rjmp	.+6      	; 0x3518 <xTaskCheckForTimeOut+0x56>
    3512:	11 82       	std	Z+1, r1	; 0x01
    3514:	10 82       	st	Z, r1
    3516:	02 c0       	rjmp	.+4      	; 0x351c <xTaskCheckForTimeOut+0x5a>
    3518:	80 e0       	ldi	r24, 0x00	; 0
    351a:	01 c0       	rjmp	.+2      	; 0x351e <xTaskCheckForTimeOut+0x5c>
    351c:	81 e0       	ldi	r24, 0x01	; 1
    351e:	0f 90       	pop	r0
    3520:	0f be       	out	0x3f, r0	; 63
    3522:	df 91       	pop	r29
    3524:	cf 91       	pop	r28
    3526:	08 95       	ret

00003528 <vTaskMissedYield>:
    3528:	81 e0       	ldi	r24, 0x01	; 1
    352a:	80 93 1e 05 	sts	0x051E, r24	; 0x80051e <xYieldPending>
    352e:	08 95       	ret

00003530 <xTaskGetSchedulerState>:
    3530:	80 91 20 05 	lds	r24, 0x0520	; 0x800520 <xSchedulerRunning>
    3534:	88 23       	and	r24, r24
    3536:	31 f0       	breq	.+12     	; 0x3544 <xTaskGetSchedulerState+0x14>
    3538:	80 91 17 05 	lds	r24, 0x0517	; 0x800517 <uxSchedulerSuspended>
    353c:	88 23       	and	r24, r24
    353e:	21 f0       	breq	.+8      	; 0x3548 <xTaskGetSchedulerState+0x18>
    3540:	80 e0       	ldi	r24, 0x00	; 0
    3542:	08 95       	ret
    3544:	81 e0       	ldi	r24, 0x01	; 1
    3546:	08 95       	ret
    3548:	82 e0       	ldi	r24, 0x02	; 2
    354a:	08 95       	ret

0000354c <xTaskPriorityDisinherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

    BaseType_t xTaskPriorityDisinherit( TaskHandle_t const pxMutexHolder )
    {
    354c:	0f 93       	push	r16
    354e:	1f 93       	push	r17
    3550:	cf 93       	push	r28
    3552:	df 93       	push	r29
    3554:	fc 01       	movw	r30, r24
    TCB_t * const pxTCB = pxMutexHolder;
    BaseType_t xReturn = pdFALSE;

        if( pxMutexHolder != NULL )
    3556:	89 2b       	or	r24, r25
    3558:	11 f4       	brne	.+4      	; 0x355e <xTaskPriorityDisinherit+0x12>
#if ( configUSE_MUTEXES == 1 )

    BaseType_t xTaskPriorityDisinherit( TaskHandle_t const pxMutexHolder )
    {
    TCB_t * const pxTCB = pxMutexHolder;
    BaseType_t xReturn = pdFALSE;
    355a:	80 e0       	ldi	r24, 0x00	; 0
    355c:	2c c0       	rjmp	.+88     	; 0x35b6 <xTaskPriorityDisinherit+0x6a>
            If the mutex is held by a task then it cannot be given from an
            interrupt, and if a mutex is given by the holding task then it must
            be the running state task. */
            configASSERT( pxTCB == pxCurrentTCB );
            configASSERT( pxTCB->uxMutexesHeld );
            ( pxTCB->uxMutexesHeld )--;
    355e:	82 a1       	ldd	r24, Z+34	; 0x22
    3560:	81 50       	subi	r24, 0x01	; 1
    3562:	82 a3       	std	Z+34, r24	; 0x22

            /* Has the holder of the mutex inherited the priority of another
            task? */
            if( pxTCB->uxPriority != pxTCB->uxBasePriority )
    3564:	26 89       	ldd	r18, Z+22	; 0x16
    3566:	91 a1       	ldd	r25, Z+33	; 0x21
    3568:	29 17       	cp	r18, r25
    356a:	b9 f3       	breq	.-18     	; 0x355a <xTaskPriorityDisinherit+0xe>
            {
                /* Only disinherit if no other mutexes are held. */
                if( pxTCB->uxMutexesHeld == ( UBaseType_t ) 0 )
    356c:	81 11       	cpse	r24, r1
    356e:	f5 cf       	rjmp	.-22     	; 0x355a <xTaskPriorityDisinherit+0xe>
    3570:	ef 01       	movw	r28, r30
                    /* A task can only have an inherited priority if it holds
                    the mutex.  If the mutex is held by a task then it cannot be
                    given from an interrupt, and if a mutex is given by the
                    holding task then it must be the running state task.  Remove
                    the holding task from the ready list. */
                    if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    3572:	8f 01       	movw	r16, r30
    3574:	0e 5f       	subi	r16, 0xFE	; 254
    3576:	1f 4f       	sbci	r17, 0xFF	; 255
    3578:	c8 01       	movw	r24, r16
    357a:	0e 94 14 1e 	call	0x3c28	; 0x3c28 <uxListRemove>
                    }

                    /* Disinherit the priority before adding the task into the
                    new    ready list. */
                    traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
                    pxTCB->uxPriority = pxTCB->uxBasePriority;
    357e:	89 a1       	ldd	r24, Y+33	; 0x21
    3580:	8e 8b       	std	Y+22, r24	; 0x16

                    /* Reset the event list item value.  It cannot be in use for
                    any other purpose if this task is running, and it must be
                    running to give back the mutex. */
                    listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    3582:	48 2f       	mov	r20, r24
    3584:	50 e0       	ldi	r21, 0x00	; 0
    3586:	24 e0       	ldi	r18, 0x04	; 4
    3588:	30 e0       	ldi	r19, 0x00	; 0
    358a:	24 1b       	sub	r18, r20
    358c:	35 0b       	sbc	r19, r21
    358e:	3d 87       	std	Y+13, r19	; 0x0d
    3590:	2c 87       	std	Y+12, r18	; 0x0c
                    prvAddTaskToReadyList( pxTCB );
    3592:	90 91 21 05 	lds	r25, 0x0521	; 0x800521 <uxTopReadyPriority>
    3596:	98 17       	cp	r25, r24
    3598:	10 f4       	brcc	.+4      	; 0x359e <xTaskPriorityDisinherit+0x52>
    359a:	80 93 21 05 	sts	0x0521, r24	; 0x800521 <uxTopReadyPriority>
    359e:	29 e0       	ldi	r18, 0x09	; 9
    35a0:	24 9f       	mul	r18, r20
    35a2:	c0 01       	movw	r24, r0
    35a4:	25 9f       	mul	r18, r21
    35a6:	90 0d       	add	r25, r0
    35a8:	11 24       	eor	r1, r1
    35aa:	b8 01       	movw	r22, r16
    35ac:	89 5a       	subi	r24, 0xA9	; 169
    35ae:	9a 4f       	sbci	r25, 0xFA	; 250
    35b0:	0e 94 bb 1d 	call	0x3b76	; 0x3b76 <vListInsertEnd>
                    in an order different to that in which they were taken.
                    If a context switch did not occur when the first mutex was
                    returned, even if a task was waiting on it, then a context
                    switch should occur when the last mutex is returned whether
                    a task is waiting on it or not. */
                    xReturn = pdTRUE;
    35b4:	81 e0       	ldi	r24, 0x01	; 1
        {
            mtCOVERAGE_TEST_MARKER();
        }

        return xReturn;
    }
    35b6:	df 91       	pop	r29
    35b8:	cf 91       	pop	r28
    35ba:	1f 91       	pop	r17
    35bc:	0f 91       	pop	r16
    35be:	08 95       	ret

000035c0 <prvCheckForValidListAndQueue>:
            pxNewTimer->ucStatus = 0x00;
            prvInitialiseNewTimer( pcTimerName, xTimerPeriodInTicks, uxAutoReload, pvTimerID, pxCallbackFunction, pxNewTimer );
        }

        return pxNewTimer;
    }
    35c0:	0f b6       	in	r0, 0x3f	; 63
    35c2:	f8 94       	cli
    35c4:	0f 92       	push	r0
    35c6:	80 91 81 05 	lds	r24, 0x0581	; 0x800581 <xTimerQueue>
    35ca:	90 91 82 05 	lds	r25, 0x0582	; 0x800582 <xTimerQueue+0x1>
    35ce:	89 2b       	or	r24, r25
    35d0:	e9 f4       	brne	.+58     	; 0x360c <prvCheckForValidListAndQueue+0x4c>
    35d2:	80 e9       	ldi	r24, 0x90	; 144
    35d4:	95 e0       	ldi	r25, 0x05	; 5
    35d6:	0e 94 a9 1d 	call	0x3b52	; 0x3b52 <vListInitialise>
    35da:	87 e8       	ldi	r24, 0x87	; 135
    35dc:	95 e0       	ldi	r25, 0x05	; 5
    35de:	0e 94 a9 1d 	call	0x3b52	; 0x3b52 <vListInitialise>
    35e2:	80 e9       	ldi	r24, 0x90	; 144
    35e4:	95 e0       	ldi	r25, 0x05	; 5
    35e6:	90 93 86 05 	sts	0x0586, r25	; 0x800586 <pxCurrentTimerList+0x1>
    35ea:	80 93 85 05 	sts	0x0585, r24	; 0x800585 <pxCurrentTimerList>
    35ee:	87 e8       	ldi	r24, 0x87	; 135
    35f0:	95 e0       	ldi	r25, 0x05	; 5
    35f2:	90 93 84 05 	sts	0x0584, r25	; 0x800584 <pxOverflowTimerList+0x1>
    35f6:	80 93 83 05 	sts	0x0583, r24	; 0x800583 <pxOverflowTimerList>
    35fa:	40 e0       	ldi	r20, 0x00	; 0
    35fc:	65 e0       	ldi	r22, 0x05	; 5
    35fe:	8a e0       	ldi	r24, 0x0A	; 10
    3600:	0e 94 46 14 	call	0x288c	; 0x288c <xQueueGenericCreate>
    3604:	90 93 82 05 	sts	0x0582, r25	; 0x800582 <xTimerQueue+0x1>
    3608:	80 93 81 05 	sts	0x0581, r24	; 0x800581 <xTimerQueue>
    360c:	0f 90       	pop	r0
    360e:	0f be       	out	0x3f, r0	; 63
    3610:	08 95       	ret

00003612 <prvInsertTimerInActiveList>:
    3612:	fc 01       	movw	r30, r24
    3614:	73 83       	std	Z+3, r23	; 0x03
    3616:	62 83       	std	Z+2, r22	; 0x02
    3618:	91 87       	std	Z+9, r25	; 0x09
    361a:	80 87       	std	Z+8, r24	; 0x08
    361c:	46 17       	cp	r20, r22
    361e:	57 07       	cpc	r21, r23
    3620:	78 f0       	brcs	.+30     	; 0x3640 <prvInsertTimerInActiveList+0x2e>
    3622:	42 1b       	sub	r20, r18
    3624:	53 0b       	sbc	r21, r19
    3626:	84 85       	ldd	r24, Z+12	; 0x0c
    3628:	95 85       	ldd	r25, Z+13	; 0x0d
    362a:	48 17       	cp	r20, r24
    362c:	59 07       	cpc	r21, r25
    362e:	c8 f4       	brcc	.+50     	; 0x3662 <prvInsertTimerInActiveList+0x50>
    3630:	bf 01       	movw	r22, r30
    3632:	6e 5f       	subi	r22, 0xFE	; 254
    3634:	7f 4f       	sbci	r23, 0xFF	; 255
    3636:	80 91 83 05 	lds	r24, 0x0583	; 0x800583 <pxOverflowTimerList>
    363a:	90 91 84 05 	lds	r25, 0x0584	; 0x800584 <pxOverflowTimerList+0x1>
    363e:	0d c0       	rjmp	.+26     	; 0x365a <prvInsertTimerInActiveList+0x48>
    3640:	42 17       	cp	r20, r18
    3642:	53 07       	cpc	r21, r19
    3644:	18 f4       	brcc	.+6      	; 0x364c <prvInsertTimerInActiveList+0x3a>
    3646:	62 17       	cp	r22, r18
    3648:	73 07       	cpc	r23, r19
    364a:	58 f4       	brcc	.+22     	; 0x3662 <prvInsertTimerInActiveList+0x50>
    364c:	bf 01       	movw	r22, r30
    364e:	6e 5f       	subi	r22, 0xFE	; 254
    3650:	7f 4f       	sbci	r23, 0xFF	; 255
    3652:	80 91 85 05 	lds	r24, 0x0585	; 0x800585 <pxCurrentTimerList>
    3656:	90 91 86 05 	lds	r25, 0x0586	; 0x800586 <pxCurrentTimerList+0x1>
    365a:	0e 94 dc 1d 	call	0x3bb8	; 0x3bb8 <vListInsert>
    365e:	80 e0       	ldi	r24, 0x00	; 0
    3660:	08 95       	ret
    3662:	81 e0       	ldi	r24, 0x01	; 1
    3664:	08 95       	ret

00003666 <xTimerCreateTimerTask>:
    3666:	ef 92       	push	r14
    3668:	ff 92       	push	r15
    366a:	0f 93       	push	r16
    366c:	0e 94 e0 1a 	call	0x35c0	; 0x35c0 <prvCheckForValidListAndQueue>
    3670:	80 91 81 05 	lds	r24, 0x0581	; 0x800581 <xTimerQueue>
    3674:	90 91 82 05 	lds	r25, 0x0582	; 0x800582 <xTimerQueue+0x1>
    3678:	89 2b       	or	r24, r25
    367a:	81 f0       	breq	.+32     	; 0x369c <xTimerCreateTimerTask+0x36>
    367c:	8f e7       	ldi	r24, 0x7F	; 127
    367e:	e8 2e       	mov	r14, r24
    3680:	85 e0       	ldi	r24, 0x05	; 5
    3682:	f8 2e       	mov	r15, r24
    3684:	03 e0       	ldi	r16, 0x03	; 3
    3686:	20 e0       	ldi	r18, 0x00	; 0
    3688:	30 e0       	ldi	r19, 0x00	; 0
    368a:	45 e5       	ldi	r20, 0x55	; 85
    368c:	50 e0       	ldi	r21, 0x00	; 0
    368e:	61 ed       	ldi	r22, 0xD1	; 209
    3690:	72 e0       	ldi	r23, 0x02	; 2
    3692:	83 ee       	ldi	r24, 0xE3	; 227
    3694:	9b e1       	ldi	r25, 0x1B	; 27
    3696:	0e 94 a9 16 	call	0x2d52	; 0x2d52 <xTaskCreate>
    369a:	01 c0       	rjmp	.+2      	; 0x369e <xTimerCreateTimerTask+0x38>
    369c:	80 e0       	ldi	r24, 0x00	; 0
    369e:	0f 91       	pop	r16
    36a0:	ff 90       	pop	r15
    36a2:	ef 90       	pop	r14
    36a4:	08 95       	ret

000036a6 <xTimerGenericCommand>:
    }
}
/*-----------------------------------------------------------*/

BaseType_t xTimerGenericCommand( TimerHandle_t xTimer, const BaseType_t xCommandID, const TickType_t xOptionalValue, BaseType_t * const pxHigherPriorityTaskWoken, const TickType_t xTicksToWait )
{
    36a6:	0f 93       	push	r16
    36a8:	1f 93       	push	r17
    36aa:	cf 93       	push	r28
    36ac:	df 93       	push	r29
    36ae:	00 d0       	rcall	.+0      	; 0x36b0 <xTimerGenericCommand+0xa>
    36b0:	00 d0       	rcall	.+0      	; 0x36b2 <xTimerGenericCommand+0xc>
    36b2:	1f 92       	push	r1
    36b4:	cd b7       	in	r28, 0x3d	; 61
    36b6:	de b7       	in	r29, 0x3e	; 62

    configASSERT( xTimer );

    /* Send a message to the timer service task to perform a particular action
    on a particular timer definition. */
    if( xTimerQueue != NULL )
    36b8:	a0 91 81 05 	lds	r26, 0x0581	; 0x800581 <xTimerQueue>
    36bc:	b0 91 82 05 	lds	r27, 0x0582	; 0x800582 <xTimerQueue+0x1>
    36c0:	10 97       	sbiw	r26, 0x00	; 0
    36c2:	29 f1       	breq	.+74     	; 0x370e <xTimerGenericCommand+0x68>
    36c4:	f9 01       	movw	r30, r18
    {
        /* Send a command to the timer service task to start the xTimer timer. */
        xMessage.xMessageID = xCommandID;
    36c6:	69 83       	std	Y+1, r22	; 0x01
        xMessage.u.xTimerParameters.xMessageValue = xOptionalValue;
    36c8:	5b 83       	std	Y+3, r21	; 0x03
    36ca:	4a 83       	std	Y+2, r20	; 0x02
        xMessage.u.xTimerParameters.pxTimer = xTimer;
    36cc:	9d 83       	std	Y+5, r25	; 0x05
    36ce:	8c 83       	std	Y+4, r24	; 0x04

        if( xCommandID < tmrFIRST_FROM_ISR_COMMAND )
    36d0:	66 30       	cpi	r22, 0x06	; 6
    36d2:	a4 f4       	brge	.+40     	; 0x36fc <xTimerGenericCommand+0x56>
        {
            if( xTaskGetSchedulerState() == taskSCHEDULER_RUNNING )
    36d4:	0e 94 98 1a 	call	0x3530	; 0x3530 <xTaskGetSchedulerState>
    36d8:	e0 91 81 05 	lds	r30, 0x0581	; 0x800581 <xTimerQueue>
    36dc:	f0 91 82 05 	lds	r31, 0x0582	; 0x800582 <xTimerQueue+0x1>
            {
                xReturn = xQueueSendToBack( xTimerQueue, &xMessage, xTicksToWait );
    36e0:	20 e0       	ldi	r18, 0x00	; 0
        xMessage.u.xTimerParameters.xMessageValue = xOptionalValue;
        xMessage.u.xTimerParameters.pxTimer = xTimer;

        if( xCommandID < tmrFIRST_FROM_ISR_COMMAND )
        {
            if( xTaskGetSchedulerState() == taskSCHEDULER_RUNNING )
    36e2:	82 30       	cpi	r24, 0x02	; 2
    36e4:	11 f4       	brne	.+4      	; 0x36ea <xTimerGenericCommand+0x44>
            {
                xReturn = xQueueSendToBack( xTimerQueue, &xMessage, xTicksToWait );
    36e6:	a8 01       	movw	r20, r16
    36e8:	02 c0       	rjmp	.+4      	; 0x36ee <xTimerGenericCommand+0x48>
            }
            else
            {
                xReturn = xQueueSendToBack( xTimerQueue, &xMessage, tmrNO_DELAY );
    36ea:	40 e0       	ldi	r20, 0x00	; 0
    36ec:	50 e0       	ldi	r21, 0x00	; 0
    36ee:	be 01       	movw	r22, r28
    36f0:	6f 5f       	subi	r22, 0xFF	; 255
    36f2:	7f 4f       	sbci	r23, 0xFF	; 255
    36f4:	cf 01       	movw	r24, r30
    36f6:	0e 94 6e 14 	call	0x28dc	; 0x28dc <xQueueGenericSend>
    36fa:	0a c0       	rjmp	.+20     	; 0x3710 <xTimerGenericCommand+0x6a>
            }
        }
        else
        {
            xReturn = xQueueSendToBackFromISR( xTimerQueue, &xMessage, pxHigherPriorityTaskWoken );
    36fc:	20 e0       	ldi	r18, 0x00	; 0
    36fe:	af 01       	movw	r20, r30
    3700:	be 01       	movw	r22, r28
    3702:	6f 5f       	subi	r22, 0xFF	; 255
    3704:	7f 4f       	sbci	r23, 0xFF	; 255
    3706:	cd 01       	movw	r24, r26
    3708:	0e 94 04 15 	call	0x2a08	; 0x2a08 <xQueueGenericSendFromISR>
    370c:	01 c0       	rjmp	.+2      	; 0x3710 <xTimerGenericCommand+0x6a>
}
/*-----------------------------------------------------------*/

BaseType_t xTimerGenericCommand( TimerHandle_t xTimer, const BaseType_t xCommandID, const TickType_t xOptionalValue, BaseType_t * const pxHigherPriorityTaskWoken, const TickType_t xTicksToWait )
{
BaseType_t xReturn = pdFAIL;
    370e:	80 e0       	ldi	r24, 0x00	; 0
    {
        mtCOVERAGE_TEST_MARKER();
    }

    return xReturn;
}
    3710:	0f 90       	pop	r0
    3712:	0f 90       	pop	r0
    3714:	0f 90       	pop	r0
    3716:	0f 90       	pop	r0
    3718:	0f 90       	pop	r0
    371a:	df 91       	pop	r29
    371c:	cf 91       	pop	r28
    371e:	1f 91       	pop	r17
    3720:	0f 91       	pop	r16
    3722:	08 95       	ret

00003724 <prvSwitchTimerLists>:
    }
}
/*-----------------------------------------------------------*/

static void prvSwitchTimerLists( void )
{
    3724:	ef 92       	push	r14
    3726:	ff 92       	push	r15
    3728:	0f 93       	push	r16
    372a:	1f 93       	push	r17
    372c:	cf 93       	push	r28
    372e:	df 93       	push	r29

    /* The tick count has overflowed.  The timer lists must be switched.
    If there are any timers still referenced from the current timer list
    then they must have expired and should be processed before the lists
    are switched. */
    while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
    3730:	e0 91 85 05 	lds	r30, 0x0585	; 0x800585 <pxCurrentTimerList>
    3734:	f0 91 86 05 	lds	r31, 0x0586	; 0x800586 <pxCurrentTimerList+0x1>
    3738:	80 81       	ld	r24, Z
    373a:	88 23       	and	r24, r24
    373c:	89 f1       	breq	.+98     	; 0x37a0 <prvSwitchTimerLists+0x7c>
    {
        xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
    373e:	05 80       	ldd	r0, Z+5	; 0x05
    3740:	f6 81       	ldd	r31, Z+6	; 0x06
    3742:	e0 2d       	mov	r30, r0
    3744:	e0 80       	ld	r14, Z
    3746:	f1 80       	ldd	r15, Z+1	; 0x01

        /* Remove the timer from the list. */
        pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList ); /*lint !e9087 !e9079 void * is used as this macro is used with tasks and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    3748:	c6 81       	ldd	r28, Z+6	; 0x06
    374a:	d7 81       	ldd	r29, Z+7	; 0x07
        ( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
    374c:	8e 01       	movw	r16, r28
    374e:	0e 5f       	subi	r16, 0xFE	; 254
    3750:	1f 4f       	sbci	r17, 0xFF	; 255
    3752:	c8 01       	movw	r24, r16
    3754:	0e 94 14 1e 	call	0x3c28	; 0x3c28 <uxListRemove>
        traceTIMER_EXPIRED( pxTimer );

        /* Execute its callback, then send a command to restart the timer if
        it is an auto-reload timer.  It cannot be restarted here as the lists
        have not yet been switched. */
        pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
    3758:	e8 89       	ldd	r30, Y+16	; 0x10
    375a:	f9 89       	ldd	r31, Y+17	; 0x11
    375c:	ce 01       	movw	r24, r28
    375e:	09 95       	icall

        if( ( pxTimer->ucStatus & tmrSTATUS_IS_AUTORELOAD ) != 0 )
    3760:	8a 89       	ldd	r24, Y+18	; 0x12
    3762:	82 ff       	sbrs	r24, 2
    3764:	e5 cf       	rjmp	.-54     	; 0x3730 <prvSwitchTimerLists+0xc>
            the timer going into the same timer list then it has already expired
            and the timer should be re-inserted into the current list so it is
            processed again within this loop.  Otherwise a command should be sent
            to restart the timer to ensure it is only inserted into a list after
            the lists have been swapped. */
            xReloadTime = ( xNextExpireTime + pxTimer->xTimerPeriodInTicks );
    3766:	8c 85       	ldd	r24, Y+12	; 0x0c
    3768:	9d 85       	ldd	r25, Y+13	; 0x0d
    376a:	8e 0d       	add	r24, r14
    376c:	9f 1d       	adc	r25, r15
            if( xReloadTime > xNextExpireTime )
    376e:	e8 16       	cp	r14, r24
    3770:	f9 06       	cpc	r15, r25
    3772:	60 f4       	brcc	.+24     	; 0x378c <prvSwitchTimerLists+0x68>
            {
                listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xReloadTime );
    3774:	9b 83       	std	Y+3, r25	; 0x03
    3776:	8a 83       	std	Y+2, r24	; 0x02
                listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
    3778:	d9 87       	std	Y+9, r29	; 0x09
    377a:	c8 87       	std	Y+8, r28	; 0x08
                vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
    377c:	b8 01       	movw	r22, r16
    377e:	80 91 85 05 	lds	r24, 0x0585	; 0x800585 <pxCurrentTimerList>
    3782:	90 91 86 05 	lds	r25, 0x0586	; 0x800586 <pxCurrentTimerList+0x1>
    3786:	0e 94 dc 1d 	call	0x3bb8	; 0x3bb8 <vListInsert>
    378a:	d2 cf       	rjmp	.-92     	; 0x3730 <prvSwitchTimerLists+0xc>
            }
            else
            {
                xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY );
    378c:	00 e0       	ldi	r16, 0x00	; 0
    378e:	10 e0       	ldi	r17, 0x00	; 0
    3790:	20 e0       	ldi	r18, 0x00	; 0
    3792:	30 e0       	ldi	r19, 0x00	; 0
    3794:	a7 01       	movw	r20, r14
    3796:	60 e0       	ldi	r22, 0x00	; 0
    3798:	ce 01       	movw	r24, r28
    379a:	0e 94 53 1b 	call	0x36a6	; 0x36a6 <xTimerGenericCommand>
    379e:	c8 cf       	rjmp	.-112    	; 0x3730 <prvSwitchTimerLists+0xc>
            mtCOVERAGE_TEST_MARKER();
        }
    }

    pxTemp = pxCurrentTimerList;
    pxCurrentTimerList = pxOverflowTimerList;
    37a0:	80 91 83 05 	lds	r24, 0x0583	; 0x800583 <pxOverflowTimerList>
    37a4:	90 91 84 05 	lds	r25, 0x0584	; 0x800584 <pxOverflowTimerList+0x1>
    37a8:	90 93 86 05 	sts	0x0586, r25	; 0x800586 <pxCurrentTimerList+0x1>
    37ac:	80 93 85 05 	sts	0x0585, r24	; 0x800585 <pxCurrentTimerList>
    pxOverflowTimerList = pxTemp;
    37b0:	f0 93 84 05 	sts	0x0584, r31	; 0x800584 <pxOverflowTimerList+0x1>
    37b4:	e0 93 83 05 	sts	0x0583, r30	; 0x800583 <pxOverflowTimerList>
}
    37b8:	df 91       	pop	r29
    37ba:	cf 91       	pop	r28
    37bc:	1f 91       	pop	r17
    37be:	0f 91       	pop	r16
    37c0:	ff 90       	pop	r15
    37c2:	ef 90       	pop	r14
    37c4:	08 95       	ret

000037c6 <prvTimerTask>:
    pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
}
/*-----------------------------------------------------------*/

static portTASK_FUNCTION( prvTimerTask, pvParameters )
{
    37c6:	cf 93       	push	r28
    37c8:	df 93       	push	r29
    37ca:	00 d0       	rcall	.+0      	; 0x37cc <prvTimerTask+0x6>
    37cc:	00 d0       	rcall	.+0      	; 0x37ce <prvTimerTask+0x8>
    37ce:	1f 92       	push	r1
    37d0:	cd b7       	in	r28, 0x3d	; 61
    37d2:	de b7       	in	r29, 0x3e	; 62
    the timer with the nearest expiry time will expire.  If there are no
    active timers then just set the next expire time to 0.  That will cause
    this task to unblock when the tick count overflows, at which point the
    timer lists will be switched and the next expiry time can be
    re-assessed.  */
    *pxListWasEmpty = listLIST_IS_EMPTY( pxCurrentTimerList );
    37d4:	e0 91 85 05 	lds	r30, 0x0585	; 0x800585 <pxCurrentTimerList>
    37d8:	f0 91 86 05 	lds	r31, 0x0586	; 0x800586 <pxCurrentTimerList+0x1>
    37dc:	d0 80       	ld	r13, Z
    if( *pxListWasEmpty == pdFALSE )
    37de:	dd 20       	and	r13, r13
    37e0:	31 f0       	breq	.+12     	; 0x37ee <prvTimerTask+0x28>
    {
        xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
    37e2:	05 80       	ldd	r0, Z+5	; 0x05
    37e4:	f6 81       	ldd	r31, Z+6	; 0x06
    37e6:	e0 2d       	mov	r30, r0
    37e8:	e0 80       	ld	r14, Z
    37ea:	f1 80       	ldd	r15, Z+1	; 0x01
    37ec:	02 c0       	rjmp	.+4      	; 0x37f2 <prvTimerTask+0x2c>
    }
    else
    {
        /* Ensure the task unblocks when the tick count rolls over. */
        xNextExpireTime = ( TickType_t ) 0U;
    37ee:	e1 2c       	mov	r14, r1
    37f0:	f1 2c       	mov	r15, r1
static void prvProcessTimerOrBlockTask( const TickType_t xNextExpireTime, BaseType_t xListWasEmpty )
{
TickType_t xTimeNow;
BaseType_t xTimerListsWereSwitched;

    vTaskSuspendAll();
    37f2:	0e 94 2c 18 	call	0x3058	; 0x3058 <vTaskSuspendAll>
static TickType_t prvSampleTimeNow( BaseType_t * const pxTimerListsWereSwitched )
{
TickType_t xTimeNow;
PRIVILEGED_DATA static TickType_t xLastTime = ( TickType_t ) 0U; /*lint !e956 Variable is only accessible to one task. */

    xTimeNow = xTaskGetTickCount();
    37f6:	0e 94 32 18 	call	0x3064	; 0x3064 <xTaskGetTickCount>
    37fa:	8c 01       	movw	r16, r24

    if( xTimeNow < xLastTime )
    37fc:	80 91 7d 05 	lds	r24, 0x057D	; 0x80057d <xLastTime.2412>
    3800:	90 91 7e 05 	lds	r25, 0x057E	; 0x80057e <xLastTime.2412+0x1>
    3804:	08 17       	cp	r16, r24
    3806:	19 07       	cpc	r17, r25
    3808:	20 f4       	brcc	.+8      	; 0x3812 <prvTimerTask+0x4c>
    {
        prvSwitchTimerLists();
    380a:	0e 94 92 1b 	call	0x3724	; 0x3724 <prvSwitchTimerLists>
        *pxTimerListsWereSwitched = pdTRUE;
    380e:	81 e0       	ldi	r24, 0x01	; 1
    3810:	01 c0       	rjmp	.+2      	; 0x3814 <prvTimerTask+0x4e>
    }
    else
    {
        *pxTimerListsWereSwitched = pdFALSE;
    3812:	80 e0       	ldi	r24, 0x00	; 0
    }

    xLastTime = xTimeNow;
    3814:	10 93 7e 05 	sts	0x057E, r17	; 0x80057e <xLastTime.2412+0x1>
    3818:	00 93 7d 05 	sts	0x057D, r16	; 0x80057d <xLastTime.2412>
        has expired or not.  If obtaining the time causes the lists to switch
        then don't process this timer as any timers that remained in the list
        when the lists were switched will have been processed within the
        prvSampleTimeNow() function. */
        xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
        if( xTimerListsWereSwitched == pdFALSE )
    381c:	81 11       	cpse	r24, r1
    381e:	55 c0       	rjmp	.+170    	; 0x38ca <prvTimerTask+0x104>
        {
            /* The tick count has not overflowed, has the timer expired? */
            if( ( xListWasEmpty == pdFALSE ) && ( xNextExpireTime <= xTimeNow ) )
    3820:	dd 20       	and	r13, r13
    3822:	d9 f1       	breq	.+118    	; 0x389a <prvTimerTask+0xd4>
    3824:	0e 15       	cp	r16, r14
    3826:	1f 05       	cpc	r17, r15
    3828:	08 f4       	brcc	.+2      	; 0x382c <prvTimerTask+0x66>
    382a:	3e c0       	rjmp	.+124    	; 0x38a8 <prvTimerTask+0xe2>
            {
                ( void ) xTaskResumeAll();
    382c:	0e 94 e8 18 	call	0x31d0	; 0x31d0 <xTaskResumeAll>
/*-----------------------------------------------------------*/

static void prvProcessExpiredTimer( const TickType_t xNextExpireTime, const TickType_t xTimeNow )
{
BaseType_t xResult;
Timer_t * const pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList ); /*lint !e9087 !e9079 void * is used as this macro is used with tasks and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    3830:	e0 91 85 05 	lds	r30, 0x0585	; 0x800585 <pxCurrentTimerList>
    3834:	f0 91 86 05 	lds	r31, 0x0586	; 0x800586 <pxCurrentTimerList+0x1>
    3838:	05 80       	ldd	r0, Z+5	; 0x05
    383a:	f6 81       	ldd	r31, Z+6	; 0x06
    383c:	e0 2d       	mov	r30, r0
    383e:	c6 80       	ldd	r12, Z+6	; 0x06
    3840:	d7 80       	ldd	r13, Z+7	; 0x07

    /* Remove the timer from the list of active timers.  A check has already
    been performed to ensure the list is not empty. */
    ( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
    3842:	c6 01       	movw	r24, r12
    3844:	02 96       	adiw	r24, 0x02	; 2
    3846:	0e 94 14 1e 	call	0x3c28	; 0x3c28 <uxListRemove>
    traceTIMER_EXPIRED( pxTimer );

    /* If the timer is an auto reload timer then calculate the next
    expiry time and re-insert the timer in the list of active timers. */
    if( ( pxTimer->ucStatus & tmrSTATUS_IS_AUTORELOAD ) != 0 )
    384a:	d6 01       	movw	r26, r12
    384c:	52 96       	adiw	r26, 0x12	; 18
    384e:	8c 91       	ld	r24, X
    3850:	52 97       	sbiw	r26, 0x12	; 18
    3852:	82 ff       	sbrs	r24, 2
    3854:	17 c0       	rjmp	.+46     	; 0x3884 <prvTimerTask+0xbe>
    {
        /* The timer is inserted into a list using a time relative to anything
        other than the current time.  It will therefore be inserted into the
        correct list relative to the time this task thinks it is now. */
        if( prvInsertTimerInActiveList( pxTimer, ( xNextExpireTime + pxTimer->xTimerPeriodInTicks ), xTimeNow, xNextExpireTime ) != pdFALSE )
    3856:	1c 96       	adiw	r26, 0x0c	; 12
    3858:	6d 91       	ld	r22, X+
    385a:	7c 91       	ld	r23, X
    385c:	1d 97       	sbiw	r26, 0x0d	; 13
    385e:	6e 0d       	add	r22, r14
    3860:	7f 1d       	adc	r23, r15
    3862:	97 01       	movw	r18, r14
    3864:	a8 01       	movw	r20, r16
    3866:	c6 01       	movw	r24, r12
    3868:	0e 94 09 1b 	call	0x3612	; 0x3612 <prvInsertTimerInActiveList>
    386c:	88 23       	and	r24, r24
    386e:	69 f0       	breq	.+26     	; 0x388a <prvTimerTask+0xc4>
        {
            /* The timer expired before it was added to the active timer
            list.  Reload it now.  */
            xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY );
    3870:	00 e0       	ldi	r16, 0x00	; 0
    3872:	10 e0       	ldi	r17, 0x00	; 0
    3874:	20 e0       	ldi	r18, 0x00	; 0
    3876:	30 e0       	ldi	r19, 0x00	; 0
    3878:	a7 01       	movw	r20, r14
    387a:	60 e0       	ldi	r22, 0x00	; 0
    387c:	c6 01       	movw	r24, r12
    387e:	0e 94 53 1b 	call	0x36a6	; 0x36a6 <xTimerGenericCommand>
    3882:	03 c0       	rjmp	.+6      	; 0x388a <prvTimerTask+0xc4>
            mtCOVERAGE_TEST_MARKER();
        }
    }
    else
    {
        pxTimer->ucStatus &= ~tmrSTATUS_IS_ACTIVE;
    3884:	8e 7f       	andi	r24, 0xFE	; 254
    3886:	f6 01       	movw	r30, r12
    3888:	82 8b       	std	Z+18, r24	; 0x12
        mtCOVERAGE_TEST_MARKER();
    }

    /* Call the timer callback. */
    pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
    388a:	d6 01       	movw	r26, r12
    388c:	50 96       	adiw	r26, 0x10	; 16
    388e:	ed 91       	ld	r30, X+
    3890:	fc 91       	ld	r31, X
    3892:	51 97       	sbiw	r26, 0x11	; 17
    3894:	c6 01       	movw	r24, r12
    3896:	09 95       	icall
    3898:	1e c0       	rjmp	.+60     	; 0x38d6 <prvTimerTask+0x110>
                case when the current timer list is empty. */
                if( xListWasEmpty != pdFALSE )
                {
                    /* The current timer list is empty - is the overflow list
                    also empty? */
                    xListWasEmpty = listLIST_IS_EMPTY( pxOverflowTimerList );
    389a:	e0 91 83 05 	lds	r30, 0x0583	; 0x800583 <pxOverflowTimerList>
    389e:	f0 91 84 05 	lds	r31, 0x0584	; 0x800584 <pxOverflowTimerList+0x1>
    38a2:	80 81       	ld	r24, Z
    38a4:	41 e0       	ldi	r20, 0x01	; 1
    38a6:	81 11       	cpse	r24, r1
        prvSampleTimeNow() function. */
        xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
        if( xTimerListsWereSwitched == pdFALSE )
        {
            /* The tick count has not overflowed, has the timer expired? */
            if( ( xListWasEmpty == pdFALSE ) && ( xNextExpireTime <= xTimeNow ) )
    38a8:	40 e0       	ldi	r20, 0x00	; 0
                    /* The current timer list is empty - is the overflow list
                    also empty? */
                    xListWasEmpty = listLIST_IS_EMPTY( pxOverflowTimerList );
                }

                vQueueWaitForMessageRestricted( xTimerQueue, ( xNextExpireTime - xTimeNow ), xListWasEmpty );
    38aa:	b7 01       	movw	r22, r14
    38ac:	60 1b       	sub	r22, r16
    38ae:	71 0b       	sbc	r23, r17
    38b0:	80 91 81 05 	lds	r24, 0x0581	; 0x800581 <xTimerQueue>
    38b4:	90 91 82 05 	lds	r25, 0x0582	; 0x800582 <xTimerQueue+0x1>
    38b8:	0e 94 e8 15 	call	0x2bd0	; 0x2bd0 <vQueueWaitForMessageRestricted>

                if( xTaskResumeAll() == pdFALSE )
    38bc:	0e 94 e8 18 	call	0x31d0	; 0x31d0 <xTaskResumeAll>
    38c0:	81 11       	cpse	r24, r1
    38c2:	09 c0       	rjmp	.+18     	; 0x38d6 <prvTimerTask+0x110>
                {
                    /* Yield to wait for either a command to arrive, or the
                    block time to expire.  If a command arrived between the
                    critical section being exited and this yield then the yield
                    will not cause the task to block. */
                    portYIELD_WITHIN_API();
    38c4:	0e 94 dc 1e 	call	0x3db8	; 0x3db8 <vPortYield>
    38c8:	06 c0       	rjmp	.+12     	; 0x38d6 <prvTimerTask+0x110>
                }
            }
        }
        else
        {
            ( void ) xTaskResumeAll();
    38ca:	0e 94 e8 18 	call	0x31d0	; 0x31d0 <xTaskResumeAll>
    38ce:	03 c0       	rjmp	.+6      	; 0x38d6 <prvTimerTask+0x110>
        }
        #endif /* INCLUDE_xTimerPendFunctionCall */

        /* Commands that are positive are timer commands rather than pended
        function calls. */
        if( xMessage.xMessageID >= ( BaseType_t ) 0 )
    38d0:	89 81       	ldd	r24, Y+1	; 0x01
    38d2:	87 ff       	sbrs	r24, 7
    38d4:	0e c0       	rjmp	.+28     	; 0x38f2 <prvTimerTask+0x12c>
DaemonTaskMessage_t xMessage;
Timer_t *pxTimer;
BaseType_t xTimerListsWereSwitched, xResult;
TickType_t xTimeNow;

    while( xQueueReceive( xTimerQueue, &xMessage, tmrNO_DELAY ) != pdFAIL ) /*lint !e603 xMessage does not have to be initialised as it is passed out, not in, and it is not used unless xQueueReceive() returns pdTRUE. */
    38d6:	40 e0       	ldi	r20, 0x00	; 0
    38d8:	50 e0       	ldi	r21, 0x00	; 0
    38da:	be 01       	movw	r22, r28
    38dc:	6f 5f       	subi	r22, 0xFF	; 255
    38de:	7f 4f       	sbci	r23, 0xFF	; 255
    38e0:	80 91 81 05 	lds	r24, 0x0581	; 0x800581 <xTimerQueue>
    38e4:	90 91 82 05 	lds	r25, 0x0582	; 0x800582 <xTimerQueue+0x1>
    38e8:	0e 94 56 15 	call	0x2aac	; 0x2aac <xQueueReceive>
    38ec:	81 11       	cpse	r24, r1
    38ee:	f0 cf       	rjmp	.-32     	; 0x38d0 <prvTimerTask+0x10a>
    38f0:	71 cf       	rjmp	.-286    	; 0x37d4 <prvTimerTask+0xe>
        function calls. */
        if( xMessage.xMessageID >= ( BaseType_t ) 0 )
        {
            /* The messages uses the xTimerParameters member to work on a
            software timer. */
            pxTimer = xMessage.u.xTimerParameters.pxTimer;
    38f2:	ec 80       	ldd	r14, Y+4	; 0x04
    38f4:	fd 80       	ldd	r15, Y+5	; 0x05

        if( listIS_CONTAINED_WITHIN( NULL, &( pxTimer->xTimerListItem ) ) == pdFALSE ) /*lint !e961. The cast is only redundant when NULL is passed into the macro. */
    38f6:	f7 01       	movw	r30, r14
    38f8:	82 85       	ldd	r24, Z+10	; 0x0a
    38fa:	93 85       	ldd	r25, Z+11	; 0x0b
    38fc:	89 2b       	or	r24, r25
    38fe:	21 f0       	breq	.+8      	; 0x3908 <prvTimerTask+0x142>
            {
                /* The timer is in a list, remove it. */
                ( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
    3900:	c7 01       	movw	r24, r14
    3902:	02 96       	adiw	r24, 0x02	; 2
    3904:	0e 94 14 1e 	call	0x3c28	; 0x3c28 <uxListRemove>
static TickType_t prvSampleTimeNow( BaseType_t * const pxTimerListsWereSwitched )
{
TickType_t xTimeNow;
PRIVILEGED_DATA static TickType_t xLastTime = ( TickType_t ) 0U; /*lint !e956 Variable is only accessible to one task. */

    xTimeNow = xTaskGetTickCount();
    3908:	0e 94 32 18 	call	0x3064	; 0x3064 <xTaskGetTickCount>
    390c:	6c 01       	movw	r12, r24

    if( xTimeNow < xLastTime )
    390e:	80 91 7d 05 	lds	r24, 0x057D	; 0x80057d <xLastTime.2412>
    3912:	90 91 7e 05 	lds	r25, 0x057E	; 0x80057e <xLastTime.2412+0x1>
    3916:	c8 16       	cp	r12, r24
    3918:	d9 06       	cpc	r13, r25
    391a:	10 f4       	brcc	.+4      	; 0x3920 <prvTimerTask+0x15a>
    {
        prvSwitchTimerLists();
    391c:	0e 94 92 1b 	call	0x3724	; 0x3724 <prvSwitchTimerLists>
    else
    {
        *pxTimerListsWereSwitched = pdFALSE;
    }

    xLastTime = xTimeNow;
    3920:	d0 92 7e 05 	sts	0x057E, r13	; 0x80057e <xLastTime.2412+0x1>
    3924:	c0 92 7d 05 	sts	0x057D, r12	; 0x80057d <xLastTime.2412>
            possibility of a higher priority task adding a message to the message
            queue with a time that is ahead of the timer daemon task (because it
            pre-empted the timer daemon task after the xTimeNow value was set). */
            xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );

            switch( xMessage.xMessageID )
    3928:	e9 81       	ldd	r30, Y+1	; 0x01
    392a:	0e 2e       	mov	r0, r30
    392c:	00 0c       	add	r0, r0
    392e:	ff 0b       	sbc	r31, r31
    3930:	ea 30       	cpi	r30, 0x0A	; 10
    3932:	f1 05       	cpc	r31, r1
    3934:	80 f6       	brcc	.-96     	; 0x38d6 <prvTimerTask+0x110>
    3936:	ec 5c       	subi	r30, 0xCC	; 204
    3938:	ff 4f       	sbci	r31, 0xFF	; 255
    393a:	d7 01       	movw	r26, r14
    393c:	52 96       	adiw	r26, 0x12	; 18
    393e:	8c 91       	ld	r24, X
    3940:	0c 94 ef 1f 	jmp	0x3fde	; 0x3fde <__tablejump2__>
                case tmrCOMMAND_START_FROM_ISR :
                case tmrCOMMAND_RESET :
                case tmrCOMMAND_RESET_FROM_ISR :
                case tmrCOMMAND_START_DONT_TRACE :
                    /* Start or restart a timer. */
                    pxTimer->ucStatus |= tmrSTATUS_IS_ACTIVE;
    3944:	81 60       	ori	r24, 0x01	; 1
    3946:	f7 01       	movw	r30, r14
    3948:	82 8b       	std	Z+18, r24	; 0x12
                    if( prvInsertTimerInActiveList( pxTimer,  xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, xTimeNow, xMessage.u.xTimerParameters.xMessageValue ) != pdFALSE )
    394a:	2a 81       	ldd	r18, Y+2	; 0x02
    394c:	3b 81       	ldd	r19, Y+3	; 0x03
    394e:	64 85       	ldd	r22, Z+12	; 0x0c
    3950:	75 85       	ldd	r23, Z+13	; 0x0d
    3952:	62 0f       	add	r22, r18
    3954:	73 1f       	adc	r23, r19
    3956:	a6 01       	movw	r20, r12
    3958:	c7 01       	movw	r24, r14
    395a:	0e 94 09 1b 	call	0x3612	; 0x3612 <prvInsertTimerInActiveList>
    395e:	88 23       	and	r24, r24
    3960:	09 f4       	brne	.+2      	; 0x3964 <prvTimerTask+0x19e>
    3962:	b9 cf       	rjmp	.-142    	; 0x38d6 <prvTimerTask+0x110>
                    {
                        /* The timer expired before it was added to the active
                        timer list.  Process it now. */
                        pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
    3964:	d7 01       	movw	r26, r14
    3966:	50 96       	adiw	r26, 0x10	; 16
    3968:	ed 91       	ld	r30, X+
    396a:	fc 91       	ld	r31, X
    396c:	51 97       	sbiw	r26, 0x11	; 17
    396e:	c7 01       	movw	r24, r14
    3970:	09 95       	icall
                        traceTIMER_EXPIRED( pxTimer );

                        if( ( pxTimer->ucStatus & tmrSTATUS_IS_AUTORELOAD ) != 0 )
    3972:	f7 01       	movw	r30, r14
    3974:	82 89       	ldd	r24, Z+18	; 0x12
    3976:	82 ff       	sbrs	r24, 2
    3978:	ae cf       	rjmp	.-164    	; 0x38d6 <prvTimerTask+0x110>
                        {
                            xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, NULL, tmrNO_DELAY );
    397a:	4a 81       	ldd	r20, Y+2	; 0x02
    397c:	5b 81       	ldd	r21, Y+3	; 0x03
    397e:	84 85       	ldd	r24, Z+12	; 0x0c
    3980:	95 85       	ldd	r25, Z+13	; 0x0d
    3982:	48 0f       	add	r20, r24
    3984:	59 1f       	adc	r21, r25
    3986:	00 e0       	ldi	r16, 0x00	; 0
    3988:	10 e0       	ldi	r17, 0x00	; 0
    398a:	20 e0       	ldi	r18, 0x00	; 0
    398c:	30 e0       	ldi	r19, 0x00	; 0
    398e:	60 e0       	ldi	r22, 0x00	; 0
    3990:	c7 01       	movw	r24, r14
    3992:	0e 94 53 1b 	call	0x36a6	; 0x36a6 <xTimerGenericCommand>
    3996:	9f cf       	rjmp	.-194    	; 0x38d6 <prvTimerTask+0x110>
                    pxTimer->ucStatus &= ~tmrSTATUS_IS_ACTIVE;
                    break;

                case tmrCOMMAND_CHANGE_PERIOD :
                case tmrCOMMAND_CHANGE_PERIOD_FROM_ISR :
                    pxTimer->ucStatus |= tmrSTATUS_IS_ACTIVE;
    3998:	81 60       	ori	r24, 0x01	; 1
    399a:	f7 01       	movw	r30, r14
    399c:	82 8b       	std	Z+18, r24	; 0x12
                    pxTimer->xTimerPeriodInTicks = xMessage.u.xTimerParameters.xMessageValue;
    399e:	6a 81       	ldd	r22, Y+2	; 0x02
    39a0:	7b 81       	ldd	r23, Y+3	; 0x03
    39a2:	75 87       	std	Z+13, r23	; 0x0d
    39a4:	64 87       	std	Z+12, r22	; 0x0c
                    be longer or shorter than the old one.  The command time is
                    therefore set to the current time, and as the period cannot
                    be zero the next expiry time can only be in the future,
                    meaning (unlike for the xTimerStart() case above) there is
                    no fail case that needs to be handled here. */
                    ( void ) prvInsertTimerInActiveList( pxTimer, ( xTimeNow + pxTimer->xTimerPeriodInTicks ), xTimeNow, xTimeNow );
    39a6:	6c 0d       	add	r22, r12
    39a8:	7d 1d       	adc	r23, r13
    39aa:	96 01       	movw	r18, r12
    39ac:	a6 01       	movw	r20, r12
    39ae:	c7 01       	movw	r24, r14
    39b0:	0e 94 09 1b 	call	0x3612	; 0x3612 <prvInsertTimerInActiveList>
    39b4:	90 cf       	rjmp	.-224    	; 0x38d6 <prvTimerTask+0x110>
                    #if ( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
                    {
                    /* The timer has already been removed from the active list,
                    just free up the memory if the memory was dynamically
                    allocated. */
                        if( ( pxTimer->ucStatus & tmrSTATUS_IS_STATICALLY_ALLOCATED ) == ( uint8_t ) 0 )
    39b6:	81 fd       	sbrc	r24, 1
    39b8:	04 c0       	rjmp	.+8      	; 0x39c2 <prvTimerTask+0x1fc>
                        {
                            vPortFree( pxTimer );
    39ba:	c7 01       	movw	r24, r14
    39bc:	0e 94 98 1d 	call	0x3b30	; 0x3b30 <vPortFree>
    39c0:	8a cf       	rjmp	.-236    	; 0x38d6 <prvTimerTask+0x110>
                        }
                        else
                        {
                            pxTimer->ucStatus &= ~tmrSTATUS_IS_ACTIVE;
    39c2:	8e 7f       	andi	r24, 0xFE	; 254
    39c4:	d7 01       	movw	r26, r14
    39c6:	52 96       	adiw	r26, 0x12	; 18
    39c8:	8c 93       	st	X, r24
    39ca:	85 cf       	rjmp	.-246    	; 0x38d6 <prvTimerTask+0x110>

000039cc <initVariant>:
{
#if defined(USBCON)
    USBDevice.attach();
#endif

    setup();        // the normal Arduino setup() function is run here.
    39cc:	0e 94 77 04 	call	0x8ee	; 0x8ee <setup>
    vTaskStartScheduler(); // initialise and run the freeRTOS scheduler. Execution should never return here.
    39d0:	0e 94 fe 17 	call	0x2ffc	; 0x2ffc <vTaskStartScheduler>
    39d4:	08 95       	ret

000039d6 <vApplicationIdleHook>:
 */
void vApplicationIdleHook( void ) __attribute__((weak));

void vApplicationIdleHook( void )
{
    loop();        // the normal Arduino loop() function is run here.
    39d6:	0e 94 f3 04 	call	0x9e6	; 0x9e6 <loop>
    if (serialEventRun) serialEventRun();
    39da:	81 ec       	ldi	r24, 0xC1	; 193
    39dc:	9d e0       	ldi	r25, 0x0D	; 13
    39de:	89 2b       	or	r24, r25
    39e0:	11 f0       	breq	.+4      	; 0x39e6 <vApplicationIdleHook+0x10>
    39e2:	0c 94 c1 0d 	jmp	0x1b82	; 0x1b82 <_Z14serialEventRunv>
    39e6:	08 95       	ret

000039e8 <vApplicationMallocFailedHook>:
#elif defined(__AVR_ATmega644P__) || defined(__AVR_ATmega644PA__) || defined(__AVR_ATmega1284P__) || defined(__AVR_ATmega1284PA__) // Seeed Goldilocks with 1284p
    DDRB  |= _BV(DDB7);
    PORTB |= _BV(PORTB7);       // Main (red PB7) LED on. Main LED on.

#elif defined(__AVR_ATmega328P__) || defined(__AVR_ATmega168__) || defined(__AVR_ATmega8__) // assume we're using an Arduino Uno with 328p
    DDRB  |= _BV(DDB5);
    39e8:	25 9a       	sbi	0x04, 5	; 4
    PORTB |= _BV(PORTB5);       // Main (red PB5) LED on. Main LED on.
    39ea:	2d 9a       	sbi	0x05, 5	; 5
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    39ec:	2f ef       	ldi	r18, 0xFF	; 255
    39ee:	80 e7       	ldi	r24, 0x70	; 112
    39f0:	92 e0       	ldi	r25, 0x02	; 2
    39f2:	21 50       	subi	r18, 0x01	; 1
    39f4:	80 40       	sbci	r24, 0x00	; 0
    39f6:	90 40       	sbci	r25, 0x00	; 0
    39f8:	e1 f7       	brne	.-8      	; 0x39f2 <vApplicationMallocFailedHook+0xa>
    39fa:	00 c0       	rjmp	.+0      	; 0x39fc <vApplicationMallocFailedHook+0x14>
    39fc:	00 00       	nop

#elif defined(__AVR_ATmega644P__) || defined(__AVR_ATmega644PA__) || defined(__AVR_ATmega1284P__) || defined(__AVR_ATmega1284PA__) // Seeed Goldilocks with 1284p
        PINB  |= _BV(PINB7);       // Main (red PB7) LED toggle. Main LED fast blink.

#elif defined(__AVR_ATmega328P__) || defined(__AVR_ATmega168__) || defined(__AVR_ATmega8__) // assume we're using an Arduino Uno with 328p
        PINB  |= _BV(PINB5);       // Main (red PB5) LED toggle. Main LED fast blink.
    39fe:	1d 9a       	sbi	0x03, 5	; 3
    3a00:	f5 cf       	rjmp	.-22     	; 0x39ec <vApplicationMallocFailedHook+0x4>

00003a02 <vApplicationStackOverflowHook>:
#elif defined(__AVR_ATmega644P__) || defined(__AVR_ATmega644PA__) || defined(__AVR_ATmega1284P__) || defined(__AVR_ATmega1284PA__) // Seeed Goldilocks with 1284p
    DDRB  |= _BV(DDB7);
    PORTB |= _BV(PORTB7);       // Main (red PB7) LED on. Main LED on.

#elif defined(__AVR_ATmega328P__) || defined(__AVR_ATmega168__) || defined(__AVR_ATmega8__) // assume we're using an Arduino Uno with 328p
    DDRB  |= _BV(DDB5);
    3a02:	25 9a       	sbi	0x04, 5	; 4
    PORTB |= _BV(PORTB5);       // Main (red PB5) LED on. Main LED on.
    3a04:	2d 9a       	sbi	0x05, 5	; 5
    3a06:	2f ef       	ldi	r18, 0xFF	; 255
    3a08:	87 ea       	ldi	r24, 0xA7	; 167
    3a0a:	91 e6       	ldi	r25, 0x61	; 97
    3a0c:	21 50       	subi	r18, 0x01	; 1
    3a0e:	80 40       	sbci	r24, 0x00	; 0
    3a10:	90 40       	sbci	r25, 0x00	; 0
    3a12:	e1 f7       	brne	.-8      	; 0x3a0c <vApplicationStackOverflowHook+0xa>
    3a14:	00 c0       	rjmp	.+0      	; 0x3a16 <vApplicationStackOverflowHook+0x14>
    3a16:	00 00       	nop

#elif defined(__AVR_ATmega644P__) || defined(__AVR_ATmega644PA__) || defined(__AVR_ATmega1284P__) || defined(__AVR_ATmega1284PA__) // Seeed Goldilocks with 1284p
        PINB  |= _BV(PINB7);       // Main (red PB7) LED toggle. Main LED slow blink.

#elif defined(__AVR_ATmega328P__) || defined(__AVR_ATmega168__) || defined(__AVR_ATmega8__) // assume we're using an Arduino Uno with 328p
        PINB  |= _BV(PINB5);       // Main (red PB5) LED toggle. Main LED slow blink.
    3a18:	1d 9a       	sbi	0x03, 5	; 3
    3a1a:	f5 cf       	rjmp	.-22     	; 0x3a06 <vApplicationStackOverflowHook+0x4>

00003a1c <__vector_7>:
	counter_shutdown();
}


ISR(TIMER_ISR_VECTOR)
{
    3a1c:	1f 92       	push	r1
    3a1e:	0f 92       	push	r0
    3a20:	0f b6       	in	r0, 0x3f	; 63
    3a22:	0f 92       	push	r0
    3a24:	11 24       	eor	r1, r1
    3a26:	0f 93       	push	r16
    3a28:	1f 93       	push	r17
    3a2a:	2f 93       	push	r18
    3a2c:	3f 93       	push	r19
    3a2e:	4f 93       	push	r20
    3a30:	5f 93       	push	r21
    3a32:	6f 93       	push	r22
    3a34:	7f 93       	push	r23
    3a36:	8f 93       	push	r24
    3a38:	9f 93       	push	r25
    3a3a:	af 93       	push	r26
    3a3c:	bf 93       	push	r27
	TCCR1B = saveTCCR1B;
}

static inline uint16_t counter_read(void)
{
	return TCNT1;
    3a3e:	20 91 84 00 	lds	r18, 0x0084	; 0x800084 <__DATA_REGION_ORIGIN__+0x24>
    3a42:	30 91 85 00 	lds	r19, 0x0085	; 0x800085 <__DATA_REGION_ORIGIN__+0x25>
	uint16_t count_lsw;
	uint32_t count;
	uint16_t index, length;

	count_lsw = counter_read();
	if (counter_overflow()) {
    3a46:	b0 9b       	sbis	0x16, 0	; 22
    3a48:	0b c0       	rjmp	.+22     	; 0x3a60 <__vector_7+0x44>
	return TIFR1 & (1<<TOV1);
}

static inline void counter_overflow_reset(void)
{
	TIFR1 = (1<<TOV1);
    3a4a:	81 e0       	ldi	r24, 0x01	; 1
    3a4c:	86 bb       	out	0x16, r24	; 22
		counter_overflow_reset();
		count_msw++;
    3a4e:	80 91 a6 05 	lds	r24, 0x05A6	; 0x8005a6 <_ZL9count_msw>
    3a52:	90 91 a7 05 	lds	r25, 0x05A7	; 0x8005a7 <_ZL9count_msw+0x1>
    3a56:	01 96       	adiw	r24, 0x01	; 1
    3a58:	90 93 a7 05 	sts	0x05A7, r25	; 0x8005a7 <_ZL9count_msw+0x1>
    3a5c:	80 93 a6 05 	sts	0x05A6, r24	; 0x8005a6 <_ZL9count_msw>
	}
	index = gate_index + 1;
    3a60:	80 91 99 05 	lds	r24, 0x0599	; 0x800599 <_ZL10gate_index>
    3a64:	90 91 9a 05 	lds	r25, 0x059A	; 0x80059a <_ZL10gate_index+0x1>
    3a68:	01 96       	adiw	r24, 0x01	; 1
	length = gate_length;
	if (index >= length) {
    3a6a:	40 91 9b 05 	lds	r20, 0x059B	; 0x80059b <_ZL11gate_length>
    3a6e:	50 91 9c 05 	lds	r21, 0x059C	; 0x80059c <_ZL11gate_length+0x1>
    3a72:	84 17       	cp	r24, r20
    3a74:	95 07       	cpc	r25, r21
    3a76:	98 f1       	brcs	.+102    	; 0x3ade <__vector_7+0xc2>
		gate_index = 0;
    3a78:	10 92 9a 05 	sts	0x059A, r1	; 0x80059a <_ZL10gate_index+0x1>
    3a7c:	10 92 99 05 	sts	0x0599, r1	; 0x800599 <_ZL10gate_index>
		count = ((uint32_t)count_msw << 16) + count_lsw;
    3a80:	80 91 a6 05 	lds	r24, 0x05A6	; 0x8005a6 <_ZL9count_msw>
    3a84:	90 91 a7 05 	lds	r25, 0x05A7	; 0x8005a7 <_ZL9count_msw+0x1>
    3a88:	a0 e0       	ldi	r26, 0x00	; 0
    3a8a:	b0 e0       	ldi	r27, 0x00	; 0
    3a8c:	dc 01       	movw	r26, r24
    3a8e:	99 27       	eor	r25, r25
    3a90:	88 27       	eor	r24, r24
    3a92:	82 0f       	add	r24, r18
    3a94:	93 1f       	adc	r25, r19
    3a96:	a1 1d       	adc	r26, r1
    3a98:	b1 1d       	adc	r27, r1
		count_output = count - count_prev;
    3a9a:	40 91 a2 05 	lds	r20, 0x05A2	; 0x8005a2 <_ZL10count_prev>
    3a9e:	50 91 a3 05 	lds	r21, 0x05A3	; 0x8005a3 <_ZL10count_prev+0x1>
    3aa2:	60 91 a4 05 	lds	r22, 0x05A4	; 0x8005a4 <_ZL10count_prev+0x2>
    3aa6:	70 91 a5 05 	lds	r23, 0x05A5	; 0x8005a5 <_ZL10count_prev+0x3>
    3aaa:	8c 01       	movw	r16, r24
    3aac:	9d 01       	movw	r18, r26
    3aae:	04 1b       	sub	r16, r20
    3ab0:	15 0b       	sbc	r17, r21
    3ab2:	26 0b       	sbc	r18, r22
    3ab4:	37 0b       	sbc	r19, r23
    3ab6:	00 93 9e 05 	sts	0x059E, r16	; 0x80059e <_ZL12count_output>
    3aba:	10 93 9f 05 	sts	0x059F, r17	; 0x80059f <_ZL12count_output+0x1>
    3abe:	20 93 a0 05 	sts	0x05A0, r18	; 0x8005a0 <_ZL12count_output+0x2>
    3ac2:	30 93 a1 05 	sts	0x05A1, r19	; 0x8005a1 <_ZL12count_output+0x3>
		count_prev = count;
    3ac6:	80 93 a2 05 	sts	0x05A2, r24	; 0x8005a2 <_ZL10count_prev>
    3aca:	90 93 a3 05 	sts	0x05A3, r25	; 0x8005a3 <_ZL10count_prev+0x1>
    3ace:	a0 93 a4 05 	sts	0x05A4, r26	; 0x8005a4 <_ZL10count_prev+0x2>
    3ad2:	b0 93 a5 05 	sts	0x05A5, r27	; 0x8005a5 <_ZL10count_prev+0x3>
		count_ready = 1;
    3ad6:	81 e0       	ldi	r24, 0x01	; 1
    3ad8:	80 93 9d 05 	sts	0x059D, r24	; 0x80059d <_ZL11count_ready>
    3adc:	04 c0       	rjmp	.+8      	; 0x3ae6 <__vector_7+0xca>
		restore_other_interrupts();
	} else {
		if (index == length - 1) disable_other_interrupts();
		gate_index = index;
    3ade:	90 93 9a 05 	sts	0x059A, r25	; 0x80059a <_ZL10gate_index+0x1>
    3ae2:	80 93 99 05 	sts	0x0599, r24	; 0x800599 <_ZL10gate_index>
	}
}
    3ae6:	bf 91       	pop	r27
    3ae8:	af 91       	pop	r26
    3aea:	9f 91       	pop	r25
    3aec:	8f 91       	pop	r24
    3aee:	7f 91       	pop	r23
    3af0:	6f 91       	pop	r22
    3af2:	5f 91       	pop	r21
    3af4:	4f 91       	pop	r20
    3af6:	3f 91       	pop	r19
    3af8:	2f 91       	pop	r18
    3afa:	1f 91       	pop	r17
    3afc:	0f 91       	pop	r16
    3afe:	0f 90       	pop	r0
    3b00:	0f be       	out	0x3f, r0	; 63
    3b02:	0f 90       	pop	r0
    3b04:	1f 90       	pop	r1
    3b06:	18 95       	reti

00003b08 <yield>:
 * libraries or sketches that supports cooperative threads.
 *
 * Its defined as a weak symbol and it can be redefined to implement a
 * real cooperative scheduler.
 */
static void __empty() {
    3b08:	08 95       	ret

00003b0a <pvPortMalloc>:
#if( configSUPPORT_DYNAMIC_ALLOCATION > 0 )

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
    3b0a:	cf 93       	push	r28
    3b0c:	df 93       	push	r29
    3b0e:	ec 01       	movw	r28, r24
void *pvReturn;

    vTaskSuspendAll();
    3b10:	0e 94 2c 18 	call	0x3058	; 0x3058 <vTaskSuspendAll>
    {
        pvReturn = malloc( xWantedSize );
    3b14:	ce 01       	movw	r24, r28
    3b16:	0e 94 09 20 	call	0x4012	; 0x4012 <malloc>
    3b1a:	ec 01       	movw	r28, r24
        traceMALLOC( pvReturn, xWantedSize );
    }
    ( void ) xTaskResumeAll();
    3b1c:	0e 94 e8 18 	call	0x31d0	; 0x31d0 <xTaskResumeAll>

    #if( configUSE_MALLOC_FAILED_HOOK == 1 )
    {
        if( pvReturn == NULL )
    3b20:	20 97       	sbiw	r28, 0x00	; 0
    3b22:	11 f4       	brne	.+4      	; 0x3b28 <pvPortMalloc+0x1e>
        {
            extern void vApplicationMallocFailedHook( void );
            vApplicationMallocFailedHook();
    3b24:	0e 94 f4 1c 	call	0x39e8	; 0x39e8 <vApplicationMallocFailedHook>
        }
    }
    #endif

    return pvReturn;
}
    3b28:	ce 01       	movw	r24, r28
    3b2a:	df 91       	pop	r29
    3b2c:	cf 91       	pop	r28
    3b2e:	08 95       	ret

00003b30 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
    3b30:	cf 93       	push	r28
    3b32:	df 93       	push	r29
    if( pv )
    3b34:	00 97       	sbiw	r24, 0x00	; 0
    3b36:	51 f0       	breq	.+20     	; 0x3b4c <vPortFree+0x1c>
    3b38:	ec 01       	movw	r28, r24
    {
        vTaskSuspendAll();
    3b3a:	0e 94 2c 18 	call	0x3058	; 0x3058 <vTaskSuspendAll>
        {
            free( pv );
    3b3e:	ce 01       	movw	r24, r28
    3b40:	0e 94 a1 20 	call	0x4142	; 0x4142 <free>
            traceFREE( pv, 0 );
        }
        ( void ) xTaskResumeAll();
    }
}
    3b44:	df 91       	pop	r29
    3b46:	cf 91       	pop	r28
        vTaskSuspendAll();
        {
            free( pv );
            traceFREE( pv, 0 );
        }
        ( void ) xTaskResumeAll();
    3b48:	0c 94 e8 18 	jmp	0x31d0	; 0x31d0 <xTaskResumeAll>
    }
}
    3b4c:	df 91       	pop	r29
    3b4e:	cf 91       	pop	r28
    3b50:	08 95       	ret

00003b52 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
    3b52:	fc 01       	movw	r30, r24
    /* The list structure contains a list item which is used to mark the
    end of the list.  To initialise the list the list end is inserted
    as the only list entry. */
    pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );            /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    3b54:	03 96       	adiw	r24, 0x03	; 3
    3b56:	92 83       	std	Z+2, r25	; 0x02
    3b58:	81 83       	std	Z+1, r24	; 0x01

    /* The list end value is the highest possible value in the list to
    ensure it remains at the end of the list. */
    pxList->xListEnd.xItemValue = portMAX_DELAY;
    3b5a:	2f ef       	ldi	r18, 0xFF	; 255
    3b5c:	3f ef       	ldi	r19, 0xFF	; 255
    3b5e:	34 83       	std	Z+4, r19	; 0x04
    3b60:	23 83       	std	Z+3, r18	; 0x03

    /* The list end next and previous pointers point to itself so we know
    when the list is empty. */
    pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );    /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    3b62:	96 83       	std	Z+6, r25	; 0x06
    3b64:	85 83       	std	Z+5, r24	; 0x05
    pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    3b66:	90 87       	std	Z+8, r25	; 0x08
    3b68:	87 83       	std	Z+7, r24	; 0x07

    pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
    3b6a:	10 82       	st	Z, r1
    3b6c:	08 95       	ret

00003b6e <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
    /* Make sure the list item is not recorded as being on a list. */
    pxItem->pxContainer = NULL;
    3b6e:	fc 01       	movw	r30, r24
    3b70:	11 86       	std	Z+9, r1	; 0x09
    3b72:	10 86       	std	Z+8, r1	; 0x08
    3b74:	08 95       	ret

00003b76 <vListInsertEnd>:
    listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    3b76:	cf 93       	push	r28
    3b78:	df 93       	push	r29
    3b7a:	9c 01       	movw	r18, r24
    3b7c:	fb 01       	movw	r30, r22
ListItem_t * const pxIndex = pxList->pxIndex;
    3b7e:	dc 01       	movw	r26, r24
    3b80:	11 96       	adiw	r26, 0x01	; 1
    3b82:	cd 91       	ld	r28, X+
    3b84:	dc 91       	ld	r29, X
    3b86:	12 97       	sbiw	r26, 0x02	; 2
    listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

    /* Insert a new list item into pxList, but rather than sort the list,
    makes the new list item the last item to be removed by a call to
    listGET_OWNER_OF_NEXT_ENTRY(). */
    pxNewListItem->pxNext = pxIndex;
    3b88:	d3 83       	std	Z+3, r29	; 0x03
    3b8a:	c2 83       	std	Z+2, r28	; 0x02
    pxNewListItem->pxPrevious = pxIndex->pxPrevious;
    3b8c:	8c 81       	ldd	r24, Y+4	; 0x04
    3b8e:	9d 81       	ldd	r25, Y+5	; 0x05
    3b90:	95 83       	std	Z+5, r25	; 0x05
    3b92:	84 83       	std	Z+4, r24	; 0x04

    /* Only used during decision coverage testing. */
    mtCOVERAGE_TEST_DELAY();

    pxIndex->pxPrevious->pxNext = pxNewListItem;
    3b94:	8c 81       	ldd	r24, Y+4	; 0x04
    3b96:	9d 81       	ldd	r25, Y+5	; 0x05
    3b98:	dc 01       	movw	r26, r24
    3b9a:	13 96       	adiw	r26, 0x03	; 3
    3b9c:	7c 93       	st	X, r23
    3b9e:	6e 93       	st	-X, r22
    3ba0:	12 97       	sbiw	r26, 0x02	; 2
    pxIndex->pxPrevious = pxNewListItem;
    3ba2:	7d 83       	std	Y+5, r23	; 0x05
    3ba4:	6c 83       	std	Y+4, r22	; 0x04

    /* Remember which list the item is in. */
    pxNewListItem->pxContainer = pxList;
    3ba6:	31 87       	std	Z+9, r19	; 0x09
    3ba8:	20 87       	std	Z+8, r18	; 0x08

    ( pxList->uxNumberOfItems )++;
    3baa:	f9 01       	movw	r30, r18
    3bac:	80 81       	ld	r24, Z
    3bae:	8f 5f       	subi	r24, 0xFF	; 255
    3bb0:	80 83       	st	Z, r24
}
    3bb2:	df 91       	pop	r29
    3bb4:	cf 91       	pop	r28
    3bb6:	08 95       	ret

00003bb8 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    3bb8:	0f 93       	push	r16
    3bba:	1f 93       	push	r17
    3bbc:	cf 93       	push	r28
    3bbe:	df 93       	push	r29
    3bc0:	8c 01       	movw	r16, r24
    3bc2:	fb 01       	movw	r30, r22
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
    3bc4:	80 81       	ld	r24, Z
    3bc6:	91 81       	ldd	r25, Z+1	; 0x01
    new list item should be placed after it.  This ensures that TCBs which are
    stored in ready lists (all of which have the same xItemValue value) get a
    share of the CPU.  However, if the xItemValue is the same as the back marker
    the iteration loop below will not end.  Therefore the value is checked
    first, and the algorithm slightly modified if necessary. */
    if( xValueOfInsertion == portMAX_DELAY )
    3bc8:	8f 3f       	cpi	r24, 0xFF	; 255
    3bca:	2f ef       	ldi	r18, 0xFF	; 255
    3bcc:	92 07       	cpc	r25, r18
    3bce:	21 f4       	brne	.+8      	; 0x3bd8 <vListInsert+0x20>
    {
        pxIterator = pxList->xListEnd.pxPrevious;
    3bd0:	e8 01       	movw	r28, r16
    3bd2:	af 81       	ldd	r26, Y+7	; 0x07
    3bd4:	b8 85       	ldd	r27, Y+8	; 0x08
    3bd6:	0e c0       	rjmp	.+28     	; 0x3bf4 <vListInsert+0x3c>
            4) Using a queue or semaphore before it has been initialised or
               before the scheduler has been started (are interrupts firing
               before vTaskStartScheduler() has been called?).
        **********************************************************************/

        for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. *//*lint !e440 The iterator moves to a different value, not xValueOfInsertion. */
    3bd8:	d8 01       	movw	r26, r16
    3bda:	13 96       	adiw	r26, 0x03	; 3
    3bdc:	12 96       	adiw	r26, 0x02	; 2
    3bde:	2d 91       	ld	r18, X+
    3be0:	3c 91       	ld	r19, X
    3be2:	13 97       	sbiw	r26, 0x03	; 3
    3be4:	e9 01       	movw	r28, r18
    3be6:	48 81       	ld	r20, Y
    3be8:	59 81       	ldd	r21, Y+1	; 0x01
    3bea:	84 17       	cp	r24, r20
    3bec:	95 07       	cpc	r25, r21
    3bee:	10 f0       	brcs	.+4      	; 0x3bf4 <vListInsert+0x3c>
    3bf0:	d9 01       	movw	r26, r18
    3bf2:	f4 cf       	rjmp	.-24     	; 0x3bdc <vListInsert+0x24>
            /* There is nothing to do here, just iterating to the wanted
            insertion position. */
        }
    }

    pxNewListItem->pxNext = pxIterator->pxNext;
    3bf4:	12 96       	adiw	r26, 0x02	; 2
    3bf6:	8d 91       	ld	r24, X+
    3bf8:	9c 91       	ld	r25, X
    3bfa:	13 97       	sbiw	r26, 0x03	; 3
    3bfc:	93 83       	std	Z+3, r25	; 0x03
    3bfe:	82 83       	std	Z+2, r24	; 0x02
    pxNewListItem->pxNext->pxPrevious = pxNewListItem;
    3c00:	ec 01       	movw	r28, r24
    3c02:	fd 83       	std	Y+5, r31	; 0x05
    3c04:	ec 83       	std	Y+4, r30	; 0x04
    pxNewListItem->pxPrevious = pxIterator;
    3c06:	b5 83       	std	Z+5, r27	; 0x05
    3c08:	a4 83       	std	Z+4, r26	; 0x04
    pxIterator->pxNext = pxNewListItem;
    3c0a:	13 96       	adiw	r26, 0x03	; 3
    3c0c:	fc 93       	st	X, r31
    3c0e:	ee 93       	st	-X, r30
    3c10:	12 97       	sbiw	r26, 0x02	; 2

    /* Remember which list the item is in.  This allows fast removal of the
    item later. */
    pxNewListItem->pxContainer = pxList;
    3c12:	11 87       	std	Z+9, r17	; 0x09
    3c14:	00 87       	std	Z+8, r16	; 0x08

    ( pxList->uxNumberOfItems )++;
    3c16:	f8 01       	movw	r30, r16
    3c18:	80 81       	ld	r24, Z
    3c1a:	8f 5f       	subi	r24, 0xFF	; 255
    3c1c:	80 83       	st	Z, r24
}
    3c1e:	df 91       	pop	r29
    3c20:	cf 91       	pop	r28
    3c22:	1f 91       	pop	r17
    3c24:	0f 91       	pop	r16
    3c26:	08 95       	ret

00003c28 <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
    3c28:	cf 93       	push	r28
    3c2a:	df 93       	push	r29
    3c2c:	fc 01       	movw	r30, r24
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = pxItemToRemove->pxContainer;
    3c2e:	a0 85       	ldd	r26, Z+8	; 0x08
    3c30:	b1 85       	ldd	r27, Z+9	; 0x09

    pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    3c32:	82 81       	ldd	r24, Z+2	; 0x02
    3c34:	93 81       	ldd	r25, Z+3	; 0x03
    3c36:	24 81       	ldd	r18, Z+4	; 0x04
    3c38:	35 81       	ldd	r19, Z+5	; 0x05
    3c3a:	ec 01       	movw	r28, r24
    3c3c:	3d 83       	std	Y+5, r19	; 0x05
    3c3e:	2c 83       	std	Y+4, r18	; 0x04
    pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    3c40:	c4 81       	ldd	r28, Z+4	; 0x04
    3c42:	d5 81       	ldd	r29, Z+5	; 0x05
    3c44:	9b 83       	std	Y+3, r25	; 0x03
    3c46:	8a 83       	std	Y+2, r24	; 0x02

    /* Only used during decision coverage testing. */
    mtCOVERAGE_TEST_DELAY();

    /* Make sure the index is left pointing to a valid item. */
    if( pxList->pxIndex == pxItemToRemove )
    3c48:	11 96       	adiw	r26, 0x01	; 1
    3c4a:	8d 91       	ld	r24, X+
    3c4c:	9c 91       	ld	r25, X
    3c4e:	12 97       	sbiw	r26, 0x02	; 2
    3c50:	e8 17       	cp	r30, r24
    3c52:	f9 07       	cpc	r31, r25
    3c54:	21 f4       	brne	.+8      	; 0x3c5e <uxListRemove+0x36>
    {
        pxList->pxIndex = pxItemToRemove->pxPrevious;
    3c56:	12 96       	adiw	r26, 0x02	; 2
    3c58:	dc 93       	st	X, r29
    3c5a:	ce 93       	st	-X, r28
    3c5c:	11 97       	sbiw	r26, 0x01	; 1
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }

    pxItemToRemove->pxContainer = NULL;
    3c5e:	11 86       	std	Z+9, r1	; 0x09
    3c60:	10 86       	std	Z+8, r1	; 0x08
    ( pxList->uxNumberOfItems )--;
    3c62:	8c 91       	ld	r24, X
    3c64:	81 50       	subi	r24, 0x01	; 1
    3c66:	8c 93       	st	X, r24

    return pxList->uxNumberOfItems;
    3c68:	8c 91       	ld	r24, X
}
    3c6a:	df 91       	pop	r29
    3c6c:	cf 91       	pop	r28
    3c6e:	08 95       	ret

00003c70 <pxPortInitialiseStack>:
		);
	}
	else
	{
        uint8_t register temp_reg;
		__asm__ __volatile__ (
    3c70:	31 e1       	ldi	r19, 0x11	; 17
    3c72:	fc 01       	movw	r30, r24
    3c74:	30 83       	st	Z, r19
    3c76:	31 97       	sbiw	r30, 0x01	; 1
    3c78:	22 e2       	ldi	r18, 0x22	; 34
    3c7a:	20 83       	st	Z, r18
    3c7c:	31 97       	sbiw	r30, 0x01	; 1
    3c7e:	a3 e3       	ldi	r26, 0x33	; 51
    3c80:	a0 83       	st	Z, r26
    3c82:	31 97       	sbiw	r30, 0x01	; 1
    3c84:	60 83       	st	Z, r22
    3c86:	31 97       	sbiw	r30, 0x01	; 1
    3c88:	70 83       	st	Z, r23
    3c8a:	31 97       	sbiw	r30, 0x01	; 1
    3c8c:	10 82       	st	Z, r1
    3c8e:	31 97       	sbiw	r30, 0x01	; 1
    3c90:	60 e8       	ldi	r22, 0x80	; 128
    3c92:	60 83       	st	Z, r22
    3c94:	31 97       	sbiw	r30, 0x01	; 1
    3c96:	10 82       	st	Z, r1
    3c98:	31 97       	sbiw	r30, 0x01	; 1
    3c9a:	62 e0       	ldi	r22, 0x02	; 2
    3c9c:	60 83       	st	Z, r22
    3c9e:	31 97       	sbiw	r30, 0x01	; 1
    3ca0:	63 e0       	ldi	r22, 0x03	; 3
    3ca2:	60 83       	st	Z, r22
    3ca4:	31 97       	sbiw	r30, 0x01	; 1
    3ca6:	64 e0       	ldi	r22, 0x04	; 4
    3ca8:	60 83       	st	Z, r22
    3caa:	31 97       	sbiw	r30, 0x01	; 1
    3cac:	65 e0       	ldi	r22, 0x05	; 5
    3cae:	60 83       	st	Z, r22
    3cb0:	31 97       	sbiw	r30, 0x01	; 1
    3cb2:	66 e0       	ldi	r22, 0x06	; 6
    3cb4:	60 83       	st	Z, r22
    3cb6:	31 97       	sbiw	r30, 0x01	; 1
    3cb8:	67 e0       	ldi	r22, 0x07	; 7
    3cba:	60 83       	st	Z, r22
    3cbc:	31 97       	sbiw	r30, 0x01	; 1
    3cbe:	68 e0       	ldi	r22, 0x08	; 8
    3cc0:	60 83       	st	Z, r22
    3cc2:	31 97       	sbiw	r30, 0x01	; 1
    3cc4:	69 e0       	ldi	r22, 0x09	; 9
    3cc6:	60 83       	st	Z, r22
    3cc8:	31 97       	sbiw	r30, 0x01	; 1
    3cca:	60 e1       	ldi	r22, 0x10	; 16
    3ccc:	60 83       	st	Z, r22
    3cce:	31 97       	sbiw	r30, 0x01	; 1
    3cd0:	30 83       	st	Z, r19
    3cd2:	31 97       	sbiw	r30, 0x01	; 1
    3cd4:	32 e1       	ldi	r19, 0x12	; 18
    3cd6:	30 83       	st	Z, r19
    3cd8:	31 97       	sbiw	r30, 0x01	; 1
    3cda:	33 e1       	ldi	r19, 0x13	; 19
    3cdc:	30 83       	st	Z, r19
    3cde:	31 97       	sbiw	r30, 0x01	; 1
    3ce0:	34 e1       	ldi	r19, 0x14	; 20
    3ce2:	30 83       	st	Z, r19
    3ce4:	31 97       	sbiw	r30, 0x01	; 1
    3ce6:	35 e1       	ldi	r19, 0x15	; 21
    3ce8:	30 83       	st	Z, r19
    3cea:	31 97       	sbiw	r30, 0x01	; 1
    3cec:	36 e1       	ldi	r19, 0x16	; 22
    3cee:	30 83       	st	Z, r19
    3cf0:	31 97       	sbiw	r30, 0x01	; 1
    3cf2:	37 e1       	ldi	r19, 0x17	; 23
    3cf4:	30 83       	st	Z, r19
    3cf6:	31 97       	sbiw	r30, 0x01	; 1
    3cf8:	38 e1       	ldi	r19, 0x18	; 24
    3cfa:	30 83       	st	Z, r19
    3cfc:	31 97       	sbiw	r30, 0x01	; 1
    3cfe:	39 e1       	ldi	r19, 0x19	; 25
    3d00:	30 83       	st	Z, r19
    3d02:	31 97       	sbiw	r30, 0x01	; 1
    3d04:	30 e2       	ldi	r19, 0x20	; 32
    3d06:	30 83       	st	Z, r19
    3d08:	31 97       	sbiw	r30, 0x01	; 1
    3d0a:	31 e2       	ldi	r19, 0x21	; 33
    3d0c:	30 83       	st	Z, r19
    3d0e:	31 97       	sbiw	r30, 0x01	; 1
    3d10:	20 83       	st	Z, r18
    3d12:	31 97       	sbiw	r30, 0x01	; 1
    3d14:	23 e2       	ldi	r18, 0x23	; 35
    3d16:	20 83       	st	Z, r18
    3d18:	31 97       	sbiw	r30, 0x01	; 1
    3d1a:	40 83       	st	Z, r20
    3d1c:	31 97       	sbiw	r30, 0x01	; 1
    3d1e:	50 83       	st	Z, r21
    3d20:	31 97       	sbiw	r30, 0x01	; 1
    3d22:	26 e2       	ldi	r18, 0x26	; 38
    3d24:	20 83       	st	Z, r18
    3d26:	31 97       	sbiw	r30, 0x01	; 1
    3d28:	27 e2       	ldi	r18, 0x27	; 39
    3d2a:	20 83       	st	Z, r18
    3d2c:	31 97       	sbiw	r30, 0x01	; 1
    3d2e:	28 e2       	ldi	r18, 0x28	; 40
    3d30:	20 83       	st	Z, r18
    3d32:	31 97       	sbiw	r30, 0x01	; 1
    3d34:	29 e2       	ldi	r18, 0x29	; 41
    3d36:	20 83       	st	Z, r18
    3d38:	31 97       	sbiw	r30, 0x01	; 1
    3d3a:	20 e3       	ldi	r18, 0x30	; 48
    3d3c:	20 83       	st	Z, r18
    3d3e:	31 97       	sbiw	r30, 0x01	; 1
    3d40:	21 e3       	ldi	r18, 0x31	; 49
    3d42:	20 83       	st	Z, r18
    3d44:	86 97       	sbiw	r24, 0x26	; 38
    3d46:	08 95       	ret

00003d48 <xPortStartScheduler>:
    3d48:	a8 95       	wdr
    3d4a:	90 ec       	ldi	r25, 0xC0	; 192
    3d4c:	88 e1       	ldi	r24, 0x18	; 24
    3d4e:	0f b6       	in	r0, 0x3f	; 63
    3d50:	f8 94       	cli
    3d52:	a8 95       	wdr
    3d54:	80 93 60 00 	sts	0x0060, r24	; 0x800060 <__DATA_REGION_ORIGIN__>
    3d58:	0f be       	out	0x3f, r0	; 63
    3d5a:	90 93 60 00 	sts	0x0060, r25	; 0x800060 <__DATA_REGION_ORIGIN__>
    3d5e:	a0 91 7b 05 	lds	r26, 0x057B	; 0x80057b <pxCurrentTCB>
    3d62:	b0 91 7c 05 	lds	r27, 0x057C	; 0x80057c <pxCurrentTCB+0x1>
    3d66:	cd 91       	ld	r28, X+
    3d68:	cd bf       	out	0x3d, r28	; 61
    3d6a:	dd 91       	ld	r29, X+
    3d6c:	de bf       	out	0x3e, r29	; 62
    3d6e:	ff 91       	pop	r31
    3d70:	ef 91       	pop	r30
    3d72:	df 91       	pop	r29
    3d74:	cf 91       	pop	r28
    3d76:	bf 91       	pop	r27
    3d78:	af 91       	pop	r26
    3d7a:	9f 91       	pop	r25
    3d7c:	8f 91       	pop	r24
    3d7e:	7f 91       	pop	r23
    3d80:	6f 91       	pop	r22
    3d82:	5f 91       	pop	r21
    3d84:	4f 91       	pop	r20
    3d86:	3f 91       	pop	r19
    3d88:	2f 91       	pop	r18
    3d8a:	1f 91       	pop	r17
    3d8c:	0f 91       	pop	r16
    3d8e:	ff 90       	pop	r15
    3d90:	ef 90       	pop	r14
    3d92:	df 90       	pop	r13
    3d94:	cf 90       	pop	r12
    3d96:	bf 90       	pop	r11
    3d98:	af 90       	pop	r10
    3d9a:	9f 90       	pop	r9
    3d9c:	8f 90       	pop	r8
    3d9e:	7f 90       	pop	r7
    3da0:	6f 90       	pop	r6
    3da2:	5f 90       	pop	r5
    3da4:	4f 90       	pop	r4
    3da6:	3f 90       	pop	r3
    3da8:	2f 90       	pop	r2
    3daa:	1f 90       	pop	r1
    3dac:	0f 90       	pop	r0
    3dae:	0f be       	out	0x3f, r0	; 63
    3db0:	0f 90       	pop	r0
    3db2:	08 95       	ret
    3db4:	81 e0       	ldi	r24, 0x01	; 1
    3db6:	08 95       	ret

00003db8 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( hot, flatten, naked ) );
void vPortYield( void )
{
    portSAVE_CONTEXT();
    3db8:	0f 92       	push	r0
    3dba:	0f b6       	in	r0, 0x3f	; 63
    3dbc:	f8 94       	cli
    3dbe:	0f 92       	push	r0
    3dc0:	1f 92       	push	r1
    3dc2:	11 24       	eor	r1, r1
    3dc4:	2f 92       	push	r2
    3dc6:	3f 92       	push	r3
    3dc8:	4f 92       	push	r4
    3dca:	5f 92       	push	r5
    3dcc:	6f 92       	push	r6
    3dce:	7f 92       	push	r7
    3dd0:	8f 92       	push	r8
    3dd2:	9f 92       	push	r9
    3dd4:	af 92       	push	r10
    3dd6:	bf 92       	push	r11
    3dd8:	cf 92       	push	r12
    3dda:	df 92       	push	r13
    3ddc:	ef 92       	push	r14
    3dde:	ff 92       	push	r15
    3de0:	0f 93       	push	r16
    3de2:	1f 93       	push	r17
    3de4:	2f 93       	push	r18
    3de6:	3f 93       	push	r19
    3de8:	4f 93       	push	r20
    3dea:	5f 93       	push	r21
    3dec:	6f 93       	push	r22
    3dee:	7f 93       	push	r23
    3df0:	8f 93       	push	r24
    3df2:	9f 93       	push	r25
    3df4:	af 93       	push	r26
    3df6:	bf 93       	push	r27
    3df8:	cf 93       	push	r28
    3dfa:	df 93       	push	r29
    3dfc:	ef 93       	push	r30
    3dfe:	ff 93       	push	r31
    3e00:	a0 91 7b 05 	lds	r26, 0x057B	; 0x80057b <pxCurrentTCB>
    3e04:	b0 91 7c 05 	lds	r27, 0x057C	; 0x80057c <pxCurrentTCB+0x1>
    3e08:	0d b6       	in	r0, 0x3d	; 61
    3e0a:	0d 92       	st	X+, r0
    3e0c:	0e b6       	in	r0, 0x3e	; 62
    3e0e:	0d 92       	st	X+, r0
    vTaskSwitchContext();
    3e10:	0e 94 8f 19 	call	0x331e	; 0x331e <vTaskSwitchContext>
    portRESTORE_CONTEXT();
    3e14:	a0 91 7b 05 	lds	r26, 0x057B	; 0x80057b <pxCurrentTCB>
    3e18:	b0 91 7c 05 	lds	r27, 0x057C	; 0x80057c <pxCurrentTCB+0x1>
    3e1c:	cd 91       	ld	r28, X+
    3e1e:	cd bf       	out	0x3d, r28	; 61
    3e20:	dd 91       	ld	r29, X+
    3e22:	de bf       	out	0x3e, r29	; 62
    3e24:	ff 91       	pop	r31
    3e26:	ef 91       	pop	r30
    3e28:	df 91       	pop	r29
    3e2a:	cf 91       	pop	r28
    3e2c:	bf 91       	pop	r27
    3e2e:	af 91       	pop	r26
    3e30:	9f 91       	pop	r25
    3e32:	8f 91       	pop	r24
    3e34:	7f 91       	pop	r23
    3e36:	6f 91       	pop	r22
    3e38:	5f 91       	pop	r21
    3e3a:	4f 91       	pop	r20
    3e3c:	3f 91       	pop	r19
    3e3e:	2f 91       	pop	r18
    3e40:	1f 91       	pop	r17
    3e42:	0f 91       	pop	r16
    3e44:	ff 90       	pop	r15
    3e46:	ef 90       	pop	r14
    3e48:	df 90       	pop	r13
    3e4a:	cf 90       	pop	r12
    3e4c:	bf 90       	pop	r11
    3e4e:	af 90       	pop	r10
    3e50:	9f 90       	pop	r9
    3e52:	8f 90       	pop	r8
    3e54:	7f 90       	pop	r7
    3e56:	6f 90       	pop	r6
    3e58:	5f 90       	pop	r5
    3e5a:	4f 90       	pop	r4
    3e5c:	3f 90       	pop	r3
    3e5e:	2f 90       	pop	r2
    3e60:	1f 90       	pop	r1
    3e62:	0f 90       	pop	r0
    3e64:	0f be       	out	0x3f, r0	; 63
    3e66:	0f 90       	pop	r0

    __asm__ __volatile__ ( "ret" );
    3e68:	08 95       	ret

00003e6a <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( hot, flatten, naked ) );
void vPortYieldFromTick( void )
{
    portSAVE_CONTEXT();
    3e6a:	0f 92       	push	r0
    3e6c:	0f b6       	in	r0, 0x3f	; 63
    3e6e:	f8 94       	cli
    3e70:	0f 92       	push	r0
    3e72:	1f 92       	push	r1
    3e74:	11 24       	eor	r1, r1
    3e76:	2f 92       	push	r2
    3e78:	3f 92       	push	r3
    3e7a:	4f 92       	push	r4
    3e7c:	5f 92       	push	r5
    3e7e:	6f 92       	push	r6
    3e80:	7f 92       	push	r7
    3e82:	8f 92       	push	r8
    3e84:	9f 92       	push	r9
    3e86:	af 92       	push	r10
    3e88:	bf 92       	push	r11
    3e8a:	cf 92       	push	r12
    3e8c:	df 92       	push	r13
    3e8e:	ef 92       	push	r14
    3e90:	ff 92       	push	r15
    3e92:	0f 93       	push	r16
    3e94:	1f 93       	push	r17
    3e96:	2f 93       	push	r18
    3e98:	3f 93       	push	r19
    3e9a:	4f 93       	push	r20
    3e9c:	5f 93       	push	r21
    3e9e:	6f 93       	push	r22
    3ea0:	7f 93       	push	r23
    3ea2:	8f 93       	push	r24
    3ea4:	9f 93       	push	r25
    3ea6:	af 93       	push	r26
    3ea8:	bf 93       	push	r27
    3eaa:	cf 93       	push	r28
    3eac:	df 93       	push	r29
    3eae:	ef 93       	push	r30
    3eb0:	ff 93       	push	r31
    3eb2:	a0 91 7b 05 	lds	r26, 0x057B	; 0x80057b <pxCurrentTCB>
    3eb6:	b0 91 7c 05 	lds	r27, 0x057C	; 0x80057c <pxCurrentTCB+0x1>
    3eba:	0d b6       	in	r0, 0x3d	; 61
    3ebc:	0d 92       	st	X+, r0
    3ebe:	0e b6       	in	r0, 0x3e	; 62
    3ec0:	0d 92       	st	X+, r0

    sleep_reset();        //     reset the sleep_mode() faster than sleep_disable();
    3ec2:	13 be       	out	0x33, r1	; 51

    if( xTaskIncrementTick() != pdFALSE )
    3ec4:	0e 94 3c 18 	call	0x3078	; 0x3078 <xTaskIncrementTick>
    3ec8:	81 11       	cpse	r24, r1
    {
        vTaskSwitchContext();
    3eca:	0e 94 8f 19 	call	0x331e	; 0x331e <vTaskSwitchContext>
    }

    portRESTORE_CONTEXT();
    3ece:	a0 91 7b 05 	lds	r26, 0x057B	; 0x80057b <pxCurrentTCB>
    3ed2:	b0 91 7c 05 	lds	r27, 0x057C	; 0x80057c <pxCurrentTCB+0x1>
    3ed6:	cd 91       	ld	r28, X+
    3ed8:	cd bf       	out	0x3d, r28	; 61
    3eda:	dd 91       	ld	r29, X+
    3edc:	de bf       	out	0x3e, r29	; 62
    3ede:	ff 91       	pop	r31
    3ee0:	ef 91       	pop	r30
    3ee2:	df 91       	pop	r29
    3ee4:	cf 91       	pop	r28
    3ee6:	bf 91       	pop	r27
    3ee8:	af 91       	pop	r26
    3eea:	9f 91       	pop	r25
    3eec:	8f 91       	pop	r24
    3eee:	7f 91       	pop	r23
    3ef0:	6f 91       	pop	r22
    3ef2:	5f 91       	pop	r21
    3ef4:	4f 91       	pop	r20
    3ef6:	3f 91       	pop	r19
    3ef8:	2f 91       	pop	r18
    3efa:	1f 91       	pop	r17
    3efc:	0f 91       	pop	r16
    3efe:	ff 90       	pop	r15
    3f00:	ef 90       	pop	r14
    3f02:	df 90       	pop	r13
    3f04:	cf 90       	pop	r12
    3f06:	bf 90       	pop	r11
    3f08:	af 90       	pop	r10
    3f0a:	9f 90       	pop	r9
    3f0c:	8f 90       	pop	r8
    3f0e:	7f 90       	pop	r7
    3f10:	6f 90       	pop	r6
    3f12:	5f 90       	pop	r5
    3f14:	4f 90       	pop	r4
    3f16:	3f 90       	pop	r3
    3f18:	2f 90       	pop	r2
    3f1a:	1f 90       	pop	r1
    3f1c:	0f 90       	pop	r0
    3f1e:	0f be       	out	0x3f, r0	; 63
    3f20:	0f 90       	pop	r0

    __asm__ __volatile__ ( "ret" );
    3f22:	08 95       	ret

00003f24 <__vector_6>:
     */
    ISR(portSCHEDULER_ISR, ISR_NAKED) __attribute__ ((hot, flatten));
//  ISR(portSCHEDULER_ISR, ISR_NAKED ISR_NOBLOCK) __attribute__ ((hot, flatten));
    ISR(portSCHEDULER_ISR)
    {
        vPortYieldFromTick();
    3f24:	0e 94 35 1f 	call	0x3e6a	; 0x3e6a <vPortYieldFromTick>
        __asm__ __volatile__ ( "reti" );
    3f28:	18 95       	reti

00003f2a <__unordsf2>:
    3f2a:	0e 94 9d 0c 	call	0x193a	; 0x193a <__fp_cmp>
    3f2e:	88 0b       	sbc	r24, r24
    3f30:	99 0b       	sbc	r25, r25
    3f32:	08 95       	ret

00003f34 <__divmodhi4>:
    3f34:	97 fb       	bst	r25, 7
    3f36:	07 2e       	mov	r0, r23
    3f38:	16 f4       	brtc	.+4      	; 0x3f3e <__divmodhi4+0xa>
    3f3a:	00 94       	com	r0
    3f3c:	07 d0       	rcall	.+14     	; 0x3f4c <__divmodhi4_neg1>
    3f3e:	77 fd       	sbrc	r23, 7
    3f40:	09 d0       	rcall	.+18     	; 0x3f54 <__divmodhi4_neg2>
    3f42:	0e 94 f5 1f 	call	0x3fea	; 0x3fea <__udivmodhi4>
    3f46:	07 fc       	sbrc	r0, 7
    3f48:	05 d0       	rcall	.+10     	; 0x3f54 <__divmodhi4_neg2>
    3f4a:	3e f4       	brtc	.+14     	; 0x3f5a <__divmodhi4_exit>

00003f4c <__divmodhi4_neg1>:
    3f4c:	90 95       	com	r25
    3f4e:	81 95       	neg	r24
    3f50:	9f 4f       	sbci	r25, 0xFF	; 255
    3f52:	08 95       	ret

00003f54 <__divmodhi4_neg2>:
    3f54:	70 95       	com	r23
    3f56:	61 95       	neg	r22
    3f58:	7f 4f       	sbci	r23, 0xFF	; 255

00003f5a <__divmodhi4_exit>:
    3f5a:	08 95       	ret

00003f5c <__udivmodsi4>:
    3f5c:	a1 e2       	ldi	r26, 0x21	; 33
    3f5e:	1a 2e       	mov	r1, r26
    3f60:	aa 1b       	sub	r26, r26
    3f62:	bb 1b       	sub	r27, r27
    3f64:	fd 01       	movw	r30, r26
    3f66:	0d c0       	rjmp	.+26     	; 0x3f82 <__udivmodsi4_ep>

00003f68 <__udivmodsi4_loop>:
    3f68:	aa 1f       	adc	r26, r26
    3f6a:	bb 1f       	adc	r27, r27
    3f6c:	ee 1f       	adc	r30, r30
    3f6e:	ff 1f       	adc	r31, r31
    3f70:	a2 17       	cp	r26, r18
    3f72:	b3 07       	cpc	r27, r19
    3f74:	e4 07       	cpc	r30, r20
    3f76:	f5 07       	cpc	r31, r21
    3f78:	20 f0       	brcs	.+8      	; 0x3f82 <__udivmodsi4_ep>
    3f7a:	a2 1b       	sub	r26, r18
    3f7c:	b3 0b       	sbc	r27, r19
    3f7e:	e4 0b       	sbc	r30, r20
    3f80:	f5 0b       	sbc	r31, r21

00003f82 <__udivmodsi4_ep>:
    3f82:	66 1f       	adc	r22, r22
    3f84:	77 1f       	adc	r23, r23
    3f86:	88 1f       	adc	r24, r24
    3f88:	99 1f       	adc	r25, r25
    3f8a:	1a 94       	dec	r1
    3f8c:	69 f7       	brne	.-38     	; 0x3f68 <__udivmodsi4_loop>
    3f8e:	60 95       	com	r22
    3f90:	70 95       	com	r23
    3f92:	80 95       	com	r24
    3f94:	90 95       	com	r25
    3f96:	9b 01       	movw	r18, r22
    3f98:	ac 01       	movw	r20, r24
    3f9a:	bd 01       	movw	r22, r26
    3f9c:	cf 01       	movw	r24, r30
    3f9e:	08 95       	ret

00003fa0 <__divmodsi4>:
    3fa0:	05 2e       	mov	r0, r21
    3fa2:	97 fb       	bst	r25, 7
    3fa4:	1e f4       	brtc	.+6      	; 0x3fac <__divmodsi4+0xc>
    3fa6:	00 94       	com	r0
    3fa8:	0e 94 e7 1f 	call	0x3fce	; 0x3fce <__negsi2>
    3fac:	57 fd       	sbrc	r21, 7
    3fae:	07 d0       	rcall	.+14     	; 0x3fbe <__divmodsi4_neg2>
    3fb0:	0e 94 ae 1f 	call	0x3f5c	; 0x3f5c <__udivmodsi4>
    3fb4:	07 fc       	sbrc	r0, 7
    3fb6:	03 d0       	rcall	.+6      	; 0x3fbe <__divmodsi4_neg2>
    3fb8:	4e f4       	brtc	.+18     	; 0x3fcc <__divmodsi4_exit>
    3fba:	0c 94 e7 1f 	jmp	0x3fce	; 0x3fce <__negsi2>

00003fbe <__divmodsi4_neg2>:
    3fbe:	50 95       	com	r21
    3fc0:	40 95       	com	r20
    3fc2:	30 95       	com	r19
    3fc4:	21 95       	neg	r18
    3fc6:	3f 4f       	sbci	r19, 0xFF	; 255
    3fc8:	4f 4f       	sbci	r20, 0xFF	; 255
    3fca:	5f 4f       	sbci	r21, 0xFF	; 255

00003fcc <__divmodsi4_exit>:
    3fcc:	08 95       	ret

00003fce <__negsi2>:
    3fce:	90 95       	com	r25
    3fd0:	80 95       	com	r24
    3fd2:	70 95       	com	r23
    3fd4:	61 95       	neg	r22
    3fd6:	7f 4f       	sbci	r23, 0xFF	; 255
    3fd8:	8f 4f       	sbci	r24, 0xFF	; 255
    3fda:	9f 4f       	sbci	r25, 0xFF	; 255
    3fdc:	08 95       	ret

00003fde <__tablejump2__>:
    3fde:	ee 0f       	add	r30, r30
    3fe0:	ff 1f       	adc	r31, r31
    3fe2:	05 90       	lpm	r0, Z+
    3fe4:	f4 91       	lpm	r31, Z
    3fe6:	e0 2d       	mov	r30, r0
    3fe8:	09 94       	ijmp

00003fea <__udivmodhi4>:
    3fea:	aa 1b       	sub	r26, r26
    3fec:	bb 1b       	sub	r27, r27
    3fee:	51 e1       	ldi	r21, 0x11	; 17
    3ff0:	07 c0       	rjmp	.+14     	; 0x4000 <__udivmodhi4_ep>

00003ff2 <__udivmodhi4_loop>:
    3ff2:	aa 1f       	adc	r26, r26
    3ff4:	bb 1f       	adc	r27, r27
    3ff6:	a6 17       	cp	r26, r22
    3ff8:	b7 07       	cpc	r27, r23
    3ffa:	10 f0       	brcs	.+4      	; 0x4000 <__udivmodhi4_ep>
    3ffc:	a6 1b       	sub	r26, r22
    3ffe:	b7 0b       	sbc	r27, r23

00004000 <__udivmodhi4_ep>:
    4000:	88 1f       	adc	r24, r24
    4002:	99 1f       	adc	r25, r25
    4004:	5a 95       	dec	r21
    4006:	a9 f7       	brne	.-22     	; 0x3ff2 <__udivmodhi4_loop>
    4008:	80 95       	com	r24
    400a:	90 95       	com	r25
    400c:	bc 01       	movw	r22, r24
    400e:	cd 01       	movw	r24, r26
    4010:	08 95       	ret

00004012 <malloc>:
    4012:	0f 93       	push	r16
    4014:	1f 93       	push	r17
    4016:	cf 93       	push	r28
    4018:	df 93       	push	r29
    401a:	82 30       	cpi	r24, 0x02	; 2
    401c:	91 05       	cpc	r25, r1
    401e:	10 f4       	brcc	.+4      	; 0x4024 <malloc+0x12>
    4020:	82 e0       	ldi	r24, 0x02	; 2
    4022:	90 e0       	ldi	r25, 0x00	; 0
    4024:	e0 91 aa 05 	lds	r30, 0x05AA	; 0x8005aa <__flp>
    4028:	f0 91 ab 05 	lds	r31, 0x05AB	; 0x8005ab <__flp+0x1>
    402c:	20 e0       	ldi	r18, 0x00	; 0
    402e:	30 e0       	ldi	r19, 0x00	; 0
    4030:	a0 e0       	ldi	r26, 0x00	; 0
    4032:	b0 e0       	ldi	r27, 0x00	; 0
    4034:	30 97       	sbiw	r30, 0x00	; 0
    4036:	19 f1       	breq	.+70     	; 0x407e <malloc+0x6c>
    4038:	40 81       	ld	r20, Z
    403a:	51 81       	ldd	r21, Z+1	; 0x01
    403c:	02 81       	ldd	r16, Z+2	; 0x02
    403e:	13 81       	ldd	r17, Z+3	; 0x03
    4040:	48 17       	cp	r20, r24
    4042:	59 07       	cpc	r21, r25
    4044:	c8 f0       	brcs	.+50     	; 0x4078 <malloc+0x66>
    4046:	84 17       	cp	r24, r20
    4048:	95 07       	cpc	r25, r21
    404a:	69 f4       	brne	.+26     	; 0x4066 <malloc+0x54>
    404c:	10 97       	sbiw	r26, 0x00	; 0
    404e:	31 f0       	breq	.+12     	; 0x405c <malloc+0x4a>
    4050:	12 96       	adiw	r26, 0x02	; 2
    4052:	0c 93       	st	X, r16
    4054:	12 97       	sbiw	r26, 0x02	; 2
    4056:	13 96       	adiw	r26, 0x03	; 3
    4058:	1c 93       	st	X, r17
    405a:	27 c0       	rjmp	.+78     	; 0x40aa <malloc+0x98>
    405c:	00 93 aa 05 	sts	0x05AA, r16	; 0x8005aa <__flp>
    4060:	10 93 ab 05 	sts	0x05AB, r17	; 0x8005ab <__flp+0x1>
    4064:	22 c0       	rjmp	.+68     	; 0x40aa <malloc+0x98>
    4066:	21 15       	cp	r18, r1
    4068:	31 05       	cpc	r19, r1
    406a:	19 f0       	breq	.+6      	; 0x4072 <malloc+0x60>
    406c:	42 17       	cp	r20, r18
    406e:	53 07       	cpc	r21, r19
    4070:	18 f4       	brcc	.+6      	; 0x4078 <malloc+0x66>
    4072:	9a 01       	movw	r18, r20
    4074:	bd 01       	movw	r22, r26
    4076:	ef 01       	movw	r28, r30
    4078:	df 01       	movw	r26, r30
    407a:	f8 01       	movw	r30, r16
    407c:	db cf       	rjmp	.-74     	; 0x4034 <malloc+0x22>
    407e:	21 15       	cp	r18, r1
    4080:	31 05       	cpc	r19, r1
    4082:	f9 f0       	breq	.+62     	; 0x40c2 <malloc+0xb0>
    4084:	28 1b       	sub	r18, r24
    4086:	39 0b       	sbc	r19, r25
    4088:	24 30       	cpi	r18, 0x04	; 4
    408a:	31 05       	cpc	r19, r1
    408c:	80 f4       	brcc	.+32     	; 0x40ae <malloc+0x9c>
    408e:	8a 81       	ldd	r24, Y+2	; 0x02
    4090:	9b 81       	ldd	r25, Y+3	; 0x03
    4092:	61 15       	cp	r22, r1
    4094:	71 05       	cpc	r23, r1
    4096:	21 f0       	breq	.+8      	; 0x40a0 <malloc+0x8e>
    4098:	fb 01       	movw	r30, r22
    409a:	93 83       	std	Z+3, r25	; 0x03
    409c:	82 83       	std	Z+2, r24	; 0x02
    409e:	04 c0       	rjmp	.+8      	; 0x40a8 <malloc+0x96>
    40a0:	90 93 ab 05 	sts	0x05AB, r25	; 0x8005ab <__flp+0x1>
    40a4:	80 93 aa 05 	sts	0x05AA, r24	; 0x8005aa <__flp>
    40a8:	fe 01       	movw	r30, r28
    40aa:	32 96       	adiw	r30, 0x02	; 2
    40ac:	44 c0       	rjmp	.+136    	; 0x4136 <malloc+0x124>
    40ae:	fe 01       	movw	r30, r28
    40b0:	e2 0f       	add	r30, r18
    40b2:	f3 1f       	adc	r31, r19
    40b4:	81 93       	st	Z+, r24
    40b6:	91 93       	st	Z+, r25
    40b8:	22 50       	subi	r18, 0x02	; 2
    40ba:	31 09       	sbc	r19, r1
    40bc:	39 83       	std	Y+1, r19	; 0x01
    40be:	28 83       	st	Y, r18
    40c0:	3a c0       	rjmp	.+116    	; 0x4136 <malloc+0x124>
    40c2:	20 91 a8 05 	lds	r18, 0x05A8	; 0x8005a8 <__brkval>
    40c6:	30 91 a9 05 	lds	r19, 0x05A9	; 0x8005a9 <__brkval+0x1>
    40ca:	23 2b       	or	r18, r19
    40cc:	41 f4       	brne	.+16     	; 0x40de <malloc+0xcc>
    40ce:	20 91 02 01 	lds	r18, 0x0102	; 0x800102 <__malloc_heap_start>
    40d2:	30 91 03 01 	lds	r19, 0x0103	; 0x800103 <__malloc_heap_start+0x1>
    40d6:	30 93 a9 05 	sts	0x05A9, r19	; 0x8005a9 <__brkval+0x1>
    40da:	20 93 a8 05 	sts	0x05A8, r18	; 0x8005a8 <__brkval>
    40de:	20 91 00 01 	lds	r18, 0x0100	; 0x800100 <__data_start>
    40e2:	30 91 01 01 	lds	r19, 0x0101	; 0x800101 <__data_start+0x1>
    40e6:	21 15       	cp	r18, r1
    40e8:	31 05       	cpc	r19, r1
    40ea:	41 f4       	brne	.+16     	; 0x40fc <malloc+0xea>
    40ec:	2d b7       	in	r18, 0x3d	; 61
    40ee:	3e b7       	in	r19, 0x3e	; 62
    40f0:	40 91 04 01 	lds	r20, 0x0104	; 0x800104 <__malloc_margin>
    40f4:	50 91 05 01 	lds	r21, 0x0105	; 0x800105 <__malloc_margin+0x1>
    40f8:	24 1b       	sub	r18, r20
    40fa:	35 0b       	sbc	r19, r21
    40fc:	e0 91 a8 05 	lds	r30, 0x05A8	; 0x8005a8 <__brkval>
    4100:	f0 91 a9 05 	lds	r31, 0x05A9	; 0x8005a9 <__brkval+0x1>
    4104:	e2 17       	cp	r30, r18
    4106:	f3 07       	cpc	r31, r19
    4108:	a0 f4       	brcc	.+40     	; 0x4132 <malloc+0x120>
    410a:	2e 1b       	sub	r18, r30
    410c:	3f 0b       	sbc	r19, r31
    410e:	28 17       	cp	r18, r24
    4110:	39 07       	cpc	r19, r25
    4112:	78 f0       	brcs	.+30     	; 0x4132 <malloc+0x120>
    4114:	ac 01       	movw	r20, r24
    4116:	4e 5f       	subi	r20, 0xFE	; 254
    4118:	5f 4f       	sbci	r21, 0xFF	; 255
    411a:	24 17       	cp	r18, r20
    411c:	35 07       	cpc	r19, r21
    411e:	48 f0       	brcs	.+18     	; 0x4132 <malloc+0x120>
    4120:	4e 0f       	add	r20, r30
    4122:	5f 1f       	adc	r21, r31
    4124:	50 93 a9 05 	sts	0x05A9, r21	; 0x8005a9 <__brkval+0x1>
    4128:	40 93 a8 05 	sts	0x05A8, r20	; 0x8005a8 <__brkval>
    412c:	81 93       	st	Z+, r24
    412e:	91 93       	st	Z+, r25
    4130:	02 c0       	rjmp	.+4      	; 0x4136 <malloc+0x124>
    4132:	e0 e0       	ldi	r30, 0x00	; 0
    4134:	f0 e0       	ldi	r31, 0x00	; 0
    4136:	cf 01       	movw	r24, r30
    4138:	df 91       	pop	r29
    413a:	cf 91       	pop	r28
    413c:	1f 91       	pop	r17
    413e:	0f 91       	pop	r16
    4140:	08 95       	ret

00004142 <free>:
    4142:	cf 93       	push	r28
    4144:	df 93       	push	r29
    4146:	00 97       	sbiw	r24, 0x00	; 0
    4148:	09 f4       	brne	.+2      	; 0x414c <free+0xa>
    414a:	81 c0       	rjmp	.+258    	; 0x424e <free+0x10c>
    414c:	fc 01       	movw	r30, r24
    414e:	32 97       	sbiw	r30, 0x02	; 2
    4150:	13 82       	std	Z+3, r1	; 0x03
    4152:	12 82       	std	Z+2, r1	; 0x02
    4154:	a0 91 aa 05 	lds	r26, 0x05AA	; 0x8005aa <__flp>
    4158:	b0 91 ab 05 	lds	r27, 0x05AB	; 0x8005ab <__flp+0x1>
    415c:	10 97       	sbiw	r26, 0x00	; 0
    415e:	81 f4       	brne	.+32     	; 0x4180 <free+0x3e>
    4160:	20 81       	ld	r18, Z
    4162:	31 81       	ldd	r19, Z+1	; 0x01
    4164:	82 0f       	add	r24, r18
    4166:	93 1f       	adc	r25, r19
    4168:	20 91 a8 05 	lds	r18, 0x05A8	; 0x8005a8 <__brkval>
    416c:	30 91 a9 05 	lds	r19, 0x05A9	; 0x8005a9 <__brkval+0x1>
    4170:	28 17       	cp	r18, r24
    4172:	39 07       	cpc	r19, r25
    4174:	51 f5       	brne	.+84     	; 0x41ca <free+0x88>
    4176:	f0 93 a9 05 	sts	0x05A9, r31	; 0x8005a9 <__brkval+0x1>
    417a:	e0 93 a8 05 	sts	0x05A8, r30	; 0x8005a8 <__brkval>
    417e:	67 c0       	rjmp	.+206    	; 0x424e <free+0x10c>
    4180:	ed 01       	movw	r28, r26
    4182:	20 e0       	ldi	r18, 0x00	; 0
    4184:	30 e0       	ldi	r19, 0x00	; 0
    4186:	ce 17       	cp	r28, r30
    4188:	df 07       	cpc	r29, r31
    418a:	40 f4       	brcc	.+16     	; 0x419c <free+0x5a>
    418c:	4a 81       	ldd	r20, Y+2	; 0x02
    418e:	5b 81       	ldd	r21, Y+3	; 0x03
    4190:	9e 01       	movw	r18, r28
    4192:	41 15       	cp	r20, r1
    4194:	51 05       	cpc	r21, r1
    4196:	f1 f0       	breq	.+60     	; 0x41d4 <free+0x92>
    4198:	ea 01       	movw	r28, r20
    419a:	f5 cf       	rjmp	.-22     	; 0x4186 <free+0x44>
    419c:	d3 83       	std	Z+3, r29	; 0x03
    419e:	c2 83       	std	Z+2, r28	; 0x02
    41a0:	40 81       	ld	r20, Z
    41a2:	51 81       	ldd	r21, Z+1	; 0x01
    41a4:	84 0f       	add	r24, r20
    41a6:	95 1f       	adc	r25, r21
    41a8:	c8 17       	cp	r28, r24
    41aa:	d9 07       	cpc	r29, r25
    41ac:	59 f4       	brne	.+22     	; 0x41c4 <free+0x82>
    41ae:	88 81       	ld	r24, Y
    41b0:	99 81       	ldd	r25, Y+1	; 0x01
    41b2:	84 0f       	add	r24, r20
    41b4:	95 1f       	adc	r25, r21
    41b6:	02 96       	adiw	r24, 0x02	; 2
    41b8:	91 83       	std	Z+1, r25	; 0x01
    41ba:	80 83       	st	Z, r24
    41bc:	8a 81       	ldd	r24, Y+2	; 0x02
    41be:	9b 81       	ldd	r25, Y+3	; 0x03
    41c0:	93 83       	std	Z+3, r25	; 0x03
    41c2:	82 83       	std	Z+2, r24	; 0x02
    41c4:	21 15       	cp	r18, r1
    41c6:	31 05       	cpc	r19, r1
    41c8:	29 f4       	brne	.+10     	; 0x41d4 <free+0x92>
    41ca:	f0 93 ab 05 	sts	0x05AB, r31	; 0x8005ab <__flp+0x1>
    41ce:	e0 93 aa 05 	sts	0x05AA, r30	; 0x8005aa <__flp>
    41d2:	3d c0       	rjmp	.+122    	; 0x424e <free+0x10c>
    41d4:	e9 01       	movw	r28, r18
    41d6:	fb 83       	std	Y+3, r31	; 0x03
    41d8:	ea 83       	std	Y+2, r30	; 0x02
    41da:	49 91       	ld	r20, Y+
    41dc:	59 91       	ld	r21, Y+
    41de:	c4 0f       	add	r28, r20
    41e0:	d5 1f       	adc	r29, r21
    41e2:	ec 17       	cp	r30, r28
    41e4:	fd 07       	cpc	r31, r29
    41e6:	61 f4       	brne	.+24     	; 0x4200 <free+0xbe>
    41e8:	80 81       	ld	r24, Z
    41ea:	91 81       	ldd	r25, Z+1	; 0x01
    41ec:	84 0f       	add	r24, r20
    41ee:	95 1f       	adc	r25, r21
    41f0:	02 96       	adiw	r24, 0x02	; 2
    41f2:	e9 01       	movw	r28, r18
    41f4:	99 83       	std	Y+1, r25	; 0x01
    41f6:	88 83       	st	Y, r24
    41f8:	82 81       	ldd	r24, Z+2	; 0x02
    41fa:	93 81       	ldd	r25, Z+3	; 0x03
    41fc:	9b 83       	std	Y+3, r25	; 0x03
    41fe:	8a 83       	std	Y+2, r24	; 0x02
    4200:	e0 e0       	ldi	r30, 0x00	; 0
    4202:	f0 e0       	ldi	r31, 0x00	; 0
    4204:	12 96       	adiw	r26, 0x02	; 2
    4206:	8d 91       	ld	r24, X+
    4208:	9c 91       	ld	r25, X
    420a:	13 97       	sbiw	r26, 0x03	; 3
    420c:	00 97       	sbiw	r24, 0x00	; 0
    420e:	19 f0       	breq	.+6      	; 0x4216 <free+0xd4>
    4210:	fd 01       	movw	r30, r26
    4212:	dc 01       	movw	r26, r24
    4214:	f7 cf       	rjmp	.-18     	; 0x4204 <free+0xc2>
    4216:	8d 91       	ld	r24, X+
    4218:	9c 91       	ld	r25, X
    421a:	11 97       	sbiw	r26, 0x01	; 1
    421c:	9d 01       	movw	r18, r26
    421e:	2e 5f       	subi	r18, 0xFE	; 254
    4220:	3f 4f       	sbci	r19, 0xFF	; 255
    4222:	82 0f       	add	r24, r18
    4224:	93 1f       	adc	r25, r19
    4226:	20 91 a8 05 	lds	r18, 0x05A8	; 0x8005a8 <__brkval>
    422a:	30 91 a9 05 	lds	r19, 0x05A9	; 0x8005a9 <__brkval+0x1>
    422e:	28 17       	cp	r18, r24
    4230:	39 07       	cpc	r19, r25
    4232:	69 f4       	brne	.+26     	; 0x424e <free+0x10c>
    4234:	30 97       	sbiw	r30, 0x00	; 0
    4236:	29 f4       	brne	.+10     	; 0x4242 <free+0x100>
    4238:	10 92 ab 05 	sts	0x05AB, r1	; 0x8005ab <__flp+0x1>
    423c:	10 92 aa 05 	sts	0x05AA, r1	; 0x8005aa <__flp>
    4240:	02 c0       	rjmp	.+4      	; 0x4246 <free+0x104>
    4242:	13 82       	std	Z+3, r1	; 0x03
    4244:	12 82       	std	Z+2, r1	; 0x02
    4246:	b0 93 a9 05 	sts	0x05A9, r27	; 0x8005a9 <__brkval+0x1>
    424a:	a0 93 a8 05 	sts	0x05A8, r26	; 0x8005a8 <__brkval>
    424e:	df 91       	pop	r29
    4250:	cf 91       	pop	r28
    4252:	08 95       	ret

00004254 <memcpy>:
    4254:	fb 01       	movw	r30, r22
    4256:	dc 01       	movw	r26, r24
    4258:	02 c0       	rjmp	.+4      	; 0x425e <memcpy+0xa>
    425a:	01 90       	ld	r0, Z+
    425c:	0d 92       	st	X+, r0
    425e:	41 50       	subi	r20, 0x01	; 1
    4260:	50 40       	sbci	r21, 0x00	; 0
    4262:	d8 f7       	brcc	.-10     	; 0x425a <memcpy+0x6>
    4264:	08 95       	ret

00004266 <memset>:
    4266:	dc 01       	movw	r26, r24
    4268:	01 c0       	rjmp	.+2      	; 0x426c <memset+0x6>
    426a:	6d 93       	st	X+, r22
    426c:	41 50       	subi	r20, 0x01	; 1
    426e:	50 40       	sbci	r21, 0x00	; 0
    4270:	e0 f7       	brcc	.-8      	; 0x426a <memset+0x4>
    4272:	08 95       	ret

00004274 <eeprom_read_byte>:
    4274:	f9 99       	sbic	0x1f, 1	; 31
    4276:	fe cf       	rjmp	.-4      	; 0x4274 <eeprom_read_byte>
    4278:	92 bd       	out	0x22, r25	; 34
    427a:	81 bd       	out	0x21, r24	; 33
    427c:	f8 9a       	sbi	0x1f, 0	; 31
    427e:	99 27       	eor	r25, r25
    4280:	80 b5       	in	r24, 0x20	; 32
    4282:	08 95       	ret

00004284 <eeprom_write_byte>:
    4284:	26 2f       	mov	r18, r22

00004286 <eeprom_write_r18>:
    4286:	f9 99       	sbic	0x1f, 1	; 31
    4288:	fe cf       	rjmp	.-4      	; 0x4286 <eeprom_write_r18>
    428a:	1f ba       	out	0x1f, r1	; 31
    428c:	92 bd       	out	0x22, r25	; 34
    428e:	81 bd       	out	0x21, r24	; 33
    4290:	20 bd       	out	0x20, r18	; 32
    4292:	0f b6       	in	r0, 0x3f	; 63
    4294:	f8 94       	cli
    4296:	fa 9a       	sbi	0x1f, 2	; 31
    4298:	f9 9a       	sbi	0x1f, 1	; 31
    429a:	0f be       	out	0x3f, r0	; 63
    429c:	01 96       	adiw	r24, 0x01	; 1
    429e:	08 95       	ret

000042a0 <__do_global_dtors>:
    42a0:	10 e0       	ldi	r17, 0x00	; 0
    42a2:	ce e7       	ldi	r28, 0x7E	; 126
    42a4:	d0 e0       	ldi	r29, 0x00	; 0
    42a6:	04 c0       	rjmp	.+8      	; 0x42b0 <__do_global_dtors+0x10>
    42a8:	fe 01       	movw	r30, r28
    42aa:	0e 94 ef 1f 	call	0x3fde	; 0x3fde <__tablejump2__>
    42ae:	21 96       	adiw	r28, 0x01	; 1
    42b0:	c0 38       	cpi	r28, 0x80	; 128
    42b2:	d1 07       	cpc	r29, r17
    42b4:	c9 f7       	brne	.-14     	; 0x42a8 <__do_global_dtors+0x8>
    42b6:	f8 94       	cli

000042b8 <__stop_program>:
    42b8:	ff cf       	rjmp	.-2      	; 0x42b8 <__stop_program>
