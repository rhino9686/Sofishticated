
lil_fish_tanks_arduino.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         0000014a  00800100  00004bc6  00004c5a  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00004bc6  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          000002c8  0080024a  0080024a  00004da4  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00004da4  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00004dd4  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000a18  00000000  00000000  00004e14  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   0001429a  00000000  00000000  0000582c  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 000040d7  00000000  00000000  00019ac6  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00006c9d  00000000  00000000  0001db9d  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00001e94  00000000  00000000  0002483c  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00004b7c  00000000  00000000  000266d0  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    0000b603  00000000  00000000  0002b24c  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000988  00000000  00000000  0003684f  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 8c 00 	jmp	0x118	; 0x118 <__dtors_end>
       4:	0c 94 90 20 	jmp	0x4120	; 0x4120 <__vector_1>
       8:	0c 94 b7 20 	jmp	0x416e	; 0x416e <__vector_2>
       c:	0c 94 8e 19 	jmp	0x331c	; 0x331c <__vector_3>
      10:	0c 94 8e 19 	jmp	0x331c	; 0x331c <__vector_3>
      14:	0c 94 8e 19 	jmp	0x331c	; 0x331c <__vector_3>
      18:	0c 94 fa 0b 	jmp	0x17f4	; 0x17f4 <__vector_6>
      1c:	0c 94 7f 23 	jmp	0x46fe	; 0x46fe <__vector_7>
      20:	0c 94 b4 00 	jmp	0x168	; 0x168 <__bad_interrupt>
      24:	0c 94 b4 00 	jmp	0x168	; 0x168 <__bad_interrupt>
      28:	0c 94 b4 00 	jmp	0x168	; 0x168 <__bad_interrupt>
      2c:	0c 94 b4 00 	jmp	0x168	; 0x168 <__bad_interrupt>
      30:	0c 94 b4 00 	jmp	0x168	; 0x168 <__bad_interrupt>
      34:	0c 94 b4 00 	jmp	0x168	; 0x168 <__bad_interrupt>
      38:	0c 94 b4 00 	jmp	0x168	; 0x168 <__bad_interrupt>
      3c:	0c 94 b4 00 	jmp	0x168	; 0x168 <__bad_interrupt>
      40:	0c 94 de 20 	jmp	0x41bc	; 0x41bc <__vector_16>
      44:	0c 94 b4 00 	jmp	0x168	; 0x168 <__bad_interrupt>
      48:	0c 94 94 1e 	jmp	0x3d28	; 0x3d28 <__vector_18>
      4c:	0c 94 c6 1e 	jmp	0x3d8c	; 0x3d8c <__vector_19>
      50:	0c 94 b4 00 	jmp	0x168	; 0x168 <__bad_interrupt>
      54:	0c 94 b4 00 	jmp	0x168	; 0x168 <__bad_interrupt>
      58:	0c 94 b4 00 	jmp	0x168	; 0x168 <__bad_interrupt>
      5c:	0c 94 b4 00 	jmp	0x168	; 0x168 <__bad_interrupt>
      60:	0c 94 b4 00 	jmp	0x168	; 0x168 <__bad_interrupt>
      64:	0c 94 b4 00 	jmp	0x168	; 0x168 <__bad_interrupt>
      68:	98 16       	cp	r9, r24
      6a:	98 16       	cp	r9, r24
      6c:	98 16       	cp	r9, r24
      6e:	d7 16       	cp	r13, r23
      70:	c2 16       	cp	r12, r18
      72:	d1 16       	cp	r13, r17
      74:	98 16       	cp	r9, r24
      76:	98 16       	cp	r9, r24
      78:	d7 16       	cp	r13, r23
      7a:	c2 16       	cp	r12, r18

0000007c <__trampolines_end>:
      7c:	0a 46       	sbci	r16, 0x6A	; 106
      7e:	6f 75       	andi	r22, 0x5F	; 95
      80:	6e 64       	ori	r22, 0x4E	; 78
      82:	20 4d       	sbci	r18, 0xD0	; 208
      84:	61 74       	andi	r22, 0x41	; 65
      86:	63 68       	ori	r22, 0x83	; 131
      88:	69 6e       	ori	r22, 0xE9	; 233
      8a:	67 20       	and	r6, r7
      8c:	43 6f       	ori	r20, 0xF3	; 243
      8e:	6c 6f       	ori	r22, 0xFC	; 252
      90:	72 00       	.word	0x0072	; ????

00000092 <_ZL15dscrc2x16_table>:
      92:	00 5e bc e2 61 3f dd 83 c2 9c 7e 20 a3 fd 1f 41     .^..a?....~ ...A
      a2:	00 9d 23 be 46 db 65 f8 8c 11 af 32 ca 57 e9 74     ..#.F.e....2.W.t

000000b2 <digital_pin_to_timer_PGM>:
      b2:	00 00 00 08 00 02 01 00 00 03 04 07 00 00 00 00     ................
      c2:	00 00 00 00                                         ....

000000c6 <digital_pin_to_bit_mask_PGM>:
      c6:	01 02 04 08 10 20 40 80 01 02 04 08 10 20 01 02     ..... @...... ..
      d6:	04 08 10 20                                         ... 

000000da <digital_pin_to_port_PGM>:
      da:	04 04 04 04 04 04 04 04 02 02 02 02 02 02 03 03     ................
      ea:	03 03 03 03                                         ....

000000ee <port_to_input_PGM>:
      ee:	00 00 00 00 23 00 26 00 29 00                       ....#.&.).

000000f8 <port_to_output_PGM>:
      f8:	00 00 00 00 25 00 28 00 2b 00                       ....%.(.+.

00000102 <port_to_mode_PGM>:
     102:	00 00 00 00 24 00 27 00 2a 00                       ....$.'.*.

0000010c <__ctors_start>:
     10c:	39 04       	cpc	r3, r9
     10e:	d1 04       	cpc	r13, r1
     110:	9b 06       	cpc	r9, r27
     112:	f6 1e       	adc	r15, r22

00000114 <__ctors_end>:
     114:	40 04       	cpc	r4, r0
     116:	a2 06       	cpc	r10, r18

00000118 <__dtors_end>:
     118:	11 24       	eor	r1, r1
     11a:	1f be       	out	0x3f, r1	; 63
     11c:	cf ef       	ldi	r28, 0xFF	; 255
     11e:	d8 e0       	ldi	r29, 0x08	; 8
     120:	de bf       	out	0x3e, r29	; 62
     122:	cd bf       	out	0x3d, r28	; 61

00000124 <__do_copy_data>:
     124:	12 e0       	ldi	r17, 0x02	; 2
     126:	a0 e0       	ldi	r26, 0x00	; 0
     128:	b1 e0       	ldi	r27, 0x01	; 1
     12a:	e6 ec       	ldi	r30, 0xC6	; 198
     12c:	fb e4       	ldi	r31, 0x4B	; 75
     12e:	02 c0       	rjmp	.+4      	; 0x134 <__do_copy_data+0x10>
     130:	05 90       	lpm	r0, Z+
     132:	0d 92       	st	X+, r0
     134:	aa 34       	cpi	r26, 0x4A	; 74
     136:	b1 07       	cpc	r27, r17
     138:	d9 f7       	brne	.-10     	; 0x130 <__do_copy_data+0xc>

0000013a <__do_clear_bss>:
     13a:	25 e0       	ldi	r18, 0x05	; 5
     13c:	aa e4       	ldi	r26, 0x4A	; 74
     13e:	b2 e0       	ldi	r27, 0x02	; 2
     140:	01 c0       	rjmp	.+2      	; 0x144 <.do_clear_bss_start>

00000142 <.do_clear_bss_loop>:
     142:	1d 92       	st	X+, r1

00000144 <.do_clear_bss_start>:
     144:	a2 31       	cpi	r26, 0x12	; 18
     146:	b2 07       	cpc	r27, r18
     148:	e1 f7       	brne	.-8      	; 0x142 <.do_clear_bss_loop>

0000014a <__do_global_ctors>:
     14a:	10 e0       	ldi	r17, 0x00	; 0
     14c:	ca e8       	ldi	r28, 0x8A	; 138
     14e:	d0 e0       	ldi	r29, 0x00	; 0
     150:	04 c0       	rjmp	.+8      	; 0x15a <__do_global_ctors+0x10>
     152:	21 97       	sbiw	r28, 0x01	; 1
     154:	fe 01       	movw	r30, r28
     156:	0e 94 4b 24 	call	0x4896	; 0x4896 <__tablejump2__>
     15a:	c6 38       	cpi	r28, 0x86	; 134
     15c:	d1 07       	cpc	r29, r17
     15e:	c9 f7       	brne	.-14     	; 0x152 <__do_global_ctors+0x8>
     160:	0e 94 23 1f 	call	0x3e46	; 0x3e46 <main>
     164:	0c 94 d6 25 	jmp	0x4bac	; 0x4bac <__do_global_dtors>

00000168 <__bad_interrupt>:
     168:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

0000016c <_Z7setupCSv>:

MD_TCS230  CS(S2, S3, OE);

// add possible color strip values to specific arrays
void setupCS()
{
     16c:	0f 93       	push	r16
     16e:	1f 93       	push	r17
     170:	cf 93       	push	r28
     172:	df 93       	push	r29
     174:	cd b7       	in	r28, 0x3d	; 61
     176:	de b7       	in	r29, 0x3e	; 62
     178:	2a 97       	sbiw	r28, 0x0a	; 10
     17a:	0f b6       	in	r0, 0x3f	; 63
     17c:	f8 94       	cli
     17e:	de bf       	out	0x3e, r29	; 62
     180:	0f be       	out	0x3f, r0	; 63
     182:	cd bf       	out	0x3d, r28	; 61
	CS.begin();
     184:	8a e4       	ldi	r24, 0x4A	; 74
     186:	92 e0       	ldi	r25, 0x02	; 2
     188:	0e 94 9d 17 	call	0x2f3a	; 0x2f3a <_ZN9MD_TCS2305beginEv>
	
	int index = 0;
	Color c;
	c.ppm = 0.0;
	c.p = {64, 62, 90};
     18c:	86 e0       	ldi	r24, 0x06	; 6
     18e:	e2 e4       	ldi	r30, 0x42	; 66
     190:	f1 e0       	ldi	r31, 0x01	; 1
     192:	de 01       	movw	r26, r28
     194:	15 96       	adiw	r26, 0x05	; 5
     196:	01 90       	ld	r0, Z+
     198:	0d 92       	st	X+, r0
     19a:	8a 95       	dec	r24
     19c:	e1 f7       	brne	.-8      	; 0x196 <_Z7setupCSv+0x2a>
	Ammonia[index] = c;
     19e:	19 82       	std	Y+1, r1	; 0x01
     1a0:	1a 82       	std	Y+2, r1	; 0x02
     1a2:	1b 82       	std	Y+3, r1	; 0x03
     1a4:	1c 82       	std	Y+4, r1	; 0x04
     1a6:	8a e0       	ldi	r24, 0x0A	; 10
     1a8:	fe 01       	movw	r30, r28
     1aa:	31 96       	adiw	r30, 0x01	; 1
     1ac:	a6 e1       	ldi	r26, 0x16	; 22
     1ae:	b3 e0       	ldi	r27, 0x03	; 3
     1b0:	01 90       	ld	r0, Z+
     1b2:	0d 92       	st	X+, r0
     1b4:	8a 95       	dec	r24
     1b6:	e1 f7       	brne	.-8      	; 0x1b0 <_Z7setupCSv+0x44>

	c.ppm = 0.0;
	c.p = {74, 77, 120};
     1b8:	86 e0       	ldi	r24, 0x06	; 6
     1ba:	e8 e4       	ldi	r30, 0x48	; 72
     1bc:	f1 e0       	ldi	r31, 0x01	; 1
     1be:	de 01       	movw	r26, r28
     1c0:	15 96       	adiw	r26, 0x05	; 5
     1c2:	01 90       	ld	r0, Z+
     1c4:	0d 92       	st	X+, r0
     1c6:	8a 95       	dec	r24
     1c8:	e1 f7       	brne	.-8      	; 0x1c2 <_Z7setupCSv+0x56>
	Nitrite[index] = c;
     1ca:	8a e0       	ldi	r24, 0x0A	; 10
     1cc:	fe 01       	movw	r30, r28
     1ce:	31 96       	adiw	r30, 0x01	; 1
     1d0:	a0 ed       	ldi	r26, 0xD0	; 208
     1d2:	b2 e0       	ldi	r27, 0x02	; 2
     1d4:	01 90       	ld	r0, Z+
     1d6:	0d 92       	st	X+, r0
     1d8:	8a 95       	dec	r24
     1da:	e1 f7       	brne	.-8      	; 0x1d4 <_Z7setupCSv+0x68>

	c.ppm = 0.0;
	c.p = {71, 74, 123};
     1dc:	86 e0       	ldi	r24, 0x06	; 6
     1de:	ee e4       	ldi	r30, 0x4E	; 78
     1e0:	f1 e0       	ldi	r31, 0x01	; 1
     1e2:	de 01       	movw	r26, r28
     1e4:	15 96       	adiw	r26, 0x05	; 5
     1e6:	01 90       	ld	r0, Z+
     1e8:	0d 92       	st	X+, r0
     1ea:	8a 95       	dec	r24
     1ec:	e1 f7       	brne	.-8      	; 0x1e6 <_Z7setupCSv+0x7a>
	Nitrate[index] = c;
     1ee:	8a e0       	ldi	r24, 0x0A	; 10
     1f0:	fe 01       	movw	r30, r28
     1f2:	31 96       	adiw	r30, 0x01	; 1
     1f4:	aa e8       	ldi	r26, 0x8A	; 138
     1f6:	b2 e0       	ldi	r27, 0x02	; 2
     1f8:	01 90       	ld	r0, Z+
     1fa:	0d 92       	st	X+, r0
     1fc:	8a 95       	dec	r24
     1fe:	e1 f7       	brne	.-8      	; 0x1f8 <_Z7setupCSv+0x8c>

	++index;

	c.ppm = 0.5;
	c.p = {61, 62, 91};
     200:	86 e0       	ldi	r24, 0x06	; 6
     202:	e4 e5       	ldi	r30, 0x54	; 84
     204:	f1 e0       	ldi	r31, 0x01	; 1
     206:	de 01       	movw	r26, r28
     208:	15 96       	adiw	r26, 0x05	; 5
     20a:	01 90       	ld	r0, Z+
     20c:	0d 92       	st	X+, r0
     20e:	8a 95       	dec	r24
     210:	e1 f7       	brne	.-8      	; 0x20a <_Z7setupCSv+0x9e>
	Ammonia[index] = c;
     212:	40 e0       	ldi	r20, 0x00	; 0
     214:	50 e0       	ldi	r21, 0x00	; 0
     216:	60 e0       	ldi	r22, 0x00	; 0
     218:	7f e3       	ldi	r23, 0x3F	; 63
     21a:	49 83       	std	Y+1, r20	; 0x01
     21c:	5a 83       	std	Y+2, r21	; 0x02
     21e:	6b 83       	std	Y+3, r22	; 0x03
     220:	7c 83       	std	Y+4, r23	; 0x04
     222:	8a e0       	ldi	r24, 0x0A	; 10
     224:	fe 01       	movw	r30, r28
     226:	31 96       	adiw	r30, 0x01	; 1
     228:	a0 e2       	ldi	r26, 0x20	; 32
     22a:	b3 e0       	ldi	r27, 0x03	; 3
     22c:	01 90       	ld	r0, Z+
     22e:	0d 92       	st	X+, r0
     230:	8a 95       	dec	r24
     232:	e1 f7       	brne	.-8      	; 0x22c <_Z7setupCSv+0xc0>

	c.ppm = 0.15;
	c.p = {71, 74, 123};
     234:	86 e0       	ldi	r24, 0x06	; 6
     236:	ee e4       	ldi	r30, 0x4E	; 78
     238:	f1 e0       	ldi	r31, 0x01	; 1
     23a:	de 01       	movw	r26, r28
     23c:	15 96       	adiw	r26, 0x05	; 5
     23e:	01 90       	ld	r0, Z+
     240:	0d 92       	st	X+, r0
     242:	8a 95       	dec	r24
     244:	e1 f7       	brne	.-8      	; 0x23e <_Z7setupCSv+0xd2>
	Nitrite[index] = c;
     246:	8a e9       	ldi	r24, 0x9A	; 154
     248:	99 e9       	ldi	r25, 0x99	; 153
     24a:	a9 e1       	ldi	r26, 0x19	; 25
     24c:	be e3       	ldi	r27, 0x3E	; 62
     24e:	89 83       	std	Y+1, r24	; 0x01
     250:	9a 83       	std	Y+2, r25	; 0x02
     252:	ab 83       	std	Y+3, r26	; 0x03
     254:	bc 83       	std	Y+4, r27	; 0x04
     256:	8a e0       	ldi	r24, 0x0A	; 10
     258:	fe 01       	movw	r30, r28
     25a:	31 96       	adiw	r30, 0x01	; 1
     25c:	aa ed       	ldi	r26, 0xDA	; 218
     25e:	b2 e0       	ldi	r27, 0x02	; 2
     260:	01 90       	ld	r0, Z+
     262:	0d 92       	st	X+, r0
     264:	8a 95       	dec	r24
     266:	e1 f7       	brne	.-8      	; 0x260 <_Z7setupCSv+0xf4>

	c.ppm = 0.5;
	c.p = {60, 60, 101};
     268:	86 e0       	ldi	r24, 0x06	; 6
     26a:	ea e5       	ldi	r30, 0x5A	; 90
     26c:	f1 e0       	ldi	r31, 0x01	; 1
     26e:	de 01       	movw	r26, r28
     270:	15 96       	adiw	r26, 0x05	; 5
     272:	01 90       	ld	r0, Z+
     274:	0d 92       	st	X+, r0
     276:	8a 95       	dec	r24
     278:	e1 f7       	brne	.-8      	; 0x272 <_Z7setupCSv+0x106>
	Nitrate[index] = c;
     27a:	49 83       	std	Y+1, r20	; 0x01
     27c:	5a 83       	std	Y+2, r21	; 0x02
     27e:	6b 83       	std	Y+3, r22	; 0x03
     280:	7c 83       	std	Y+4, r23	; 0x04
     282:	8a e0       	ldi	r24, 0x0A	; 10
     284:	fe 01       	movw	r30, r28
     286:	31 96       	adiw	r30, 0x01	; 1
     288:	a4 e9       	ldi	r26, 0x94	; 148
     28a:	b2 e0       	ldi	r27, 0x02	; 2
     28c:	01 90       	ld	r0, Z+
     28e:	0d 92       	st	X+, r0
     290:	8a 95       	dec	r24
     292:	e1 f7       	brne	.-8      	; 0x28c <_Z7setupCSv+0x120>

	++index;

	c.ppm = 1.0;
	c.p = {50, 63, 90};
     294:	86 e0       	ldi	r24, 0x06	; 6
     296:	e0 e6       	ldi	r30, 0x60	; 96
     298:	f1 e0       	ldi	r31, 0x01	; 1
     29a:	de 01       	movw	r26, r28
     29c:	15 96       	adiw	r26, 0x05	; 5
     29e:	01 90       	ld	r0, Z+
     2a0:	0d 92       	st	X+, r0
     2a2:	8a 95       	dec	r24
     2a4:	e1 f7       	brne	.-8      	; 0x29e <_Z7setupCSv+0x132>
	Ammonia[index] = c;
     2a6:	40 e0       	ldi	r20, 0x00	; 0
     2a8:	50 e0       	ldi	r21, 0x00	; 0
     2aa:	60 e8       	ldi	r22, 0x80	; 128
     2ac:	7f e3       	ldi	r23, 0x3F	; 63
     2ae:	49 83       	std	Y+1, r20	; 0x01
     2b0:	5a 83       	std	Y+2, r21	; 0x02
     2b2:	6b 83       	std	Y+3, r22	; 0x03
     2b4:	7c 83       	std	Y+4, r23	; 0x04
     2b6:	8a e0       	ldi	r24, 0x0A	; 10
     2b8:	fe 01       	movw	r30, r28
     2ba:	31 96       	adiw	r30, 0x01	; 1
     2bc:	aa e2       	ldi	r26, 0x2A	; 42
     2be:	b3 e0       	ldi	r27, 0x03	; 3
     2c0:	01 90       	ld	r0, Z+
     2c2:	0d 92       	st	X+, r0
     2c4:	8a 95       	dec	r24
     2c6:	e1 f7       	brne	.-8      	; 0x2c0 <_Z7setupCSv+0x154>

	c.ppm = 0.3;
	c.p = {64, 67, 114};
     2c8:	86 e0       	ldi	r24, 0x06	; 6
     2ca:	e6 e6       	ldi	r30, 0x66	; 102
     2cc:	f1 e0       	ldi	r31, 0x01	; 1
     2ce:	de 01       	movw	r26, r28
     2d0:	15 96       	adiw	r26, 0x05	; 5
     2d2:	01 90       	ld	r0, Z+
     2d4:	0d 92       	st	X+, r0
     2d6:	8a 95       	dec	r24
     2d8:	e1 f7       	brne	.-8      	; 0x2d2 <_Z7setupCSv+0x166>
	Nitrite[index] = c;
     2da:	8a e9       	ldi	r24, 0x9A	; 154
     2dc:	99 e9       	ldi	r25, 0x99	; 153
     2de:	a9 e9       	ldi	r26, 0x99	; 153
     2e0:	be e3       	ldi	r27, 0x3E	; 62
     2e2:	89 83       	std	Y+1, r24	; 0x01
     2e4:	9a 83       	std	Y+2, r25	; 0x02
     2e6:	ab 83       	std	Y+3, r26	; 0x03
     2e8:	bc 83       	std	Y+4, r27	; 0x04
     2ea:	8a e0       	ldi	r24, 0x0A	; 10
     2ec:	fe 01       	movw	r30, r28
     2ee:	31 96       	adiw	r30, 0x01	; 1
     2f0:	a4 ee       	ldi	r26, 0xE4	; 228
     2f2:	b2 e0       	ldi	r27, 0x02	; 2
     2f4:	01 90       	ld	r0, Z+
     2f6:	0d 92       	st	X+, r0
     2f8:	8a 95       	dec	r24
     2fa:	e1 f7       	brne	.-8      	; 0x2f4 <_Z7setupCSv+0x188>

	c.ppm = 2.0;
	c.p = {68, 65, 114};
     2fc:	86 e0       	ldi	r24, 0x06	; 6
     2fe:	ec e6       	ldi	r30, 0x6C	; 108
     300:	f1 e0       	ldi	r31, 0x01	; 1
     302:	de 01       	movw	r26, r28
     304:	15 96       	adiw	r26, 0x05	; 5
     306:	01 90       	ld	r0, Z+
     308:	0d 92       	st	X+, r0
     30a:	8a 95       	dec	r24
     30c:	e1 f7       	brne	.-8      	; 0x306 <_Z7setupCSv+0x19a>
	Nitrate[index] = c;
     30e:	80 e0       	ldi	r24, 0x00	; 0
     310:	90 e0       	ldi	r25, 0x00	; 0
     312:	a0 e0       	ldi	r26, 0x00	; 0
     314:	b0 e4       	ldi	r27, 0x40	; 64
     316:	89 83       	std	Y+1, r24	; 0x01
     318:	9a 83       	std	Y+2, r25	; 0x02
     31a:	ab 83       	std	Y+3, r26	; 0x03
     31c:	bc 83       	std	Y+4, r27	; 0x04
     31e:	8a e0       	ldi	r24, 0x0A	; 10
     320:	fe 01       	movw	r30, r28
     322:	31 96       	adiw	r30, 0x01	; 1
     324:	ae e9       	ldi	r26, 0x9E	; 158
     326:	b2 e0       	ldi	r27, 0x02	; 2
     328:	01 90       	ld	r0, Z+
     32a:	0d 92       	st	X+, r0
     32c:	8a 95       	dec	r24
     32e:	e1 f7       	brne	.-8      	; 0x328 <_Z7setupCSv+0x1bc>

	++index;

	c.ppm = 3.0;
	c.p = {52, 60, 90};
     330:	86 e0       	ldi	r24, 0x06	; 6
     332:	e2 e7       	ldi	r30, 0x72	; 114
     334:	f1 e0       	ldi	r31, 0x01	; 1
     336:	de 01       	movw	r26, r28
     338:	15 96       	adiw	r26, 0x05	; 5
     33a:	01 90       	ld	r0, Z+
     33c:	0d 92       	st	X+, r0
     33e:	8a 95       	dec	r24
     340:	e1 f7       	brne	.-8      	; 0x33a <_Z7setupCSv+0x1ce>
	Ammonia[index] = c;
     342:	00 e0       	ldi	r16, 0x00	; 0
     344:	10 e0       	ldi	r17, 0x00	; 0
     346:	20 e4       	ldi	r18, 0x40	; 64
     348:	30 e4       	ldi	r19, 0x40	; 64
     34a:	09 83       	std	Y+1, r16	; 0x01
     34c:	1a 83       	std	Y+2, r17	; 0x02
     34e:	2b 83       	std	Y+3, r18	; 0x03
     350:	3c 83       	std	Y+4, r19	; 0x04
     352:	8a e0       	ldi	r24, 0x0A	; 10
     354:	fe 01       	movw	r30, r28
     356:	31 96       	adiw	r30, 0x01	; 1
     358:	a4 e3       	ldi	r26, 0x34	; 52
     35a:	b3 e0       	ldi	r27, 0x03	; 3
     35c:	01 90       	ld	r0, Z+
     35e:	0d 92       	st	X+, r0
     360:	8a 95       	dec	r24
     362:	e1 f7       	brne	.-8      	; 0x35c <_Z7setupCSv+0x1f0>

	c.ppm = 1.0;
	c.p = {52, 52, 94};
     364:	86 e0       	ldi	r24, 0x06	; 6
     366:	e8 e7       	ldi	r30, 0x78	; 120
     368:	f1 e0       	ldi	r31, 0x01	; 1
     36a:	de 01       	movw	r26, r28
     36c:	15 96       	adiw	r26, 0x05	; 5
     36e:	01 90       	ld	r0, Z+
     370:	0d 92       	st	X+, r0
     372:	8a 95       	dec	r24
     374:	e1 f7       	brne	.-8      	; 0x36e <_Z7setupCSv+0x202>
	Nitrite[index] = c;
     376:	49 83       	std	Y+1, r20	; 0x01
     378:	5a 83       	std	Y+2, r21	; 0x02
     37a:	6b 83       	std	Y+3, r22	; 0x03
     37c:	7c 83       	std	Y+4, r23	; 0x04
     37e:	8a e0       	ldi	r24, 0x0A	; 10
     380:	fe 01       	movw	r30, r28
     382:	31 96       	adiw	r30, 0x01	; 1
     384:	ae ee       	ldi	r26, 0xEE	; 238
     386:	b2 e0       	ldi	r27, 0x02	; 2
     388:	01 90       	ld	r0, Z+
     38a:	0d 92       	st	X+, r0
     38c:	8a 95       	dec	r24
     38e:	e1 f7       	brne	.-8      	; 0x388 <_Z7setupCSv+0x21c>

	c.ppm = 5.0;
	c.p = {58, 53, 96};
     390:	86 e0       	ldi	r24, 0x06	; 6
     392:	ee e7       	ldi	r30, 0x7E	; 126
     394:	f1 e0       	ldi	r31, 0x01	; 1
     396:	de 01       	movw	r26, r28
     398:	15 96       	adiw	r26, 0x05	; 5
     39a:	01 90       	ld	r0, Z+
     39c:	0d 92       	st	X+, r0
     39e:	8a 95       	dec	r24
     3a0:	e1 f7       	brne	.-8      	; 0x39a <_Z7setupCSv+0x22e>
	Nitrate[index] = c;
     3a2:	80 e0       	ldi	r24, 0x00	; 0
     3a4:	90 e0       	ldi	r25, 0x00	; 0
     3a6:	a0 ea       	ldi	r26, 0xA0	; 160
     3a8:	b0 e4       	ldi	r27, 0x40	; 64
     3aa:	89 83       	std	Y+1, r24	; 0x01
     3ac:	9a 83       	std	Y+2, r25	; 0x02
     3ae:	ab 83       	std	Y+3, r26	; 0x03
     3b0:	bc 83       	std	Y+4, r27	; 0x04
     3b2:	8a e0       	ldi	r24, 0x0A	; 10
     3b4:	fe 01       	movw	r30, r28
     3b6:	31 96       	adiw	r30, 0x01	; 1
     3b8:	a8 ea       	ldi	r26, 0xA8	; 168
     3ba:	b2 e0       	ldi	r27, 0x02	; 2
     3bc:	01 90       	ld	r0, Z+
     3be:	0d 92       	st	X+, r0
     3c0:	8a 95       	dec	r24
     3c2:	e1 f7       	brne	.-8      	; 0x3bc <_Z7setupCSv+0x250>

	++index;

	c.ppm = 6.0;
	c.p = {48, 54, 86};
     3c4:	86 e0       	ldi	r24, 0x06	; 6
     3c6:	e4 e8       	ldi	r30, 0x84	; 132
     3c8:	f1 e0       	ldi	r31, 0x01	; 1
     3ca:	de 01       	movw	r26, r28
     3cc:	15 96       	adiw	r26, 0x05	; 5
     3ce:	01 90       	ld	r0, Z+
     3d0:	0d 92       	st	X+, r0
     3d2:	8a 95       	dec	r24
     3d4:	e1 f7       	brne	.-8      	; 0x3ce <_Z7setupCSv+0x262>
	Ammonia[index] = c;
     3d6:	80 e0       	ldi	r24, 0x00	; 0
     3d8:	90 e0       	ldi	r25, 0x00	; 0
     3da:	a0 ec       	ldi	r26, 0xC0	; 192
     3dc:	b0 e4       	ldi	r27, 0x40	; 64
     3de:	89 83       	std	Y+1, r24	; 0x01
     3e0:	9a 83       	std	Y+2, r25	; 0x02
     3e2:	ab 83       	std	Y+3, r26	; 0x03
     3e4:	bc 83       	std	Y+4, r27	; 0x04
     3e6:	8a e0       	ldi	r24, 0x0A	; 10
     3e8:	fe 01       	movw	r30, r28
     3ea:	31 96       	adiw	r30, 0x01	; 1
     3ec:	ae e3       	ldi	r26, 0x3E	; 62
     3ee:	b3 e0       	ldi	r27, 0x03	; 3
     3f0:	01 90       	ld	r0, Z+
     3f2:	0d 92       	st	X+, r0
     3f4:	8a 95       	dec	r24
     3f6:	e1 f7       	brne	.-8      	; 0x3f0 <_Z7setupCSv+0x284>

	c.ppm = 1.5;
	c.p = {49, 48, 88};
     3f8:	86 e0       	ldi	r24, 0x06	; 6
     3fa:	ea e8       	ldi	r30, 0x8A	; 138
     3fc:	f1 e0       	ldi	r31, 0x01	; 1
     3fe:	de 01       	movw	r26, r28
     400:	15 96       	adiw	r26, 0x05	; 5
     402:	01 90       	ld	r0, Z+
     404:	0d 92       	st	X+, r0
     406:	8a 95       	dec	r24
     408:	e1 f7       	brne	.-8      	; 0x402 <__LOCK_REGION_LENGTH__+0x2>
	Nitrite[index] = c;
     40a:	80 e0       	ldi	r24, 0x00	; 0
     40c:	90 e0       	ldi	r25, 0x00	; 0
     40e:	a0 ec       	ldi	r26, 0xC0	; 192
     410:	bf e3       	ldi	r27, 0x3F	; 63
     412:	89 83       	std	Y+1, r24	; 0x01
     414:	9a 83       	std	Y+2, r25	; 0x02
     416:	ab 83       	std	Y+3, r26	; 0x03
     418:	bc 83       	std	Y+4, r27	; 0x04
     41a:	8a e0       	ldi	r24, 0x0A	; 10
     41c:	fe 01       	movw	r30, r28
     41e:	31 96       	adiw	r30, 0x01	; 1
     420:	a8 ef       	ldi	r26, 0xF8	; 248
     422:	b2 e0       	ldi	r27, 0x02	; 2
     424:	01 90       	ld	r0, Z+
     426:	0d 92       	st	X+, r0
     428:	8a 95       	dec	r24
     42a:	e1 f7       	brne	.-8      	; 0x424 <__LOCK_REGION_LENGTH__+0x24>

	c.ppm = 10.0;
	c.p = {49, 48, 88};
     42c:	86 e0       	ldi	r24, 0x06	; 6
     42e:	ea e8       	ldi	r30, 0x8A	; 138
     430:	f1 e0       	ldi	r31, 0x01	; 1
     432:	de 01       	movw	r26, r28
     434:	15 96       	adiw	r26, 0x05	; 5
     436:	01 90       	ld	r0, Z+
     438:	0d 92       	st	X+, r0
     43a:	8a 95       	dec	r24
     43c:	e1 f7       	brne	.-8      	; 0x436 <__LOCK_REGION_LENGTH__+0x36>
	Nitrate[index] = c;
     43e:	40 e0       	ldi	r20, 0x00	; 0
     440:	50 e0       	ldi	r21, 0x00	; 0
     442:	60 e2       	ldi	r22, 0x20	; 32
     444:	71 e4       	ldi	r23, 0x41	; 65
     446:	49 83       	std	Y+1, r20	; 0x01
     448:	5a 83       	std	Y+2, r21	; 0x02
     44a:	6b 83       	std	Y+3, r22	; 0x03
     44c:	7c 83       	std	Y+4, r23	; 0x04
     44e:	8a e0       	ldi	r24, 0x0A	; 10
     450:	fe 01       	movw	r30, r28
     452:	31 96       	adiw	r30, 0x01	; 1
     454:	a2 eb       	ldi	r26, 0xB2	; 178
     456:	b2 e0       	ldi	r27, 0x02	; 2
     458:	01 90       	ld	r0, Z+
     45a:	0d 92       	st	X+, r0
     45c:	8a 95       	dec	r24
     45e:	e1 f7       	brne	.-8      	; 0x458 <__LOCK_REGION_LENGTH__+0x58>

	++index;

	c.ppm = 3.0;
	c.p = {54, 46, 88};
     460:	86 e0       	ldi	r24, 0x06	; 6
     462:	e0 e9       	ldi	r30, 0x90	; 144
     464:	f1 e0       	ldi	r31, 0x01	; 1
     466:	de 01       	movw	r26, r28
     468:	15 96       	adiw	r26, 0x05	; 5
     46a:	01 90       	ld	r0, Z+
     46c:	0d 92       	st	X+, r0
     46e:	8a 95       	dec	r24
     470:	e1 f7       	brne	.-8      	; 0x46a <__LOCK_REGION_LENGTH__+0x6a>
	Nitrite[index] = c;
     472:	09 83       	std	Y+1, r16	; 0x01
     474:	1a 83       	std	Y+2, r17	; 0x02
     476:	2b 83       	std	Y+3, r18	; 0x03
     478:	3c 83       	std	Y+4, r19	; 0x04
     47a:	8a e0       	ldi	r24, 0x0A	; 10
     47c:	fe 01       	movw	r30, r28
     47e:	31 96       	adiw	r30, 0x01	; 1
     480:	a2 e0       	ldi	r26, 0x02	; 2
     482:	b3 e0       	ldi	r27, 0x03	; 3
     484:	01 90       	ld	r0, Z+
     486:	0d 92       	st	X+, r0
     488:	8a 95       	dec	r24
     48a:	e1 f7       	brne	.-8      	; 0x484 <__LOCK_REGION_LENGTH__+0x84>

	c.ppm = 20.0;
	c.p = {50, 44, 86};
     48c:	86 e0       	ldi	r24, 0x06	; 6
     48e:	e6 e9       	ldi	r30, 0x96	; 150
     490:	f1 e0       	ldi	r31, 0x01	; 1
     492:	de 01       	movw	r26, r28
     494:	15 96       	adiw	r26, 0x05	; 5
     496:	01 90       	ld	r0, Z+
     498:	0d 92       	st	X+, r0
     49a:	8a 95       	dec	r24
     49c:	e1 f7       	brne	.-8      	; 0x496 <__LOCK_REGION_LENGTH__+0x96>
	Nitrate[index] = c;
     49e:	80 e0       	ldi	r24, 0x00	; 0
     4a0:	90 e0       	ldi	r25, 0x00	; 0
     4a2:	a0 ea       	ldi	r26, 0xA0	; 160
     4a4:	b1 e4       	ldi	r27, 0x41	; 65
     4a6:	89 83       	std	Y+1, r24	; 0x01
     4a8:	9a 83       	std	Y+2, r25	; 0x02
     4aa:	ab 83       	std	Y+3, r26	; 0x03
     4ac:	bc 83       	std	Y+4, r27	; 0x04
     4ae:	8a e0       	ldi	r24, 0x0A	; 10
     4b0:	fe 01       	movw	r30, r28
     4b2:	31 96       	adiw	r30, 0x01	; 1
     4b4:	ac eb       	ldi	r26, 0xBC	; 188
     4b6:	b2 e0       	ldi	r27, 0x02	; 2
     4b8:	01 90       	ld	r0, Z+
     4ba:	0d 92       	st	X+, r0
     4bc:	8a 95       	dec	r24
     4be:	e1 f7       	brne	.-8      	; 0x4b8 <__LOCK_REGION_LENGTH__+0xb8>

	++index;

	c.ppm = 10.0;
	c.p = {52, 42, 82};
     4c0:	86 e0       	ldi	r24, 0x06	; 6
     4c2:	ec e9       	ldi	r30, 0x9C	; 156
     4c4:	f1 e0       	ldi	r31, 0x01	; 1
     4c6:	de 01       	movw	r26, r28
     4c8:	15 96       	adiw	r26, 0x05	; 5
     4ca:	01 90       	ld	r0, Z+
     4cc:	0d 92       	st	X+, r0
     4ce:	8a 95       	dec	r24
     4d0:	e1 f7       	brne	.-8      	; 0x4ca <__LOCK_REGION_LENGTH__+0xca>
	Nitrite[index] = c;
     4d2:	49 83       	std	Y+1, r20	; 0x01
     4d4:	5a 83       	std	Y+2, r21	; 0x02
     4d6:	6b 83       	std	Y+3, r22	; 0x03
     4d8:	7c 83       	std	Y+4, r23	; 0x04
     4da:	8a e0       	ldi	r24, 0x0A	; 10
     4dc:	fe 01       	movw	r30, r28
     4de:	31 96       	adiw	r30, 0x01	; 1
     4e0:	ac e0       	ldi	r26, 0x0C	; 12
     4e2:	b3 e0       	ldi	r27, 0x03	; 3
     4e4:	01 90       	ld	r0, Z+
     4e6:	0d 92       	st	X+, r0
     4e8:	8a 95       	dec	r24
     4ea:	e1 f7       	brne	.-8      	; 0x4e4 <__LOCK_REGION_LENGTH__+0xe4>

	c.ppm = 50.0;
	c.p = {47, 43, 82};
     4ec:	86 e0       	ldi	r24, 0x06	; 6
     4ee:	e2 ea       	ldi	r30, 0xA2	; 162
     4f0:	f1 e0       	ldi	r31, 0x01	; 1
     4f2:	de 01       	movw	r26, r28
     4f4:	15 96       	adiw	r26, 0x05	; 5
     4f6:	01 90       	ld	r0, Z+
     4f8:	0d 92       	st	X+, r0
     4fa:	8a 95       	dec	r24
     4fc:	e1 f7       	brne	.-8      	; 0x4f6 <__LOCK_REGION_LENGTH__+0xf6>
	Nitrate[index] = c;
     4fe:	80 e0       	ldi	r24, 0x00	; 0
     500:	90 e0       	ldi	r25, 0x00	; 0
     502:	a8 e4       	ldi	r26, 0x48	; 72
     504:	b2 e4       	ldi	r27, 0x42	; 66
     506:	89 83       	std	Y+1, r24	; 0x01
     508:	9a 83       	std	Y+2, r25	; 0x02
     50a:	ab 83       	std	Y+3, r26	; 0x03
     50c:	bc 83       	std	Y+4, r27	; 0x04
     50e:	8a e0       	ldi	r24, 0x0A	; 10
     510:	fe 01       	movw	r30, r28
     512:	31 96       	adiw	r30, 0x01	; 1
     514:	a6 ec       	ldi	r26, 0xC6	; 198
     516:	b2 e0       	ldi	r27, 0x02	; 2
     518:	01 90       	ld	r0, Z+
     51a:	0d 92       	st	X+, r0
     51c:	8a 95       	dec	r24
     51e:	e1 f7       	brne	.-8      	; 0x518 <__LOCK_REGION_LENGTH__+0x118>
}
     520:	2a 96       	adiw	r28, 0x0a	; 10
     522:	0f b6       	in	r0, 0x3f	; 63
     524:	f8 94       	cli
     526:	de bf       	out	0x3e, r29	; 62
     528:	0f be       	out	0x3f, r0	; 63
     52a:	cd bf       	out	0x3d, r28	; 61
     52c:	df 91       	pop	r29
     52e:	cf 91       	pop	r28
     530:	1f 91       	pop	r17
     532:	0f 91       	pop	r16
     534:	08 95       	ret

00000536 <_Z9SameColorv>:


bool SameColor()
{
	Serial.print("c: ");
     536:	68 ea       	ldi	r22, 0xA8	; 168
     538:	71 e0       	ldi	r23, 0x01	; 1
     53a:	84 e5       	ldi	r24, 0x54	; 84
     53c:	94 e0       	ldi	r25, 0x04	; 4
     53e:	0e 94 80 1f 	call	0x3f00	; 0x3f00 <_ZN5Print5printEPKc>
	Serial.print(c.p.R);
     542:	60 91 81 02 	lds	r22, 0x0281	; 0x800281 <c+0x4>
     546:	70 91 82 02 	lds	r23, 0x0282	; 0x800282 <c+0x5>
     54a:	4a e0       	ldi	r20, 0x0A	; 10
     54c:	50 e0       	ldi	r21, 0x00	; 0
     54e:	84 e5       	ldi	r24, 0x54	; 84
     550:	94 e0       	ldi	r25, 0x04	; 4
     552:	0e 94 56 20 	call	0x40ac	; 0x40ac <_ZN5Print5printEii>
	Serial.print(" ");
     556:	6a ef       	ldi	r22, 0xFA	; 250
     558:	71 e0       	ldi	r23, 0x01	; 1
     55a:	84 e5       	ldi	r24, 0x54	; 84
     55c:	94 e0       	ldi	r25, 0x04	; 4
     55e:	0e 94 80 1f 	call	0x3f00	; 0x3f00 <_ZN5Print5printEPKc>
	Serial.print(c.p.G);
     562:	60 91 83 02 	lds	r22, 0x0283	; 0x800283 <c+0x6>
     566:	70 91 84 02 	lds	r23, 0x0284	; 0x800284 <c+0x7>
     56a:	4a e0       	ldi	r20, 0x0A	; 10
     56c:	50 e0       	ldi	r21, 0x00	; 0
     56e:	84 e5       	ldi	r24, 0x54	; 84
     570:	94 e0       	ldi	r25, 0x04	; 4
     572:	0e 94 56 20 	call	0x40ac	; 0x40ac <_ZN5Print5printEii>
	Serial.print(" ");
     576:	6a ef       	ldi	r22, 0xFA	; 250
     578:	71 e0       	ldi	r23, 0x01	; 1
     57a:	84 e5       	ldi	r24, 0x54	; 84
     57c:	94 e0       	ldi	r25, 0x04	; 4
     57e:	0e 94 80 1f 	call	0x3f00	; 0x3f00 <_ZN5Print5printEPKc>
	Serial.print(c.p.B);
     582:	60 91 85 02 	lds	r22, 0x0285	; 0x800285 <c+0x8>
     586:	70 91 86 02 	lds	r23, 0x0286	; 0x800286 <c+0x9>
     58a:	4a e0       	ldi	r20, 0x0A	; 10
     58c:	50 e0       	ldi	r21, 0x00	; 0
     58e:	84 e5       	ldi	r24, 0x54	; 84
     590:	94 e0       	ldi	r25, 0x04	; 4
     592:	0e 94 56 20 	call	0x40ac	; 0x40ac <_ZN5Print5printEii>
	Serial.print("read_in: ");
     596:	6c ea       	ldi	r22, 0xAC	; 172
     598:	71 e0       	ldi	r23, 0x01	; 1
     59a:	84 e5       	ldi	r24, 0x54	; 84
     59c:	94 e0       	ldi	r25, 0x04	; 4
     59e:	0e 94 80 1f 	call	0x3f00	; 0x3f00 <_ZN5Print5printEPKc>
	Serial.print(redScanned);
     5a2:	4a e0       	ldi	r20, 0x0A	; 10
     5a4:	50 e0       	ldi	r21, 0x00	; 0
     5a6:	60 91 7b 02 	lds	r22, 0x027B	; 0x80027b <redScanned>
     5aa:	84 e5       	ldi	r24, 0x54	; 84
     5ac:	94 e0       	ldi	r25, 0x04	; 4
     5ae:	0e 94 f5 1f 	call	0x3fea	; 0x3fea <_ZN5Print5printEhi>
	Serial.print(" ");
     5b2:	6a ef       	ldi	r22, 0xFA	; 250
     5b4:	71 e0       	ldi	r23, 0x01	; 1
     5b6:	84 e5       	ldi	r24, 0x54	; 84
     5b8:	94 e0       	ldi	r25, 0x04	; 4
     5ba:	0e 94 80 1f 	call	0x3f00	; 0x3f00 <_ZN5Print5printEPKc>
	Serial.print(greenScanned);
     5be:	4a e0       	ldi	r20, 0x0A	; 10
     5c0:	50 e0       	ldi	r21, 0x00	; 0
     5c2:	60 91 7c 02 	lds	r22, 0x027C	; 0x80027c <greenScanned>
     5c6:	84 e5       	ldi	r24, 0x54	; 84
     5c8:	94 e0       	ldi	r25, 0x04	; 4
     5ca:	0e 94 f5 1f 	call	0x3fea	; 0x3fea <_ZN5Print5printEhi>
	Serial.print(" ");
     5ce:	6a ef       	ldi	r22, 0xFA	; 250
     5d0:	71 e0       	ldi	r23, 0x01	; 1
     5d2:	84 e5       	ldi	r24, 0x54	; 84
     5d4:	94 e0       	ldi	r25, 0x04	; 4
     5d6:	0e 94 80 1f 	call	0x3f00	; 0x3f00 <_ZN5Print5printEPKc>
	Serial.print(blueScanned);
     5da:	4a e0       	ldi	r20, 0x0A	; 10
     5dc:	50 e0       	ldi	r21, 0x00	; 0
     5de:	60 91 7a 02 	lds	r22, 0x027A	; 0x80027a <blueScanned>
     5e2:	84 e5       	ldi	r24, 0x54	; 84
     5e4:	94 e0       	ldi	r25, 0x04	; 4
     5e6:	0e 94 f5 1f 	call	0x3fea	; 0x3fea <_ZN5Print5printEhi>
	// check if RGB values are within range specified by tolerance
	if (redScanned < (c.p.R - TOLERANCE) || redScanned > (c.p.R + TOLERANCE))
     5ea:	20 91 7b 02 	lds	r18, 0x027B	; 0x80027b <redScanned>
     5ee:	30 e0       	ldi	r19, 0x00	; 0
     5f0:	80 91 81 02 	lds	r24, 0x0281	; 0x800281 <c+0x4>
     5f4:	90 91 82 02 	lds	r25, 0x0282	; 0x800282 <c+0x5>
     5f8:	ac 01       	movw	r20, r24
     5fa:	45 50       	subi	r20, 0x05	; 5
     5fc:	51 09       	sbc	r21, r1
     5fe:	24 17       	cp	r18, r20
     600:	35 07       	cpc	r19, r21
     602:	74 f1       	brlt	.+92     	; 0x660 <_Z9SameColorv+0x12a>
     604:	05 96       	adiw	r24, 0x05	; 5
     606:	82 17       	cp	r24, r18
     608:	93 07       	cpc	r25, r19
     60a:	54 f1       	brlt	.+84     	; 0x660 <_Z9SameColorv+0x12a>
	return false;
	if (greenScanned < (c.p.G - TOLERANCE) || greenScanned > (c.p.G + TOLERANCE))
     60c:	20 91 7c 02 	lds	r18, 0x027C	; 0x80027c <greenScanned>
     610:	30 e0       	ldi	r19, 0x00	; 0
     612:	80 91 83 02 	lds	r24, 0x0283	; 0x800283 <c+0x6>
     616:	90 91 84 02 	lds	r25, 0x0284	; 0x800284 <c+0x7>
     61a:	ac 01       	movw	r20, r24
     61c:	45 50       	subi	r20, 0x05	; 5
     61e:	51 09       	sbc	r21, r1
     620:	24 17       	cp	r18, r20
     622:	35 07       	cpc	r19, r21
     624:	ec f0       	brlt	.+58     	; 0x660 <_Z9SameColorv+0x12a>
     626:	05 96       	adiw	r24, 0x05	; 5
     628:	82 17       	cp	r24, r18
     62a:	93 07       	cpc	r25, r19
     62c:	cc f0       	brlt	.+50     	; 0x660 <_Z9SameColorv+0x12a>
	return false;
	if (blueScanned < (c.p.B - TOLERANCE) || blueScanned > (c.p.B + TOLERANCE))
     62e:	20 91 7a 02 	lds	r18, 0x027A	; 0x80027a <blueScanned>
     632:	30 e0       	ldi	r19, 0x00	; 0
     634:	80 91 85 02 	lds	r24, 0x0285	; 0x800285 <c+0x8>
     638:	90 91 86 02 	lds	r25, 0x0286	; 0x800286 <c+0x9>
     63c:	ac 01       	movw	r20, r24
     63e:	45 50       	subi	r20, 0x05	; 5
     640:	51 09       	sbc	r21, r1
     642:	24 17       	cp	r18, r20
     644:	35 07       	cpc	r19, r21
     646:	64 f0       	brlt	.+24     	; 0x660 <_Z9SameColorv+0x12a>
     648:	05 96       	adiw	r24, 0x05	; 5
     64a:	82 17       	cp	r24, r18
     64c:	93 07       	cpc	r25, r19
     64e:	44 f0       	brlt	.+16     	; 0x660 <_Z9SameColorv+0x12a>
	return false;
	
	Serial.print(F("\nFound Matching Color"));
     650:	6c e7       	ldi	r22, 0x7C	; 124
     652:	70 e0       	ldi	r23, 0x00	; 0
     654:	84 e5       	ldi	r24, 0x54	; 84
     656:	94 e0       	ldi	r25, 0x04	; 4
     658:	0e 94 5c 1f 	call	0x3eb8	; 0x3eb8 <_ZN5Print5printEPK19__FlashStringHelper>
	return true;
     65c:	81 e0       	ldi	r24, 0x01	; 1
     65e:	08 95       	ret
	Serial.print(greenScanned);
	Serial.print(" ");
	Serial.print(blueScanned);
	// check if RGB values are within range specified by tolerance
	if (redScanned < (c.p.R - TOLERANCE) || redScanned > (c.p.R + TOLERANCE))
	return false;
     660:	80 e0       	ldi	r24, 0x00	; 0
	if (blueScanned < (c.p.B - TOLERANCE) || blueScanned > (c.p.B + TOLERANCE))
	return false;
	
	Serial.print(F("\nFound Matching Color"));
	return true;
}
     662:	08 95       	ret

00000664 <_Z9FindMatchv>:

double FindMatch()
{
     664:	0f 93       	push	r16
     666:	1f 93       	push	r17
     668:	cf 93       	push	r28
     66a:	df 93       	push	r29
	switch(typeToRead)
     66c:	80 91 79 02 	lds	r24, 0x0279	; 0x800279 <typeToRead>
     670:	81 30       	cpi	r24, 0x01	; 1
     672:	09 f4       	brne	.+2      	; 0x676 <_Z9FindMatchv+0x12>
     674:	44 c0       	rjmp	.+136    	; 0x6fe <_Z9FindMatchv+0x9a>
     676:	40 f0       	brcs	.+16     	; 0x688 <_Z9FindMatchv+0x24>
     678:	82 30       	cpi	r24, 0x02	; 2
     67a:	09 f0       	breq	.+2      	; 0x67e <_Z9FindMatchv+0x1a>
     67c:	68 c0       	rjmp	.+208    	; 0x74e <_Z9FindMatchv+0xea>
     67e:	00 ed       	ldi	r16, 0xD0	; 208
     680:	12 e0       	ldi	r17, 0x02	; 2
     682:	c0 e0       	ldi	r28, 0x00	; 0
     684:	d0 e0       	ldi	r29, 0x00	; 0
     686:	26 c0       	rjmp	.+76     	; 0x6d4 <_Z9FindMatchv+0x70>
     688:	06 e1       	ldi	r16, 0x16	; 22
     68a:	13 e0       	ldi	r17, 0x03	; 3
     68c:	c0 e0       	ldi	r28, 0x00	; 0
     68e:	d0 e0       	ldi	r29, 0x00	; 0
		case AMMONIA:
		{
			// find matching ammonia value
			for(int i = 0; i < MAX_AMMONIA_COLORS; ++i)
			{
				c = Ammonia[i];
     690:	8a e0       	ldi	r24, 0x0A	; 10
     692:	f8 01       	movw	r30, r16
     694:	ad e7       	ldi	r26, 0x7D	; 125
     696:	b2 e0       	ldi	r27, 0x02	; 2
     698:	01 90       	ld	r0, Z+
     69a:	0d 92       	st	X+, r0
     69c:	8a 95       	dec	r24
     69e:	e1 f7       	brne	.-8      	; 0x698 <_Z9FindMatchv+0x34>
				if(SameColor())
     6a0:	0e 94 9b 02 	call	0x536	; 0x536 <_Z9SameColorv>
     6a4:	88 23       	and	r24, r24
     6a6:	49 f0       	breq	.+18     	; 0x6ba <_Z9FindMatchv+0x56>
				return Ammonia[i].ppm;
     6a8:	8a e0       	ldi	r24, 0x0A	; 10
     6aa:	8c 9f       	mul	r24, r28
     6ac:	f0 01       	movw	r30, r0
     6ae:	8d 9f       	mul	r24, r29
     6b0:	f0 0d       	add	r31, r0
     6b2:	11 24       	eor	r1, r1
     6b4:	ea 5e       	subi	r30, 0xEA	; 234
     6b6:	fc 4f       	sbci	r31, 0xFC	; 252
     6b8:	3a c0       	rjmp	.+116    	; 0x72e <_Z9FindMatchv+0xca>
	switch(typeToRead)
	{
		case AMMONIA:
		{
			// find matching ammonia value
			for(int i = 0; i < MAX_AMMONIA_COLORS; ++i)
     6ba:	21 96       	adiw	r28, 0x01	; 1
     6bc:	06 5f       	subi	r16, 0xF6	; 246
     6be:	1f 4f       	sbci	r17, 0xFF	; 255
     6c0:	c5 30       	cpi	r28, 0x05	; 5
     6c2:	d1 05       	cpc	r29, r1
     6c4:	29 f7       	brne	.-54     	; 0x690 <_Z9FindMatchv+0x2c>
     6c6:	3e c0       	rjmp	.+124    	; 0x744 <_Z9FindMatchv+0xe0>
			break;
		}
		case NITRITE:
		{
			// find matching nitrite value
			for(int i = 0; i < MAX_NITRITE_NITRATE_COLORS; ++i)
     6c8:	21 96       	adiw	r28, 0x01	; 1
     6ca:	06 5f       	subi	r16, 0xF6	; 246
     6cc:	1f 4f       	sbci	r17, 0xFF	; 255
     6ce:	c7 30       	cpi	r28, 0x07	; 7
     6d0:	d1 05       	cpc	r29, r1
     6d2:	c1 f1       	breq	.+112    	; 0x744 <_Z9FindMatchv+0xe0>
			{
				c = Nitrite[i];
     6d4:	8a e0       	ldi	r24, 0x0A	; 10
     6d6:	f8 01       	movw	r30, r16
     6d8:	ad e7       	ldi	r26, 0x7D	; 125
     6da:	b2 e0       	ldi	r27, 0x02	; 2
     6dc:	01 90       	ld	r0, Z+
     6de:	0d 92       	st	X+, r0
     6e0:	8a 95       	dec	r24
     6e2:	e1 f7       	brne	.-8      	; 0x6dc <_Z9FindMatchv+0x78>
				if(SameColor())
     6e4:	0e 94 9b 02 	call	0x536	; 0x536 <_Z9SameColorv>
     6e8:	88 23       	and	r24, r24
     6ea:	71 f3       	breq	.-36     	; 0x6c8 <_Z9FindMatchv+0x64>
				return Nitrite[i].ppm;
     6ec:	8a e0       	ldi	r24, 0x0A	; 10
     6ee:	8c 9f       	mul	r24, r28
     6f0:	f0 01       	movw	r30, r0
     6f2:	8d 9f       	mul	r24, r29
     6f4:	f0 0d       	add	r31, r0
     6f6:	11 24       	eor	r1, r1
     6f8:	e0 53       	subi	r30, 0x30	; 48
     6fa:	fd 4f       	sbci	r31, 0xFD	; 253
     6fc:	18 c0       	rjmp	.+48     	; 0x72e <_Z9FindMatchv+0xca>
     6fe:	0a e8       	ldi	r16, 0x8A	; 138
     700:	12 e0       	ldi	r17, 0x02	; 2
	return true;
}

double FindMatch()
{
	switch(typeToRead)
     702:	c0 e0       	ldi	r28, 0x00	; 0
     704:	d0 e0       	ldi	r29, 0x00	; 0
		case NITRATE:
		{
			// find matching nitrate value
			for(int i = 0; i < MAX_NITRITE_NITRATE_COLORS; ++i)
			{
				c = Nitrate[i];
     706:	8a e0       	ldi	r24, 0x0A	; 10
     708:	f8 01       	movw	r30, r16
     70a:	ad e7       	ldi	r26, 0x7D	; 125
     70c:	b2 e0       	ldi	r27, 0x02	; 2
     70e:	01 90       	ld	r0, Z+
     710:	0d 92       	st	X+, r0
     712:	8a 95       	dec	r24
     714:	e1 f7       	brne	.-8      	; 0x70e <_Z9FindMatchv+0xaa>
				if(SameColor())
     716:	0e 94 9b 02 	call	0x536	; 0x536 <_Z9SameColorv>
     71a:	88 23       	and	r24, r24
     71c:	69 f0       	breq	.+26     	; 0x738 <_Z9FindMatchv+0xd4>
				return Nitrate[i].ppm;
     71e:	8a e0       	ldi	r24, 0x0A	; 10
     720:	8c 9f       	mul	r24, r28
     722:	f0 01       	movw	r30, r0
     724:	8d 9f       	mul	r24, r29
     726:	f0 0d       	add	r31, r0
     728:	11 24       	eor	r1, r1
     72a:	e6 57       	subi	r30, 0x76	; 118
     72c:	fd 4f       	sbci	r31, 0xFD	; 253
     72e:	30 81       	ld	r19, Z
     730:	21 81       	ldd	r18, Z+1	; 0x01
     732:	92 81       	ldd	r25, Z+2	; 0x02
     734:	83 81       	ldd	r24, Z+3	; 0x03
     736:	0a c0       	rjmp	.+20     	; 0x74c <_Z9FindMatchv+0xe8>
			break;
		}
		case NITRATE:
		{
			// find matching nitrate value
			for(int i = 0; i < MAX_NITRITE_NITRATE_COLORS; ++i)
     738:	21 96       	adiw	r28, 0x01	; 1
     73a:	06 5f       	subi	r16, 0xF6	; 246
     73c:	1f 4f       	sbci	r17, 0xFF	; 255
     73e:	c7 30       	cpi	r28, 0x07	; 7
     740:	d1 05       	cpc	r29, r1
     742:	09 f7       	brne	.-62     	; 0x706 <_Z9FindMatchv+0xa2>
			{
				c = Ammonia[i];
				if(SameColor())
				return Ammonia[i].ppm;
			}
			return -1;
     744:	30 e0       	ldi	r19, 0x00	; 0
     746:	20 e0       	ldi	r18, 0x00	; 0
     748:	90 e8       	ldi	r25, 0x80	; 128
     74a:	8f eb       	ldi	r24, 0xBF	; 191
     74c:	ac 01       	movw	r20, r24
			}
			return -1;
			break;
		}
	}
}
     74e:	63 2f       	mov	r22, r19
     750:	72 2f       	mov	r23, r18
     752:	85 2f       	mov	r24, r21
     754:	94 2f       	mov	r25, r20
     756:	df 91       	pop	r29
     758:	cf 91       	pop	r28
     75a:	1f 91       	pop	r17
     75c:	0f 91       	pop	r16
     75e:	08 95       	ret

00000760 <_Z9ScanColor8ReadType>:

long ScanColor(ReadType r)
{
	typeToRead = r;
     760:	80 93 79 02 	sts	0x0279, r24	; 0x800279 <typeToRead>
	CS.read();
     764:	8a e4       	ldi	r24, 0x4A	; 74
     766:	92 e0       	ldi	r25, 0x02	; 2
     768:	0e 94 92 18 	call	0x3124	; 0x3124 <_ZN9MD_TCS2304readEv>
	while(CS.available() == 0);  // wait for read to complete
     76c:	8a e4       	ldi	r24, 0x4A	; 74
     76e:	92 e0       	ldi	r25, 0x02	; 2
     770:	0e 94 9c 18 	call	0x3138	; 0x3138 <_ZN9MD_TCS2309availableEv>
     774:	88 23       	and	r24, r24
     776:	d1 f3       	breq	.-12     	; 0x76c <_Z9ScanColor8ReadType+0xc>
	CS.getRGB(&rgb);
     778:	67 e8       	ldi	r22, 0x87	; 135
     77a:	72 e0       	ldi	r23, 0x02	; 2
     77c:	8a e4       	ldi	r24, 0x4A	; 74
     77e:	92 e0       	ldi	r25, 0x02	; 2
     780:	0e 94 c8 17 	call	0x2f90	; 0x2f90 <_ZN9MD_TCS2306getRGBEP9colorData>
	greenScanned = rgb.value[TCS230_RGB_G];
     784:	80 91 88 02 	lds	r24, 0x0288	; 0x800288 <rgb+0x1>
     788:	80 93 7c 02 	sts	0x027C, r24	; 0x80027c <greenScanned>
	redScanned = rgb.value[TCS230_RGB_R];
     78c:	80 91 87 02 	lds	r24, 0x0287	; 0x800287 <rgb>
     790:	80 93 7b 02 	sts	0x027B, r24	; 0x80027b <redScanned>
	blueScanned = rgb.value[TCS230_RGB_B];
     794:	80 91 89 02 	lds	r24, 0x0289	; 0x800289 <rgb+0x2>
     798:	80 93 7a 02 	sts	0x027A, r24	; 0x80027a <blueScanned>
	// look for match
	Serial.println("RGB");
     79c:	66 eb       	ldi	r22, 0xB6	; 182
     79e:	71 e0       	ldi	r23, 0x01	; 1
     7a0:	84 e5       	ldi	r24, 0x54	; 84
     7a2:	94 e0       	ldi	r25, 0x04	; 4
     7a4:	0e 94 8d 1f 	call	0x3f1a	; 0x3f1a <_ZN5Print7printlnEPKc>
	Serial.println(redScanned);
     7a8:	4a e0       	ldi	r20, 0x0A	; 10
     7aa:	50 e0       	ldi	r21, 0x00	; 0
     7ac:	60 91 7b 02 	lds	r22, 0x027B	; 0x80027b <redScanned>
     7b0:	84 e5       	ldi	r24, 0x54	; 84
     7b2:	94 e0       	ldi	r25, 0x04	; 4
     7b4:	0e 94 fc 1f 	call	0x3ff8	; 0x3ff8 <_ZN5Print7printlnEhi>
	Serial.println(greenScanned);
     7b8:	4a e0       	ldi	r20, 0x0A	; 10
     7ba:	50 e0       	ldi	r21, 0x00	; 0
     7bc:	60 91 7c 02 	lds	r22, 0x027C	; 0x80027c <greenScanned>
     7c0:	84 e5       	ldi	r24, 0x54	; 84
     7c2:	94 e0       	ldi	r25, 0x04	; 4
     7c4:	0e 94 fc 1f 	call	0x3ff8	; 0x3ff8 <_ZN5Print7printlnEhi>
	Serial.println(blueScanned);
     7c8:	4a e0       	ldi	r20, 0x0A	; 10
     7ca:	50 e0       	ldi	r21, 0x00	; 0
     7cc:	60 91 7a 02 	lds	r22, 0x027A	; 0x80027a <blueScanned>
     7d0:	84 e5       	ldi	r24, 0x54	; 84
     7d2:	94 e0       	ldi	r25, 0x04	; 4
     7d4:	0e 94 fc 1f 	call	0x3ff8	; 0x3ff8 <_ZN5Print7printlnEhi>
	return FindMatch();
     7d8:	0e 94 32 03 	call	0x664	; 0x664 <_Z9FindMatchv>
     7dc:	0e 94 fe 1b 	call	0x37fc	; 0x37fc <__fixsfsi>
}
     7e0:	08 95       	ret

000007e2 <_Z13findTestStrip8ReadType>:

bool findTestStrip(ReadType r)
{
     7e2:	cf 93       	push	r28
	typeToRead = r;
     7e4:	80 93 79 02 	sts	0x0279, r24	; 0x800279 <typeToRead>
	// Scan for color
	CS.read();
     7e8:	8a e4       	ldi	r24, 0x4A	; 74
     7ea:	92 e0       	ldi	r25, 0x02	; 2
     7ec:	0e 94 92 18 	call	0x3124	; 0x3124 <_ZN9MD_TCS2304readEv>
	while (CS.available() == 0);
     7f0:	8a e4       	ldi	r24, 0x4A	; 74
     7f2:	92 e0       	ldi	r25, 0x02	; 2
     7f4:	0e 94 9c 18 	call	0x3138	; 0x3138 <_ZN9MD_TCS2309availableEv>
     7f8:	88 23       	and	r24, r24
     7fa:	d1 f3       	breq	.-12     	; 0x7f0 <_Z13findTestStrip8ReadType+0xe>
	CS.getRGB(&rgb);
     7fc:	67 e8       	ldi	r22, 0x87	; 135
     7fe:	72 e0       	ldi	r23, 0x02	; 2
     800:	8a e4       	ldi	r24, 0x4A	; 74
     802:	92 e0       	ldi	r25, 0x02	; 2
     804:	0e 94 c8 17 	call	0x2f90	; 0x2f90 <_ZN9MD_TCS2306getRGBEP9colorData>
	greenScanned = rgb.value[TCS230_RGB_G];
     808:	80 91 88 02 	lds	r24, 0x0288	; 0x800288 <rgb+0x1>
     80c:	80 93 7c 02 	sts	0x027C, r24	; 0x80027c <greenScanned>
	redScanned = rgb.value[TCS230_RGB_R];
     810:	80 91 87 02 	lds	r24, 0x0287	; 0x800287 <rgb>
     814:	80 93 7b 02 	sts	0x027B, r24	; 0x80027b <redScanned>
	blueScanned = rgb.value[TCS230_RGB_B];
     818:	80 91 89 02 	lds	r24, 0x0289	; 0x800289 <rgb+0x2>
     81c:	80 93 7a 02 	sts	0x027A, r24	; 0x80027a <blueScanned>
	// look for match against black
	c = EmptyTestBox;
     820:	8a e0       	ldi	r24, 0x0A	; 10
     822:	e0 e1       	ldi	r30, 0x10	; 16
     824:	f1 e0       	ldi	r31, 0x01	; 1
     826:	ad e7       	ldi	r26, 0x7D	; 125
     828:	b2 e0       	ldi	r27, 0x02	; 2
     82a:	01 90       	ld	r0, Z+
     82c:	0d 92       	st	X+, r0
     82e:	8a 95       	dec	r24
     830:	e1 f7       	brne	.-8      	; 0x82a <_Z13findTestStrip8ReadType+0x48>
	bool foundEmptyBox = SameColor();
     832:	0e 94 9b 02 	call	0x536	; 0x536 <_Z9SameColorv>
	c = WhiteTestStrip;
     836:	9a e0       	ldi	r25, 0x0A	; 10
     838:	e6 e0       	ldi	r30, 0x06	; 6
     83a:	f1 e0       	ldi	r31, 0x01	; 1
     83c:	ad e7       	ldi	r26, 0x7D	; 125
     83e:	b2 e0       	ldi	r27, 0x02	; 2
     840:	01 90       	ld	r0, Z+
     842:	0d 92       	st	X+, r0
     844:	9a 95       	dec	r25
     846:	e1 f7       	brne	.-8      	; 0x840 <_Z13findTestStrip8ReadType+0x5e>
	foundEmptyBox =  foundEmptyBox || SameColor();
     848:	81 11       	cpse	r24, r1
     84a:	05 c0       	rjmp	.+10     	; 0x856 <_Z13findTestStrip8ReadType+0x74>
     84c:	0e 94 9b 02 	call	0x536	; 0x536 <_Z9SameColorv>
     850:	c8 2f       	mov	r28, r24
     852:	88 23       	and	r24, r24
     854:	59 f0       	breq	.+22     	; 0x86c <_Z13findTestStrip8ReadType+0x8a>
	return foundEmptyBox && (FindMatch() == -1);
     856:	0e 94 32 03 	call	0x664	; 0x664 <_Z9FindMatchv>
     85a:	c1 e0       	ldi	r28, 0x01	; 1
     85c:	20 e0       	ldi	r18, 0x00	; 0
     85e:	30 e0       	ldi	r19, 0x00	; 0
     860:	40 e8       	ldi	r20, 0x80	; 128
     862:	5f eb       	ldi	r21, 0xBF	; 191
     864:	0e 94 87 1b 	call	0x370e	; 0x370e <__cmpsf2>
     868:	81 11       	cpse	r24, r1
     86a:	c0 e0       	ldi	r28, 0x00	; 0
     86c:	8c 2f       	mov	r24, r28
     86e:	cf 91       	pop	r28
     870:	08 95       	ret

00000872 <_GLOBAL__sub_I_Ammonia>:
uint8_t redScanned;
uint8_t blueScanned;

ReadType typeToRead;

MD_TCS230  CS(S2, S3, OE);
     872:	28 e0       	ldi	r18, 0x08	; 8
     874:	4d e0       	ldi	r20, 0x0D	; 13
     876:	6c e0       	ldi	r22, 0x0C	; 12
     878:	8a e4       	ldi	r24, 0x4A	; 74
     87a:	92 e0       	ldi	r25, 0x02	; 2
     87c:	0c 94 2b 17 	jmp	0x2e56	; 0x2e56 <_ZN9MD_TCS230C1Ehhh>

00000880 <_GLOBAL__sub_D_Ammonia>:
     880:	8a e4       	ldi	r24, 0x4A	; 74
     882:	92 e0       	ldi	r25, 0x02	; 2
     884:	0c 94 3f 17 	jmp	0x2e7e	; 0x2e7e <_ZN9MD_TCS230D1Ev>

00000888 <_Z11measureTempv>:

#define TEMP_PIN 6

OneWire ds(TEMP_PIN); // Temp sensor on pin 6

float measureTemp() {
     888:	ef 92       	push	r14
     88a:	ff 92       	push	r15
     88c:	0f 93       	push	r16
     88e:	1f 93       	push	r17
     890:	cf 93       	push	r28
     892:	df 93       	push	r29
     894:	cd b7       	in	r28, 0x3d	; 61
     896:	de b7       	in	r29, 0x3e	; 62
     898:	64 97       	sbiw	r28, 0x14	; 20
     89a:	0f b6       	in	r0, 0x3f	; 63
     89c:	f8 94       	cli
     89e:	de bf       	out	0x3e, r29	; 62
     8a0:	0f be       	out	0x3f, r0	; 63
     8a2:	cd bf       	out	0x3d, r28	; 61
	byte i;
	byte data[12];
	byte addr[8];
	float celsius; //, fahrenheit;
	
	ds.reset_search();
     8a4:	88 e4       	ldi	r24, 0x48	; 72
     8a6:	93 e0       	ldi	r25, 0x03	; 3
     8a8:	0e 94 c8 08 	call	0x1190	; 0x1190 <_ZN7OneWire12reset_searchEv>
	delay(250);
     8ac:	6a ef       	ldi	r22, 0xFA	; 250
     8ae:	70 e0       	ldi	r23, 0x00	; 0
     8b0:	80 e0       	ldi	r24, 0x00	; 0
     8b2:	90 e0       	ldi	r25, 0x00	; 0
     8b4:	0e 94 4d 21 	call	0x429a	; 0x429a <delay>
	ds.search(addr);
     8b8:	41 e0       	ldi	r20, 0x01	; 1
     8ba:	be 01       	movw	r22, r28
     8bc:	63 5f       	subi	r22, 0xF3	; 243
     8be:	7f 4f       	sbci	r23, 0xFF	; 255
     8c0:	88 e4       	ldi	r24, 0x48	; 72
     8c2:	93 e0       	ldi	r25, 0x03	; 3
     8c4:	0e 94 f7 08 	call	0x11ee	; 0x11ee <_ZN7OneWire6searchEPhb>

	if (OneWire::crc8(addr, 7) != addr[7]) {
     8c8:	67 e0       	ldi	r22, 0x07	; 7
     8ca:	ce 01       	movw	r24, r28
     8cc:	0d 96       	adiw	r24, 0x0d	; 13
     8ce:	0e 94 7e 09 	call	0x12fc	; 0x12fc <_ZN7OneWire4crc8EPKhh>
     8d2:	9c 89       	ldd	r25, Y+20	; 0x14
     8d4:	89 13       	cpse	r24, r25
     8d6:	54 c0       	rjmp	.+168    	; 0x980 <__stack+0x81>
		return -1;
	}

	ds.reset();
     8d8:	88 e4       	ldi	r24, 0x48	; 72
     8da:	93 e0       	ldi	r25, 0x03	; 3
     8dc:	0e 94 bc 07 	call	0xf78	; 0xf78 <_ZN7OneWire5resetEv>
	ds.select(addr);
     8e0:	be 01       	movw	r22, r28
     8e2:	63 5f       	subi	r22, 0xF3	; 243
     8e4:	7f 4f       	sbci	r23, 0xFF	; 255
     8e6:	88 e4       	ldi	r24, 0x48	; 72
     8e8:	93 e0       	ldi	r25, 0x03	; 3
     8ea:	0e 94 a9 08 	call	0x1152	; 0x1152 <_ZN7OneWire6selectEPKh>
	ds.write(0x44, 1);        // start conversion, with parasite power on at the end
     8ee:	41 e0       	ldi	r20, 0x01	; 1
     8f0:	64 e4       	ldi	r22, 0x44	; 68
     8f2:	88 e4       	ldi	r24, 0x48	; 72
     8f4:	93 e0       	ldi	r25, 0x03	; 3
     8f6:	0e 94 59 08 	call	0x10b2	; 0x10b2 <_ZN7OneWire5writeEhh>
	
	delay(1000);     // maybe 750ms is enough, maybe not
     8fa:	68 ee       	ldi	r22, 0xE8	; 232
     8fc:	73 e0       	ldi	r23, 0x03	; 3
     8fe:	80 e0       	ldi	r24, 0x00	; 0
     900:	90 e0       	ldi	r25, 0x00	; 0
     902:	0e 94 4d 21 	call	0x429a	; 0x429a <delay>
	
	ds.reset();
     906:	88 e4       	ldi	r24, 0x48	; 72
     908:	93 e0       	ldi	r25, 0x03	; 3
     90a:	0e 94 bc 07 	call	0xf78	; 0xf78 <_ZN7OneWire5resetEv>
	ds.select(addr);
     90e:	be 01       	movw	r22, r28
     910:	63 5f       	subi	r22, 0xF3	; 243
     912:	7f 4f       	sbci	r23, 0xFF	; 255
     914:	88 e4       	ldi	r24, 0x48	; 72
     916:	93 e0       	ldi	r25, 0x03	; 3
     918:	0e 94 a9 08 	call	0x1152	; 0x1152 <_ZN7OneWire6selectEPKh>
	ds.write(0xBE);         // Read Scratchpad
     91c:	40 e0       	ldi	r20, 0x00	; 0
     91e:	6e eb       	ldi	r22, 0xBE	; 190
     920:	88 e4       	ldi	r24, 0x48	; 72
     922:	93 e0       	ldi	r25, 0x03	; 3
     924:	0e 94 59 08 	call	0x10b2	; 0x10b2 <_ZN7OneWire5writeEhh>
     928:	8e 01       	movw	r16, r28
     92a:	0f 5f       	subi	r16, 0xFF	; 255
     92c:	1f 4f       	sbci	r17, 0xFF	; 255
     92e:	7e 01       	movw	r14, r28
     930:	8a e0       	ldi	r24, 0x0A	; 10
     932:	e8 0e       	add	r14, r24
     934:	f1 1c       	adc	r15, r1

	for ( i = 0; i < 9; i++) {           // we need 9 bytes
		data[i] = ds.read();
     936:	88 e4       	ldi	r24, 0x48	; 72
     938:	93 e0       	ldi	r25, 0x03	; 3
     93a:	0e 94 8d 08 	call	0x111a	; 0x111a <_ZN7OneWire4readEv>
     93e:	f8 01       	movw	r30, r16
     940:	81 93       	st	Z+, r24
     942:	8f 01       	movw	r16, r30
	
	ds.reset();
	ds.select(addr);
	ds.write(0xBE);         // Read Scratchpad

	for ( i = 0; i < 9; i++) {           // we need 9 bytes
     944:	ee 15       	cp	r30, r14
     946:	ff 05       	cpc	r31, r15
     948:	b1 f7       	brne	.-20     	; 0x936 <__stack+0x37>

	// Convert the data to actual temperature
	// because the result is a 16 bit signed integer, it should
	// be stored to an "int16_t" type, which is always 16 bits
	// even when compiled on a 32 bit processor.
	int16_t raw = (data[1] << 8) | data[0];
     94a:	69 81       	ldd	r22, Y+1	; 0x01
     94c:	7a 81       	ldd	r23, Y+2	; 0x02

	byte cfg = (data[4] & 0x60);
     94e:	8d 81       	ldd	r24, Y+5	; 0x05
     950:	80 76       	andi	r24, 0x60	; 96
	// at lower res, the low bits are undefined, so let's zero them
	if (cfg == 0x00) raw = raw & ~7;  // 9 bit resolution, 93.75 ms
     952:	11 f4       	brne	.+4      	; 0x958 <__stack+0x59>
     954:	68 7f       	andi	r22, 0xF8	; 248
     956:	07 c0       	rjmp	.+14     	; 0x966 <__stack+0x67>
	else if (cfg == 0x20) raw = raw & ~3; // 10 bit res, 187.5 ms
     958:	80 32       	cpi	r24, 0x20	; 32
     95a:	11 f4       	brne	.+4      	; 0x960 <__stack+0x61>
     95c:	6c 7f       	andi	r22, 0xFC	; 252
     95e:	03 c0       	rjmp	.+6      	; 0x966 <__stack+0x67>
	else if (cfg == 0x40) raw = raw & ~1; // 11 bit res, 375 ms
     960:	80 34       	cpi	r24, 0x40	; 64
     962:	09 f4       	brne	.+2      	; 0x966 <__stack+0x67>
     964:	6e 7f       	andi	r22, 0xFE	; 254
	
	celsius = (float)raw / 16.0;
     966:	07 2e       	mov	r0, r23
     968:	00 0c       	add	r0, r0
     96a:	88 0b       	sbc	r24, r24
     96c:	99 0b       	sbc	r25, r25
     96e:	0e 94 36 1c 	call	0x386c	; 0x386c <__floatsisf>
     972:	20 e0       	ldi	r18, 0x00	; 0
     974:	30 e0       	ldi	r19, 0x00	; 0
     976:	40 e8       	ldi	r20, 0x80	; 128
     978:	5d e3       	ldi	r21, 0x3D	; 61
     97a:	0e 94 e6 1c 	call	0x39cc	; 0x39cc <__mulsf3>
	return celsius;
     97e:	04 c0       	rjmp	.+8      	; 0x988 <__stack+0x89>
	ds.reset_search();
	delay(250);
	ds.search(addr);

	if (OneWire::crc8(addr, 7) != addr[7]) {
		return -1;
     980:	60 e0       	ldi	r22, 0x00	; 0
     982:	70 e0       	ldi	r23, 0x00	; 0
     984:	80 e8       	ldi	r24, 0x80	; 128
     986:	9f eb       	ldi	r25, 0xBF	; 191
	else if (cfg == 0x20) raw = raw & ~3; // 10 bit res, 187.5 ms
	else if (cfg == 0x40) raw = raw & ~1; // 11 bit res, 375 ms
	
	celsius = (float)raw / 16.0;
	return celsius;
     988:	64 96       	adiw	r28, 0x14	; 20
     98a:	0f b6       	in	r0, 0x3f	; 63
     98c:	f8 94       	cli
     98e:	de bf       	out	0x3e, r29	; 62
     990:	0f be       	out	0x3f, r0	; 63
     992:	cd bf       	out	0x3d, r28	; 61
     994:	df 91       	pop	r29
     996:	cf 91       	pop	r28
     998:	1f 91       	pop	r17
     99a:	0f 91       	pop	r16
     99c:	ff 90       	pop	r15
     99e:	ef 90       	pop	r14
     9a0:	08 95       	ret

000009a2 <_GLOBAL__sub_I_ds>:
    bool LastDeviceFlag;
#endif

  public:
    OneWire() { }
    OneWire(uint8_t pin) { begin(pin); }
     9a2:	66 e0       	ldi	r22, 0x06	; 6
     9a4:	88 e4       	ldi	r24, 0x48	; 72
     9a6:	93 e0       	ldi	r25, 0x03	; 3
     9a8:	0c 94 d4 08 	jmp	0x11a8	; 0x11a8 <_ZN7OneWire5beginEh>

000009ac <_Z20TaskPHandTemperaturePv>:
}


// get pH and temp reading from sensors
void TaskPHandTemperature(void *pvParameters)
{
     9ac:	cf 93       	push	r28
     9ae:	df 93       	push	r29
     9b0:	00 d0       	rcall	.+0      	; 0x9b2 <_Z20TaskPHandTemperaturePv+0x6>
     9b2:	cd b7       	in	r28, 0x3d	; 61
     9b4:	de b7       	in	r29, 0x3e	; 62
  (void) pvParameters;
  
	TickType_t xLastWakeTime = xTaskGetTickCount();
     9b6:	0e 94 57 11 	call	0x22ae	; 0x22ae <xTaskGetTickCount>
     9ba:	9a 83       	std	Y+2, r25	; 0x02
     9bc:	89 83       	std	Y+1, r24	; 0x01
	for (;;) // A Task shall never return or exit.
	{
		// Gets pH value
		phValue = calcPH() * 100;
     9be:	0e 94 96 09 	call	0x132c	; 0x132c <_Z6calcPHv>
     9c2:	20 e0       	ldi	r18, 0x00	; 0
     9c4:	30 e0       	ldi	r19, 0x00	; 0
     9c6:	48 ec       	ldi	r20, 0xC8	; 200
     9c8:	52 e4       	ldi	r21, 0x42	; 66
     9ca:	0e 94 e6 1c 	call	0x39cc	; 0x39cc <__mulsf3>
     9ce:	0e 94 fe 1b 	call	0x37fc	; 0x37fc <__fixsfsi>
     9d2:	60 93 83 03 	sts	0x0383, r22	; 0x800383 <phValue>
     9d6:	70 93 84 03 	sts	0x0384, r23	; 0x800384 <phValue+0x1>
     9da:	80 93 85 03 	sts	0x0385, r24	; 0x800385 <phValue+0x2>
     9de:	90 93 86 03 	sts	0x0386, r25	; 0x800386 <phValue+0x3>
		// Gets temperature value in Celsius
		tempValue = measureTemp() * 100;
     9e2:	0e 94 44 04 	call	0x888	; 0x888 <_Z11measureTempv>
     9e6:	20 e0       	ldi	r18, 0x00	; 0
     9e8:	30 e0       	ldi	r19, 0x00	; 0
     9ea:	48 ec       	ldi	r20, 0xC8	; 200
     9ec:	52 e4       	ldi	r21, 0x42	; 66
     9ee:	0e 94 e6 1c 	call	0x39cc	; 0x39cc <__mulsf3>
     9f2:	0e 94 fe 1b 	call	0x37fc	; 0x37fc <__fixsfsi>
     9f6:	9b 01       	movw	r18, r22
     9f8:	70 93 82 03 	sts	0x0382, r23	; 0x800382 <tempValue+0x1>
     9fc:	60 93 81 03 	sts	0x0381, r22	; 0x800381 <tempValue>

		// RELAY LOGIC (switching on 0.5 C above and below temperature threshold)
		if (tempValue < (tempThreshold - 50)) {
     a00:	80 91 1b 01 	lds	r24, 0x011B	; 0x80011b <tempThreshold>
     a04:	90 91 1c 01 	lds	r25, 0x011C	; 0x80011c <tempThreshold+0x1>
     a08:	ac 01       	movw	r20, r24
     a0a:	42 53       	subi	r20, 0x32	; 50
     a0c:	51 09       	sbc	r21, r1
     a0e:	24 17       	cp	r18, r20
     a10:	35 07       	cpc	r19, r21
     a12:	14 f4       	brge	.+4      	; 0xa18 <_Z20TaskPHandTemperaturePv+0x6c>
			digitalWrite(relay, HIGH);
     a14:	61 e0       	ldi	r22, 0x01	; 1
     a16:	05 c0       	rjmp	.+10     	; 0xa22 <_Z20TaskPHandTemperaturePv+0x76>
		}
		else if (tempValue > (tempThreshold + 50)) {
     a18:	c2 96       	adiw	r24, 0x32	; 50
     a1a:	82 17       	cp	r24, r18
     a1c:	93 07       	cpc	r25, r19
     a1e:	24 f4       	brge	.+8      	; 0xa28 <_Z20TaskPHandTemperaturePv+0x7c>
			digitalWrite(relay, LOW);
     a20:	60 e0       	ldi	r22, 0x00	; 0
     a22:	84 e0       	ldi	r24, 0x04	; 4
     a24:	0e 94 b0 22 	call	0x4560	; 0x4560 <digitalWrite>
		}
    // check pH and temp every 5 sec
    vTaskDelayUntil( &xLastWakeTime, 5000 / portTICK_PERIOD_MS );
     a28:	68 e3       	ldi	r22, 0x38	; 56
     a2a:	71 e0       	ldi	r23, 0x01	; 1
     a2c:	ce 01       	movw	r24, r28
     a2e:	01 96       	adiw	r24, 0x01	; 1
     a30:	0e 94 7c 12 	call	0x24f8	; 0x24f8 <vTaskDelayUntil>
void TaskPHandTemperature(void *pvParameters)
{
  (void) pvParameters;
  
	TickType_t xLastWakeTime = xTaskGetTickCount();
	for (;;) // A Task shall never return or exit.
     a34:	c4 cf       	rjmp	.-120    	; 0x9be <_Z20TaskPHandTemperaturePv+0x12>

00000a36 <_ZN5Print5writeEPKc>:
    int getWriteError() { return write_error; }
    void clearWriteError() { setWriteError(0); }
  
    virtual size_t write(uint8_t) = 0;
    size_t write(const char *str) {
      if (str == NULL) return 0;
     a36:	61 15       	cp	r22, r1
     a38:	71 05       	cpc	r23, r1
     a3a:	79 f0       	breq	.+30     	; 0xa5a <_ZN5Print5writeEPKc+0x24>
      return write((const uint8_t *)str, strlen(str));
     a3c:	fb 01       	movw	r30, r22
     a3e:	01 90       	ld	r0, Z+
     a40:	00 20       	and	r0, r0
     a42:	e9 f7       	brne	.-6      	; 0xa3e <_ZN5Print5writeEPKc+0x8>
     a44:	31 97       	sbiw	r30, 0x01	; 1
     a46:	af 01       	movw	r20, r30
     a48:	46 1b       	sub	r20, r22
     a4a:	57 0b       	sbc	r21, r23
     a4c:	dc 01       	movw	r26, r24
     a4e:	ed 91       	ld	r30, X+
     a50:	fc 91       	ld	r31, X
     a52:	02 80       	ldd	r0, Z+2	; 0x02
     a54:	f3 81       	ldd	r31, Z+3	; 0x03
     a56:	e0 2d       	mov	r30, r0
     a58:	09 94       	ijmp
    }
     a5a:	80 e0       	ldi	r24, 0x00	; 0
     a5c:	90 e0       	ldi	r25, 0x00	; 0
     a5e:	08 95       	ret

00000a60 <_Z6setLED8LEDColor>:
LEDColor White = {255, 255, 255};
LEDColor Off = {0, 0, 0};


void setLED(LEDColor c)
{
     a60:	cf 93       	push	r28
     a62:	df 93       	push	r29
     a64:	00 d0       	rcall	.+0      	; 0xa66 <_Z6setLED8LEDColor+0x6>
     a66:	00 d0       	rcall	.+0      	; 0xa68 <_Z6setLED8LEDColor+0x8>
     a68:	00 d0       	rcall	.+0      	; 0xa6a <_Z6setLED8LEDColor+0xa>
     a6a:	cd b7       	in	r28, 0x3d	; 61
     a6c:	de b7       	in	r29, 0x3e	; 62
     a6e:	49 83       	std	Y+1, r20	; 0x01
     a70:	5a 83       	std	Y+2, r21	; 0x02
     a72:	6b 83       	std	Y+3, r22	; 0x03
     a74:	7c 83       	std	Y+4, r23	; 0x04
     a76:	8d 83       	std	Y+5, r24	; 0x05
     a78:	9e 83       	std	Y+6, r25	; 0x06
	analogWrite(R_LED, c.r);
     a7a:	69 81       	ldd	r22, Y+1	; 0x01
     a7c:	7a 81       	ldd	r23, Y+2	; 0x02
     a7e:	8f e0       	ldi	r24, 0x0F	; 15
     a80:	0e 94 ec 21 	call	0x43d8	; 0x43d8 <analogWrite>
	analogWrite(G_LED, c.g);
     a84:	6b 81       	ldd	r22, Y+3	; 0x03
     a86:	7c 81       	ldd	r23, Y+4	; 0x04
     a88:	80 e1       	ldi	r24, 0x10	; 16
     a8a:	0e 94 ec 21 	call	0x43d8	; 0x43d8 <analogWrite>
	analogWrite(B_LED, c.b);
     a8e:	6d 81       	ldd	r22, Y+5	; 0x05
     a90:	7e 81       	ldd	r23, Y+6	; 0x06
     a92:	81 e1       	ldi	r24, 0x11	; 17
}
     a94:	26 96       	adiw	r28, 0x06	; 6
     a96:	0f b6       	in	r0, 0x3f	; 63
     a98:	f8 94       	cli
     a9a:	de bf       	out	0x3e, r29	; 62
     a9c:	0f be       	out	0x3f, r0	; 63
     a9e:	cd bf       	out	0x3d, r28	; 61
     aa0:	df 91       	pop	r29
     aa2:	cf 91       	pop	r28

void setLED(LEDColor c)
{
	analogWrite(R_LED, c.r);
	analogWrite(G_LED, c.g);
	analogWrite(B_LED, c.b);
     aa4:	0c 94 ec 21 	jmp	0x43d8	; 0x43d8 <analogWrite>

00000aa8 <_Z15TaskColorSensorPv>:
// get Ammonia, Nitrite, and Nitrate reading from color sensor
void TaskColorSensor(void *pvParameters)
{
	(void) pvParameters;
  
	TickType_t xLastWakeTime = xTaskGetTickCount();
     aa8:	0e 94 57 11 	call	0x22ae	; 0x22ae <xTaskGetTickCount>
				case 'N':
				{
					while (findTestStrip(NITRATE));
					setLED(Green);
					delay(250); // allow user to see LED and stop moving test strip
					nitrateValue = ScanColor(NITRATE) * 100;					
     aac:	c4 e6       	ldi	r28, 0x64	; 100
	(void) pvParameters;
  
	TickType_t xLastWakeTime = xTaskGetTickCount();
	for (;;) // A Task shall never return or exit.
	{
		if ( xSemaphoreTake( xSerialSemaphoreColorSensor, ( TickType_t ) 1 ) == pdTRUE )
     aae:	61 e0       	ldi	r22, 0x01	; 1
     ab0:	70 e0       	ldi	r23, 0x00	; 0
     ab2:	80 91 7a 03 	lds	r24, 0x037A	; 0x80037a <xSerialSemaphoreColorSensor>
     ab6:	90 91 7b 03 	lds	r25, 0x037B	; 0x80037b <xSerialSemaphoreColorSensor+0x1>
     aba:	0e 94 94 0e 	call	0x1d28	; 0x1d28 <xQueueSemaphoreTake>
     abe:	81 30       	cpi	r24, 0x01	; 1
     ac0:	09 f0       	breq	.+2      	; 0xac4 <_Z15TaskColorSensorPv+0x1c>
     ac2:	a3 c0       	rjmp	.+326    	; 0xc0a <_Z15TaskColorSensorPv+0x162>
		{
			switch (colorToRead)
     ac4:	80 91 1a 01 	lds	r24, 0x011A	; 0x80011a <colorToRead>
     ac8:	8e 34       	cpi	r24, 0x4E	; 78
     aca:	09 f4       	brne	.+2      	; 0xace <_Z15TaskColorSensorPv+0x26>
     acc:	57 c0       	rjmp	.+174    	; 0xb7c <_Z15TaskColorSensorPv+0xd4>
     ace:	8e 36       	cpi	r24, 0x6E	; 110
     ad0:	49 f1       	breq	.+82     	; 0xb24 <_Z15TaskColorSensorPv+0x7c>
     ad2:	81 34       	cpi	r24, 0x41	; 65
     ad4:	09 f0       	breq	.+2      	; 0xad8 <_Z15TaskColorSensorPv+0x30>
     ad6:	8b c0       	rjmp	.+278    	; 0xbee <_Z15TaskColorSensorPv+0x146>
			{
				case 'A':
				{
					while (findTestStrip(AMMONIA));
     ad8:	80 e0       	ldi	r24, 0x00	; 0
     ada:	0e 94 f1 03 	call	0x7e2	; 0x7e2 <_Z13findTestStrip8ReadType>
     ade:	81 11       	cpse	r24, r1
     ae0:	fb cf       	rjmp	.-10     	; 0xad8 <_Z15TaskColorSensorPv+0x30>
					setLED(Red);
     ae2:	40 91 2f 01 	lds	r20, 0x012F	; 0x80012f <Red>
     ae6:	50 91 30 01 	lds	r21, 0x0130	; 0x800130 <Red+0x1>
     aea:	60 91 31 01 	lds	r22, 0x0131	; 0x800131 <Red+0x2>
     aee:	70 91 32 01 	lds	r23, 0x0132	; 0x800132 <Red+0x3>
     af2:	80 91 33 01 	lds	r24, 0x0133	; 0x800133 <Red+0x4>
     af6:	90 91 34 01 	lds	r25, 0x0134	; 0x800134 <Red+0x5>
     afa:	0e 94 30 05 	call	0xa60	; 0xa60 <_Z6setLED8LEDColor>
					delay(250);
     afe:	6a ef       	ldi	r22, 0xFA	; 250
     b00:	70 e0       	ldi	r23, 0x00	; 0
     b02:	80 e0       	ldi	r24, 0x00	; 0
     b04:	90 e0       	ldi	r25, 0x00	; 0
     b06:	0e 94 4d 21 	call	0x429a	; 0x429a <delay>
					ammoniaValue = ScanColor(AMMONIA) * 100;
     b0a:	80 e0       	ldi	r24, 0x00	; 0
     b0c:	0e 94 b0 03 	call	0x760	; 0x760 <_Z9ScanColor8ReadType>
     b10:	c6 9f       	mul	r28, r22
     b12:	90 01       	movw	r18, r0
     b14:	c7 9f       	mul	r28, r23
     b16:	30 0d       	add	r19, r0
     b18:	11 24       	eor	r1, r1
     b1a:	30 93 22 01 	sts	0x0122, r19	; 0x800122 <ammoniaValue+0x1>
     b1e:	20 93 21 01 	sts	0x0121, r18	; 0x800121 <ammoniaValue>
     b22:	25 c0       	rjmp	.+74     	; 0xb6e <_Z15TaskColorSensorPv+0xc6>
					delay(250);
					break;
				}
				case 'n':
				{
					while (findTestStrip(NITRITE));
     b24:	82 e0       	ldi	r24, 0x02	; 2
     b26:	0e 94 f1 03 	call	0x7e2	; 0x7e2 <_Z13findTestStrip8ReadType>
     b2a:	81 11       	cpse	r24, r1
     b2c:	fb cf       	rjmp	.-10     	; 0xb24 <_Z15TaskColorSensorPv+0x7c>
					setLED(Blue);
     b2e:	40 91 23 01 	lds	r20, 0x0123	; 0x800123 <Blue>
     b32:	50 91 24 01 	lds	r21, 0x0124	; 0x800124 <Blue+0x1>
     b36:	60 91 25 01 	lds	r22, 0x0125	; 0x800125 <Blue+0x2>
     b3a:	70 91 26 01 	lds	r23, 0x0126	; 0x800126 <Blue+0x3>
     b3e:	80 91 27 01 	lds	r24, 0x0127	; 0x800127 <Blue+0x4>
     b42:	90 91 28 01 	lds	r25, 0x0128	; 0x800128 <Blue+0x5>
     b46:	0e 94 30 05 	call	0xa60	; 0xa60 <_Z6setLED8LEDColor>
					delay(250);
     b4a:	6a ef       	ldi	r22, 0xFA	; 250
     b4c:	70 e0       	ldi	r23, 0x00	; 0
     b4e:	80 e0       	ldi	r24, 0x00	; 0
     b50:	90 e0       	ldi	r25, 0x00	; 0
     b52:	0e 94 4d 21 	call	0x429a	; 0x429a <delay>
					nitriteValue = ScanColor(NITRITE) * 100;
     b56:	82 e0       	ldi	r24, 0x02	; 2
     b58:	0e 94 b0 03 	call	0x760	; 0x760 <_Z9ScanColor8ReadType>
     b5c:	c6 9f       	mul	r28, r22
     b5e:	90 01       	movw	r18, r0
     b60:	c7 9f       	mul	r28, r23
     b62:	30 0d       	add	r19, r0
     b64:	11 24       	eor	r1, r1
     b66:	30 93 1e 01 	sts	0x011E, r19	; 0x80011e <nitriteValue+0x1>
     b6a:	20 93 1d 01 	sts	0x011D, r18	; 0x80011d <nitriteValue>
					delay(250);
     b6e:	6a ef       	ldi	r22, 0xFA	; 250
     b70:	70 e0       	ldi	r23, 0x00	; 0
     b72:	80 e0       	ldi	r24, 0x00	; 0
     b74:	90 e0       	ldi	r25, 0x00	; 0
     b76:	0e 94 4d 21 	call	0x429a	; 0x429a <delay>
					break;
     b7a:	39 c0       	rjmp	.+114    	; 0xbee <_Z15TaskColorSensorPv+0x146>
				}
				case 'N':
				{
					while (findTestStrip(NITRATE));
     b7c:	81 e0       	ldi	r24, 0x01	; 1
     b7e:	0e 94 f1 03 	call	0x7e2	; 0x7e2 <_Z13findTestStrip8ReadType>
     b82:	81 11       	cpse	r24, r1
     b84:	fb cf       	rjmp	.-10     	; 0xb7c <_Z15TaskColorSensorPv+0xd4>
					setLED(Green);
     b86:	40 91 29 01 	lds	r20, 0x0129	; 0x800129 <Green>
     b8a:	50 91 2a 01 	lds	r21, 0x012A	; 0x80012a <Green+0x1>
     b8e:	60 91 2b 01 	lds	r22, 0x012B	; 0x80012b <Green+0x2>
     b92:	70 91 2c 01 	lds	r23, 0x012C	; 0x80012c <Green+0x3>
     b96:	80 91 2d 01 	lds	r24, 0x012D	; 0x80012d <Green+0x4>
     b9a:	90 91 2e 01 	lds	r25, 0x012E	; 0x80012e <Green+0x5>
     b9e:	0e 94 30 05 	call	0xa60	; 0xa60 <_Z6setLED8LEDColor>
					delay(250); // allow user to see LED and stop moving test strip
     ba2:	6a ef       	ldi	r22, 0xFA	; 250
     ba4:	70 e0       	ldi	r23, 0x00	; 0
     ba6:	80 e0       	ldi	r24, 0x00	; 0
     ba8:	90 e0       	ldi	r25, 0x00	; 0
     baa:	0e 94 4d 21 	call	0x429a	; 0x429a <delay>
					nitrateValue = ScanColor(NITRATE) * 100;					
     bae:	81 e0       	ldi	r24, 0x01	; 1
     bb0:	0e 94 b0 03 	call	0x760	; 0x760 <_Z9ScanColor8ReadType>
     bb4:	c6 9f       	mul	r28, r22
     bb6:	90 01       	movw	r18, r0
     bb8:	c7 9f       	mul	r28, r23
     bba:	30 0d       	add	r19, r0
     bbc:	11 24       	eor	r1, r1
     bbe:	30 93 20 01 	sts	0x0120, r19	; 0x800120 <nitrateValue+0x1>
     bc2:	20 93 1f 01 	sts	0x011F, r18	; 0x80011f <nitrateValue>
					delay(250);
     bc6:	6a ef       	ldi	r22, 0xFA	; 250
     bc8:	70 e0       	ldi	r23, 0x00	; 0
     bca:	80 e0       	ldi	r24, 0x00	; 0
     bcc:	90 e0       	ldi	r25, 0x00	; 0
     bce:	0e 94 4d 21 	call	0x429a	; 0x429a <delay>
					setLED(Off);
     bd2:	40 91 87 03 	lds	r20, 0x0387	; 0x800387 <Off>
     bd6:	50 91 88 03 	lds	r21, 0x0388	; 0x800388 <Off+0x1>
     bda:	60 91 89 03 	lds	r22, 0x0389	; 0x800389 <Off+0x2>
     bde:	70 91 8a 03 	lds	r23, 0x038A	; 0x80038a <Off+0x3>
     be2:	80 91 8b 03 	lds	r24, 0x038B	; 0x80038b <Off+0x4>
     be6:	90 91 8c 03 	lds	r25, 0x038C	; 0x80038c <Off+0x5>
     bea:	0e 94 30 05 	call	0xa60	; 0xa60 <_Z6setLED8LEDColor>
					break;
				}
			}
			setLED(Off);	  
     bee:	40 91 87 03 	lds	r20, 0x0387	; 0x800387 <Off>
     bf2:	50 91 88 03 	lds	r21, 0x0388	; 0x800388 <Off+0x1>
     bf6:	60 91 89 03 	lds	r22, 0x0389	; 0x800389 <Off+0x2>
     bfa:	70 91 8a 03 	lds	r23, 0x038A	; 0x80038a <Off+0x3>
     bfe:	80 91 8b 03 	lds	r24, 0x038B	; 0x80038b <Off+0x4>
     c02:	90 91 8c 03 	lds	r25, 0x038C	; 0x80038c <Off+0x5>
     c06:	0e 94 30 05 	call	0xa60	; 0xa60 <_Z6setLED8LEDColor>
		}
		vTaskDelay(1); // 1 tick delay between reads for stability*/
     c0a:	81 e0       	ldi	r24, 0x01	; 1
     c0c:	90 e0       	ldi	r25, 0x00	; 0
     c0e:	0e 94 b4 12 	call	0x2568	; 0x2568 <vTaskDelay>
void TaskColorSensor(void *pvParameters)
{
	(void) pvParameters;
  
	TickType_t xLastWakeTime = xTaskGetTickCount();
	for (;;) // A Task shall never return or exit.
     c12:	4d cf       	rjmp	.-358    	; 0xaae <_Z15TaskColorSensorPv+0x6>

00000c14 <_Z8setupLEDv>:
}

void setupLED()
{
	pinMode(R_LED, OUTPUT);
     c14:	61 e0       	ldi	r22, 0x01	; 1
     c16:	8f e0       	ldi	r24, 0x0F	; 15
     c18:	0e 94 74 22 	call	0x44e8	; 0x44e8 <pinMode>
	pinMode(G_LED, OUTPUT);
     c1c:	61 e0       	ldi	r22, 0x01	; 1
     c1e:	80 e1       	ldi	r24, 0x10	; 16
     c20:	0e 94 74 22 	call	0x44e8	; 0x44e8 <pinMode>
	pinMode(B_LED, OUTPUT);
     c24:	61 e0       	ldi	r22, 0x01	; 1
     c26:	81 e1       	ldi	r24, 0x11	; 17
     c28:	0e 94 74 22 	call	0x44e8	; 0x44e8 <pinMode>
	setLED(Off);
     c2c:	40 91 87 03 	lds	r20, 0x0387	; 0x800387 <Off>
     c30:	50 91 88 03 	lds	r21, 0x0388	; 0x800388 <Off+0x1>
     c34:	60 91 89 03 	lds	r22, 0x0389	; 0x800389 <Off+0x2>
     c38:	70 91 8a 03 	lds	r23, 0x038A	; 0x80038a <Off+0x3>
     c3c:	80 91 8b 03 	lds	r24, 0x038B	; 0x80038b <Off+0x4>
     c40:	90 91 8c 03 	lds	r25, 0x038C	; 0x80038c <Off+0x5>
     c44:	0c 94 30 05 	jmp	0xa60	; 0xa60 <_Z6setLED8LEDColor>

00000c48 <setup>:
TaskHandle_t xPHandTemperature;

SoftwareSerial serial(rxPin, txPin);

// the setup function runs once when you press reset or power the board
void setup() {  
     c48:	ef 92       	push	r14
     c4a:	ff 92       	push	r15
     c4c:	0f 93       	push	r16
	// initialize serial communication at 115200 bits per second:
	serial.begin(115200);
     c4e:	40 e0       	ldi	r20, 0x00	; 0
     c50:	52 ec       	ldi	r21, 0xC2	; 194
     c52:	61 e0       	ldi	r22, 0x01	; 1
     c54:	70 e0       	ldi	r23, 0x00	; 0
     c56:	87 e5       	ldi	r24, 0x57	; 87
     c58:	93 e0       	ldi	r25, 0x03	; 3
     c5a:	0e 94 8c 1a 	call	0x3518	; 0x3518 <_ZN14SoftwareSerial5beginEl>
	pinMode(wifiRst, OUTPUT);
     c5e:	61 e0       	ldi	r22, 0x01	; 1
     c60:	8a e0       	ldi	r24, 0x0A	; 10
     c62:	0e 94 74 22 	call	0x44e8	; 0x44e8 <pinMode>
	pinMode(relay, OUTPUT);
     c66:	61 e0       	ldi	r22, 0x01	; 1
     c68:	84 e0       	ldi	r24, 0x04	; 4
     c6a:	0e 94 74 22 	call	0x44e8	; 0x44e8 <pinMode>
	digitalWrite(relay, HIGH);
     c6e:	61 e0       	ldi	r22, 0x01	; 1
     c70:	84 e0       	ldi	r24, 0x04	; 4
     c72:	0e 94 b0 22 	call	0x4560	; 0x4560 <digitalWrite>
  public:
    inline HardwareSerial(
      volatile uint8_t *ubrrh, volatile uint8_t *ubrrl,
      volatile uint8_t *ucsra, volatile uint8_t *ucsrb,
      volatile uint8_t *ucsrc, volatile uint8_t *udr);
    void begin(unsigned long baud) { begin(baud, SERIAL_8N1); }
     c76:	26 e0       	ldi	r18, 0x06	; 6
     c78:	40 e0       	ldi	r20, 0x00	; 0
     c7a:	52 ec       	ldi	r21, 0xC2	; 194
     c7c:	61 e0       	ldi	r22, 0x01	; 1
     c7e:	70 e0       	ldi	r23, 0x00	; 0
     c80:	84 e5       	ldi	r24, 0x54	; 84
     c82:	94 e0       	ldi	r25, 0x04	; 4
     c84:	0e 94 2f 1e 	call	0x3c5e	; 0x3c5e <_ZN14HardwareSerial5beginEmh>
	while (!serial) {
		; // wait for serial port to connect. Needed for native USB, on LEONARDO, MICRO, YUN, and other 32u4 based boards.
	}
  
	// drive Wifi Enable pin High
	digitalWrite(wifiRst, HIGH);
     c88:	61 e0       	ldi	r22, 0x01	; 1
     c8a:	8a e0       	ldi	r24, 0x0A	; 10
     c8c:	0e 94 b0 22 	call	0x4560	; 0x4560 <digitalWrite>
	// load test strip color data and initialize indicator LED
	setupCS();
     c90:	0e 94 b6 00 	call	0x16c	; 0x16c <_Z7setupCSv>
	setupLED();
     c94:	0e 94 0a 06 	call	0xc14	; 0xc14 <_Z8setupLEDv>
 
	// create interrupt to be triggered by Wifi module
	attachInterrupt(digitalPinToInterrupt(2), fromWifi, RISING);
     c98:	43 e0       	ldi	r20, 0x03	; 3
     c9a:	50 e0       	ldi	r21, 0x00	; 0
     c9c:	66 ea       	ldi	r22, 0xA6	; 166
     c9e:	76 e0       	ldi	r23, 0x06	; 6
     ca0:	80 e0       	ldi	r24, 0x00	; 0
     ca2:	0e 94 70 20 	call	0x40e0	; 0x40e0 <attachInterrupt>
	
	if (xSerialSemaphoreColorSensor == NULL)
     ca6:	80 91 7a 03 	lds	r24, 0x037A	; 0x80037a <xSerialSemaphoreColorSensor>
     caa:	90 91 7b 03 	lds	r25, 0x037B	; 0x80037b <xSerialSemaphoreColorSensor+0x1>
     cae:	89 2b       	or	r24, r25
     cb0:	f9 f4       	brne	.+62     	; 0xcf0 <setup+0xa8>
	{
		vSemaphoreCreateBinary(xSerialSemaphoreColorSensor);	
     cb2:	43 e0       	ldi	r20, 0x03	; 3
     cb4:	60 e0       	ldi	r22, 0x00	; 0
     cb6:	81 e0       	ldi	r24, 0x01	; 1
     cb8:	0e 94 f2 0c 	call	0x19e4	; 0x19e4 <xQueueGenericCreate>
     cbc:	90 93 7b 03 	sts	0x037B, r25	; 0x80037b <xSerialSemaphoreColorSensor+0x1>
     cc0:	80 93 7a 03 	sts	0x037A, r24	; 0x80037a <xSerialSemaphoreColorSensor>
     cc4:	00 97       	sbiw	r24, 0x00	; 0
     cc6:	39 f0       	breq	.+14     	; 0xcd6 <setup+0x8e>
     cc8:	20 e0       	ldi	r18, 0x00	; 0
     cca:	40 e0       	ldi	r20, 0x00	; 0
     ccc:	50 e0       	ldi	r21, 0x00	; 0
     cce:	60 e0       	ldi	r22, 0x00	; 0
     cd0:	70 e0       	ldi	r23, 0x00	; 0
     cd2:	0e 94 1a 0d 	call	0x1a34	; 0x1a34 <xQueueGenericSend>
		if ( ( xSerialSemaphoreColorSensor ) != NULL ) {
     cd6:	80 91 7a 03 	lds	r24, 0x037A	; 0x80037a <xSerialSemaphoreColorSensor>
     cda:	90 91 7b 03 	lds	r25, 0x037B	; 0x80037b <xSerialSemaphoreColorSensor+0x1>
     cde:	00 97       	sbiw	r24, 0x00	; 0
     ce0:	39 f0       	breq	.+14     	; 0xcf0 <setup+0xa8>
			xSemaphoreGive( ( xSerialSemaphoreColorSensor ) ); }
     ce2:	20 e0       	ldi	r18, 0x00	; 0
     ce4:	40 e0       	ldi	r20, 0x00	; 0
     ce6:	50 e0       	ldi	r21, 0x00	; 0
     ce8:	60 e0       	ldi	r22, 0x00	; 0
     cea:	70 e0       	ldi	r23, 0x00	; 0
     cec:	0e 94 1a 0d 	call	0x1a34	; 0x1a34 <xQueueGenericSend>
	TaskColorSensor
	,  (const portCHAR *)"ColorSensor"
	,  128
	,  NULL
	,  2
	,  &xColorSensor ); 
     cf0:	88 e7       	ldi	r24, 0x78	; 120
     cf2:	e8 2e       	mov	r14, r24
     cf4:	83 e0       	ldi	r24, 0x03	; 3
     cf6:	f8 2e       	mov	r15, r24
     cf8:	02 e0       	ldi	r16, 0x02	; 2
     cfa:	20 e0       	ldi	r18, 0x00	; 0
     cfc:	30 e0       	ldi	r19, 0x00	; 0
     cfe:	40 e8       	ldi	r20, 0x80	; 128
     d00:	50 e0       	ldi	r21, 0x00	; 0
     d02:	6a eb       	ldi	r22, 0xBA	; 186
     d04:	71 e0       	ldi	r23, 0x01	; 1
     d06:	84 e5       	ldi	r24, 0x54	; 84
     d08:	95 e0       	ldi	r25, 0x05	; 5
     d0a:	0e 94 17 10 	call	0x202e	; 0x202e <xTaskCreate>
	TaskPHandTemperature
	,  (const portCHAR *) "PHandTemperature"
	,  128
	,  NULL
	,  2
	,  &xPHandTemperature );
     d0e:	96 e7       	ldi	r25, 0x76	; 118
     d10:	e9 2e       	mov	r14, r25
     d12:	93 e0       	ldi	r25, 0x03	; 3
     d14:	f9 2e       	mov	r15, r25
     d16:	20 e0       	ldi	r18, 0x00	; 0
     d18:	30 e0       	ldi	r19, 0x00	; 0
     d1a:	40 e8       	ldi	r20, 0x80	; 128
     d1c:	50 e0       	ldi	r21, 0x00	; 0
     d1e:	66 ec       	ldi	r22, 0xC6	; 198
     d20:	71 e0       	ldi	r23, 0x01	; 1
     d22:	86 ed       	ldi	r24, 0xD6	; 214
     d24:	94 e0       	ldi	r25, 0x04	; 4
     d26:	0e 94 17 10 	call	0x202e	; 0x202e <xTaskCreate>

	// Now the task scheduler, which takes over control of scheduling individual tasks, is automatically started.
	vTaskStartScheduler();
}
     d2a:	0f 91       	pop	r16
     d2c:	ff 90       	pop	r15
     d2e:	ef 90       	pop	r14
	,  NULL
	,  2
	,  &xPHandTemperature );

	// Now the task scheduler, which takes over control of scheduling individual tasks, is automatically started.
	vTaskStartScheduler();
     d30:	0c 94 23 11 	jmp	0x2246	; 0x2246 <vTaskStartScheduler>

00000d34 <loop>:
}

void loop()
{
     d34:	08 95       	ret

00000d36 <_GLOBAL__sub_I_Red>:
SemaphoreHandle_t xSerialSemaphoreColorSensor;

TaskHandle_t xColorSensor;
TaskHandle_t xPHandTemperature;

SoftwareSerial serial(rxPin, txPin);
     d36:	20 e0       	ldi	r18, 0x00	; 0
     d38:	43 e0       	ldi	r20, 0x03	; 3
     d3a:	62 e0       	ldi	r22, 0x02	; 2
     d3c:	87 e5       	ldi	r24, 0x57	; 87
     d3e:	93 e0       	ldi	r25, 0x03	; 3
     d40:	0c 94 61 1a 	jmp	0x34c2	; 0x34c2 <_ZN14SoftwareSerialC1Ehhb>

00000d44 <_GLOBAL__sub_D_Red>:
     d44:	87 e5       	ldi	r24, 0x57	; 87
     d46:	93 e0       	ldi	r25, 0x03	; 3
     d48:	0c 94 08 1a 	jmp	0x3410	; 0x3410 <_ZN14SoftwareSerialD1Ev>

00000d4c <_Z8fromWifiv>:
  }
}


void fromWifi()
{
     d4c:	ef 92       	push	r14
     d4e:	ff 92       	push	r15
     d50:	0f 93       	push	r16
     d52:	1f 93       	push	r17
     d54:	cf 93       	push	r28
     d56:	df 93       	push	r29
     d58:	00 d0       	rcall	.+0      	; 0xd5a <_Z8fromWifiv+0xe>
     d5a:	cd b7       	in	r28, 0x3d	; 61
     d5c:	de b7       	in	r29, 0x3e	; 62
	char action = '\0';
	// check for data from Wifi
	delay(50);
     d5e:	62 e3       	ldi	r22, 0x32	; 50
     d60:	70 e0       	ldi	r23, 0x00	; 0
     d62:	80 e0       	ldi	r24, 0x00	; 0
     d64:	90 e0       	ldi	r25, 0x00	; 0
     d66:	0e 94 4d 21 	call	0x429a	; 0x429a <delay>
	if (serial.available() > 0)
     d6a:	87 e5       	ldi	r24, 0x57	; 87
     d6c:	93 e0       	ldi	r25, 0x03	; 3
     d6e:	0e 94 37 19 	call	0x326e	; 0x326e <_ZN14SoftwareSerial9availableEv>
     d72:	18 16       	cp	r1, r24
     d74:	19 06       	cpc	r1, r25
     d76:	0c f0       	brlt	.+2      	; 0xd7a <_Z8fromWifiv+0x2e>
     d78:	48 c0       	rjmp	.+144    	; 0xe0a <_Z8fromWifiv+0xbe>
	{
		delay(100); // allows all serial sent to be received together
     d7a:	64 e6       	ldi	r22, 0x64	; 100
     d7c:	70 e0       	ldi	r23, 0x00	; 0
     d7e:	80 e0       	ldi	r24, 0x00	; 0
     d80:	90 e0       	ldi	r25, 0x00	; 0
     d82:	0e 94 4d 21 	call	0x429a	; 0x429a <delay>
		Serial.println(serial.available());
     d86:	87 e5       	ldi	r24, 0x57	; 87
     d88:	93 e0       	ldi	r25, 0x03	; 3
     d8a:	0e 94 37 19 	call	0x326e	; 0x326e <_ZN14SoftwareSerial9availableEv>
     d8e:	4a e0       	ldi	r20, 0x0A	; 10
     d90:	50 e0       	ldi	r21, 0x00	; 0
     d92:	bc 01       	movw	r22, r24
     d94:	84 e5       	ldi	r24, 0x54	; 84
     d96:	94 e0       	ldi	r25, 0x04	; 4
     d98:	0e 94 5d 20 	call	0x40ba	; 0x40ba <_ZN5Print7printlnEii>
}


void fromWifi()
{
	char action = '\0';
     d9c:	10 e0       	ldi	r17, 0x00	; 0
		{
			char c = serial.read();
			char str[] = {c, '\0'};
			// currently updating temperature threshold - read in int values
			if (setTemp) {
				thresh *= 10;
     d9e:	0a e0       	ldi	r16, 0x0A	; 10
	delay(50);
	if (serial.available() > 0)
	{
		delay(100); // allows all serial sent to be received together
		Serial.println(serial.available());
		while (serial.available() > 0)
     da0:	87 e5       	ldi	r24, 0x57	; 87
     da2:	93 e0       	ldi	r25, 0x03	; 3
     da4:	0e 94 37 19 	call	0x326e	; 0x326e <_ZN14SoftwareSerial9availableEv>
     da8:	18 16       	cp	r1, r24
     daa:	19 06       	cpc	r1, r25
     dac:	7c f5       	brge	.+94     	; 0xe0c <_Z8fromWifiv+0xc0>
		{
			char c = serial.read();
     dae:	87 e5       	ldi	r24, 0x57	; 87
     db0:	93 e0       	ldi	r25, 0x03	; 3
     db2:	0e 94 ad 18 	call	0x315a	; 0x315a <_ZN14SoftwareSerial4readEv>
			char str[] = {c, '\0'};
     db6:	1a 82       	std	Y+2, r1	; 0x02
     db8:	19 82       	std	Y+1, r1	; 0x01
     dba:	89 83       	std	Y+1, r24	; 0x01
			// currently updating temperature threshold - read in int values
			if (setTemp) {
     dbc:	90 91 80 03 	lds	r25, 0x0380	; 0x800380 <setTemp>
     dc0:	99 23       	and	r25, r25
     dc2:	09 f1       	breq	.+66     	; 0xe06 <_Z8fromWifiv+0xba>
				thresh *= 10;
     dc4:	80 91 7e 03 	lds	r24, 0x037E	; 0x80037e <thresh>
     dc8:	90 91 7f 03 	lds	r25, 0x037F	; 0x80037f <thresh+0x1>
     dcc:	08 9f       	mul	r16, r24
     dce:	70 01       	movw	r14, r0
     dd0:	09 9f       	mul	r16, r25
     dd2:	f0 0c       	add	r15, r0
     dd4:	11 24       	eor	r1, r1
     dd6:	f0 92 7f 03 	sts	0x037F, r15	; 0x80037f <thresh+0x1>
     dda:	e0 92 7e 03 	sts	0x037E, r14	; 0x80037e <thresh>
				thresh += atoi(str);
     dde:	ce 01       	movw	r24, r28
     de0:	01 96       	adiw	r24, 0x01	; 1
     de2:	0e 94 a0 25 	call	0x4b40	; 0x4b40 <atoi>
     de6:	8e 0d       	add	r24, r14
     de8:	9f 1d       	adc	r25, r15
     dea:	90 93 7f 03 	sts	0x037F, r25	; 0x80037f <thresh+0x1>
     dee:	80 93 7e 03 	sts	0x037E, r24	; 0x80037e <thresh>
				++setTempCounter;
     df2:	80 91 7c 03 	lds	r24, 0x037C	; 0x80037c <setTempCounter>
     df6:	90 91 7d 03 	lds	r25, 0x037D	; 0x80037d <setTempCounter+0x1>
     dfa:	01 96       	adiw	r24, 0x01	; 1
     dfc:	90 93 7d 03 	sts	0x037D, r25	; 0x80037d <setTempCounter+0x1>
     e00:	80 93 7c 03 	sts	0x037C, r24	; 0x80037c <setTempCounter>
     e04:	81 2f       	mov	r24, r17
	delay(50);
	if (serial.available() > 0)
	{
		delay(100); // allows all serial sent to be received together
		Serial.println(serial.available());
		while (serial.available() > 0)
     e06:	18 2f       	mov	r17, r24
     e08:	cb cf       	rjmp	.-106    	; 0xda0 <_Z8fromWifiv+0x54>
}


void fromWifi()
{
	char action = '\0';
     e0a:	10 e0       	ldi	r17, 0x00	; 0
			}
		}
	}
	
	// found all temp threshold values
	if (setTempCounter == 4)
     e0c:	80 91 7c 03 	lds	r24, 0x037C	; 0x80037c <setTempCounter>
     e10:	90 91 7d 03 	lds	r25, 0x037D	; 0x80037d <setTempCounter+0x1>
     e14:	04 97       	sbiw	r24, 0x04	; 4
     e16:	51 f4       	brne	.+20     	; 0xe2c <_Z8fromWifiv+0xe0>
	{
		tempThreshold = thresh;
     e18:	80 91 7e 03 	lds	r24, 0x037E	; 0x80037e <thresh>
     e1c:	90 91 7f 03 	lds	r25, 0x037F	; 0x80037f <thresh+0x1>
     e20:	90 93 1c 01 	sts	0x011C, r25	; 0x80011c <tempThreshold+0x1>
     e24:	80 93 1b 01 	sts	0x011B, r24	; 0x80011b <tempThreshold>
		setTemp = false;
     e28:	10 92 80 03 	sts	0x0380, r1	; 0x800380 <setTemp>
	}

	static BaseType_t xHigherPriorityTaskWoken;
	xHigherPriorityTaskWoken = pdFALSE;
     e2c:	10 92 56 03 	sts	0x0356, r1	; 0x800356 <_ZZ8fromWifivE24xHigherPriorityTaskWoken>

	switch(action)
     e30:	10 35       	cpi	r17, 0x50	; 80
     e32:	09 f4       	brne	.+2      	; 0xe36 <_Z8fromWifiv+0xea>
     e34:	5f c0       	rjmp	.+190    	; 0xef4 <_Z8fromWifiv+0x1a8>
     e36:	40 f4       	brcc	.+16     	; 0xe48 <_Z8fromWifiv+0xfc>
     e38:	13 34       	cpi	r17, 0x43	; 67
     e3a:	29 f1       	breq	.+74     	; 0xe86 <_Z8fromWifiv+0x13a>
     e3c:	1e 34       	cpi	r17, 0x4E	; 78
     e3e:	c1 f0       	breq	.+48     	; 0xe70 <_Z8fromWifiv+0x124>
     e40:	11 34       	cpi	r17, 0x41	; 65
     e42:	09 f0       	breq	.+2      	; 0xe46 <_Z8fromWifiv+0xfa>
     e44:	7c c0       	rjmp	.+248    	; 0xf3e <_Z8fromWifiv+0x1f2>
     e46:	14 c0       	rjmp	.+40     	; 0xe70 <_Z8fromWifiv+0x124>
     e48:	14 35       	cpi	r17, 0x54	; 84
     e4a:	09 f4       	brne	.+2      	; 0xe4e <_Z8fromWifiv+0x102>
     e4c:	68 c0       	rjmp	.+208    	; 0xf1e <_Z8fromWifiv+0x1d2>
     e4e:	1e 36       	cpi	r17, 0x6E	; 110
     e50:	79 f0       	breq	.+30     	; 0xe70 <_Z8fromWifiv+0x124>
     e52:	13 35       	cpi	r17, 0x53	; 83
     e54:	09 f0       	breq	.+2      	; 0xe58 <_Z8fromWifiv+0x10c>
     e56:	73 c0       	rjmp	.+230    	; 0xf3e <_Z8fromWifiv+0x1f2>
		break;
	}
	case 'S':
	{
		// set up to read ints for threshold
		setTemp = true;
     e58:	81 e0       	ldi	r24, 0x01	; 1
     e5a:	80 93 80 03 	sts	0x0380, r24	; 0x800380 <setTemp>
		setTempCounter = 0;
     e5e:	10 92 7d 03 	sts	0x037D, r1	; 0x80037d <setTempCounter+0x1>
     e62:	10 92 7c 03 	sts	0x037C, r1	; 0x80037c <setTempCounter>
		thresh = 0;
     e66:	10 92 7f 03 	sts	0x037F, r1	; 0x80037f <thresh+0x1>
     e6a:	10 92 7e 03 	sts	0x037E, r1	; 0x80037e <thresh>
		break;
     e6e:	67 c0       	rjmp	.+206    	; 0xf3e <_Z8fromWifiv+0x1f2>
		xSemaphoreGiveFromISR(xSerialSemaphoreColorSensor, &xHigherPriorityTaskWoken);
		break;
	}
	case 'N':
	{
		colorToRead = 'N';
     e70:	10 93 1a 01 	sts	0x011A, r17	; 0x80011a <colorToRead>
		xSemaphoreGiveFromISR(xSerialSemaphoreColorSensor, &xHigherPriorityTaskWoken);
     e74:	66 e5       	ldi	r22, 0x56	; 86
     e76:	73 e0       	ldi	r23, 0x03	; 3
     e78:	80 91 7a 03 	lds	r24, 0x037A	; 0x80037a <xSerialSemaphoreColorSensor>
     e7c:	90 91 7b 03 	lds	r25, 0x037B	; 0x80037b <xSerialSemaphoreColorSensor+0x1>
     e80:	0e 94 df 0d 	call	0x1bbe	; 0x1bbe <xQueueGiveFromISR>
		break;
     e84:	5c c0       	rjmp	.+184    	; 0xf3e <_Z8fromWifiv+0x1f2>
	}
	case 'C':
	{
		serial.write("ammonia:");
     e86:	67 ed       	ldi	r22, 0xD7	; 215
     e88:	71 e0       	ldi	r23, 0x01	; 1
     e8a:	87 e5       	ldi	r24, 0x57	; 87
     e8c:	93 e0       	ldi	r25, 0x03	; 3
     e8e:	0e 94 1b 05 	call	0xa36	; 0xa36 <_ZN5Print5writeEPKc>
		serial.print(ammoniaValue);
     e92:	60 91 21 01 	lds	r22, 0x0121	; 0x800121 <ammoniaValue>
     e96:	70 91 22 01 	lds	r23, 0x0122	; 0x800122 <ammoniaValue+0x1>
     e9a:	4a e0       	ldi	r20, 0x0A	; 10
     e9c:	50 e0       	ldi	r21, 0x00	; 0
     e9e:	87 e5       	ldi	r24, 0x57	; 87
     ea0:	93 e0       	ldi	r25, 0x03	; 3
     ea2:	0e 94 56 20 	call	0x40ac	; 0x40ac <_ZN5Print5printEii>
		serial.write("   nitrate:");
     ea6:	60 ee       	ldi	r22, 0xE0	; 224
     ea8:	71 e0       	ldi	r23, 0x01	; 1
     eaa:	87 e5       	ldi	r24, 0x57	; 87
     eac:	93 e0       	ldi	r25, 0x03	; 3
     eae:	0e 94 1b 05 	call	0xa36	; 0xa36 <_ZN5Print5writeEPKc>
		serial.print(nitrateValue);
     eb2:	60 91 1f 01 	lds	r22, 0x011F	; 0x80011f <nitrateValue>
     eb6:	70 91 20 01 	lds	r23, 0x0120	; 0x800120 <nitrateValue+0x1>
     eba:	4a e0       	ldi	r20, 0x0A	; 10
     ebc:	50 e0       	ldi	r21, 0x00	; 0
     ebe:	87 e5       	ldi	r24, 0x57	; 87
     ec0:	93 e0       	ldi	r25, 0x03	; 3
     ec2:	0e 94 56 20 	call	0x40ac	; 0x40ac <_ZN5Print5printEii>
		serial.write("   nitrite:");
     ec6:	6c ee       	ldi	r22, 0xEC	; 236
     ec8:	71 e0       	ldi	r23, 0x01	; 1
     eca:	87 e5       	ldi	r24, 0x57	; 87
     ecc:	93 e0       	ldi	r25, 0x03	; 3
     ece:	0e 94 1b 05 	call	0xa36	; 0xa36 <_ZN5Print5writeEPKc>
		serial.print(nitriteValue);
     ed2:	60 91 1d 01 	lds	r22, 0x011D	; 0x80011d <nitriteValue>
     ed6:	70 91 1e 01 	lds	r23, 0x011E	; 0x80011e <nitriteValue+0x1>
     eda:	4a e0       	ldi	r20, 0x0A	; 10
     edc:	50 e0       	ldi	r21, 0x00	; 0
     ede:	87 e5       	ldi	r24, 0x57	; 87
     ee0:	93 e0       	ldi	r25, 0x03	; 3
     ee2:	0e 94 56 20 	call	0x40ac	; 0x40ac <_ZN5Print5printEii>
		serial.write("   ");
     ee6:	68 ef       	ldi	r22, 0xF8	; 248
     ee8:	71 e0       	ldi	r23, 0x01	; 1
     eea:	87 e5       	ldi	r24, 0x57	; 87
     eec:	93 e0       	ldi	r25, 0x03	; 3
     eee:	0e 94 1b 05 	call	0xa36	; 0xa36 <_ZN5Print5writeEPKc>
		break;
     ef2:	25 c0       	rjmp	.+74     	; 0xf3e <_Z8fromWifiv+0x1f2>
	}
	case 'P':
	{
		serial.write("ph:");
     ef4:	6c ef       	ldi	r22, 0xFC	; 252
     ef6:	71 e0       	ldi	r23, 0x01	; 1
     ef8:	87 e5       	ldi	r24, 0x57	; 87
     efa:	93 e0       	ldi	r25, 0x03	; 3
     efc:	0e 94 1b 05 	call	0xa36	; 0xa36 <_ZN5Print5writeEPKc>
		serial.print(phValue);
     f00:	40 91 83 03 	lds	r20, 0x0383	; 0x800383 <phValue>
     f04:	50 91 84 03 	lds	r21, 0x0384	; 0x800384 <phValue+0x1>
     f08:	60 91 85 03 	lds	r22, 0x0385	; 0x800385 <phValue+0x2>
     f0c:	70 91 86 03 	lds	r23, 0x0386	; 0x800386 <phValue+0x3>
     f10:	2a e0       	ldi	r18, 0x0A	; 10
     f12:	30 e0       	ldi	r19, 0x00	; 0
     f14:	87 e5       	ldi	r24, 0x57	; 87
     f16:	93 e0       	ldi	r25, 0x03	; 3
     f18:	0e 94 0e 20 	call	0x401c	; 0x401c <_ZN5Print5printEli>
		break;
     f1c:	10 c0       	rjmp	.+32     	; 0xf3e <_Z8fromWifiv+0x1f2>
	}
	case 'T':
	{
		serial.write("temp:");
     f1e:	60 e0       	ldi	r22, 0x00	; 0
     f20:	72 e0       	ldi	r23, 0x02	; 2
     f22:	87 e5       	ldi	r24, 0x57	; 87
     f24:	93 e0       	ldi	r25, 0x03	; 3
     f26:	0e 94 1b 05 	call	0xa36	; 0xa36 <_ZN5Print5writeEPKc>
		serial.print(tempValue);
     f2a:	60 91 81 03 	lds	r22, 0x0381	; 0x800381 <tempValue>
     f2e:	70 91 82 03 	lds	r23, 0x0382	; 0x800382 <tempValue+0x1>
     f32:	4a e0       	ldi	r20, 0x0A	; 10
     f34:	50 e0       	ldi	r21, 0x00	; 0
     f36:	87 e5       	ldi	r24, 0x57	; 87
     f38:	93 e0       	ldi	r25, 0x03	; 3
     f3a:	0e 94 56 20 	call	0x40ac	; 0x40ac <_ZN5Print5printEii>
		break;
	}
	default:
		break;
	}
	delay(500);
     f3e:	64 ef       	ldi	r22, 0xF4	; 244
     f40:	71 e0       	ldi	r23, 0x01	; 1
     f42:	80 e0       	ldi	r24, 0x00	; 0
     f44:	90 e0       	ldi	r25, 0x00	; 0
     f46:	0e 94 4d 21 	call	0x429a	; 0x429a <delay>
	setLED(Off);
     f4a:	40 91 87 03 	lds	r20, 0x0387	; 0x800387 <Off>
     f4e:	50 91 88 03 	lds	r21, 0x0388	; 0x800388 <Off+0x1>
     f52:	60 91 89 03 	lds	r22, 0x0389	; 0x800389 <Off+0x2>
     f56:	70 91 8a 03 	lds	r23, 0x038A	; 0x80038a <Off+0x3>
     f5a:	80 91 8b 03 	lds	r24, 0x038B	; 0x80038b <Off+0x4>
     f5e:	90 91 8c 03 	lds	r25, 0x038C	; 0x80038c <Off+0x5>
     f62:	0e 94 30 05 	call	0xa60	; 0xa60 <_Z6setLED8LEDColor>
}
     f66:	0f 90       	pop	r0
     f68:	0f 90       	pop	r0
     f6a:	df 91       	pop	r29
     f6c:	cf 91       	pop	r28
     f6e:	1f 91       	pop	r17
     f70:	0f 91       	pop	r16
     f72:	ff 90       	pop	r15
     f74:	ef 90       	pop	r14
     f76:	08 95       	ret

00000f78 <_ZN7OneWire5resetEv>:
   ROM_NO[0] = family_code;
   for (uint8_t i = 1; i < 8; i++)
      ROM_NO[i] = 0;
   LastDiscrepancy = 64;
   LastFamilyDiscrepancy = 0;
   LastDeviceFlag = false;
     f78:	ff 92       	push	r15
     f7a:	0f 93       	push	r16
     f7c:	1f 93       	push	r17
     f7e:	cf 93       	push	r28
     f80:	df 93       	push	r29
     f82:	fc 01       	movw	r30, r24
     f84:	f0 80       	ld	r15, Z
     f86:	c1 81       	ldd	r28, Z+1	; 0x01
     f88:	d2 81       	ldd	r29, Z+2	; 0x02
     f8a:	f8 94       	cli
     f8c:	89 81       	ldd	r24, Y+1	; 0x01
     f8e:	0f 2d       	mov	r16, r15
     f90:	00 95       	com	r16
     f92:	80 23       	and	r24, r16
     f94:	89 83       	std	Y+1, r24	; 0x01
     f96:	78 94       	sei
     f98:	1d e7       	ldi	r17, 0x7D	; 125
     f9a:	11 50       	subi	r17, 0x01	; 1
     f9c:	29 f1       	breq	.+74     	; 0xfe8 <_ZN7OneWire5resetEv+0x70>
     f9e:	82 e0       	ldi	r24, 0x02	; 2
     fa0:	90 e0       	ldi	r25, 0x00	; 0
     fa2:	0e 94 89 21 	call	0x4312	; 0x4312 <delayMicroseconds>
     fa6:	88 81       	ld	r24, Y
     fa8:	8f 21       	and	r24, r15
     faa:	b9 f3       	breq	.-18     	; 0xf9a <_ZN7OneWire5resetEv+0x22>
     fac:	f8 94       	cli
     fae:	8a 81       	ldd	r24, Y+2	; 0x02
     fb0:	80 23       	and	r24, r16
     fb2:	8a 83       	std	Y+2, r24	; 0x02
     fb4:	89 81       	ldd	r24, Y+1	; 0x01
     fb6:	8f 29       	or	r24, r15
     fb8:	89 83       	std	Y+1, r24	; 0x01
     fba:	78 94       	sei
     fbc:	80 ee       	ldi	r24, 0xE0	; 224
     fbe:	91 e0       	ldi	r25, 0x01	; 1
     fc0:	0e 94 89 21 	call	0x4312	; 0x4312 <delayMicroseconds>
     fc4:	f8 94       	cli
     fc6:	89 81       	ldd	r24, Y+1	; 0x01
     fc8:	08 23       	and	r16, r24
     fca:	09 83       	std	Y+1, r16	; 0x01
     fcc:	86 e4       	ldi	r24, 0x46	; 70
     fce:	90 e0       	ldi	r25, 0x00	; 0
     fd0:	0e 94 89 21 	call	0x4312	; 0x4312 <delayMicroseconds>
     fd4:	88 81       	ld	r24, Y
     fd6:	f8 22       	and	r15, r24
     fd8:	11 e0       	ldi	r17, 0x01	; 1
     fda:	09 f0       	breq	.+2      	; 0xfde <_ZN7OneWire5resetEv+0x66>
     fdc:	10 e0       	ldi	r17, 0x00	; 0
     fde:	78 94       	sei
     fe0:	8a e9       	ldi	r24, 0x9A	; 154
     fe2:	91 e0       	ldi	r25, 0x01	; 1
     fe4:	0e 94 89 21 	call	0x4312	; 0x4312 <delayMicroseconds>
     fe8:	81 2f       	mov	r24, r17
     fea:	df 91       	pop	r29
     fec:	cf 91       	pop	r28
     fee:	1f 91       	pop	r17
     ff0:	0f 91       	pop	r16
     ff2:	ff 90       	pop	r15
     ff4:	08 95       	ret

00000ff6 <_ZN7OneWire9write_bitEh>:
     ff6:	1f 93       	push	r17
     ff8:	cf 93       	push	r28
     ffa:	df 93       	push	r29
     ffc:	fc 01       	movw	r30, r24
     ffe:	10 81       	ld	r17, Z
    1000:	c1 81       	ldd	r28, Z+1	; 0x01
    1002:	d2 81       	ldd	r29, Z+2	; 0x02
    1004:	81 2f       	mov	r24, r17
    1006:	80 95       	com	r24
    1008:	60 ff       	sbrs	r22, 0
    100a:	12 c0       	rjmp	.+36     	; 0x1030 <_ZN7OneWire9write_bitEh+0x3a>
    100c:	f8 94       	cli
    100e:	9a 81       	ldd	r25, Y+2	; 0x02
    1010:	89 23       	and	r24, r25
    1012:	8a 83       	std	Y+2, r24	; 0x02
    1014:	89 81       	ldd	r24, Y+1	; 0x01
    1016:	81 2b       	or	r24, r17
    1018:	89 83       	std	Y+1, r24	; 0x01
    101a:	8a e0       	ldi	r24, 0x0A	; 10
    101c:	90 e0       	ldi	r25, 0x00	; 0
    101e:	0e 94 89 21 	call	0x4312	; 0x4312 <delayMicroseconds>
    1022:	8a 81       	ldd	r24, Y+2	; 0x02
    1024:	18 2b       	or	r17, r24
    1026:	1a 83       	std	Y+2, r17	; 0x02
    1028:	78 94       	sei
    102a:	87 e3       	ldi	r24, 0x37	; 55
    102c:	90 e0       	ldi	r25, 0x00	; 0
    102e:	11 c0       	rjmp	.+34     	; 0x1052 <_ZN7OneWire9write_bitEh+0x5c>
    1030:	f8 94       	cli
    1032:	9a 81       	ldd	r25, Y+2	; 0x02
    1034:	89 23       	and	r24, r25
    1036:	8a 83       	std	Y+2, r24	; 0x02
    1038:	89 81       	ldd	r24, Y+1	; 0x01
    103a:	81 2b       	or	r24, r17
    103c:	89 83       	std	Y+1, r24	; 0x01
    103e:	81 e4       	ldi	r24, 0x41	; 65
    1040:	90 e0       	ldi	r25, 0x00	; 0
    1042:	0e 94 89 21 	call	0x4312	; 0x4312 <delayMicroseconds>
    1046:	8a 81       	ldd	r24, Y+2	; 0x02
    1048:	18 2b       	or	r17, r24
    104a:	1a 83       	std	Y+2, r17	; 0x02
    104c:	78 94       	sei
    104e:	85 e0       	ldi	r24, 0x05	; 5
    1050:	90 e0       	ldi	r25, 0x00	; 0
    1052:	df 91       	pop	r29
    1054:	cf 91       	pop	r28
    1056:	1f 91       	pop	r17
    1058:	0c 94 89 21 	jmp	0x4312	; 0x4312 <delayMicroseconds>

0000105c <_ZN7OneWire8read_bitEv>:
    105c:	0f 93       	push	r16
    105e:	1f 93       	push	r17
    1060:	cf 93       	push	r28
    1062:	df 93       	push	r29
    1064:	fc 01       	movw	r30, r24
    1066:	00 81       	ld	r16, Z
    1068:	c1 81       	ldd	r28, Z+1	; 0x01
    106a:	d2 81       	ldd	r29, Z+2	; 0x02
    106c:	f8 94       	cli
    106e:	89 81       	ldd	r24, Y+1	; 0x01
    1070:	80 2b       	or	r24, r16
    1072:	89 83       	std	Y+1, r24	; 0x01
    1074:	8a 81       	ldd	r24, Y+2	; 0x02
    1076:	10 2f       	mov	r17, r16
    1078:	10 95       	com	r17
    107a:	81 23       	and	r24, r17
    107c:	8a 83       	std	Y+2, r24	; 0x02
    107e:	83 e0       	ldi	r24, 0x03	; 3
    1080:	90 e0       	ldi	r25, 0x00	; 0
    1082:	0e 94 89 21 	call	0x4312	; 0x4312 <delayMicroseconds>
    1086:	89 81       	ldd	r24, Y+1	; 0x01
    1088:	18 23       	and	r17, r24
    108a:	19 83       	std	Y+1, r17	; 0x01
    108c:	8a e0       	ldi	r24, 0x0A	; 10
    108e:	90 e0       	ldi	r25, 0x00	; 0
    1090:	0e 94 89 21 	call	0x4312	; 0x4312 <delayMicroseconds>
    1094:	c8 81       	ld	r28, Y
    1096:	78 94       	sei
    1098:	85 e3       	ldi	r24, 0x35	; 53
    109a:	90 e0       	ldi	r25, 0x00	; 0
    109c:	0e 94 89 21 	call	0x4312	; 0x4312 <delayMicroseconds>
    10a0:	c0 23       	and	r28, r16
    10a2:	81 e0       	ldi	r24, 0x01	; 1
    10a4:	09 f4       	brne	.+2      	; 0x10a8 <_ZN7OneWire8read_bitEv+0x4c>
    10a6:	80 e0       	ldi	r24, 0x00	; 0
    10a8:	df 91       	pop	r29
    10aa:	cf 91       	pop	r28
    10ac:	1f 91       	pop	r17
    10ae:	0f 91       	pop	r16
    10b0:	08 95       	ret

000010b2 <_ZN7OneWire5writeEhh>:
    10b2:	df 92       	push	r13
    10b4:	ef 92       	push	r14
    10b6:	ff 92       	push	r15
    10b8:	0f 93       	push	r16
    10ba:	1f 93       	push	r17
    10bc:	cf 93       	push	r28
    10be:	df 93       	push	r29
    10c0:	ec 01       	movw	r28, r24
    10c2:	d6 2e       	mov	r13, r22
    10c4:	e4 2e       	mov	r14, r20
    10c6:	08 e0       	ldi	r16, 0x08	; 8
    10c8:	10 e0       	ldi	r17, 0x00	; 0
    10ca:	ff 24       	eor	r15, r15
    10cc:	f3 94       	inc	r15
    10ce:	61 e0       	ldi	r22, 0x01	; 1
    10d0:	8d 2d       	mov	r24, r13
    10d2:	8f 21       	and	r24, r15
    10d4:	09 f4       	brne	.+2      	; 0x10d8 <_ZN7OneWire5writeEhh+0x26>
    10d6:	60 e0       	ldi	r22, 0x00	; 0
    10d8:	ce 01       	movw	r24, r28
    10da:	0e 94 fb 07 	call	0xff6	; 0xff6 <_ZN7OneWire9write_bitEh>
    10de:	ff 0c       	add	r15, r15
    10e0:	01 50       	subi	r16, 0x01	; 1
    10e2:	11 09       	sbc	r17, r1
    10e4:	a1 f7       	brne	.-24     	; 0x10ce <_ZN7OneWire5writeEhh+0x1c>
    10e6:	e1 10       	cpse	r14, r1
    10e8:	10 c0       	rjmp	.+32     	; 0x110a <_ZN7OneWire5writeEhh+0x58>
    10ea:	f8 94       	cli
    10ec:	e9 81       	ldd	r30, Y+1	; 0x01
    10ee:	fa 81       	ldd	r31, Y+2	; 0x02
    10f0:	91 81       	ldd	r25, Z+1	; 0x01
    10f2:	88 81       	ld	r24, Y
    10f4:	80 95       	com	r24
    10f6:	89 23       	and	r24, r25
    10f8:	81 83       	std	Z+1, r24	; 0x01
    10fa:	e9 81       	ldd	r30, Y+1	; 0x01
    10fc:	fa 81       	ldd	r31, Y+2	; 0x02
    10fe:	92 81       	ldd	r25, Z+2	; 0x02
    1100:	88 81       	ld	r24, Y
    1102:	80 95       	com	r24
    1104:	89 23       	and	r24, r25
    1106:	82 83       	std	Z+2, r24	; 0x02
    1108:	78 94       	sei
    110a:	df 91       	pop	r29
    110c:	cf 91       	pop	r28
    110e:	1f 91       	pop	r17
    1110:	0f 91       	pop	r16
    1112:	ff 90       	pop	r15
    1114:	ef 90       	pop	r14
    1116:	df 90       	pop	r13
    1118:	08 95       	ret

0000111a <_ZN7OneWire4readEv>:
    111a:	ef 92       	push	r14
    111c:	ff 92       	push	r15
    111e:	0f 93       	push	r16
    1120:	1f 93       	push	r17
    1122:	cf 93       	push	r28
    1124:	df 93       	push	r29
    1126:	7c 01       	movw	r14, r24
    1128:	08 e0       	ldi	r16, 0x08	; 8
    112a:	10 e0       	ldi	r17, 0x00	; 0
    112c:	c0 e0       	ldi	r28, 0x00	; 0
    112e:	d1 e0       	ldi	r29, 0x01	; 1
    1130:	c7 01       	movw	r24, r14
    1132:	0e 94 2e 08 	call	0x105c	; 0x105c <_ZN7OneWire8read_bitEv>
    1136:	81 11       	cpse	r24, r1
    1138:	cd 2b       	or	r28, r29
    113a:	dd 0f       	add	r29, r29
    113c:	01 50       	subi	r16, 0x01	; 1
    113e:	11 09       	sbc	r17, r1
    1140:	b9 f7       	brne	.-18     	; 0x1130 <_ZN7OneWire4readEv+0x16>
    1142:	8c 2f       	mov	r24, r28
    1144:	df 91       	pop	r29
    1146:	cf 91       	pop	r28
    1148:	1f 91       	pop	r17
    114a:	0f 91       	pop	r16
    114c:	ff 90       	pop	r15
    114e:	ef 90       	pop	r14
    1150:	08 95       	ret

00001152 <_ZN7OneWire6selectEPKh>:
    1152:	ef 92       	push	r14
    1154:	ff 92       	push	r15
    1156:	0f 93       	push	r16
    1158:	1f 93       	push	r17
    115a:	cf 93       	push	r28
    115c:	df 93       	push	r29
    115e:	8c 01       	movw	r16, r24
    1160:	7b 01       	movw	r14, r22
    1162:	40 e0       	ldi	r20, 0x00	; 0
    1164:	65 e5       	ldi	r22, 0x55	; 85
    1166:	0e 94 59 08 	call	0x10b2	; 0x10b2 <_ZN7OneWire5writeEhh>
    116a:	e7 01       	movw	r28, r14
    116c:	88 e0       	ldi	r24, 0x08	; 8
    116e:	e8 0e       	add	r14, r24
    1170:	f1 1c       	adc	r15, r1
    1172:	69 91       	ld	r22, Y+
    1174:	40 e0       	ldi	r20, 0x00	; 0
    1176:	c8 01       	movw	r24, r16
    1178:	0e 94 59 08 	call	0x10b2	; 0x10b2 <_ZN7OneWire5writeEhh>
    117c:	ce 15       	cp	r28, r14
    117e:	df 05       	cpc	r29, r15
    1180:	c1 f7       	brne	.-16     	; 0x1172 <_ZN7OneWire6selectEPKh+0x20>
    1182:	df 91       	pop	r29
    1184:	cf 91       	pop	r28
    1186:	1f 91       	pop	r17
    1188:	0f 91       	pop	r16
    118a:	ff 90       	pop	r15
    118c:	ef 90       	pop	r14
    118e:	08 95       	ret

00001190 <_ZN7OneWire12reset_searchEv>:
    1190:	fc 01       	movw	r30, r24
    1192:	13 86       	std	Z+11, r1	; 0x0b
    1194:	15 86       	std	Z+13, r1	; 0x0d
    1196:	14 86       	std	Z+12, r1	; 0x0c
    1198:	dc 01       	movw	r26, r24
    119a:	1b 96       	adiw	r26, 0x0b	; 11
    119c:	33 96       	adiw	r30, 0x03	; 3
    119e:	1e 92       	st	-X, r1
    11a0:	ae 17       	cp	r26, r30
    11a2:	bf 07       	cpc	r27, r31
    11a4:	e1 f7       	brne	.-8      	; 0x119e <_ZN7OneWire12reset_searchEv+0xe>
    11a6:	08 95       	ret

000011a8 <_ZN7OneWire5beginEh>:
    11a8:	1f 93       	push	r17
    11aa:	cf 93       	push	r28
    11ac:	df 93       	push	r29
    11ae:	ec 01       	movw	r28, r24
    11b0:	16 2f       	mov	r17, r22
    11b2:	60 e0       	ldi	r22, 0x00	; 0
    11b4:	81 2f       	mov	r24, r17
    11b6:	0e 94 74 22 	call	0x44e8	; 0x44e8 <pinMode>
    11ba:	61 2f       	mov	r22, r17
    11bc:	70 e0       	ldi	r23, 0x00	; 0
    11be:	fb 01       	movw	r30, r22
    11c0:	ea 53       	subi	r30, 0x3A	; 58
    11c2:	ff 4f       	sbci	r31, 0xFF	; 255
    11c4:	e4 91       	lpm	r30, Z
    11c6:	e8 83       	st	Y, r30
    11c8:	fb 01       	movw	r30, r22
    11ca:	e6 52       	subi	r30, 0x26	; 38
    11cc:	ff 4f       	sbci	r31, 0xFF	; 255
    11ce:	e4 91       	lpm	r30, Z
    11d0:	f0 e0       	ldi	r31, 0x00	; 0
    11d2:	ee 0f       	add	r30, r30
    11d4:	ff 1f       	adc	r31, r31
    11d6:	e2 51       	subi	r30, 0x12	; 18
    11d8:	ff 4f       	sbci	r31, 0xFF	; 255
    11da:	85 91       	lpm	r24, Z+
    11dc:	94 91       	lpm	r25, Z
    11de:	9a 83       	std	Y+2, r25	; 0x02
    11e0:	89 83       	std	Y+1, r24	; 0x01
    11e2:	ce 01       	movw	r24, r28
    11e4:	df 91       	pop	r29
    11e6:	cf 91       	pop	r28
    11e8:	1f 91       	pop	r17
    11ea:	0c 94 c8 08 	jmp	0x1190	; 0x1190 <_ZN7OneWire12reset_searchEv>

000011ee <_ZN7OneWire6searchEPhb>:
// search state.
// Return TRUE  : device found, ROM number in ROM_NO buffer
//        FALSE : device not found, end of search
//
bool OneWire::search(uint8_t *newAddr, bool search_mode /* = true */)
{
    11ee:	bf 92       	push	r11
    11f0:	cf 92       	push	r12
    11f2:	df 92       	push	r13
    11f4:	ef 92       	push	r14
    11f6:	ff 92       	push	r15
    11f8:	0f 93       	push	r16
    11fa:	1f 93       	push	r17
    11fc:	cf 93       	push	r28
    11fe:	df 93       	push	r29
    1200:	ec 01       	movw	r28, r24
    1202:	6b 01       	movw	r12, r22
    1204:	14 2f       	mov	r17, r20
   rom_byte_number = 0;
   rom_byte_mask = 1;
   search_result = false;

   // if the last call was not the last one
   if (!LastDeviceFlag) {
    1206:	8d 85       	ldd	r24, Y+13	; 0x0d
    1208:	81 11       	cpse	r24, r1
    120a:	05 c0       	rjmp	.+10     	; 0x1216 <_ZN7OneWire6searchEPhb+0x28>
      // 1-Wire reset
      if (!reset()) {
    120c:	ce 01       	movw	r24, r28
    120e:	0e 94 bc 07 	call	0xf78	; 0xf78 <_ZN7OneWire5resetEv>
    1212:	81 11       	cpse	r24, r1
    1214:	05 c0       	rjmp	.+10     	; 0x1220 <_ZN7OneWire6searchEPhb+0x32>
         // reset the search
         LastDiscrepancy = 0;
    1216:	1b 86       	std	Y+11, r1	; 0x0b
         LastDeviceFlag = false;
    1218:	1d 86       	std	Y+13, r1	; 0x0d
         LastFamilyDiscrepancy = 0;
    121a:	1c 86       	std	Y+12, r1	; 0x0c
         return false;
    121c:	80 e0       	ldi	r24, 0x00	; 0
    121e:	64 c0       	rjmp	.+200    	; 0x12e8 <_ZN7OneWire6searchEPhb+0xfa>
      }

      // issue the search command
      if (search_mode == true) {
        write(0xF0);   // NORMAL SEARCH
    1220:	40 e0       	ldi	r20, 0x00	; 0
         LastFamilyDiscrepancy = 0;
         return false;
      }

      // issue the search command
      if (search_mode == true) {
    1222:	11 23       	and	r17, r17
    1224:	11 f0       	breq	.+4      	; 0x122a <_ZN7OneWire6searchEPhb+0x3c>
        write(0xF0);   // NORMAL SEARCH
    1226:	60 ef       	ldi	r22, 0xF0	; 240
    1228:	01 c0       	rjmp	.+2      	; 0x122c <_ZN7OneWire6searchEPhb+0x3e>
      } else {
        write(0xEC);   // CONDITIONAL SEARCH
    122a:	6c ee       	ldi	r22, 0xEC	; 236
    122c:	ce 01       	movw	r24, r28
    122e:	0e 94 59 08 	call	0x10b2	; 0x10b2 <_ZN7OneWire5writeEhh>
// search state.
// Return TRUE  : device found, ROM number in ROM_NO buffer
//        FALSE : device not found, end of search
//
bool OneWire::search(uint8_t *newAddr, bool search_mode /* = true */)
{
    1232:	01 e0       	ldi	r16, 0x01	; 1
    1234:	e1 2c       	mov	r14, r1
    1236:	b1 2c       	mov	r11, r1
    1238:	11 e0       	ldi	r17, 0x01	; 1

      // loop to do the search
      do
      {
         // read a bit and its complement
         id_bit = read_bit();
    123a:	ce 01       	movw	r24, r28
    123c:	0e 94 2e 08 	call	0x105c	; 0x105c <_ZN7OneWire8read_bitEv>
    1240:	f8 2e       	mov	r15, r24
         cmp_id_bit = read_bit();
    1242:	ce 01       	movw	r24, r28
    1244:	0e 94 2e 08 	call	0x105c	; 0x105c <_ZN7OneWire8read_bitEv>

         // check for no devices on 1-wire
         if ((id_bit == 1) && (cmp_id_bit == 1)) {
    1248:	91 e0       	ldi	r25, 0x01	; 1
    124a:	f9 12       	cpse	r15, r25
    124c:	03 c0       	rjmp	.+6      	; 0x1254 <_ZN7OneWire6searchEPhb+0x66>
    124e:	81 30       	cpi	r24, 0x01	; 1
    1250:	b1 f4       	brne	.+44     	; 0x127e <_ZN7OneWire6searchEPhb+0x90>
    1252:	34 c0       	rjmp	.+104    	; 0x12bc <_ZN7OneWire6searchEPhb+0xce>
    1254:	2e 2d       	mov	r18, r14
    1256:	30 e0       	ldi	r19, 0x00	; 0
            break;
         } else {
            // all devices coupled have 0 or 1
            if (id_bit != cmp_id_bit) {
    1258:	f8 12       	cpse	r15, r24
    125a:	1b c0       	rjmp	.+54     	; 0x1292 <_ZN7OneWire6searchEPhb+0xa4>
               search_direction = id_bit;  // bit write value for search
            } else {
               // if this discrepancy if before the Last Discrepancy
               // on a previous next then pick the same as last time
               if (id_bit_number < LastDiscrepancy) {
    125c:	8b 85       	ldd	r24, Y+11	; 0x0b
    125e:	18 17       	cp	r17, r24
    1260:	38 f4       	brcc	.+14     	; 0x1270 <_ZN7OneWire6searchEPhb+0x82>
                  search_direction = ((ROM_NO[rom_byte_number] & rom_byte_mask) > 0);
    1262:	fe 01       	movw	r30, r28
    1264:	e2 0f       	add	r30, r18
    1266:	f3 1f       	adc	r31, r19
    1268:	83 81       	ldd	r24, Z+3	; 0x03
    126a:	80 23       	and	r24, r16
    126c:	41 f4       	brne	.+16     	; 0x127e <_ZN7OneWire6searchEPhb+0x90>
    126e:	02 c0       	rjmp	.+4      	; 0x1274 <_ZN7OneWire6searchEPhb+0x86>
               } else {
                  // if equal to last pick 1, if not then pick 0
                  search_direction = (id_bit_number == LastDiscrepancy);
    1270:	18 17       	cp	r17, r24
    1272:	29 f0       	breq	.+10     	; 0x127e <_ZN7OneWire6searchEPhb+0x90>
    1274:	f1 2c       	mov	r15, r1
               // if 0 was picked then record its position in LastZero
               if (search_direction == 0) {
                  last_zero = id_bit_number;

                  // check for Last discrepancy in family
                  if (last_zero < 9)
    1276:	19 30       	cpi	r17, 0x09	; 9
    1278:	58 f4       	brcc	.+22     	; 0x1290 <_ZN7OneWire6searchEPhb+0xa2>
                     LastFamilyDiscrepancy = last_zero;
    127a:	1c 87       	std	Y+12, r17	; 0x0c
    127c:	09 c0       	rjmp	.+18     	; 0x1290 <_ZN7OneWire6searchEPhb+0xa2>
            }

            // set or clear the bit in the ROM byte rom_byte_number
            // with mask rom_byte_mask
            if (search_direction == 1)
              ROM_NO[rom_byte_number] |= rom_byte_mask;
    127e:	fe 01       	movw	r30, r28
    1280:	ee 0d       	add	r30, r14
    1282:	f1 1d       	adc	r31, r1
    1284:	83 81       	ldd	r24, Z+3	; 0x03
    1286:	80 2b       	or	r24, r16
    1288:	83 83       	std	Z+3, r24	; 0x03
    128a:	ff 24       	eor	r15, r15
    128c:	f3 94       	inc	r15
    128e:	09 c0       	rjmp	.+18     	; 0x12a2 <_ZN7OneWire6searchEPhb+0xb4>
// search state.
// Return TRUE  : device found, ROM number in ROM_NO buffer
//        FALSE : device not found, end of search
//
bool OneWire::search(uint8_t *newAddr, bool search_mode /* = true */)
{
    1290:	b1 2e       	mov	r11, r17
            // set or clear the bit in the ROM byte rom_byte_number
            // with mask rom_byte_mask
            if (search_direction == 1)
              ROM_NO[rom_byte_number] |= rom_byte_mask;
            else
              ROM_NO[rom_byte_number] &= ~rom_byte_mask;
    1292:	fe 01       	movw	r30, r28
    1294:	e2 0f       	add	r30, r18
    1296:	f3 1f       	adc	r31, r19
    1298:	93 81       	ldd	r25, Z+3	; 0x03
    129a:	80 2f       	mov	r24, r16
    129c:	80 95       	com	r24
    129e:	89 23       	and	r24, r25
    12a0:	83 83       	std	Z+3, r24	; 0x03

            // serial number search direction write bit
            write_bit(search_direction);
    12a2:	6f 2d       	mov	r22, r15
    12a4:	ce 01       	movw	r24, r28
    12a6:	0e 94 fb 07 	call	0xff6	; 0xff6 <_ZN7OneWire9write_bitEh>

            // increment the byte counter id_bit_number
            // and shift the mask rom_byte_mask
            id_bit_number++;
    12aa:	1f 5f       	subi	r17, 0xFF	; 255
            rom_byte_mask <<= 1;
    12ac:	00 0f       	add	r16, r16

            // if the mask is 0 then go to new SerialNum byte rom_byte_number and reset mask
            if (rom_byte_mask == 0) {
    12ae:	11 f4       	brne	.+4      	; 0x12b4 <_ZN7OneWire6searchEPhb+0xc6>
                rom_byte_number++;
    12b0:	e3 94       	inc	r14
                rom_byte_mask = 1;
    12b2:	01 e0       	ldi	r16, 0x01	; 1
            }
         }
      }
      while(rom_byte_number < 8);  // loop until through all ROM bytes 0-7
    12b4:	87 e0       	ldi	r24, 0x07	; 7
    12b6:	8e 15       	cp	r24, r14
    12b8:	08 f0       	brcs	.+2      	; 0x12bc <_ZN7OneWire6searchEPhb+0xce>
    12ba:	bf cf       	rjmp	.-130    	; 0x123a <_ZN7OneWire6searchEPhb+0x4c>

      // if the search was successful then
      if (!(id_bit_number < 65)) {
    12bc:	11 34       	cpi	r17, 0x41	; 65
    12be:	08 f4       	brcc	.+2      	; 0x12c2 <_ZN7OneWire6searchEPhb+0xd4>
    12c0:	aa cf       	rjmp	.-172    	; 0x1216 <_ZN7OneWire6searchEPhb+0x28>
         // search successful so set LastDiscrepancy,LastDeviceFlag,search_result
         LastDiscrepancy = last_zero;
    12c2:	bb 86       	std	Y+11, r11	; 0x0b

         // check for last device
         if (LastDiscrepancy == 0) {
    12c4:	b1 10       	cpse	r11, r1
    12c6:	02 c0       	rjmp	.+4      	; 0x12cc <_ZN7OneWire6searchEPhb+0xde>
            LastDeviceFlag = true;
    12c8:	81 e0       	ldi	r24, 0x01	; 1
    12ca:	8d 87       	std	Y+13, r24	; 0x0d
         search_result = true;
      }
   }

   // if no device found then reset counters so next 'search' will be like a first
   if (!search_result || !ROM_NO[0]) {
    12cc:	8b 81       	ldd	r24, Y+3	; 0x03
    12ce:	88 23       	and	r24, r24
    12d0:	09 f4       	brne	.+2      	; 0x12d4 <_ZN7OneWire6searchEPhb+0xe6>
    12d2:	a1 cf       	rjmp	.-190    	; 0x1216 <_ZN7OneWire6searchEPhb+0x28>
    12d4:	de 01       	movw	r26, r28
    12d6:	13 96       	adiw	r26, 0x03	; 3
    12d8:	f6 01       	movw	r30, r12
    12da:	2b 96       	adiw	r28, 0x0b	; 11
      LastDiscrepancy = 0;
      LastDeviceFlag = false;
      LastFamilyDiscrepancy = 0;
      search_result = false;
   } else {
      for (int i = 0; i < 8; i++) newAddr[i] = ROM_NO[i];
    12dc:	8d 91       	ld	r24, X+
    12de:	81 93       	st	Z+, r24
    12e0:	ca 17       	cp	r28, r26
    12e2:	db 07       	cpc	r29, r27
    12e4:	d9 f7       	brne	.-10     	; 0x12dc <_ZN7OneWire6searchEPhb+0xee>
    12e6:	81 e0       	ldi	r24, 0x01	; 1
   }
   return search_result;
  }
    12e8:	df 91       	pop	r29
    12ea:	cf 91       	pop	r28
    12ec:	1f 91       	pop	r17
    12ee:	0f 91       	pop	r16
    12f0:	ff 90       	pop	r15
    12f2:	ef 90       	pop	r14
    12f4:	df 90       	pop	r13
    12f6:	cf 90       	pop	r12
    12f8:	bf 90       	pop	r11
    12fa:	08 95       	ret

000012fc <_ZN7OneWire4crc8EPKhh>:
};

// Compute a Dallas Semiconductor 8 bit CRC. These show up in the ROM
// and the registers.  (Use tiny 2x16 entry CRC table)
uint8_t OneWire::crc8(const uint8_t *addr, uint8_t len)
{
    12fc:	dc 01       	movw	r26, r24
	uint8_t crc = 0;
    12fe:	80 e0       	ldi	r24, 0x00	; 0

	while (len--) {
    1300:	61 50       	subi	r22, 0x01	; 1
    1302:	98 f0       	brcs	.+38     	; 0x132a <_ZN7OneWire4crc8EPKhh+0x2e>
		crc = *addr++ ^ crc;  // just re-using crc as intermediate
    1304:	2d 91       	ld	r18, X+
    1306:	98 2f       	mov	r25, r24
    1308:	92 27       	eor	r25, r18
		crc = pgm_read_byte(dscrc2x16_table + (crc & 0x0f)) ^
    130a:	e9 2f       	mov	r30, r25
    130c:	ef 70       	andi	r30, 0x0F	; 15
    130e:	f0 e0       	ldi	r31, 0x00	; 0
    1310:	ee 56       	subi	r30, 0x6E	; 110
    1312:	ff 4f       	sbci	r31, 0xFF	; 255
    1314:	24 91       	lpm	r18, Z
		pgm_read_byte(dscrc2x16_table + 16 + ((crc >> 4) & 0x0f));
    1316:	92 95       	swap	r25
    1318:	9f 70       	andi	r25, 0x0F	; 15
    131a:	e9 2f       	mov	r30, r25
    131c:	f0 e0       	ldi	r31, 0x00	; 0
    131e:	ee 55       	subi	r30, 0x5E	; 94
    1320:	ff 4f       	sbci	r31, 0xFF	; 255
    1322:	e4 91       	lpm	r30, Z
    1324:	82 2f       	mov	r24, r18
    1326:	8e 27       	eor	r24, r30
// and the registers.  (Use tiny 2x16 entry CRC table)
uint8_t OneWire::crc8(const uint8_t *addr, uint8_t len)
{
	uint8_t crc = 0;

	while (len--) {
    1328:	eb cf       	rjmp	.-42     	; 0x1300 <_ZN7OneWire4crc8EPKhh+0x4>
		crc = pgm_read_byte(dscrc2x16_table + (crc & 0x0f)) ^
		pgm_read_byte(dscrc2x16_table + 16 + ((crc >> 4) & 0x0f));
	}

	return crc;
}
    132a:	08 95       	ret

0000132c <_Z6calcPHv>:
float neutralVoltage = 404.0;
float acidVoltage = 166.0;


float calcPH()
{
    132c:	8f 92       	push	r8
    132e:	9f 92       	push	r9
    1330:	af 92       	push	r10
    1332:	bf 92       	push	r11
    1334:	cf 92       	push	r12
    1336:	df 92       	push	r13
    1338:	ef 92       	push	r14
    133a:	ff 92       	push	r15
    133c:	cf 93       	push	r28
    133e:	df 93       	push	r29
	float voltage = analogRead(PH_PIN);
    1340:	8e e0       	ldi	r24, 0x0E	; 14
    1342:	0e 94 cf 21 	call	0x439e	; 0x439e <analogRead>
    1346:	ec 01       	movw	r28, r24
	float slope = (7.0 - 4.0) / (neutralVoltage - acidVoltage);
    1348:	80 90 39 01 	lds	r8, 0x0139	; 0x800139 <neutralVoltage>
    134c:	90 90 3a 01 	lds	r9, 0x013A	; 0x80013a <neutralVoltage+0x1>
    1350:	a0 90 3b 01 	lds	r10, 0x013B	; 0x80013b <neutralVoltage+0x2>
    1354:	b0 90 3c 01 	lds	r11, 0x013C	; 0x80013c <neutralVoltage+0x3>
    1358:	20 91 35 01 	lds	r18, 0x0135	; 0x800135 <acidVoltage>
    135c:	30 91 36 01 	lds	r19, 0x0136	; 0x800136 <acidVoltage+0x1>
    1360:	40 91 37 01 	lds	r20, 0x0137	; 0x800137 <acidVoltage+0x2>
    1364:	50 91 38 01 	lds	r21, 0x0138	; 0x800138 <acidVoltage+0x3>
    1368:	c5 01       	movw	r24, r10
    136a:	b4 01       	movw	r22, r8
    136c:	0e 94 1a 1b 	call	0x3634	; 0x3634 <__subsf3>
    1370:	9b 01       	movw	r18, r22
    1372:	ac 01       	movw	r20, r24
    1374:	60 e0       	ldi	r22, 0x00	; 0
    1376:	70 e0       	ldi	r23, 0x00	; 0
    1378:	80 e4       	ldi	r24, 0x40	; 64
    137a:	90 e4       	ldi	r25, 0x40	; 64
    137c:	0e 94 8c 1b 	call	0x3718	; 0x3718 <__divsf3>
    1380:	6b 01       	movw	r12, r22
    1382:	7c 01       	movw	r14, r24
	float intercept = 7.0 - (slope * neutralVoltage);
	return (slope * voltage) + intercept;
    1384:	9b 01       	movw	r18, r22
    1386:	ac 01       	movw	r20, r24
    1388:	c5 01       	movw	r24, r10
    138a:	b4 01       	movw	r22, r8
    138c:	0e 94 e6 1c 	call	0x39cc	; 0x39cc <__mulsf3>
    1390:	9b 01       	movw	r18, r22
    1392:	ac 01       	movw	r20, r24
    1394:	60 e0       	ldi	r22, 0x00	; 0
    1396:	70 e0       	ldi	r23, 0x00	; 0
    1398:	80 ee       	ldi	r24, 0xE0	; 224
    139a:	90 e4       	ldi	r25, 0x40	; 64
    139c:	0e 94 1a 1b 	call	0x3634	; 0x3634 <__subsf3>
    13a0:	4b 01       	movw	r8, r22
    13a2:	5c 01       	movw	r10, r24
    13a4:	be 01       	movw	r22, r28
    13a6:	dd 0f       	add	r29, r29
    13a8:	88 0b       	sbc	r24, r24
    13aa:	99 0b       	sbc	r25, r25
    13ac:	0e 94 36 1c 	call	0x386c	; 0x386c <__floatsisf>
    13b0:	a7 01       	movw	r20, r14
    13b2:	96 01       	movw	r18, r12
    13b4:	0e 94 e6 1c 	call	0x39cc	; 0x39cc <__mulsf3>
    13b8:	9b 01       	movw	r18, r22
    13ba:	ac 01       	movw	r20, r24
    13bc:	c5 01       	movw	r24, r10
    13be:	b4 01       	movw	r22, r8
    13c0:	0e 94 1b 1b 	call	0x3636	; 0x3636 <__addsf3>
    13c4:	df 91       	pop	r29
    13c6:	cf 91       	pop	r28
    13c8:	ff 90       	pop	r15
    13ca:	ef 90       	pop	r14
    13cc:	df 90       	pop	r13
    13ce:	cf 90       	pop	r12
    13d0:	bf 90       	pop	r11
    13d2:	af 90       	pop	r10
    13d4:	9f 90       	pop	r9
    13d6:	8f 90       	pop	r8
    13d8:	08 95       	ret

000013da <pvPortMalloc>:
#if( configSUPPORT_DYNAMIC_ALLOCATION > 0 )

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
    13da:	cf 93       	push	r28
    13dc:	df 93       	push	r29
    13de:	ec 01       	movw	r28, r24
void *pvReturn;

    vTaskSuspendAll();
    13e0:	0e 94 51 11 	call	0x22a2	; 0x22a2 <vTaskSuspendAll>
    {
        pvReturn = malloc( xWantedSize );
    13e4:	ce 01       	movw	r24, r28
    13e6:	0e 94 7f 24 	call	0x48fe	; 0x48fe <malloc>
    13ea:	ec 01       	movw	r28, r24
        traceMALLOC( pvReturn, xWantedSize );
    }
    ( void ) xTaskResumeAll();
    13ec:	0e 94 0d 12 	call	0x241a	; 0x241a <xTaskResumeAll>

    #if( configUSE_MALLOC_FAILED_HOOK == 1 )
    {
        if( pvReturn == NULL )
    13f0:	20 97       	sbiw	r28, 0x00	; 0
    13f2:	11 f4       	brne	.+4      	; 0x13f8 <pvPortMalloc+0x1e>
        {
            extern void vApplicationMallocFailedHook( void );
            vApplicationMallocFailedHook();
    13f4:	0e 94 ea 16 	call	0x2dd4	; 0x2dd4 <vApplicationMallocFailedHook>
        }
    }
    #endif

    return pvReturn;
}
    13f8:	ce 01       	movw	r24, r28
    13fa:	df 91       	pop	r29
    13fc:	cf 91       	pop	r28
    13fe:	08 95       	ret

00001400 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
    1400:	cf 93       	push	r28
    1402:	df 93       	push	r29
    if( pv )
    1404:	00 97       	sbiw	r24, 0x00	; 0
    1406:	51 f0       	breq	.+20     	; 0x141c <vPortFree+0x1c>
    1408:	ec 01       	movw	r28, r24
    {
        vTaskSuspendAll();
    140a:	0e 94 51 11 	call	0x22a2	; 0x22a2 <vTaskSuspendAll>
        {
            free( pv );
    140e:	ce 01       	movw	r24, r28
    1410:	0e 94 17 25 	call	0x4a2e	; 0x4a2e <free>
            traceFREE( pv, 0 );
        }
        ( void ) xTaskResumeAll();
    }
}
    1414:	df 91       	pop	r29
    1416:	cf 91       	pop	r28
        vTaskSuspendAll();
        {
            free( pv );
            traceFREE( pv, 0 );
        }
        ( void ) xTaskResumeAll();
    1418:	0c 94 0d 12 	jmp	0x241a	; 0x241a <xTaskResumeAll>
    }
}
    141c:	df 91       	pop	r29
    141e:	cf 91       	pop	r28
    1420:	08 95       	ret

00001422 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
    1422:	fc 01       	movw	r30, r24
    /* The list structure contains a list item which is used to mark the
    end of the list.  To initialise the list the list end is inserted
    as the only list entry. */
    pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );            /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    1424:	03 96       	adiw	r24, 0x03	; 3
    1426:	92 83       	std	Z+2, r25	; 0x02
    1428:	81 83       	std	Z+1, r24	; 0x01

    /* The list end value is the highest possible value in the list to
    ensure it remains at the end of the list. */
    pxList->xListEnd.xItemValue = portMAX_DELAY;
    142a:	2f ef       	ldi	r18, 0xFF	; 255
    142c:	3f ef       	ldi	r19, 0xFF	; 255
    142e:	34 83       	std	Z+4, r19	; 0x04
    1430:	23 83       	std	Z+3, r18	; 0x03

    /* The list end next and previous pointers point to itself so we know
    when the list is empty. */
    pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );    /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    1432:	96 83       	std	Z+6, r25	; 0x06
    1434:	85 83       	std	Z+5, r24	; 0x05
    pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    1436:	90 87       	std	Z+8, r25	; 0x08
    1438:	87 83       	std	Z+7, r24	; 0x07

    pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
    143a:	10 82       	st	Z, r1
    143c:	08 95       	ret

0000143e <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
    /* Make sure the list item is not recorded as being on a list. */
    pxItem->pxContainer = NULL;
    143e:	fc 01       	movw	r30, r24
    1440:	11 86       	std	Z+9, r1	; 0x09
    1442:	10 86       	std	Z+8, r1	; 0x08
    1444:	08 95       	ret

00001446 <vListInsertEnd>:
    listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    1446:	cf 93       	push	r28
    1448:	df 93       	push	r29
    144a:	9c 01       	movw	r18, r24
    144c:	fb 01       	movw	r30, r22
ListItem_t * const pxIndex = pxList->pxIndex;
    144e:	dc 01       	movw	r26, r24
    1450:	11 96       	adiw	r26, 0x01	; 1
    1452:	cd 91       	ld	r28, X+
    1454:	dc 91       	ld	r29, X
    1456:	12 97       	sbiw	r26, 0x02	; 2
    listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

    /* Insert a new list item into pxList, but rather than sort the list,
    makes the new list item the last item to be removed by a call to
    listGET_OWNER_OF_NEXT_ENTRY(). */
    pxNewListItem->pxNext = pxIndex;
    1458:	d3 83       	std	Z+3, r29	; 0x03
    145a:	c2 83       	std	Z+2, r28	; 0x02
    pxNewListItem->pxPrevious = pxIndex->pxPrevious;
    145c:	8c 81       	ldd	r24, Y+4	; 0x04
    145e:	9d 81       	ldd	r25, Y+5	; 0x05
    1460:	95 83       	std	Z+5, r25	; 0x05
    1462:	84 83       	std	Z+4, r24	; 0x04

    /* Only used during decision coverage testing. */
    mtCOVERAGE_TEST_DELAY();

    pxIndex->pxPrevious->pxNext = pxNewListItem;
    1464:	8c 81       	ldd	r24, Y+4	; 0x04
    1466:	9d 81       	ldd	r25, Y+5	; 0x05
    1468:	dc 01       	movw	r26, r24
    146a:	13 96       	adiw	r26, 0x03	; 3
    146c:	7c 93       	st	X, r23
    146e:	6e 93       	st	-X, r22
    1470:	12 97       	sbiw	r26, 0x02	; 2
    pxIndex->pxPrevious = pxNewListItem;
    1472:	7d 83       	std	Y+5, r23	; 0x05
    1474:	6c 83       	std	Y+4, r22	; 0x04

    /* Remember which list the item is in. */
    pxNewListItem->pxContainer = pxList;
    1476:	31 87       	std	Z+9, r19	; 0x09
    1478:	20 87       	std	Z+8, r18	; 0x08

    ( pxList->uxNumberOfItems )++;
    147a:	f9 01       	movw	r30, r18
    147c:	80 81       	ld	r24, Z
    147e:	8f 5f       	subi	r24, 0xFF	; 255
    1480:	80 83       	st	Z, r24
}
    1482:	df 91       	pop	r29
    1484:	cf 91       	pop	r28
    1486:	08 95       	ret

00001488 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    1488:	0f 93       	push	r16
    148a:	1f 93       	push	r17
    148c:	cf 93       	push	r28
    148e:	df 93       	push	r29
    1490:	8c 01       	movw	r16, r24
    1492:	fb 01       	movw	r30, r22
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
    1494:	80 81       	ld	r24, Z
    1496:	91 81       	ldd	r25, Z+1	; 0x01
    new list item should be placed after it.  This ensures that TCBs which are
    stored in ready lists (all of which have the same xItemValue value) get a
    share of the CPU.  However, if the xItemValue is the same as the back marker
    the iteration loop below will not end.  Therefore the value is checked
    first, and the algorithm slightly modified if necessary. */
    if( xValueOfInsertion == portMAX_DELAY )
    1498:	8f 3f       	cpi	r24, 0xFF	; 255
    149a:	2f ef       	ldi	r18, 0xFF	; 255
    149c:	92 07       	cpc	r25, r18
    149e:	21 f4       	brne	.+8      	; 0x14a8 <vListInsert+0x20>
    {
        pxIterator = pxList->xListEnd.pxPrevious;
    14a0:	e8 01       	movw	r28, r16
    14a2:	af 81       	ldd	r26, Y+7	; 0x07
    14a4:	b8 85       	ldd	r27, Y+8	; 0x08
    14a6:	0e c0       	rjmp	.+28     	; 0x14c4 <vListInsert+0x3c>
            4) Using a queue or semaphore before it has been initialised or
               before the scheduler has been started (are interrupts firing
               before vTaskStartScheduler() has been called?).
        **********************************************************************/

        for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. *//*lint !e440 The iterator moves to a different value, not xValueOfInsertion. */
    14a8:	d8 01       	movw	r26, r16
    14aa:	13 96       	adiw	r26, 0x03	; 3
    14ac:	12 96       	adiw	r26, 0x02	; 2
    14ae:	2d 91       	ld	r18, X+
    14b0:	3c 91       	ld	r19, X
    14b2:	13 97       	sbiw	r26, 0x03	; 3
    14b4:	e9 01       	movw	r28, r18
    14b6:	48 81       	ld	r20, Y
    14b8:	59 81       	ldd	r21, Y+1	; 0x01
    14ba:	84 17       	cp	r24, r20
    14bc:	95 07       	cpc	r25, r21
    14be:	10 f0       	brcs	.+4      	; 0x14c4 <vListInsert+0x3c>
    14c0:	d9 01       	movw	r26, r18
    14c2:	f4 cf       	rjmp	.-24     	; 0x14ac <vListInsert+0x24>
            /* There is nothing to do here, just iterating to the wanted
            insertion position. */
        }
    }

    pxNewListItem->pxNext = pxIterator->pxNext;
    14c4:	12 96       	adiw	r26, 0x02	; 2
    14c6:	8d 91       	ld	r24, X+
    14c8:	9c 91       	ld	r25, X
    14ca:	13 97       	sbiw	r26, 0x03	; 3
    14cc:	93 83       	std	Z+3, r25	; 0x03
    14ce:	82 83       	std	Z+2, r24	; 0x02
    pxNewListItem->pxNext->pxPrevious = pxNewListItem;
    14d0:	ec 01       	movw	r28, r24
    14d2:	fd 83       	std	Y+5, r31	; 0x05
    14d4:	ec 83       	std	Y+4, r30	; 0x04
    pxNewListItem->pxPrevious = pxIterator;
    14d6:	b5 83       	std	Z+5, r27	; 0x05
    14d8:	a4 83       	std	Z+4, r26	; 0x04
    pxIterator->pxNext = pxNewListItem;
    14da:	13 96       	adiw	r26, 0x03	; 3
    14dc:	fc 93       	st	X, r31
    14de:	ee 93       	st	-X, r30
    14e0:	12 97       	sbiw	r26, 0x02	; 2

    /* Remember which list the item is in.  This allows fast removal of the
    item later. */
    pxNewListItem->pxContainer = pxList;
    14e2:	11 87       	std	Z+9, r17	; 0x09
    14e4:	00 87       	std	Z+8, r16	; 0x08

    ( pxList->uxNumberOfItems )++;
    14e6:	f8 01       	movw	r30, r16
    14e8:	80 81       	ld	r24, Z
    14ea:	8f 5f       	subi	r24, 0xFF	; 255
    14ec:	80 83       	st	Z, r24
}
    14ee:	df 91       	pop	r29
    14f0:	cf 91       	pop	r28
    14f2:	1f 91       	pop	r17
    14f4:	0f 91       	pop	r16
    14f6:	08 95       	ret

000014f8 <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
    14f8:	cf 93       	push	r28
    14fa:	df 93       	push	r29
    14fc:	fc 01       	movw	r30, r24
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = pxItemToRemove->pxContainer;
    14fe:	a0 85       	ldd	r26, Z+8	; 0x08
    1500:	b1 85       	ldd	r27, Z+9	; 0x09

    pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    1502:	82 81       	ldd	r24, Z+2	; 0x02
    1504:	93 81       	ldd	r25, Z+3	; 0x03
    1506:	24 81       	ldd	r18, Z+4	; 0x04
    1508:	35 81       	ldd	r19, Z+5	; 0x05
    150a:	ec 01       	movw	r28, r24
    150c:	3d 83       	std	Y+5, r19	; 0x05
    150e:	2c 83       	std	Y+4, r18	; 0x04
    pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    1510:	c4 81       	ldd	r28, Z+4	; 0x04
    1512:	d5 81       	ldd	r29, Z+5	; 0x05
    1514:	9b 83       	std	Y+3, r25	; 0x03
    1516:	8a 83       	std	Y+2, r24	; 0x02

    /* Only used during decision coverage testing. */
    mtCOVERAGE_TEST_DELAY();

    /* Make sure the index is left pointing to a valid item. */
    if( pxList->pxIndex == pxItemToRemove )
    1518:	11 96       	adiw	r26, 0x01	; 1
    151a:	8d 91       	ld	r24, X+
    151c:	9c 91       	ld	r25, X
    151e:	12 97       	sbiw	r26, 0x02	; 2
    1520:	e8 17       	cp	r30, r24
    1522:	f9 07       	cpc	r31, r25
    1524:	21 f4       	brne	.+8      	; 0x152e <uxListRemove+0x36>
    {
        pxList->pxIndex = pxItemToRemove->pxPrevious;
    1526:	12 96       	adiw	r26, 0x02	; 2
    1528:	dc 93       	st	X, r29
    152a:	ce 93       	st	-X, r28
    152c:	11 97       	sbiw	r26, 0x01	; 1
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }

    pxItemToRemove->pxContainer = NULL;
    152e:	11 86       	std	Z+9, r1	; 0x09
    1530:	10 86       	std	Z+8, r1	; 0x08
    ( pxList->uxNumberOfItems )--;
    1532:	8c 91       	ld	r24, X
    1534:	81 50       	subi	r24, 0x01	; 1
    1536:	8c 93       	st	X, r24

    return pxList->uxNumberOfItems;
    1538:	8c 91       	ld	r24, X
}
    153a:	df 91       	pop	r29
    153c:	cf 91       	pop	r28
    153e:	08 95       	ret

00001540 <pxPortInitialiseStack>:
		);
	}
	else
	{
        uint8_t register temp_reg;
		__asm__ __volatile__ (
    1540:	31 e1       	ldi	r19, 0x11	; 17
    1542:	fc 01       	movw	r30, r24
    1544:	30 83       	st	Z, r19
    1546:	31 97       	sbiw	r30, 0x01	; 1
    1548:	22 e2       	ldi	r18, 0x22	; 34
    154a:	20 83       	st	Z, r18
    154c:	31 97       	sbiw	r30, 0x01	; 1
    154e:	a3 e3       	ldi	r26, 0x33	; 51
    1550:	a0 83       	st	Z, r26
    1552:	31 97       	sbiw	r30, 0x01	; 1
    1554:	60 83       	st	Z, r22
    1556:	31 97       	sbiw	r30, 0x01	; 1
    1558:	70 83       	st	Z, r23
    155a:	31 97       	sbiw	r30, 0x01	; 1
    155c:	10 82       	st	Z, r1
    155e:	31 97       	sbiw	r30, 0x01	; 1
    1560:	60 e8       	ldi	r22, 0x80	; 128
    1562:	60 83       	st	Z, r22
    1564:	31 97       	sbiw	r30, 0x01	; 1
    1566:	10 82       	st	Z, r1
    1568:	31 97       	sbiw	r30, 0x01	; 1
    156a:	62 e0       	ldi	r22, 0x02	; 2
    156c:	60 83       	st	Z, r22
    156e:	31 97       	sbiw	r30, 0x01	; 1
    1570:	63 e0       	ldi	r22, 0x03	; 3
    1572:	60 83       	st	Z, r22
    1574:	31 97       	sbiw	r30, 0x01	; 1
    1576:	64 e0       	ldi	r22, 0x04	; 4
    1578:	60 83       	st	Z, r22
    157a:	31 97       	sbiw	r30, 0x01	; 1
    157c:	65 e0       	ldi	r22, 0x05	; 5
    157e:	60 83       	st	Z, r22
    1580:	31 97       	sbiw	r30, 0x01	; 1
    1582:	66 e0       	ldi	r22, 0x06	; 6
    1584:	60 83       	st	Z, r22
    1586:	31 97       	sbiw	r30, 0x01	; 1
    1588:	67 e0       	ldi	r22, 0x07	; 7
    158a:	60 83       	st	Z, r22
    158c:	31 97       	sbiw	r30, 0x01	; 1
    158e:	68 e0       	ldi	r22, 0x08	; 8
    1590:	60 83       	st	Z, r22
    1592:	31 97       	sbiw	r30, 0x01	; 1
    1594:	69 e0       	ldi	r22, 0x09	; 9
    1596:	60 83       	st	Z, r22
    1598:	31 97       	sbiw	r30, 0x01	; 1
    159a:	60 e1       	ldi	r22, 0x10	; 16
    159c:	60 83       	st	Z, r22
    159e:	31 97       	sbiw	r30, 0x01	; 1
    15a0:	30 83       	st	Z, r19
    15a2:	31 97       	sbiw	r30, 0x01	; 1
    15a4:	32 e1       	ldi	r19, 0x12	; 18
    15a6:	30 83       	st	Z, r19
    15a8:	31 97       	sbiw	r30, 0x01	; 1
    15aa:	33 e1       	ldi	r19, 0x13	; 19
    15ac:	30 83       	st	Z, r19
    15ae:	31 97       	sbiw	r30, 0x01	; 1
    15b0:	34 e1       	ldi	r19, 0x14	; 20
    15b2:	30 83       	st	Z, r19
    15b4:	31 97       	sbiw	r30, 0x01	; 1
    15b6:	35 e1       	ldi	r19, 0x15	; 21
    15b8:	30 83       	st	Z, r19
    15ba:	31 97       	sbiw	r30, 0x01	; 1
    15bc:	36 e1       	ldi	r19, 0x16	; 22
    15be:	30 83       	st	Z, r19
    15c0:	31 97       	sbiw	r30, 0x01	; 1
    15c2:	37 e1       	ldi	r19, 0x17	; 23
    15c4:	30 83       	st	Z, r19
    15c6:	31 97       	sbiw	r30, 0x01	; 1
    15c8:	38 e1       	ldi	r19, 0x18	; 24
    15ca:	30 83       	st	Z, r19
    15cc:	31 97       	sbiw	r30, 0x01	; 1
    15ce:	39 e1       	ldi	r19, 0x19	; 25
    15d0:	30 83       	st	Z, r19
    15d2:	31 97       	sbiw	r30, 0x01	; 1
    15d4:	30 e2       	ldi	r19, 0x20	; 32
    15d6:	30 83       	st	Z, r19
    15d8:	31 97       	sbiw	r30, 0x01	; 1
    15da:	31 e2       	ldi	r19, 0x21	; 33
    15dc:	30 83       	st	Z, r19
    15de:	31 97       	sbiw	r30, 0x01	; 1
    15e0:	20 83       	st	Z, r18
    15e2:	31 97       	sbiw	r30, 0x01	; 1
    15e4:	23 e2       	ldi	r18, 0x23	; 35
    15e6:	20 83       	st	Z, r18
    15e8:	31 97       	sbiw	r30, 0x01	; 1
    15ea:	40 83       	st	Z, r20
    15ec:	31 97       	sbiw	r30, 0x01	; 1
    15ee:	50 83       	st	Z, r21
    15f0:	31 97       	sbiw	r30, 0x01	; 1
    15f2:	26 e2       	ldi	r18, 0x26	; 38
    15f4:	20 83       	st	Z, r18
    15f6:	31 97       	sbiw	r30, 0x01	; 1
    15f8:	27 e2       	ldi	r18, 0x27	; 39
    15fa:	20 83       	st	Z, r18
    15fc:	31 97       	sbiw	r30, 0x01	; 1
    15fe:	28 e2       	ldi	r18, 0x28	; 40
    1600:	20 83       	st	Z, r18
    1602:	31 97       	sbiw	r30, 0x01	; 1
    1604:	29 e2       	ldi	r18, 0x29	; 41
    1606:	20 83       	st	Z, r18
    1608:	31 97       	sbiw	r30, 0x01	; 1
    160a:	20 e3       	ldi	r18, 0x30	; 48
    160c:	20 83       	st	Z, r18
    160e:	31 97       	sbiw	r30, 0x01	; 1
    1610:	21 e3       	ldi	r18, 0x31	; 49
    1612:	20 83       	st	Z, r18
    1614:	86 97       	sbiw	r24, 0x26	; 38
    1616:	08 95       	ret

00001618 <xPortStartScheduler>:
    1618:	a8 95       	wdr
    161a:	90 ec       	ldi	r25, 0xC0	; 192
    161c:	88 e1       	ldi	r24, 0x18	; 24
    161e:	0f b6       	in	r0, 0x3f	; 63
    1620:	f8 94       	cli
    1622:	a8 95       	wdr
    1624:	80 93 60 00 	sts	0x0060, r24	; 0x800060 <__DATA_REGION_ORIGIN__>
    1628:	0f be       	out	0x3f, r0	; 63
    162a:	90 93 60 00 	sts	0x0060, r25	; 0x800060 <__DATA_REGION_ORIGIN__>
    162e:	a0 91 f1 03 	lds	r26, 0x03F1	; 0x8003f1 <pxCurrentTCB>
    1632:	b0 91 f2 03 	lds	r27, 0x03F2	; 0x8003f2 <pxCurrentTCB+0x1>
    1636:	cd 91       	ld	r28, X+
    1638:	cd bf       	out	0x3d, r28	; 61
    163a:	dd 91       	ld	r29, X+
    163c:	de bf       	out	0x3e, r29	; 62
    163e:	ff 91       	pop	r31
    1640:	ef 91       	pop	r30
    1642:	df 91       	pop	r29
    1644:	cf 91       	pop	r28
    1646:	bf 91       	pop	r27
    1648:	af 91       	pop	r26
    164a:	9f 91       	pop	r25
    164c:	8f 91       	pop	r24
    164e:	7f 91       	pop	r23
    1650:	6f 91       	pop	r22
    1652:	5f 91       	pop	r21
    1654:	4f 91       	pop	r20
    1656:	3f 91       	pop	r19
    1658:	2f 91       	pop	r18
    165a:	1f 91       	pop	r17
    165c:	0f 91       	pop	r16
    165e:	ff 90       	pop	r15
    1660:	ef 90       	pop	r14
    1662:	df 90       	pop	r13
    1664:	cf 90       	pop	r12
    1666:	bf 90       	pop	r11
    1668:	af 90       	pop	r10
    166a:	9f 90       	pop	r9
    166c:	8f 90       	pop	r8
    166e:	7f 90       	pop	r7
    1670:	6f 90       	pop	r6
    1672:	5f 90       	pop	r5
    1674:	4f 90       	pop	r4
    1676:	3f 90       	pop	r3
    1678:	2f 90       	pop	r2
    167a:	1f 90       	pop	r1
    167c:	0f 90       	pop	r0
    167e:	0f be       	out	0x3f, r0	; 63
    1680:	0f 90       	pop	r0
    1682:	08 95       	ret
    1684:	81 e0       	ldi	r24, 0x01	; 1
    1686:	08 95       	ret

00001688 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( hot, flatten, naked ) );
void vPortYield( void )
{
    portSAVE_CONTEXT();
    1688:	0f 92       	push	r0
    168a:	0f b6       	in	r0, 0x3f	; 63
    168c:	f8 94       	cli
    168e:	0f 92       	push	r0
    1690:	1f 92       	push	r1
    1692:	11 24       	eor	r1, r1
    1694:	2f 92       	push	r2
    1696:	3f 92       	push	r3
    1698:	4f 92       	push	r4
    169a:	5f 92       	push	r5
    169c:	6f 92       	push	r6
    169e:	7f 92       	push	r7
    16a0:	8f 92       	push	r8
    16a2:	9f 92       	push	r9
    16a4:	af 92       	push	r10
    16a6:	bf 92       	push	r11
    16a8:	cf 92       	push	r12
    16aa:	df 92       	push	r13
    16ac:	ef 92       	push	r14
    16ae:	ff 92       	push	r15
    16b0:	0f 93       	push	r16
    16b2:	1f 93       	push	r17
    16b4:	2f 93       	push	r18
    16b6:	3f 93       	push	r19
    16b8:	4f 93       	push	r20
    16ba:	5f 93       	push	r21
    16bc:	6f 93       	push	r22
    16be:	7f 93       	push	r23
    16c0:	8f 93       	push	r24
    16c2:	9f 93       	push	r25
    16c4:	af 93       	push	r26
    16c6:	bf 93       	push	r27
    16c8:	cf 93       	push	r28
    16ca:	df 93       	push	r29
    16cc:	ef 93       	push	r30
    16ce:	ff 93       	push	r31
    16d0:	a0 91 f1 03 	lds	r26, 0x03F1	; 0x8003f1 <pxCurrentTCB>
    16d4:	b0 91 f2 03 	lds	r27, 0x03F2	; 0x8003f2 <pxCurrentTCB+0x1>
    16d8:	0d b6       	in	r0, 0x3d	; 61
    16da:	0d 92       	st	X+, r0
    16dc:	0e b6       	in	r0, 0x3e	; 62
    16de:	0d 92       	st	X+, r0
    vTaskSwitchContext();
    16e0:	0e 94 c9 12 	call	0x2592	; 0x2592 <vTaskSwitchContext>
    portRESTORE_CONTEXT();
    16e4:	a0 91 f1 03 	lds	r26, 0x03F1	; 0x8003f1 <pxCurrentTCB>
    16e8:	b0 91 f2 03 	lds	r27, 0x03F2	; 0x8003f2 <pxCurrentTCB+0x1>
    16ec:	cd 91       	ld	r28, X+
    16ee:	cd bf       	out	0x3d, r28	; 61
    16f0:	dd 91       	ld	r29, X+
    16f2:	de bf       	out	0x3e, r29	; 62
    16f4:	ff 91       	pop	r31
    16f6:	ef 91       	pop	r30
    16f8:	df 91       	pop	r29
    16fa:	cf 91       	pop	r28
    16fc:	bf 91       	pop	r27
    16fe:	af 91       	pop	r26
    1700:	9f 91       	pop	r25
    1702:	8f 91       	pop	r24
    1704:	7f 91       	pop	r23
    1706:	6f 91       	pop	r22
    1708:	5f 91       	pop	r21
    170a:	4f 91       	pop	r20
    170c:	3f 91       	pop	r19
    170e:	2f 91       	pop	r18
    1710:	1f 91       	pop	r17
    1712:	0f 91       	pop	r16
    1714:	ff 90       	pop	r15
    1716:	ef 90       	pop	r14
    1718:	df 90       	pop	r13
    171a:	cf 90       	pop	r12
    171c:	bf 90       	pop	r11
    171e:	af 90       	pop	r10
    1720:	9f 90       	pop	r9
    1722:	8f 90       	pop	r8
    1724:	7f 90       	pop	r7
    1726:	6f 90       	pop	r6
    1728:	5f 90       	pop	r5
    172a:	4f 90       	pop	r4
    172c:	3f 90       	pop	r3
    172e:	2f 90       	pop	r2
    1730:	1f 90       	pop	r1
    1732:	0f 90       	pop	r0
    1734:	0f be       	out	0x3f, r0	; 63
    1736:	0f 90       	pop	r0

    __asm__ __volatile__ ( "ret" );
    1738:	08 95       	ret

0000173a <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( hot, flatten, naked ) );
void vPortYieldFromTick( void )
{
    portSAVE_CONTEXT();
    173a:	0f 92       	push	r0
    173c:	0f b6       	in	r0, 0x3f	; 63
    173e:	f8 94       	cli
    1740:	0f 92       	push	r0
    1742:	1f 92       	push	r1
    1744:	11 24       	eor	r1, r1
    1746:	2f 92       	push	r2
    1748:	3f 92       	push	r3
    174a:	4f 92       	push	r4
    174c:	5f 92       	push	r5
    174e:	6f 92       	push	r6
    1750:	7f 92       	push	r7
    1752:	8f 92       	push	r8
    1754:	9f 92       	push	r9
    1756:	af 92       	push	r10
    1758:	bf 92       	push	r11
    175a:	cf 92       	push	r12
    175c:	df 92       	push	r13
    175e:	ef 92       	push	r14
    1760:	ff 92       	push	r15
    1762:	0f 93       	push	r16
    1764:	1f 93       	push	r17
    1766:	2f 93       	push	r18
    1768:	3f 93       	push	r19
    176a:	4f 93       	push	r20
    176c:	5f 93       	push	r21
    176e:	6f 93       	push	r22
    1770:	7f 93       	push	r23
    1772:	8f 93       	push	r24
    1774:	9f 93       	push	r25
    1776:	af 93       	push	r26
    1778:	bf 93       	push	r27
    177a:	cf 93       	push	r28
    177c:	df 93       	push	r29
    177e:	ef 93       	push	r30
    1780:	ff 93       	push	r31
    1782:	a0 91 f1 03 	lds	r26, 0x03F1	; 0x8003f1 <pxCurrentTCB>
    1786:	b0 91 f2 03 	lds	r27, 0x03F2	; 0x8003f2 <pxCurrentTCB+0x1>
    178a:	0d b6       	in	r0, 0x3d	; 61
    178c:	0d 92       	st	X+, r0
    178e:	0e b6       	in	r0, 0x3e	; 62
    1790:	0d 92       	st	X+, r0

    sleep_reset();        //     reset the sleep_mode() faster than sleep_disable();
    1792:	13 be       	out	0x33, r1	; 51

    if( xTaskIncrementTick() != pdFALSE )
    1794:	0e 94 61 11 	call	0x22c2	; 0x22c2 <xTaskIncrementTick>
    1798:	81 11       	cpse	r24, r1
    {
        vTaskSwitchContext();
    179a:	0e 94 c9 12 	call	0x2592	; 0x2592 <vTaskSwitchContext>
    }

    portRESTORE_CONTEXT();
    179e:	a0 91 f1 03 	lds	r26, 0x03F1	; 0x8003f1 <pxCurrentTCB>
    17a2:	b0 91 f2 03 	lds	r27, 0x03F2	; 0x8003f2 <pxCurrentTCB+0x1>
    17a6:	cd 91       	ld	r28, X+
    17a8:	cd bf       	out	0x3d, r28	; 61
    17aa:	dd 91       	ld	r29, X+
    17ac:	de bf       	out	0x3e, r29	; 62
    17ae:	ff 91       	pop	r31
    17b0:	ef 91       	pop	r30
    17b2:	df 91       	pop	r29
    17b4:	cf 91       	pop	r28
    17b6:	bf 91       	pop	r27
    17b8:	af 91       	pop	r26
    17ba:	9f 91       	pop	r25
    17bc:	8f 91       	pop	r24
    17be:	7f 91       	pop	r23
    17c0:	6f 91       	pop	r22
    17c2:	5f 91       	pop	r21
    17c4:	4f 91       	pop	r20
    17c6:	3f 91       	pop	r19
    17c8:	2f 91       	pop	r18
    17ca:	1f 91       	pop	r17
    17cc:	0f 91       	pop	r16
    17ce:	ff 90       	pop	r15
    17d0:	ef 90       	pop	r14
    17d2:	df 90       	pop	r13
    17d4:	cf 90       	pop	r12
    17d6:	bf 90       	pop	r11
    17d8:	af 90       	pop	r10
    17da:	9f 90       	pop	r9
    17dc:	8f 90       	pop	r8
    17de:	7f 90       	pop	r7
    17e0:	6f 90       	pop	r6
    17e2:	5f 90       	pop	r5
    17e4:	4f 90       	pop	r4
    17e6:	3f 90       	pop	r3
    17e8:	2f 90       	pop	r2
    17ea:	1f 90       	pop	r1
    17ec:	0f 90       	pop	r0
    17ee:	0f be       	out	0x3f, r0	; 63
    17f0:	0f 90       	pop	r0

    __asm__ __volatile__ ( "ret" );
    17f2:	08 95       	ret

000017f4 <__vector_6>:
     */
    ISR(portSCHEDULER_ISR, ISR_NAKED) __attribute__ ((hot, flatten));
//  ISR(portSCHEDULER_ISR, ISR_NAKED ISR_NOBLOCK) __attribute__ ((hot, flatten));
    ISR(portSCHEDULER_ISR)
    {
        vPortYieldFromTick();
    17f4:	0e 94 9d 0b 	call	0x173a	; 0x173a <vPortYieldFromTick>
        __asm__ __volatile__ ( "reti" );
    17f8:	18 95       	reti

000017fa <prvIsQueueEmpty>:
    {
        xReturn = pdFALSE;
    }

    return xReturn;
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
    17fa:	0f b6       	in	r0, 0x3f	; 63
    17fc:	f8 94       	cli
    17fe:	0f 92       	push	r0
    1800:	fc 01       	movw	r30, r24
    1802:	92 8d       	ldd	r25, Z+26	; 0x1a
    1804:	0f 90       	pop	r0
    1806:	0f be       	out	0x3f, r0	; 63
    1808:	81 e0       	ldi	r24, 0x01	; 1
    180a:	91 11       	cpse	r25, r1
    180c:	80 e0       	ldi	r24, 0x00	; 0
    180e:	08 95       	ret

00001810 <prvCopyDataToQueue>:
    1810:	0f 93       	push	r16
    1812:	1f 93       	push	r17
    1814:	cf 93       	push	r28
    1816:	df 93       	push	r29
    1818:	ec 01       	movw	r28, r24
    181a:	04 2f       	mov	r16, r20
    181c:	1a 8d       	ldd	r17, Y+26	; 0x1a
    181e:	4c 8d       	ldd	r20, Y+28	; 0x1c
    1820:	41 11       	cpse	r20, r1
    1822:	0b c0       	rjmp	.+22     	; 0x183a <prvCopyDataToQueue+0x2a>
    1824:	88 81       	ld	r24, Y
    1826:	99 81       	ldd	r25, Y+1	; 0x01
    1828:	89 2b       	or	r24, r25
    182a:	e9 f5       	brne	.+122    	; 0x18a6 <prvCopyDataToQueue+0x96>
    182c:	8c 81       	ldd	r24, Y+4	; 0x04
    182e:	9d 81       	ldd	r25, Y+5	; 0x05
    1830:	0e 94 43 14 	call	0x2886	; 0x2886 <xTaskPriorityDisinherit>
    1834:	1d 82       	std	Y+5, r1	; 0x05
    1836:	1c 82       	std	Y+4, r1	; 0x04
    1838:	37 c0       	rjmp	.+110    	; 0x18a8 <prvCopyDataToQueue+0x98>
    183a:	50 e0       	ldi	r21, 0x00	; 0
    183c:	01 11       	cpse	r16, r1
    183e:	15 c0       	rjmp	.+42     	; 0x186a <prvCopyDataToQueue+0x5a>
    1840:	8a 81       	ldd	r24, Y+2	; 0x02
    1842:	9b 81       	ldd	r25, Y+3	; 0x03
    1844:	0e 94 be 25 	call	0x4b7c	; 0x4b7c <memcpy>
    1848:	2c 8d       	ldd	r18, Y+28	; 0x1c
    184a:	8a 81       	ldd	r24, Y+2	; 0x02
    184c:	9b 81       	ldd	r25, Y+3	; 0x03
    184e:	82 0f       	add	r24, r18
    1850:	91 1d       	adc	r25, r1
    1852:	9b 83       	std	Y+3, r25	; 0x03
    1854:	8a 83       	std	Y+2, r24	; 0x02
    1856:	2c 81       	ldd	r18, Y+4	; 0x04
    1858:	3d 81       	ldd	r19, Y+5	; 0x05
    185a:	82 17       	cp	r24, r18
    185c:	93 07       	cpc	r25, r19
    185e:	18 f1       	brcs	.+70     	; 0x18a6 <prvCopyDataToQueue+0x96>
    1860:	88 81       	ld	r24, Y
    1862:	99 81       	ldd	r25, Y+1	; 0x01
    1864:	9b 83       	std	Y+3, r25	; 0x03
    1866:	8a 83       	std	Y+2, r24	; 0x02
    1868:	1e c0       	rjmp	.+60     	; 0x18a6 <prvCopyDataToQueue+0x96>
    186a:	8e 81       	ldd	r24, Y+6	; 0x06
    186c:	9f 81       	ldd	r25, Y+7	; 0x07
    186e:	0e 94 be 25 	call	0x4b7c	; 0x4b7c <memcpy>
    1872:	8c 8d       	ldd	r24, Y+28	; 0x1c
    1874:	90 e0       	ldi	r25, 0x00	; 0
    1876:	91 95       	neg	r25
    1878:	81 95       	neg	r24
    187a:	91 09       	sbc	r25, r1
    187c:	2e 81       	ldd	r18, Y+6	; 0x06
    187e:	3f 81       	ldd	r19, Y+7	; 0x07
    1880:	28 0f       	add	r18, r24
    1882:	39 1f       	adc	r19, r25
    1884:	3f 83       	std	Y+7, r19	; 0x07
    1886:	2e 83       	std	Y+6, r18	; 0x06
    1888:	48 81       	ld	r20, Y
    188a:	59 81       	ldd	r21, Y+1	; 0x01
    188c:	24 17       	cp	r18, r20
    188e:	35 07       	cpc	r19, r21
    1890:	30 f4       	brcc	.+12     	; 0x189e <prvCopyDataToQueue+0x8e>
    1892:	2c 81       	ldd	r18, Y+4	; 0x04
    1894:	3d 81       	ldd	r19, Y+5	; 0x05
    1896:	82 0f       	add	r24, r18
    1898:	93 1f       	adc	r25, r19
    189a:	9f 83       	std	Y+7, r25	; 0x07
    189c:	8e 83       	std	Y+6, r24	; 0x06
    189e:	02 30       	cpi	r16, 0x02	; 2
    18a0:	11 f4       	brne	.+4      	; 0x18a6 <prvCopyDataToQueue+0x96>
    18a2:	11 11       	cpse	r17, r1
    18a4:	11 50       	subi	r17, 0x01	; 1
    18a6:	80 e0       	ldi	r24, 0x00	; 0
    18a8:	1f 5f       	subi	r17, 0xFF	; 255
    18aa:	1a 8f       	std	Y+26, r17	; 0x1a
    18ac:	df 91       	pop	r29
    18ae:	cf 91       	pop	r28
    18b0:	1f 91       	pop	r17
    18b2:	0f 91       	pop	r16
    18b4:	08 95       	ret

000018b6 <prvCopyDataFromQueue>:
    18b6:	fc 01       	movw	r30, r24
    18b8:	cb 01       	movw	r24, r22
    18ba:	44 8d       	ldd	r20, Z+28	; 0x1c
    18bc:	44 23       	and	r20, r20
    18be:	a1 f0       	breq	.+40     	; 0x18e8 <prvCopyDataFromQueue+0x32>
    18c0:	50 e0       	ldi	r21, 0x00	; 0
    18c2:	26 81       	ldd	r18, Z+6	; 0x06
    18c4:	37 81       	ldd	r19, Z+7	; 0x07
    18c6:	24 0f       	add	r18, r20
    18c8:	35 1f       	adc	r19, r21
    18ca:	37 83       	std	Z+7, r19	; 0x07
    18cc:	26 83       	std	Z+6, r18	; 0x06
    18ce:	64 81       	ldd	r22, Z+4	; 0x04
    18d0:	75 81       	ldd	r23, Z+5	; 0x05
    18d2:	26 17       	cp	r18, r22
    18d4:	37 07       	cpc	r19, r23
    18d6:	20 f0       	brcs	.+8      	; 0x18e0 <prvCopyDataFromQueue+0x2a>
    18d8:	20 81       	ld	r18, Z
    18da:	31 81       	ldd	r19, Z+1	; 0x01
    18dc:	37 83       	std	Z+7, r19	; 0x07
    18de:	26 83       	std	Z+6, r18	; 0x06
    18e0:	66 81       	ldd	r22, Z+6	; 0x06
    18e2:	77 81       	ldd	r23, Z+7	; 0x07
    18e4:	0c 94 be 25 	jmp	0x4b7c	; 0x4b7c <memcpy>
    18e8:	08 95       	ret

000018ea <prvUnlockQueue>:
    18ea:	ef 92       	push	r14
    18ec:	ff 92       	push	r15
    18ee:	1f 93       	push	r17
    18f0:	cf 93       	push	r28
    18f2:	df 93       	push	r29
    18f4:	ec 01       	movw	r28, r24
    18f6:	0f b6       	in	r0, 0x3f	; 63
    18f8:	f8 94       	cli
    18fa:	0f 92       	push	r0
    18fc:	1e 8d       	ldd	r17, Y+30	; 0x1e
    18fe:	7c 01       	movw	r14, r24
    1900:	81 e1       	ldi	r24, 0x11	; 17
    1902:	e8 0e       	add	r14, r24
    1904:	f1 1c       	adc	r15, r1
    1906:	11 16       	cp	r1, r17
    1908:	5c f4       	brge	.+22     	; 0x1920 <prvUnlockQueue+0x36>
    190a:	89 89       	ldd	r24, Y+17	; 0x11
    190c:	88 23       	and	r24, r24
    190e:	41 f0       	breq	.+16     	; 0x1920 <prvUnlockQueue+0x36>
    1910:	c7 01       	movw	r24, r14
    1912:	0e 94 50 13 	call	0x26a0	; 0x26a0 <xTaskRemoveFromEventList>
    1916:	81 11       	cpse	r24, r1
    1918:	0e 94 ce 13 	call	0x279c	; 0x279c <vTaskMissedYield>
    191c:	11 50       	subi	r17, 0x01	; 1
    191e:	f3 cf       	rjmp	.-26     	; 0x1906 <prvUnlockQueue+0x1c>
    1920:	8f ef       	ldi	r24, 0xFF	; 255
    1922:	8e 8f       	std	Y+30, r24	; 0x1e
    1924:	0f 90       	pop	r0
    1926:	0f be       	out	0x3f, r0	; 63
    1928:	0f b6       	in	r0, 0x3f	; 63
    192a:	f8 94       	cli
    192c:	0f 92       	push	r0
    192e:	1d 8d       	ldd	r17, Y+29	; 0x1d
    1930:	7e 01       	movw	r14, r28
    1932:	88 e0       	ldi	r24, 0x08	; 8
    1934:	e8 0e       	add	r14, r24
    1936:	f1 1c       	adc	r15, r1
    1938:	11 16       	cp	r1, r17
    193a:	5c f4       	brge	.+22     	; 0x1952 <prvUnlockQueue+0x68>
    193c:	88 85       	ldd	r24, Y+8	; 0x08
    193e:	88 23       	and	r24, r24
    1940:	41 f0       	breq	.+16     	; 0x1952 <prvUnlockQueue+0x68>
    1942:	c7 01       	movw	r24, r14
    1944:	0e 94 50 13 	call	0x26a0	; 0x26a0 <xTaskRemoveFromEventList>
    1948:	81 11       	cpse	r24, r1
    194a:	0e 94 ce 13 	call	0x279c	; 0x279c <vTaskMissedYield>
    194e:	11 50       	subi	r17, 0x01	; 1
    1950:	f3 cf       	rjmp	.-26     	; 0x1938 <prvUnlockQueue+0x4e>
    1952:	8f ef       	ldi	r24, 0xFF	; 255
    1954:	8d 8f       	std	Y+29, r24	; 0x1d
    1956:	0f 90       	pop	r0
    1958:	0f be       	out	0x3f, r0	; 63
    195a:	df 91       	pop	r29
    195c:	cf 91       	pop	r28
    195e:	1f 91       	pop	r17
    1960:	ff 90       	pop	r15
    1962:	ef 90       	pop	r14
    1964:	08 95       	ret

00001966 <xQueueGenericReset>:
    1966:	cf 93       	push	r28
    1968:	df 93       	push	r29
    196a:	ec 01       	movw	r28, r24
    196c:	0f b6       	in	r0, 0x3f	; 63
    196e:	f8 94       	cli
    1970:	0f 92       	push	r0
    1972:	48 81       	ld	r20, Y
    1974:	59 81       	ldd	r21, Y+1	; 0x01
    1976:	8b 8d       	ldd	r24, Y+27	; 0x1b
    1978:	7c 8d       	ldd	r23, Y+28	; 0x1c
    197a:	9a 01       	movw	r18, r20
    197c:	87 9f       	mul	r24, r23
    197e:	20 0d       	add	r18, r0
    1980:	31 1d       	adc	r19, r1
    1982:	11 24       	eor	r1, r1
    1984:	3d 83       	std	Y+5, r19	; 0x05
    1986:	2c 83       	std	Y+4, r18	; 0x04
    1988:	1a 8e       	std	Y+26, r1	; 0x1a
    198a:	5b 83       	std	Y+3, r21	; 0x03
    198c:	4a 83       	std	Y+2, r20	; 0x02
    198e:	90 e0       	ldi	r25, 0x00	; 0
    1990:	01 97       	sbiw	r24, 0x01	; 1
    1992:	78 9f       	mul	r23, r24
    1994:	90 01       	movw	r18, r0
    1996:	79 9f       	mul	r23, r25
    1998:	30 0d       	add	r19, r0
    199a:	11 24       	eor	r1, r1
    199c:	ca 01       	movw	r24, r20
    199e:	82 0f       	add	r24, r18
    19a0:	93 1f       	adc	r25, r19
    19a2:	9f 83       	std	Y+7, r25	; 0x07
    19a4:	8e 83       	std	Y+6, r24	; 0x06
    19a6:	8f ef       	ldi	r24, 0xFF	; 255
    19a8:	8d 8f       	std	Y+29, r24	; 0x1d
    19aa:	8e 8f       	std	Y+30, r24	; 0x1e
    19ac:	61 11       	cpse	r22, r1
    19ae:	0c c0       	rjmp	.+24     	; 0x19c8 <xQueueGenericReset+0x62>
    19b0:	88 85       	ldd	r24, Y+8	; 0x08
    19b2:	88 23       	and	r24, r24
    19b4:	89 f0       	breq	.+34     	; 0x19d8 <xQueueGenericReset+0x72>
    19b6:	ce 01       	movw	r24, r28
    19b8:	08 96       	adiw	r24, 0x08	; 8
    19ba:	0e 94 50 13 	call	0x26a0	; 0x26a0 <xTaskRemoveFromEventList>
    19be:	88 23       	and	r24, r24
    19c0:	59 f0       	breq	.+22     	; 0x19d8 <xQueueGenericReset+0x72>
    19c2:	0e 94 44 0b 	call	0x1688	; 0x1688 <vPortYield>
    19c6:	08 c0       	rjmp	.+16     	; 0x19d8 <xQueueGenericReset+0x72>
    19c8:	ce 01       	movw	r24, r28
    19ca:	08 96       	adiw	r24, 0x08	; 8
    19cc:	0e 94 11 0a 	call	0x1422	; 0x1422 <vListInitialise>
    19d0:	ce 01       	movw	r24, r28
    19d2:	41 96       	adiw	r24, 0x11	; 17
    19d4:	0e 94 11 0a 	call	0x1422	; 0x1422 <vListInitialise>
    19d8:	0f 90       	pop	r0
    19da:	0f be       	out	0x3f, r0	; 63
    19dc:	81 e0       	ldi	r24, 0x01	; 1
    19de:	df 91       	pop	r29
    19e0:	cf 91       	pop	r28
    19e2:	08 95       	ret

000019e4 <xQueueGenericCreate>:
    19e4:	0f 93       	push	r16
    19e6:	1f 93       	push	r17
    19e8:	cf 93       	push	r28
    19ea:	df 93       	push	r29
    19ec:	08 2f       	mov	r16, r24
    19ee:	16 2f       	mov	r17, r22
    19f0:	66 23       	and	r22, r22
    19f2:	21 f0       	breq	.+8      	; 0x19fc <xQueueGenericCreate+0x18>
    19f4:	86 9f       	mul	r24, r22
    19f6:	c0 01       	movw	r24, r0
    19f8:	11 24       	eor	r1, r1
    19fa:	02 c0       	rjmp	.+4      	; 0x1a00 <xQueueGenericCreate+0x1c>
    19fc:	80 e0       	ldi	r24, 0x00	; 0
    19fe:	90 e0       	ldi	r25, 0x00	; 0
    1a00:	4f 96       	adiw	r24, 0x1f	; 31
    1a02:	0e 94 ed 09 	call	0x13da	; 0x13da <pvPortMalloc>
    1a06:	ec 01       	movw	r28, r24
    1a08:	00 97       	sbiw	r24, 0x00	; 0
    1a0a:	71 f0       	breq	.+28     	; 0x1a28 <xQueueGenericCreate+0x44>
    1a0c:	11 11       	cpse	r17, r1
    1a0e:	03 c0       	rjmp	.+6      	; 0x1a16 <xQueueGenericCreate+0x32>
    1a10:	99 83       	std	Y+1, r25	; 0x01
    1a12:	88 83       	st	Y, r24
    1a14:	03 c0       	rjmp	.+6      	; 0x1a1c <xQueueGenericCreate+0x38>
    1a16:	4f 96       	adiw	r24, 0x1f	; 31
    1a18:	99 83       	std	Y+1, r25	; 0x01
    1a1a:	88 83       	st	Y, r24
    1a1c:	0b 8f       	std	Y+27, r16	; 0x1b
    1a1e:	1c 8f       	std	Y+28, r17	; 0x1c
    1a20:	61 e0       	ldi	r22, 0x01	; 1
    1a22:	ce 01       	movw	r24, r28
    1a24:	0e 94 b3 0c 	call	0x1966	; 0x1966 <xQueueGenericReset>
    1a28:	ce 01       	movw	r24, r28
    1a2a:	df 91       	pop	r29
    1a2c:	cf 91       	pop	r28
    1a2e:	1f 91       	pop	r17
    1a30:	0f 91       	pop	r16
    1a32:	08 95       	ret

00001a34 <xQueueGenericSend>:
    1a34:	af 92       	push	r10
    1a36:	bf 92       	push	r11
    1a38:	cf 92       	push	r12
    1a3a:	df 92       	push	r13
    1a3c:	ff 92       	push	r15
    1a3e:	0f 93       	push	r16
    1a40:	1f 93       	push	r17
    1a42:	cf 93       	push	r28
    1a44:	df 93       	push	r29
    1a46:	00 d0       	rcall	.+0      	; 0x1a48 <xQueueGenericSend+0x14>
    1a48:	00 d0       	rcall	.+0      	; 0x1a4a <xQueueGenericSend+0x16>
    1a4a:	1f 92       	push	r1
    1a4c:	cd b7       	in	r28, 0x3d	; 61
    1a4e:	de b7       	in	r29, 0x3e	; 62
    1a50:	8c 01       	movw	r16, r24
    1a52:	6b 01       	movw	r12, r22
    1a54:	5d 83       	std	Y+5, r21	; 0x05
    1a56:	4c 83       	std	Y+4, r20	; 0x04
    1a58:	f2 2e       	mov	r15, r18
    1a5a:	80 e0       	ldi	r24, 0x00	; 0
    1a5c:	58 01       	movw	r10, r16
    1a5e:	98 e0       	ldi	r25, 0x08	; 8
    1a60:	a9 0e       	add	r10, r25
    1a62:	b1 1c       	adc	r11, r1
    1a64:	0f b6       	in	r0, 0x3f	; 63
    1a66:	f8 94       	cli
    1a68:	0f 92       	push	r0
    1a6a:	f8 01       	movw	r30, r16
    1a6c:	22 8d       	ldd	r18, Z+26	; 0x1a
    1a6e:	93 8d       	ldd	r25, Z+27	; 0x1b
    1a70:	29 17       	cp	r18, r25
    1a72:	18 f0       	brcs	.+6      	; 0x1a7a <xQueueGenericSend+0x46>
    1a74:	f2 e0       	ldi	r31, 0x02	; 2
    1a76:	ff 12       	cpse	r15, r31
    1a78:	14 c0       	rjmp	.+40     	; 0x1aa2 <xQueueGenericSend+0x6e>
    1a7a:	4f 2d       	mov	r20, r15
    1a7c:	b6 01       	movw	r22, r12
    1a7e:	c8 01       	movw	r24, r16
    1a80:	0e 94 08 0c 	call	0x1810	; 0x1810 <prvCopyDataToQueue>
    1a84:	f8 01       	movw	r30, r16
    1a86:	91 89       	ldd	r25, Z+17	; 0x11
    1a88:	99 23       	and	r25, r25
    1a8a:	21 f0       	breq	.+8      	; 0x1a94 <xQueueGenericSend+0x60>
    1a8c:	c8 01       	movw	r24, r16
    1a8e:	41 96       	adiw	r24, 0x11	; 17
    1a90:	0e 94 50 13 	call	0x26a0	; 0x26a0 <xTaskRemoveFromEventList>
    1a94:	81 11       	cpse	r24, r1
    1a96:	0e 94 44 0b 	call	0x1688	; 0x1688 <vPortYield>
    1a9a:	0f 90       	pop	r0
    1a9c:	0f be       	out	0x3f, r0	; 63
    1a9e:	81 e0       	ldi	r24, 0x01	; 1
    1aa0:	50 c0       	rjmp	.+160    	; 0x1b42 <xQueueGenericSend+0x10e>
    1aa2:	2c 81       	ldd	r18, Y+4	; 0x04
    1aa4:	3d 81       	ldd	r19, Y+5	; 0x05
    1aa6:	23 2b       	or	r18, r19
    1aa8:	19 f4       	brne	.+6      	; 0x1ab0 <xQueueGenericSend+0x7c>
    1aaa:	0f 90       	pop	r0
    1aac:	0f be       	out	0x3f, r0	; 63
    1aae:	48 c0       	rjmp	.+144    	; 0x1b40 <xQueueGenericSend+0x10c>
    1ab0:	81 11       	cpse	r24, r1
    1ab2:	04 c0       	rjmp	.+8      	; 0x1abc <xQueueGenericSend+0x88>
    1ab4:	ce 01       	movw	r24, r28
    1ab6:	01 96       	adiw	r24, 0x01	; 1
    1ab8:	0e 94 90 13 	call	0x2720	; 0x2720 <vTaskInternalSetTimeOutState>
    1abc:	0f 90       	pop	r0
    1abe:	0f be       	out	0x3f, r0	; 63
    1ac0:	0e 94 51 11 	call	0x22a2	; 0x22a2 <vTaskSuspendAll>
    1ac4:	0f b6       	in	r0, 0x3f	; 63
    1ac6:	f8 94       	cli
    1ac8:	0f 92       	push	r0
    1aca:	f8 01       	movw	r30, r16
    1acc:	85 8d       	ldd	r24, Z+29	; 0x1d
    1ace:	8f 3f       	cpi	r24, 0xFF	; 255
    1ad0:	09 f4       	brne	.+2      	; 0x1ad4 <xQueueGenericSend+0xa0>
    1ad2:	15 8e       	std	Z+29, r1	; 0x1d
    1ad4:	f8 01       	movw	r30, r16
    1ad6:	86 8d       	ldd	r24, Z+30	; 0x1e
    1ad8:	8f 3f       	cpi	r24, 0xFF	; 255
    1ada:	09 f4       	brne	.+2      	; 0x1ade <xQueueGenericSend+0xaa>
    1adc:	16 8e       	std	Z+30, r1	; 0x1e
    1ade:	0f 90       	pop	r0
    1ae0:	0f be       	out	0x3f, r0	; 63
    1ae2:	be 01       	movw	r22, r28
    1ae4:	6c 5f       	subi	r22, 0xFC	; 252
    1ae6:	7f 4f       	sbci	r23, 0xFF	; 255
    1ae8:	ce 01       	movw	r24, r28
    1aea:	01 96       	adiw	r24, 0x01	; 1
    1aec:	0e 94 9b 13 	call	0x2736	; 0x2736 <xTaskCheckForTimeOut>
    1af0:	81 11       	cpse	r24, r1
    1af2:	21 c0       	rjmp	.+66     	; 0x1b36 <xQueueGenericSend+0x102>
    1af4:	0f b6       	in	r0, 0x3f	; 63
    1af6:	f8 94       	cli
    1af8:	0f 92       	push	r0
    1afa:	f8 01       	movw	r30, r16
    1afc:	92 8d       	ldd	r25, Z+26	; 0x1a
    1afe:	83 8d       	ldd	r24, Z+27	; 0x1b
    1b00:	0f 90       	pop	r0
    1b02:	0f be       	out	0x3f, r0	; 63
    1b04:	98 13       	cpse	r25, r24
    1b06:	11 c0       	rjmp	.+34     	; 0x1b2a <xQueueGenericSend+0xf6>
    1b08:	6c 81       	ldd	r22, Y+4	; 0x04
    1b0a:	7d 81       	ldd	r23, Y+5	; 0x05
    1b0c:	c5 01       	movw	r24, r10
    1b0e:	0e 94 27 13 	call	0x264e	; 0x264e <vTaskPlaceOnEventList>
    1b12:	c8 01       	movw	r24, r16
    1b14:	0e 94 75 0c 	call	0x18ea	; 0x18ea <prvUnlockQueue>
    1b18:	0e 94 0d 12 	call	0x241a	; 0x241a <xTaskResumeAll>
    1b1c:	88 23       	and	r24, r24
    1b1e:	11 f0       	breq	.+4      	; 0x1b24 <xQueueGenericSend+0xf0>
    1b20:	81 e0       	ldi	r24, 0x01	; 1
    1b22:	a0 cf       	rjmp	.-192    	; 0x1a64 <xQueueGenericSend+0x30>
    1b24:	0e 94 44 0b 	call	0x1688	; 0x1688 <vPortYield>
    1b28:	fb cf       	rjmp	.-10     	; 0x1b20 <xQueueGenericSend+0xec>
    1b2a:	c8 01       	movw	r24, r16
    1b2c:	0e 94 75 0c 	call	0x18ea	; 0x18ea <prvUnlockQueue>
    1b30:	0e 94 0d 12 	call	0x241a	; 0x241a <xTaskResumeAll>
    1b34:	f5 cf       	rjmp	.-22     	; 0x1b20 <xQueueGenericSend+0xec>
    1b36:	c8 01       	movw	r24, r16
    1b38:	0e 94 75 0c 	call	0x18ea	; 0x18ea <prvUnlockQueue>
    1b3c:	0e 94 0d 12 	call	0x241a	; 0x241a <xTaskResumeAll>
    1b40:	80 e0       	ldi	r24, 0x00	; 0
    1b42:	0f 90       	pop	r0
    1b44:	0f 90       	pop	r0
    1b46:	0f 90       	pop	r0
    1b48:	0f 90       	pop	r0
    1b4a:	0f 90       	pop	r0
    1b4c:	df 91       	pop	r29
    1b4e:	cf 91       	pop	r28
    1b50:	1f 91       	pop	r17
    1b52:	0f 91       	pop	r16
    1b54:	ff 90       	pop	r15
    1b56:	df 90       	pop	r13
    1b58:	cf 90       	pop	r12
    1b5a:	bf 90       	pop	r11
    1b5c:	af 90       	pop	r10
    1b5e:	08 95       	ret

00001b60 <xQueueGenericSendFromISR>:
    1b60:	ef 92       	push	r14
    1b62:	ff 92       	push	r15
    1b64:	1f 93       	push	r17
    1b66:	cf 93       	push	r28
    1b68:	df 93       	push	r29
    1b6a:	ec 01       	movw	r28, r24
    1b6c:	9a 8d       	ldd	r25, Y+26	; 0x1a
    1b6e:	8b 8d       	ldd	r24, Y+27	; 0x1b
    1b70:	98 17       	cp	r25, r24
    1b72:	10 f0       	brcs	.+4      	; 0x1b78 <xQueueGenericSendFromISR+0x18>
    1b74:	22 30       	cpi	r18, 0x02	; 2
    1b76:	e1 f4       	brne	.+56     	; 0x1bb0 <xQueueGenericSendFromISR+0x50>
    1b78:	7a 01       	movw	r14, r20
    1b7a:	1e 8d       	ldd	r17, Y+30	; 0x1e
    1b7c:	42 2f       	mov	r20, r18
    1b7e:	ce 01       	movw	r24, r28
    1b80:	0e 94 08 0c 	call	0x1810	; 0x1810 <prvCopyDataToQueue>
    1b84:	1f 3f       	cpi	r17, 0xFF	; 255
    1b86:	81 f4       	brne	.+32     	; 0x1ba8 <xQueueGenericSendFromISR+0x48>
    1b88:	89 89       	ldd	r24, Y+17	; 0x11
    1b8a:	88 23       	and	r24, r24
    1b8c:	79 f0       	breq	.+30     	; 0x1bac <xQueueGenericSendFromISR+0x4c>
    1b8e:	ce 01       	movw	r24, r28
    1b90:	41 96       	adiw	r24, 0x11	; 17
    1b92:	0e 94 50 13 	call	0x26a0	; 0x26a0 <xTaskRemoveFromEventList>
    1b96:	88 23       	and	r24, r24
    1b98:	49 f0       	breq	.+18     	; 0x1bac <xQueueGenericSendFromISR+0x4c>
    1b9a:	e1 14       	cp	r14, r1
    1b9c:	f1 04       	cpc	r15, r1
    1b9e:	31 f0       	breq	.+12     	; 0x1bac <xQueueGenericSendFromISR+0x4c>
    1ba0:	81 e0       	ldi	r24, 0x01	; 1
    1ba2:	f7 01       	movw	r30, r14
    1ba4:	80 83       	st	Z, r24
    1ba6:	05 c0       	rjmp	.+10     	; 0x1bb2 <xQueueGenericSendFromISR+0x52>
    1ba8:	1f 5f       	subi	r17, 0xFF	; 255
    1baa:	1e 8f       	std	Y+30, r17	; 0x1e
    1bac:	81 e0       	ldi	r24, 0x01	; 1
    1bae:	01 c0       	rjmp	.+2      	; 0x1bb2 <xQueueGenericSendFromISR+0x52>
    1bb0:	80 e0       	ldi	r24, 0x00	; 0
    1bb2:	df 91       	pop	r29
    1bb4:	cf 91       	pop	r28
    1bb6:	1f 91       	pop	r17
    1bb8:	ff 90       	pop	r15
    1bba:	ef 90       	pop	r14
    1bbc:	08 95       	ret

00001bbe <xQueueGiveFromISR>:
    1bbe:	cf 93       	push	r28
    1bc0:	df 93       	push	r29
    1bc2:	fc 01       	movw	r30, r24
    1bc4:	92 8d       	ldd	r25, Z+26	; 0x1a
    1bc6:	83 8d       	ldd	r24, Z+27	; 0x1b
    1bc8:	98 17       	cp	r25, r24
    1bca:	c0 f4       	brcc	.+48     	; 0x1bfc <xQueueGiveFromISR+0x3e>
    1bcc:	86 8d       	ldd	r24, Z+30	; 0x1e
    1bce:	9f 5f       	subi	r25, 0xFF	; 255
    1bd0:	92 8f       	std	Z+26, r25	; 0x1a
    1bd2:	8f 3f       	cpi	r24, 0xFF	; 255
    1bd4:	79 f4       	brne	.+30     	; 0x1bf4 <xQueueGiveFromISR+0x36>
    1bd6:	81 89       	ldd	r24, Z+17	; 0x11
    1bd8:	88 23       	and	r24, r24
    1bda:	71 f0       	breq	.+28     	; 0x1bf8 <xQueueGiveFromISR+0x3a>
    1bdc:	eb 01       	movw	r28, r22
    1bde:	cf 01       	movw	r24, r30
    1be0:	41 96       	adiw	r24, 0x11	; 17
    1be2:	0e 94 50 13 	call	0x26a0	; 0x26a0 <xTaskRemoveFromEventList>
    1be6:	88 23       	and	r24, r24
    1be8:	39 f0       	breq	.+14     	; 0x1bf8 <xQueueGiveFromISR+0x3a>
    1bea:	20 97       	sbiw	r28, 0x00	; 0
    1bec:	29 f0       	breq	.+10     	; 0x1bf8 <xQueueGiveFromISR+0x3a>
    1bee:	81 e0       	ldi	r24, 0x01	; 1
    1bf0:	88 83       	st	Y, r24
    1bf2:	05 c0       	rjmp	.+10     	; 0x1bfe <xQueueGiveFromISR+0x40>
    1bf4:	8f 5f       	subi	r24, 0xFF	; 255
    1bf6:	86 8f       	std	Z+30, r24	; 0x1e
    1bf8:	81 e0       	ldi	r24, 0x01	; 1
    1bfa:	01 c0       	rjmp	.+2      	; 0x1bfe <xQueueGiveFromISR+0x40>
    1bfc:	80 e0       	ldi	r24, 0x00	; 0
    1bfe:	df 91       	pop	r29
    1c00:	cf 91       	pop	r28
    1c02:	08 95       	ret

00001c04 <xQueueReceive>:
    1c04:	af 92       	push	r10
    1c06:	bf 92       	push	r11
    1c08:	cf 92       	push	r12
    1c0a:	df 92       	push	r13
    1c0c:	ff 92       	push	r15
    1c0e:	0f 93       	push	r16
    1c10:	1f 93       	push	r17
    1c12:	cf 93       	push	r28
    1c14:	df 93       	push	r29
    1c16:	00 d0       	rcall	.+0      	; 0x1c18 <xQueueReceive+0x14>
    1c18:	00 d0       	rcall	.+0      	; 0x1c1a <xQueueReceive+0x16>
    1c1a:	1f 92       	push	r1
    1c1c:	cd b7       	in	r28, 0x3d	; 61
    1c1e:	de b7       	in	r29, 0x3e	; 62
    1c20:	8c 01       	movw	r16, r24
    1c22:	6b 01       	movw	r12, r22
    1c24:	5d 83       	std	Y+5, r21	; 0x05
    1c26:	4c 83       	std	Y+4, r20	; 0x04
    1c28:	80 e0       	ldi	r24, 0x00	; 0
    1c2a:	58 01       	movw	r10, r16
    1c2c:	91 e1       	ldi	r25, 0x11	; 17
    1c2e:	a9 0e       	add	r10, r25
    1c30:	b1 1c       	adc	r11, r1
    1c32:	0f b6       	in	r0, 0x3f	; 63
    1c34:	f8 94       	cli
    1c36:	0f 92       	push	r0
    1c38:	f8 01       	movw	r30, r16
    1c3a:	f2 8c       	ldd	r15, Z+26	; 0x1a
    1c3c:	ff 20       	and	r15, r15
    1c3e:	a9 f0       	breq	.+42     	; 0x1c6a <xQueueReceive+0x66>
    1c40:	b6 01       	movw	r22, r12
    1c42:	c8 01       	movw	r24, r16
    1c44:	0e 94 5b 0c 	call	0x18b6	; 0x18b6 <prvCopyDataFromQueue>
    1c48:	fa 94       	dec	r15
    1c4a:	f8 01       	movw	r30, r16
    1c4c:	f2 8e       	std	Z+26, r15	; 0x1a
    1c4e:	80 85       	ldd	r24, Z+8	; 0x08
    1c50:	88 23       	and	r24, r24
    1c52:	39 f0       	breq	.+14     	; 0x1c62 <xQueueReceive+0x5e>
    1c54:	c8 01       	movw	r24, r16
    1c56:	08 96       	adiw	r24, 0x08	; 8
    1c58:	0e 94 50 13 	call	0x26a0	; 0x26a0 <xTaskRemoveFromEventList>
    1c5c:	81 11       	cpse	r24, r1
    1c5e:	0e 94 44 0b 	call	0x1688	; 0x1688 <vPortYield>
    1c62:	0f 90       	pop	r0
    1c64:	0f be       	out	0x3f, r0	; 63
    1c66:	81 e0       	ldi	r24, 0x01	; 1
    1c68:	50 c0       	rjmp	.+160    	; 0x1d0a <xQueueReceive+0x106>
    1c6a:	2c 81       	ldd	r18, Y+4	; 0x04
    1c6c:	3d 81       	ldd	r19, Y+5	; 0x05
    1c6e:	23 2b       	or	r18, r19
    1c70:	19 f4       	brne	.+6      	; 0x1c78 <xQueueReceive+0x74>
    1c72:	0f 90       	pop	r0
    1c74:	0f be       	out	0x3f, r0	; 63
    1c76:	48 c0       	rjmp	.+144    	; 0x1d08 <xQueueReceive+0x104>
    1c78:	81 11       	cpse	r24, r1
    1c7a:	04 c0       	rjmp	.+8      	; 0x1c84 <xQueueReceive+0x80>
    1c7c:	ce 01       	movw	r24, r28
    1c7e:	01 96       	adiw	r24, 0x01	; 1
    1c80:	0e 94 90 13 	call	0x2720	; 0x2720 <vTaskInternalSetTimeOutState>
    1c84:	0f 90       	pop	r0
    1c86:	0f be       	out	0x3f, r0	; 63
    1c88:	0e 94 51 11 	call	0x22a2	; 0x22a2 <vTaskSuspendAll>
    1c8c:	0f b6       	in	r0, 0x3f	; 63
    1c8e:	f8 94       	cli
    1c90:	0f 92       	push	r0
    1c92:	f8 01       	movw	r30, r16
    1c94:	85 8d       	ldd	r24, Z+29	; 0x1d
    1c96:	8f 3f       	cpi	r24, 0xFF	; 255
    1c98:	09 f4       	brne	.+2      	; 0x1c9c <xQueueReceive+0x98>
    1c9a:	15 8e       	std	Z+29, r1	; 0x1d
    1c9c:	f8 01       	movw	r30, r16
    1c9e:	86 8d       	ldd	r24, Z+30	; 0x1e
    1ca0:	8f 3f       	cpi	r24, 0xFF	; 255
    1ca2:	09 f4       	brne	.+2      	; 0x1ca6 <xQueueReceive+0xa2>
    1ca4:	16 8e       	std	Z+30, r1	; 0x1e
    1ca6:	0f 90       	pop	r0
    1ca8:	0f be       	out	0x3f, r0	; 63
    1caa:	be 01       	movw	r22, r28
    1cac:	6c 5f       	subi	r22, 0xFC	; 252
    1cae:	7f 4f       	sbci	r23, 0xFF	; 255
    1cb0:	ce 01       	movw	r24, r28
    1cb2:	01 96       	adiw	r24, 0x01	; 1
    1cb4:	0e 94 9b 13 	call	0x2736	; 0x2736 <xTaskCheckForTimeOut>
    1cb8:	81 11       	cpse	r24, r1
    1cba:	1c c0       	rjmp	.+56     	; 0x1cf4 <xQueueReceive+0xf0>
    1cbc:	c8 01       	movw	r24, r16
    1cbe:	0e 94 fd 0b 	call	0x17fa	; 0x17fa <prvIsQueueEmpty>
    1cc2:	88 23       	and	r24, r24
    1cc4:	89 f0       	breq	.+34     	; 0x1ce8 <xQueueReceive+0xe4>
    1cc6:	6c 81       	ldd	r22, Y+4	; 0x04
    1cc8:	7d 81       	ldd	r23, Y+5	; 0x05
    1cca:	c5 01       	movw	r24, r10
    1ccc:	0e 94 27 13 	call	0x264e	; 0x264e <vTaskPlaceOnEventList>
    1cd0:	c8 01       	movw	r24, r16
    1cd2:	0e 94 75 0c 	call	0x18ea	; 0x18ea <prvUnlockQueue>
    1cd6:	0e 94 0d 12 	call	0x241a	; 0x241a <xTaskResumeAll>
    1cda:	88 23       	and	r24, r24
    1cdc:	11 f0       	breq	.+4      	; 0x1ce2 <xQueueReceive+0xde>
    1cde:	81 e0       	ldi	r24, 0x01	; 1
    1ce0:	a8 cf       	rjmp	.-176    	; 0x1c32 <xQueueReceive+0x2e>
    1ce2:	0e 94 44 0b 	call	0x1688	; 0x1688 <vPortYield>
    1ce6:	fb cf       	rjmp	.-10     	; 0x1cde <xQueueReceive+0xda>
    1ce8:	c8 01       	movw	r24, r16
    1cea:	0e 94 75 0c 	call	0x18ea	; 0x18ea <prvUnlockQueue>
    1cee:	0e 94 0d 12 	call	0x241a	; 0x241a <xTaskResumeAll>
    1cf2:	f5 cf       	rjmp	.-22     	; 0x1cde <xQueueReceive+0xda>
    1cf4:	c8 01       	movw	r24, r16
    1cf6:	0e 94 75 0c 	call	0x18ea	; 0x18ea <prvUnlockQueue>
    1cfa:	0e 94 0d 12 	call	0x241a	; 0x241a <xTaskResumeAll>
    1cfe:	c8 01       	movw	r24, r16
    1d00:	0e 94 fd 0b 	call	0x17fa	; 0x17fa <prvIsQueueEmpty>
    1d04:	88 23       	and	r24, r24
    1d06:	59 f3       	breq	.-42     	; 0x1cde <xQueueReceive+0xda>
    1d08:	80 e0       	ldi	r24, 0x00	; 0
    1d0a:	0f 90       	pop	r0
    1d0c:	0f 90       	pop	r0
    1d0e:	0f 90       	pop	r0
    1d10:	0f 90       	pop	r0
    1d12:	0f 90       	pop	r0
    1d14:	df 91       	pop	r29
    1d16:	cf 91       	pop	r28
    1d18:	1f 91       	pop	r17
    1d1a:	0f 91       	pop	r16
    1d1c:	ff 90       	pop	r15
    1d1e:	df 90       	pop	r13
    1d20:	cf 90       	pop	r12
    1d22:	bf 90       	pop	r11
    1d24:	af 90       	pop	r10
    1d26:	08 95       	ret

00001d28 <xQueueSemaphoreTake>:
    1d28:	cf 92       	push	r12
    1d2a:	df 92       	push	r13
    1d2c:	ff 92       	push	r15
    1d2e:	0f 93       	push	r16
    1d30:	1f 93       	push	r17
    1d32:	cf 93       	push	r28
    1d34:	df 93       	push	r29
    1d36:	00 d0       	rcall	.+0      	; 0x1d38 <xQueueSemaphoreTake+0x10>
    1d38:	00 d0       	rcall	.+0      	; 0x1d3a <xQueueSemaphoreTake+0x12>
    1d3a:	1f 92       	push	r1
    1d3c:	cd b7       	in	r28, 0x3d	; 61
    1d3e:	de b7       	in	r29, 0x3e	; 62
    1d40:	8c 01       	movw	r16, r24
    1d42:	7d 83       	std	Y+5, r23	; 0x05
    1d44:	6c 83       	std	Y+4, r22	; 0x04
    1d46:	f1 2c       	mov	r15, r1
    1d48:	90 e0       	ldi	r25, 0x00	; 0
    1d4a:	68 01       	movw	r12, r16
    1d4c:	81 e1       	ldi	r24, 0x11	; 17
    1d4e:	c8 0e       	add	r12, r24
    1d50:	d1 1c       	adc	r13, r1
    1d52:	0f b6       	in	r0, 0x3f	; 63
    1d54:	f8 94       	cli
    1d56:	0f 92       	push	r0
    1d58:	d8 01       	movw	r26, r16
    1d5a:	5a 96       	adiw	r26, 0x1a	; 26
    1d5c:	8c 91       	ld	r24, X
    1d5e:	5a 97       	sbiw	r26, 0x1a	; 26
    1d60:	88 23       	and	r24, r24
    1d62:	e9 f0       	breq	.+58     	; 0x1d9e <xQueueSemaphoreTake+0x76>
    1d64:	81 50       	subi	r24, 0x01	; 1
    1d66:	5a 96       	adiw	r26, 0x1a	; 26
    1d68:	8c 93       	st	X, r24
    1d6a:	5a 97       	sbiw	r26, 0x1a	; 26
    1d6c:	8d 91       	ld	r24, X+
    1d6e:	9c 91       	ld	r25, X
    1d70:	89 2b       	or	r24, r25
    1d72:	29 f4       	brne	.+10     	; 0x1d7e <xQueueSemaphoreTake+0x56>
    1d74:	0e 94 c4 14 	call	0x2988	; 0x2988 <pvTaskIncrementMutexHeldCount>
    1d78:	f8 01       	movw	r30, r16
    1d7a:	95 83       	std	Z+5, r25	; 0x05
    1d7c:	84 83       	std	Z+4, r24	; 0x04
    1d7e:	d8 01       	movw	r26, r16
    1d80:	18 96       	adiw	r26, 0x08	; 8
    1d82:	8c 91       	ld	r24, X
    1d84:	88 23       	and	r24, r24
    1d86:	39 f0       	breq	.+14     	; 0x1d96 <xQueueSemaphoreTake+0x6e>
    1d88:	c8 01       	movw	r24, r16
    1d8a:	08 96       	adiw	r24, 0x08	; 8
    1d8c:	0e 94 50 13 	call	0x26a0	; 0x26a0 <xTaskRemoveFromEventList>
    1d90:	81 11       	cpse	r24, r1
    1d92:	0e 94 44 0b 	call	0x1688	; 0x1688 <vPortYield>
    1d96:	0f 90       	pop	r0
    1d98:	0f be       	out	0x3f, r0	; 63
    1d9a:	81 e0       	ldi	r24, 0x01	; 1
    1d9c:	7a c0       	rjmp	.+244    	; 0x1e92 <xQueueSemaphoreTake+0x16a>
    1d9e:	2c 81       	ldd	r18, Y+4	; 0x04
    1da0:	3d 81       	ldd	r19, Y+5	; 0x05
    1da2:	23 2b       	or	r18, r19
    1da4:	09 f4       	brne	.+2      	; 0x1da8 <xQueueSemaphoreTake+0x80>
    1da6:	72 c0       	rjmp	.+228    	; 0x1e8c <xQueueSemaphoreTake+0x164>
    1da8:	91 11       	cpse	r25, r1
    1daa:	04 c0       	rjmp	.+8      	; 0x1db4 <xQueueSemaphoreTake+0x8c>
    1dac:	ce 01       	movw	r24, r28
    1dae:	01 96       	adiw	r24, 0x01	; 1
    1db0:	0e 94 90 13 	call	0x2720	; 0x2720 <vTaskInternalSetTimeOutState>
    1db4:	0f 90       	pop	r0
    1db6:	0f be       	out	0x3f, r0	; 63
    1db8:	0e 94 51 11 	call	0x22a2	; 0x22a2 <vTaskSuspendAll>
    1dbc:	0f b6       	in	r0, 0x3f	; 63
    1dbe:	f8 94       	cli
    1dc0:	0f 92       	push	r0
    1dc2:	f8 01       	movw	r30, r16
    1dc4:	85 8d       	ldd	r24, Z+29	; 0x1d
    1dc6:	8f 3f       	cpi	r24, 0xFF	; 255
    1dc8:	09 f4       	brne	.+2      	; 0x1dcc <xQueueSemaphoreTake+0xa4>
    1dca:	15 8e       	std	Z+29, r1	; 0x1d
    1dcc:	d8 01       	movw	r26, r16
    1dce:	5e 96       	adiw	r26, 0x1e	; 30
    1dd0:	8c 91       	ld	r24, X
    1dd2:	5e 97       	sbiw	r26, 0x1e	; 30
    1dd4:	8f 3f       	cpi	r24, 0xFF	; 255
    1dd6:	11 f4       	brne	.+4      	; 0x1ddc <xQueueSemaphoreTake+0xb4>
    1dd8:	5e 96       	adiw	r26, 0x1e	; 30
    1dda:	1c 92       	st	X, r1
    1ddc:	0f 90       	pop	r0
    1dde:	0f be       	out	0x3f, r0	; 63
    1de0:	be 01       	movw	r22, r28
    1de2:	6c 5f       	subi	r22, 0xFC	; 252
    1de4:	7f 4f       	sbci	r23, 0xFF	; 255
    1de6:	ce 01       	movw	r24, r28
    1de8:	01 96       	adiw	r24, 0x01	; 1
    1dea:	0e 94 9b 13 	call	0x2736	; 0x2736 <xTaskCheckForTimeOut>
    1dee:	81 11       	cpse	r24, r1
    1df0:	2b c0       	rjmp	.+86     	; 0x1e48 <xQueueSemaphoreTake+0x120>
    1df2:	c8 01       	movw	r24, r16
    1df4:	0e 94 fd 0b 	call	0x17fa	; 0x17fa <prvIsQueueEmpty>
    1df8:	88 23       	and	r24, r24
    1dfa:	01 f1       	breq	.+64     	; 0x1e3c <xQueueSemaphoreTake+0x114>
    1dfc:	f8 01       	movw	r30, r16
    1dfe:	80 81       	ld	r24, Z
    1e00:	91 81       	ldd	r25, Z+1	; 0x01
    1e02:	89 2b       	or	r24, r25
    1e04:	51 f4       	brne	.+20     	; 0x1e1a <xQueueSemaphoreTake+0xf2>
    1e06:	0f b6       	in	r0, 0x3f	; 63
    1e08:	f8 94       	cli
    1e0a:	0f 92       	push	r0
    1e0c:	84 81       	ldd	r24, Z+4	; 0x04
    1e0e:	95 81       	ldd	r25, Z+5	; 0x05
    1e10:	0e 94 e0 13 	call	0x27c0	; 0x27c0 <xTaskPriorityInherit>
    1e14:	f8 2e       	mov	r15, r24
    1e16:	0f 90       	pop	r0
    1e18:	0f be       	out	0x3f, r0	; 63
    1e1a:	6c 81       	ldd	r22, Y+4	; 0x04
    1e1c:	7d 81       	ldd	r23, Y+5	; 0x05
    1e1e:	c6 01       	movw	r24, r12
    1e20:	0e 94 27 13 	call	0x264e	; 0x264e <vTaskPlaceOnEventList>
    1e24:	c8 01       	movw	r24, r16
    1e26:	0e 94 75 0c 	call	0x18ea	; 0x18ea <prvUnlockQueue>
    1e2a:	0e 94 0d 12 	call	0x241a	; 0x241a <xTaskResumeAll>
    1e2e:	88 23       	and	r24, r24
    1e30:	11 f0       	breq	.+4      	; 0x1e36 <xQueueSemaphoreTake+0x10e>
    1e32:	91 e0       	ldi	r25, 0x01	; 1
    1e34:	8e cf       	rjmp	.-228    	; 0x1d52 <xQueueSemaphoreTake+0x2a>
    1e36:	0e 94 44 0b 	call	0x1688	; 0x1688 <vPortYield>
    1e3a:	fb cf       	rjmp	.-10     	; 0x1e32 <xQueueSemaphoreTake+0x10a>
    1e3c:	c8 01       	movw	r24, r16
    1e3e:	0e 94 75 0c 	call	0x18ea	; 0x18ea <prvUnlockQueue>
    1e42:	0e 94 0d 12 	call	0x241a	; 0x241a <xTaskResumeAll>
    1e46:	f5 cf       	rjmp	.-22     	; 0x1e32 <xQueueSemaphoreTake+0x10a>
    1e48:	c8 01       	movw	r24, r16
    1e4a:	0e 94 75 0c 	call	0x18ea	; 0x18ea <prvUnlockQueue>
    1e4e:	0e 94 0d 12 	call	0x241a	; 0x241a <xTaskResumeAll>
    1e52:	c8 01       	movw	r24, r16
    1e54:	0e 94 fd 0b 	call	0x17fa	; 0x17fa <prvIsQueueEmpty>
    1e58:	88 23       	and	r24, r24
    1e5a:	59 f3       	breq	.-42     	; 0x1e32 <xQueueSemaphoreTake+0x10a>
    1e5c:	ff 20       	and	r15, r15
    1e5e:	c1 f0       	breq	.+48     	; 0x1e90 <xQueueSemaphoreTake+0x168>
    1e60:	0f b6       	in	r0, 0x3f	; 63
    1e62:	f8 94       	cli
    1e64:	0f 92       	push	r0
    1e66:	f8 01       	movw	r30, r16
    1e68:	81 89       	ldd	r24, Z+17	; 0x11
    1e6a:	88 23       	and	r24, r24
    1e6c:	39 f0       	breq	.+14     	; 0x1e7c <xQueueSemaphoreTake+0x154>
    1e6e:	06 88       	ldd	r0, Z+22	; 0x16
    1e70:	f7 89       	ldd	r31, Z+23	; 0x17
    1e72:	e0 2d       	mov	r30, r0
    1e74:	80 81       	ld	r24, Z
    1e76:	64 e0       	ldi	r22, 0x04	; 4
    1e78:	68 1b       	sub	r22, r24
    1e7a:	01 c0       	rjmp	.+2      	; 0x1e7e <xQueueSemaphoreTake+0x156>
    1e7c:	60 e0       	ldi	r22, 0x00	; 0
    1e7e:	d8 01       	movw	r26, r16
    1e80:	14 96       	adiw	r26, 0x04	; 4
    1e82:	8d 91       	ld	r24, X+
    1e84:	9c 91       	ld	r25, X
    1e86:	15 97       	sbiw	r26, 0x05	; 5
    1e88:	0e 94 7d 14 	call	0x28fa	; 0x28fa <vTaskPriorityDisinheritAfterTimeout>
    1e8c:	0f 90       	pop	r0
    1e8e:	0f be       	out	0x3f, r0	; 63
    1e90:	80 e0       	ldi	r24, 0x00	; 0
    1e92:	0f 90       	pop	r0
    1e94:	0f 90       	pop	r0
    1e96:	0f 90       	pop	r0
    1e98:	0f 90       	pop	r0
    1e9a:	0f 90       	pop	r0
    1e9c:	df 91       	pop	r29
    1e9e:	cf 91       	pop	r28
    1ea0:	1f 91       	pop	r17
    1ea2:	0f 91       	pop	r16
    1ea4:	ff 90       	pop	r15
    1ea6:	df 90       	pop	r13
    1ea8:	cf 90       	pop	r12
    1eaa:	08 95       	ret

00001eac <vQueueWaitForMessageRestricted>:
/*-----------------------------------------------------------*/

#if ( configUSE_TIMERS == 1 )

    void vQueueWaitForMessageRestricted( QueueHandle_t xQueue, TickType_t xTicksToWait, const BaseType_t xWaitIndefinitely )
    {
    1eac:	cf 93       	push	r28
    1eae:	df 93       	push	r29
    1eb0:	ec 01       	movw	r28, r24
        will not actually cause the task to block, just place it on a blocked
        list.  It will not block until the scheduler is unlocked - at which
        time a yield will be performed.  If an item is added to the queue while
        the queue is locked, and the calling task blocks on the queue, then the
        calling task will be immediately unblocked when the queue is unlocked. */
        prvLockQueue( pxQueue );
    1eb2:	0f b6       	in	r0, 0x3f	; 63
    1eb4:	f8 94       	cli
    1eb6:	0f 92       	push	r0
    1eb8:	8d 8d       	ldd	r24, Y+29	; 0x1d
    1eba:	8f 3f       	cpi	r24, 0xFF	; 255
    1ebc:	09 f4       	brne	.+2      	; 0x1ec0 <vQueueWaitForMessageRestricted+0x14>
    1ebe:	1d 8e       	std	Y+29, r1	; 0x1d
    1ec0:	8e 8d       	ldd	r24, Y+30	; 0x1e
    1ec2:	8f 3f       	cpi	r24, 0xFF	; 255
    1ec4:	09 f4       	brne	.+2      	; 0x1ec8 <vQueueWaitForMessageRestricted+0x1c>
    1ec6:	1e 8e       	std	Y+30, r1	; 0x1e
    1ec8:	0f 90       	pop	r0
    1eca:	0f be       	out	0x3f, r0	; 63
        if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0U )
    1ecc:	8a 8d       	ldd	r24, Y+26	; 0x1a
    1ece:	81 11       	cpse	r24, r1
    1ed0:	04 c0       	rjmp	.+8      	; 0x1eda <vQueueWaitForMessageRestricted+0x2e>
        {
            /* There is nothing in the queue, block for the specified period. */
            vTaskPlaceOnEventListRestricted( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait, xWaitIndefinitely );
    1ed2:	ce 01       	movw	r24, r28
    1ed4:	41 96       	adiw	r24, 0x11	; 17
    1ed6:	0e 94 38 13 	call	0x2670	; 0x2670 <vTaskPlaceOnEventListRestricted>
        }
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }
        prvUnlockQueue( pxQueue );
    1eda:	ce 01       	movw	r24, r28
    }
    1edc:	df 91       	pop	r29
    1ede:	cf 91       	pop	r28
        }
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }
        prvUnlockQueue( pxQueue );
    1ee0:	0c 94 75 0c 	jmp	0x18ea	; 0x18ea <prvUnlockQueue>

00001ee4 <prvResetNextTaskUnblockTime>:
    /* Reset the event list item to its normal value - so it can be used with
    queues and semaphores. */
    listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */

    return uxReturn;
}
    1ee4:	e0 91 b9 03 	lds	r30, 0x03B9	; 0x8003b9 <pxDelayedTaskList>
    1ee8:	f0 91 ba 03 	lds	r31, 0x03BA	; 0x8003ba <pxDelayedTaskList+0x1>
    1eec:	80 81       	ld	r24, Z
    1eee:	81 11       	cpse	r24, r1
    1ef0:	03 c0       	rjmp	.+6      	; 0x1ef8 <prvResetNextTaskUnblockTime+0x14>
    1ef2:	8f ef       	ldi	r24, 0xFF	; 255
    1ef4:	9f ef       	ldi	r25, 0xFF	; 255
    1ef6:	0c c0       	rjmp	.+24     	; 0x1f10 <prvResetNextTaskUnblockTime+0x2c>
    1ef8:	e0 91 b9 03 	lds	r30, 0x03B9	; 0x8003b9 <pxDelayedTaskList>
    1efc:	f0 91 ba 03 	lds	r31, 0x03BA	; 0x8003ba <pxDelayedTaskList+0x1>
    1f00:	05 80       	ldd	r0, Z+5	; 0x05
    1f02:	f6 81       	ldd	r31, Z+6	; 0x06
    1f04:	e0 2d       	mov	r30, r0
    1f06:	06 80       	ldd	r0, Z+6	; 0x06
    1f08:	f7 81       	ldd	r31, Z+7	; 0x07
    1f0a:	e0 2d       	mov	r30, r0
    1f0c:	82 81       	ldd	r24, Z+2	; 0x02
    1f0e:	93 81       	ldd	r25, Z+3	; 0x03
    1f10:	90 93 91 03 	sts	0x0391, r25	; 0x800391 <xNextTaskUnblockTime+0x1>
    1f14:	80 93 90 03 	sts	0x0390, r24	; 0x800390 <xNextTaskUnblockTime>
    1f18:	08 95       	ret

00001f1a <prvAddCurrentTaskToDelayedList>:
    1f1a:	ff 92       	push	r15
    1f1c:	0f 93       	push	r16
    1f1e:	1f 93       	push	r17
    1f20:	cf 93       	push	r28
    1f22:	df 93       	push	r29
    1f24:	ec 01       	movw	r28, r24
    1f26:	f6 2e       	mov	r15, r22
    1f28:	00 91 98 03 	lds	r16, 0x0398	; 0x800398 <xTickCount>
    1f2c:	10 91 99 03 	lds	r17, 0x0399	; 0x800399 <xTickCount+0x1>
    1f30:	80 91 f1 03 	lds	r24, 0x03F1	; 0x8003f1 <pxCurrentTCB>
    1f34:	90 91 f2 03 	lds	r25, 0x03F2	; 0x8003f2 <pxCurrentTCB+0x1>
    1f38:	02 96       	adiw	r24, 0x02	; 2
    1f3a:	0e 94 7c 0a 	call	0x14f8	; 0x14f8 <uxListRemove>
    1f3e:	cf 3f       	cpi	r28, 0xFF	; 255
    1f40:	8f ef       	ldi	r24, 0xFF	; 255
    1f42:	d8 07       	cpc	r29, r24
    1f44:	89 f4       	brne	.+34     	; 0x1f68 <prvAddCurrentTaskToDelayedList+0x4e>
    1f46:	ff 20       	and	r15, r15
    1f48:	79 f0       	breq	.+30     	; 0x1f68 <prvAddCurrentTaskToDelayedList+0x4e>
    1f4a:	60 91 f1 03 	lds	r22, 0x03F1	; 0x8003f1 <pxCurrentTCB>
    1f4e:	70 91 f2 03 	lds	r23, 0x03F2	; 0x8003f2 <pxCurrentTCB+0x1>
    1f52:	6e 5f       	subi	r22, 0xFE	; 254
    1f54:	7f 4f       	sbci	r23, 0xFF	; 255
    1f56:	8b e9       	ldi	r24, 0x9B	; 155
    1f58:	93 e0       	ldi	r25, 0x03	; 3
    1f5a:	df 91       	pop	r29
    1f5c:	cf 91       	pop	r28
    1f5e:	1f 91       	pop	r17
    1f60:	0f 91       	pop	r16
    1f62:	ff 90       	pop	r15
    1f64:	0c 94 23 0a 	jmp	0x1446	; 0x1446 <vListInsertEnd>
    1f68:	c0 0f       	add	r28, r16
    1f6a:	d1 1f       	adc	r29, r17
    1f6c:	e0 91 f1 03 	lds	r30, 0x03F1	; 0x8003f1 <pxCurrentTCB>
    1f70:	f0 91 f2 03 	lds	r31, 0x03F2	; 0x8003f2 <pxCurrentTCB+0x1>
    1f74:	d3 83       	std	Z+3, r29	; 0x03
    1f76:	c2 83       	std	Z+2, r28	; 0x02
    1f78:	60 91 f1 03 	lds	r22, 0x03F1	; 0x8003f1 <pxCurrentTCB>
    1f7c:	70 91 f2 03 	lds	r23, 0x03F2	; 0x8003f2 <pxCurrentTCB+0x1>
    1f80:	c0 17       	cp	r28, r16
    1f82:	d1 07       	cpc	r29, r17
    1f84:	68 f4       	brcc	.+26     	; 0x1fa0 <prvAddCurrentTaskToDelayedList+0x86>
    1f86:	80 91 b7 03 	lds	r24, 0x03B7	; 0x8003b7 <pxOverflowDelayedTaskList>
    1f8a:	90 91 b8 03 	lds	r25, 0x03B8	; 0x8003b8 <pxOverflowDelayedTaskList+0x1>
    1f8e:	6e 5f       	subi	r22, 0xFE	; 254
    1f90:	7f 4f       	sbci	r23, 0xFF	; 255
    1f92:	df 91       	pop	r29
    1f94:	cf 91       	pop	r28
    1f96:	1f 91       	pop	r17
    1f98:	0f 91       	pop	r16
    1f9a:	ff 90       	pop	r15
    1f9c:	0c 94 44 0a 	jmp	0x1488	; 0x1488 <vListInsert>
    1fa0:	80 91 b9 03 	lds	r24, 0x03B9	; 0x8003b9 <pxDelayedTaskList>
    1fa4:	90 91 ba 03 	lds	r25, 0x03BA	; 0x8003ba <pxDelayedTaskList+0x1>
    1fa8:	6e 5f       	subi	r22, 0xFE	; 254
    1faa:	7f 4f       	sbci	r23, 0xFF	; 255
    1fac:	0e 94 44 0a 	call	0x1488	; 0x1488 <vListInsert>
    1fb0:	80 91 90 03 	lds	r24, 0x0390	; 0x800390 <xNextTaskUnblockTime>
    1fb4:	90 91 91 03 	lds	r25, 0x0391	; 0x800391 <xNextTaskUnblockTime+0x1>
    1fb8:	c8 17       	cp	r28, r24
    1fba:	d9 07       	cpc	r29, r25
    1fbc:	20 f4       	brcc	.+8      	; 0x1fc6 <prvAddCurrentTaskToDelayedList+0xac>
    1fbe:	d0 93 91 03 	sts	0x0391, r29	; 0x800391 <xNextTaskUnblockTime+0x1>
    1fc2:	c0 93 90 03 	sts	0x0390, r28	; 0x800390 <xNextTaskUnblockTime>
    1fc6:	df 91       	pop	r29
    1fc8:	cf 91       	pop	r28
    1fca:	1f 91       	pop	r17
    1fcc:	0f 91       	pop	r16
    1fce:	ff 90       	pop	r15
    1fd0:	08 95       	ret

00001fd2 <prvIdleTask>:
    1fd2:	80 91 a4 03 	lds	r24, 0x03A4	; 0x8003a4 <uxDeletedTasksWaitingCleanUp>
    1fd6:	88 23       	and	r24, r24
    1fd8:	09 f1       	breq	.+66     	; 0x201c <prvIdleTask+0x4a>
    1fda:	0f b6       	in	r0, 0x3f	; 63
    1fdc:	f8 94       	cli
    1fde:	0f 92       	push	r0
    1fe0:	e0 91 aa 03 	lds	r30, 0x03AA	; 0x8003aa <xTasksWaitingTermination+0x5>
    1fe4:	f0 91 ab 03 	lds	r31, 0x03AB	; 0x8003ab <xTasksWaitingTermination+0x6>
    1fe8:	c6 81       	ldd	r28, Z+6	; 0x06
    1fea:	d7 81       	ldd	r29, Z+7	; 0x07
    1fec:	ce 01       	movw	r24, r28
    1fee:	02 96       	adiw	r24, 0x02	; 2
    1ff0:	0e 94 7c 0a 	call	0x14f8	; 0x14f8 <uxListRemove>
    1ff4:	80 91 9a 03 	lds	r24, 0x039A	; 0x80039a <uxCurrentNumberOfTasks>
    1ff8:	81 50       	subi	r24, 0x01	; 1
    1ffa:	80 93 9a 03 	sts	0x039A, r24	; 0x80039a <uxCurrentNumberOfTasks>
    1ffe:	80 91 a4 03 	lds	r24, 0x03A4	; 0x8003a4 <uxDeletedTasksWaitingCleanUp>
    2002:	81 50       	subi	r24, 0x01	; 1
    2004:	80 93 a4 03 	sts	0x03A4, r24	; 0x8003a4 <uxDeletedTasksWaitingCleanUp>
    2008:	0f 90       	pop	r0
    200a:	0f be       	out	0x3f, r0	; 63
    200c:	8f 89       	ldd	r24, Y+23	; 0x17
    200e:	98 8d       	ldd	r25, Y+24	; 0x18
    2010:	0e 94 00 0a 	call	0x1400	; 0x1400 <vPortFree>
    2014:	ce 01       	movw	r24, r28
    2016:	0e 94 00 0a 	call	0x1400	; 0x1400 <vPortFree>
    201a:	db cf       	rjmp	.-74     	; 0x1fd2 <prvIdleTask>
    201c:	80 91 cd 03 	lds	r24, 0x03CD	; 0x8003cd <pxReadyTasksLists>
    2020:	82 30       	cpi	r24, 0x02	; 2
    2022:	10 f0       	brcs	.+4      	; 0x2028 <prvIdleTask+0x56>
    2024:	0e 94 44 0b 	call	0x1688	; 0x1688 <vPortYield>
    2028:	0e 94 e1 16 	call	0x2dc2	; 0x2dc2 <vApplicationIdleHook>
    202c:	d2 cf       	rjmp	.-92     	; 0x1fd2 <prvIdleTask>

0000202e <xTaskCreate>:
    202e:	5f 92       	push	r5
    2030:	6f 92       	push	r6
    2032:	7f 92       	push	r7
    2034:	8f 92       	push	r8
    2036:	9f 92       	push	r9
    2038:	af 92       	push	r10
    203a:	bf 92       	push	r11
    203c:	cf 92       	push	r12
    203e:	df 92       	push	r13
    2040:	ef 92       	push	r14
    2042:	ff 92       	push	r15
    2044:	0f 93       	push	r16
    2046:	1f 93       	push	r17
    2048:	cf 93       	push	r28
    204a:	df 93       	push	r29
    204c:	3c 01       	movw	r6, r24
    204e:	6b 01       	movw	r12, r22
    2050:	5a 01       	movw	r10, r20
    2052:	49 01       	movw	r8, r18
    2054:	50 2e       	mov	r5, r16
    2056:	ca 01       	movw	r24, r20
    2058:	0e 94 ed 09 	call	0x13da	; 0x13da <pvPortMalloc>
    205c:	8c 01       	movw	r16, r24
    205e:	89 2b       	or	r24, r25
    2060:	09 f4       	brne	.+2      	; 0x2064 <xTaskCreate+0x36>
    2062:	e0 c0       	rjmp	.+448    	; 0x2224 <xTaskCreate+0x1f6>
    2064:	88 e2       	ldi	r24, 0x28	; 40
    2066:	90 e0       	ldi	r25, 0x00	; 0
    2068:	0e 94 ed 09 	call	0x13da	; 0x13da <pvPortMalloc>
    206c:	ec 01       	movw	r28, r24
    206e:	89 2b       	or	r24, r25
    2070:	c9 f0       	breq	.+50     	; 0x20a4 <xTaskCreate+0x76>
    2072:	18 8f       	std	Y+24, r17	; 0x18
    2074:	0f 8b       	std	Y+23, r16	; 0x17
    2076:	a5 01       	movw	r20, r10
    2078:	65 ea       	ldi	r22, 0xA5	; 165
    207a:	70 e0       	ldi	r23, 0x00	; 0
    207c:	c8 01       	movw	r24, r16
    207e:	0e 94 c7 25 	call	0x4b8e	; 0x4b8e <memset>
    2082:	21 e0       	ldi	r18, 0x01	; 1
    2084:	a2 1a       	sub	r10, r18
    2086:	b1 08       	sbc	r11, r1
    2088:	8f 89       	ldd	r24, Y+23	; 0x17
    208a:	98 8d       	ldd	r25, Y+24	; 0x18
    208c:	a8 0e       	add	r10, r24
    208e:	b9 1e       	adc	r11, r25
    2090:	c1 14       	cp	r12, r1
    2092:	d1 04       	cpc	r13, r1
    2094:	c9 f0       	breq	.+50     	; 0x20c8 <xTaskCreate+0x9a>
    2096:	be 01       	movw	r22, r28
    2098:	67 5e       	subi	r22, 0xE7	; 231
    209a:	7f 4f       	sbci	r23, 0xFF	; 255
    209c:	f6 01       	movw	r30, r12
    209e:	c6 01       	movw	r24, r12
    20a0:	08 96       	adiw	r24, 0x08	; 8
    20a2:	07 c0       	rjmp	.+14     	; 0x20b2 <xTaskCreate+0x84>
    20a4:	c8 01       	movw	r24, r16
    20a6:	0e 94 00 0a 	call	0x1400	; 0x1400 <vPortFree>
    20aa:	bc c0       	rjmp	.+376    	; 0x2224 <xTaskCreate+0x1f6>
    20ac:	e8 17       	cp	r30, r24
    20ae:	f9 07       	cpc	r31, r25
    20b0:	49 f0       	breq	.+18     	; 0x20c4 <xTaskCreate+0x96>
    20b2:	9f 01       	movw	r18, r30
    20b4:	41 91       	ld	r20, Z+
    20b6:	db 01       	movw	r26, r22
    20b8:	4d 93       	st	X+, r20
    20ba:	bd 01       	movw	r22, r26
    20bc:	d9 01       	movw	r26, r18
    20be:	2c 91       	ld	r18, X
    20c0:	21 11       	cpse	r18, r1
    20c2:	f4 cf       	rjmp	.-24     	; 0x20ac <xTaskCreate+0x7e>
    20c4:	18 a2       	std	Y+32, r1	; 0x20
    20c6:	01 c0       	rjmp	.+2      	; 0x20ca <xTaskCreate+0x9c>
    20c8:	19 8e       	std	Y+25, r1	; 0x19
    20ca:	05 2d       	mov	r16, r5
    20cc:	04 30       	cpi	r16, 0x04	; 4
    20ce:	08 f0       	brcs	.+2      	; 0x20d2 <xTaskCreate+0xa4>
    20d0:	03 e0       	ldi	r16, 0x03	; 3
    20d2:	0e 8b       	std	Y+22, r16	; 0x16
    20d4:	09 a3       	std	Y+33, r16	; 0x21
    20d6:	1a a2       	std	Y+34, r1	; 0x22
    20d8:	6e 01       	movw	r12, r28
    20da:	b2 e0       	ldi	r27, 0x02	; 2
    20dc:	cb 0e       	add	r12, r27
    20de:	d1 1c       	adc	r13, r1
    20e0:	c6 01       	movw	r24, r12
    20e2:	0e 94 1f 0a 	call	0x143e	; 0x143e <vListInitialiseItem>
    20e6:	ce 01       	movw	r24, r28
    20e8:	0c 96       	adiw	r24, 0x0c	; 12
    20ea:	0e 94 1f 0a 	call	0x143e	; 0x143e <vListInitialiseItem>
    20ee:	d9 87       	std	Y+9, r29	; 0x09
    20f0:	c8 87       	std	Y+8, r28	; 0x08
    20f2:	84 e0       	ldi	r24, 0x04	; 4
    20f4:	90 e0       	ldi	r25, 0x00	; 0
    20f6:	80 1b       	sub	r24, r16
    20f8:	91 09       	sbc	r25, r1
    20fa:	9d 87       	std	Y+13, r25	; 0x0d
    20fc:	8c 87       	std	Y+12, r24	; 0x0c
    20fe:	db 8b       	std	Y+19, r29	; 0x13
    2100:	ca 8b       	std	Y+18, r28	; 0x12
    2102:	1b a2       	std	Y+35, r1	; 0x23
    2104:	1c a2       	std	Y+36, r1	; 0x24
    2106:	1d a2       	std	Y+37, r1	; 0x25
    2108:	1e a2       	std	Y+38, r1	; 0x26
    210a:	1f a2       	std	Y+39, r1	; 0x27
    210c:	a4 01       	movw	r20, r8
    210e:	b3 01       	movw	r22, r6
    2110:	c5 01       	movw	r24, r10
    2112:	0e 94 a0 0a 	call	0x1540	; 0x1540 <pxPortInitialiseStack>
    2116:	99 83       	std	Y+1, r25	; 0x01
    2118:	88 83       	st	Y, r24
    211a:	e1 14       	cp	r14, r1
    211c:	f1 04       	cpc	r15, r1
    211e:	19 f0       	breq	.+6      	; 0x2126 <xTaskCreate+0xf8>
    2120:	f7 01       	movw	r30, r14
    2122:	d1 83       	std	Z+1, r29	; 0x01
    2124:	c0 83       	st	Z, r28
    2126:	0f b6       	in	r0, 0x3f	; 63
    2128:	f8 94       	cli
    212a:	0f 92       	push	r0
    212c:	80 91 9a 03 	lds	r24, 0x039A	; 0x80039a <uxCurrentNumberOfTasks>
    2130:	8f 5f       	subi	r24, 0xFF	; 255
    2132:	80 93 9a 03 	sts	0x039A, r24	; 0x80039a <uxCurrentNumberOfTasks>
    2136:	80 91 f1 03 	lds	r24, 0x03F1	; 0x8003f1 <pxCurrentTCB>
    213a:	90 91 f2 03 	lds	r25, 0x03F2	; 0x8003f2 <pxCurrentTCB+0x1>
    213e:	89 2b       	or	r24, r25
    2140:	d1 f5       	brne	.+116    	; 0x21b6 <xTaskCreate+0x188>
    2142:	d0 93 f2 03 	sts	0x03F2, r29	; 0x8003f2 <pxCurrentTCB+0x1>
    2146:	c0 93 f1 03 	sts	0x03F1, r28	; 0x8003f1 <pxCurrentTCB>
    214a:	80 91 9a 03 	lds	r24, 0x039A	; 0x80039a <uxCurrentNumberOfTasks>
    214e:	81 30       	cpi	r24, 0x01	; 1
    2150:	09 f0       	breq	.+2      	; 0x2154 <xTaskCreate+0x126>
    2152:	41 c0       	rjmp	.+130    	; 0x21d6 <xTaskCreate+0x1a8>
    2154:	8d ec       	ldi	r24, 0xCD	; 205
    2156:	93 e0       	ldi	r25, 0x03	; 3
    2158:	0e 94 11 0a 	call	0x1422	; 0x1422 <vListInitialise>
    215c:	86 ed       	ldi	r24, 0xD6	; 214
    215e:	93 e0       	ldi	r25, 0x03	; 3
    2160:	0e 94 11 0a 	call	0x1422	; 0x1422 <vListInitialise>
    2164:	8f ed       	ldi	r24, 0xDF	; 223
    2166:	93 e0       	ldi	r25, 0x03	; 3
    2168:	0e 94 11 0a 	call	0x1422	; 0x1422 <vListInitialise>
    216c:	88 ee       	ldi	r24, 0xE8	; 232
    216e:	93 e0       	ldi	r25, 0x03	; 3
    2170:	0e 94 11 0a 	call	0x1422	; 0x1422 <vListInitialise>
    2174:	84 ec       	ldi	r24, 0xC4	; 196
    2176:	93 e0       	ldi	r25, 0x03	; 3
    2178:	0e 94 11 0a 	call	0x1422	; 0x1422 <vListInitialise>
    217c:	8b eb       	ldi	r24, 0xBB	; 187
    217e:	93 e0       	ldi	r25, 0x03	; 3
    2180:	0e 94 11 0a 	call	0x1422	; 0x1422 <vListInitialise>
    2184:	8e ea       	ldi	r24, 0xAE	; 174
    2186:	93 e0       	ldi	r25, 0x03	; 3
    2188:	0e 94 11 0a 	call	0x1422	; 0x1422 <vListInitialise>
    218c:	85 ea       	ldi	r24, 0xA5	; 165
    218e:	93 e0       	ldi	r25, 0x03	; 3
    2190:	0e 94 11 0a 	call	0x1422	; 0x1422 <vListInitialise>
    2194:	8b e9       	ldi	r24, 0x9B	; 155
    2196:	93 e0       	ldi	r25, 0x03	; 3
    2198:	0e 94 11 0a 	call	0x1422	; 0x1422 <vListInitialise>
    219c:	84 ec       	ldi	r24, 0xC4	; 196
    219e:	93 e0       	ldi	r25, 0x03	; 3
    21a0:	90 93 ba 03 	sts	0x03BA, r25	; 0x8003ba <pxDelayedTaskList+0x1>
    21a4:	80 93 b9 03 	sts	0x03B9, r24	; 0x8003b9 <pxDelayedTaskList>
    21a8:	8b eb       	ldi	r24, 0xBB	; 187
    21aa:	93 e0       	ldi	r25, 0x03	; 3
    21ac:	90 93 b8 03 	sts	0x03B8, r25	; 0x8003b8 <pxOverflowDelayedTaskList+0x1>
    21b0:	80 93 b7 03 	sts	0x03B7, r24	; 0x8003b7 <pxOverflowDelayedTaskList>
    21b4:	10 c0       	rjmp	.+32     	; 0x21d6 <xTaskCreate+0x1a8>
    21b6:	80 91 96 03 	lds	r24, 0x0396	; 0x800396 <xSchedulerRunning>
    21ba:	81 11       	cpse	r24, r1
    21bc:	0c c0       	rjmp	.+24     	; 0x21d6 <xTaskCreate+0x1a8>
    21be:	e0 91 f1 03 	lds	r30, 0x03F1	; 0x8003f1 <pxCurrentTCB>
    21c2:	f0 91 f2 03 	lds	r31, 0x03F2	; 0x8003f2 <pxCurrentTCB+0x1>
    21c6:	96 89       	ldd	r25, Z+22	; 0x16
    21c8:	8e 89       	ldd	r24, Y+22	; 0x16
    21ca:	89 17       	cp	r24, r25
    21cc:	20 f0       	brcs	.+8      	; 0x21d6 <xTaskCreate+0x1a8>
    21ce:	d0 93 f2 03 	sts	0x03F2, r29	; 0x8003f2 <pxCurrentTCB+0x1>
    21d2:	c0 93 f1 03 	sts	0x03F1, r28	; 0x8003f1 <pxCurrentTCB>
    21d6:	80 91 92 03 	lds	r24, 0x0392	; 0x800392 <uxTaskNumber>
    21da:	8f 5f       	subi	r24, 0xFF	; 255
    21dc:	80 93 92 03 	sts	0x0392, r24	; 0x800392 <uxTaskNumber>
    21e0:	8e 89       	ldd	r24, Y+22	; 0x16
    21e2:	90 91 97 03 	lds	r25, 0x0397	; 0x800397 <uxTopReadyPriority>
    21e6:	98 17       	cp	r25, r24
    21e8:	10 f4       	brcc	.+4      	; 0x21ee <xTaskCreate+0x1c0>
    21ea:	80 93 97 03 	sts	0x0397, r24	; 0x800397 <uxTopReadyPriority>
    21ee:	f9 e0       	ldi	r31, 0x09	; 9
    21f0:	8f 9f       	mul	r24, r31
    21f2:	c0 01       	movw	r24, r0
    21f4:	11 24       	eor	r1, r1
    21f6:	b6 01       	movw	r22, r12
    21f8:	83 53       	subi	r24, 0x33	; 51
    21fa:	9c 4f       	sbci	r25, 0xFC	; 252
    21fc:	0e 94 23 0a 	call	0x1446	; 0x1446 <vListInsertEnd>
    2200:	0f 90       	pop	r0
    2202:	0f be       	out	0x3f, r0	; 63
    2204:	80 91 96 03 	lds	r24, 0x0396	; 0x800396 <xSchedulerRunning>
    2208:	88 23       	and	r24, r24
    220a:	51 f0       	breq	.+20     	; 0x2220 <xTaskCreate+0x1f2>
    220c:	e0 91 f1 03 	lds	r30, 0x03F1	; 0x8003f1 <pxCurrentTCB>
    2210:	f0 91 f2 03 	lds	r31, 0x03F2	; 0x8003f2 <pxCurrentTCB+0x1>
    2214:	96 89       	ldd	r25, Z+22	; 0x16
    2216:	8e 89       	ldd	r24, Y+22	; 0x16
    2218:	98 17       	cp	r25, r24
    221a:	10 f4       	brcc	.+4      	; 0x2220 <xTaskCreate+0x1f2>
    221c:	0e 94 44 0b 	call	0x1688	; 0x1688 <vPortYield>
    2220:	81 e0       	ldi	r24, 0x01	; 1
    2222:	01 c0       	rjmp	.+2      	; 0x2226 <xTaskCreate+0x1f8>
    2224:	8f ef       	ldi	r24, 0xFF	; 255
    2226:	df 91       	pop	r29
    2228:	cf 91       	pop	r28
    222a:	1f 91       	pop	r17
    222c:	0f 91       	pop	r16
    222e:	ff 90       	pop	r15
    2230:	ef 90       	pop	r14
    2232:	df 90       	pop	r13
    2234:	cf 90       	pop	r12
    2236:	bf 90       	pop	r11
    2238:	af 90       	pop	r10
    223a:	9f 90       	pop	r9
    223c:	8f 90       	pop	r8
    223e:	7f 90       	pop	r7
    2240:	6f 90       	pop	r6
    2242:	5f 90       	pop	r5
    2244:	08 95       	ret

00002246 <vTaskStartScheduler>:
    2246:	ef 92       	push	r14
    2248:	ff 92       	push	r15
    224a:	0f 93       	push	r16
    224c:	8e e8       	ldi	r24, 0x8E	; 142
    224e:	e8 2e       	mov	r14, r24
    2250:	83 e0       	ldi	r24, 0x03	; 3
    2252:	f8 2e       	mov	r15, r24
    2254:	00 e0       	ldi	r16, 0x00	; 0
    2256:	20 e0       	ldi	r18, 0x00	; 0
    2258:	30 e0       	ldi	r19, 0x00	; 0
    225a:	40 ec       	ldi	r20, 0xC0	; 192
    225c:	50 e0       	ldi	r21, 0x00	; 0
    225e:	66 e0       	ldi	r22, 0x06	; 6
    2260:	72 e0       	ldi	r23, 0x02	; 2
    2262:	89 ee       	ldi	r24, 0xE9	; 233
    2264:	9f e0       	ldi	r25, 0x0F	; 15
    2266:	0e 94 17 10 	call	0x202e	; 0x202e <xTaskCreate>
    226a:	81 30       	cpi	r24, 0x01	; 1
    226c:	b1 f4       	brne	.+44     	; 0x229a <vTaskStartScheduler+0x54>
    226e:	0e 94 29 15 	call	0x2a52	; 0x2a52 <xTimerCreateTimerTask>
    2272:	81 30       	cpi	r24, 0x01	; 1
    2274:	91 f4       	brne	.+36     	; 0x229a <vTaskStartScheduler+0x54>
    2276:	f8 94       	cli
    2278:	2f ef       	ldi	r18, 0xFF	; 255
    227a:	3f ef       	ldi	r19, 0xFF	; 255
    227c:	30 93 91 03 	sts	0x0391, r19	; 0x800391 <xNextTaskUnblockTime+0x1>
    2280:	20 93 90 03 	sts	0x0390, r18	; 0x800390 <xNextTaskUnblockTime>
    2284:	80 93 96 03 	sts	0x0396, r24	; 0x800396 <xSchedulerRunning>
    2288:	10 92 99 03 	sts	0x0399, r1	; 0x800399 <xTickCount+0x1>
    228c:	10 92 98 03 	sts	0x0398, r1	; 0x800398 <xTickCount>
    2290:	0f 91       	pop	r16
    2292:	ff 90       	pop	r15
    2294:	ef 90       	pop	r14
    2296:	0c 94 0c 0b 	jmp	0x1618	; 0x1618 <xPortStartScheduler>
    229a:	0f 91       	pop	r16
    229c:	ff 90       	pop	r15
    229e:	ef 90       	pop	r14
    22a0:	08 95       	ret

000022a2 <vTaskSuspendAll>:
    22a2:	80 91 8d 03 	lds	r24, 0x038D	; 0x80038d <uxSchedulerSuspended>
    22a6:	8f 5f       	subi	r24, 0xFF	; 255
    22a8:	80 93 8d 03 	sts	0x038D, r24	; 0x80038d <uxSchedulerSuspended>
    22ac:	08 95       	ret

000022ae <xTaskGetTickCount>:
    22ae:	0f b6       	in	r0, 0x3f	; 63
    22b0:	f8 94       	cli
    22b2:	0f 92       	push	r0
    22b4:	80 91 98 03 	lds	r24, 0x0398	; 0x800398 <xTickCount>
    22b8:	90 91 99 03 	lds	r25, 0x0399	; 0x800399 <xTickCount+0x1>
    22bc:	0f 90       	pop	r0
    22be:	0f be       	out	0x3f, r0	; 63
    22c0:	08 95       	ret

000022c2 <xTaskIncrementTick>:
    22c2:	cf 92       	push	r12
    22c4:	df 92       	push	r13
    22c6:	ef 92       	push	r14
    22c8:	ff 92       	push	r15
    22ca:	0f 93       	push	r16
    22cc:	1f 93       	push	r17
    22ce:	cf 93       	push	r28
    22d0:	df 93       	push	r29
    22d2:	80 91 8d 03 	lds	r24, 0x038D	; 0x80038d <uxSchedulerSuspended>
    22d6:	81 11       	cpse	r24, r1
    22d8:	8c c0       	rjmp	.+280    	; 0x23f2 <xTaskIncrementTick+0x130>
    22da:	00 91 98 03 	lds	r16, 0x0398	; 0x800398 <xTickCount>
    22de:	10 91 99 03 	lds	r17, 0x0399	; 0x800399 <xTickCount+0x1>
    22e2:	0f 5f       	subi	r16, 0xFF	; 255
    22e4:	1f 4f       	sbci	r17, 0xFF	; 255
    22e6:	10 93 99 03 	sts	0x0399, r17	; 0x800399 <xTickCount+0x1>
    22ea:	00 93 98 03 	sts	0x0398, r16	; 0x800398 <xTickCount>
    22ee:	01 15       	cp	r16, r1
    22f0:	11 05       	cpc	r17, r1
    22f2:	b9 f4       	brne	.+46     	; 0x2322 <xTaskIncrementTick+0x60>
    22f4:	80 91 b9 03 	lds	r24, 0x03B9	; 0x8003b9 <pxDelayedTaskList>
    22f8:	90 91 ba 03 	lds	r25, 0x03BA	; 0x8003ba <pxDelayedTaskList+0x1>
    22fc:	20 91 b7 03 	lds	r18, 0x03B7	; 0x8003b7 <pxOverflowDelayedTaskList>
    2300:	30 91 b8 03 	lds	r19, 0x03B8	; 0x8003b8 <pxOverflowDelayedTaskList+0x1>
    2304:	30 93 ba 03 	sts	0x03BA, r19	; 0x8003ba <pxDelayedTaskList+0x1>
    2308:	20 93 b9 03 	sts	0x03B9, r18	; 0x8003b9 <pxDelayedTaskList>
    230c:	90 93 b8 03 	sts	0x03B8, r25	; 0x8003b8 <pxOverflowDelayedTaskList+0x1>
    2310:	80 93 b7 03 	sts	0x03B7, r24	; 0x8003b7 <pxOverflowDelayedTaskList>
    2314:	80 91 93 03 	lds	r24, 0x0393	; 0x800393 <xNumOfOverflows>
    2318:	8f 5f       	subi	r24, 0xFF	; 255
    231a:	80 93 93 03 	sts	0x0393, r24	; 0x800393 <xNumOfOverflows>
    231e:	0e 94 72 0f 	call	0x1ee4	; 0x1ee4 <prvResetNextTaskUnblockTime>
    2322:	80 91 90 03 	lds	r24, 0x0390	; 0x800390 <xNextTaskUnblockTime>
    2326:	90 91 91 03 	lds	r25, 0x0391	; 0x800391 <xNextTaskUnblockTime+0x1>
    232a:	c0 e0       	ldi	r28, 0x00	; 0
    232c:	08 17       	cp	r16, r24
    232e:	19 07       	cpc	r17, r25
    2330:	08 f4       	brcc	.+2      	; 0x2334 <xTaskIncrementTick+0x72>
    2332:	4f c0       	rjmp	.+158    	; 0x23d2 <xTaskIncrementTick+0x110>
    2334:	d9 e0       	ldi	r29, 0x09	; 9
    2336:	e0 91 b9 03 	lds	r30, 0x03B9	; 0x8003b9 <pxDelayedTaskList>
    233a:	f0 91 ba 03 	lds	r31, 0x03BA	; 0x8003ba <pxDelayedTaskList+0x1>
    233e:	80 81       	ld	r24, Z
    2340:	81 11       	cpse	r24, r1
    2342:	03 c0       	rjmp	.+6      	; 0x234a <xTaskIncrementTick+0x88>
    2344:	8f ef       	ldi	r24, 0xFF	; 255
    2346:	9f ef       	ldi	r25, 0xFF	; 255
    2348:	11 c0       	rjmp	.+34     	; 0x236c <xTaskIncrementTick+0xaa>
    234a:	e0 91 b9 03 	lds	r30, 0x03B9	; 0x8003b9 <pxDelayedTaskList>
    234e:	f0 91 ba 03 	lds	r31, 0x03BA	; 0x8003ba <pxDelayedTaskList+0x1>
    2352:	05 80       	ldd	r0, Z+5	; 0x05
    2354:	f6 81       	ldd	r31, Z+6	; 0x06
    2356:	e0 2d       	mov	r30, r0
    2358:	e6 80       	ldd	r14, Z+6	; 0x06
    235a:	f7 80       	ldd	r15, Z+7	; 0x07
    235c:	d7 01       	movw	r26, r14
    235e:	12 96       	adiw	r26, 0x02	; 2
    2360:	8d 91       	ld	r24, X+
    2362:	9c 91       	ld	r25, X
    2364:	13 97       	sbiw	r26, 0x03	; 3
    2366:	08 17       	cp	r16, r24
    2368:	19 07       	cpc	r17, r25
    236a:	28 f4       	brcc	.+10     	; 0x2376 <xTaskIncrementTick+0xb4>
    236c:	90 93 91 03 	sts	0x0391, r25	; 0x800391 <xNextTaskUnblockTime+0x1>
    2370:	80 93 90 03 	sts	0x0390, r24	; 0x800390 <xNextTaskUnblockTime>
    2374:	2e c0       	rjmp	.+92     	; 0x23d2 <xTaskIncrementTick+0x110>
    2376:	67 01       	movw	r12, r14
    2378:	b2 e0       	ldi	r27, 0x02	; 2
    237a:	cb 0e       	add	r12, r27
    237c:	d1 1c       	adc	r13, r1
    237e:	c6 01       	movw	r24, r12
    2380:	0e 94 7c 0a 	call	0x14f8	; 0x14f8 <uxListRemove>
    2384:	f7 01       	movw	r30, r14
    2386:	84 89       	ldd	r24, Z+20	; 0x14
    2388:	95 89       	ldd	r25, Z+21	; 0x15
    238a:	89 2b       	or	r24, r25
    238c:	21 f0       	breq	.+8      	; 0x2396 <xTaskIncrementTick+0xd4>
    238e:	c7 01       	movw	r24, r14
    2390:	0c 96       	adiw	r24, 0x0c	; 12
    2392:	0e 94 7c 0a 	call	0x14f8	; 0x14f8 <uxListRemove>
    2396:	d7 01       	movw	r26, r14
    2398:	56 96       	adiw	r26, 0x16	; 22
    239a:	8c 91       	ld	r24, X
    239c:	90 91 97 03 	lds	r25, 0x0397	; 0x800397 <uxTopReadyPriority>
    23a0:	98 17       	cp	r25, r24
    23a2:	10 f4       	brcc	.+4      	; 0x23a8 <xTaskIncrementTick+0xe6>
    23a4:	80 93 97 03 	sts	0x0397, r24	; 0x800397 <uxTopReadyPriority>
    23a8:	d8 9f       	mul	r29, r24
    23aa:	c0 01       	movw	r24, r0
    23ac:	11 24       	eor	r1, r1
    23ae:	b6 01       	movw	r22, r12
    23b0:	83 53       	subi	r24, 0x33	; 51
    23b2:	9c 4f       	sbci	r25, 0xFC	; 252
    23b4:	0e 94 23 0a 	call	0x1446	; 0x1446 <vListInsertEnd>
    23b8:	e0 91 f1 03 	lds	r30, 0x03F1	; 0x8003f1 <pxCurrentTCB>
    23bc:	f0 91 f2 03 	lds	r31, 0x03F2	; 0x8003f2 <pxCurrentTCB+0x1>
    23c0:	d7 01       	movw	r26, r14
    23c2:	56 96       	adiw	r26, 0x16	; 22
    23c4:	9c 91       	ld	r25, X
    23c6:	86 89       	ldd	r24, Z+22	; 0x16
    23c8:	98 17       	cp	r25, r24
    23ca:	08 f4       	brcc	.+2      	; 0x23ce <xTaskIncrementTick+0x10c>
    23cc:	b4 cf       	rjmp	.-152    	; 0x2336 <xTaskIncrementTick+0x74>
    23ce:	c1 e0       	ldi	r28, 0x01	; 1
    23d0:	b2 cf       	rjmp	.-156    	; 0x2336 <xTaskIncrementTick+0x74>
    23d2:	e0 91 f1 03 	lds	r30, 0x03F1	; 0x8003f1 <pxCurrentTCB>
    23d6:	f0 91 f2 03 	lds	r31, 0x03F2	; 0x8003f2 <pxCurrentTCB+0x1>
    23da:	e6 89       	ldd	r30, Z+22	; 0x16
    23dc:	b9 e0       	ldi	r27, 0x09	; 9
    23de:	eb 9f       	mul	r30, r27
    23e0:	f0 01       	movw	r30, r0
    23e2:	11 24       	eor	r1, r1
    23e4:	e3 53       	subi	r30, 0x33	; 51
    23e6:	fc 4f       	sbci	r31, 0xFC	; 252
    23e8:	80 81       	ld	r24, Z
    23ea:	82 30       	cpi	r24, 0x02	; 2
    23ec:	40 f0       	brcs	.+16     	; 0x23fe <xTaskIncrementTick+0x13c>
    23ee:	c1 e0       	ldi	r28, 0x01	; 1
    23f0:	06 c0       	rjmp	.+12     	; 0x23fe <xTaskIncrementTick+0x13c>
    23f2:	80 91 95 03 	lds	r24, 0x0395	; 0x800395 <uxPendedTicks>
    23f6:	8f 5f       	subi	r24, 0xFF	; 255
    23f8:	80 93 95 03 	sts	0x0395, r24	; 0x800395 <uxPendedTicks>
    23fc:	c0 e0       	ldi	r28, 0x00	; 0
    23fe:	80 91 94 03 	lds	r24, 0x0394	; 0x800394 <xYieldPending>
    2402:	81 11       	cpse	r24, r1
    2404:	c1 e0       	ldi	r28, 0x01	; 1
    2406:	8c 2f       	mov	r24, r28
    2408:	df 91       	pop	r29
    240a:	cf 91       	pop	r28
    240c:	1f 91       	pop	r17
    240e:	0f 91       	pop	r16
    2410:	ff 90       	pop	r15
    2412:	ef 90       	pop	r14
    2414:	df 90       	pop	r13
    2416:	cf 90       	pop	r12
    2418:	08 95       	ret

0000241a <xTaskResumeAll>:
    241a:	ef 92       	push	r14
    241c:	ff 92       	push	r15
    241e:	0f 93       	push	r16
    2420:	1f 93       	push	r17
    2422:	cf 93       	push	r28
    2424:	df 93       	push	r29
    2426:	0f b6       	in	r0, 0x3f	; 63
    2428:	f8 94       	cli
    242a:	0f 92       	push	r0
    242c:	80 91 8d 03 	lds	r24, 0x038D	; 0x80038d <uxSchedulerSuspended>
    2430:	81 50       	subi	r24, 0x01	; 1
    2432:	80 93 8d 03 	sts	0x038D, r24	; 0x80038d <uxSchedulerSuspended>
    2436:	80 91 8d 03 	lds	r24, 0x038D	; 0x80038d <uxSchedulerSuspended>
    243a:	88 23       	and	r24, r24
    243c:	11 f0       	breq	.+4      	; 0x2442 <xTaskResumeAll+0x28>
    243e:	80 e0       	ldi	r24, 0x00	; 0
    2440:	52 c0       	rjmp	.+164    	; 0x24e6 <xTaskResumeAll+0xcc>
    2442:	80 91 9a 03 	lds	r24, 0x039A	; 0x80039a <uxCurrentNumberOfTasks>
    2446:	88 23       	and	r24, r24
    2448:	d1 f3       	breq	.-12     	; 0x243e <xTaskResumeAll+0x24>
    244a:	c0 e0       	ldi	r28, 0x00	; 0
    244c:	d0 e0       	ldi	r29, 0x00	; 0
    244e:	89 e0       	ldi	r24, 0x09	; 9
    2450:	f8 2e       	mov	r15, r24
    2452:	ee 24       	eor	r14, r14
    2454:	e3 94       	inc	r14
    2456:	80 91 ae 03 	lds	r24, 0x03AE	; 0x8003ae <xPendingReadyList>
    245a:	88 23       	and	r24, r24
    245c:	51 f1       	breq	.+84     	; 0x24b2 <xTaskResumeAll+0x98>
    245e:	e0 91 b3 03 	lds	r30, 0x03B3	; 0x8003b3 <xPendingReadyList+0x5>
    2462:	f0 91 b4 03 	lds	r31, 0x03B4	; 0x8003b4 <xPendingReadyList+0x6>
    2466:	c6 81       	ldd	r28, Z+6	; 0x06
    2468:	d7 81       	ldd	r29, Z+7	; 0x07
    246a:	ce 01       	movw	r24, r28
    246c:	0c 96       	adiw	r24, 0x0c	; 12
    246e:	0e 94 7c 0a 	call	0x14f8	; 0x14f8 <uxListRemove>
    2472:	8e 01       	movw	r16, r28
    2474:	0e 5f       	subi	r16, 0xFE	; 254
    2476:	1f 4f       	sbci	r17, 0xFF	; 255
    2478:	c8 01       	movw	r24, r16
    247a:	0e 94 7c 0a 	call	0x14f8	; 0x14f8 <uxListRemove>
    247e:	8e 89       	ldd	r24, Y+22	; 0x16
    2480:	90 91 97 03 	lds	r25, 0x0397	; 0x800397 <uxTopReadyPriority>
    2484:	98 17       	cp	r25, r24
    2486:	10 f4       	brcc	.+4      	; 0x248c <xTaskResumeAll+0x72>
    2488:	80 93 97 03 	sts	0x0397, r24	; 0x800397 <uxTopReadyPriority>
    248c:	f8 9e       	mul	r15, r24
    248e:	c0 01       	movw	r24, r0
    2490:	11 24       	eor	r1, r1
    2492:	b8 01       	movw	r22, r16
    2494:	83 53       	subi	r24, 0x33	; 51
    2496:	9c 4f       	sbci	r25, 0xFC	; 252
    2498:	0e 94 23 0a 	call	0x1446	; 0x1446 <vListInsertEnd>
    249c:	e0 91 f1 03 	lds	r30, 0x03F1	; 0x8003f1 <pxCurrentTCB>
    24a0:	f0 91 f2 03 	lds	r31, 0x03F2	; 0x8003f2 <pxCurrentTCB+0x1>
    24a4:	9e 89       	ldd	r25, Y+22	; 0x16
    24a6:	86 89       	ldd	r24, Z+22	; 0x16
    24a8:	98 17       	cp	r25, r24
    24aa:	a8 f2       	brcs	.-86     	; 0x2456 <xTaskResumeAll+0x3c>
    24ac:	e0 92 94 03 	sts	0x0394, r14	; 0x800394 <xYieldPending>
    24b0:	d2 cf       	rjmp	.-92     	; 0x2456 <xTaskResumeAll+0x3c>
    24b2:	cd 2b       	or	r28, r29
    24b4:	11 f0       	breq	.+4      	; 0x24ba <xTaskResumeAll+0xa0>
    24b6:	0e 94 72 0f 	call	0x1ee4	; 0x1ee4 <prvResetNextTaskUnblockTime>
    24ba:	c0 91 95 03 	lds	r28, 0x0395	; 0x800395 <uxPendedTicks>
    24be:	cc 23       	and	r28, r28
    24c0:	51 f0       	breq	.+20     	; 0x24d6 <xTaskResumeAll+0xbc>
    24c2:	d1 e0       	ldi	r29, 0x01	; 1
    24c4:	0e 94 61 11 	call	0x22c2	; 0x22c2 <xTaskIncrementTick>
    24c8:	81 11       	cpse	r24, r1
    24ca:	d0 93 94 03 	sts	0x0394, r29	; 0x800394 <xYieldPending>
    24ce:	c1 50       	subi	r28, 0x01	; 1
    24d0:	c9 f7       	brne	.-14     	; 0x24c4 <xTaskResumeAll+0xaa>
    24d2:	10 92 95 03 	sts	0x0395, r1	; 0x800395 <uxPendedTicks>
    24d6:	80 91 94 03 	lds	r24, 0x0394	; 0x800394 <xYieldPending>
    24da:	88 23       	and	r24, r24
    24dc:	09 f4       	brne	.+2      	; 0x24e0 <xTaskResumeAll+0xc6>
    24de:	af cf       	rjmp	.-162    	; 0x243e <xTaskResumeAll+0x24>
    24e0:	0e 94 44 0b 	call	0x1688	; 0x1688 <vPortYield>
    24e4:	81 e0       	ldi	r24, 0x01	; 1
    24e6:	0f 90       	pop	r0
    24e8:	0f be       	out	0x3f, r0	; 63
    24ea:	df 91       	pop	r29
    24ec:	cf 91       	pop	r28
    24ee:	1f 91       	pop	r17
    24f0:	0f 91       	pop	r16
    24f2:	ff 90       	pop	r15
    24f4:	ef 90       	pop	r14
    24f6:	08 95       	ret

000024f8 <vTaskDelayUntil>:
    24f8:	0f 93       	push	r16
    24fa:	1f 93       	push	r17
    24fc:	cf 93       	push	r28
    24fe:	df 93       	push	r29
    2500:	8c 01       	movw	r16, r24
    2502:	eb 01       	movw	r28, r22
    2504:	0e 94 51 11 	call	0x22a2	; 0x22a2 <vTaskSuspendAll>
    2508:	40 91 98 03 	lds	r20, 0x0398	; 0x800398 <xTickCount>
    250c:	50 91 99 03 	lds	r21, 0x0399	; 0x800399 <xTickCount+0x1>
    2510:	f8 01       	movw	r30, r16
    2512:	20 81       	ld	r18, Z
    2514:	31 81       	ldd	r19, Z+1	; 0x01
    2516:	c9 01       	movw	r24, r18
    2518:	8c 0f       	add	r24, r28
    251a:	9d 1f       	adc	r25, r29
    251c:	42 17       	cp	r20, r18
    251e:	53 07       	cpc	r21, r19
    2520:	20 f4       	brcc	.+8      	; 0x252a <vTaskDelayUntil+0x32>
    2522:	82 17       	cp	r24, r18
    2524:	93 07       	cpc	r25, r19
    2526:	40 f4       	brcc	.+16     	; 0x2538 <vTaskDelayUntil+0x40>
    2528:	03 c0       	rjmp	.+6      	; 0x2530 <vTaskDelayUntil+0x38>
    252a:	82 17       	cp	r24, r18
    252c:	93 07       	cpc	r25, r19
    252e:	30 f0       	brcs	.+12     	; 0x253c <vTaskDelayUntil+0x44>
    2530:	21 e0       	ldi	r18, 0x01	; 1
    2532:	48 17       	cp	r20, r24
    2534:	59 07       	cpc	r21, r25
    2536:	18 f0       	brcs	.+6      	; 0x253e <vTaskDelayUntil+0x46>
    2538:	20 e0       	ldi	r18, 0x00	; 0
    253a:	01 c0       	rjmp	.+2      	; 0x253e <vTaskDelayUntil+0x46>
    253c:	21 e0       	ldi	r18, 0x01	; 1
    253e:	f8 01       	movw	r30, r16
    2540:	91 83       	std	Z+1, r25	; 0x01
    2542:	80 83       	st	Z, r24
    2544:	22 23       	and	r18, r18
    2546:	29 f0       	breq	.+10     	; 0x2552 <vTaskDelayUntil+0x5a>
    2548:	60 e0       	ldi	r22, 0x00	; 0
    254a:	84 1b       	sub	r24, r20
    254c:	95 0b       	sbc	r25, r21
    254e:	0e 94 8d 0f 	call	0x1f1a	; 0x1f1a <prvAddCurrentTaskToDelayedList>
    2552:	0e 94 0d 12 	call	0x241a	; 0x241a <xTaskResumeAll>
    2556:	81 11       	cpse	r24, r1
    2558:	02 c0       	rjmp	.+4      	; 0x255e <vTaskDelayUntil+0x66>
    255a:	0e 94 44 0b 	call	0x1688	; 0x1688 <vPortYield>
    255e:	df 91       	pop	r29
    2560:	cf 91       	pop	r28
    2562:	1f 91       	pop	r17
    2564:	0f 91       	pop	r16
    2566:	08 95       	ret

00002568 <vTaskDelay>:
    2568:	cf 93       	push	r28
    256a:	df 93       	push	r29
    256c:	ec 01       	movw	r28, r24
    256e:	89 2b       	or	r24, r25
    2570:	19 f4       	brne	.+6      	; 0x2578 <vTaskDelay+0x10>
    2572:	0e 94 44 0b 	call	0x1688	; 0x1688 <vPortYield>
    2576:	0a c0       	rjmp	.+20     	; 0x258c <vTaskDelay+0x24>
    2578:	0e 94 51 11 	call	0x22a2	; 0x22a2 <vTaskSuspendAll>
    257c:	60 e0       	ldi	r22, 0x00	; 0
    257e:	ce 01       	movw	r24, r28
    2580:	0e 94 8d 0f 	call	0x1f1a	; 0x1f1a <prvAddCurrentTaskToDelayedList>
    2584:	0e 94 0d 12 	call	0x241a	; 0x241a <xTaskResumeAll>
    2588:	88 23       	and	r24, r24
    258a:	99 f3       	breq	.-26     	; 0x2572 <vTaskDelay+0xa>
    258c:	df 91       	pop	r29
    258e:	cf 91       	pop	r28
    2590:	08 95       	ret

00002592 <vTaskSwitchContext>:
    2592:	80 91 8d 03 	lds	r24, 0x038D	; 0x80038d <uxSchedulerSuspended>
    2596:	88 23       	and	r24, r24
    2598:	21 f0       	breq	.+8      	; 0x25a2 <vTaskSwitchContext+0x10>
    259a:	81 e0       	ldi	r24, 0x01	; 1
    259c:	80 93 94 03 	sts	0x0394, r24	; 0x800394 <xYieldPending>
    25a0:	08 95       	ret
    25a2:	10 92 94 03 	sts	0x0394, r1	; 0x800394 <xYieldPending>
    25a6:	a0 91 f1 03 	lds	r26, 0x03F1	; 0x8003f1 <pxCurrentTCB>
    25aa:	b0 91 f2 03 	lds	r27, 0x03F2	; 0x8003f2 <pxCurrentTCB+0x1>
    25ae:	e0 91 f1 03 	lds	r30, 0x03F1	; 0x8003f1 <pxCurrentTCB>
    25b2:	f0 91 f2 03 	lds	r31, 0x03F2	; 0x8003f2 <pxCurrentTCB+0x1>
    25b6:	2d 91       	ld	r18, X+
    25b8:	3c 91       	ld	r19, X
    25ba:	87 89       	ldd	r24, Z+23	; 0x17
    25bc:	90 8d       	ldd	r25, Z+24	; 0x18
    25be:	82 17       	cp	r24, r18
    25c0:	93 07       	cpc	r25, r19
    25c2:	60 f0       	brcs	.+24     	; 0x25dc <vTaskSwitchContext+0x4a>
    25c4:	60 91 f1 03 	lds	r22, 0x03F1	; 0x8003f1 <pxCurrentTCB>
    25c8:	70 91 f2 03 	lds	r23, 0x03F2	; 0x8003f2 <pxCurrentTCB+0x1>
    25cc:	80 91 f1 03 	lds	r24, 0x03F1	; 0x8003f1 <pxCurrentTCB>
    25d0:	90 91 f2 03 	lds	r25, 0x03F2	; 0x8003f2 <pxCurrentTCB+0x1>
    25d4:	67 5e       	subi	r22, 0xE7	; 231
    25d6:	7f 4f       	sbci	r23, 0xFF	; 255
    25d8:	0e 94 f7 16 	call	0x2dee	; 0x2dee <vApplicationStackOverflowHook>
    25dc:	80 91 97 03 	lds	r24, 0x0397	; 0x800397 <uxTopReadyPriority>
    25e0:	69 e0       	ldi	r22, 0x09	; 9
    25e2:	48 2f       	mov	r20, r24
    25e4:	50 e0       	ldi	r21, 0x00	; 0
    25e6:	64 9f       	mul	r22, r20
    25e8:	90 01       	movw	r18, r0
    25ea:	65 9f       	mul	r22, r21
    25ec:	30 0d       	add	r19, r0
    25ee:	11 24       	eor	r1, r1
    25f0:	f9 01       	movw	r30, r18
    25f2:	e3 53       	subi	r30, 0x33	; 51
    25f4:	fc 4f       	sbci	r31, 0xFC	; 252
    25f6:	90 81       	ld	r25, Z
    25f8:	91 11       	cpse	r25, r1
    25fa:	02 c0       	rjmp	.+4      	; 0x2600 <vTaskSwitchContext+0x6e>
    25fc:	81 50       	subi	r24, 0x01	; 1
    25fe:	f1 cf       	rjmp	.-30     	; 0x25e2 <vTaskSwitchContext+0x50>
    2600:	a1 81       	ldd	r26, Z+1	; 0x01
    2602:	b2 81       	ldd	r27, Z+2	; 0x02
    2604:	12 96       	adiw	r26, 0x02	; 2
    2606:	0d 90       	ld	r0, X+
    2608:	bc 91       	ld	r27, X
    260a:	a0 2d       	mov	r26, r0
    260c:	b2 83       	std	Z+2, r27	; 0x02
    260e:	a1 83       	std	Z+1, r26	; 0x01
    2610:	20 53       	subi	r18, 0x30	; 48
    2612:	3c 4f       	sbci	r19, 0xFC	; 252
    2614:	a2 17       	cp	r26, r18
    2616:	b3 07       	cpc	r27, r19
    2618:	31 f4       	brne	.+12     	; 0x2626 <vTaskSwitchContext+0x94>
    261a:	12 96       	adiw	r26, 0x02	; 2
    261c:	2d 91       	ld	r18, X+
    261e:	3c 91       	ld	r19, X
    2620:	13 97       	sbiw	r26, 0x03	; 3
    2622:	32 83       	std	Z+2, r19	; 0x02
    2624:	21 83       	std	Z+1, r18	; 0x01
    2626:	99 e0       	ldi	r25, 0x09	; 9
    2628:	94 9f       	mul	r25, r20
    262a:	f0 01       	movw	r30, r0
    262c:	95 9f       	mul	r25, r21
    262e:	f0 0d       	add	r31, r0
    2630:	11 24       	eor	r1, r1
    2632:	e3 53       	subi	r30, 0x33	; 51
    2634:	fc 4f       	sbci	r31, 0xFC	; 252
    2636:	01 80       	ldd	r0, Z+1	; 0x01
    2638:	f2 81       	ldd	r31, Z+2	; 0x02
    263a:	e0 2d       	mov	r30, r0
    263c:	26 81       	ldd	r18, Z+6	; 0x06
    263e:	37 81       	ldd	r19, Z+7	; 0x07
    2640:	30 93 f2 03 	sts	0x03F2, r19	; 0x8003f2 <pxCurrentTCB+0x1>
    2644:	20 93 f1 03 	sts	0x03F1, r18	; 0x8003f1 <pxCurrentTCB>
    2648:	80 93 97 03 	sts	0x0397, r24	; 0x800397 <uxTopReadyPriority>
    264c:	08 95       	ret

0000264e <vTaskPlaceOnEventList>:
    264e:	cf 93       	push	r28
    2650:	df 93       	push	r29
    2652:	eb 01       	movw	r28, r22
    2654:	60 91 f1 03 	lds	r22, 0x03F1	; 0x8003f1 <pxCurrentTCB>
    2658:	70 91 f2 03 	lds	r23, 0x03F2	; 0x8003f2 <pxCurrentTCB+0x1>
    265c:	64 5f       	subi	r22, 0xF4	; 244
    265e:	7f 4f       	sbci	r23, 0xFF	; 255
    2660:	0e 94 44 0a 	call	0x1488	; 0x1488 <vListInsert>
    2664:	61 e0       	ldi	r22, 0x01	; 1
    2666:	ce 01       	movw	r24, r28
    2668:	df 91       	pop	r29
    266a:	cf 91       	pop	r28
    266c:	0c 94 8d 0f 	jmp	0x1f1a	; 0x1f1a <prvAddCurrentTaskToDelayedList>

00002670 <vTaskPlaceOnEventListRestricted>:
    2670:	1f 93       	push	r17
    2672:	cf 93       	push	r28
    2674:	df 93       	push	r29
    2676:	eb 01       	movw	r28, r22
    2678:	14 2f       	mov	r17, r20
    267a:	60 91 f1 03 	lds	r22, 0x03F1	; 0x8003f1 <pxCurrentTCB>
    267e:	70 91 f2 03 	lds	r23, 0x03F2	; 0x8003f2 <pxCurrentTCB+0x1>
    2682:	64 5f       	subi	r22, 0xF4	; 244
    2684:	7f 4f       	sbci	r23, 0xFF	; 255
    2686:	0e 94 23 0a 	call	0x1446	; 0x1446 <vListInsertEnd>
    268a:	11 23       	and	r17, r17
    268c:	11 f0       	breq	.+4      	; 0x2692 <vTaskPlaceOnEventListRestricted+0x22>
    268e:	cf ef       	ldi	r28, 0xFF	; 255
    2690:	df ef       	ldi	r29, 0xFF	; 255
    2692:	61 2f       	mov	r22, r17
    2694:	ce 01       	movw	r24, r28
    2696:	df 91       	pop	r29
    2698:	cf 91       	pop	r28
    269a:	1f 91       	pop	r17
    269c:	0c 94 8d 0f 	jmp	0x1f1a	; 0x1f1a <prvAddCurrentTaskToDelayedList>

000026a0 <xTaskRemoveFromEventList>:
    26a0:	0f 93       	push	r16
    26a2:	1f 93       	push	r17
    26a4:	cf 93       	push	r28
    26a6:	df 93       	push	r29
    26a8:	dc 01       	movw	r26, r24
    26aa:	15 96       	adiw	r26, 0x05	; 5
    26ac:	ed 91       	ld	r30, X+
    26ae:	fc 91       	ld	r31, X
    26b0:	16 97       	sbiw	r26, 0x06	; 6
    26b2:	c6 81       	ldd	r28, Z+6	; 0x06
    26b4:	d7 81       	ldd	r29, Z+7	; 0x07
    26b6:	8e 01       	movw	r16, r28
    26b8:	04 5f       	subi	r16, 0xF4	; 244
    26ba:	1f 4f       	sbci	r17, 0xFF	; 255
    26bc:	c8 01       	movw	r24, r16
    26be:	0e 94 7c 0a 	call	0x14f8	; 0x14f8 <uxListRemove>
    26c2:	80 91 8d 03 	lds	r24, 0x038D	; 0x80038d <uxSchedulerSuspended>
    26c6:	81 11       	cpse	r24, r1
    26c8:	14 c0       	rjmp	.+40     	; 0x26f2 <xTaskRemoveFromEventList+0x52>
    26ca:	0a 50       	subi	r16, 0x0A	; 10
    26cc:	11 09       	sbc	r17, r1
    26ce:	c8 01       	movw	r24, r16
    26d0:	0e 94 7c 0a 	call	0x14f8	; 0x14f8 <uxListRemove>
    26d4:	8e 89       	ldd	r24, Y+22	; 0x16
    26d6:	90 91 97 03 	lds	r25, 0x0397	; 0x800397 <uxTopReadyPriority>
    26da:	98 17       	cp	r25, r24
    26dc:	10 f4       	brcc	.+4      	; 0x26e2 <xTaskRemoveFromEventList+0x42>
    26de:	80 93 97 03 	sts	0x0397, r24	; 0x800397 <uxTopReadyPriority>
    26e2:	b9 e0       	ldi	r27, 0x09	; 9
    26e4:	8b 9f       	mul	r24, r27
    26e6:	c0 01       	movw	r24, r0
    26e8:	11 24       	eor	r1, r1
    26ea:	b8 01       	movw	r22, r16
    26ec:	83 53       	subi	r24, 0x33	; 51
    26ee:	9c 4f       	sbci	r25, 0xFC	; 252
    26f0:	03 c0       	rjmp	.+6      	; 0x26f8 <xTaskRemoveFromEventList+0x58>
    26f2:	b8 01       	movw	r22, r16
    26f4:	8e ea       	ldi	r24, 0xAE	; 174
    26f6:	93 e0       	ldi	r25, 0x03	; 3
    26f8:	0e 94 23 0a 	call	0x1446	; 0x1446 <vListInsertEnd>
    26fc:	e0 91 f1 03 	lds	r30, 0x03F1	; 0x8003f1 <pxCurrentTCB>
    2700:	f0 91 f2 03 	lds	r31, 0x03F2	; 0x8003f2 <pxCurrentTCB+0x1>
    2704:	9e 89       	ldd	r25, Y+22	; 0x16
    2706:	86 89       	ldd	r24, Z+22	; 0x16
    2708:	89 17       	cp	r24, r25
    270a:	20 f4       	brcc	.+8      	; 0x2714 <xTaskRemoveFromEventList+0x74>
    270c:	81 e0       	ldi	r24, 0x01	; 1
    270e:	80 93 94 03 	sts	0x0394, r24	; 0x800394 <xYieldPending>
    2712:	01 c0       	rjmp	.+2      	; 0x2716 <xTaskRemoveFromEventList+0x76>
    2714:	80 e0       	ldi	r24, 0x00	; 0
    2716:	df 91       	pop	r29
    2718:	cf 91       	pop	r28
    271a:	1f 91       	pop	r17
    271c:	0f 91       	pop	r16
    271e:	08 95       	ret

00002720 <vTaskInternalSetTimeOutState>:
    2720:	20 91 93 03 	lds	r18, 0x0393	; 0x800393 <xNumOfOverflows>
    2724:	fc 01       	movw	r30, r24
    2726:	20 83       	st	Z, r18
    2728:	20 91 98 03 	lds	r18, 0x0398	; 0x800398 <xTickCount>
    272c:	30 91 99 03 	lds	r19, 0x0399	; 0x800399 <xTickCount+0x1>
    2730:	32 83       	std	Z+2, r19	; 0x02
    2732:	21 83       	std	Z+1, r18	; 0x01
    2734:	08 95       	ret

00002736 <xTaskCheckForTimeOut>:
    2736:	cf 93       	push	r28
    2738:	df 93       	push	r29
    273a:	0f b6       	in	r0, 0x3f	; 63
    273c:	f8 94       	cli
    273e:	0f 92       	push	r0
    2740:	40 91 98 03 	lds	r20, 0x0398	; 0x800398 <xTickCount>
    2744:	50 91 99 03 	lds	r21, 0x0399	; 0x800399 <xTickCount+0x1>
    2748:	db 01       	movw	r26, r22
    274a:	2d 91       	ld	r18, X+
    274c:	3c 91       	ld	r19, X
    274e:	2f 3f       	cpi	r18, 0xFF	; 255
    2750:	bf ef       	ldi	r27, 0xFF	; 255
    2752:	3b 07       	cpc	r19, r27
    2754:	d9 f0       	breq	.+54     	; 0x278c <xTaskCheckForTimeOut+0x56>
    2756:	ec 01       	movw	r28, r24
    2758:	e9 81       	ldd	r30, Y+1	; 0x01
    275a:	fa 81       	ldd	r31, Y+2	; 0x02
    275c:	a0 91 93 03 	lds	r26, 0x0393	; 0x800393 <xNumOfOverflows>
    2760:	b8 81       	ld	r27, Y
    2762:	ba 17       	cp	r27, r26
    2764:	19 f0       	breq	.+6      	; 0x276c <xTaskCheckForTimeOut+0x36>
    2766:	4e 17       	cp	r20, r30
    2768:	5f 07       	cpc	r21, r31
    276a:	90 f4       	brcc	.+36     	; 0x2790 <xTaskCheckForTimeOut+0x5a>
    276c:	4e 1b       	sub	r20, r30
    276e:	5f 0b       	sbc	r21, r31
    2770:	fb 01       	movw	r30, r22
    2772:	42 17       	cp	r20, r18
    2774:	53 07       	cpc	r21, r19
    2776:	38 f4       	brcc	.+14     	; 0x2786 <xTaskCheckForTimeOut+0x50>
    2778:	24 1b       	sub	r18, r20
    277a:	35 0b       	sbc	r19, r21
    277c:	31 83       	std	Z+1, r19	; 0x01
    277e:	20 83       	st	Z, r18
    2780:	0e 94 90 13 	call	0x2720	; 0x2720 <vTaskInternalSetTimeOutState>
    2784:	03 c0       	rjmp	.+6      	; 0x278c <xTaskCheckForTimeOut+0x56>
    2786:	11 82       	std	Z+1, r1	; 0x01
    2788:	10 82       	st	Z, r1
    278a:	02 c0       	rjmp	.+4      	; 0x2790 <xTaskCheckForTimeOut+0x5a>
    278c:	80 e0       	ldi	r24, 0x00	; 0
    278e:	01 c0       	rjmp	.+2      	; 0x2792 <xTaskCheckForTimeOut+0x5c>
    2790:	81 e0       	ldi	r24, 0x01	; 1
    2792:	0f 90       	pop	r0
    2794:	0f be       	out	0x3f, r0	; 63
    2796:	df 91       	pop	r29
    2798:	cf 91       	pop	r28
    279a:	08 95       	ret

0000279c <vTaskMissedYield>:
    279c:	81 e0       	ldi	r24, 0x01	; 1
    279e:	80 93 94 03 	sts	0x0394, r24	; 0x800394 <xYieldPending>
    27a2:	08 95       	ret

000027a4 <xTaskGetSchedulerState>:
    27a4:	80 91 96 03 	lds	r24, 0x0396	; 0x800396 <xSchedulerRunning>
    27a8:	88 23       	and	r24, r24
    27aa:	31 f0       	breq	.+12     	; 0x27b8 <xTaskGetSchedulerState+0x14>
    27ac:	80 91 8d 03 	lds	r24, 0x038D	; 0x80038d <uxSchedulerSuspended>
    27b0:	88 23       	and	r24, r24
    27b2:	21 f0       	breq	.+8      	; 0x27bc <xTaskGetSchedulerState+0x18>
    27b4:	80 e0       	ldi	r24, 0x00	; 0
    27b6:	08 95       	ret
    27b8:	81 e0       	ldi	r24, 0x01	; 1
    27ba:	08 95       	ret
    27bc:	82 e0       	ldi	r24, 0x02	; 2
    27be:	08 95       	ret

000027c0 <xTaskPriorityInherit>:
    27c0:	0f 93       	push	r16
    27c2:	1f 93       	push	r17
    27c4:	cf 93       	push	r28
    27c6:	df 93       	push	r29
    27c8:	fc 01       	movw	r30, r24
    27ca:	89 2b       	or	r24, r25
    27cc:	09 f4       	brne	.+2      	; 0x27d0 <xTaskPriorityInherit+0x10>
    27ce:	55 c0       	rjmp	.+170    	; 0x287a <xTaskPriorityInherit+0xba>
    27d0:	86 89       	ldd	r24, Z+22	; 0x16
    27d2:	a0 91 f1 03 	lds	r26, 0x03F1	; 0x8003f1 <pxCurrentTCB>
    27d6:	b0 91 f2 03 	lds	r27, 0x03F2	; 0x8003f2 <pxCurrentTCB+0x1>
    27da:	56 96       	adiw	r26, 0x16	; 22
    27dc:	9c 91       	ld	r25, X
    27de:	89 17       	cp	r24, r25
    27e0:	08 f0       	brcs	.+2      	; 0x27e4 <xTaskPriorityInherit+0x24>
    27e2:	41 c0       	rjmp	.+130    	; 0x2866 <xTaskPriorityInherit+0xa6>
    27e4:	24 85       	ldd	r18, Z+12	; 0x0c
    27e6:	35 85       	ldd	r19, Z+13	; 0x0d
    27e8:	37 fd       	sbrc	r19, 7
    27ea:	0c c0       	rjmp	.+24     	; 0x2804 <xTaskPriorityInherit+0x44>
    27ec:	a0 91 f1 03 	lds	r26, 0x03F1	; 0x8003f1 <pxCurrentTCB>
    27f0:	b0 91 f2 03 	lds	r27, 0x03F2	; 0x8003f2 <pxCurrentTCB+0x1>
    27f4:	56 96       	adiw	r26, 0x16	; 22
    27f6:	9c 91       	ld	r25, X
    27f8:	24 e0       	ldi	r18, 0x04	; 4
    27fa:	30 e0       	ldi	r19, 0x00	; 0
    27fc:	29 1b       	sub	r18, r25
    27fe:	31 09       	sbc	r19, r1
    2800:	35 87       	std	Z+13, r19	; 0x0d
    2802:	24 87       	std	Z+12, r18	; 0x0c
    2804:	29 e0       	ldi	r18, 0x09	; 9
    2806:	82 9f       	mul	r24, r18
    2808:	c0 01       	movw	r24, r0
    280a:	11 24       	eor	r1, r1
    280c:	83 53       	subi	r24, 0x33	; 51
    280e:	9c 4f       	sbci	r25, 0xFC	; 252
    2810:	22 85       	ldd	r18, Z+10	; 0x0a
    2812:	33 85       	ldd	r19, Z+11	; 0x0b
    2814:	28 17       	cp	r18, r24
    2816:	39 07       	cpc	r19, r25
    2818:	e9 f4       	brne	.+58     	; 0x2854 <xTaskPriorityInherit+0x94>
    281a:	8f 01       	movw	r16, r30
    281c:	ef 01       	movw	r28, r30
    281e:	22 96       	adiw	r28, 0x02	; 2
    2820:	ce 01       	movw	r24, r28
    2822:	0e 94 7c 0a 	call	0x14f8	; 0x14f8 <uxListRemove>
    2826:	e0 91 f1 03 	lds	r30, 0x03F1	; 0x8003f1 <pxCurrentTCB>
    282a:	f0 91 f2 03 	lds	r31, 0x03F2	; 0x8003f2 <pxCurrentTCB+0x1>
    282e:	86 89       	ldd	r24, Z+22	; 0x16
    2830:	f8 01       	movw	r30, r16
    2832:	86 8b       	std	Z+22, r24	; 0x16
    2834:	90 91 97 03 	lds	r25, 0x0397	; 0x800397 <uxTopReadyPriority>
    2838:	98 17       	cp	r25, r24
    283a:	10 f4       	brcc	.+4      	; 0x2840 <xTaskPriorityInherit+0x80>
    283c:	80 93 97 03 	sts	0x0397, r24	; 0x800397 <uxTopReadyPriority>
    2840:	f9 e0       	ldi	r31, 0x09	; 9
    2842:	8f 9f       	mul	r24, r31
    2844:	c0 01       	movw	r24, r0
    2846:	11 24       	eor	r1, r1
    2848:	be 01       	movw	r22, r28
    284a:	83 53       	subi	r24, 0x33	; 51
    284c:	9c 4f       	sbci	r25, 0xFC	; 252
    284e:	0e 94 23 0a 	call	0x1446	; 0x1446 <vListInsertEnd>
    2852:	07 c0       	rjmp	.+14     	; 0x2862 <xTaskPriorityInherit+0xa2>
    2854:	a0 91 f1 03 	lds	r26, 0x03F1	; 0x8003f1 <pxCurrentTCB>
    2858:	b0 91 f2 03 	lds	r27, 0x03F2	; 0x8003f2 <pxCurrentTCB+0x1>
    285c:	56 96       	adiw	r26, 0x16	; 22
    285e:	8c 91       	ld	r24, X
    2860:	86 8b       	std	Z+22, r24	; 0x16
    2862:	81 e0       	ldi	r24, 0x01	; 1
    2864:	0b c0       	rjmp	.+22     	; 0x287c <xTaskPriorityInherit+0xbc>
    2866:	a0 91 f1 03 	lds	r26, 0x03F1	; 0x8003f1 <pxCurrentTCB>
    286a:	b0 91 f2 03 	lds	r27, 0x03F2	; 0x8003f2 <pxCurrentTCB+0x1>
    286e:	81 e0       	ldi	r24, 0x01	; 1
    2870:	21 a1       	ldd	r18, Z+33	; 0x21
    2872:	56 96       	adiw	r26, 0x16	; 22
    2874:	9c 91       	ld	r25, X
    2876:	29 17       	cp	r18, r25
    2878:	08 f0       	brcs	.+2      	; 0x287c <xTaskPriorityInherit+0xbc>
    287a:	80 e0       	ldi	r24, 0x00	; 0
    287c:	df 91       	pop	r29
    287e:	cf 91       	pop	r28
    2880:	1f 91       	pop	r17
    2882:	0f 91       	pop	r16
    2884:	08 95       	ret

00002886 <xTaskPriorityDisinherit>:
    2886:	0f 93       	push	r16
    2888:	1f 93       	push	r17
    288a:	cf 93       	push	r28
    288c:	df 93       	push	r29
    288e:	fc 01       	movw	r30, r24
    2890:	89 2b       	or	r24, r25
    2892:	11 f4       	brne	.+4      	; 0x2898 <xTaskPriorityDisinherit+0x12>
    2894:	80 e0       	ldi	r24, 0x00	; 0
    2896:	2c c0       	rjmp	.+88     	; 0x28f0 <xTaskPriorityDisinherit+0x6a>
    2898:	82 a1       	ldd	r24, Z+34	; 0x22
    289a:	81 50       	subi	r24, 0x01	; 1
    289c:	82 a3       	std	Z+34, r24	; 0x22
    289e:	26 89       	ldd	r18, Z+22	; 0x16
    28a0:	91 a1       	ldd	r25, Z+33	; 0x21
    28a2:	29 17       	cp	r18, r25
    28a4:	b9 f3       	breq	.-18     	; 0x2894 <xTaskPriorityDisinherit+0xe>
    28a6:	81 11       	cpse	r24, r1
    28a8:	f5 cf       	rjmp	.-22     	; 0x2894 <xTaskPriorityDisinherit+0xe>
    28aa:	ef 01       	movw	r28, r30
    28ac:	8f 01       	movw	r16, r30
    28ae:	0e 5f       	subi	r16, 0xFE	; 254
    28b0:	1f 4f       	sbci	r17, 0xFF	; 255
    28b2:	c8 01       	movw	r24, r16
    28b4:	0e 94 7c 0a 	call	0x14f8	; 0x14f8 <uxListRemove>
    28b8:	89 a1       	ldd	r24, Y+33	; 0x21
    28ba:	8e 8b       	std	Y+22, r24	; 0x16
    28bc:	48 2f       	mov	r20, r24
    28be:	50 e0       	ldi	r21, 0x00	; 0
    28c0:	24 e0       	ldi	r18, 0x04	; 4
    28c2:	30 e0       	ldi	r19, 0x00	; 0
    28c4:	24 1b       	sub	r18, r20
    28c6:	35 0b       	sbc	r19, r21
    28c8:	3d 87       	std	Y+13, r19	; 0x0d
    28ca:	2c 87       	std	Y+12, r18	; 0x0c
    28cc:	90 91 97 03 	lds	r25, 0x0397	; 0x800397 <uxTopReadyPriority>
    28d0:	98 17       	cp	r25, r24
    28d2:	10 f4       	brcc	.+4      	; 0x28d8 <xTaskPriorityDisinherit+0x52>
    28d4:	80 93 97 03 	sts	0x0397, r24	; 0x800397 <uxTopReadyPriority>
    28d8:	29 e0       	ldi	r18, 0x09	; 9
    28da:	24 9f       	mul	r18, r20
    28dc:	c0 01       	movw	r24, r0
    28de:	25 9f       	mul	r18, r21
    28e0:	90 0d       	add	r25, r0
    28e2:	11 24       	eor	r1, r1
    28e4:	b8 01       	movw	r22, r16
    28e6:	83 53       	subi	r24, 0x33	; 51
    28e8:	9c 4f       	sbci	r25, 0xFC	; 252
    28ea:	0e 94 23 0a 	call	0x1446	; 0x1446 <vListInsertEnd>
    28ee:	81 e0       	ldi	r24, 0x01	; 1
    28f0:	df 91       	pop	r29
    28f2:	cf 91       	pop	r28
    28f4:	1f 91       	pop	r17
    28f6:	0f 91       	pop	r16
    28f8:	08 95       	ret

000028fa <vTaskPriorityDisinheritAfterTimeout>:
    28fa:	0f 93       	push	r16
    28fc:	1f 93       	push	r17
    28fe:	cf 93       	push	r28
    2900:	df 93       	push	r29
    2902:	fc 01       	movw	r30, r24
    2904:	89 2b       	or	r24, r25
    2906:	d9 f1       	breq	.+118    	; 0x297e <vTaskPriorityDisinheritAfterTimeout+0x84>
    2908:	91 a1       	ldd	r25, Z+33	; 0x21
    290a:	96 17       	cp	r25, r22
    290c:	08 f4       	brcc	.+2      	; 0x2910 <vTaskPriorityDisinheritAfterTimeout+0x16>
    290e:	96 2f       	mov	r25, r22
    2910:	86 89       	ldd	r24, Z+22	; 0x16
    2912:	89 17       	cp	r24, r25
    2914:	a1 f1       	breq	.+104    	; 0x297e <vTaskPriorityDisinheritAfterTimeout+0x84>
    2916:	22 a1       	ldd	r18, Z+34	; 0x22
    2918:	21 30       	cpi	r18, 0x01	; 1
    291a:	89 f5       	brne	.+98     	; 0x297e <vTaskPriorityDisinheritAfterTimeout+0x84>
    291c:	96 8b       	std	Z+22, r25	; 0x16
    291e:	24 85       	ldd	r18, Z+12	; 0x0c
    2920:	35 85       	ldd	r19, Z+13	; 0x0d
    2922:	37 fd       	sbrc	r19, 7
    2924:	06 c0       	rjmp	.+12     	; 0x2932 <vTaskPriorityDisinheritAfterTimeout+0x38>
    2926:	24 e0       	ldi	r18, 0x04	; 4
    2928:	30 e0       	ldi	r19, 0x00	; 0
    292a:	29 1b       	sub	r18, r25
    292c:	31 09       	sbc	r19, r1
    292e:	35 87       	std	Z+13, r19	; 0x0d
    2930:	24 87       	std	Z+12, r18	; 0x0c
    2932:	29 e0       	ldi	r18, 0x09	; 9
    2934:	82 9f       	mul	r24, r18
    2936:	c0 01       	movw	r24, r0
    2938:	11 24       	eor	r1, r1
    293a:	83 53       	subi	r24, 0x33	; 51
    293c:	9c 4f       	sbci	r25, 0xFC	; 252
    293e:	22 85       	ldd	r18, Z+10	; 0x0a
    2940:	33 85       	ldd	r19, Z+11	; 0x0b
    2942:	28 17       	cp	r18, r24
    2944:	39 07       	cpc	r19, r25
    2946:	d9 f4       	brne	.+54     	; 0x297e <vTaskPriorityDisinheritAfterTimeout+0x84>
    2948:	ef 01       	movw	r28, r30
    294a:	8f 01       	movw	r16, r30
    294c:	0e 5f       	subi	r16, 0xFE	; 254
    294e:	1f 4f       	sbci	r17, 0xFF	; 255
    2950:	c8 01       	movw	r24, r16
    2952:	0e 94 7c 0a 	call	0x14f8	; 0x14f8 <uxListRemove>
    2956:	8e 89       	ldd	r24, Y+22	; 0x16
    2958:	90 91 97 03 	lds	r25, 0x0397	; 0x800397 <uxTopReadyPriority>
    295c:	98 17       	cp	r25, r24
    295e:	10 f4       	brcc	.+4      	; 0x2964 <vTaskPriorityDisinheritAfterTimeout+0x6a>
    2960:	80 93 97 03 	sts	0x0397, r24	; 0x800397 <uxTopReadyPriority>
    2964:	29 e0       	ldi	r18, 0x09	; 9
    2966:	82 9f       	mul	r24, r18
    2968:	c0 01       	movw	r24, r0
    296a:	11 24       	eor	r1, r1
    296c:	b8 01       	movw	r22, r16
    296e:	83 53       	subi	r24, 0x33	; 51
    2970:	9c 4f       	sbci	r25, 0xFC	; 252
    2972:	df 91       	pop	r29
    2974:	cf 91       	pop	r28
    2976:	1f 91       	pop	r17
    2978:	0f 91       	pop	r16
    297a:	0c 94 23 0a 	jmp	0x1446	; 0x1446 <vListInsertEnd>
    297e:	df 91       	pop	r29
    2980:	cf 91       	pop	r28
    2982:	1f 91       	pop	r17
    2984:	0f 91       	pop	r16
    2986:	08 95       	ret

00002988 <pvTaskIncrementMutexHeldCount>:

    TaskHandle_t pvTaskIncrementMutexHeldCount( void )
    {
        /* If xSemaphoreCreateMutex() is called before any tasks have been created
        then pxCurrentTCB will be NULL. */
        if( pxCurrentTCB != NULL )
    2988:	80 91 f1 03 	lds	r24, 0x03F1	; 0x8003f1 <pxCurrentTCB>
    298c:	90 91 f2 03 	lds	r25, 0x03F2	; 0x8003f2 <pxCurrentTCB+0x1>
    2990:	89 2b       	or	r24, r25
    2992:	39 f0       	breq	.+14     	; 0x29a2 <pvTaskIncrementMutexHeldCount+0x1a>
        {
            ( pxCurrentTCB->uxMutexesHeld )++;
    2994:	e0 91 f1 03 	lds	r30, 0x03F1	; 0x8003f1 <pxCurrentTCB>
    2998:	f0 91 f2 03 	lds	r31, 0x03F2	; 0x8003f2 <pxCurrentTCB+0x1>
    299c:	82 a1       	ldd	r24, Z+34	; 0x22
    299e:	8f 5f       	subi	r24, 0xFF	; 255
    29a0:	82 a3       	std	Z+34, r24	; 0x22
        }

        return pxCurrentTCB;
    29a2:	80 91 f1 03 	lds	r24, 0x03F1	; 0x8003f1 <pxCurrentTCB>
    29a6:	90 91 f2 03 	lds	r25, 0x03F2	; 0x8003f2 <pxCurrentTCB+0x1>
    }
    29aa:	08 95       	ret

000029ac <prvCheckForValidListAndQueue>:
            pxNewTimer->ucStatus = 0x00;
            prvInitialiseNewTimer( pcTimerName, xTimerPeriodInTicks, uxAutoReload, pvTimerID, pxCallbackFunction, pxNewTimer );
        }

        return pxNewTimer;
    }
    29ac:	0f b6       	in	r0, 0x3f	; 63
    29ae:	f8 94       	cli
    29b0:	0f 92       	push	r0
    29b2:	80 91 f7 03 	lds	r24, 0x03F7	; 0x8003f7 <xTimerQueue>
    29b6:	90 91 f8 03 	lds	r25, 0x03F8	; 0x8003f8 <xTimerQueue+0x1>
    29ba:	89 2b       	or	r24, r25
    29bc:	e9 f4       	brne	.+58     	; 0x29f8 <prvCheckForValidListAndQueue+0x4c>
    29be:	86 e0       	ldi	r24, 0x06	; 6
    29c0:	94 e0       	ldi	r25, 0x04	; 4
    29c2:	0e 94 11 0a 	call	0x1422	; 0x1422 <vListInitialise>
    29c6:	8d ef       	ldi	r24, 0xFD	; 253
    29c8:	93 e0       	ldi	r25, 0x03	; 3
    29ca:	0e 94 11 0a 	call	0x1422	; 0x1422 <vListInitialise>
    29ce:	86 e0       	ldi	r24, 0x06	; 6
    29d0:	94 e0       	ldi	r25, 0x04	; 4
    29d2:	90 93 fc 03 	sts	0x03FC, r25	; 0x8003fc <pxCurrentTimerList+0x1>
    29d6:	80 93 fb 03 	sts	0x03FB, r24	; 0x8003fb <pxCurrentTimerList>
    29da:	8d ef       	ldi	r24, 0xFD	; 253
    29dc:	93 e0       	ldi	r25, 0x03	; 3
    29de:	90 93 fa 03 	sts	0x03FA, r25	; 0x8003fa <pxOverflowTimerList+0x1>
    29e2:	80 93 f9 03 	sts	0x03F9, r24	; 0x8003f9 <pxOverflowTimerList>
    29e6:	40 e0       	ldi	r20, 0x00	; 0
    29e8:	65 e0       	ldi	r22, 0x05	; 5
    29ea:	8a e0       	ldi	r24, 0x0A	; 10
    29ec:	0e 94 f2 0c 	call	0x19e4	; 0x19e4 <xQueueGenericCreate>
    29f0:	90 93 f8 03 	sts	0x03F8, r25	; 0x8003f8 <xTimerQueue+0x1>
    29f4:	80 93 f7 03 	sts	0x03F7, r24	; 0x8003f7 <xTimerQueue>
    29f8:	0f 90       	pop	r0
    29fa:	0f be       	out	0x3f, r0	; 63
    29fc:	08 95       	ret

000029fe <prvInsertTimerInActiveList>:
    29fe:	fc 01       	movw	r30, r24
    2a00:	73 83       	std	Z+3, r23	; 0x03
    2a02:	62 83       	std	Z+2, r22	; 0x02
    2a04:	91 87       	std	Z+9, r25	; 0x09
    2a06:	80 87       	std	Z+8, r24	; 0x08
    2a08:	46 17       	cp	r20, r22
    2a0a:	57 07       	cpc	r21, r23
    2a0c:	78 f0       	brcs	.+30     	; 0x2a2c <prvInsertTimerInActiveList+0x2e>
    2a0e:	42 1b       	sub	r20, r18
    2a10:	53 0b       	sbc	r21, r19
    2a12:	84 85       	ldd	r24, Z+12	; 0x0c
    2a14:	95 85       	ldd	r25, Z+13	; 0x0d
    2a16:	48 17       	cp	r20, r24
    2a18:	59 07       	cpc	r21, r25
    2a1a:	c8 f4       	brcc	.+50     	; 0x2a4e <prvInsertTimerInActiveList+0x50>
    2a1c:	bf 01       	movw	r22, r30
    2a1e:	6e 5f       	subi	r22, 0xFE	; 254
    2a20:	7f 4f       	sbci	r23, 0xFF	; 255
    2a22:	80 91 f9 03 	lds	r24, 0x03F9	; 0x8003f9 <pxOverflowTimerList>
    2a26:	90 91 fa 03 	lds	r25, 0x03FA	; 0x8003fa <pxOverflowTimerList+0x1>
    2a2a:	0d c0       	rjmp	.+26     	; 0x2a46 <prvInsertTimerInActiveList+0x48>
    2a2c:	42 17       	cp	r20, r18
    2a2e:	53 07       	cpc	r21, r19
    2a30:	18 f4       	brcc	.+6      	; 0x2a38 <prvInsertTimerInActiveList+0x3a>
    2a32:	62 17       	cp	r22, r18
    2a34:	73 07       	cpc	r23, r19
    2a36:	58 f4       	brcc	.+22     	; 0x2a4e <prvInsertTimerInActiveList+0x50>
    2a38:	bf 01       	movw	r22, r30
    2a3a:	6e 5f       	subi	r22, 0xFE	; 254
    2a3c:	7f 4f       	sbci	r23, 0xFF	; 255
    2a3e:	80 91 fb 03 	lds	r24, 0x03FB	; 0x8003fb <pxCurrentTimerList>
    2a42:	90 91 fc 03 	lds	r25, 0x03FC	; 0x8003fc <pxCurrentTimerList+0x1>
    2a46:	0e 94 44 0a 	call	0x1488	; 0x1488 <vListInsert>
    2a4a:	80 e0       	ldi	r24, 0x00	; 0
    2a4c:	08 95       	ret
    2a4e:	81 e0       	ldi	r24, 0x01	; 1
    2a50:	08 95       	ret

00002a52 <xTimerCreateTimerTask>:
    2a52:	ef 92       	push	r14
    2a54:	ff 92       	push	r15
    2a56:	0f 93       	push	r16
    2a58:	0e 94 d6 14 	call	0x29ac	; 0x29ac <prvCheckForValidListAndQueue>
    2a5c:	80 91 f7 03 	lds	r24, 0x03F7	; 0x8003f7 <xTimerQueue>
    2a60:	90 91 f8 03 	lds	r25, 0x03F8	; 0x8003f8 <xTimerQueue+0x1>
    2a64:	89 2b       	or	r24, r25
    2a66:	81 f0       	breq	.+32     	; 0x2a88 <xTimerCreateTimerTask+0x36>
    2a68:	85 ef       	ldi	r24, 0xF5	; 245
    2a6a:	e8 2e       	mov	r14, r24
    2a6c:	83 e0       	ldi	r24, 0x03	; 3
    2a6e:	f8 2e       	mov	r15, r24
    2a70:	03 e0       	ldi	r16, 0x03	; 3
    2a72:	20 e0       	ldi	r18, 0x00	; 0
    2a74:	30 e0       	ldi	r19, 0x00	; 0
    2a76:	45 e5       	ldi	r20, 0x55	; 85
    2a78:	50 e0       	ldi	r21, 0x00	; 0
    2a7a:	6b e0       	ldi	r22, 0x0B	; 11
    2a7c:	72 e0       	ldi	r23, 0x02	; 2
    2a7e:	89 ed       	ldi	r24, 0xD9	; 217
    2a80:	95 e1       	ldi	r25, 0x15	; 21
    2a82:	0e 94 17 10 	call	0x202e	; 0x202e <xTaskCreate>
    2a86:	01 c0       	rjmp	.+2      	; 0x2a8a <xTimerCreateTimerTask+0x38>
    2a88:	80 e0       	ldi	r24, 0x00	; 0
    2a8a:	0f 91       	pop	r16
    2a8c:	ff 90       	pop	r15
    2a8e:	ef 90       	pop	r14
    2a90:	08 95       	ret

00002a92 <xTimerGenericCommand>:
    }
}
/*-----------------------------------------------------------*/

BaseType_t xTimerGenericCommand( TimerHandle_t xTimer, const BaseType_t xCommandID, const TickType_t xOptionalValue, BaseType_t * const pxHigherPriorityTaskWoken, const TickType_t xTicksToWait )
{
    2a92:	0f 93       	push	r16
    2a94:	1f 93       	push	r17
    2a96:	cf 93       	push	r28
    2a98:	df 93       	push	r29
    2a9a:	00 d0       	rcall	.+0      	; 0x2a9c <xTimerGenericCommand+0xa>
    2a9c:	00 d0       	rcall	.+0      	; 0x2a9e <xTimerGenericCommand+0xc>
    2a9e:	1f 92       	push	r1
    2aa0:	cd b7       	in	r28, 0x3d	; 61
    2aa2:	de b7       	in	r29, 0x3e	; 62

    configASSERT( xTimer );

    /* Send a message to the timer service task to perform a particular action
    on a particular timer definition. */
    if( xTimerQueue != NULL )
    2aa4:	a0 91 f7 03 	lds	r26, 0x03F7	; 0x8003f7 <xTimerQueue>
    2aa8:	b0 91 f8 03 	lds	r27, 0x03F8	; 0x8003f8 <xTimerQueue+0x1>
    2aac:	10 97       	sbiw	r26, 0x00	; 0
    2aae:	29 f1       	breq	.+74     	; 0x2afa <xTimerGenericCommand+0x68>
    2ab0:	f9 01       	movw	r30, r18
    {
        /* Send a command to the timer service task to start the xTimer timer. */
        xMessage.xMessageID = xCommandID;
    2ab2:	69 83       	std	Y+1, r22	; 0x01
        xMessage.u.xTimerParameters.xMessageValue = xOptionalValue;
    2ab4:	5b 83       	std	Y+3, r21	; 0x03
    2ab6:	4a 83       	std	Y+2, r20	; 0x02
        xMessage.u.xTimerParameters.pxTimer = xTimer;
    2ab8:	9d 83       	std	Y+5, r25	; 0x05
    2aba:	8c 83       	std	Y+4, r24	; 0x04

        if( xCommandID < tmrFIRST_FROM_ISR_COMMAND )
    2abc:	66 30       	cpi	r22, 0x06	; 6
    2abe:	a4 f4       	brge	.+40     	; 0x2ae8 <xTimerGenericCommand+0x56>
        {
            if( xTaskGetSchedulerState() == taskSCHEDULER_RUNNING )
    2ac0:	0e 94 d2 13 	call	0x27a4	; 0x27a4 <xTaskGetSchedulerState>
    2ac4:	e0 91 f7 03 	lds	r30, 0x03F7	; 0x8003f7 <xTimerQueue>
    2ac8:	f0 91 f8 03 	lds	r31, 0x03F8	; 0x8003f8 <xTimerQueue+0x1>
            {
                xReturn = xQueueSendToBack( xTimerQueue, &xMessage, xTicksToWait );
    2acc:	20 e0       	ldi	r18, 0x00	; 0
        xMessage.u.xTimerParameters.xMessageValue = xOptionalValue;
        xMessage.u.xTimerParameters.pxTimer = xTimer;

        if( xCommandID < tmrFIRST_FROM_ISR_COMMAND )
        {
            if( xTaskGetSchedulerState() == taskSCHEDULER_RUNNING )
    2ace:	82 30       	cpi	r24, 0x02	; 2
    2ad0:	11 f4       	brne	.+4      	; 0x2ad6 <xTimerGenericCommand+0x44>
            {
                xReturn = xQueueSendToBack( xTimerQueue, &xMessage, xTicksToWait );
    2ad2:	a8 01       	movw	r20, r16
    2ad4:	02 c0       	rjmp	.+4      	; 0x2ada <xTimerGenericCommand+0x48>
            }
            else
            {
                xReturn = xQueueSendToBack( xTimerQueue, &xMessage, tmrNO_DELAY );
    2ad6:	40 e0       	ldi	r20, 0x00	; 0
    2ad8:	50 e0       	ldi	r21, 0x00	; 0
    2ada:	be 01       	movw	r22, r28
    2adc:	6f 5f       	subi	r22, 0xFF	; 255
    2ade:	7f 4f       	sbci	r23, 0xFF	; 255
    2ae0:	cf 01       	movw	r24, r30
    2ae2:	0e 94 1a 0d 	call	0x1a34	; 0x1a34 <xQueueGenericSend>
    2ae6:	0a c0       	rjmp	.+20     	; 0x2afc <xTimerGenericCommand+0x6a>
            }
        }
        else
        {
            xReturn = xQueueSendToBackFromISR( xTimerQueue, &xMessage, pxHigherPriorityTaskWoken );
    2ae8:	20 e0       	ldi	r18, 0x00	; 0
    2aea:	af 01       	movw	r20, r30
    2aec:	be 01       	movw	r22, r28
    2aee:	6f 5f       	subi	r22, 0xFF	; 255
    2af0:	7f 4f       	sbci	r23, 0xFF	; 255
    2af2:	cd 01       	movw	r24, r26
    2af4:	0e 94 b0 0d 	call	0x1b60	; 0x1b60 <xQueueGenericSendFromISR>
    2af8:	01 c0       	rjmp	.+2      	; 0x2afc <xTimerGenericCommand+0x6a>
}
/*-----------------------------------------------------------*/

BaseType_t xTimerGenericCommand( TimerHandle_t xTimer, const BaseType_t xCommandID, const TickType_t xOptionalValue, BaseType_t * const pxHigherPriorityTaskWoken, const TickType_t xTicksToWait )
{
BaseType_t xReturn = pdFAIL;
    2afa:	80 e0       	ldi	r24, 0x00	; 0
    {
        mtCOVERAGE_TEST_MARKER();
    }

    return xReturn;
}
    2afc:	0f 90       	pop	r0
    2afe:	0f 90       	pop	r0
    2b00:	0f 90       	pop	r0
    2b02:	0f 90       	pop	r0
    2b04:	0f 90       	pop	r0
    2b06:	df 91       	pop	r29
    2b08:	cf 91       	pop	r28
    2b0a:	1f 91       	pop	r17
    2b0c:	0f 91       	pop	r16
    2b0e:	08 95       	ret

00002b10 <prvSwitchTimerLists>:
    }
}
/*-----------------------------------------------------------*/

static void prvSwitchTimerLists( void )
{
    2b10:	ef 92       	push	r14
    2b12:	ff 92       	push	r15
    2b14:	0f 93       	push	r16
    2b16:	1f 93       	push	r17
    2b18:	cf 93       	push	r28
    2b1a:	df 93       	push	r29

    /* The tick count has overflowed.  The timer lists must be switched.
    If there are any timers still referenced from the current timer list
    then they must have expired and should be processed before the lists
    are switched. */
    while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
    2b1c:	e0 91 fb 03 	lds	r30, 0x03FB	; 0x8003fb <pxCurrentTimerList>
    2b20:	f0 91 fc 03 	lds	r31, 0x03FC	; 0x8003fc <pxCurrentTimerList+0x1>
    2b24:	80 81       	ld	r24, Z
    2b26:	88 23       	and	r24, r24
    2b28:	89 f1       	breq	.+98     	; 0x2b8c <prvSwitchTimerLists+0x7c>
    {
        xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
    2b2a:	05 80       	ldd	r0, Z+5	; 0x05
    2b2c:	f6 81       	ldd	r31, Z+6	; 0x06
    2b2e:	e0 2d       	mov	r30, r0
    2b30:	e0 80       	ld	r14, Z
    2b32:	f1 80       	ldd	r15, Z+1	; 0x01

        /* Remove the timer from the list. */
        pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList ); /*lint !e9087 !e9079 void * is used as this macro is used with tasks and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    2b34:	c6 81       	ldd	r28, Z+6	; 0x06
    2b36:	d7 81       	ldd	r29, Z+7	; 0x07
        ( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
    2b38:	8e 01       	movw	r16, r28
    2b3a:	0e 5f       	subi	r16, 0xFE	; 254
    2b3c:	1f 4f       	sbci	r17, 0xFF	; 255
    2b3e:	c8 01       	movw	r24, r16
    2b40:	0e 94 7c 0a 	call	0x14f8	; 0x14f8 <uxListRemove>
        traceTIMER_EXPIRED( pxTimer );

        /* Execute its callback, then send a command to restart the timer if
        it is an auto-reload timer.  It cannot be restarted here as the lists
        have not yet been switched. */
        pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
    2b44:	e8 89       	ldd	r30, Y+16	; 0x10
    2b46:	f9 89       	ldd	r31, Y+17	; 0x11
    2b48:	ce 01       	movw	r24, r28
    2b4a:	09 95       	icall

        if( ( pxTimer->ucStatus & tmrSTATUS_IS_AUTORELOAD ) != 0 )
    2b4c:	8a 89       	ldd	r24, Y+18	; 0x12
    2b4e:	82 ff       	sbrs	r24, 2
    2b50:	e5 cf       	rjmp	.-54     	; 0x2b1c <prvSwitchTimerLists+0xc>
            the timer going into the same timer list then it has already expired
            and the timer should be re-inserted into the current list so it is
            processed again within this loop.  Otherwise a command should be sent
            to restart the timer to ensure it is only inserted into a list after
            the lists have been swapped. */
            xReloadTime = ( xNextExpireTime + pxTimer->xTimerPeriodInTicks );
    2b52:	8c 85       	ldd	r24, Y+12	; 0x0c
    2b54:	9d 85       	ldd	r25, Y+13	; 0x0d
    2b56:	8e 0d       	add	r24, r14
    2b58:	9f 1d       	adc	r25, r15
            if( xReloadTime > xNextExpireTime )
    2b5a:	e8 16       	cp	r14, r24
    2b5c:	f9 06       	cpc	r15, r25
    2b5e:	60 f4       	brcc	.+24     	; 0x2b78 <prvSwitchTimerLists+0x68>
            {
                listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xReloadTime );
    2b60:	9b 83       	std	Y+3, r25	; 0x03
    2b62:	8a 83       	std	Y+2, r24	; 0x02
                listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
    2b64:	d9 87       	std	Y+9, r29	; 0x09
    2b66:	c8 87       	std	Y+8, r28	; 0x08
                vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
    2b68:	b8 01       	movw	r22, r16
    2b6a:	80 91 fb 03 	lds	r24, 0x03FB	; 0x8003fb <pxCurrentTimerList>
    2b6e:	90 91 fc 03 	lds	r25, 0x03FC	; 0x8003fc <pxCurrentTimerList+0x1>
    2b72:	0e 94 44 0a 	call	0x1488	; 0x1488 <vListInsert>
    2b76:	d2 cf       	rjmp	.-92     	; 0x2b1c <prvSwitchTimerLists+0xc>
            }
            else
            {
                xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY );
    2b78:	00 e0       	ldi	r16, 0x00	; 0
    2b7a:	10 e0       	ldi	r17, 0x00	; 0
    2b7c:	20 e0       	ldi	r18, 0x00	; 0
    2b7e:	30 e0       	ldi	r19, 0x00	; 0
    2b80:	a7 01       	movw	r20, r14
    2b82:	60 e0       	ldi	r22, 0x00	; 0
    2b84:	ce 01       	movw	r24, r28
    2b86:	0e 94 49 15 	call	0x2a92	; 0x2a92 <xTimerGenericCommand>
    2b8a:	c8 cf       	rjmp	.-112    	; 0x2b1c <prvSwitchTimerLists+0xc>
            mtCOVERAGE_TEST_MARKER();
        }
    }

    pxTemp = pxCurrentTimerList;
    pxCurrentTimerList = pxOverflowTimerList;
    2b8c:	80 91 f9 03 	lds	r24, 0x03F9	; 0x8003f9 <pxOverflowTimerList>
    2b90:	90 91 fa 03 	lds	r25, 0x03FA	; 0x8003fa <pxOverflowTimerList+0x1>
    2b94:	90 93 fc 03 	sts	0x03FC, r25	; 0x8003fc <pxCurrentTimerList+0x1>
    2b98:	80 93 fb 03 	sts	0x03FB, r24	; 0x8003fb <pxCurrentTimerList>
    pxOverflowTimerList = pxTemp;
    2b9c:	f0 93 fa 03 	sts	0x03FA, r31	; 0x8003fa <pxOverflowTimerList+0x1>
    2ba0:	e0 93 f9 03 	sts	0x03F9, r30	; 0x8003f9 <pxOverflowTimerList>
}
    2ba4:	df 91       	pop	r29
    2ba6:	cf 91       	pop	r28
    2ba8:	1f 91       	pop	r17
    2baa:	0f 91       	pop	r16
    2bac:	ff 90       	pop	r15
    2bae:	ef 90       	pop	r14
    2bb0:	08 95       	ret

00002bb2 <prvTimerTask>:
    pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
}
/*-----------------------------------------------------------*/

static portTASK_FUNCTION( prvTimerTask, pvParameters )
{
    2bb2:	cf 93       	push	r28
    2bb4:	df 93       	push	r29
    2bb6:	00 d0       	rcall	.+0      	; 0x2bb8 <prvTimerTask+0x6>
    2bb8:	00 d0       	rcall	.+0      	; 0x2bba <prvTimerTask+0x8>
    2bba:	1f 92       	push	r1
    2bbc:	cd b7       	in	r28, 0x3d	; 61
    2bbe:	de b7       	in	r29, 0x3e	; 62
    the timer with the nearest expiry time will expire.  If there are no
    active timers then just set the next expire time to 0.  That will cause
    this task to unblock when the tick count overflows, at which point the
    timer lists will be switched and the next expiry time can be
    re-assessed.  */
    *pxListWasEmpty = listLIST_IS_EMPTY( pxCurrentTimerList );
    2bc0:	e0 91 fb 03 	lds	r30, 0x03FB	; 0x8003fb <pxCurrentTimerList>
    2bc4:	f0 91 fc 03 	lds	r31, 0x03FC	; 0x8003fc <pxCurrentTimerList+0x1>
    2bc8:	d0 80       	ld	r13, Z
    if( *pxListWasEmpty == pdFALSE )
    2bca:	dd 20       	and	r13, r13
    2bcc:	31 f0       	breq	.+12     	; 0x2bda <prvTimerTask+0x28>
    {
        xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
    2bce:	05 80       	ldd	r0, Z+5	; 0x05
    2bd0:	f6 81       	ldd	r31, Z+6	; 0x06
    2bd2:	e0 2d       	mov	r30, r0
    2bd4:	e0 80       	ld	r14, Z
    2bd6:	f1 80       	ldd	r15, Z+1	; 0x01
    2bd8:	02 c0       	rjmp	.+4      	; 0x2bde <prvTimerTask+0x2c>
    }
    else
    {
        /* Ensure the task unblocks when the tick count rolls over. */
        xNextExpireTime = ( TickType_t ) 0U;
    2bda:	e1 2c       	mov	r14, r1
    2bdc:	f1 2c       	mov	r15, r1
static void prvProcessTimerOrBlockTask( const TickType_t xNextExpireTime, BaseType_t xListWasEmpty )
{
TickType_t xTimeNow;
BaseType_t xTimerListsWereSwitched;

    vTaskSuspendAll();
    2bde:	0e 94 51 11 	call	0x22a2	; 0x22a2 <vTaskSuspendAll>
static TickType_t prvSampleTimeNow( BaseType_t * const pxTimerListsWereSwitched )
{
TickType_t xTimeNow;
PRIVILEGED_DATA static TickType_t xLastTime = ( TickType_t ) 0U; /*lint !e956 Variable is only accessible to one task. */

    xTimeNow = xTaskGetTickCount();
    2be2:	0e 94 57 11 	call	0x22ae	; 0x22ae <xTaskGetTickCount>
    2be6:	8c 01       	movw	r16, r24

    if( xTimeNow < xLastTime )
    2be8:	80 91 f3 03 	lds	r24, 0x03F3	; 0x8003f3 <xLastTime.2412>
    2bec:	90 91 f4 03 	lds	r25, 0x03F4	; 0x8003f4 <xLastTime.2412+0x1>
    2bf0:	08 17       	cp	r16, r24
    2bf2:	19 07       	cpc	r17, r25
    2bf4:	20 f4       	brcc	.+8      	; 0x2bfe <prvTimerTask+0x4c>
    {
        prvSwitchTimerLists();
    2bf6:	0e 94 88 15 	call	0x2b10	; 0x2b10 <prvSwitchTimerLists>
        *pxTimerListsWereSwitched = pdTRUE;
    2bfa:	81 e0       	ldi	r24, 0x01	; 1
    2bfc:	01 c0       	rjmp	.+2      	; 0x2c00 <prvTimerTask+0x4e>
    }
    else
    {
        *pxTimerListsWereSwitched = pdFALSE;
    2bfe:	80 e0       	ldi	r24, 0x00	; 0
    }

    xLastTime = xTimeNow;
    2c00:	10 93 f4 03 	sts	0x03F4, r17	; 0x8003f4 <xLastTime.2412+0x1>
    2c04:	00 93 f3 03 	sts	0x03F3, r16	; 0x8003f3 <xLastTime.2412>
        has expired or not.  If obtaining the time causes the lists to switch
        then don't process this timer as any timers that remained in the list
        when the lists were switched will have been processed within the
        prvSampleTimeNow() function. */
        xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
        if( xTimerListsWereSwitched == pdFALSE )
    2c08:	81 11       	cpse	r24, r1
    2c0a:	55 c0       	rjmp	.+170    	; 0x2cb6 <prvTimerTask+0x104>
        {
            /* The tick count has not overflowed, has the timer expired? */
            if( ( xListWasEmpty == pdFALSE ) && ( xNextExpireTime <= xTimeNow ) )
    2c0c:	dd 20       	and	r13, r13
    2c0e:	d9 f1       	breq	.+118    	; 0x2c86 <prvTimerTask+0xd4>
    2c10:	0e 15       	cp	r16, r14
    2c12:	1f 05       	cpc	r17, r15
    2c14:	08 f4       	brcc	.+2      	; 0x2c18 <prvTimerTask+0x66>
    2c16:	3e c0       	rjmp	.+124    	; 0x2c94 <prvTimerTask+0xe2>
            {
                ( void ) xTaskResumeAll();
    2c18:	0e 94 0d 12 	call	0x241a	; 0x241a <xTaskResumeAll>
/*-----------------------------------------------------------*/

static void prvProcessExpiredTimer( const TickType_t xNextExpireTime, const TickType_t xTimeNow )
{
BaseType_t xResult;
Timer_t * const pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList ); /*lint !e9087 !e9079 void * is used as this macro is used with tasks and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    2c1c:	e0 91 fb 03 	lds	r30, 0x03FB	; 0x8003fb <pxCurrentTimerList>
    2c20:	f0 91 fc 03 	lds	r31, 0x03FC	; 0x8003fc <pxCurrentTimerList+0x1>
    2c24:	05 80       	ldd	r0, Z+5	; 0x05
    2c26:	f6 81       	ldd	r31, Z+6	; 0x06
    2c28:	e0 2d       	mov	r30, r0
    2c2a:	c6 80       	ldd	r12, Z+6	; 0x06
    2c2c:	d7 80       	ldd	r13, Z+7	; 0x07

    /* Remove the timer from the list of active timers.  A check has already
    been performed to ensure the list is not empty. */
    ( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
    2c2e:	c6 01       	movw	r24, r12
    2c30:	02 96       	adiw	r24, 0x02	; 2
    2c32:	0e 94 7c 0a 	call	0x14f8	; 0x14f8 <uxListRemove>
    traceTIMER_EXPIRED( pxTimer );

    /* If the timer is an auto reload timer then calculate the next
    expiry time and re-insert the timer in the list of active timers. */
    if( ( pxTimer->ucStatus & tmrSTATUS_IS_AUTORELOAD ) != 0 )
    2c36:	d6 01       	movw	r26, r12
    2c38:	52 96       	adiw	r26, 0x12	; 18
    2c3a:	8c 91       	ld	r24, X
    2c3c:	52 97       	sbiw	r26, 0x12	; 18
    2c3e:	82 ff       	sbrs	r24, 2
    2c40:	17 c0       	rjmp	.+46     	; 0x2c70 <prvTimerTask+0xbe>
    {
        /* The timer is inserted into a list using a time relative to anything
        other than the current time.  It will therefore be inserted into the
        correct list relative to the time this task thinks it is now. */
        if( prvInsertTimerInActiveList( pxTimer, ( xNextExpireTime + pxTimer->xTimerPeriodInTicks ), xTimeNow, xNextExpireTime ) != pdFALSE )
    2c42:	1c 96       	adiw	r26, 0x0c	; 12
    2c44:	6d 91       	ld	r22, X+
    2c46:	7c 91       	ld	r23, X
    2c48:	1d 97       	sbiw	r26, 0x0d	; 13
    2c4a:	6e 0d       	add	r22, r14
    2c4c:	7f 1d       	adc	r23, r15
    2c4e:	97 01       	movw	r18, r14
    2c50:	a8 01       	movw	r20, r16
    2c52:	c6 01       	movw	r24, r12
    2c54:	0e 94 ff 14 	call	0x29fe	; 0x29fe <prvInsertTimerInActiveList>
    2c58:	88 23       	and	r24, r24
    2c5a:	69 f0       	breq	.+26     	; 0x2c76 <prvTimerTask+0xc4>
        {
            /* The timer expired before it was added to the active timer
            list.  Reload it now.  */
            xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY );
    2c5c:	00 e0       	ldi	r16, 0x00	; 0
    2c5e:	10 e0       	ldi	r17, 0x00	; 0
    2c60:	20 e0       	ldi	r18, 0x00	; 0
    2c62:	30 e0       	ldi	r19, 0x00	; 0
    2c64:	a7 01       	movw	r20, r14
    2c66:	60 e0       	ldi	r22, 0x00	; 0
    2c68:	c6 01       	movw	r24, r12
    2c6a:	0e 94 49 15 	call	0x2a92	; 0x2a92 <xTimerGenericCommand>
    2c6e:	03 c0       	rjmp	.+6      	; 0x2c76 <prvTimerTask+0xc4>
            mtCOVERAGE_TEST_MARKER();
        }
    }
    else
    {
        pxTimer->ucStatus &= ~tmrSTATUS_IS_ACTIVE;
    2c70:	8e 7f       	andi	r24, 0xFE	; 254
    2c72:	f6 01       	movw	r30, r12
    2c74:	82 8b       	std	Z+18, r24	; 0x12
        mtCOVERAGE_TEST_MARKER();
    }

    /* Call the timer callback. */
    pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
    2c76:	d6 01       	movw	r26, r12
    2c78:	50 96       	adiw	r26, 0x10	; 16
    2c7a:	ed 91       	ld	r30, X+
    2c7c:	fc 91       	ld	r31, X
    2c7e:	51 97       	sbiw	r26, 0x11	; 17
    2c80:	c6 01       	movw	r24, r12
    2c82:	09 95       	icall
    2c84:	1e c0       	rjmp	.+60     	; 0x2cc2 <prvTimerTask+0x110>
                case when the current timer list is empty. */
                if( xListWasEmpty != pdFALSE )
                {
                    /* The current timer list is empty - is the overflow list
                    also empty? */
                    xListWasEmpty = listLIST_IS_EMPTY( pxOverflowTimerList );
    2c86:	e0 91 f9 03 	lds	r30, 0x03F9	; 0x8003f9 <pxOverflowTimerList>
    2c8a:	f0 91 fa 03 	lds	r31, 0x03FA	; 0x8003fa <pxOverflowTimerList+0x1>
    2c8e:	80 81       	ld	r24, Z
    2c90:	41 e0       	ldi	r20, 0x01	; 1
    2c92:	81 11       	cpse	r24, r1
        prvSampleTimeNow() function. */
        xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
        if( xTimerListsWereSwitched == pdFALSE )
        {
            /* The tick count has not overflowed, has the timer expired? */
            if( ( xListWasEmpty == pdFALSE ) && ( xNextExpireTime <= xTimeNow ) )
    2c94:	40 e0       	ldi	r20, 0x00	; 0
                    /* The current timer list is empty - is the overflow list
                    also empty? */
                    xListWasEmpty = listLIST_IS_EMPTY( pxOverflowTimerList );
                }

                vQueueWaitForMessageRestricted( xTimerQueue, ( xNextExpireTime - xTimeNow ), xListWasEmpty );
    2c96:	b7 01       	movw	r22, r14
    2c98:	60 1b       	sub	r22, r16
    2c9a:	71 0b       	sbc	r23, r17
    2c9c:	80 91 f7 03 	lds	r24, 0x03F7	; 0x8003f7 <xTimerQueue>
    2ca0:	90 91 f8 03 	lds	r25, 0x03F8	; 0x8003f8 <xTimerQueue+0x1>
    2ca4:	0e 94 56 0f 	call	0x1eac	; 0x1eac <vQueueWaitForMessageRestricted>

                if( xTaskResumeAll() == pdFALSE )
    2ca8:	0e 94 0d 12 	call	0x241a	; 0x241a <xTaskResumeAll>
    2cac:	81 11       	cpse	r24, r1
    2cae:	09 c0       	rjmp	.+18     	; 0x2cc2 <prvTimerTask+0x110>
                {
                    /* Yield to wait for either a command to arrive, or the
                    block time to expire.  If a command arrived between the
                    critical section being exited and this yield then the yield
                    will not cause the task to block. */
                    portYIELD_WITHIN_API();
    2cb0:	0e 94 44 0b 	call	0x1688	; 0x1688 <vPortYield>
    2cb4:	06 c0       	rjmp	.+12     	; 0x2cc2 <prvTimerTask+0x110>
                }
            }
        }
        else
        {
            ( void ) xTaskResumeAll();
    2cb6:	0e 94 0d 12 	call	0x241a	; 0x241a <xTaskResumeAll>
    2cba:	03 c0       	rjmp	.+6      	; 0x2cc2 <prvTimerTask+0x110>
        }
        #endif /* INCLUDE_xTimerPendFunctionCall */

        /* Commands that are positive are timer commands rather than pended
        function calls. */
        if( xMessage.xMessageID >= ( BaseType_t ) 0 )
    2cbc:	89 81       	ldd	r24, Y+1	; 0x01
    2cbe:	87 ff       	sbrs	r24, 7
    2cc0:	0e c0       	rjmp	.+28     	; 0x2cde <prvTimerTask+0x12c>
DaemonTaskMessage_t xMessage;
Timer_t *pxTimer;
BaseType_t xTimerListsWereSwitched, xResult;
TickType_t xTimeNow;

    while( xQueueReceive( xTimerQueue, &xMessage, tmrNO_DELAY ) != pdFAIL ) /*lint !e603 xMessage does not have to be initialised as it is passed out, not in, and it is not used unless xQueueReceive() returns pdTRUE. */
    2cc2:	40 e0       	ldi	r20, 0x00	; 0
    2cc4:	50 e0       	ldi	r21, 0x00	; 0
    2cc6:	be 01       	movw	r22, r28
    2cc8:	6f 5f       	subi	r22, 0xFF	; 255
    2cca:	7f 4f       	sbci	r23, 0xFF	; 255
    2ccc:	80 91 f7 03 	lds	r24, 0x03F7	; 0x8003f7 <xTimerQueue>
    2cd0:	90 91 f8 03 	lds	r25, 0x03F8	; 0x8003f8 <xTimerQueue+0x1>
    2cd4:	0e 94 02 0e 	call	0x1c04	; 0x1c04 <xQueueReceive>
    2cd8:	81 11       	cpse	r24, r1
    2cda:	f0 cf       	rjmp	.-32     	; 0x2cbc <prvTimerTask+0x10a>
    2cdc:	71 cf       	rjmp	.-286    	; 0x2bc0 <prvTimerTask+0xe>
        function calls. */
        if( xMessage.xMessageID >= ( BaseType_t ) 0 )
        {
            /* The messages uses the xTimerParameters member to work on a
            software timer. */
            pxTimer = xMessage.u.xTimerParameters.pxTimer;
    2cde:	ec 80       	ldd	r14, Y+4	; 0x04
    2ce0:	fd 80       	ldd	r15, Y+5	; 0x05

        if( listIS_CONTAINED_WITHIN( NULL, &( pxTimer->xTimerListItem ) ) == pdFALSE ) /*lint !e961. The cast is only redundant when NULL is passed into the macro. */
    2ce2:	f7 01       	movw	r30, r14
    2ce4:	82 85       	ldd	r24, Z+10	; 0x0a
    2ce6:	93 85       	ldd	r25, Z+11	; 0x0b
    2ce8:	89 2b       	or	r24, r25
    2cea:	21 f0       	breq	.+8      	; 0x2cf4 <prvTimerTask+0x142>
            {
                /* The timer is in a list, remove it. */
                ( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
    2cec:	c7 01       	movw	r24, r14
    2cee:	02 96       	adiw	r24, 0x02	; 2
    2cf0:	0e 94 7c 0a 	call	0x14f8	; 0x14f8 <uxListRemove>
static TickType_t prvSampleTimeNow( BaseType_t * const pxTimerListsWereSwitched )
{
TickType_t xTimeNow;
PRIVILEGED_DATA static TickType_t xLastTime = ( TickType_t ) 0U; /*lint !e956 Variable is only accessible to one task. */

    xTimeNow = xTaskGetTickCount();
    2cf4:	0e 94 57 11 	call	0x22ae	; 0x22ae <xTaskGetTickCount>
    2cf8:	6c 01       	movw	r12, r24

    if( xTimeNow < xLastTime )
    2cfa:	80 91 f3 03 	lds	r24, 0x03F3	; 0x8003f3 <xLastTime.2412>
    2cfe:	90 91 f4 03 	lds	r25, 0x03F4	; 0x8003f4 <xLastTime.2412+0x1>
    2d02:	c8 16       	cp	r12, r24
    2d04:	d9 06       	cpc	r13, r25
    2d06:	10 f4       	brcc	.+4      	; 0x2d0c <prvTimerTask+0x15a>
    {
        prvSwitchTimerLists();
    2d08:	0e 94 88 15 	call	0x2b10	; 0x2b10 <prvSwitchTimerLists>
    else
    {
        *pxTimerListsWereSwitched = pdFALSE;
    }

    xLastTime = xTimeNow;
    2d0c:	d0 92 f4 03 	sts	0x03F4, r13	; 0x8003f4 <xLastTime.2412+0x1>
    2d10:	c0 92 f3 03 	sts	0x03F3, r12	; 0x8003f3 <xLastTime.2412>
            possibility of a higher priority task adding a message to the message
            queue with a time that is ahead of the timer daemon task (because it
            pre-empted the timer daemon task after the xTimeNow value was set). */
            xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );

            switch( xMessage.xMessageID )
    2d14:	e9 81       	ldd	r30, Y+1	; 0x01
    2d16:	0e 2e       	mov	r0, r30
    2d18:	00 0c       	add	r0, r0
    2d1a:	ff 0b       	sbc	r31, r31
    2d1c:	ea 30       	cpi	r30, 0x0A	; 10
    2d1e:	f1 05       	cpc	r31, r1
    2d20:	80 f6       	brcc	.-96     	; 0x2cc2 <prvTimerTask+0x110>
    2d22:	ec 5c       	subi	r30, 0xCC	; 204
    2d24:	ff 4f       	sbci	r31, 0xFF	; 255
    2d26:	d7 01       	movw	r26, r14
    2d28:	52 96       	adiw	r26, 0x12	; 18
    2d2a:	8c 91       	ld	r24, X
    2d2c:	0c 94 4b 24 	jmp	0x4896	; 0x4896 <__tablejump2__>
                case tmrCOMMAND_START_FROM_ISR :
                case tmrCOMMAND_RESET :
                case tmrCOMMAND_RESET_FROM_ISR :
                case tmrCOMMAND_START_DONT_TRACE :
                    /* Start or restart a timer. */
                    pxTimer->ucStatus |= tmrSTATUS_IS_ACTIVE;
    2d30:	81 60       	ori	r24, 0x01	; 1
    2d32:	f7 01       	movw	r30, r14
    2d34:	82 8b       	std	Z+18, r24	; 0x12
                    if( prvInsertTimerInActiveList( pxTimer,  xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, xTimeNow, xMessage.u.xTimerParameters.xMessageValue ) != pdFALSE )
    2d36:	2a 81       	ldd	r18, Y+2	; 0x02
    2d38:	3b 81       	ldd	r19, Y+3	; 0x03
    2d3a:	64 85       	ldd	r22, Z+12	; 0x0c
    2d3c:	75 85       	ldd	r23, Z+13	; 0x0d
    2d3e:	62 0f       	add	r22, r18
    2d40:	73 1f       	adc	r23, r19
    2d42:	a6 01       	movw	r20, r12
    2d44:	c7 01       	movw	r24, r14
    2d46:	0e 94 ff 14 	call	0x29fe	; 0x29fe <prvInsertTimerInActiveList>
    2d4a:	88 23       	and	r24, r24
    2d4c:	09 f4       	brne	.+2      	; 0x2d50 <prvTimerTask+0x19e>
    2d4e:	b9 cf       	rjmp	.-142    	; 0x2cc2 <prvTimerTask+0x110>
                    {
                        /* The timer expired before it was added to the active
                        timer list.  Process it now. */
                        pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
    2d50:	d7 01       	movw	r26, r14
    2d52:	50 96       	adiw	r26, 0x10	; 16
    2d54:	ed 91       	ld	r30, X+
    2d56:	fc 91       	ld	r31, X
    2d58:	51 97       	sbiw	r26, 0x11	; 17
    2d5a:	c7 01       	movw	r24, r14
    2d5c:	09 95       	icall
                        traceTIMER_EXPIRED( pxTimer );

                        if( ( pxTimer->ucStatus & tmrSTATUS_IS_AUTORELOAD ) != 0 )
    2d5e:	f7 01       	movw	r30, r14
    2d60:	82 89       	ldd	r24, Z+18	; 0x12
    2d62:	82 ff       	sbrs	r24, 2
    2d64:	ae cf       	rjmp	.-164    	; 0x2cc2 <prvTimerTask+0x110>
                        {
                            xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, NULL, tmrNO_DELAY );
    2d66:	4a 81       	ldd	r20, Y+2	; 0x02
    2d68:	5b 81       	ldd	r21, Y+3	; 0x03
    2d6a:	84 85       	ldd	r24, Z+12	; 0x0c
    2d6c:	95 85       	ldd	r25, Z+13	; 0x0d
    2d6e:	48 0f       	add	r20, r24
    2d70:	59 1f       	adc	r21, r25
    2d72:	00 e0       	ldi	r16, 0x00	; 0
    2d74:	10 e0       	ldi	r17, 0x00	; 0
    2d76:	20 e0       	ldi	r18, 0x00	; 0
    2d78:	30 e0       	ldi	r19, 0x00	; 0
    2d7a:	60 e0       	ldi	r22, 0x00	; 0
    2d7c:	c7 01       	movw	r24, r14
    2d7e:	0e 94 49 15 	call	0x2a92	; 0x2a92 <xTimerGenericCommand>
    2d82:	9f cf       	rjmp	.-194    	; 0x2cc2 <prvTimerTask+0x110>
                    pxTimer->ucStatus &= ~tmrSTATUS_IS_ACTIVE;
                    break;

                case tmrCOMMAND_CHANGE_PERIOD :
                case tmrCOMMAND_CHANGE_PERIOD_FROM_ISR :
                    pxTimer->ucStatus |= tmrSTATUS_IS_ACTIVE;
    2d84:	81 60       	ori	r24, 0x01	; 1
    2d86:	f7 01       	movw	r30, r14
    2d88:	82 8b       	std	Z+18, r24	; 0x12
                    pxTimer->xTimerPeriodInTicks = xMessage.u.xTimerParameters.xMessageValue;
    2d8a:	6a 81       	ldd	r22, Y+2	; 0x02
    2d8c:	7b 81       	ldd	r23, Y+3	; 0x03
    2d8e:	75 87       	std	Z+13, r23	; 0x0d
    2d90:	64 87       	std	Z+12, r22	; 0x0c
                    be longer or shorter than the old one.  The command time is
                    therefore set to the current time, and as the period cannot
                    be zero the next expiry time can only be in the future,
                    meaning (unlike for the xTimerStart() case above) there is
                    no fail case that needs to be handled here. */
                    ( void ) prvInsertTimerInActiveList( pxTimer, ( xTimeNow + pxTimer->xTimerPeriodInTicks ), xTimeNow, xTimeNow );
    2d92:	6c 0d       	add	r22, r12
    2d94:	7d 1d       	adc	r23, r13
    2d96:	96 01       	movw	r18, r12
    2d98:	a6 01       	movw	r20, r12
    2d9a:	c7 01       	movw	r24, r14
    2d9c:	0e 94 ff 14 	call	0x29fe	; 0x29fe <prvInsertTimerInActiveList>
    2da0:	90 cf       	rjmp	.-224    	; 0x2cc2 <prvTimerTask+0x110>
                    #if ( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
                    {
                    /* The timer has already been removed from the active list,
                    just free up the memory if the memory was dynamically
                    allocated. */
                        if( ( pxTimer->ucStatus & tmrSTATUS_IS_STATICALLY_ALLOCATED ) == ( uint8_t ) 0 )
    2da2:	81 fd       	sbrc	r24, 1
    2da4:	04 c0       	rjmp	.+8      	; 0x2dae <prvTimerTask+0x1fc>
                        {
                            vPortFree( pxTimer );
    2da6:	c7 01       	movw	r24, r14
    2da8:	0e 94 00 0a 	call	0x1400	; 0x1400 <vPortFree>
    2dac:	8a cf       	rjmp	.-236    	; 0x2cc2 <prvTimerTask+0x110>
                        }
                        else
                        {
                            pxTimer->ucStatus &= ~tmrSTATUS_IS_ACTIVE;
    2dae:	8e 7f       	andi	r24, 0xFE	; 254
    2db0:	d7 01       	movw	r26, r14
    2db2:	52 96       	adiw	r26, 0x12	; 18
    2db4:	8c 93       	st	X, r24
    2db6:	85 cf       	rjmp	.-246    	; 0x2cc2 <prvTimerTask+0x110>

00002db8 <initVariant>:
{
#if defined(USBCON)
    USBDevice.attach();
#endif

    setup();        // the normal Arduino setup() function is run here.
    2db8:	0e 94 24 06 	call	0xc48	; 0xc48 <setup>
    vTaskStartScheduler(); // initialise and run the freeRTOS scheduler. Execution should never return here.
    2dbc:	0e 94 23 11 	call	0x2246	; 0x2246 <vTaskStartScheduler>
    2dc0:	08 95       	ret

00002dc2 <vApplicationIdleHook>:
 */
void vApplicationIdleHook( void ) __attribute__((weak));

void vApplicationIdleHook( void )
{
    loop();        // the normal Arduino loop() function is run here.
    2dc2:	0e 94 9a 06 	call	0xd34	; 0xd34 <loop>
    if (serialEventRun) serialEventRun();
    2dc6:	80 e9       	ldi	r24, 0x90	; 144
    2dc8:	9d e1       	ldi	r25, 0x1D	; 29
    2dca:	89 2b       	or	r24, r25
    2dcc:	11 f0       	breq	.+4      	; 0x2dd2 <vApplicationIdleHook+0x10>
    2dce:	0c 94 90 1d 	jmp	0x3b20	; 0x3b20 <_Z14serialEventRunv>
    2dd2:	08 95       	ret

00002dd4 <vApplicationMallocFailedHook>:
#elif defined(__AVR_ATmega644P__) || defined(__AVR_ATmega644PA__) || defined(__AVR_ATmega1284P__) || defined(__AVR_ATmega1284PA__) // Seeed Goldilocks with 1284p
    DDRB  |= _BV(DDB7);
    PORTB |= _BV(PORTB7);       // Main (red PB7) LED on. Main LED on.

#elif defined(__AVR_ATmega328P__) || defined(__AVR_ATmega168__) || defined(__AVR_ATmega8__) // assume we're using an Arduino Uno with 328p
    DDRB  |= _BV(DDB5);
    2dd4:	25 9a       	sbi	0x04, 5	; 4
    PORTB |= _BV(PORTB5);       // Main (red PB5) LED on. Main LED on.
    2dd6:	2d 9a       	sbi	0x05, 5	; 5
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    2dd8:	2f ef       	ldi	r18, 0xFF	; 255
    2dda:	80 e7       	ldi	r24, 0x70	; 112
    2ddc:	92 e0       	ldi	r25, 0x02	; 2
    2dde:	21 50       	subi	r18, 0x01	; 1
    2de0:	80 40       	sbci	r24, 0x00	; 0
    2de2:	90 40       	sbci	r25, 0x00	; 0
    2de4:	e1 f7       	brne	.-8      	; 0x2dde <vApplicationMallocFailedHook+0xa>
    2de6:	00 c0       	rjmp	.+0      	; 0x2de8 <vApplicationMallocFailedHook+0x14>
    2de8:	00 00       	nop

#elif defined(__AVR_ATmega644P__) || defined(__AVR_ATmega644PA__) || defined(__AVR_ATmega1284P__) || defined(__AVR_ATmega1284PA__) // Seeed Goldilocks with 1284p
        PINB  |= _BV(PINB7);       // Main (red PB7) LED toggle. Main LED fast blink.

#elif defined(__AVR_ATmega328P__) || defined(__AVR_ATmega168__) || defined(__AVR_ATmega8__) // assume we're using an Arduino Uno with 328p
        PINB  |= _BV(PINB5);       // Main (red PB5) LED toggle. Main LED fast blink.
    2dea:	1d 9a       	sbi	0x03, 5	; 3
    2dec:	f5 cf       	rjmp	.-22     	; 0x2dd8 <vApplicationMallocFailedHook+0x4>

00002dee <vApplicationStackOverflowHook>:
#elif defined(__AVR_ATmega644P__) || defined(__AVR_ATmega644PA__) || defined(__AVR_ATmega1284P__) || defined(__AVR_ATmega1284PA__) // Seeed Goldilocks with 1284p
    DDRB  |= _BV(DDB7);
    PORTB |= _BV(PORTB7);       // Main (red PB7) LED on. Main LED on.

#elif defined(__AVR_ATmega328P__) || defined(__AVR_ATmega168__) || defined(__AVR_ATmega8__) // assume we're using an Arduino Uno with 328p
    DDRB  |= _BV(DDB5);
    2dee:	25 9a       	sbi	0x04, 5	; 4
    PORTB |= _BV(PORTB5);       // Main (red PB5) LED on. Main LED on.
    2df0:	2d 9a       	sbi	0x05, 5	; 5
    2df2:	2f ef       	ldi	r18, 0xFF	; 255
    2df4:	87 ea       	ldi	r24, 0xA7	; 167
    2df6:	91 e6       	ldi	r25, 0x61	; 97
    2df8:	21 50       	subi	r18, 0x01	; 1
    2dfa:	80 40       	sbci	r24, 0x00	; 0
    2dfc:	90 40       	sbci	r25, 0x00	; 0
    2dfe:	e1 f7       	brne	.-8      	; 0x2df8 <vApplicationStackOverflowHook+0xa>
    2e00:	00 c0       	rjmp	.+0      	; 0x2e02 <vApplicationStackOverflowHook+0x14>
    2e02:	00 00       	nop

#elif defined(__AVR_ATmega644P__) || defined(__AVR_ATmega644PA__) || defined(__AVR_ATmega1284P__) || defined(__AVR_ATmega1284PA__) // Seeed Goldilocks with 1284p
        PINB  |= _BV(PINB7);       // Main (red PB7) LED toggle. Main LED slow blink.

#elif defined(__AVR_ATmega328P__) || defined(__AVR_ATmega168__) || defined(__AVR_ATmega8__) // assume we're using an Arduino Uno with 328p
        PINB  |= _BV(PINB5);       // Main (red PB5) LED toggle. Main LED slow blink.
    2e04:	1d 9a       	sbi	0x03, 5	; 3
    2e06:	f5 cf       	rjmp	.-22     	; 0x2df2 <vApplicationStackOverflowHook+0x4>

00002e08 <_ZN9MD_TCS23010initialiseEv>:
  }
  FreqCount.end();      // stop
  DUMP("VALUE ", FreqCount.read());

  return(FreqCount.read() * _readDiv);
}
    2e08:	0f 93       	push	r16
    2e0a:	1f 93       	push	r17
    2e0c:	fc 01       	movw	r30, r24
    2e0e:	8f ef       	ldi	r24, 0xFF	; 255
    2e10:	80 83       	st	Z, r24
    2e12:	81 83       	std	Z+1, r24	; 0x01
    2e14:	82 83       	std	Z+2, r24	; 0x02
    2e16:	83 83       	std	Z+3, r24	; 0x03
    2e18:	84 83       	std	Z+4, r24	; 0x04
    2e1a:	8a e0       	ldi	r24, 0x0A	; 10
    2e1c:	85 83       	std	Z+5, r24	; 0x05
    2e1e:	16 82       	std	Z+6, r1	; 0x06
    2e20:	df 01       	movw	r26, r30
    2e22:	17 96       	adiw	r26, 0x07	; 7
    2e24:	73 96       	adiw	r30, 0x13	; 19
    2e26:	00 e7       	ldi	r16, 0x70	; 112
    2e28:	17 e1       	ldi	r17, 0x17	; 23
    2e2a:	20 e0       	ldi	r18, 0x00	; 0
    2e2c:	30 e0       	ldi	r19, 0x00	; 0
    2e2e:	48 ed       	ldi	r20, 0xD8	; 216
    2e30:	56 ed       	ldi	r21, 0xD6	; 214
    2e32:	60 e0       	ldi	r22, 0x00	; 0
    2e34:	70 e0       	ldi	r23, 0x00	; 0
    2e36:	0d 93       	st	X+, r16
    2e38:	1d 93       	st	X+, r17
    2e3a:	2d 93       	st	X+, r18
    2e3c:	3d 93       	st	X+, r19
    2e3e:	18 96       	adiw	r26, 0x08	; 8
    2e40:	4d 93       	st	X+, r20
    2e42:	5d 93       	st	X+, r21
    2e44:	6d 93       	st	X+, r22
    2e46:	7c 93       	st	X, r23
    2e48:	1b 97       	sbiw	r26, 0x0b	; 11
    2e4a:	ae 17       	cp	r26, r30
    2e4c:	bf 07       	cpc	r27, r31
    2e4e:	99 f7       	brne	.-26     	; 0x2e36 <_ZN9MD_TCS23010initialiseEv+0x2e>
    2e50:	1f 91       	pop	r17
    2e52:	0f 91       	pop	r16
    2e54:	08 95       	ret

00002e56 <_ZN9MD_TCS230C1Ehhh>:
    2e56:	ff 92       	push	r15
    2e58:	0f 93       	push	r16
    2e5a:	1f 93       	push	r17
    2e5c:	cf 93       	push	r28
    2e5e:	df 93       	push	r29
    2e60:	ec 01       	movw	r28, r24
    2e62:	f6 2e       	mov	r15, r22
    2e64:	04 2f       	mov	r16, r20
    2e66:	12 2f       	mov	r17, r18
    2e68:	0e 94 04 17 	call	0x2e08	; 0x2e08 <_ZN9MD_TCS23010initialiseEv>
    2e6c:	fb 82       	std	Y+3, r15	; 0x03
    2e6e:	0c 83       	std	Y+4, r16	; 0x04
    2e70:	18 83       	st	Y, r17
    2e72:	df 91       	pop	r29
    2e74:	cf 91       	pop	r28
    2e76:	1f 91       	pop	r17
    2e78:	0f 91       	pop	r16
    2e7a:	ff 90       	pop	r15
    2e7c:	08 95       	ret

00002e7e <_ZN9MD_TCS230D1Ev>:
    2e7e:	08 95       	ret

00002e80 <_ZN9MD_TCS2309setFilterEh>:
    2e80:	cf 93       	push	r28
    2e82:	df 93       	push	r29
    2e84:	ec 01       	movw	r28, r24
    2e86:	8b 81       	ldd	r24, Y+3	; 0x03
    2e88:	8f 3f       	cpi	r24, 0xFF	; 255
    2e8a:	e9 f0       	breq	.+58     	; 0x2ec6 <_ZN9MD_TCS2309setFilterEh+0x46>
    2e8c:	9c 81       	ldd	r25, Y+4	; 0x04
    2e8e:	9f 3f       	cpi	r25, 0xFF	; 255
    2e90:	d1 f0       	breq	.+52     	; 0x2ec6 <_ZN9MD_TCS2309setFilterEh+0x46>
    2e92:	61 30       	cpi	r22, 0x01	; 1
    2e94:	49 f0       	breq	.+18     	; 0x2ea8 <_ZN9MD_TCS2309setFilterEh+0x28>
    2e96:	30 f0       	brcs	.+12     	; 0x2ea4 <_ZN9MD_TCS2309setFilterEh+0x24>
    2e98:	62 30       	cpi	r22, 0x02	; 2
    2e9a:	41 f0       	breq	.+16     	; 0x2eac <_ZN9MD_TCS2309setFilterEh+0x2c>
    2e9c:	63 30       	cpi	r22, 0x03	; 3
    2e9e:	99 f4       	brne	.+38     	; 0x2ec6 <_ZN9MD_TCS2309setFilterEh+0x46>
    2ea0:	61 e0       	ldi	r22, 0x01	; 1
    2ea2:	09 c0       	rjmp	.+18     	; 0x2eb6 <_ZN9MD_TCS2309setFilterEh+0x36>
    2ea4:	60 e0       	ldi	r22, 0x00	; 0
    2ea6:	07 c0       	rjmp	.+14     	; 0x2eb6 <_ZN9MD_TCS2309setFilterEh+0x36>
    2ea8:	61 e0       	ldi	r22, 0x01	; 1
    2eaa:	01 c0       	rjmp	.+2      	; 0x2eae <_ZN9MD_TCS2309setFilterEh+0x2e>
    2eac:	60 e0       	ldi	r22, 0x00	; 0
    2eae:	0e 94 b0 22 	call	0x4560	; 0x4560 <digitalWrite>
    2eb2:	61 e0       	ldi	r22, 0x01	; 1
    2eb4:	03 c0       	rjmp	.+6      	; 0x2ebc <_ZN9MD_TCS2309setFilterEh+0x3c>
    2eb6:	0e 94 b0 22 	call	0x4560	; 0x4560 <digitalWrite>
    2eba:	60 e0       	ldi	r22, 0x00	; 0
    2ebc:	8c 81       	ldd	r24, Y+4	; 0x04
    2ebe:	df 91       	pop	r29
    2ec0:	cf 91       	pop	r28
    2ec2:	0c 94 b0 22 	jmp	0x4560	; 0x4560 <digitalWrite>
    2ec6:	df 91       	pop	r29
    2ec8:	cf 91       	pop	r28
    2eca:	08 95       	ret

00002ecc <_ZN9MD_TCS23013setFrequency2Eh>:
    2ecc:	cf 93       	push	r28
    2ece:	df 93       	push	r29
    2ed0:	ec 01       	movw	r28, r24
    2ed2:	89 81       	ldd	r24, Y+1	; 0x01
    2ed4:	8f 3f       	cpi	r24, 0xFF	; 255
    2ed6:	e9 f0       	breq	.+58     	; 0x2f12 <_ZN9MD_TCS23013setFrequency2Eh+0x46>
    2ed8:	9a 81       	ldd	r25, Y+2	; 0x02
    2eda:	9f 3f       	cpi	r25, 0xFF	; 255
    2edc:	d1 f0       	breq	.+52     	; 0x2f12 <_ZN9MD_TCS23013setFrequency2Eh+0x46>
    2ede:	61 30       	cpi	r22, 0x01	; 1
    2ee0:	49 f0       	breq	.+18     	; 0x2ef4 <_ZN9MD_TCS23013setFrequency2Eh+0x28>
    2ee2:	30 f0       	brcs	.+12     	; 0x2ef0 <_ZN9MD_TCS23013setFrequency2Eh+0x24>
    2ee4:	62 30       	cpi	r22, 0x02	; 2
    2ee6:	41 f0       	breq	.+16     	; 0x2ef8 <_ZN9MD_TCS23013setFrequency2Eh+0x2c>
    2ee8:	63 30       	cpi	r22, 0x03	; 3
    2eea:	99 f4       	brne	.+38     	; 0x2f12 <_ZN9MD_TCS23013setFrequency2Eh+0x46>
    2eec:	60 e0       	ldi	r22, 0x00	; 0
    2eee:	09 c0       	rjmp	.+18     	; 0x2f02 <_ZN9MD_TCS23013setFrequency2Eh+0x36>
    2ef0:	61 e0       	ldi	r22, 0x01	; 1
    2ef2:	03 c0       	rjmp	.+6      	; 0x2efa <_ZN9MD_TCS23013setFrequency2Eh+0x2e>
    2ef4:	61 e0       	ldi	r22, 0x01	; 1
    2ef6:	05 c0       	rjmp	.+10     	; 0x2f02 <_ZN9MD_TCS23013setFrequency2Eh+0x36>
    2ef8:	60 e0       	ldi	r22, 0x00	; 0
    2efa:	0e 94 b0 22 	call	0x4560	; 0x4560 <digitalWrite>
    2efe:	61 e0       	ldi	r22, 0x01	; 1
    2f00:	03 c0       	rjmp	.+6      	; 0x2f08 <_ZN9MD_TCS23013setFrequency2Eh+0x3c>
    2f02:	0e 94 b0 22 	call	0x4560	; 0x4560 <digitalWrite>
    2f06:	60 e0       	ldi	r22, 0x00	; 0
    2f08:	8a 81       	ldd	r24, Y+2	; 0x02
    2f0a:	df 91       	pop	r29
    2f0c:	cf 91       	pop	r28
    2f0e:	0c 94 b0 22 	jmp	0x4560	; 0x4560 <digitalWrite>
    2f12:	df 91       	pop	r29
    2f14:	cf 91       	pop	r28
    2f16:	08 95       	ret

00002f18 <_ZN9MD_TCS2309setEnableEb>:
    2f18:	fc 01       	movw	r30, r24
    2f1a:	20 81       	ld	r18, Z
    2f1c:	2f 3f       	cpi	r18, 0xFF	; 255
    2f1e:	29 f0       	breq	.+10     	; 0x2f2a <_ZN9MD_TCS2309setEnableEb+0x12>
    2f20:	91 e0       	ldi	r25, 0x01	; 1
    2f22:	69 27       	eor	r22, r25
    2f24:	82 2f       	mov	r24, r18
    2f26:	0c 94 b0 22 	jmp	0x4560	; 0x4560 <digitalWrite>
    2f2a:	66 23       	and	r22, r22
    2f2c:	19 f0       	breq	.+6      	; 0x2f34 <_ZN9MD_TCS2309setEnableEb+0x1c>
    2f2e:	fc 01       	movw	r30, r24
    2f30:	66 81       	ldd	r22, Z+6	; 0x06
    2f32:	01 c0       	rjmp	.+2      	; 0x2f36 <_ZN9MD_TCS2309setEnableEb+0x1e>
    2f34:	63 e0       	ldi	r22, 0x03	; 3
    2f36:	0c 94 66 17 	jmp	0x2ecc	; 0x2ecc <_ZN9MD_TCS23013setFrequency2Eh>

00002f3a <_ZN9MD_TCS2305beginEv>:
    2f3a:	cf 93       	push	r28
    2f3c:	df 93       	push	r29
    2f3e:	ec 01       	movw	r28, r24
    2f40:	89 81       	ldd	r24, Y+1	; 0x01
    2f42:	8f 3f       	cpi	r24, 0xFF	; 255
    2f44:	19 f0       	breq	.+6      	; 0x2f4c <_ZN9MD_TCS2305beginEv+0x12>
    2f46:	61 e0       	ldi	r22, 0x01	; 1
    2f48:	0e 94 74 22 	call	0x44e8	; 0x44e8 <pinMode>
    2f4c:	8a 81       	ldd	r24, Y+2	; 0x02
    2f4e:	8f 3f       	cpi	r24, 0xFF	; 255
    2f50:	19 f0       	breq	.+6      	; 0x2f58 <_ZN9MD_TCS2305beginEv+0x1e>
    2f52:	61 e0       	ldi	r22, 0x01	; 1
    2f54:	0e 94 74 22 	call	0x44e8	; 0x44e8 <pinMode>
    2f58:	8b 81       	ldd	r24, Y+3	; 0x03
    2f5a:	8f 3f       	cpi	r24, 0xFF	; 255
    2f5c:	19 f0       	breq	.+6      	; 0x2f64 <_ZN9MD_TCS2305beginEv+0x2a>
    2f5e:	61 e0       	ldi	r22, 0x01	; 1
    2f60:	0e 94 74 22 	call	0x44e8	; 0x44e8 <pinMode>
    2f64:	8c 81       	ldd	r24, Y+4	; 0x04
    2f66:	8f 3f       	cpi	r24, 0xFF	; 255
    2f68:	19 f0       	breq	.+6      	; 0x2f70 <_ZN9MD_TCS2305beginEv+0x36>
    2f6a:	61 e0       	ldi	r22, 0x01	; 1
    2f6c:	0e 94 74 22 	call	0x44e8	; 0x44e8 <pinMode>
    2f70:	88 81       	ld	r24, Y
    2f72:	8f 3f       	cpi	r24, 0xFF	; 255
    2f74:	19 f0       	breq	.+6      	; 0x2f7c <_ZN9MD_TCS2305beginEv+0x42>
    2f76:	61 e0       	ldi	r22, 0x01	; 1
    2f78:	0e 94 74 22 	call	0x44e8	; 0x44e8 <pinMode>
    2f7c:	60 e0       	ldi	r22, 0x00	; 0
    2f7e:	ce 01       	movw	r24, r28
    2f80:	0e 94 8c 17 	call	0x2f18	; 0x2f18 <_ZN9MD_TCS2309setEnableEb>
    2f84:	6e 81       	ldd	r22, Y+6	; 0x06
    2f86:	ce 01       	movw	r24, r28
    2f88:	df 91       	pop	r29
    2f8a:	cf 91       	pop	r28
    2f8c:	0c 94 66 17 	jmp	0x2ecc	; 0x2ecc <_ZN9MD_TCS23013setFrequency2Eh>

00002f90 <_ZN9MD_TCS2306getRGBEP9colorData>:
    2f90:	dc 01       	movw	r26, r24
    2f92:	fb 01       	movw	r30, r22
    2f94:	30 97       	sbiw	r30, 0x00	; 0
    2f96:	59 f0       	breq	.+22     	; 0x2fae <_ZN9MD_TCS2306getRGBEP9colorData+0x1e>
    2f98:	9b 96       	adiw	r26, 0x2b	; 43
    2f9a:	8c 91       	ld	r24, X
    2f9c:	9b 97       	sbiw	r26, 0x2b	; 43
    2f9e:	80 83       	st	Z, r24
    2fa0:	9c 96       	adiw	r26, 0x2c	; 44
    2fa2:	8c 91       	ld	r24, X
    2fa4:	9c 97       	sbiw	r26, 0x2c	; 44
    2fa6:	81 83       	std	Z+1, r24	; 0x01
    2fa8:	9d 96       	adiw	r26, 0x2d	; 45
    2faa:	8c 91       	ld	r24, X
    2fac:	82 83       	std	Z+2, r24	; 0x02
    2fae:	08 95       	ret

00002fb0 <_ZN9MD_TCS23017RGBTransformationEv>:
  return(s);
}

void MD_TCS230::RGBTransformation(void)
// Exploiting linear relationship to remap the range 
{
    2fb0:	4f 92       	push	r4
    2fb2:	5f 92       	push	r5
    2fb4:	6f 92       	push	r6
    2fb6:	7f 92       	push	r7
    2fb8:	8f 92       	push	r8
    2fba:	9f 92       	push	r9
    2fbc:	af 92       	push	r10
    2fbe:	bf 92       	push	r11
    2fc0:	df 92       	push	r13
    2fc2:	ef 92       	push	r14
    2fc4:	ff 92       	push	r15
    2fc6:	0f 93       	push	r16
    2fc8:	1f 93       	push	r17
    2fca:	cf 93       	push	r28
    2fcc:	df 93       	push	r29
    2fce:	8c 01       	movw	r16, r24
    2fd0:	09 5f       	subi	r16, 0xF9	; 249
    2fd2:	1f 4f       	sbci	r17, 0xFF	; 255
    2fd4:	ec 01       	movw	r28, r24
    2fd6:	7c 01       	movw	r14, r24
    2fd8:	83 e1       	ldi	r24, 0x13	; 19
    2fda:	e8 0e       	add	r14, r24
    2fdc:	f1 1c       	adc	r15, r1
    x = (_Fo.value[i] - _Fd.value[i]) * 255;
    x /= (_Fw.value[i] - _Fd.value[i]);

    // copy results back into the global structures
    if (x < 0) _rgb.value[i] = 0; 
    else if (x > 255) _rgb.value[i] = 255;
    2fde:	dd 24       	eor	r13, r13
    2fe0:	da 94       	dec	r13
    2fe2:	f8 01       	movw	r30, r16
{
  int32_t x;

  for (uint8_t i=0; i<RGB_SIZE; i++)
  {
    x = (_Fo.value[i] - _Fd.value[i]) * 255;
    2fe4:	d8 01       	movw	r26, r16
    2fe6:	8d 90       	ld	r8, X+
    2fe8:	9d 90       	ld	r9, X+
    2fea:	ad 90       	ld	r10, X+
    2fec:	bd 90       	ld	r11, X+
    2fee:	8d 01       	movw	r16, r26
    2ff0:	80 8d       	ldd	r24, Z+24	; 0x18
    2ff2:	91 8d       	ldd	r25, Z+25	; 0x19
    2ff4:	a2 8d       	ldd	r26, Z+26	; 0x1a
    2ff6:	b3 8d       	ldd	r27, Z+27	; 0x1b
    2ff8:	9c 01       	movw	r18, r24
    2ffa:	ad 01       	movw	r20, r26
    2ffc:	28 19       	sub	r18, r8
    2ffe:	39 09       	sbc	r19, r9
    3000:	4a 09       	sbc	r20, r10
    3002:	5b 09       	sbc	r21, r11
    3004:	af ef       	ldi	r26, 0xFF	; 255
    3006:	b0 e0       	ldi	r27, 0x00	; 0
    3008:	0e 94 51 24 	call	0x48a2	; 0x48a2 <__muluhisi3>
    x /= (_Fw.value[i] - _Fd.value[i]);
    300c:	f8 01       	movw	r30, r16
    300e:	40 84       	ldd	r4, Z+8	; 0x08
    3010:	51 84       	ldd	r5, Z+9	; 0x09
    3012:	62 84       	ldd	r6, Z+10	; 0x0a
    3014:	73 84       	ldd	r7, Z+11	; 0x0b
    3016:	a3 01       	movw	r20, r6
    3018:	92 01       	movw	r18, r4
    301a:	28 19       	sub	r18, r8
    301c:	39 09       	sbc	r19, r9
    301e:	4a 09       	sbc	r20, r10
    3020:	5b 09       	sbc	r21, r11
    3022:	0e 94 2c 24 	call	0x4858	; 0x4858 <__divmodsi4>

    // copy results back into the global structures
    if (x < 0) _rgb.value[i] = 0; 
    3026:	57 ff       	sbrs	r21, 7
    3028:	02 c0       	rjmp	.+4      	; 0x302e <_ZN9MD_TCS23017RGBTransformationEv+0x7e>
    302a:	1b a6       	std	Y+43, r1	; 0x2b
    302c:	09 c0       	rjmp	.+18     	; 0x3040 <_ZN9MD_TCS23017RGBTransformationEv+0x90>
    else if (x > 255) _rgb.value[i] = 255;
    302e:	2f 3f       	cpi	r18, 0xFF	; 255
    3030:	31 05       	cpc	r19, r1
    3032:	41 05       	cpc	r20, r1
    3034:	51 05       	cpc	r21, r1
    3036:	19 f0       	breq	.+6      	; 0x303e <_ZN9MD_TCS23017RGBTransformationEv+0x8e>
    3038:	14 f0       	brlt	.+4      	; 0x303e <_ZN9MD_TCS23017RGBTransformationEv+0x8e>
    303a:	db a6       	std	Y+43, r13	; 0x2b
    303c:	01 c0       	rjmp	.+2      	; 0x3040 <_ZN9MD_TCS23017RGBTransformationEv+0x90>
    else _rgb.value[i] = x;
    303e:	2b a7       	std	Y+43, r18	; 0x2b
    3040:	21 96       	adiw	r28, 0x01	; 1
void MD_TCS230::RGBTransformation(void)
// Exploiting linear relationship to remap the range 
{
  int32_t x;

  for (uint8_t i=0; i<RGB_SIZE; i++)
    3042:	0e 15       	cp	r16, r14
    3044:	1f 05       	cpc	r17, r15
    3046:	69 f6       	brne	.-102    	; 0x2fe2 <_ZN9MD_TCS23017RGBTransformationEv+0x32>
    // copy results back into the global structures
    if (x < 0) _rgb.value[i] = 0; 
    else if (x > 255) _rgb.value[i] = 255;
    else _rgb.value[i] = x;
  }
}
    3048:	df 91       	pop	r29
    304a:	cf 91       	pop	r28
    304c:	1f 91       	pop	r17
    304e:	0f 91       	pop	r16
    3050:	ff 90       	pop	r15
    3052:	ef 90       	pop	r14
    3054:	df 90       	pop	r13
    3056:	bf 90       	pop	r11
    3058:	af 90       	pop	r10
    305a:	9f 90       	pop	r9
    305c:	8f 90       	pop	r8
    305e:	7f 90       	pop	r7
    3060:	6f 90       	pop	r6
    3062:	5f 90       	pop	r5
    3064:	4f 90       	pop	r4
    3066:	08 95       	ret

00003068 <_ZN9MD_TCS2307readFSMEh>:
  return(_readState == 0);
}

uint8_t MD_TCS230::readFSM(uint8_t s)
// Finite State Machine to read a value (internal function)
{
    3068:	0f 93       	push	r16
    306a:	1f 93       	push	r17
    306c:	cf 93       	push	r28
    306e:	df 93       	push	r29
    3070:	8c 01       	movw	r16, r24
    3072:	c6 2f       	mov	r28, r22
  static const uint8_t seq[] = { TCS230_RGB_R, TCS230_RGB_G, TCS230_RGB_B };
  static uint8_t       currCol;  // index for seq above

  switch(s)
    3074:	61 30       	cpi	r22, 0x01	; 1
    3076:	49 f0       	breq	.+18     	; 0x308a <_ZN9MD_TCS2307readFSMEh+0x22>
    3078:	18 f0       	brcs	.+6      	; 0x3080 <_ZN9MD_TCS2307readFSMEh+0x18>
    307a:	62 30       	cpi	r22, 0x02	; 2
    307c:	d9 f0       	breq	.+54     	; 0x30b4 <_ZN9MD_TCS2307readFSMEh+0x4c>
    307e:	4c c0       	rjmp	.+152    	; 0x3118 <_ZN9MD_TCS2307readFSMEh+0xb0>
  {
  case 0: // enable the hardware for reading
    DUMPS("\n0");
    currCol = 0;  // RGB_R but we don't care
    3080:	10 92 0f 04 	sts	0x040F, r1	; 0x80040f <_ZZN9MD_TCS2307readFSMEhE7currCol>
    setEnable(true);
    3084:	61 e0       	ldi	r22, 0x01	; 1
    3086:	0e 94 8c 17 	call	0x2f18	; 0x2f18 <_ZN9MD_TCS2309setEnableEb>
    s++;
    // fall through to the next state

  case 1: // select a filter and start a reading
    DUMPS("\n1");
    setFilter(seq[currCol]);
    308a:	e0 91 0f 04 	lds	r30, 0x040F	; 0x80040f <_ZZN9MD_TCS2307readFSMEhE7currCol>
    308e:	f0 e0       	ldi	r31, 0x00	; 0
    3090:	ed 5e       	subi	r30, 0xED	; 237
    3092:	fd 4f       	sbci	r31, 0xFD	; 253
    3094:	60 81       	ld	r22, Z
    3096:	c8 01       	movw	r24, r16
    3098:	0e 94 40 17 	call	0x2e80	; 0x2e80 <_ZN9MD_TCS2309setFilterEh>
    FreqCount.begin(1000/_readDiv);
    309c:	f8 01       	movw	r30, r16
    309e:	65 81       	ldd	r22, Z+5	; 0x05
    30a0:	70 e0       	ldi	r23, 0x00	; 0
    30a2:	88 ee       	ldi	r24, 0xE8	; 232
    30a4:	93 e0       	ldi	r25, 0x03	; 3
    30a6:	0e 94 f6 23 	call	0x47ec	; 0x47ec <__divmodhi4>
    30aa:	cb 01       	movw	r24, r22
    30ac:	0e 94 df 22 	call	0x45be	; 0x45be <_ZN14FreqCountClass5beginEj>
    s++;
    30b0:	c2 e0       	ldi	r28, 0x02	; 2
    break;
    30b2:	32 c0       	rjmp	.+100    	; 0x3118 <_ZN9MD_TCS2307readFSMEh+0xb0>

  case 2: // see if a value is available
    DUMPS("2");
    if (FreqCount.available())
    30b4:	0e 94 57 23 	call	0x46ae	; 0x46ae <_ZN14FreqCountClass9availableEv>
    30b8:	88 23       	and	r24, r24
    30ba:	71 f1       	breq	.+92     	; 0x3118 <_ZN9MD_TCS2307readFSMEh+0xb0>
    {
      DUMP(" VALUE ", FreqCount.read());
      // read the value and save it 
      _Fo.value[seq[currCol++]] = FreqCount.read() * _readDiv;
    30bc:	e0 91 0f 04 	lds	r30, 0x040F	; 0x80040f <_ZZN9MD_TCS2307readFSMEhE7currCol>
    30c0:	81 e0       	ldi	r24, 0x01	; 1
    30c2:	8e 0f       	add	r24, r30
    30c4:	80 93 0f 04 	sts	0x040F, r24	; 0x80040f <_ZZN9MD_TCS2307readFSMEhE7currCol>
    30c8:	f0 e0       	ldi	r31, 0x00	; 0
    30ca:	ed 5e       	subi	r30, 0xED	; 237
    30cc:	fd 4f       	sbci	r31, 0xFD	; 253
    30ce:	c0 81       	ld	r28, Z
    30d0:	d0 e0       	ldi	r29, 0x00	; 0
    30d2:	0e 94 5a 23 	call	0x46b4	; 0x46b4 <_ZN14FreqCountClass4readEv>
    30d6:	9b 01       	movw	r18, r22
    30d8:	ac 01       	movw	r20, r24
    30da:	cc 0f       	add	r28, r28
    30dc:	dd 1f       	adc	r29, r29
    30de:	cc 0f       	add	r28, r28
    30e0:	dd 1f       	adc	r29, r29
    30e2:	c0 0f       	add	r28, r16
    30e4:	d1 1f       	adc	r29, r17
    30e6:	f8 01       	movw	r30, r16
    30e8:	a5 81       	ldd	r26, Z+5	; 0x05
    30ea:	b0 e0       	ldi	r27, 0x00	; 0
    30ec:	0e 94 51 24 	call	0x48a2	; 0x48a2 <__muluhisi3>
    30f0:	6f 8f       	std	Y+31, r22	; 0x1f
    30f2:	78 a3       	std	Y+32, r23	; 0x20
    30f4:	89 a3       	std	Y+33, r24	; 0x21
    30f6:	9a a3       	std	Y+34, r25	; 0x22

      if (currCol < RGB_SIZE)
    30f8:	80 91 0f 04 	lds	r24, 0x040F	; 0x80040f <_ZZN9MD_TCS2307readFSMEhE7currCol>
    30fc:	83 30       	cpi	r24, 0x03	; 3
    30fe:	58 f0       	brcs	.+22     	; 0x3116 <_ZN9MD_TCS2307readFSMEh+0xae>
        s--;
      }
      else
      {
        // end this reading session
        FreqCount.end();
    3100:	0e 94 68 23 	call	0x46d0	; 0x46d0 <_ZN14FreqCountClass3endEv>
        setEnable(false);
    3104:	60 e0       	ldi	r22, 0x00	; 0
    3106:	c8 01       	movw	r24, r16
    3108:	0e 94 8c 17 	call	0x2f18	; 0x2f18 <_ZN9MD_TCS2309setEnableEb>
        RGBTransformation();
    310c:	c8 01       	movw	r24, r16
    310e:	0e 94 d8 17 	call	0x2fb0	; 0x2fb0 <_ZN9MD_TCS23017RGBTransformationEv>
        s = 0;
    3112:	c0 e0       	ldi	r28, 0x00	; 0
    3114:	01 c0       	rjmp	.+2      	; 0x3118 <_ZN9MD_TCS2307readFSMEh+0xb0>
      _Fo.value[seq[currCol++]] = FreqCount.read() * _readDiv;

      if (currCol < RGB_SIZE)
      {
        // loop around again on next call to available()
        s--;
    3116:	c1 e0       	ldi	r28, 0x01	; 1
    }
    break;
  }

  return(s);
}
    3118:	8c 2f       	mov	r24, r28
    311a:	df 91       	pop	r29
    311c:	cf 91       	pop	r28
    311e:	1f 91       	pop	r17
    3120:	0f 91       	pop	r16
    3122:	08 95       	ret

00003124 <_ZN9MD_TCS2304readEv>:
  return(FreqCount.read() * _readDiv);
}

void MD_TCS230::read(void)
// initiate the finite state machine for reading a value
{
    3124:	cf 93       	push	r28
    3126:	df 93       	push	r29
    3128:	ec 01       	movw	r28, r24
  _readState = readFSM(0);
    312a:	60 e0       	ldi	r22, 0x00	; 0
    312c:	0e 94 34 18 	call	0x3068	; 0x3068 <_ZN9MD_TCS2307readFSMEh>
    3130:	8e a7       	std	Y+46, r24	; 0x2e
}
    3132:	df 91       	pop	r29
    3134:	cf 91       	pop	r28
    3136:	08 95       	ret

00003138 <_ZN9MD_TCS2309availableEv>:

bool MD_TCS230::available(void)
// check if a value is ready. Called repeatedly until it is!
{
    3138:	cf 93       	push	r28
    313a:	df 93       	push	r29
    313c:	ec 01       	movw	r28, r24
  _readState = readFSM(_readState);
    313e:	6e a5       	ldd	r22, Y+46	; 0x2e
    3140:	0e 94 34 18 	call	0x3068	; 0x3068 <_ZN9MD_TCS2307readFSMEh>
    3144:	98 2f       	mov	r25, r24
    3146:	8e a7       	std	Y+46, r24	; 0x2e

  return(_readState == 0);
    3148:	81 e0       	ldi	r24, 0x01	; 1
    314a:	91 11       	cpse	r25, r1
    314c:	80 e0       	ldi	r24, 0x00	; 0
}
    314e:	df 91       	pop	r29
    3150:	cf 91       	pop	r28
    3152:	08 95       	ret

00003154 <_ZN5Print17availableForWriteEv>:
uint16_t SoftwareSerial::subtract_cap(uint16_t num, uint16_t sub) {
  if (num > sub)
    return num - sub;
  else
    return 1;
}
    3154:	80 e0       	ldi	r24, 0x00	; 0
    3156:	90 e0       	ldi	r25, 0x00	; 0
    3158:	08 95       	ret

0000315a <_ZN14SoftwareSerial4readEv>:
    315a:	20 91 52 04 	lds	r18, 0x0452	; 0x800452 <_ZN14SoftwareSerial13active_objectE>
    315e:	30 91 53 04 	lds	r19, 0x0453	; 0x800453 <_ZN14SoftwareSerial13active_objectE+0x1>
    3162:	28 17       	cp	r18, r24
    3164:	39 07       	cpc	r19, r25
    3166:	b9 f4       	brne	.+46     	; 0x3196 <_ZN14SoftwareSerial4readEv+0x3c>
    3168:	90 91 10 04 	lds	r25, 0x0410	; 0x800410 <_ZN14SoftwareSerial20_receive_buffer_headE>
    316c:	80 91 11 04 	lds	r24, 0x0411	; 0x800411 <_ZN14SoftwareSerial20_receive_buffer_tailE>
    3170:	98 17       	cp	r25, r24
    3172:	89 f0       	breq	.+34     	; 0x3196 <_ZN14SoftwareSerial4readEv+0x3c>
    3174:	e0 91 10 04 	lds	r30, 0x0410	; 0x800410 <_ZN14SoftwareSerial20_receive_buffer_headE>
    3178:	f0 e0       	ldi	r31, 0x00	; 0
    317a:	ee 5e       	subi	r30, 0xEE	; 238
    317c:	fb 4f       	sbci	r31, 0xFB	; 251
    317e:	80 81       	ld	r24, Z
    3180:	20 91 10 04 	lds	r18, 0x0410	; 0x800410 <_ZN14SoftwareSerial20_receive_buffer_headE>
    3184:	30 e0       	ldi	r19, 0x00	; 0
    3186:	2f 5f       	subi	r18, 0xFF	; 255
    3188:	3f 4f       	sbci	r19, 0xFF	; 255
    318a:	2f 73       	andi	r18, 0x3F	; 63
    318c:	33 27       	eor	r19, r19
    318e:	20 93 10 04 	sts	0x0410, r18	; 0x800410 <_ZN14SoftwareSerial20_receive_buffer_headE>
    3192:	90 e0       	ldi	r25, 0x00	; 0
    3194:	08 95       	ret
    3196:	8f ef       	ldi	r24, 0xFF	; 255
    3198:	9f ef       	ldi	r25, 0xFF	; 255
    319a:	08 95       	ret

0000319c <_ZN14SoftwareSerial5writeEh>:
    319c:	1f 93       	push	r17
    319e:	cf 93       	push	r28
    31a0:	df 93       	push	r29
    31a2:	dc 01       	movw	r26, r24
    31a4:	5c 96       	adiw	r26, 0x1c	; 28
    31a6:	8d 91       	ld	r24, X+
    31a8:	9c 91       	ld	r25, X
    31aa:	5d 97       	sbiw	r26, 0x1d	; 29
    31ac:	00 97       	sbiw	r24, 0x00	; 0
    31ae:	39 f4       	brne	.+14     	; 0x31be <_ZN14SoftwareSerial5writeEh+0x22>
    31b0:	21 e0       	ldi	r18, 0x01	; 1
    31b2:	30 e0       	ldi	r19, 0x00	; 0
    31b4:	13 96       	adiw	r26, 0x03	; 3
    31b6:	3c 93       	st	X, r19
    31b8:	2e 93       	st	-X, r18
    31ba:	12 97       	sbiw	r26, 0x02	; 2
    31bc:	3b c0       	rjmp	.+118    	; 0x3234 <_ZN14SoftwareSerial5writeEh+0x98>
    31be:	51 96       	adiw	r26, 0x11	; 17
    31c0:	ed 91       	ld	r30, X+
    31c2:	fc 91       	ld	r31, X
    31c4:	52 97       	sbiw	r26, 0x12	; 18
    31c6:	50 96       	adiw	r26, 0x10	; 16
    31c8:	2c 91       	ld	r18, X
    31ca:	50 97       	sbiw	r26, 0x10	; 16
    31cc:	32 2f       	mov	r19, r18
    31ce:	30 95       	com	r19
    31d0:	1f b7       	in	r17, 0x3f	; 63
    31d2:	5e 96       	adiw	r26, 0x1e	; 30
    31d4:	4c 91       	ld	r20, X
    31d6:	5e 97       	sbiw	r26, 0x1e	; 30
    31d8:	74 2f       	mov	r23, r20
    31da:	72 70       	andi	r23, 0x02	; 2
    31dc:	41 fd       	sbrc	r20, 1
    31de:	60 95       	com	r22
    31e0:	f8 94       	cli
    31e2:	40 81       	ld	r20, Z
    31e4:	77 23       	and	r23, r23
    31e6:	11 f0       	breq	.+4      	; 0x31ec <_ZN14SoftwareSerial5writeEh+0x50>
    31e8:	42 2b       	or	r20, r18
    31ea:	01 c0       	rjmp	.+2      	; 0x31ee <_ZN14SoftwareSerial5writeEh+0x52>
    31ec:	43 23       	and	r20, r19
    31ee:	40 83       	st	Z, r20
    31f0:	ec 01       	movw	r28, r24
    31f2:	21 97       	sbiw	r28, 0x01	; 1
    31f4:	f1 f7       	brne	.-4      	; 0x31f2 <_ZN14SoftwareSerial5writeEh+0x56>
    31f6:	48 e0       	ldi	r20, 0x08	; 8
    31f8:	50 81       	ld	r21, Z
    31fa:	60 ff       	sbrs	r22, 0
    31fc:	02 c0       	rjmp	.+4      	; 0x3202 <_ZN14SoftwareSerial5writeEh+0x66>
    31fe:	52 2b       	or	r21, r18
    3200:	01 c0       	rjmp	.+2      	; 0x3204 <_ZN14SoftwareSerial5writeEh+0x68>
    3202:	53 23       	and	r21, r19
    3204:	50 83       	st	Z, r21
    3206:	ec 01       	movw	r28, r24
    3208:	21 97       	sbiw	r28, 0x01	; 1
    320a:	f1 f7       	brne	.-4      	; 0x3208 <_ZN14SoftwareSerial5writeEh+0x6c>
    320c:	66 95       	lsr	r22
    320e:	41 50       	subi	r20, 0x01	; 1
    3210:	99 f7       	brne	.-26     	; 0x31f8 <_ZN14SoftwareSerial5writeEh+0x5c>
    3212:	80 81       	ld	r24, Z
    3214:	77 23       	and	r23, r23
    3216:	19 f0       	breq	.+6      	; 0x321e <_ZN14SoftwareSerial5writeEh+0x82>
    3218:	83 23       	and	r24, r19
    321a:	80 83       	st	Z, r24
    321c:	02 c0       	rjmp	.+4      	; 0x3222 <_ZN14SoftwareSerial5writeEh+0x86>
    321e:	28 2b       	or	r18, r24
    3220:	20 83       	st	Z, r18
    3222:	1f bf       	out	0x3f, r17	; 63
    3224:	5c 96       	adiw	r26, 0x1c	; 28
    3226:	8d 91       	ld	r24, X+
    3228:	9c 91       	ld	r25, X
    322a:	5d 97       	sbiw	r26, 0x1d	; 29
    322c:	01 97       	sbiw	r24, 0x01	; 1
    322e:	f1 f7       	brne	.-4      	; 0x322c <_ZN14SoftwareSerial5writeEh+0x90>
    3230:	81 e0       	ldi	r24, 0x01	; 1
    3232:	90 e0       	ldi	r25, 0x00	; 0
    3234:	df 91       	pop	r29
    3236:	cf 91       	pop	r28
    3238:	1f 91       	pop	r17
    323a:	08 95       	ret

0000323c <_ZN14SoftwareSerial5flushEv>:
    323c:	08 95       	ret

0000323e <_ZN14SoftwareSerial4peekEv>:
    323e:	20 91 52 04 	lds	r18, 0x0452	; 0x800452 <_ZN14SoftwareSerial13active_objectE>
    3242:	30 91 53 04 	lds	r19, 0x0453	; 0x800453 <_ZN14SoftwareSerial13active_objectE+0x1>
    3246:	28 17       	cp	r18, r24
    3248:	39 07       	cpc	r19, r25
    324a:	71 f4       	brne	.+28     	; 0x3268 <_ZN14SoftwareSerial4peekEv+0x2a>
    324c:	90 91 10 04 	lds	r25, 0x0410	; 0x800410 <_ZN14SoftwareSerial20_receive_buffer_headE>
    3250:	80 91 11 04 	lds	r24, 0x0411	; 0x800411 <_ZN14SoftwareSerial20_receive_buffer_tailE>
    3254:	98 17       	cp	r25, r24
    3256:	41 f0       	breq	.+16     	; 0x3268 <_ZN14SoftwareSerial4peekEv+0x2a>
    3258:	e0 91 10 04 	lds	r30, 0x0410	; 0x800410 <_ZN14SoftwareSerial20_receive_buffer_headE>
    325c:	f0 e0       	ldi	r31, 0x00	; 0
    325e:	ee 5e       	subi	r30, 0xEE	; 238
    3260:	fb 4f       	sbci	r31, 0xFB	; 251
    3262:	80 81       	ld	r24, Z
    3264:	90 e0       	ldi	r25, 0x00	; 0
    3266:	08 95       	ret
    3268:	8f ef       	ldi	r24, 0xFF	; 255
    326a:	9f ef       	ldi	r25, 0xFF	; 255
    326c:	08 95       	ret

0000326e <_ZN14SoftwareSerial9availableEv>:
    326e:	20 91 52 04 	lds	r18, 0x0452	; 0x800452 <_ZN14SoftwareSerial13active_objectE>
    3272:	30 91 53 04 	lds	r19, 0x0453	; 0x800453 <_ZN14SoftwareSerial13active_objectE+0x1>
    3276:	28 17       	cp	r18, r24
    3278:	39 07       	cpc	r19, r25
    327a:	71 f4       	brne	.+28     	; 0x3298 <_ZN14SoftwareSerial9availableEv+0x2a>
    327c:	80 91 11 04 	lds	r24, 0x0411	; 0x800411 <_ZN14SoftwareSerial20_receive_buffer_tailE>
    3280:	20 91 10 04 	lds	r18, 0x0410	; 0x800410 <_ZN14SoftwareSerial20_receive_buffer_headE>
    3284:	90 e0       	ldi	r25, 0x00	; 0
    3286:	80 5c       	subi	r24, 0xC0	; 192
    3288:	9f 4f       	sbci	r25, 0xFF	; 255
    328a:	82 1b       	sub	r24, r18
    328c:	91 09       	sbc	r25, r1
    328e:	60 e4       	ldi	r22, 0x40	; 64
    3290:	70 e0       	ldi	r23, 0x00	; 0
    3292:	0e 94 f6 23 	call	0x47ec	; 0x47ec <__divmodhi4>
    3296:	08 95       	ret
    3298:	80 e0       	ldi	r24, 0x00	; 0
    329a:	90 e0       	ldi	r25, 0x00	; 0
    329c:	08 95       	ret

0000329e <_ZN14SoftwareSerial13stopListeningEv>:
    329e:	e0 91 52 04 	lds	r30, 0x0452	; 0x800452 <_ZN14SoftwareSerial13active_objectE>
    32a2:	f0 91 53 04 	lds	r31, 0x0453	; 0x800453 <_ZN14SoftwareSerial13active_objectE+0x1>
    32a6:	e8 17       	cp	r30, r24
    32a8:	f9 07       	cpc	r31, r25
    32aa:	69 f4       	brne	.+26     	; 0x32c6 <_ZN14SoftwareSerial13stopListeningEv+0x28>
    32ac:	a3 89       	ldd	r26, Z+19	; 0x13
    32ae:	b4 89       	ldd	r27, Z+20	; 0x14
    32b0:	9c 91       	ld	r25, X
    32b2:	85 89       	ldd	r24, Z+21	; 0x15
    32b4:	80 95       	com	r24
    32b6:	89 23       	and	r24, r25
    32b8:	8c 93       	st	X, r24
    32ba:	10 92 53 04 	sts	0x0453, r1	; 0x800453 <_ZN14SoftwareSerial13active_objectE+0x1>
    32be:	10 92 52 04 	sts	0x0452, r1	; 0x800452 <_ZN14SoftwareSerial13active_objectE>
    32c2:	81 e0       	ldi	r24, 0x01	; 1
    32c4:	08 95       	ret
    32c6:	80 e0       	ldi	r24, 0x00	; 0
    32c8:	08 95       	ret

000032ca <_ZN14SoftwareSerial6listenEv>:
    32ca:	cf 93       	push	r28
    32cc:	df 93       	push	r29
    32ce:	ec 01       	movw	r28, r24
    32d0:	8a 8d       	ldd	r24, Y+26	; 0x1a
    32d2:	9b 8d       	ldd	r25, Y+27	; 0x1b
    32d4:	89 2b       	or	r24, r25
    32d6:	f1 f0       	breq	.+60     	; 0x3314 <_ZN14SoftwareSerial6listenEv+0x4a>
    32d8:	80 91 52 04 	lds	r24, 0x0452	; 0x800452 <_ZN14SoftwareSerial13active_objectE>
    32dc:	90 91 53 04 	lds	r25, 0x0453	; 0x800453 <_ZN14SoftwareSerial13active_objectE+0x1>
    32e0:	c8 17       	cp	r28, r24
    32e2:	d9 07       	cpc	r29, r25
    32e4:	b9 f0       	breq	.+46     	; 0x3314 <_ZN14SoftwareSerial6listenEv+0x4a>
    32e6:	00 97       	sbiw	r24, 0x00	; 0
    32e8:	11 f0       	breq	.+4      	; 0x32ee <_ZN14SoftwareSerial6listenEv+0x24>
    32ea:	0e 94 4f 19 	call	0x329e	; 0x329e <_ZN14SoftwareSerial13stopListeningEv>
    32ee:	8e 8d       	ldd	r24, Y+30	; 0x1e
    32f0:	8e 7f       	andi	r24, 0xFE	; 254
    32f2:	8e 8f       	std	Y+30, r24	; 0x1e
    32f4:	10 92 11 04 	sts	0x0411, r1	; 0x800411 <_ZN14SoftwareSerial20_receive_buffer_tailE>
    32f8:	10 92 10 04 	sts	0x0410, r1	; 0x800410 <_ZN14SoftwareSerial20_receive_buffer_headE>
    32fc:	d0 93 53 04 	sts	0x0453, r29	; 0x800453 <_ZN14SoftwareSerial13active_objectE+0x1>
    3300:	c0 93 52 04 	sts	0x0452, r28	; 0x800452 <_ZN14SoftwareSerial13active_objectE>
    3304:	eb 89       	ldd	r30, Y+19	; 0x13
    3306:	fc 89       	ldd	r31, Y+20	; 0x14
    3308:	90 81       	ld	r25, Z
    330a:	8d 89       	ldd	r24, Y+21	; 0x15
    330c:	89 2b       	or	r24, r25
    330e:	80 83       	st	Z, r24
    3310:	81 e0       	ldi	r24, 0x01	; 1
    3312:	01 c0       	rjmp	.+2      	; 0x3316 <_ZN14SoftwareSerial6listenEv+0x4c>
    3314:	80 e0       	ldi	r24, 0x00	; 0
    3316:	df 91       	pop	r29
    3318:	cf 91       	pop	r28
    331a:	08 95       	ret

0000331c <__vector_3>:
    331c:	1f 92       	push	r1
    331e:	0f 92       	push	r0
    3320:	0f b6       	in	r0, 0x3f	; 63
    3322:	0f 92       	push	r0
    3324:	11 24       	eor	r1, r1
    3326:	2f 93       	push	r18
    3328:	3f 93       	push	r19
    332a:	4f 93       	push	r20
    332c:	5f 93       	push	r21
    332e:	6f 93       	push	r22
    3330:	7f 93       	push	r23
    3332:	8f 93       	push	r24
    3334:	9f 93       	push	r25
    3336:	af 93       	push	r26
    3338:	bf 93       	push	r27
    333a:	ef 93       	push	r30
    333c:	ff 93       	push	r31
    333e:	e0 91 52 04 	lds	r30, 0x0452	; 0x800452 <_ZN14SoftwareSerial13active_objectE>
    3342:	f0 91 53 04 	lds	r31, 0x0453	; 0x800453 <_ZN14SoftwareSerial13active_objectE+0x1>
    3346:	30 97       	sbiw	r30, 0x00	; 0
    3348:	09 f4       	brne	.+2      	; 0x334c <__vector_3+0x30>
    334a:	51 c0       	rjmp	.+162    	; 0x33ee <__vector_3+0xd2>
    334c:	96 8d       	ldd	r25, Z+30	; 0x1e
    334e:	a6 85       	ldd	r26, Z+14	; 0x0e
    3350:	b7 85       	ldd	r27, Z+15	; 0x0f
    3352:	85 85       	ldd	r24, Z+13	; 0x0d
    3354:	91 ff       	sbrs	r25, 1
    3356:	04 c0       	rjmp	.+8      	; 0x3360 <__vector_3+0x44>
    3358:	9c 91       	ld	r25, X
    335a:	89 23       	and	r24, r25
    335c:	29 f4       	brne	.+10     	; 0x3368 <__vector_3+0x4c>
    335e:	47 c0       	rjmp	.+142    	; 0x33ee <__vector_3+0xd2>
    3360:	9c 91       	ld	r25, X
    3362:	89 23       	and	r24, r25
    3364:	09 f0       	breq	.+2      	; 0x3368 <__vector_3+0x4c>
    3366:	43 c0       	rjmp	.+134    	; 0x33ee <__vector_3+0xd2>
    3368:	a3 89       	ldd	r26, Z+19	; 0x13
    336a:	b4 89       	ldd	r27, Z+20	; 0x14
    336c:	9c 91       	ld	r25, X
    336e:	85 89       	ldd	r24, Z+21	; 0x15
    3370:	80 95       	com	r24
    3372:	89 23       	and	r24, r25
    3374:	8c 93       	st	X, r24
    3376:	86 89       	ldd	r24, Z+22	; 0x16
    3378:	97 89       	ldd	r25, Z+23	; 0x17
    337a:	01 97       	sbiw	r24, 0x01	; 1
    337c:	f1 f7       	brne	.-4      	; 0x337a <__vector_3+0x5e>
    337e:	60 8d       	ldd	r22, Z+24	; 0x18
    3380:	71 8d       	ldd	r23, Z+25	; 0x19
    3382:	a6 85       	ldd	r26, Z+14	; 0x0e
    3384:	b7 85       	ldd	r27, Z+15	; 0x0f
    3386:	55 85       	ldd	r21, Z+13	; 0x0d
    3388:	38 e0       	ldi	r19, 0x08	; 8
    338a:	20 e0       	ldi	r18, 0x00	; 0
    338c:	cb 01       	movw	r24, r22
    338e:	01 97       	sbiw	r24, 0x01	; 1
    3390:	f1 f7       	brne	.-4      	; 0x338e <__vector_3+0x72>
    3392:	82 2f       	mov	r24, r18
    3394:	90 e0       	ldi	r25, 0x00	; 0
    3396:	95 95       	asr	r25
    3398:	87 95       	ror	r24
    339a:	28 2f       	mov	r18, r24
    339c:	4c 91       	ld	r20, X
    339e:	45 23       	and	r20, r21
    33a0:	09 f0       	breq	.+2      	; 0x33a4 <__vector_3+0x88>
    33a2:	20 68       	ori	r18, 0x80	; 128
    33a4:	31 50       	subi	r19, 0x01	; 1
    33a6:	91 f7       	brne	.-28     	; 0x338c <__vector_3+0x70>
    33a8:	86 8d       	ldd	r24, Z+30	; 0x1e
    33aa:	81 fd       	sbrc	r24, 1
    33ac:	20 95       	com	r18
    33ae:	80 91 11 04 	lds	r24, 0x0411	; 0x800411 <_ZN14SoftwareSerial20_receive_buffer_tailE>
    33b2:	90 e0       	ldi	r25, 0x00	; 0
    33b4:	01 96       	adiw	r24, 0x01	; 1
    33b6:	8f 73       	andi	r24, 0x3F	; 63
    33b8:	99 27       	eor	r25, r25
    33ba:	30 91 10 04 	lds	r19, 0x0410	; 0x800410 <_ZN14SoftwareSerial20_receive_buffer_headE>
    33be:	38 17       	cp	r19, r24
    33c0:	49 f0       	breq	.+18     	; 0x33d4 <__vector_3+0xb8>
    33c2:	a0 91 11 04 	lds	r26, 0x0411	; 0x800411 <_ZN14SoftwareSerial20_receive_buffer_tailE>
    33c6:	b0 e0       	ldi	r27, 0x00	; 0
    33c8:	ae 5e       	subi	r26, 0xEE	; 238
    33ca:	bb 4f       	sbci	r27, 0xFB	; 251
    33cc:	2c 93       	st	X, r18
    33ce:	80 93 11 04 	sts	0x0411, r24	; 0x800411 <_ZN14SoftwareSerial20_receive_buffer_tailE>
    33d2:	03 c0       	rjmp	.+6      	; 0x33da <__vector_3+0xbe>
    33d4:	86 8d       	ldd	r24, Z+30	; 0x1e
    33d6:	81 60       	ori	r24, 0x01	; 1
    33d8:	86 8f       	std	Z+30, r24	; 0x1e
    33da:	82 8d       	ldd	r24, Z+26	; 0x1a
    33dc:	93 8d       	ldd	r25, Z+27	; 0x1b
    33de:	01 97       	sbiw	r24, 0x01	; 1
    33e0:	f1 f7       	brne	.-4      	; 0x33de <__vector_3+0xc2>
    33e2:	a3 89       	ldd	r26, Z+19	; 0x13
    33e4:	b4 89       	ldd	r27, Z+20	; 0x14
    33e6:	9c 91       	ld	r25, X
    33e8:	85 89       	ldd	r24, Z+21	; 0x15
    33ea:	89 2b       	or	r24, r25
    33ec:	8c 93       	st	X, r24
    33ee:	ff 91       	pop	r31
    33f0:	ef 91       	pop	r30
    33f2:	bf 91       	pop	r27
    33f4:	af 91       	pop	r26
    33f6:	9f 91       	pop	r25
    33f8:	8f 91       	pop	r24
    33fa:	7f 91       	pop	r23
    33fc:	6f 91       	pop	r22
    33fe:	5f 91       	pop	r21
    3400:	4f 91       	pop	r20
    3402:	3f 91       	pop	r19
    3404:	2f 91       	pop	r18
    3406:	0f 90       	pop	r0
    3408:	0f be       	out	0x3f, r0	; 63
    340a:	0f 90       	pop	r0
    340c:	1f 90       	pop	r1
    340e:	18 95       	reti

00003410 <_ZN14SoftwareSerialD1Ev>:
    3410:	2a e1       	ldi	r18, 0x1A	; 26
    3412:	32 e0       	ldi	r19, 0x02	; 2
    3414:	fc 01       	movw	r30, r24
    3416:	31 83       	std	Z+1, r19	; 0x01
    3418:	20 83       	st	Z, r18
    341a:	0c 94 4f 19 	jmp	0x329e	; 0x329e <_ZN14SoftwareSerial13stopListeningEv>

0000341e <_ZN14SoftwareSerial5setTXEh>:
    341e:	1f 93       	push	r17
    3420:	cf 93       	push	r28
    3422:	df 93       	push	r29
    3424:	ec 01       	movw	r28, r24
    3426:	16 2f       	mov	r17, r22
    3428:	6e 8d       	ldd	r22, Y+30	; 0x1e
    342a:	66 95       	lsr	r22
    342c:	61 70       	andi	r22, 0x01	; 1
    342e:	81 e0       	ldi	r24, 0x01	; 1
    3430:	68 27       	eor	r22, r24
    3432:	81 2f       	mov	r24, r17
    3434:	0e 94 b0 22 	call	0x4560	; 0x4560 <digitalWrite>
    3438:	61 e0       	ldi	r22, 0x01	; 1
    343a:	81 2f       	mov	r24, r17
    343c:	0e 94 74 22 	call	0x44e8	; 0x44e8 <pinMode>
    3440:	81 2f       	mov	r24, r17
    3442:	90 e0       	ldi	r25, 0x00	; 0
    3444:	fc 01       	movw	r30, r24
    3446:	ea 53       	subi	r30, 0x3A	; 58
    3448:	ff 4f       	sbci	r31, 0xFF	; 255
    344a:	e4 91       	lpm	r30, Z
    344c:	e8 8b       	std	Y+16, r30	; 0x10
    344e:	fc 01       	movw	r30, r24
    3450:	e6 52       	subi	r30, 0x26	; 38
    3452:	ff 4f       	sbci	r31, 0xFF	; 255
    3454:	e4 91       	lpm	r30, Z
    3456:	f0 e0       	ldi	r31, 0x00	; 0
    3458:	ee 0f       	add	r30, r30
    345a:	ff 1f       	adc	r31, r31
    345c:	e8 50       	subi	r30, 0x08	; 8
    345e:	ff 4f       	sbci	r31, 0xFF	; 255
    3460:	85 91       	lpm	r24, Z+
    3462:	94 91       	lpm	r25, Z
    3464:	9a 8b       	std	Y+18, r25	; 0x12
    3466:	89 8b       	std	Y+17, r24	; 0x11
    3468:	df 91       	pop	r29
    346a:	cf 91       	pop	r28
    346c:	1f 91       	pop	r17
    346e:	08 95       	ret

00003470 <_ZN14SoftwareSerial5setRXEh>:
    3470:	1f 93       	push	r17
    3472:	cf 93       	push	r28
    3474:	df 93       	push	r29
    3476:	ec 01       	movw	r28, r24
    3478:	16 2f       	mov	r17, r22
    347a:	60 e0       	ldi	r22, 0x00	; 0
    347c:	81 2f       	mov	r24, r17
    347e:	0e 94 74 22 	call	0x44e8	; 0x44e8 <pinMode>
    3482:	8e 8d       	ldd	r24, Y+30	; 0x1e
    3484:	81 fd       	sbrc	r24, 1
    3486:	04 c0       	rjmp	.+8      	; 0x3490 <_ZN14SoftwareSerial5setRXEh+0x20>
    3488:	61 e0       	ldi	r22, 0x01	; 1
    348a:	81 2f       	mov	r24, r17
    348c:	0e 94 b0 22 	call	0x4560	; 0x4560 <digitalWrite>
    3490:	1c 87       	std	Y+12, r17	; 0x0c
    3492:	81 2f       	mov	r24, r17
    3494:	90 e0       	ldi	r25, 0x00	; 0
    3496:	fc 01       	movw	r30, r24
    3498:	ea 53       	subi	r30, 0x3A	; 58
    349a:	ff 4f       	sbci	r31, 0xFF	; 255
    349c:	e4 91       	lpm	r30, Z
    349e:	ed 87       	std	Y+13, r30	; 0x0d
    34a0:	fc 01       	movw	r30, r24
    34a2:	e6 52       	subi	r30, 0x26	; 38
    34a4:	ff 4f       	sbci	r31, 0xFF	; 255
    34a6:	e4 91       	lpm	r30, Z
    34a8:	f0 e0       	ldi	r31, 0x00	; 0
    34aa:	ee 0f       	add	r30, r30
    34ac:	ff 1f       	adc	r31, r31
    34ae:	e2 51       	subi	r30, 0x12	; 18
    34b0:	ff 4f       	sbci	r31, 0xFF	; 255
    34b2:	85 91       	lpm	r24, Z+
    34b4:	94 91       	lpm	r25, Z
    34b6:	9f 87       	std	Y+15, r25	; 0x0f
    34b8:	8e 87       	std	Y+14, r24	; 0x0e
    34ba:	df 91       	pop	r29
    34bc:	cf 91       	pop	r28
    34be:	1f 91       	pop	r17
    34c0:	08 95       	ret

000034c2 <_ZN14SoftwareSerialC1Ehhb>:
    34c2:	1f 93       	push	r17
    34c4:	cf 93       	push	r28
    34c6:	df 93       	push	r29
    34c8:	ec 01       	movw	r28, r24
    34ca:	16 2f       	mov	r17, r22
    34cc:	1b 82       	std	Y+3, r1	; 0x03
    34ce:	1a 82       	std	Y+2, r1	; 0x02
    34d0:	88 ee       	ldi	r24, 0xE8	; 232
    34d2:	93 e0       	ldi	r25, 0x03	; 3
    34d4:	a0 e0       	ldi	r26, 0x00	; 0
    34d6:	b0 e0       	ldi	r27, 0x00	; 0
    34d8:	8c 83       	std	Y+4, r24	; 0x04
    34da:	9d 83       	std	Y+5, r25	; 0x05
    34dc:	ae 83       	std	Y+6, r26	; 0x06
    34de:	bf 83       	std	Y+7, r27	; 0x07
    34e0:	8a e1       	ldi	r24, 0x1A	; 26
    34e2:	92 e0       	ldi	r25, 0x02	; 2
    34e4:	99 83       	std	Y+1, r25	; 0x01
    34e6:	88 83       	st	Y, r24
    34e8:	1f 8a       	std	Y+23, r1	; 0x17
    34ea:	1e 8a       	std	Y+22, r1	; 0x16
    34ec:	19 8e       	std	Y+25, r1	; 0x19
    34ee:	18 8e       	std	Y+24, r1	; 0x18
    34f0:	1b 8e       	std	Y+27, r1	; 0x1b
    34f2:	1a 8e       	std	Y+26, r1	; 0x1a
    34f4:	1d 8e       	std	Y+29, r1	; 0x1d
    34f6:	1c 8e       	std	Y+28, r1	; 0x1c
    34f8:	8e 8d       	ldd	r24, Y+30	; 0x1e
    34fa:	8e 7f       	andi	r24, 0xFE	; 254
    34fc:	20 fb       	bst	r18, 0
    34fe:	81 f9       	bld	r24, 1
    3500:	8e 8f       	std	Y+30, r24	; 0x1e
    3502:	64 2f       	mov	r22, r20
    3504:	ce 01       	movw	r24, r28
    3506:	0e 94 0f 1a 	call	0x341e	; 0x341e <_ZN14SoftwareSerial5setTXEh>
    350a:	61 2f       	mov	r22, r17
    350c:	ce 01       	movw	r24, r28
    350e:	df 91       	pop	r29
    3510:	cf 91       	pop	r28
    3512:	1f 91       	pop	r17
    3514:	0c 94 38 1a 	jmp	0x3470	; 0x3470 <_ZN14SoftwareSerial5setRXEh>

00003518 <_ZN14SoftwareSerial5beginEl>:
//
// Public methods
//

void SoftwareSerial::begin(long speed)
{
    3518:	cf 93       	push	r28
    351a:	df 93       	push	r29
    351c:	ec 01       	movw	r28, r24
    351e:	9a 01       	movw	r18, r20
    3520:	ab 01       	movw	r20, r22
  _rx_delay_centering = _rx_delay_intrabit = _rx_delay_stopbit = _tx_delay = 0;
    3522:	1b 8e       	std	Y+27, r1	; 0x1b
    3524:	1a 8e       	std	Y+26, r1	; 0x1a
    3526:	19 8e       	std	Y+25, r1	; 0x19
    3528:	18 8e       	std	Y+24, r1	; 0x18
    352a:	1f 8a       	std	Y+23, r1	; 0x17
    352c:	1e 8a       	std	Y+22, r1	; 0x16

  // Precalculate the various delays, in number of 4-cycle delays
  uint16_t bit_delay = (F_CPU / speed) / 4;
    352e:	60 e0       	ldi	r22, 0x00	; 0
    3530:	79 e0       	ldi	r23, 0x09	; 9
    3532:	8d e3       	ldi	r24, 0x3D	; 61
    3534:	90 e0       	ldi	r25, 0x00	; 0
    3536:	0e 94 2c 24 	call	0x4858	; 0x4858 <__divmodsi4>
    353a:	f9 01       	movw	r30, r18
  uint8_t port = digitalPinToPort(rx);
  _receivePortRegister = portInputRegister(port);
}

uint16_t SoftwareSerial::subtract_cap(uint16_t num, uint16_t sub) {
  if (num > sub)
    353c:	24 30       	cpi	r18, 0x04	; 4
    353e:	31 05       	cpc	r19, r1
    3540:	18 f0       	brcs	.+6      	; 0x3548 <_ZN14SoftwareSerial5beginEl+0x30>
    return num - sub;
    3542:	c9 01       	movw	r24, r18
    3544:	03 97       	sbiw	r24, 0x03	; 3
    3546:	02 c0       	rjmp	.+4      	; 0x354c <_ZN14SoftwareSerial5beginEl+0x34>
  else
    return 1;
    3548:	81 e0       	ldi	r24, 0x01	; 1
    354a:	90 e0       	ldi	r25, 0x00	; 0
  // 12 (gcc 4.8.2) or 13 (gcc 4.3.2) cycles from start bit to first bit,
  // 15 (gcc 4.8.2) or 16 (gcc 4.3.2) cycles between bits,
  // 12 (gcc 4.8.2) or 14 (gcc 4.3.2) cycles from last bit to stop bit
  // These are all close enough to just use 15 cycles, since the inter-bit
  // timings are the most critical (deviations stack 8 times)
  _tx_delay = subtract_cap(bit_delay, 15 / 4);
    354c:	9d 8f       	std	Y+29, r25	; 0x1d
    354e:	8c 8f       	std	Y+28, r24	; 0x1c

  // Only setup rx when we have a valid PCINT for this pin
  if (digitalPinToPCICR(_receivePin)) {
    3550:	6c 85       	ldd	r22, Y+12	; 0x0c
    3552:	66 31       	cpi	r22, 0x16	; 22
    3554:	08 f0       	brcs	.+2      	; 0x3558 <_ZN14SoftwareSerial5beginEl+0x40>
    3556:	69 c0       	rjmp	.+210    	; 0x362a <_ZN14SoftwareSerial5beginEl+0x112>
    // are 17 more cycles until the pin value is read (excluding the
    // delay in the loop).
    // We want to have a total delay of 1.5 bit time. Inside the loop,
    // we already wait for 1 bit time - 23 cycles, so here we wait for
    // 0.5 bit time - (71 + 18 - 22) cycles.
    _rx_delay_centering = subtract_cap(bit_delay / 2, (4 + 4 + 75 + 17 - 23) / 4);
    3558:	c9 01       	movw	r24, r18
    355a:	96 95       	lsr	r25
    355c:	87 95       	ror	r24
  uint8_t port = digitalPinToPort(rx);
  _receivePortRegister = portInputRegister(port);
}

uint16_t SoftwareSerial::subtract_cap(uint16_t num, uint16_t sub) {
  if (num > sub)
    355e:	84 31       	cpi	r24, 0x14	; 20
    3560:	91 05       	cpc	r25, r1
    3562:	10 f0       	brcs	.+4      	; 0x3568 <_ZN14SoftwareSerial5beginEl+0x50>
    return num - sub;
    3564:	43 97       	sbiw	r24, 0x13	; 19
    3566:	02 c0       	rjmp	.+4      	; 0x356c <_ZN14SoftwareSerial5beginEl+0x54>
  else
    return 1;
    3568:	81 e0       	ldi	r24, 0x01	; 1
    356a:	90 e0       	ldi	r25, 0x00	; 0
    // are 17 more cycles until the pin value is read (excluding the
    // delay in the loop).
    // We want to have a total delay of 1.5 bit time. Inside the loop,
    // we already wait for 1 bit time - 23 cycles, so here we wait for
    // 0.5 bit time - (71 + 18 - 22) cycles.
    _rx_delay_centering = subtract_cap(bit_delay / 2, (4 + 4 + 75 + 17 - 23) / 4);
    356c:	9f 8b       	std	Y+23, r25	; 0x17
    356e:	8e 8b       	std	Y+22, r24	; 0x16
  uint8_t port = digitalPinToPort(rx);
  _receivePortRegister = portInputRegister(port);
}

uint16_t SoftwareSerial::subtract_cap(uint16_t num, uint16_t sub) {
  if (num > sub)
    3570:	36 97       	sbiw	r30, 0x06	; 6
    3572:	18 f0       	brcs	.+6      	; 0x357a <_ZN14SoftwareSerial5beginEl+0x62>
    return num - sub;
    3574:	c9 01       	movw	r24, r18
    3576:	05 97       	sbiw	r24, 0x05	; 5
    3578:	02 c0       	rjmp	.+4      	; 0x357e <_ZN14SoftwareSerial5beginEl+0x66>
  else
    return 1;
    357a:	81 e0       	ldi	r24, 0x01	; 1
    357c:	90 e0       	ldi	r25, 0x00	; 0
    // we already wait for 1 bit time - 23 cycles, so here we wait for
    // 0.5 bit time - (71 + 18 - 22) cycles.
    _rx_delay_centering = subtract_cap(bit_delay / 2, (4 + 4 + 75 + 17 - 23) / 4);

    // There are 23 cycles in each loop iteration (excluding the delay)
    _rx_delay_intrabit = subtract_cap(bit_delay, 23 / 4);
    357e:	99 8f       	std	Y+25, r25	; 0x19
    3580:	88 8f       	std	Y+24, r24	; 0x18
    // mask is enabled again (which _must_ happen during the stopbit).
    // This delay aims at 3/4 of a bit time, meaning the end of the
    // delay will be at 1/4th of the stopbit. This allows some extra
    // time for ISR cleanup, which makes 115200 baud at 16Mhz work more
    // reliably
    _rx_delay_stopbit = subtract_cap(bit_delay * 3 / 4, (37 + 11) / 4);
    3582:	c9 01       	movw	r24, r18
    3584:	88 0f       	add	r24, r24
    3586:	99 1f       	adc	r25, r25
    3588:	28 0f       	add	r18, r24
    358a:	39 1f       	adc	r19, r25
    358c:	36 95       	lsr	r19
    358e:	27 95       	ror	r18
    3590:	36 95       	lsr	r19
    3592:	27 95       	ror	r18
  uint8_t port = digitalPinToPort(rx);
  _receivePortRegister = portInputRegister(port);
}

uint16_t SoftwareSerial::subtract_cap(uint16_t num, uint16_t sub) {
  if (num > sub)
    3594:	2d 30       	cpi	r18, 0x0D	; 13
    3596:	31 05       	cpc	r19, r1
    3598:	18 f0       	brcs	.+6      	; 0x35a0 <_ZN14SoftwareSerial5beginEl+0x88>
    return num - sub;
    359a:	2c 50       	subi	r18, 0x0C	; 12
    359c:	31 09       	sbc	r19, r1
    359e:	02 c0       	rjmp	.+4      	; 0x35a4 <_ZN14SoftwareSerial5beginEl+0x8c>
  else
    return 1;
    35a0:	21 e0       	ldi	r18, 0x01	; 1
    35a2:	30 e0       	ldi	r19, 0x00	; 0
    // mask is enabled again (which _must_ happen during the stopbit).
    // This delay aims at 3/4 of a bit time, meaning the end of the
    // delay will be at 1/4th of the stopbit. This allows some extra
    // time for ISR cleanup, which makes 115200 baud at 16Mhz work more
    // reliably
    _rx_delay_stopbit = subtract_cap(bit_delay * 3 / 4, (37 + 11) / 4);
    35a4:	3b 8f       	std	Y+27, r19	; 0x1b
    35a6:	2a 8f       	std	Y+26, r18	; 0x1a


    // Enable the PCINT for the entire port here, but never disable it
    // (others might also need it, so we disable the interrupt by using
    // the per-pin PCMSK register).
    *digitalPinToPCICR(_receivePin) |= _BV(digitalPinToPCICRbit(_receivePin));
    35a8:	90 91 68 00 	lds	r25, 0x0068	; 0x800068 <__DATA_REGION_ORIGIN__+0x8>
    35ac:	68 30       	cpi	r22, 0x08	; 8
    35ae:	50 f0       	brcs	.+20     	; 0x35c4 <_ZN14SoftwareSerial5beginEl+0xac>
    35b0:	21 e0       	ldi	r18, 0x01	; 1
    35b2:	6e 30       	cpi	r22, 0x0E	; 14
    35b4:	08 f4       	brcc	.+2      	; 0x35b8 <_ZN14SoftwareSerial5beginEl+0xa0>
    35b6:	20 e0       	ldi	r18, 0x00	; 0
    35b8:	81 e0       	ldi	r24, 0x01	; 1
    35ba:	01 c0       	rjmp	.+2      	; 0x35be <_ZN14SoftwareSerial5beginEl+0xa6>
    35bc:	88 0f       	add	r24, r24
    35be:	2a 95       	dec	r18
    35c0:	ea f7       	brpl	.-6      	; 0x35bc <_ZN14SoftwareSerial5beginEl+0xa4>
    35c2:	01 c0       	rjmp	.+2      	; 0x35c6 <_ZN14SoftwareSerial5beginEl+0xae>
    35c4:	84 e0       	ldi	r24, 0x04	; 4
    35c6:	89 2b       	or	r24, r25
    35c8:	80 93 68 00 	sts	0x0068, r24	; 0x800068 <__DATA_REGION_ORIGIN__+0x8>
    // Precalculate the pcint mask register and value, so setRxIntMask
    // can be used inside the ISR without costing too much time.
    _pcint_maskreg = digitalPinToPCMSK(_receivePin);
    35cc:	9c 85       	ldd	r25, Y+12	; 0x0c
    35ce:	98 30       	cpi	r25, 0x08	; 8
    35d0:	38 f0       	brcs	.+14     	; 0x35e0 <_ZN14SoftwareSerial5beginEl+0xc8>
    35d2:	9e 30       	cpi	r25, 0x0E	; 14
    35d4:	40 f0       	brcs	.+16     	; 0x35e6 <_ZN14SoftwareSerial5beginEl+0xce>
    35d6:	96 31       	cpi	r25, 0x16	; 22
    35d8:	48 f0       	brcs	.+18     	; 0x35ec <_ZN14SoftwareSerial5beginEl+0xd4>
    35da:	20 e0       	ldi	r18, 0x00	; 0
    35dc:	30 e0       	ldi	r19, 0x00	; 0
    35de:	08 c0       	rjmp	.+16     	; 0x35f0 <_ZN14SoftwareSerial5beginEl+0xd8>
    35e0:	2d e6       	ldi	r18, 0x6D	; 109
    35e2:	30 e0       	ldi	r19, 0x00	; 0
    35e4:	05 c0       	rjmp	.+10     	; 0x35f0 <_ZN14SoftwareSerial5beginEl+0xd8>
    35e6:	2b e6       	ldi	r18, 0x6B	; 107
    35e8:	30 e0       	ldi	r19, 0x00	; 0
    35ea:	02 c0       	rjmp	.+4      	; 0x35f0 <_ZN14SoftwareSerial5beginEl+0xd8>
    35ec:	2c e6       	ldi	r18, 0x6C	; 108
    35ee:	30 e0       	ldi	r19, 0x00	; 0
    35f0:	3c 8b       	std	Y+20, r19	; 0x14
    35f2:	2b 8b       	std	Y+19, r18	; 0x13
    _pcint_maskvalue = _BV(digitalPinToPCMSKbit(_receivePin));
    35f4:	98 30       	cpi	r25, 0x08	; 8
    35f6:	30 f4       	brcc	.+12     	; 0x3604 <_ZN14SoftwareSerial5beginEl+0xec>
    35f8:	81 e0       	ldi	r24, 0x01	; 1
    35fa:	01 c0       	rjmp	.+2      	; 0x35fe <_ZN14SoftwareSerial5beginEl+0xe6>
    35fc:	88 0f       	add	r24, r24
    35fe:	9a 95       	dec	r25
    3600:	ea f7       	brpl	.-6      	; 0x35fc <_ZN14SoftwareSerial5beginEl+0xe4>
    3602:	0e c0       	rjmp	.+28     	; 0x3620 <_ZN14SoftwareSerial5beginEl+0x108>
    3604:	29 2f       	mov	r18, r25
    3606:	30 e0       	ldi	r19, 0x00	; 0
    3608:	9e 30       	cpi	r25, 0x0E	; 14
    360a:	18 f4       	brcc	.+6      	; 0x3612 <_ZN14SoftwareSerial5beginEl+0xfa>
    360c:	28 50       	subi	r18, 0x08	; 8
    360e:	31 09       	sbc	r19, r1
    3610:	02 c0       	rjmp	.+4      	; 0x3616 <_ZN14SoftwareSerial5beginEl+0xfe>
    3612:	2e 50       	subi	r18, 0x0E	; 14
    3614:	31 09       	sbc	r19, r1
    3616:	81 e0       	ldi	r24, 0x01	; 1
    3618:	01 c0       	rjmp	.+2      	; 0x361c <_ZN14SoftwareSerial5beginEl+0x104>
    361a:	88 0f       	add	r24, r24
    361c:	2a 95       	dec	r18
    361e:	ea f7       	brpl	.-6      	; 0x361a <_ZN14SoftwareSerial5beginEl+0x102>
    3620:	8d 8b       	std	Y+21, r24	; 0x15
	__asm__ volatile (
		"1: sbiw %0,1" "\n\t"
		"brne 1b"
		: "=w" (__count)
		: "0" (__count)
	);
    3622:	8c 8d       	ldd	r24, Y+28	; 0x1c
    3624:	9d 8d       	ldd	r25, Y+29	; 0x1d
    3626:	01 97       	sbiw	r24, 0x01	; 1
    3628:	f1 f7       	brne	.-4      	; 0x3626 <_ZN14SoftwareSerial5beginEl+0x10e>
#if _DEBUG
  pinMode(_DEBUG_PIN1, OUTPUT);
  pinMode(_DEBUG_PIN2, OUTPUT);
#endif

  listen();
    362a:	ce 01       	movw	r24, r28
}
    362c:	df 91       	pop	r29
    362e:	cf 91       	pop	r28
#if _DEBUG
  pinMode(_DEBUG_PIN1, OUTPUT);
  pinMode(_DEBUG_PIN2, OUTPUT);
#endif

  listen();
    3630:	0c 94 65 19 	jmp	0x32ca	; 0x32ca <_ZN14SoftwareSerial6listenEv>

00003634 <__subsf3>:
    3634:	50 58       	subi	r21, 0x80	; 128

00003636 <__addsf3>:
    3636:	bb 27       	eor	r27, r27
    3638:	aa 27       	eor	r26, r26
    363a:	0e 94 32 1b 	call	0x3664	; 0x3664 <__addsf3x>
    363e:	0c 94 ac 1c 	jmp	0x3958	; 0x3958 <__fp_round>
    3642:	0e 94 9e 1c 	call	0x393c	; 0x393c <__fp_pscA>
    3646:	38 f0       	brcs	.+14     	; 0x3656 <__addsf3+0x20>
    3648:	0e 94 a5 1c 	call	0x394a	; 0x394a <__fp_pscB>
    364c:	20 f0       	brcs	.+8      	; 0x3656 <__addsf3+0x20>
    364e:	39 f4       	brne	.+14     	; 0x365e <__addsf3+0x28>
    3650:	9f 3f       	cpi	r25, 0xFF	; 255
    3652:	19 f4       	brne	.+6      	; 0x365a <__addsf3+0x24>
    3654:	26 f4       	brtc	.+8      	; 0x365e <__addsf3+0x28>
    3656:	0c 94 9b 1c 	jmp	0x3936	; 0x3936 <__fp_nan>
    365a:	0e f4       	brtc	.+2      	; 0x365e <__addsf3+0x28>
    365c:	e0 95       	com	r30
    365e:	e7 fb       	bst	r30, 7
    3660:	0c 94 95 1c 	jmp	0x392a	; 0x392a <__fp_inf>

00003664 <__addsf3x>:
    3664:	e9 2f       	mov	r30, r25
    3666:	0e 94 bd 1c 	call	0x397a	; 0x397a <__fp_split3>
    366a:	58 f3       	brcs	.-42     	; 0x3642 <__addsf3+0xc>
    366c:	ba 17       	cp	r27, r26
    366e:	62 07       	cpc	r22, r18
    3670:	73 07       	cpc	r23, r19
    3672:	84 07       	cpc	r24, r20
    3674:	95 07       	cpc	r25, r21
    3676:	20 f0       	brcs	.+8      	; 0x3680 <__addsf3x+0x1c>
    3678:	79 f4       	brne	.+30     	; 0x3698 <__addsf3x+0x34>
    367a:	a6 f5       	brtc	.+104    	; 0x36e4 <__addsf3x+0x80>
    367c:	0c 94 df 1c 	jmp	0x39be	; 0x39be <__fp_zero>
    3680:	0e f4       	brtc	.+2      	; 0x3684 <__addsf3x+0x20>
    3682:	e0 95       	com	r30
    3684:	0b 2e       	mov	r0, r27
    3686:	ba 2f       	mov	r27, r26
    3688:	a0 2d       	mov	r26, r0
    368a:	0b 01       	movw	r0, r22
    368c:	b9 01       	movw	r22, r18
    368e:	90 01       	movw	r18, r0
    3690:	0c 01       	movw	r0, r24
    3692:	ca 01       	movw	r24, r20
    3694:	a0 01       	movw	r20, r0
    3696:	11 24       	eor	r1, r1
    3698:	ff 27       	eor	r31, r31
    369a:	59 1b       	sub	r21, r25
    369c:	99 f0       	breq	.+38     	; 0x36c4 <__addsf3x+0x60>
    369e:	59 3f       	cpi	r21, 0xF9	; 249
    36a0:	50 f4       	brcc	.+20     	; 0x36b6 <__addsf3x+0x52>
    36a2:	50 3e       	cpi	r21, 0xE0	; 224
    36a4:	68 f1       	brcs	.+90     	; 0x3700 <__addsf3x+0x9c>
    36a6:	1a 16       	cp	r1, r26
    36a8:	f0 40       	sbci	r31, 0x00	; 0
    36aa:	a2 2f       	mov	r26, r18
    36ac:	23 2f       	mov	r18, r19
    36ae:	34 2f       	mov	r19, r20
    36b0:	44 27       	eor	r20, r20
    36b2:	58 5f       	subi	r21, 0xF8	; 248
    36b4:	f3 cf       	rjmp	.-26     	; 0x369c <__addsf3x+0x38>
    36b6:	46 95       	lsr	r20
    36b8:	37 95       	ror	r19
    36ba:	27 95       	ror	r18
    36bc:	a7 95       	ror	r26
    36be:	f0 40       	sbci	r31, 0x00	; 0
    36c0:	53 95       	inc	r21
    36c2:	c9 f7       	brne	.-14     	; 0x36b6 <__addsf3x+0x52>
    36c4:	7e f4       	brtc	.+30     	; 0x36e4 <__addsf3x+0x80>
    36c6:	1f 16       	cp	r1, r31
    36c8:	ba 0b       	sbc	r27, r26
    36ca:	62 0b       	sbc	r22, r18
    36cc:	73 0b       	sbc	r23, r19
    36ce:	84 0b       	sbc	r24, r20
    36d0:	ba f0       	brmi	.+46     	; 0x3700 <__addsf3x+0x9c>
    36d2:	91 50       	subi	r25, 0x01	; 1
    36d4:	a1 f0       	breq	.+40     	; 0x36fe <__addsf3x+0x9a>
    36d6:	ff 0f       	add	r31, r31
    36d8:	bb 1f       	adc	r27, r27
    36da:	66 1f       	adc	r22, r22
    36dc:	77 1f       	adc	r23, r23
    36de:	88 1f       	adc	r24, r24
    36e0:	c2 f7       	brpl	.-16     	; 0x36d2 <__addsf3x+0x6e>
    36e2:	0e c0       	rjmp	.+28     	; 0x3700 <__addsf3x+0x9c>
    36e4:	ba 0f       	add	r27, r26
    36e6:	62 1f       	adc	r22, r18
    36e8:	73 1f       	adc	r23, r19
    36ea:	84 1f       	adc	r24, r20
    36ec:	48 f4       	brcc	.+18     	; 0x3700 <__addsf3x+0x9c>
    36ee:	87 95       	ror	r24
    36f0:	77 95       	ror	r23
    36f2:	67 95       	ror	r22
    36f4:	b7 95       	ror	r27
    36f6:	f7 95       	ror	r31
    36f8:	9e 3f       	cpi	r25, 0xFE	; 254
    36fa:	08 f0       	brcs	.+2      	; 0x36fe <__addsf3x+0x9a>
    36fc:	b0 cf       	rjmp	.-160    	; 0x365e <__addsf3+0x28>
    36fe:	93 95       	inc	r25
    3700:	88 0f       	add	r24, r24
    3702:	08 f0       	brcs	.+2      	; 0x3706 <__addsf3x+0xa2>
    3704:	99 27       	eor	r25, r25
    3706:	ee 0f       	add	r30, r30
    3708:	97 95       	ror	r25
    370a:	87 95       	ror	r24
    370c:	08 95       	ret

0000370e <__cmpsf2>:
    370e:	0e 94 71 1c 	call	0x38e2	; 0x38e2 <__fp_cmp>
    3712:	08 f4       	brcc	.+2      	; 0x3716 <__cmpsf2+0x8>
    3714:	81 e0       	ldi	r24, 0x01	; 1
    3716:	08 95       	ret

00003718 <__divsf3>:
    3718:	0e 94 a0 1b 	call	0x3740	; 0x3740 <__divsf3x>
    371c:	0c 94 ac 1c 	jmp	0x3958	; 0x3958 <__fp_round>
    3720:	0e 94 a5 1c 	call	0x394a	; 0x394a <__fp_pscB>
    3724:	58 f0       	brcs	.+22     	; 0x373c <__divsf3+0x24>
    3726:	0e 94 9e 1c 	call	0x393c	; 0x393c <__fp_pscA>
    372a:	40 f0       	brcs	.+16     	; 0x373c <__divsf3+0x24>
    372c:	29 f4       	brne	.+10     	; 0x3738 <__divsf3+0x20>
    372e:	5f 3f       	cpi	r21, 0xFF	; 255
    3730:	29 f0       	breq	.+10     	; 0x373c <__divsf3+0x24>
    3732:	0c 94 95 1c 	jmp	0x392a	; 0x392a <__fp_inf>
    3736:	51 11       	cpse	r21, r1
    3738:	0c 94 e0 1c 	jmp	0x39c0	; 0x39c0 <__fp_szero>
    373c:	0c 94 9b 1c 	jmp	0x3936	; 0x3936 <__fp_nan>

00003740 <__divsf3x>:
    3740:	0e 94 bd 1c 	call	0x397a	; 0x397a <__fp_split3>
    3744:	68 f3       	brcs	.-38     	; 0x3720 <__divsf3+0x8>

00003746 <__divsf3_pse>:
    3746:	99 23       	and	r25, r25
    3748:	b1 f3       	breq	.-20     	; 0x3736 <__divsf3+0x1e>
    374a:	55 23       	and	r21, r21
    374c:	91 f3       	breq	.-28     	; 0x3732 <__divsf3+0x1a>
    374e:	95 1b       	sub	r25, r21
    3750:	55 0b       	sbc	r21, r21
    3752:	bb 27       	eor	r27, r27
    3754:	aa 27       	eor	r26, r26
    3756:	62 17       	cp	r22, r18
    3758:	73 07       	cpc	r23, r19
    375a:	84 07       	cpc	r24, r20
    375c:	38 f0       	brcs	.+14     	; 0x376c <__divsf3_pse+0x26>
    375e:	9f 5f       	subi	r25, 0xFF	; 255
    3760:	5f 4f       	sbci	r21, 0xFF	; 255
    3762:	22 0f       	add	r18, r18
    3764:	33 1f       	adc	r19, r19
    3766:	44 1f       	adc	r20, r20
    3768:	aa 1f       	adc	r26, r26
    376a:	a9 f3       	breq	.-22     	; 0x3756 <__divsf3_pse+0x10>
    376c:	35 d0       	rcall	.+106    	; 0x37d8 <__divsf3_pse+0x92>
    376e:	0e 2e       	mov	r0, r30
    3770:	3a f0       	brmi	.+14     	; 0x3780 <__divsf3_pse+0x3a>
    3772:	e0 e8       	ldi	r30, 0x80	; 128
    3774:	32 d0       	rcall	.+100    	; 0x37da <__divsf3_pse+0x94>
    3776:	91 50       	subi	r25, 0x01	; 1
    3778:	50 40       	sbci	r21, 0x00	; 0
    377a:	e6 95       	lsr	r30
    377c:	00 1c       	adc	r0, r0
    377e:	ca f7       	brpl	.-14     	; 0x3772 <__divsf3_pse+0x2c>
    3780:	2b d0       	rcall	.+86     	; 0x37d8 <__divsf3_pse+0x92>
    3782:	fe 2f       	mov	r31, r30
    3784:	29 d0       	rcall	.+82     	; 0x37d8 <__divsf3_pse+0x92>
    3786:	66 0f       	add	r22, r22
    3788:	77 1f       	adc	r23, r23
    378a:	88 1f       	adc	r24, r24
    378c:	bb 1f       	adc	r27, r27
    378e:	26 17       	cp	r18, r22
    3790:	37 07       	cpc	r19, r23
    3792:	48 07       	cpc	r20, r24
    3794:	ab 07       	cpc	r26, r27
    3796:	b0 e8       	ldi	r27, 0x80	; 128
    3798:	09 f0       	breq	.+2      	; 0x379c <__divsf3_pse+0x56>
    379a:	bb 0b       	sbc	r27, r27
    379c:	80 2d       	mov	r24, r0
    379e:	bf 01       	movw	r22, r30
    37a0:	ff 27       	eor	r31, r31
    37a2:	93 58       	subi	r25, 0x83	; 131
    37a4:	5f 4f       	sbci	r21, 0xFF	; 255
    37a6:	3a f0       	brmi	.+14     	; 0x37b6 <__divsf3_pse+0x70>
    37a8:	9e 3f       	cpi	r25, 0xFE	; 254
    37aa:	51 05       	cpc	r21, r1
    37ac:	78 f0       	brcs	.+30     	; 0x37cc <__divsf3_pse+0x86>
    37ae:	0c 94 95 1c 	jmp	0x392a	; 0x392a <__fp_inf>
    37b2:	0c 94 e0 1c 	jmp	0x39c0	; 0x39c0 <__fp_szero>
    37b6:	5f 3f       	cpi	r21, 0xFF	; 255
    37b8:	e4 f3       	brlt	.-8      	; 0x37b2 <__divsf3_pse+0x6c>
    37ba:	98 3e       	cpi	r25, 0xE8	; 232
    37bc:	d4 f3       	brlt	.-12     	; 0x37b2 <__divsf3_pse+0x6c>
    37be:	86 95       	lsr	r24
    37c0:	77 95       	ror	r23
    37c2:	67 95       	ror	r22
    37c4:	b7 95       	ror	r27
    37c6:	f7 95       	ror	r31
    37c8:	9f 5f       	subi	r25, 0xFF	; 255
    37ca:	c9 f7       	brne	.-14     	; 0x37be <__divsf3_pse+0x78>
    37cc:	88 0f       	add	r24, r24
    37ce:	91 1d       	adc	r25, r1
    37d0:	96 95       	lsr	r25
    37d2:	87 95       	ror	r24
    37d4:	97 f9       	bld	r25, 7
    37d6:	08 95       	ret
    37d8:	e1 e0       	ldi	r30, 0x01	; 1
    37da:	66 0f       	add	r22, r22
    37dc:	77 1f       	adc	r23, r23
    37de:	88 1f       	adc	r24, r24
    37e0:	bb 1f       	adc	r27, r27
    37e2:	62 17       	cp	r22, r18
    37e4:	73 07       	cpc	r23, r19
    37e6:	84 07       	cpc	r24, r20
    37e8:	ba 07       	cpc	r27, r26
    37ea:	20 f0       	brcs	.+8      	; 0x37f4 <__divsf3_pse+0xae>
    37ec:	62 1b       	sub	r22, r18
    37ee:	73 0b       	sbc	r23, r19
    37f0:	84 0b       	sbc	r24, r20
    37f2:	ba 0b       	sbc	r27, r26
    37f4:	ee 1f       	adc	r30, r30
    37f6:	88 f7       	brcc	.-30     	; 0x37da <__divsf3_pse+0x94>
    37f8:	e0 95       	com	r30
    37fa:	08 95       	ret

000037fc <__fixsfsi>:
    37fc:	0e 94 05 1c 	call	0x380a	; 0x380a <__fixunssfsi>
    3800:	68 94       	set
    3802:	b1 11       	cpse	r27, r1
    3804:	0c 94 e0 1c 	jmp	0x39c0	; 0x39c0 <__fp_szero>
    3808:	08 95       	ret

0000380a <__fixunssfsi>:
    380a:	0e 94 c5 1c 	call	0x398a	; 0x398a <__fp_splitA>
    380e:	88 f0       	brcs	.+34     	; 0x3832 <__fixunssfsi+0x28>
    3810:	9f 57       	subi	r25, 0x7F	; 127
    3812:	98 f0       	brcs	.+38     	; 0x383a <__fixunssfsi+0x30>
    3814:	b9 2f       	mov	r27, r25
    3816:	99 27       	eor	r25, r25
    3818:	b7 51       	subi	r27, 0x17	; 23
    381a:	b0 f0       	brcs	.+44     	; 0x3848 <__fixunssfsi+0x3e>
    381c:	e1 f0       	breq	.+56     	; 0x3856 <__fixunssfsi+0x4c>
    381e:	66 0f       	add	r22, r22
    3820:	77 1f       	adc	r23, r23
    3822:	88 1f       	adc	r24, r24
    3824:	99 1f       	adc	r25, r25
    3826:	1a f0       	brmi	.+6      	; 0x382e <__fixunssfsi+0x24>
    3828:	ba 95       	dec	r27
    382a:	c9 f7       	brne	.-14     	; 0x381e <__fixunssfsi+0x14>
    382c:	14 c0       	rjmp	.+40     	; 0x3856 <__fixunssfsi+0x4c>
    382e:	b1 30       	cpi	r27, 0x01	; 1
    3830:	91 f0       	breq	.+36     	; 0x3856 <__fixunssfsi+0x4c>
    3832:	0e 94 df 1c 	call	0x39be	; 0x39be <__fp_zero>
    3836:	b1 e0       	ldi	r27, 0x01	; 1
    3838:	08 95       	ret
    383a:	0c 94 df 1c 	jmp	0x39be	; 0x39be <__fp_zero>
    383e:	67 2f       	mov	r22, r23
    3840:	78 2f       	mov	r23, r24
    3842:	88 27       	eor	r24, r24
    3844:	b8 5f       	subi	r27, 0xF8	; 248
    3846:	39 f0       	breq	.+14     	; 0x3856 <__fixunssfsi+0x4c>
    3848:	b9 3f       	cpi	r27, 0xF9	; 249
    384a:	cc f3       	brlt	.-14     	; 0x383e <__fixunssfsi+0x34>
    384c:	86 95       	lsr	r24
    384e:	77 95       	ror	r23
    3850:	67 95       	ror	r22
    3852:	b3 95       	inc	r27
    3854:	d9 f7       	brne	.-10     	; 0x384c <__fixunssfsi+0x42>
    3856:	3e f4       	brtc	.+14     	; 0x3866 <__fixunssfsi+0x5c>
    3858:	90 95       	com	r25
    385a:	80 95       	com	r24
    385c:	70 95       	com	r23
    385e:	61 95       	neg	r22
    3860:	7f 4f       	sbci	r23, 0xFF	; 255
    3862:	8f 4f       	sbci	r24, 0xFF	; 255
    3864:	9f 4f       	sbci	r25, 0xFF	; 255
    3866:	08 95       	ret

00003868 <__floatunsisf>:
    3868:	e8 94       	clt
    386a:	09 c0       	rjmp	.+18     	; 0x387e <__floatsisf+0x12>

0000386c <__floatsisf>:
    386c:	97 fb       	bst	r25, 7
    386e:	3e f4       	brtc	.+14     	; 0x387e <__floatsisf+0x12>
    3870:	90 95       	com	r25
    3872:	80 95       	com	r24
    3874:	70 95       	com	r23
    3876:	61 95       	neg	r22
    3878:	7f 4f       	sbci	r23, 0xFF	; 255
    387a:	8f 4f       	sbci	r24, 0xFF	; 255
    387c:	9f 4f       	sbci	r25, 0xFF	; 255
    387e:	99 23       	and	r25, r25
    3880:	a9 f0       	breq	.+42     	; 0x38ac <__floatsisf+0x40>
    3882:	f9 2f       	mov	r31, r25
    3884:	96 e9       	ldi	r25, 0x96	; 150
    3886:	bb 27       	eor	r27, r27
    3888:	93 95       	inc	r25
    388a:	f6 95       	lsr	r31
    388c:	87 95       	ror	r24
    388e:	77 95       	ror	r23
    3890:	67 95       	ror	r22
    3892:	b7 95       	ror	r27
    3894:	f1 11       	cpse	r31, r1
    3896:	f8 cf       	rjmp	.-16     	; 0x3888 <__floatsisf+0x1c>
    3898:	fa f4       	brpl	.+62     	; 0x38d8 <__floatsisf+0x6c>
    389a:	bb 0f       	add	r27, r27
    389c:	11 f4       	brne	.+4      	; 0x38a2 <__floatsisf+0x36>
    389e:	60 ff       	sbrs	r22, 0
    38a0:	1b c0       	rjmp	.+54     	; 0x38d8 <__floatsisf+0x6c>
    38a2:	6f 5f       	subi	r22, 0xFF	; 255
    38a4:	7f 4f       	sbci	r23, 0xFF	; 255
    38a6:	8f 4f       	sbci	r24, 0xFF	; 255
    38a8:	9f 4f       	sbci	r25, 0xFF	; 255
    38aa:	16 c0       	rjmp	.+44     	; 0x38d8 <__floatsisf+0x6c>
    38ac:	88 23       	and	r24, r24
    38ae:	11 f0       	breq	.+4      	; 0x38b4 <__floatsisf+0x48>
    38b0:	96 e9       	ldi	r25, 0x96	; 150
    38b2:	11 c0       	rjmp	.+34     	; 0x38d6 <__floatsisf+0x6a>
    38b4:	77 23       	and	r23, r23
    38b6:	21 f0       	breq	.+8      	; 0x38c0 <__floatsisf+0x54>
    38b8:	9e e8       	ldi	r25, 0x8E	; 142
    38ba:	87 2f       	mov	r24, r23
    38bc:	76 2f       	mov	r23, r22
    38be:	05 c0       	rjmp	.+10     	; 0x38ca <__floatsisf+0x5e>
    38c0:	66 23       	and	r22, r22
    38c2:	71 f0       	breq	.+28     	; 0x38e0 <__floatsisf+0x74>
    38c4:	96 e8       	ldi	r25, 0x86	; 134
    38c6:	86 2f       	mov	r24, r22
    38c8:	70 e0       	ldi	r23, 0x00	; 0
    38ca:	60 e0       	ldi	r22, 0x00	; 0
    38cc:	2a f0       	brmi	.+10     	; 0x38d8 <__floatsisf+0x6c>
    38ce:	9a 95       	dec	r25
    38d0:	66 0f       	add	r22, r22
    38d2:	77 1f       	adc	r23, r23
    38d4:	88 1f       	adc	r24, r24
    38d6:	da f7       	brpl	.-10     	; 0x38ce <__floatsisf+0x62>
    38d8:	88 0f       	add	r24, r24
    38da:	96 95       	lsr	r25
    38dc:	87 95       	ror	r24
    38de:	97 f9       	bld	r25, 7
    38e0:	08 95       	ret

000038e2 <__fp_cmp>:
    38e2:	99 0f       	add	r25, r25
    38e4:	00 08       	sbc	r0, r0
    38e6:	55 0f       	add	r21, r21
    38e8:	aa 0b       	sbc	r26, r26
    38ea:	e0 e8       	ldi	r30, 0x80	; 128
    38ec:	fe ef       	ldi	r31, 0xFE	; 254
    38ee:	16 16       	cp	r1, r22
    38f0:	17 06       	cpc	r1, r23
    38f2:	e8 07       	cpc	r30, r24
    38f4:	f9 07       	cpc	r31, r25
    38f6:	c0 f0       	brcs	.+48     	; 0x3928 <__fp_cmp+0x46>
    38f8:	12 16       	cp	r1, r18
    38fa:	13 06       	cpc	r1, r19
    38fc:	e4 07       	cpc	r30, r20
    38fe:	f5 07       	cpc	r31, r21
    3900:	98 f0       	brcs	.+38     	; 0x3928 <__fp_cmp+0x46>
    3902:	62 1b       	sub	r22, r18
    3904:	73 0b       	sbc	r23, r19
    3906:	84 0b       	sbc	r24, r20
    3908:	95 0b       	sbc	r25, r21
    390a:	39 f4       	brne	.+14     	; 0x391a <__fp_cmp+0x38>
    390c:	0a 26       	eor	r0, r26
    390e:	61 f0       	breq	.+24     	; 0x3928 <__fp_cmp+0x46>
    3910:	23 2b       	or	r18, r19
    3912:	24 2b       	or	r18, r20
    3914:	25 2b       	or	r18, r21
    3916:	21 f4       	brne	.+8      	; 0x3920 <__fp_cmp+0x3e>
    3918:	08 95       	ret
    391a:	0a 26       	eor	r0, r26
    391c:	09 f4       	brne	.+2      	; 0x3920 <__fp_cmp+0x3e>
    391e:	a1 40       	sbci	r26, 0x01	; 1
    3920:	a6 95       	lsr	r26
    3922:	8f ef       	ldi	r24, 0xFF	; 255
    3924:	81 1d       	adc	r24, r1
    3926:	81 1d       	adc	r24, r1
    3928:	08 95       	ret

0000392a <__fp_inf>:
    392a:	97 f9       	bld	r25, 7
    392c:	9f 67       	ori	r25, 0x7F	; 127
    392e:	80 e8       	ldi	r24, 0x80	; 128
    3930:	70 e0       	ldi	r23, 0x00	; 0
    3932:	60 e0       	ldi	r22, 0x00	; 0
    3934:	08 95       	ret

00003936 <__fp_nan>:
    3936:	9f ef       	ldi	r25, 0xFF	; 255
    3938:	80 ec       	ldi	r24, 0xC0	; 192
    393a:	08 95       	ret

0000393c <__fp_pscA>:
    393c:	00 24       	eor	r0, r0
    393e:	0a 94       	dec	r0
    3940:	16 16       	cp	r1, r22
    3942:	17 06       	cpc	r1, r23
    3944:	18 06       	cpc	r1, r24
    3946:	09 06       	cpc	r0, r25
    3948:	08 95       	ret

0000394a <__fp_pscB>:
    394a:	00 24       	eor	r0, r0
    394c:	0a 94       	dec	r0
    394e:	12 16       	cp	r1, r18
    3950:	13 06       	cpc	r1, r19
    3952:	14 06       	cpc	r1, r20
    3954:	05 06       	cpc	r0, r21
    3956:	08 95       	ret

00003958 <__fp_round>:
    3958:	09 2e       	mov	r0, r25
    395a:	03 94       	inc	r0
    395c:	00 0c       	add	r0, r0
    395e:	11 f4       	brne	.+4      	; 0x3964 <__fp_round+0xc>
    3960:	88 23       	and	r24, r24
    3962:	52 f0       	brmi	.+20     	; 0x3978 <__fp_round+0x20>
    3964:	bb 0f       	add	r27, r27
    3966:	40 f4       	brcc	.+16     	; 0x3978 <__fp_round+0x20>
    3968:	bf 2b       	or	r27, r31
    396a:	11 f4       	brne	.+4      	; 0x3970 <__fp_round+0x18>
    396c:	60 ff       	sbrs	r22, 0
    396e:	04 c0       	rjmp	.+8      	; 0x3978 <__fp_round+0x20>
    3970:	6f 5f       	subi	r22, 0xFF	; 255
    3972:	7f 4f       	sbci	r23, 0xFF	; 255
    3974:	8f 4f       	sbci	r24, 0xFF	; 255
    3976:	9f 4f       	sbci	r25, 0xFF	; 255
    3978:	08 95       	ret

0000397a <__fp_split3>:
    397a:	57 fd       	sbrc	r21, 7
    397c:	90 58       	subi	r25, 0x80	; 128
    397e:	44 0f       	add	r20, r20
    3980:	55 1f       	adc	r21, r21
    3982:	59 f0       	breq	.+22     	; 0x399a <__fp_splitA+0x10>
    3984:	5f 3f       	cpi	r21, 0xFF	; 255
    3986:	71 f0       	breq	.+28     	; 0x39a4 <__fp_splitA+0x1a>
    3988:	47 95       	ror	r20

0000398a <__fp_splitA>:
    398a:	88 0f       	add	r24, r24
    398c:	97 fb       	bst	r25, 7
    398e:	99 1f       	adc	r25, r25
    3990:	61 f0       	breq	.+24     	; 0x39aa <__fp_splitA+0x20>
    3992:	9f 3f       	cpi	r25, 0xFF	; 255
    3994:	79 f0       	breq	.+30     	; 0x39b4 <__fp_splitA+0x2a>
    3996:	87 95       	ror	r24
    3998:	08 95       	ret
    399a:	12 16       	cp	r1, r18
    399c:	13 06       	cpc	r1, r19
    399e:	14 06       	cpc	r1, r20
    39a0:	55 1f       	adc	r21, r21
    39a2:	f2 cf       	rjmp	.-28     	; 0x3988 <__fp_split3+0xe>
    39a4:	46 95       	lsr	r20
    39a6:	f1 df       	rcall	.-30     	; 0x398a <__fp_splitA>
    39a8:	08 c0       	rjmp	.+16     	; 0x39ba <__fp_splitA+0x30>
    39aa:	16 16       	cp	r1, r22
    39ac:	17 06       	cpc	r1, r23
    39ae:	18 06       	cpc	r1, r24
    39b0:	99 1f       	adc	r25, r25
    39b2:	f1 cf       	rjmp	.-30     	; 0x3996 <__fp_splitA+0xc>
    39b4:	86 95       	lsr	r24
    39b6:	71 05       	cpc	r23, r1
    39b8:	61 05       	cpc	r22, r1
    39ba:	08 94       	sec
    39bc:	08 95       	ret

000039be <__fp_zero>:
    39be:	e8 94       	clt

000039c0 <__fp_szero>:
    39c0:	bb 27       	eor	r27, r27
    39c2:	66 27       	eor	r22, r22
    39c4:	77 27       	eor	r23, r23
    39c6:	cb 01       	movw	r24, r22
    39c8:	97 f9       	bld	r25, 7
    39ca:	08 95       	ret

000039cc <__mulsf3>:
    39cc:	0e 94 f9 1c 	call	0x39f2	; 0x39f2 <__mulsf3x>
    39d0:	0c 94 ac 1c 	jmp	0x3958	; 0x3958 <__fp_round>
    39d4:	0e 94 9e 1c 	call	0x393c	; 0x393c <__fp_pscA>
    39d8:	38 f0       	brcs	.+14     	; 0x39e8 <__mulsf3+0x1c>
    39da:	0e 94 a5 1c 	call	0x394a	; 0x394a <__fp_pscB>
    39de:	20 f0       	brcs	.+8      	; 0x39e8 <__mulsf3+0x1c>
    39e0:	95 23       	and	r25, r21
    39e2:	11 f0       	breq	.+4      	; 0x39e8 <__mulsf3+0x1c>
    39e4:	0c 94 95 1c 	jmp	0x392a	; 0x392a <__fp_inf>
    39e8:	0c 94 9b 1c 	jmp	0x3936	; 0x3936 <__fp_nan>
    39ec:	11 24       	eor	r1, r1
    39ee:	0c 94 e0 1c 	jmp	0x39c0	; 0x39c0 <__fp_szero>

000039f2 <__mulsf3x>:
    39f2:	0e 94 bd 1c 	call	0x397a	; 0x397a <__fp_split3>
    39f6:	70 f3       	brcs	.-36     	; 0x39d4 <__mulsf3+0x8>

000039f8 <__mulsf3_pse>:
    39f8:	95 9f       	mul	r25, r21
    39fa:	c1 f3       	breq	.-16     	; 0x39ec <__mulsf3+0x20>
    39fc:	95 0f       	add	r25, r21
    39fe:	50 e0       	ldi	r21, 0x00	; 0
    3a00:	55 1f       	adc	r21, r21
    3a02:	62 9f       	mul	r22, r18
    3a04:	f0 01       	movw	r30, r0
    3a06:	72 9f       	mul	r23, r18
    3a08:	bb 27       	eor	r27, r27
    3a0a:	f0 0d       	add	r31, r0
    3a0c:	b1 1d       	adc	r27, r1
    3a0e:	63 9f       	mul	r22, r19
    3a10:	aa 27       	eor	r26, r26
    3a12:	f0 0d       	add	r31, r0
    3a14:	b1 1d       	adc	r27, r1
    3a16:	aa 1f       	adc	r26, r26
    3a18:	64 9f       	mul	r22, r20
    3a1a:	66 27       	eor	r22, r22
    3a1c:	b0 0d       	add	r27, r0
    3a1e:	a1 1d       	adc	r26, r1
    3a20:	66 1f       	adc	r22, r22
    3a22:	82 9f       	mul	r24, r18
    3a24:	22 27       	eor	r18, r18
    3a26:	b0 0d       	add	r27, r0
    3a28:	a1 1d       	adc	r26, r1
    3a2a:	62 1f       	adc	r22, r18
    3a2c:	73 9f       	mul	r23, r19
    3a2e:	b0 0d       	add	r27, r0
    3a30:	a1 1d       	adc	r26, r1
    3a32:	62 1f       	adc	r22, r18
    3a34:	83 9f       	mul	r24, r19
    3a36:	a0 0d       	add	r26, r0
    3a38:	61 1d       	adc	r22, r1
    3a3a:	22 1f       	adc	r18, r18
    3a3c:	74 9f       	mul	r23, r20
    3a3e:	33 27       	eor	r19, r19
    3a40:	a0 0d       	add	r26, r0
    3a42:	61 1d       	adc	r22, r1
    3a44:	23 1f       	adc	r18, r19
    3a46:	84 9f       	mul	r24, r20
    3a48:	60 0d       	add	r22, r0
    3a4a:	21 1d       	adc	r18, r1
    3a4c:	82 2f       	mov	r24, r18
    3a4e:	76 2f       	mov	r23, r22
    3a50:	6a 2f       	mov	r22, r26
    3a52:	11 24       	eor	r1, r1
    3a54:	9f 57       	subi	r25, 0x7F	; 127
    3a56:	50 40       	sbci	r21, 0x00	; 0
    3a58:	9a f0       	brmi	.+38     	; 0x3a80 <__mulsf3_pse+0x88>
    3a5a:	f1 f0       	breq	.+60     	; 0x3a98 <__mulsf3_pse+0xa0>
    3a5c:	88 23       	and	r24, r24
    3a5e:	4a f0       	brmi	.+18     	; 0x3a72 <__mulsf3_pse+0x7a>
    3a60:	ee 0f       	add	r30, r30
    3a62:	ff 1f       	adc	r31, r31
    3a64:	bb 1f       	adc	r27, r27
    3a66:	66 1f       	adc	r22, r22
    3a68:	77 1f       	adc	r23, r23
    3a6a:	88 1f       	adc	r24, r24
    3a6c:	91 50       	subi	r25, 0x01	; 1
    3a6e:	50 40       	sbci	r21, 0x00	; 0
    3a70:	a9 f7       	brne	.-22     	; 0x3a5c <__mulsf3_pse+0x64>
    3a72:	9e 3f       	cpi	r25, 0xFE	; 254
    3a74:	51 05       	cpc	r21, r1
    3a76:	80 f0       	brcs	.+32     	; 0x3a98 <__mulsf3_pse+0xa0>
    3a78:	0c 94 95 1c 	jmp	0x392a	; 0x392a <__fp_inf>
    3a7c:	0c 94 e0 1c 	jmp	0x39c0	; 0x39c0 <__fp_szero>
    3a80:	5f 3f       	cpi	r21, 0xFF	; 255
    3a82:	e4 f3       	brlt	.-8      	; 0x3a7c <__mulsf3_pse+0x84>
    3a84:	98 3e       	cpi	r25, 0xE8	; 232
    3a86:	d4 f3       	brlt	.-12     	; 0x3a7c <__mulsf3_pse+0x84>
    3a88:	86 95       	lsr	r24
    3a8a:	77 95       	ror	r23
    3a8c:	67 95       	ror	r22
    3a8e:	b7 95       	ror	r27
    3a90:	f7 95       	ror	r31
    3a92:	e7 95       	ror	r30
    3a94:	9f 5f       	subi	r25, 0xFF	; 255
    3a96:	c1 f7       	brne	.-16     	; 0x3a88 <__mulsf3_pse+0x90>
    3a98:	fe 2b       	or	r31, r30
    3a9a:	88 0f       	add	r24, r24
    3a9c:	91 1d       	adc	r25, r1
    3a9e:	96 95       	lsr	r25
    3aa0:	87 95       	ror	r24
    3aa2:	97 f9       	bld	r25, 7
    3aa4:	08 95       	ret

00003aa6 <_ZN14HardwareSerial9availableEv>:
  // clear any received data
  _rx_buffer_head = _rx_buffer_tail;
}

int HardwareSerial::available(void)
{
    3aa6:	fc 01       	movw	r30, r24
  return ((unsigned int)(SERIAL_RX_BUFFER_SIZE + _rx_buffer_head - _rx_buffer_tail)) % SERIAL_RX_BUFFER_SIZE;
    3aa8:	91 8d       	ldd	r25, Z+25	; 0x19
    3aaa:	22 8d       	ldd	r18, Z+26	; 0x1a
    3aac:	89 2f       	mov	r24, r25
    3aae:	90 e0       	ldi	r25, 0x00	; 0
    3ab0:	80 5c       	subi	r24, 0xC0	; 192
    3ab2:	9f 4f       	sbci	r25, 0xFF	; 255
    3ab4:	82 1b       	sub	r24, r18
    3ab6:	91 09       	sbc	r25, r1
}
    3ab8:	8f 73       	andi	r24, 0x3F	; 63
    3aba:	99 27       	eor	r25, r25
    3abc:	08 95       	ret

00003abe <_ZN14HardwareSerial4peekEv>:

int HardwareSerial::peek(void)
{
    3abe:	fc 01       	movw	r30, r24
  if (_rx_buffer_head == _rx_buffer_tail) {
    3ac0:	91 8d       	ldd	r25, Z+25	; 0x19
    3ac2:	82 8d       	ldd	r24, Z+26	; 0x1a
    3ac4:	98 17       	cp	r25, r24
    3ac6:	31 f0       	breq	.+12     	; 0x3ad4 <_ZN14HardwareSerial4peekEv+0x16>
    return -1;
  } else {
    return _rx_buffer[_rx_buffer_tail];
    3ac8:	82 8d       	ldd	r24, Z+26	; 0x1a
    3aca:	e8 0f       	add	r30, r24
    3acc:	f1 1d       	adc	r31, r1
    3ace:	85 8d       	ldd	r24, Z+29	; 0x1d
    3ad0:	90 e0       	ldi	r25, 0x00	; 0
    3ad2:	08 95       	ret
}

int HardwareSerial::peek(void)
{
  if (_rx_buffer_head == _rx_buffer_tail) {
    return -1;
    3ad4:	8f ef       	ldi	r24, 0xFF	; 255
    3ad6:	9f ef       	ldi	r25, 0xFF	; 255
  } else {
    return _rx_buffer[_rx_buffer_tail];
  }
}
    3ad8:	08 95       	ret

00003ada <_ZN14HardwareSerial4readEv>:

int HardwareSerial::read(void)
{
    3ada:	fc 01       	movw	r30, r24
  // if the head isn't ahead of the tail, we don't have any characters
  if (_rx_buffer_head == _rx_buffer_tail) {
    3adc:	91 8d       	ldd	r25, Z+25	; 0x19
    3ade:	82 8d       	ldd	r24, Z+26	; 0x1a
    3ae0:	98 17       	cp	r25, r24
    3ae2:	61 f0       	breq	.+24     	; 0x3afc <_ZN14HardwareSerial4readEv+0x22>
    return -1;
  } else {
    unsigned char c = _rx_buffer[_rx_buffer_tail];
    3ae4:	82 8d       	ldd	r24, Z+26	; 0x1a
    3ae6:	df 01       	movw	r26, r30
    3ae8:	a8 0f       	add	r26, r24
    3aea:	b1 1d       	adc	r27, r1
    3aec:	5d 96       	adiw	r26, 0x1d	; 29
    3aee:	8c 91       	ld	r24, X
    _rx_buffer_tail = (rx_buffer_index_t)(_rx_buffer_tail + 1) % SERIAL_RX_BUFFER_SIZE;
    3af0:	92 8d       	ldd	r25, Z+26	; 0x1a
    3af2:	9f 5f       	subi	r25, 0xFF	; 255
    3af4:	9f 73       	andi	r25, 0x3F	; 63
    3af6:	92 8f       	std	Z+26, r25	; 0x1a
    return c;
    3af8:	90 e0       	ldi	r25, 0x00	; 0
    3afa:	08 95       	ret

int HardwareSerial::read(void)
{
  // if the head isn't ahead of the tail, we don't have any characters
  if (_rx_buffer_head == _rx_buffer_tail) {
    return -1;
    3afc:	8f ef       	ldi	r24, 0xFF	; 255
    3afe:	9f ef       	ldi	r25, 0xFF	; 255
  } else {
    unsigned char c = _rx_buffer[_rx_buffer_tail];
    _rx_buffer_tail = (rx_buffer_index_t)(_rx_buffer_tail + 1) % SERIAL_RX_BUFFER_SIZE;
    return c;
  }
}
    3b00:	08 95       	ret

00003b02 <_ZN14HardwareSerial17availableForWriteEv>:
{
  tx_buffer_index_t head;
  tx_buffer_index_t tail;

  TX_BUFFER_ATOMIC {
    head = _tx_buffer_head;
    3b02:	fc 01       	movw	r30, r24
    3b04:	53 8d       	ldd	r21, Z+27	; 0x1b
    tail = _tx_buffer_tail;
    3b06:	44 8d       	ldd	r20, Z+28	; 0x1c
    3b08:	25 2f       	mov	r18, r21
    3b0a:	30 e0       	ldi	r19, 0x00	; 0
    3b0c:	84 2f       	mov	r24, r20
    3b0e:	90 e0       	ldi	r25, 0x00	; 0
  }
  if (head >= tail) return SERIAL_TX_BUFFER_SIZE - 1 - head + tail;
    3b10:	82 1b       	sub	r24, r18
    3b12:	93 0b       	sbc	r25, r19
    3b14:	54 17       	cp	r21, r20
    3b16:	10 f0       	brcs	.+4      	; 0x3b1c <_ZN14HardwareSerial17availableForWriteEv+0x1a>
    3b18:	cf 96       	adiw	r24, 0x3f	; 63
    3b1a:	08 95       	ret
  return tail - head - 1;
    3b1c:	01 97       	sbiw	r24, 0x01	; 1
}
    3b1e:	08 95       	ret

00003b20 <_Z14serialEventRunv>:
#endif

void serialEventRun(void)
{
#if defined(HAVE_HWSERIAL0)
  if (Serial0_available && serialEvent && Serial0_available()) serialEvent();
    3b20:	8c ee       	ldi	r24, 0xEC	; 236
    3b22:	9e e1       	ldi	r25, 0x1E	; 30
    3b24:	89 2b       	or	r24, r25
    3b26:	49 f0       	breq	.+18     	; 0x3b3a <_Z14serialEventRunv+0x1a>
    3b28:	80 e0       	ldi	r24, 0x00	; 0
    3b2a:	90 e0       	ldi	r25, 0x00	; 0
    3b2c:	89 2b       	or	r24, r25
    3b2e:	29 f0       	breq	.+10     	; 0x3b3a <_Z14serialEventRunv+0x1a>
    3b30:	0e 94 ec 1e 	call	0x3dd8	; 0x3dd8 <_Z17Serial0_availablev>
    3b34:	81 11       	cpse	r24, r1
    3b36:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>
    3b3a:	08 95       	ret

00003b3c <_ZN14HardwareSerial17_tx_udr_empty_irqEv>:
#endif

// Actual interrupt handlers //////////////////////////////////////////////////////////////

void HardwareSerial::_tx_udr_empty_irq(void)
{
    3b3c:	fc 01       	movw	r30, r24
  // If interrupts are enabled, there must be more data in the output
  // buffer. Send the next byte
  unsigned char c = _tx_buffer[_tx_buffer_tail];
    3b3e:	84 8d       	ldd	r24, Z+28	; 0x1c
    3b40:	df 01       	movw	r26, r30
    3b42:	a8 0f       	add	r26, r24
    3b44:	b1 1d       	adc	r27, r1
    3b46:	a3 5a       	subi	r26, 0xA3	; 163
    3b48:	bf 4f       	sbci	r27, 0xFF	; 255
    3b4a:	2c 91       	ld	r18, X
  _tx_buffer_tail = (_tx_buffer_tail + 1) % SERIAL_TX_BUFFER_SIZE;
    3b4c:	84 8d       	ldd	r24, Z+28	; 0x1c
    3b4e:	90 e0       	ldi	r25, 0x00	; 0
    3b50:	01 96       	adiw	r24, 0x01	; 1
    3b52:	8f 73       	andi	r24, 0x3F	; 63
    3b54:	99 27       	eor	r25, r25
    3b56:	84 8f       	std	Z+28, r24	; 0x1c

  *_udr = c;
    3b58:	a6 89       	ldd	r26, Z+22	; 0x16
    3b5a:	b7 89       	ldd	r27, Z+23	; 0x17
    3b5c:	2c 93       	st	X, r18
  // location". This makes sure flush() won't return until the bytes
  // actually got written. Other r/w bits are preserved, and zeroes
  // written to the rest.

#ifdef MPCM0
  *_ucsra = ((*_ucsra) & ((1 << U2X0) | (1 << MPCM0))) | (1 << TXC0);
    3b5e:	a0 89       	ldd	r26, Z+16	; 0x10
    3b60:	b1 89       	ldd	r27, Z+17	; 0x11
    3b62:	8c 91       	ld	r24, X
    3b64:	83 70       	andi	r24, 0x03	; 3
    3b66:	80 64       	ori	r24, 0x40	; 64
    3b68:	8c 93       	st	X, r24
#else
  *_ucsra = ((*_ucsra) & ((1 << U2X0) | (1 << TXC0)));
#endif

  if (_tx_buffer_head == _tx_buffer_tail) {
    3b6a:	93 8d       	ldd	r25, Z+27	; 0x1b
    3b6c:	84 8d       	ldd	r24, Z+28	; 0x1c
    3b6e:	98 13       	cpse	r25, r24
    3b70:	06 c0       	rjmp	.+12     	; 0x3b7e <_ZN14HardwareSerial17_tx_udr_empty_irqEv+0x42>
    // Buffer empty, so disable interrupts
    cbi(*_ucsrb, UDRIE0);
    3b72:	02 88       	ldd	r0, Z+18	; 0x12
    3b74:	f3 89       	ldd	r31, Z+19	; 0x13
    3b76:	e0 2d       	mov	r30, r0
    3b78:	80 81       	ld	r24, Z
    3b7a:	8f 7d       	andi	r24, 0xDF	; 223
    3b7c:	80 83       	st	Z, r24
    3b7e:	08 95       	ret

00003b80 <_ZN14HardwareSerial5writeEh>:
  // If we get here, nothing is queued anymore (DRIE is disabled) and
  // the hardware finished tranmission (TXC is set).
}

size_t HardwareSerial::write(uint8_t c)
{
    3b80:	ef 92       	push	r14
    3b82:	ff 92       	push	r15
    3b84:	0f 93       	push	r16
    3b86:	1f 93       	push	r17
    3b88:	cf 93       	push	r28
    3b8a:	df 93       	push	r29
    3b8c:	ec 01       	movw	r28, r24
  _written = true;
    3b8e:	81 e0       	ldi	r24, 0x01	; 1
    3b90:	88 8f       	std	Y+24, r24	; 0x18
  // If the buffer and the data register is empty, just write the byte
  // to the data register and be done. This shortcut helps
  // significantly improve the effective datarate at high (>
  // 500kbit/s) bitrates, where interrupt overhead becomes a slowdown.
  if (_tx_buffer_head == _tx_buffer_tail && bit_is_set(*_ucsra, UDRE0)) {
    3b92:	9b 8d       	ldd	r25, Y+27	; 0x1b
    3b94:	8c 8d       	ldd	r24, Y+28	; 0x1c
    3b96:	98 13       	cpse	r25, r24
    3b98:	05 c0       	rjmp	.+10     	; 0x3ba4 <_ZN14HardwareSerial5writeEh+0x24>
    3b9a:	e8 89       	ldd	r30, Y+16	; 0x10
    3b9c:	f9 89       	ldd	r31, Y+17	; 0x11
    3b9e:	80 81       	ld	r24, Z
    3ba0:	85 fd       	sbrc	r24, 5
    3ba2:	26 c0       	rjmp	.+76     	; 0x3bf0 <_ZN14HardwareSerial5writeEh+0x70>
    3ba4:	f6 2e       	mov	r15, r22
      *_ucsra = ((*_ucsra) & ((1 << U2X0) | (1 << TXC0)));
#endif
    }
    return 1;
  }
  tx_buffer_index_t i = (_tx_buffer_head + 1) % SERIAL_TX_BUFFER_SIZE;
    3ba6:	0b 8d       	ldd	r16, Y+27	; 0x1b
    3ba8:	10 e0       	ldi	r17, 0x00	; 0
    3baa:	0f 5f       	subi	r16, 0xFF	; 255
    3bac:	1f 4f       	sbci	r17, 0xFF	; 255
    3bae:	0f 73       	andi	r16, 0x3F	; 63
    3bb0:	11 27       	eor	r17, r17
    3bb2:	e0 2e       	mov	r14, r16
	
  // If the output buffer is full, there's nothing for it other than to 
  // wait for the interrupt handler to empty it a bit
  while (i == _tx_buffer_tail) {
    3bb4:	8c 8d       	ldd	r24, Y+28	; 0x1c
    3bb6:	e8 12       	cpse	r14, r24
    3bb8:	0c c0       	rjmp	.+24     	; 0x3bd2 <_ZN14HardwareSerial5writeEh+0x52>
    if (bit_is_clear(SREG, SREG_I)) {
    3bba:	0f b6       	in	r0, 0x3f	; 63
    3bbc:	07 fc       	sbrc	r0, 7
    3bbe:	fa cf       	rjmp	.-12     	; 0x3bb4 <_ZN14HardwareSerial5writeEh+0x34>
      // Interrupts are disabled, so we'll have to poll the data
      // register empty flag ourselves. If it is set, pretend an
      // interrupt has happened and call the handler to free up
      // space for us.
      if(bit_is_set(*_ucsra, UDRE0))
    3bc0:	e8 89       	ldd	r30, Y+16	; 0x10
    3bc2:	f9 89       	ldd	r31, Y+17	; 0x11
    3bc4:	80 81       	ld	r24, Z
    3bc6:	85 ff       	sbrs	r24, 5
    3bc8:	f5 cf       	rjmp	.-22     	; 0x3bb4 <_ZN14HardwareSerial5writeEh+0x34>
	_tx_udr_empty_irq();
    3bca:	ce 01       	movw	r24, r28
    3bcc:	0e 94 9e 1d 	call	0x3b3c	; 0x3b3c <_ZN14HardwareSerial17_tx_udr_empty_irqEv>
    3bd0:	f1 cf       	rjmp	.-30     	; 0x3bb4 <_ZN14HardwareSerial5writeEh+0x34>
    } else {
      // nop, the interrupt handler will free up space for us
    }
  }

  _tx_buffer[_tx_buffer_head] = c;
    3bd2:	8b 8d       	ldd	r24, Y+27	; 0x1b
    3bd4:	fe 01       	movw	r30, r28
    3bd6:	e8 0f       	add	r30, r24
    3bd8:	f1 1d       	adc	r31, r1
    3bda:	e3 5a       	subi	r30, 0xA3	; 163
    3bdc:	ff 4f       	sbci	r31, 0xFF	; 255
    3bde:	f0 82       	st	Z, r15

  // make atomic to prevent execution of ISR between setting the
  // head pointer and setting the interrupt flag resulting in buffer
  // retransmission
  ATOMIC_BLOCK(ATOMIC_RESTORESTATE) {
    3be0:	9f b7       	in	r25, 0x3f	; 63
    return 1;
}

static __inline__ uint8_t __iCliRetVal(void)
{
    cli();
    3be2:	f8 94       	cli
    _tx_buffer_head = i;
    3be4:	0b 8f       	std	Y+27, r16	; 0x1b
    sbi(*_ucsrb, UDRIE0);
    3be6:	ea 89       	ldd	r30, Y+18	; 0x12
    3be8:	fb 89       	ldd	r31, Y+19	; 0x13
    3bea:	80 81       	ld	r24, Z
    3bec:	80 62       	ori	r24, 0x20	; 32
    3bee:	0a c0       	rjmp	.+20     	; 0x3c04 <_ZN14HardwareSerial5writeEh+0x84>
    // So writing UDR must happen first.
    // Writing UDR and clearing TC must be done atomically, otherwise
    // interrupts might delay the TXC clear so the byte written to UDR
    // is transmitted (setting TXC) before clearing TXC. Then TXC will
    // be cleared when no bytes are left, causing flush() to hang
    ATOMIC_BLOCK(ATOMIC_RESTORESTATE) {
    3bf0:	9f b7       	in	r25, 0x3f	; 63
    3bf2:	f8 94       	cli
      *_udr = c;
    3bf4:	ee 89       	ldd	r30, Y+22	; 0x16
    3bf6:	ff 89       	ldd	r31, Y+23	; 0x17
    3bf8:	60 83       	st	Z, r22
#ifdef MPCM0
      *_ucsra = ((*_ucsra) & ((1 << U2X0) | (1 << MPCM0))) | (1 << TXC0);
    3bfa:	e8 89       	ldd	r30, Y+16	; 0x10
    3bfc:	f9 89       	ldd	r31, Y+17	; 0x11
    3bfe:	80 81       	ld	r24, Z
    3c00:	83 70       	andi	r24, 0x03	; 3
    3c02:	80 64       	ori	r24, 0x40	; 64
    3c04:	80 83       	st	Z, r24
    (void)__s;
}

static __inline__ void __iRestore(const  uint8_t *__s)
{
    SREG = *__s;
    3c06:	9f bf       	out	0x3f, r25	; 63
    _tx_buffer_head = i;
    sbi(*_ucsrb, UDRIE0);
  }
  
  return 1;
}
    3c08:	81 e0       	ldi	r24, 0x01	; 1
    3c0a:	90 e0       	ldi	r25, 0x00	; 0
    3c0c:	df 91       	pop	r29
    3c0e:	cf 91       	pop	r28
    3c10:	1f 91       	pop	r17
    3c12:	0f 91       	pop	r16
    3c14:	ff 90       	pop	r15
    3c16:	ef 90       	pop	r14
    3c18:	08 95       	ret

00003c1a <_ZN14HardwareSerial5flushEv>:
  if (head >= tail) return SERIAL_TX_BUFFER_SIZE - 1 - head + tail;
  return tail - head - 1;
}

void HardwareSerial::flush()
{
    3c1a:	cf 93       	push	r28
    3c1c:	df 93       	push	r29
    3c1e:	ec 01       	movw	r28, r24
  // If we have never written a byte, no need to flush. This special
  // case is needed since there is no way to force the TXC (transmit
  // complete) bit to 1 during initialization
  if (!_written)
    3c20:	88 8d       	ldd	r24, Y+24	; 0x18
    3c22:	88 23       	and	r24, r24
    3c24:	c9 f0       	breq	.+50     	; 0x3c58 <_ZN14HardwareSerial5flushEv+0x3e>
    return;

  while (bit_is_set(*_ucsrb, UDRIE0) || bit_is_clear(*_ucsra, TXC0)) {
    3c26:	ea 89       	ldd	r30, Y+18	; 0x12
    3c28:	fb 89       	ldd	r31, Y+19	; 0x13
    3c2a:	80 81       	ld	r24, Z
    3c2c:	85 fd       	sbrc	r24, 5
    3c2e:	05 c0       	rjmp	.+10     	; 0x3c3a <_ZN14HardwareSerial5flushEv+0x20>
    3c30:	a8 89       	ldd	r26, Y+16	; 0x10
    3c32:	b9 89       	ldd	r27, Y+17	; 0x11
    3c34:	8c 91       	ld	r24, X
    3c36:	86 fd       	sbrc	r24, 6
    3c38:	0f c0       	rjmp	.+30     	; 0x3c58 <_ZN14HardwareSerial5flushEv+0x3e>
    if (bit_is_clear(SREG, SREG_I) && bit_is_set(*_ucsrb, UDRIE0))
    3c3a:	0f b6       	in	r0, 0x3f	; 63
    3c3c:	07 fc       	sbrc	r0, 7
    3c3e:	f5 cf       	rjmp	.-22     	; 0x3c2a <_ZN14HardwareSerial5flushEv+0x10>
    3c40:	80 81       	ld	r24, Z
    3c42:	85 ff       	sbrs	r24, 5
    3c44:	f2 cf       	rjmp	.-28     	; 0x3c2a <_ZN14HardwareSerial5flushEv+0x10>
	// Interrupts are globally disabled, but the DR empty
	// interrupt should be enabled, so poll the DR empty flag to
	// prevent deadlock
	if (bit_is_set(*_ucsra, UDRE0))
    3c46:	a8 89       	ldd	r26, Y+16	; 0x10
    3c48:	b9 89       	ldd	r27, Y+17	; 0x11
    3c4a:	8c 91       	ld	r24, X
    3c4c:	85 ff       	sbrs	r24, 5
    3c4e:	ed cf       	rjmp	.-38     	; 0x3c2a <_ZN14HardwareSerial5flushEv+0x10>
	  _tx_udr_empty_irq();
    3c50:	ce 01       	movw	r24, r28
    3c52:	0e 94 9e 1d 	call	0x3b3c	; 0x3b3c <_ZN14HardwareSerial17_tx_udr_empty_irqEv>
    3c56:	e7 cf       	rjmp	.-50     	; 0x3c26 <_ZN14HardwareSerial5flushEv+0xc>
  }
  // If we get here, nothing is queued anymore (DRIE is disabled) and
  // the hardware finished tranmission (TXC is set).
}
    3c58:	df 91       	pop	r29
    3c5a:	cf 91       	pop	r28
    3c5c:	08 95       	ret

00003c5e <_ZN14HardwareSerial5beginEmh>:
}

// Public Methods //////////////////////////////////////////////////////////////

void HardwareSerial::begin(unsigned long baud, byte config)
{
    3c5e:	cf 92       	push	r12
    3c60:	df 92       	push	r13
    3c62:	ef 92       	push	r14
    3c64:	ff 92       	push	r15
    3c66:	1f 93       	push	r17
    3c68:	cf 93       	push	r28
    3c6a:	df 93       	push	r29
    3c6c:	ec 01       	movw	r28, r24
    3c6e:	6a 01       	movw	r12, r20
    3c70:	7b 01       	movw	r14, r22
    3c72:	12 2f       	mov	r17, r18
  // Try u2x mode first
  uint16_t baud_setting = (F_CPU / 4 / baud - 1) / 2;
  *_ucsra = 1 << U2X0;
    3c74:	e8 89       	ldd	r30, Y+16	; 0x10
    3c76:	f9 89       	ldd	r31, Y+17	; 0x11
    3c78:	82 e0       	ldi	r24, 0x02	; 2
    3c7a:	80 83       	st	Z, r24
  // hardcoded exception for 57600 for compatibility with the bootloader
  // shipped with the Duemilanove and previous boards and the firmware
  // on the 8U2 on the Uno and Mega 2560. Also, The baud_setting cannot
  // be > 4095, so switch back to non-u2x mode if the baud rate is too
  // low.
  if (((F_CPU == 16000000UL) && (baud == 57600)) || (baud_setting >4095))
    3c7c:	41 15       	cp	r20, r1
    3c7e:	51 4e       	sbci	r21, 0xE1	; 225
    3c80:	61 05       	cpc	r22, r1
    3c82:	71 05       	cpc	r23, r1
    3c84:	b1 f0       	breq	.+44     	; 0x3cb2 <_ZN14HardwareSerial5beginEmh+0x54>
// Public Methods //////////////////////////////////////////////////////////////

void HardwareSerial::begin(unsigned long baud, byte config)
{
  // Try u2x mode first
  uint16_t baud_setting = (F_CPU / 4 / baud - 1) / 2;
    3c86:	60 e0       	ldi	r22, 0x00	; 0
    3c88:	79 e0       	ldi	r23, 0x09	; 9
    3c8a:	8d e3       	ldi	r24, 0x3D	; 61
    3c8c:	90 e0       	ldi	r25, 0x00	; 0
    3c8e:	a7 01       	movw	r20, r14
    3c90:	96 01       	movw	r18, r12
    3c92:	0e 94 0a 24 	call	0x4814	; 0x4814 <__udivmodsi4>
    3c96:	da 01       	movw	r26, r20
    3c98:	c9 01       	movw	r24, r18
    3c9a:	01 97       	sbiw	r24, 0x01	; 1
    3c9c:	a1 09       	sbc	r26, r1
    3c9e:	b1 09       	sbc	r27, r1
    3ca0:	b6 95       	lsr	r27
    3ca2:	a7 95       	ror	r26
    3ca4:	97 95       	ror	r25
    3ca6:	87 95       	ror	r24
    3ca8:	9c 01       	movw	r18, r24
  // hardcoded exception for 57600 for compatibility with the bootloader
  // shipped with the Duemilanove and previous boards and the firmware
  // on the 8U2 on the Uno and Mega 2560. Also, The baud_setting cannot
  // be > 4095, so switch back to non-u2x mode if the baud rate is too
  // low.
  if (((F_CPU == 16000000UL) && (baud == 57600)) || (baud_setting >4095))
    3caa:	21 15       	cp	r18, r1
    3cac:	80 e1       	ldi	r24, 0x10	; 16
    3cae:	38 07       	cpc	r19, r24
    3cb0:	a8 f0       	brcs	.+42     	; 0x3cdc <_ZN14HardwareSerial5beginEmh+0x7e>
  {
    *_ucsra = 0;
    3cb2:	e8 89       	ldd	r30, Y+16	; 0x10
    3cb4:	f9 89       	ldd	r31, Y+17	; 0x11
    3cb6:	10 82       	st	Z, r1
    baud_setting = (F_CPU / 8 / baud - 1) / 2;
    3cb8:	60 e8       	ldi	r22, 0x80	; 128
    3cba:	74 e8       	ldi	r23, 0x84	; 132
    3cbc:	8e e1       	ldi	r24, 0x1E	; 30
    3cbe:	90 e0       	ldi	r25, 0x00	; 0
    3cc0:	a7 01       	movw	r20, r14
    3cc2:	96 01       	movw	r18, r12
    3cc4:	0e 94 0a 24 	call	0x4814	; 0x4814 <__udivmodsi4>
    3cc8:	da 01       	movw	r26, r20
    3cca:	c9 01       	movw	r24, r18
    3ccc:	01 97       	sbiw	r24, 0x01	; 1
    3cce:	a1 09       	sbc	r26, r1
    3cd0:	b1 09       	sbc	r27, r1
    3cd2:	b6 95       	lsr	r27
    3cd4:	a7 95       	ror	r26
    3cd6:	97 95       	ror	r25
    3cd8:	87 95       	ror	r24
    3cda:	9c 01       	movw	r18, r24
  }

  // assign the baud_setting, a.k.a. ubrr (USART Baud Rate Register)
  *_ubrrh = baud_setting >> 8;
    3cdc:	ec 85       	ldd	r30, Y+12	; 0x0c
    3cde:	fd 85       	ldd	r31, Y+13	; 0x0d
    3ce0:	30 83       	st	Z, r19
  *_ubrrl = baud_setting;
    3ce2:	ee 85       	ldd	r30, Y+14	; 0x0e
    3ce4:	ff 85       	ldd	r31, Y+15	; 0x0f
    3ce6:	20 83       	st	Z, r18

  _written = false;
    3ce8:	18 8e       	std	Y+24, r1	; 0x18

  //set the data bits, parity, and stop bits
#if defined(__AVR_ATmega8__)
  config |= 0x80; // select UCSRC register (shared with UBRRH)
#endif
  *_ucsrc = config;
    3cea:	ec 89       	ldd	r30, Y+20	; 0x14
    3cec:	fd 89       	ldd	r31, Y+21	; 0x15
    3cee:	10 83       	st	Z, r17
  
  sbi(*_ucsrb, RXEN0);
    3cf0:	ea 89       	ldd	r30, Y+18	; 0x12
    3cf2:	fb 89       	ldd	r31, Y+19	; 0x13
    3cf4:	80 81       	ld	r24, Z
    3cf6:	80 61       	ori	r24, 0x10	; 16
    3cf8:	80 83       	st	Z, r24
  sbi(*_ucsrb, TXEN0);
    3cfa:	ea 89       	ldd	r30, Y+18	; 0x12
    3cfc:	fb 89       	ldd	r31, Y+19	; 0x13
    3cfe:	80 81       	ld	r24, Z
    3d00:	88 60       	ori	r24, 0x08	; 8
    3d02:	80 83       	st	Z, r24
  sbi(*_ucsrb, RXCIE0);
    3d04:	ea 89       	ldd	r30, Y+18	; 0x12
    3d06:	fb 89       	ldd	r31, Y+19	; 0x13
    3d08:	80 81       	ld	r24, Z
    3d0a:	80 68       	ori	r24, 0x80	; 128
    3d0c:	80 83       	st	Z, r24
  cbi(*_ucsrb, UDRIE0);
    3d0e:	ea 89       	ldd	r30, Y+18	; 0x12
    3d10:	fb 89       	ldd	r31, Y+19	; 0x13
    3d12:	80 81       	ld	r24, Z
    3d14:	8f 7d       	andi	r24, 0xDF	; 223
    3d16:	80 83       	st	Z, r24
}
    3d18:	df 91       	pop	r29
    3d1a:	cf 91       	pop	r28
    3d1c:	1f 91       	pop	r17
    3d1e:	ff 90       	pop	r15
    3d20:	ef 90       	pop	r14
    3d22:	df 90       	pop	r13
    3d24:	cf 90       	pop	r12
    3d26:	08 95       	ret

00003d28 <__vector_18>:
#elif defined(USART_RXC_vect)
  ISR(USART_RXC_vect) // ATmega8
#else
  #error "Don't know what the Data Received vector is called for Serial"
#endif
  {
    3d28:	1f 92       	push	r1
    3d2a:	0f 92       	push	r0
    3d2c:	0f b6       	in	r0, 0x3f	; 63
    3d2e:	0f 92       	push	r0
    3d30:	11 24       	eor	r1, r1
    3d32:	2f 93       	push	r18
    3d34:	8f 93       	push	r24
    3d36:	9f 93       	push	r25
    3d38:	ef 93       	push	r30
    3d3a:	ff 93       	push	r31

// Actual interrupt handlers //////////////////////////////////////////////////////////////

void HardwareSerial::_rx_complete_irq(void)
{
  if (bit_is_clear(*_ucsra, UPE0)) {
    3d3c:	e0 91 64 04 	lds	r30, 0x0464	; 0x800464 <Serial+0x10>
    3d40:	f0 91 65 04 	lds	r31, 0x0465	; 0x800465 <Serial+0x11>
    3d44:	80 81       	ld	r24, Z
    3d46:	e0 91 6a 04 	lds	r30, 0x046A	; 0x80046a <Serial+0x16>
    3d4a:	f0 91 6b 04 	lds	r31, 0x046B	; 0x80046b <Serial+0x17>
    3d4e:	82 fd       	sbrc	r24, 2
    3d50:	12 c0       	rjmp	.+36     	; 0x3d76 <__vector_18+0x4e>
    // No Parity error, read byte and store it in the buffer if there is
    // room
    unsigned char c = *_udr;
    3d52:	90 81       	ld	r25, Z
    rx_buffer_index_t i = (unsigned int)(_rx_buffer_head + 1) % SERIAL_RX_BUFFER_SIZE;
    3d54:	80 91 6d 04 	lds	r24, 0x046D	; 0x80046d <Serial+0x19>
    3d58:	8f 5f       	subi	r24, 0xFF	; 255
    3d5a:	8f 73       	andi	r24, 0x3F	; 63

    // if we should be storing the received character into the location
    // just before the tail (meaning that the head would advance to the
    // current location of the tail), we're about to overflow the buffer
    // and so we don't write the character or advance the head.
    if (i != _rx_buffer_tail) {
    3d5c:	20 91 6e 04 	lds	r18, 0x046E	; 0x80046e <Serial+0x1a>
    3d60:	82 17       	cp	r24, r18
    3d62:	51 f0       	breq	.+20     	; 0x3d78 <__vector_18+0x50>
      _rx_buffer[_rx_buffer_head] = c;
    3d64:	e0 91 6d 04 	lds	r30, 0x046D	; 0x80046d <Serial+0x19>
    3d68:	f0 e0       	ldi	r31, 0x00	; 0
    3d6a:	ec 5a       	subi	r30, 0xAC	; 172
    3d6c:	fb 4f       	sbci	r31, 0xFB	; 251
    3d6e:	95 8f       	std	Z+29, r25	; 0x1d
      _rx_buffer_head = i;
    3d70:	80 93 6d 04 	sts	0x046D, r24	; 0x80046d <Serial+0x19>
    3d74:	01 c0       	rjmp	.+2      	; 0x3d78 <__vector_18+0x50>
    }
  } else {
    // Parity error, read byte but discard it
    *_udr;
    3d76:	80 81       	ld	r24, Z
    Serial._rx_complete_irq();
  }
    3d78:	ff 91       	pop	r31
    3d7a:	ef 91       	pop	r30
    3d7c:	9f 91       	pop	r25
    3d7e:	8f 91       	pop	r24
    3d80:	2f 91       	pop	r18
    3d82:	0f 90       	pop	r0
    3d84:	0f be       	out	0x3f, r0	; 63
    3d86:	0f 90       	pop	r0
    3d88:	1f 90       	pop	r1
    3d8a:	18 95       	reti

00003d8c <__vector_19>:
#elif defined(USART_UDRE_vect)
ISR(USART_UDRE_vect)
#else
  #error "Don't know what the Data Register Empty vector is called for Serial"
#endif
{
    3d8c:	1f 92       	push	r1
    3d8e:	0f 92       	push	r0
    3d90:	0f b6       	in	r0, 0x3f	; 63
    3d92:	0f 92       	push	r0
    3d94:	11 24       	eor	r1, r1
    3d96:	2f 93       	push	r18
    3d98:	3f 93       	push	r19
    3d9a:	4f 93       	push	r20
    3d9c:	5f 93       	push	r21
    3d9e:	6f 93       	push	r22
    3da0:	7f 93       	push	r23
    3da2:	8f 93       	push	r24
    3da4:	9f 93       	push	r25
    3da6:	af 93       	push	r26
    3da8:	bf 93       	push	r27
    3daa:	ef 93       	push	r30
    3dac:	ff 93       	push	r31
  Serial._tx_udr_empty_irq();
    3dae:	84 e5       	ldi	r24, 0x54	; 84
    3db0:	94 e0       	ldi	r25, 0x04	; 4
    3db2:	0e 94 9e 1d 	call	0x3b3c	; 0x3b3c <_ZN14HardwareSerial17_tx_udr_empty_irqEv>
}
    3db6:	ff 91       	pop	r31
    3db8:	ef 91       	pop	r30
    3dba:	bf 91       	pop	r27
    3dbc:	af 91       	pop	r26
    3dbe:	9f 91       	pop	r25
    3dc0:	8f 91       	pop	r24
    3dc2:	7f 91       	pop	r23
    3dc4:	6f 91       	pop	r22
    3dc6:	5f 91       	pop	r21
    3dc8:	4f 91       	pop	r20
    3dca:	3f 91       	pop	r19
    3dcc:	2f 91       	pop	r18
    3dce:	0f 90       	pop	r0
    3dd0:	0f be       	out	0x3f, r0	; 63
    3dd2:	0f 90       	pop	r0
    3dd4:	1f 90       	pop	r1
    3dd6:	18 95       	reti

00003dd8 <_Z17Serial0_availablev>:
#endif

// Function that can be weakly referenced by serialEventRun to prevent
// pulling in this file if it's not otherwise used.
bool Serial0_available() {
  return Serial.available();
    3dd8:	84 e5       	ldi	r24, 0x54	; 84
    3dda:	94 e0       	ldi	r25, 0x04	; 4
    3ddc:	0e 94 53 1d 	call	0x3aa6	; 0x3aa6 <_ZN14HardwareSerial9availableEv>
    3de0:	21 e0       	ldi	r18, 0x01	; 1
    3de2:	89 2b       	or	r24, r25
    3de4:	09 f4       	brne	.+2      	; 0x3de8 <_Z17Serial0_availablev+0x10>
    3de6:	20 e0       	ldi	r18, 0x00	; 0
}
    3de8:	82 2f       	mov	r24, r18
    3dea:	08 95       	ret

00003dec <_GLOBAL__sub_I___vector_18>:
    size_t printNumber(unsigned long, uint8_t);
    size_t printFloat(double, uint8_t);
  protected:
    void setWriteError(int err = 1) { write_error = err; }
  public:
    Print() : write_error(0) {}
    3dec:	e4 e5       	ldi	r30, 0x54	; 84
    3dee:	f4 e0       	ldi	r31, 0x04	; 4
    3df0:	13 82       	std	Z+3, r1	; 0x03
    3df2:	12 82       	std	Z+2, r1	; 0x02
  public:
    virtual int available() = 0;
    virtual int read() = 0;
    virtual int peek() = 0;

    Stream() {_timeout=1000;}
    3df4:	88 ee       	ldi	r24, 0xE8	; 232
    3df6:	93 e0       	ldi	r25, 0x03	; 3
    3df8:	a0 e0       	ldi	r26, 0x00	; 0
    3dfa:	b0 e0       	ldi	r27, 0x00	; 0
    3dfc:	84 83       	std	Z+4, r24	; 0x04
    3dfe:	95 83       	std	Z+5, r25	; 0x05
    3e00:	a6 83       	std	Z+6, r26	; 0x06
    3e02:	b7 83       	std	Z+7, r27	; 0x07
  volatile uint8_t *ucsrc, volatile uint8_t *udr) :
    _ubrrh(ubrrh), _ubrrl(ubrrl),
    _ucsra(ucsra), _ucsrb(ucsrb), _ucsrc(ucsrc),
    _udr(udr),
    _rx_buffer_head(0), _rx_buffer_tail(0),
    _tx_buffer_head(0), _tx_buffer_tail(0)
    3e04:	8c e2       	ldi	r24, 0x2C	; 44
    3e06:	92 e0       	ldi	r25, 0x02	; 2
    3e08:	91 83       	std	Z+1, r25	; 0x01
    3e0a:	80 83       	st	Z, r24
    3e0c:	85 ec       	ldi	r24, 0xC5	; 197
    3e0e:	90 e0       	ldi	r25, 0x00	; 0
    3e10:	95 87       	std	Z+13, r25	; 0x0d
    3e12:	84 87       	std	Z+12, r24	; 0x0c
    3e14:	84 ec       	ldi	r24, 0xC4	; 196
    3e16:	90 e0       	ldi	r25, 0x00	; 0
    3e18:	97 87       	std	Z+15, r25	; 0x0f
    3e1a:	86 87       	std	Z+14, r24	; 0x0e
    3e1c:	80 ec       	ldi	r24, 0xC0	; 192
    3e1e:	90 e0       	ldi	r25, 0x00	; 0
    3e20:	91 8b       	std	Z+17, r25	; 0x11
    3e22:	80 8b       	std	Z+16, r24	; 0x10
    3e24:	81 ec       	ldi	r24, 0xC1	; 193
    3e26:	90 e0       	ldi	r25, 0x00	; 0
    3e28:	93 8b       	std	Z+19, r25	; 0x13
    3e2a:	82 8b       	std	Z+18, r24	; 0x12
    3e2c:	82 ec       	ldi	r24, 0xC2	; 194
    3e2e:	90 e0       	ldi	r25, 0x00	; 0
    3e30:	95 8b       	std	Z+21, r25	; 0x15
    3e32:	84 8b       	std	Z+20, r24	; 0x14
    3e34:	86 ec       	ldi	r24, 0xC6	; 198
    3e36:	90 e0       	ldi	r25, 0x00	; 0
    3e38:	97 8b       	std	Z+23, r25	; 0x17
    3e3a:	86 8b       	std	Z+22, r24	; 0x16
    3e3c:	11 8e       	std	Z+25, r1	; 0x19
    3e3e:	12 8e       	std	Z+26, r1	; 0x1a
    3e40:	13 8e       	std	Z+27, r1	; 0x1b
    3e42:	14 8e       	std	Z+28, r1	; 0x1c
    3e44:	08 95       	ret

00003e46 <main>:
void setupUSB() __attribute__((weak));
void setupUSB() { }

int main(void)
{
	init();
    3e46:	0e 94 94 21 	call	0x4328	; 0x4328 <init>

	initVariant();
    3e4a:	0e 94 dc 16 	call	0x2db8	; 0x2db8 <initVariant>

#if defined(USBCON)
	USBDevice.attach();
#endif
	
	setup();
    3e4e:	0e 94 24 06 	call	0xc48	; 0xc48 <setup>
    
	for (;;) {
		loop();
		if (serialEventRun) serialEventRun();
    3e52:	c0 e9       	ldi	r28, 0x90	; 144
    3e54:	dd e1       	ldi	r29, 0x1D	; 29
#endif
	
	setup();
    
	for (;;) {
		loop();
    3e56:	0e 94 9a 06 	call	0xd34	; 0xd34 <loop>
		if (serialEventRun) serialEventRun();
    3e5a:	20 97       	sbiw	r28, 0x00	; 0
    3e5c:	e1 f3       	breq	.-8      	; 0x3e56 <main+0x10>
    3e5e:	0e 94 90 1d 	call	0x3b20	; 0x3b20 <_Z14serialEventRunv>
    3e62:	f9 cf       	rjmp	.-14     	; 0x3e56 <main+0x10>

00003e64 <_ZN5Print5writeEPKhj>:
size_t Print::println(unsigned long num, int base)
{
  size_t n = print(num, base);
  n += println();
  return n;
}
    3e64:	cf 92       	push	r12
    3e66:	df 92       	push	r13
    3e68:	ef 92       	push	r14
    3e6a:	ff 92       	push	r15
    3e6c:	0f 93       	push	r16
    3e6e:	1f 93       	push	r17
    3e70:	cf 93       	push	r28
    3e72:	df 93       	push	r29
    3e74:	6c 01       	movw	r12, r24
    3e76:	7a 01       	movw	r14, r20
    3e78:	8b 01       	movw	r16, r22
    3e7a:	c0 e0       	ldi	r28, 0x00	; 0
    3e7c:	d0 e0       	ldi	r29, 0x00	; 0
    3e7e:	ce 15       	cp	r28, r14
    3e80:	df 05       	cpc	r29, r15
    3e82:	81 f0       	breq	.+32     	; 0x3ea4 <_ZN5Print5writeEPKhj+0x40>
    3e84:	d8 01       	movw	r26, r16
    3e86:	6d 91       	ld	r22, X+
    3e88:	8d 01       	movw	r16, r26
    3e8a:	d6 01       	movw	r26, r12
    3e8c:	ed 91       	ld	r30, X+
    3e8e:	fc 91       	ld	r31, X
    3e90:	01 90       	ld	r0, Z+
    3e92:	f0 81       	ld	r31, Z
    3e94:	e0 2d       	mov	r30, r0
    3e96:	c6 01       	movw	r24, r12
    3e98:	09 95       	icall
    3e9a:	89 2b       	or	r24, r25
    3e9c:	11 f0       	breq	.+4      	; 0x3ea2 <_ZN5Print5writeEPKhj+0x3e>
    3e9e:	21 96       	adiw	r28, 0x01	; 1
    3ea0:	ee cf       	rjmp	.-36     	; 0x3e7e <_ZN5Print5writeEPKhj+0x1a>
    3ea2:	7e 01       	movw	r14, r28
    3ea4:	c7 01       	movw	r24, r14
    3ea6:	df 91       	pop	r29
    3ea8:	cf 91       	pop	r28
    3eaa:	1f 91       	pop	r17
    3eac:	0f 91       	pop	r16
    3eae:	ff 90       	pop	r15
    3eb0:	ef 90       	pop	r14
    3eb2:	df 90       	pop	r13
    3eb4:	cf 90       	pop	r12
    3eb6:	08 95       	ret

00003eb8 <_ZN5Print5printEPK19__FlashStringHelper>:
    3eb8:	ef 92       	push	r14
    3eba:	ff 92       	push	r15
    3ebc:	0f 93       	push	r16
    3ebe:	1f 93       	push	r17
    3ec0:	cf 93       	push	r28
    3ec2:	df 93       	push	r29
    3ec4:	8c 01       	movw	r16, r24
    3ec6:	7b 01       	movw	r14, r22
    3ec8:	c0 e0       	ldi	r28, 0x00	; 0
    3eca:	d0 e0       	ldi	r29, 0x00	; 0
    3ecc:	f7 01       	movw	r30, r14
    3ece:	ec 0f       	add	r30, r28
    3ed0:	fd 1f       	adc	r31, r29
    3ed2:	64 91       	lpm	r22, Z
    3ed4:	66 23       	and	r22, r22
    3ed6:	61 f0       	breq	.+24     	; 0x3ef0 <_ZN5Print5printEPK19__FlashStringHelper+0x38>
    3ed8:	d8 01       	movw	r26, r16
    3eda:	ed 91       	ld	r30, X+
    3edc:	fc 91       	ld	r31, X
    3ede:	01 90       	ld	r0, Z+
    3ee0:	f0 81       	ld	r31, Z
    3ee2:	e0 2d       	mov	r30, r0
    3ee4:	c8 01       	movw	r24, r16
    3ee6:	09 95       	icall
    3ee8:	89 2b       	or	r24, r25
    3eea:	11 f0       	breq	.+4      	; 0x3ef0 <_ZN5Print5printEPK19__FlashStringHelper+0x38>
    3eec:	21 96       	adiw	r28, 0x01	; 1
    3eee:	ee cf       	rjmp	.-36     	; 0x3ecc <_ZN5Print5printEPK19__FlashStringHelper+0x14>
    3ef0:	ce 01       	movw	r24, r28
    3ef2:	df 91       	pop	r29
    3ef4:	cf 91       	pop	r28
    3ef6:	1f 91       	pop	r17
    3ef8:	0f 91       	pop	r16
    3efa:	ff 90       	pop	r15
    3efc:	ef 90       	pop	r14
    3efe:	08 95       	ret

00003f00 <_ZN5Print5printEPKc>:
    3f00:	0c 94 1b 05 	jmp	0xa36	; 0xa36 <_ZN5Print5writeEPKc>

00003f04 <_ZN5Print5printEc>:
    3f04:	dc 01       	movw	r26, r24
    3f06:	ed 91       	ld	r30, X+
    3f08:	fc 91       	ld	r31, X
    3f0a:	01 90       	ld	r0, Z+
    3f0c:	f0 81       	ld	r31, Z
    3f0e:	e0 2d       	mov	r30, r0
    3f10:	09 94       	ijmp

00003f12 <_ZN5Print7printlnEv>:
    3f12:	6a e3       	ldi	r22, 0x3A	; 58
    3f14:	72 e0       	ldi	r23, 0x02	; 2
    3f16:	0c 94 1b 05 	jmp	0xa36	; 0xa36 <_ZN5Print5writeEPKc>

00003f1a <_ZN5Print7printlnEPKc>:
    3f1a:	0f 93       	push	r16
    3f1c:	1f 93       	push	r17
    3f1e:	cf 93       	push	r28
    3f20:	df 93       	push	r29
    3f22:	ec 01       	movw	r28, r24
    3f24:	0e 94 1b 05 	call	0xa36	; 0xa36 <_ZN5Print5writeEPKc>
    3f28:	8c 01       	movw	r16, r24
    3f2a:	ce 01       	movw	r24, r28
    3f2c:	0e 94 89 1f 	call	0x3f12	; 0x3f12 <_ZN5Print7printlnEv>
    3f30:	80 0f       	add	r24, r16
    3f32:	91 1f       	adc	r25, r17
    3f34:	df 91       	pop	r29
    3f36:	cf 91       	pop	r28
    3f38:	1f 91       	pop	r17
    3f3a:	0f 91       	pop	r16
    3f3c:	08 95       	ret

00003f3e <_ZN5Print11printNumberEmh>:
    3f3e:	8f 92       	push	r8
    3f40:	9f 92       	push	r9
    3f42:	af 92       	push	r10
    3f44:	bf 92       	push	r11
    3f46:	ef 92       	push	r14
    3f48:	ff 92       	push	r15
    3f4a:	0f 93       	push	r16
    3f4c:	1f 93       	push	r17
    3f4e:	cf 93       	push	r28
    3f50:	df 93       	push	r29
    3f52:	cd b7       	in	r28, 0x3d	; 61
    3f54:	de b7       	in	r29, 0x3e	; 62
    3f56:	a1 97       	sbiw	r28, 0x21	; 33
    3f58:	0f b6       	in	r0, 0x3f	; 63
    3f5a:	f8 94       	cli
    3f5c:	de bf       	out	0x3e, r29	; 62
    3f5e:	0f be       	out	0x3f, r0	; 63
    3f60:	cd bf       	out	0x3d, r28	; 61
    3f62:	7c 01       	movw	r14, r24
    3f64:	fa 01       	movw	r30, r20
    3f66:	cb 01       	movw	r24, r22
    3f68:	19 a2       	std	Y+33, r1	; 0x21
    3f6a:	22 30       	cpi	r18, 0x02	; 2
    3f6c:	08 f4       	brcc	.+2      	; 0x3f70 <_ZN5Print11printNumberEmh+0x32>
    3f6e:	2a e0       	ldi	r18, 0x0A	; 10
    3f70:	8e 01       	movw	r16, r28
    3f72:	0f 5d       	subi	r16, 0xDF	; 223
    3f74:	1f 4f       	sbci	r17, 0xFF	; 255
    3f76:	82 2e       	mov	r8, r18
    3f78:	91 2c       	mov	r9, r1
    3f7a:	a1 2c       	mov	r10, r1
    3f7c:	b1 2c       	mov	r11, r1
    3f7e:	bf 01       	movw	r22, r30
    3f80:	a5 01       	movw	r20, r10
    3f82:	94 01       	movw	r18, r8
    3f84:	0e 94 0a 24 	call	0x4814	; 0x4814 <__udivmodsi4>
    3f88:	f9 01       	movw	r30, r18
    3f8a:	ca 01       	movw	r24, r20
    3f8c:	01 50       	subi	r16, 0x01	; 1
    3f8e:	11 09       	sbc	r17, r1
    3f90:	6a 30       	cpi	r22, 0x0A	; 10
    3f92:	10 f4       	brcc	.+4      	; 0x3f98 <_ZN5Print11printNumberEmh+0x5a>
    3f94:	60 5d       	subi	r22, 0xD0	; 208
    3f96:	01 c0       	rjmp	.+2      	; 0x3f9a <_ZN5Print11printNumberEmh+0x5c>
    3f98:	69 5c       	subi	r22, 0xC9	; 201
    3f9a:	d8 01       	movw	r26, r16
    3f9c:	6c 93       	st	X, r22
    3f9e:	23 2b       	or	r18, r19
    3fa0:	24 2b       	or	r18, r20
    3fa2:	25 2b       	or	r18, r21
    3fa4:	61 f7       	brne	.-40     	; 0x3f7e <_ZN5Print11printNumberEmh+0x40>
    3fa6:	b8 01       	movw	r22, r16
    3fa8:	c7 01       	movw	r24, r14
    3faa:	0e 94 1b 05 	call	0xa36	; 0xa36 <_ZN5Print5writeEPKc>
    3fae:	a1 96       	adiw	r28, 0x21	; 33
    3fb0:	0f b6       	in	r0, 0x3f	; 63
    3fb2:	f8 94       	cli
    3fb4:	de bf       	out	0x3e, r29	; 62
    3fb6:	0f be       	out	0x3f, r0	; 63
    3fb8:	cd bf       	out	0x3d, r28	; 61
    3fba:	df 91       	pop	r29
    3fbc:	cf 91       	pop	r28
    3fbe:	1f 91       	pop	r17
    3fc0:	0f 91       	pop	r16
    3fc2:	ff 90       	pop	r15
    3fc4:	ef 90       	pop	r14
    3fc6:	bf 90       	pop	r11
    3fc8:	af 90       	pop	r10
    3fca:	9f 90       	pop	r9
    3fcc:	8f 90       	pop	r8
    3fce:	08 95       	ret

00003fd0 <_ZN5Print5printEmi>:
    3fd0:	21 15       	cp	r18, r1
    3fd2:	31 05       	cpc	r19, r1
    3fd4:	41 f4       	brne	.+16     	; 0x3fe6 <_ZN5Print5printEmi+0x16>
    3fd6:	dc 01       	movw	r26, r24
    3fd8:	ed 91       	ld	r30, X+
    3fda:	fc 91       	ld	r31, X
    3fdc:	01 90       	ld	r0, Z+
    3fde:	f0 81       	ld	r31, Z
    3fe0:	e0 2d       	mov	r30, r0
    3fe2:	64 2f       	mov	r22, r20
    3fe4:	09 94       	ijmp
    3fe6:	0c 94 9f 1f 	jmp	0x3f3e	; 0x3f3e <_ZN5Print11printNumberEmh>

00003fea <_ZN5Print5printEhi>:
    3fea:	9a 01       	movw	r18, r20
    3fec:	46 2f       	mov	r20, r22
    3fee:	50 e0       	ldi	r21, 0x00	; 0
    3ff0:	60 e0       	ldi	r22, 0x00	; 0
    3ff2:	70 e0       	ldi	r23, 0x00	; 0
    3ff4:	0c 94 e8 1f 	jmp	0x3fd0	; 0x3fd0 <_ZN5Print5printEmi>

00003ff8 <_ZN5Print7printlnEhi>:
    3ff8:	0f 93       	push	r16
    3ffa:	1f 93       	push	r17
    3ffc:	cf 93       	push	r28
    3ffe:	df 93       	push	r29
    4000:	ec 01       	movw	r28, r24
    4002:	0e 94 f5 1f 	call	0x3fea	; 0x3fea <_ZN5Print5printEhi>
    4006:	8c 01       	movw	r16, r24
    4008:	ce 01       	movw	r24, r28
    400a:	0e 94 89 1f 	call	0x3f12	; 0x3f12 <_ZN5Print7printlnEv>
    400e:	80 0f       	add	r24, r16
    4010:	91 1f       	adc	r25, r17
    4012:	df 91       	pop	r29
    4014:	cf 91       	pop	r28
    4016:	1f 91       	pop	r17
    4018:	0f 91       	pop	r16
    401a:	08 95       	ret

0000401c <_ZN5Print5printEli>:
{
  return print((unsigned long) n, base);
}

size_t Print::print(long n, int base)
{
    401c:	cf 92       	push	r12
    401e:	df 92       	push	r13
    4020:	ef 92       	push	r14
    4022:	ff 92       	push	r15
    4024:	0f 93       	push	r16
    4026:	1f 93       	push	r17
    4028:	cf 93       	push	r28
    402a:	df 93       	push	r29
  if (base == 0) {
    402c:	21 15       	cp	r18, r1
    402e:	31 05       	cpc	r19, r1
    4030:	81 f4       	brne	.+32     	; 0x4052 <_ZN5Print5printEli+0x36>
    return write(n);
    4032:	dc 01       	movw	r26, r24
    4034:	ed 91       	ld	r30, X+
    4036:	fc 91       	ld	r31, X
    4038:	01 90       	ld	r0, Z+
    403a:	f0 81       	ld	r31, Z
    403c:	e0 2d       	mov	r30, r0
    403e:	64 2f       	mov	r22, r20
    }
    return printNumber(n, 10);
  } else {
    return printNumber(n, base);
  }
}
    4040:	df 91       	pop	r29
    4042:	cf 91       	pop	r28
    4044:	1f 91       	pop	r17
    4046:	0f 91       	pop	r16
    4048:	ff 90       	pop	r15
    404a:	ef 90       	pop	r14
    404c:	df 90       	pop	r13
    404e:	cf 90       	pop	r12
}

size_t Print::print(long n, int base)
{
  if (base == 0) {
    return write(n);
    4050:	09 94       	ijmp
  } else if (base == 10) {
    4052:	2a 30       	cpi	r18, 0x0A	; 10
    4054:	31 05       	cpc	r19, r1
    4056:	01 f5       	brne	.+64     	; 0x4098 <_ZN5Print5printEli+0x7c>
    if (n < 0) {
    4058:	77 ff       	sbrs	r23, 7
    405a:	1d c0       	rjmp	.+58     	; 0x4096 <_ZN5Print5printEli+0x7a>
    405c:	6a 01       	movw	r12, r20
    405e:	7b 01       	movw	r14, r22
    4060:	ec 01       	movw	r28, r24
      int t = print('-');
    4062:	6d e2       	ldi	r22, 0x2D	; 45
    4064:	0e 94 82 1f 	call	0x3f04	; 0x3f04 <_ZN5Print5printEc>
    4068:	8c 01       	movw	r16, r24
      n = -n;
      return printNumber(n, 10) + t;
    406a:	44 27       	eor	r20, r20
    406c:	55 27       	eor	r21, r21
    406e:	ba 01       	movw	r22, r20
    4070:	4c 19       	sub	r20, r12
    4072:	5d 09       	sbc	r21, r13
    4074:	6e 09       	sbc	r22, r14
    4076:	7f 09       	sbc	r23, r15
    4078:	2a e0       	ldi	r18, 0x0A	; 10
    407a:	ce 01       	movw	r24, r28
    407c:	0e 94 9f 1f 	call	0x3f3e	; 0x3f3e <_ZN5Print11printNumberEmh>
    4080:	80 0f       	add	r24, r16
    4082:	91 1f       	adc	r25, r17
    }
    return printNumber(n, 10);
  } else {
    return printNumber(n, base);
  }
}
    4084:	df 91       	pop	r29
    4086:	cf 91       	pop	r28
    4088:	1f 91       	pop	r17
    408a:	0f 91       	pop	r16
    408c:	ff 90       	pop	r15
    408e:	ef 90       	pop	r14
    4090:	df 90       	pop	r13
    4092:	cf 90       	pop	r12
    4094:	08 95       	ret
    if (n < 0) {
      int t = print('-');
      n = -n;
      return printNumber(n, 10) + t;
    }
    return printNumber(n, 10);
    4096:	2a e0       	ldi	r18, 0x0A	; 10
  } else {
    return printNumber(n, base);
  }
}
    4098:	df 91       	pop	r29
    409a:	cf 91       	pop	r28
    409c:	1f 91       	pop	r17
    409e:	0f 91       	pop	r16
    40a0:	ff 90       	pop	r15
    40a2:	ef 90       	pop	r14
    40a4:	df 90       	pop	r13
    40a6:	cf 90       	pop	r12
      n = -n;
      return printNumber(n, 10) + t;
    }
    return printNumber(n, 10);
  } else {
    return printNumber(n, base);
    40a8:	0c 94 9f 1f 	jmp	0x3f3e	; 0x3f3e <_ZN5Print11printNumberEmh>

000040ac <_ZN5Print5printEii>:
{
  return print((unsigned long) b, base);
}

size_t Print::print(int n, int base)
{
    40ac:	9a 01       	movw	r18, r20
  return print((long) n, base);
    40ae:	ab 01       	movw	r20, r22
    40b0:	77 0f       	add	r23, r23
    40b2:	66 0b       	sbc	r22, r22
    40b4:	77 0b       	sbc	r23, r23
    40b6:	0c 94 0e 20 	jmp	0x401c	; 0x401c <_ZN5Print5printEli>

000040ba <_ZN5Print7printlnEii>:
  n += println();
  return n;
}

size_t Print::println(int num, int base)
{
    40ba:	0f 93       	push	r16
    40bc:	1f 93       	push	r17
    40be:	cf 93       	push	r28
    40c0:	df 93       	push	r29
    40c2:	ec 01       	movw	r28, r24
  size_t n = print(num, base);
    40c4:	0e 94 56 20 	call	0x40ac	; 0x40ac <_ZN5Print5printEii>
    40c8:	8c 01       	movw	r16, r24
  n += println();
    40ca:	ce 01       	movw	r24, r28
    40cc:	0e 94 89 1f 	call	0x3f12	; 0x3f12 <_ZN5Print7printlnEv>
  return n;
}
    40d0:	80 0f       	add	r24, r16
    40d2:	91 1f       	adc	r25, r17
    40d4:	df 91       	pop	r29
    40d6:	cf 91       	pop	r28
    40d8:	1f 91       	pop	r17
    40da:	0f 91       	pop	r16
    40dc:	08 95       	ret

000040de <nothing>:
    #endif
      break;       
#endif
    }
      
    intFunc[interruptNum] = nothing;
    40de:	08 95       	ret

000040e0 <attachInterrupt>:
    40e0:	82 30       	cpi	r24, 0x02	; 2
    40e2:	e8 f4       	brcc	.+58     	; 0x411e <attachInterrupt+0x3e>
    40e4:	e8 2f       	mov	r30, r24
    40e6:	f0 e0       	ldi	r31, 0x00	; 0
    40e8:	ee 0f       	add	r30, r30
    40ea:	ff 1f       	adc	r31, r31
    40ec:	e3 5c       	subi	r30, 0xC3	; 195
    40ee:	fe 4f       	sbci	r31, 0xFE	; 254
    40f0:	71 83       	std	Z+1, r23	; 0x01
    40f2:	60 83       	st	Z, r22
    40f4:	81 30       	cpi	r24, 0x01	; 1
    40f6:	41 f0       	breq	.+16     	; 0x4108 <attachInterrupt+0x28>
    40f8:	80 91 69 00 	lds	r24, 0x0069	; 0x800069 <__DATA_REGION_ORIGIN__+0x9>
    40fc:	8c 7f       	andi	r24, 0xFC	; 252
    40fe:	48 2b       	or	r20, r24
    4100:	40 93 69 00 	sts	0x0069, r20	; 0x800069 <__DATA_REGION_ORIGIN__+0x9>
    4104:	e8 9a       	sbi	0x1d, 0	; 29
    4106:	08 95       	ret
    4108:	80 91 69 00 	lds	r24, 0x0069	; 0x800069 <__DATA_REGION_ORIGIN__+0x9>
    410c:	83 7f       	andi	r24, 0xF3	; 243
    410e:	44 0f       	add	r20, r20
    4110:	55 1f       	adc	r21, r21
    4112:	44 0f       	add	r20, r20
    4114:	55 1f       	adc	r21, r21
    4116:	48 2b       	or	r20, r24
    4118:	40 93 69 00 	sts	0x0069, r20	; 0x800069 <__DATA_REGION_ORIGIN__+0x9>
    411c:	e9 9a       	sbi	0x1d, 1	; 29
    411e:	08 95       	ret

00004120 <__vector_1>:
IMPLEMENT_ISR(INT6_vect, EXTERNAL_INT_6)
IMPLEMENT_ISR(INT7_vect, EXTERNAL_INT_7)

#else

IMPLEMENT_ISR(INT0_vect, EXTERNAL_INT_0)
    4120:	1f 92       	push	r1
    4122:	0f 92       	push	r0
    4124:	0f b6       	in	r0, 0x3f	; 63
    4126:	0f 92       	push	r0
    4128:	11 24       	eor	r1, r1
    412a:	2f 93       	push	r18
    412c:	3f 93       	push	r19
    412e:	4f 93       	push	r20
    4130:	5f 93       	push	r21
    4132:	6f 93       	push	r22
    4134:	7f 93       	push	r23
    4136:	8f 93       	push	r24
    4138:	9f 93       	push	r25
    413a:	af 93       	push	r26
    413c:	bf 93       	push	r27
    413e:	ef 93       	push	r30
    4140:	ff 93       	push	r31
    4142:	e0 91 3d 01 	lds	r30, 0x013D	; 0x80013d <intFunc>
    4146:	f0 91 3e 01 	lds	r31, 0x013E	; 0x80013e <intFunc+0x1>
    414a:	09 95       	icall
    414c:	ff 91       	pop	r31
    414e:	ef 91       	pop	r30
    4150:	bf 91       	pop	r27
    4152:	af 91       	pop	r26
    4154:	9f 91       	pop	r25
    4156:	8f 91       	pop	r24
    4158:	7f 91       	pop	r23
    415a:	6f 91       	pop	r22
    415c:	5f 91       	pop	r21
    415e:	4f 91       	pop	r20
    4160:	3f 91       	pop	r19
    4162:	2f 91       	pop	r18
    4164:	0f 90       	pop	r0
    4166:	0f be       	out	0x3f, r0	; 63
    4168:	0f 90       	pop	r0
    416a:	1f 90       	pop	r1
    416c:	18 95       	reti

0000416e <__vector_2>:
IMPLEMENT_ISR(INT1_vect, EXTERNAL_INT_1)
    416e:	1f 92       	push	r1
    4170:	0f 92       	push	r0
    4172:	0f b6       	in	r0, 0x3f	; 63
    4174:	0f 92       	push	r0
    4176:	11 24       	eor	r1, r1
    4178:	2f 93       	push	r18
    417a:	3f 93       	push	r19
    417c:	4f 93       	push	r20
    417e:	5f 93       	push	r21
    4180:	6f 93       	push	r22
    4182:	7f 93       	push	r23
    4184:	8f 93       	push	r24
    4186:	9f 93       	push	r25
    4188:	af 93       	push	r26
    418a:	bf 93       	push	r27
    418c:	ef 93       	push	r30
    418e:	ff 93       	push	r31
    4190:	e0 91 3f 01 	lds	r30, 0x013F	; 0x80013f <intFunc+0x2>
    4194:	f0 91 40 01 	lds	r31, 0x0140	; 0x800140 <intFunc+0x3>
    4198:	09 95       	icall
    419a:	ff 91       	pop	r31
    419c:	ef 91       	pop	r30
    419e:	bf 91       	pop	r27
    41a0:	af 91       	pop	r26
    41a2:	9f 91       	pop	r25
    41a4:	8f 91       	pop	r24
    41a6:	7f 91       	pop	r23
    41a8:	6f 91       	pop	r22
    41aa:	5f 91       	pop	r21
    41ac:	4f 91       	pop	r20
    41ae:	3f 91       	pop	r19
    41b0:	2f 91       	pop	r18
    41b2:	0f 90       	pop	r0
    41b4:	0f be       	out	0x3f, r0	; 63
    41b6:	0f 90       	pop	r0
    41b8:	1f 90       	pop	r1
    41ba:	18 95       	reti

000041bc <__vector_16>:
	cli();
	m = timer0_millis;
	SREG = oldSREG;

	return m;
}
    41bc:	1f 92       	push	r1
    41be:	0f 92       	push	r0
    41c0:	0f b6       	in	r0, 0x3f	; 63
    41c2:	0f 92       	push	r0
    41c4:	11 24       	eor	r1, r1
    41c6:	2f 93       	push	r18
    41c8:	3f 93       	push	r19
    41ca:	8f 93       	push	r24
    41cc:	9f 93       	push	r25
    41ce:	af 93       	push	r26
    41d0:	bf 93       	push	r27
    41d2:	80 91 f2 04 	lds	r24, 0x04F2	; 0x8004f2 <timer0_millis>
    41d6:	90 91 f3 04 	lds	r25, 0x04F3	; 0x8004f3 <timer0_millis+0x1>
    41da:	a0 91 f4 04 	lds	r26, 0x04F4	; 0x8004f4 <timer0_millis+0x2>
    41de:	b0 91 f5 04 	lds	r27, 0x04F5	; 0x8004f5 <timer0_millis+0x3>
    41e2:	30 91 f1 04 	lds	r19, 0x04F1	; 0x8004f1 <timer0_fract>
    41e6:	23 e0       	ldi	r18, 0x03	; 3
    41e8:	23 0f       	add	r18, r19
    41ea:	2d 37       	cpi	r18, 0x7D	; 125
    41ec:	20 f4       	brcc	.+8      	; 0x41f6 <__vector_16+0x3a>
    41ee:	01 96       	adiw	r24, 0x01	; 1
    41f0:	a1 1d       	adc	r26, r1
    41f2:	b1 1d       	adc	r27, r1
    41f4:	05 c0       	rjmp	.+10     	; 0x4200 <__vector_16+0x44>
    41f6:	26 e8       	ldi	r18, 0x86	; 134
    41f8:	23 0f       	add	r18, r19
    41fa:	02 96       	adiw	r24, 0x02	; 2
    41fc:	a1 1d       	adc	r26, r1
    41fe:	b1 1d       	adc	r27, r1
    4200:	20 93 f1 04 	sts	0x04F1, r18	; 0x8004f1 <timer0_fract>
    4204:	80 93 f2 04 	sts	0x04F2, r24	; 0x8004f2 <timer0_millis>
    4208:	90 93 f3 04 	sts	0x04F3, r25	; 0x8004f3 <timer0_millis+0x1>
    420c:	a0 93 f4 04 	sts	0x04F4, r26	; 0x8004f4 <timer0_millis+0x2>
    4210:	b0 93 f5 04 	sts	0x04F5, r27	; 0x8004f5 <timer0_millis+0x3>
    4214:	80 91 f6 04 	lds	r24, 0x04F6	; 0x8004f6 <timer0_overflow_count>
    4218:	90 91 f7 04 	lds	r25, 0x04F7	; 0x8004f7 <timer0_overflow_count+0x1>
    421c:	a0 91 f8 04 	lds	r26, 0x04F8	; 0x8004f8 <timer0_overflow_count+0x2>
    4220:	b0 91 f9 04 	lds	r27, 0x04F9	; 0x8004f9 <timer0_overflow_count+0x3>
    4224:	01 96       	adiw	r24, 0x01	; 1
    4226:	a1 1d       	adc	r26, r1
    4228:	b1 1d       	adc	r27, r1
    422a:	80 93 f6 04 	sts	0x04F6, r24	; 0x8004f6 <timer0_overflow_count>
    422e:	90 93 f7 04 	sts	0x04F7, r25	; 0x8004f7 <timer0_overflow_count+0x1>
    4232:	a0 93 f8 04 	sts	0x04F8, r26	; 0x8004f8 <timer0_overflow_count+0x2>
    4236:	b0 93 f9 04 	sts	0x04F9, r27	; 0x8004f9 <timer0_overflow_count+0x3>
    423a:	bf 91       	pop	r27
    423c:	af 91       	pop	r26
    423e:	9f 91       	pop	r25
    4240:	8f 91       	pop	r24
    4242:	3f 91       	pop	r19
    4244:	2f 91       	pop	r18
    4246:	0f 90       	pop	r0
    4248:	0f be       	out	0x3f, r0	; 63
    424a:	0f 90       	pop	r0
    424c:	1f 90       	pop	r1
    424e:	18 95       	reti

00004250 <micros>:

unsigned long micros() {
	unsigned long m;
	uint8_t oldSREG = SREG, t;
    4250:	3f b7       	in	r19, 0x3f	; 63
	
	cli();
    4252:	f8 94       	cli
	m = timer0_overflow_count;
    4254:	80 91 f6 04 	lds	r24, 0x04F6	; 0x8004f6 <timer0_overflow_count>
    4258:	90 91 f7 04 	lds	r25, 0x04F7	; 0x8004f7 <timer0_overflow_count+0x1>
    425c:	a0 91 f8 04 	lds	r26, 0x04F8	; 0x8004f8 <timer0_overflow_count+0x2>
    4260:	b0 91 f9 04 	lds	r27, 0x04F9	; 0x8004f9 <timer0_overflow_count+0x3>
#if defined(TCNT0)
	t = TCNT0;
    4264:	26 b5       	in	r18, 0x26	; 38
#else
	#error TIMER 0 not defined
#endif

#ifdef TIFR0
	if ((TIFR0 & _BV(TOV0)) && (t < 255))
    4266:	a8 9b       	sbis	0x15, 0	; 21
    4268:	05 c0       	rjmp	.+10     	; 0x4274 <micros+0x24>
    426a:	2f 3f       	cpi	r18, 0xFF	; 255
    426c:	19 f0       	breq	.+6      	; 0x4274 <micros+0x24>
		m++;
    426e:	01 96       	adiw	r24, 0x01	; 1
    4270:	a1 1d       	adc	r26, r1
    4272:	b1 1d       	adc	r27, r1
#else
	if ((TIFR & _BV(TOV0)) && (t < 255))
		m++;
#endif

	SREG = oldSREG;
    4274:	3f bf       	out	0x3f, r19	; 63
	
	return ((m << 8) + t) * (64 / clockCyclesPerMicrosecond());
    4276:	ba 2f       	mov	r27, r26
    4278:	a9 2f       	mov	r26, r25
    427a:	98 2f       	mov	r25, r24
    427c:	88 27       	eor	r24, r24
    427e:	82 0f       	add	r24, r18
    4280:	91 1d       	adc	r25, r1
    4282:	a1 1d       	adc	r26, r1
    4284:	b1 1d       	adc	r27, r1
    4286:	bc 01       	movw	r22, r24
    4288:	cd 01       	movw	r24, r26
    428a:	42 e0       	ldi	r20, 0x02	; 2
    428c:	66 0f       	add	r22, r22
    428e:	77 1f       	adc	r23, r23
    4290:	88 1f       	adc	r24, r24
    4292:	99 1f       	adc	r25, r25
    4294:	4a 95       	dec	r20
    4296:	d1 f7       	brne	.-12     	; 0x428c <micros+0x3c>
}
    4298:	08 95       	ret

0000429a <delay>:

void delay(unsigned long ms)
{
    429a:	8f 92       	push	r8
    429c:	9f 92       	push	r9
    429e:	af 92       	push	r10
    42a0:	bf 92       	push	r11
    42a2:	cf 92       	push	r12
    42a4:	df 92       	push	r13
    42a6:	ef 92       	push	r14
    42a8:	ff 92       	push	r15
    42aa:	6b 01       	movw	r12, r22
    42ac:	7c 01       	movw	r14, r24
	uint32_t start = micros();
    42ae:	0e 94 28 21 	call	0x4250	; 0x4250 <micros>
    42b2:	4b 01       	movw	r8, r22
    42b4:	5c 01       	movw	r10, r24

	while (ms > 0) {
    42b6:	c1 14       	cp	r12, r1
    42b8:	d1 04       	cpc	r13, r1
    42ba:	e1 04       	cpc	r14, r1
    42bc:	f1 04       	cpc	r15, r1
    42be:	01 f1       	breq	.+64     	; 0x4300 <delay+0x66>
		yield();
    42c0:	0e 94 f5 23 	call	0x47ea	; 0x47ea <yield>
		while ( ms > 0 && (micros() - start) >= 1000) {
    42c4:	0e 94 28 21 	call	0x4250	; 0x4250 <micros>
    42c8:	dc 01       	movw	r26, r24
    42ca:	cb 01       	movw	r24, r22
    42cc:	88 19       	sub	r24, r8
    42ce:	99 09       	sbc	r25, r9
    42d0:	aa 09       	sbc	r26, r10
    42d2:	bb 09       	sbc	r27, r11
    42d4:	88 3e       	cpi	r24, 0xE8	; 232
    42d6:	93 40       	sbci	r25, 0x03	; 3
    42d8:	a1 05       	cpc	r26, r1
    42da:	b1 05       	cpc	r27, r1
    42dc:	60 f3       	brcs	.-40     	; 0x42b6 <delay+0x1c>
			ms--;
    42de:	21 e0       	ldi	r18, 0x01	; 1
    42e0:	c2 1a       	sub	r12, r18
    42e2:	d1 08       	sbc	r13, r1
    42e4:	e1 08       	sbc	r14, r1
    42e6:	f1 08       	sbc	r15, r1
			start += 1000;
    42e8:	88 ee       	ldi	r24, 0xE8	; 232
    42ea:	88 0e       	add	r8, r24
    42ec:	83 e0       	ldi	r24, 0x03	; 3
    42ee:	98 1e       	adc	r9, r24
    42f0:	a1 1c       	adc	r10, r1
    42f2:	b1 1c       	adc	r11, r1
{
	uint32_t start = micros();

	while (ms > 0) {
		yield();
		while ( ms > 0 && (micros() - start) >= 1000) {
    42f4:	c1 14       	cp	r12, r1
    42f6:	d1 04       	cpc	r13, r1
    42f8:	e1 04       	cpc	r14, r1
    42fa:	f1 04       	cpc	r15, r1
    42fc:	19 f7       	brne	.-58     	; 0x42c4 <delay+0x2a>
    42fe:	db cf       	rjmp	.-74     	; 0x42b6 <delay+0x1c>
			ms--;
			start += 1000;
		}
	}
}
    4300:	ff 90       	pop	r15
    4302:	ef 90       	pop	r14
    4304:	df 90       	pop	r13
    4306:	cf 90       	pop	r12
    4308:	bf 90       	pop	r11
    430a:	af 90       	pop	r10
    430c:	9f 90       	pop	r9
    430e:	8f 90       	pop	r8
    4310:	08 95       	ret

00004312 <delayMicroseconds>:
#elif F_CPU >= 16000000L
	// for the 16 MHz clock on most Arduino boards

	// for a one-microsecond delay, simply return.  the overhead
	// of the function call takes 14 (16) cycles, which is 1us
	if (us <= 1) return; //  = 3 cycles, (4 when true)
    4312:	82 30       	cpi	r24, 0x02	; 2
    4314:	91 05       	cpc	r25, r1
    4316:	38 f0       	brcs	.+14     	; 0x4326 <delayMicroseconds+0x14>

	// the following loop takes 1/4 of a microsecond (4 cycles)
	// per iteration, so execute it four times for each microsecond of
	// delay requested.
	us <<= 2; // x4 us, = 4 cycles
    4318:	88 0f       	add	r24, r24
    431a:	99 1f       	adc	r25, r25
    431c:	88 0f       	add	r24, r24
    431e:	99 1f       	adc	r25, r25

	// account for the time taken in the preceeding commands.
	// we just burned 19 (21) cycles above, remove 5, (5*4=20)
	// us is at least 8 so we can substract 5
	us -= 5; // = 2 cycles,
    4320:	05 97       	sbiw	r24, 0x05	; 5
	

#endif

	// busy wait
	__asm__ __volatile__ (
    4322:	01 97       	sbiw	r24, 0x01	; 1
    4324:	f1 f7       	brne	.-4      	; 0x4322 <delayMicroseconds+0x10>
    4326:	08 95       	ret

00004328 <init>:

void init()
{
	// this needs to be called before setup() or some functions won't
	// work there
	sei();
    4328:	78 94       	sei
	
	// on the ATmega168, timer 0 is also used for fast hardware pwm
	// (using phase-correct PWM would mean that timer 0 overflowed half as often
	// resulting in different millis() behavior on the ATmega8 and ATmega168)
#if defined(TCCR0A) && defined(WGM01)
	sbi(TCCR0A, WGM01);
    432a:	84 b5       	in	r24, 0x24	; 36
    432c:	82 60       	ori	r24, 0x02	; 2
    432e:	84 bd       	out	0x24, r24	; 36
	sbi(TCCR0A, WGM00);
    4330:	84 b5       	in	r24, 0x24	; 36
    4332:	81 60       	ori	r24, 0x01	; 1
    4334:	84 bd       	out	0x24, r24	; 36
	// this combination is for the standard atmega8
	sbi(TCCR0, CS01);
	sbi(TCCR0, CS00);
#elif defined(TCCR0B) && defined(CS01) && defined(CS00)
	// this combination is for the standard 168/328/1280/2560
	sbi(TCCR0B, CS01);
    4336:	85 b5       	in	r24, 0x25	; 37
    4338:	82 60       	ori	r24, 0x02	; 2
    433a:	85 bd       	out	0x25, r24	; 37
	sbi(TCCR0B, CS00);
    433c:	85 b5       	in	r24, 0x25	; 37
    433e:	81 60       	ori	r24, 0x01	; 1
    4340:	85 bd       	out	0x25, r24	; 37

	// enable timer 0 overflow interrupt
#if defined(TIMSK) && defined(TOIE0)
	sbi(TIMSK, TOIE0);
#elif defined(TIMSK0) && defined(TOIE0)
	sbi(TIMSK0, TOIE0);
    4342:	ee e6       	ldi	r30, 0x6E	; 110
    4344:	f0 e0       	ldi	r31, 0x00	; 0
    4346:	80 81       	ld	r24, Z
    4348:	81 60       	ori	r24, 0x01	; 1
    434a:	80 83       	st	Z, r24
	// this is better for motors as it ensures an even waveform
	// note, however, that fast pwm mode can achieve a frequency of up
	// 8 MHz (with a 16 MHz clock) at 50% duty cycle

#if defined(TCCR1B) && defined(CS11) && defined(CS10)
	TCCR1B = 0;
    434c:	e1 e8       	ldi	r30, 0x81	; 129
    434e:	f0 e0       	ldi	r31, 0x00	; 0
    4350:	10 82       	st	Z, r1

	// set timer 1 prescale factor to 64
	sbi(TCCR1B, CS11);
    4352:	80 81       	ld	r24, Z
    4354:	82 60       	ori	r24, 0x02	; 2
    4356:	80 83       	st	Z, r24
#if F_CPU >= 8000000L
	sbi(TCCR1B, CS10);
    4358:	80 81       	ld	r24, Z
    435a:	81 60       	ori	r24, 0x01	; 1
    435c:	80 83       	st	Z, r24
	sbi(TCCR1, CS10);
#endif
#endif
	// put timer 1 in 8-bit phase correct pwm mode
#if defined(TCCR1A) && defined(WGM10)
	sbi(TCCR1A, WGM10);
    435e:	e0 e8       	ldi	r30, 0x80	; 128
    4360:	f0 e0       	ldi	r31, 0x00	; 0
    4362:	80 81       	ld	r24, Z
    4364:	81 60       	ori	r24, 0x01	; 1
    4366:	80 83       	st	Z, r24

	// set timer 2 prescale factor to 64
#if defined(TCCR2) && defined(CS22)
	sbi(TCCR2, CS22);
#elif defined(TCCR2B) && defined(CS22)
	sbi(TCCR2B, CS22);
    4368:	e1 eb       	ldi	r30, 0xB1	; 177
    436a:	f0 e0       	ldi	r31, 0x00	; 0
    436c:	80 81       	ld	r24, Z
    436e:	84 60       	ori	r24, 0x04	; 4
    4370:	80 83       	st	Z, r24

	// configure timer 2 for phase correct pwm (8-bit)
#if defined(TCCR2) && defined(WGM20)
	sbi(TCCR2, WGM20);
#elif defined(TCCR2A) && defined(WGM20)
	sbi(TCCR2A, WGM20);
    4372:	e0 eb       	ldi	r30, 0xB0	; 176
    4374:	f0 e0       	ldi	r31, 0x00	; 0
    4376:	80 81       	ld	r24, Z
    4378:	81 60       	ori	r24, 0x01	; 1
    437a:	80 83       	st	Z, r24
#endif

#if defined(ADCSRA)
	// set a2d prescaler so we are inside the desired 50-200 KHz range.
	#if F_CPU >= 16000000 // 16 MHz / 128 = 125 KHz
		sbi(ADCSRA, ADPS2);
    437c:	ea e7       	ldi	r30, 0x7A	; 122
    437e:	f0 e0       	ldi	r31, 0x00	; 0
    4380:	80 81       	ld	r24, Z
    4382:	84 60       	ori	r24, 0x04	; 4
    4384:	80 83       	st	Z, r24
		sbi(ADCSRA, ADPS1);
    4386:	80 81       	ld	r24, Z
    4388:	82 60       	ori	r24, 0x02	; 2
    438a:	80 83       	st	Z, r24
		sbi(ADCSRA, ADPS0);
    438c:	80 81       	ld	r24, Z
    438e:	81 60       	ori	r24, 0x01	; 1
    4390:	80 83       	st	Z, r24
		cbi(ADCSRA, ADPS2);
		cbi(ADCSRA, ADPS1);
		sbi(ADCSRA, ADPS0);
	#endif
	// enable a2d conversions
	sbi(ADCSRA, ADEN);
    4392:	80 81       	ld	r24, Z
    4394:	80 68       	ori	r24, 0x80	; 128
    4396:	80 83       	st	Z, r24
	// here so they can be used as normal digital i/o; they will be
	// reconnected in Serial.begin()
#if defined(UCSRB)
	UCSRB = 0;
#elif defined(UCSR0B)
	UCSR0B = 0;
    4398:	10 92 c1 00 	sts	0x00C1, r1	; 0x8000c1 <__DATA_REGION_ORIGIN__+0x61>
    439c:	08 95       	ret

0000439e <analogRead>:
#elif defined(__AVR_ATmega32U4__)
	if (pin >= 18) pin -= 18; // allow for channel or pin numbers
#elif defined(__AVR_ATmega1284__) || defined(__AVR_ATmega1284P__) || defined(__AVR_ATmega644__) || defined(__AVR_ATmega644A__) || defined(__AVR_ATmega644P__) || defined(__AVR_ATmega644PA__)
	if (pin >= 24) pin -= 24; // allow for channel or pin numbers
#else
	if (pin >= 14) pin -= 14; // allow for channel or pin numbers
    439e:	8e 30       	cpi	r24, 0x0E	; 14
    43a0:	08 f0       	brcs	.+2      	; 0x43a4 <analogRead+0x6>
    43a2:	8e 50       	subi	r24, 0x0E	; 14
	// to 0 (the default).
#if defined(ADMUX)
#if defined(__AVR_ATtiny25__) || defined(__AVR_ATtiny45__) || defined(__AVR_ATtiny85__)
	ADMUX = (analog_reference << 4) | (pin & 0x07);
#else
	ADMUX = (analog_reference << 6) | (pin & 0x07);
    43a4:	20 91 41 01 	lds	r18, 0x0141	; 0x800141 <analog_reference>
    43a8:	90 e4       	ldi	r25, 0x40	; 64
    43aa:	29 9f       	mul	r18, r25
    43ac:	90 01       	movw	r18, r0
    43ae:	11 24       	eor	r1, r1
    43b0:	87 70       	andi	r24, 0x07	; 7
    43b2:	82 2b       	or	r24, r18
    43b4:	80 93 7c 00 	sts	0x007C, r24	; 0x80007c <__DATA_REGION_ORIGIN__+0x1c>
	// without a delay, we seem to read from the wrong channel
	//delay(1);

#if defined(ADCSRA) && defined(ADCL)
	// start the conversion
	sbi(ADCSRA, ADSC);
    43b8:	80 91 7a 00 	lds	r24, 0x007A	; 0x80007a <__DATA_REGION_ORIGIN__+0x1a>
    43bc:	80 64       	ori	r24, 0x40	; 64
    43be:	80 93 7a 00 	sts	0x007A, r24	; 0x80007a <__DATA_REGION_ORIGIN__+0x1a>

	// ADSC is cleared when the conversion finishes
	while (bit_is_set(ADCSRA, ADSC));
    43c2:	80 91 7a 00 	lds	r24, 0x007A	; 0x80007a <__DATA_REGION_ORIGIN__+0x1a>
    43c6:	86 fd       	sbrc	r24, 6
    43c8:	fc cf       	rjmp	.-8      	; 0x43c2 <analogRead+0x24>

	// we have to read ADCL first; doing so locks both ADCL
	// and ADCH until ADCH is read.  reading ADCL second would
	// cause the results of each conversion to be discarded,
	// as ADCL and ADCH would be locked when it completed.
	low  = ADCL;
    43ca:	80 91 78 00 	lds	r24, 0x0078	; 0x800078 <__DATA_REGION_ORIGIN__+0x18>
	high = ADCH;
    43ce:	20 91 79 00 	lds	r18, 0x0079	; 0x800079 <__DATA_REGION_ORIGIN__+0x19>
	low  = 0;
	high = 0;
#endif

	// combine the two bytes
	return (high << 8) | low;
    43d2:	90 e0       	ldi	r25, 0x00	; 0
}
    43d4:	92 2b       	or	r25, r18
    43d6:	08 95       	ret

000043d8 <analogWrite>:
// Right now, PWM output only works on the pins with
// hardware support.  These are defined in the appropriate
// pins_*.c file.  For the rest of the pins, we default
// to digital output.
void analogWrite(uint8_t pin, int val)
{
    43d8:	1f 93       	push	r17
    43da:	cf 93       	push	r28
    43dc:	df 93       	push	r29
    43de:	18 2f       	mov	r17, r24
    43e0:	eb 01       	movw	r28, r22
	// We need to make sure the PWM output is enabled for those pins
	// that support it, as we turn it off when digitally reading or
	// writing with them.  Also, make sure the pin is in output mode
	// for consistenty with Wiring, which doesn't require a pinMode
	// call for the analog output pins.
	pinMode(pin, OUTPUT);
    43e2:	61 e0       	ldi	r22, 0x01	; 1
    43e4:	0e 94 74 22 	call	0x44e8	; 0x44e8 <pinMode>
	if (val == 0)
    43e8:	20 97       	sbiw	r28, 0x00	; 0
    43ea:	11 f4       	brne	.+4      	; 0x43f0 <analogWrite+0x18>
	{
		digitalWrite(pin, LOW);
    43ec:	60 e0       	ldi	r22, 0x00	; 0
    43ee:	04 c0       	rjmp	.+8      	; 0x43f8 <analogWrite+0x20>
	}
	else if (val == 255)
    43f0:	cf 3f       	cpi	r28, 0xFF	; 255
    43f2:	d1 05       	cpc	r29, r1
    43f4:	39 f4       	brne	.+14     	; 0x4404 <analogWrite+0x2c>
	{
		digitalWrite(pin, HIGH);
    43f6:	61 e0       	ldi	r22, 0x01	; 1
    43f8:	81 2f       	mov	r24, r17
				} else {
					digitalWrite(pin, HIGH);
				}
		}
	}
}
    43fa:	df 91       	pop	r29
    43fc:	cf 91       	pop	r28
    43fe:	1f 91       	pop	r17
	{
		digitalWrite(pin, LOW);
	}
	else if (val == 255)
	{
		digitalWrite(pin, HIGH);
    4400:	0c 94 b0 22 	jmp	0x4560	; 0x4560 <digitalWrite>
	}
	else
	{
		switch(digitalPinToTimer(pin))
    4404:	e1 2f       	mov	r30, r17
    4406:	f0 e0       	ldi	r31, 0x00	; 0
    4408:	ee 54       	subi	r30, 0x4E	; 78
    440a:	ff 4f       	sbci	r31, 0xFF	; 255
    440c:	e4 91       	lpm	r30, Z
    440e:	e3 30       	cpi	r30, 0x03	; 3
    4410:	f9 f0       	breq	.+62     	; 0x4450 <analogWrite+0x78>
    4412:	48 f4       	brcc	.+18     	; 0x4426 <analogWrite+0x4e>
    4414:	e1 30       	cpi	r30, 0x01	; 1
    4416:	b9 f0       	breq	.+46     	; 0x4446 <analogWrite+0x6e>
    4418:	e2 30       	cpi	r30, 0x02	; 2
    441a:	a1 f5       	brne	.+104    	; 0x4484 <analogWrite+0xac>
			#endif

			#if defined(TCCR0A) && defined(COM0B1)
			case TIMER0B:
				// connect pwm to pin on timer 0, channel B
				sbi(TCCR0A, COM0B1);
    441c:	84 b5       	in	r24, 0x24	; 36
    441e:	80 62       	ori	r24, 0x20	; 32
    4420:	84 bd       	out	0x24, r24	; 36
				OCR0B = val; // set pwm duty
    4422:	c8 bd       	out	0x28, r28	; 40
				break;
    4424:	34 c0       	rjmp	.+104    	; 0x448e <analogWrite+0xb6>
	{
		digitalWrite(pin, HIGH);
	}
	else
	{
		switch(digitalPinToTimer(pin))
    4426:	e7 30       	cpi	r30, 0x07	; 7
    4428:	e9 f0       	breq	.+58     	; 0x4464 <analogWrite+0x8c>
    442a:	e8 30       	cpi	r30, 0x08	; 8
    442c:	19 f1       	breq	.+70     	; 0x4474 <analogWrite+0x9c>
    442e:	e4 30       	cpi	r30, 0x04	; 4
    4430:	49 f5       	brne	.+82     	; 0x4484 <analogWrite+0xac>
			#endif

			#if defined(TCCR1A) && defined(COM1B1)
			case TIMER1B:
				// connect pwm to pin on timer 1, channel B
				sbi(TCCR1A, COM1B1);
    4432:	80 91 80 00 	lds	r24, 0x0080	; 0x800080 <__DATA_REGION_ORIGIN__+0x20>
    4436:	80 62       	ori	r24, 0x20	; 32
    4438:	80 93 80 00 	sts	0x0080, r24	; 0x800080 <__DATA_REGION_ORIGIN__+0x20>
				OCR1B = val; // set pwm duty
    443c:	d0 93 8b 00 	sts	0x008B, r29	; 0x80008b <__DATA_REGION_ORIGIN__+0x2b>
    4440:	c0 93 8a 00 	sts	0x008A, r28	; 0x80008a <__DATA_REGION_ORIGIN__+0x2a>
				break;
    4444:	24 c0       	rjmp	.+72     	; 0x448e <analogWrite+0xb6>
			#endif

			#if defined(TCCR0A) && defined(COM0A1)
			case TIMER0A:
				// connect pwm to pin on timer 0, channel A
				sbi(TCCR0A, COM0A1);
    4446:	84 b5       	in	r24, 0x24	; 36
    4448:	80 68       	ori	r24, 0x80	; 128
    444a:	84 bd       	out	0x24, r24	; 36
				OCR0A = val; // set pwm duty
    444c:	c7 bd       	out	0x27, r28	; 39
				break;
    444e:	1f c0       	rjmp	.+62     	; 0x448e <analogWrite+0xb6>
			#endif

			#if defined(TCCR1A) && defined(COM1A1)
			case TIMER1A:
				// connect pwm to pin on timer 1, channel A
				sbi(TCCR1A, COM1A1);
    4450:	80 91 80 00 	lds	r24, 0x0080	; 0x800080 <__DATA_REGION_ORIGIN__+0x20>
    4454:	80 68       	ori	r24, 0x80	; 128
    4456:	80 93 80 00 	sts	0x0080, r24	; 0x800080 <__DATA_REGION_ORIGIN__+0x20>
				OCR1A = val; // set pwm duty
    445a:	d0 93 89 00 	sts	0x0089, r29	; 0x800089 <__DATA_REGION_ORIGIN__+0x29>
    445e:	c0 93 88 00 	sts	0x0088, r28	; 0x800088 <__DATA_REGION_ORIGIN__+0x28>
				break;
    4462:	15 c0       	rjmp	.+42     	; 0x448e <analogWrite+0xb6>
			#endif

			#if defined(TCCR2A) && defined(COM2A1)
			case TIMER2A:
				// connect pwm to pin on timer 2, channel A
				sbi(TCCR2A, COM2A1);
    4464:	80 91 b0 00 	lds	r24, 0x00B0	; 0x8000b0 <__DATA_REGION_ORIGIN__+0x50>
    4468:	80 68       	ori	r24, 0x80	; 128
    446a:	80 93 b0 00 	sts	0x00B0, r24	; 0x8000b0 <__DATA_REGION_ORIGIN__+0x50>
				OCR2A = val; // set pwm duty
    446e:	c0 93 b3 00 	sts	0x00B3, r28	; 0x8000b3 <__DATA_REGION_ORIGIN__+0x53>
				break;
    4472:	0d c0       	rjmp	.+26     	; 0x448e <analogWrite+0xb6>
			#endif

			#if defined(TCCR2A) && defined(COM2B1)
			case TIMER2B:
				// connect pwm to pin on timer 2, channel B
				sbi(TCCR2A, COM2B1);
    4474:	80 91 b0 00 	lds	r24, 0x00B0	; 0x8000b0 <__DATA_REGION_ORIGIN__+0x50>
    4478:	80 62       	ori	r24, 0x20	; 32
    447a:	80 93 b0 00 	sts	0x00B0, r24	; 0x8000b0 <__DATA_REGION_ORIGIN__+0x50>
				OCR2B = val; // set pwm duty
    447e:	c0 93 b4 00 	sts	0x00B4, r28	; 0x8000b4 <__DATA_REGION_ORIGIN__+0x54>
				break;
    4482:	05 c0       	rjmp	.+10     	; 0x448e <analogWrite+0xb6>
				break;
			#endif

			case NOT_ON_TIMER:
			default:
				if (val < 128) {
    4484:	c0 38       	cpi	r28, 0x80	; 128
    4486:	d1 05       	cpc	r29, r1
    4488:	0c f0       	brlt	.+2      	; 0x448c <analogWrite+0xb4>
    448a:	b5 cf       	rjmp	.-150    	; 0x43f6 <analogWrite+0x1e>
    448c:	af cf       	rjmp	.-162    	; 0x43ec <analogWrite+0x14>
				} else {
					digitalWrite(pin, HIGH);
				}
		}
	}
}
    448e:	df 91       	pop	r29
    4490:	cf 91       	pop	r28
    4492:	1f 91       	pop	r17
    4494:	08 95       	ret

00004496 <turnOffPWM>:
//
//static inline void turnOffPWM(uint8_t timer) __attribute__ ((always_inline));
//static inline void turnOffPWM(uint8_t timer)
static void turnOffPWM(uint8_t timer)
{
	switch (timer)
    4496:	83 30       	cpi	r24, 0x03	; 3
    4498:	81 f0       	breq	.+32     	; 0x44ba <turnOffPWM+0x24>
    449a:	28 f4       	brcc	.+10     	; 0x44a6 <turnOffPWM+0x10>
    449c:	81 30       	cpi	r24, 0x01	; 1
    449e:	99 f0       	breq	.+38     	; 0x44c6 <turnOffPWM+0x30>
    44a0:	82 30       	cpi	r24, 0x02	; 2
    44a2:	a1 f0       	breq	.+40     	; 0x44cc <turnOffPWM+0x36>
    44a4:	08 95       	ret
    44a6:	87 30       	cpi	r24, 0x07	; 7
    44a8:	a9 f0       	breq	.+42     	; 0x44d4 <turnOffPWM+0x3e>
    44aa:	88 30       	cpi	r24, 0x08	; 8
    44ac:	b9 f0       	breq	.+46     	; 0x44dc <turnOffPWM+0x46>
    44ae:	84 30       	cpi	r24, 0x04	; 4
    44b0:	d1 f4       	brne	.+52     	; 0x44e6 <turnOffPWM+0x50>
	{
		#if defined(TCCR1A) && defined(COM1A1)
		case TIMER1A:   cbi(TCCR1A, COM1A1);    break;
		#endif
		#if defined(TCCR1A) && defined(COM1B1)
		case TIMER1B:   cbi(TCCR1A, COM1B1);    break;
    44b2:	80 91 80 00 	lds	r24, 0x0080	; 0x800080 <__DATA_REGION_ORIGIN__+0x20>
    44b6:	8f 7d       	andi	r24, 0xDF	; 223
    44b8:	03 c0       	rjmp	.+6      	; 0x44c0 <turnOffPWM+0x2a>
static void turnOffPWM(uint8_t timer)
{
	switch (timer)
	{
		#if defined(TCCR1A) && defined(COM1A1)
		case TIMER1A:   cbi(TCCR1A, COM1A1);    break;
    44ba:	80 91 80 00 	lds	r24, 0x0080	; 0x800080 <__DATA_REGION_ORIGIN__+0x20>
    44be:	8f 77       	andi	r24, 0x7F	; 127
		#endif
		#if defined(TCCR1A) && defined(COM1B1)
		case TIMER1B:   cbi(TCCR1A, COM1B1);    break;
    44c0:	80 93 80 00 	sts	0x0080, r24	; 0x800080 <__DATA_REGION_ORIGIN__+0x20>
    44c4:	08 95       	ret
		#if defined(TCCR2) && defined(COM21)
		case  TIMER2:   cbi(TCCR2, COM21);      break;
		#endif
		
		#if defined(TCCR0A) && defined(COM0A1)
		case  TIMER0A:  cbi(TCCR0A, COM0A1);    break;
    44c6:	84 b5       	in	r24, 0x24	; 36
    44c8:	8f 77       	andi	r24, 0x7F	; 127
    44ca:	02 c0       	rjmp	.+4      	; 0x44d0 <turnOffPWM+0x3a>
		#endif
		
		#if defined(TCCR0A) && defined(COM0B1)
		case  TIMER0B:  cbi(TCCR0A, COM0B1);    break;
    44cc:	84 b5       	in	r24, 0x24	; 36
    44ce:	8f 7d       	andi	r24, 0xDF	; 223
    44d0:	84 bd       	out	0x24, r24	; 36
    44d2:	08 95       	ret
		#endif
		#if defined(TCCR2A) && defined(COM2A1)
		case  TIMER2A:  cbi(TCCR2A, COM2A1);    break;
    44d4:	80 91 b0 00 	lds	r24, 0x00B0	; 0x8000b0 <__DATA_REGION_ORIGIN__+0x50>
    44d8:	8f 77       	andi	r24, 0x7F	; 127
    44da:	03 c0       	rjmp	.+6      	; 0x44e2 <turnOffPWM+0x4c>
		#endif
		#if defined(TCCR2A) && defined(COM2B1)
		case  TIMER2B:  cbi(TCCR2A, COM2B1);    break;
    44dc:	80 91 b0 00 	lds	r24, 0x00B0	; 0x8000b0 <__DATA_REGION_ORIGIN__+0x50>
    44e0:	8f 7d       	andi	r24, 0xDF	; 223
    44e2:	80 93 b0 00 	sts	0x00B0, r24	; 0x8000b0 <__DATA_REGION_ORIGIN__+0x50>
    44e6:	08 95       	ret

000044e8 <pinMode>:
#define ARDUINO_MAIN
#include "wiring_private.h"
#include "pins_arduino.h"

void pinMode(uint8_t pin, uint8_t mode)
{
    44e8:	cf 93       	push	r28
    44ea:	df 93       	push	r29
	uint8_t bit = digitalPinToBitMask(pin);
    44ec:	90 e0       	ldi	r25, 0x00	; 0
    44ee:	fc 01       	movw	r30, r24
    44f0:	ea 53       	subi	r30, 0x3A	; 58
    44f2:	ff 4f       	sbci	r31, 0xFF	; 255
    44f4:	24 91       	lpm	r18, Z
	uint8_t port = digitalPinToPort(pin);
    44f6:	fc 01       	movw	r30, r24
    44f8:	e6 52       	subi	r30, 0x26	; 38
    44fa:	ff 4f       	sbci	r31, 0xFF	; 255
    44fc:	84 91       	lpm	r24, Z
	volatile uint8_t *reg, *out;

	if (port == NOT_A_PIN) return;
    44fe:	88 23       	and	r24, r24
    4500:	61 f1       	breq	.+88     	; 0x455a <pinMode+0x72>

	// JWS: can I let the optimizer do this?
	reg = portModeRegister(port);
    4502:	90 e0       	ldi	r25, 0x00	; 0
    4504:	88 0f       	add	r24, r24
    4506:	99 1f       	adc	r25, r25
    4508:	fc 01       	movw	r30, r24
    450a:	ee 5f       	subi	r30, 0xFE	; 254
    450c:	fe 4f       	sbci	r31, 0xFE	; 254
    450e:	c5 91       	lpm	r28, Z+
    4510:	d4 91       	lpm	r29, Z
	out = portOutputRegister(port);
    4512:	fc 01       	movw	r30, r24
    4514:	e8 50       	subi	r30, 0x08	; 8
    4516:	ff 4f       	sbci	r31, 0xFF	; 255
    4518:	a5 91       	lpm	r26, Z+
    451a:	b4 91       	lpm	r27, Z

	if (mode == INPUT) { 
    451c:	61 11       	cpse	r22, r1
    451e:	09 c0       	rjmp	.+18     	; 0x4532 <pinMode+0x4a>
		uint8_t oldSREG = SREG;
    4520:	9f b7       	in	r25, 0x3f	; 63
                cli();
    4522:	f8 94       	cli
		*reg &= ~bit;
    4524:	88 81       	ld	r24, Y
    4526:	20 95       	com	r18
    4528:	82 23       	and	r24, r18
    452a:	88 83       	st	Y, r24
		*out &= ~bit;
    452c:	ec 91       	ld	r30, X
    452e:	2e 23       	and	r18, r30
    4530:	0b c0       	rjmp	.+22     	; 0x4548 <pinMode+0x60>
		SREG = oldSREG;
	} else if (mode == INPUT_PULLUP) {
    4532:	62 30       	cpi	r22, 0x02	; 2
    4534:	61 f4       	brne	.+24     	; 0x454e <pinMode+0x66>
		uint8_t oldSREG = SREG;
    4536:	9f b7       	in	r25, 0x3f	; 63
                cli();
    4538:	f8 94       	cli
		*reg &= ~bit;
    453a:	88 81       	ld	r24, Y
    453c:	32 2f       	mov	r19, r18
    453e:	30 95       	com	r19
    4540:	83 23       	and	r24, r19
    4542:	88 83       	st	Y, r24
		*out |= bit;
    4544:	ec 91       	ld	r30, X
    4546:	2e 2b       	or	r18, r30
    4548:	2c 93       	st	X, r18
		SREG = oldSREG;
    454a:	9f bf       	out	0x3f, r25	; 63
    454c:	06 c0       	rjmp	.+12     	; 0x455a <pinMode+0x72>
	} else {
		uint8_t oldSREG = SREG;
    454e:	8f b7       	in	r24, 0x3f	; 63
                cli();
    4550:	f8 94       	cli
		*reg |= bit;
    4552:	e8 81       	ld	r30, Y
    4554:	2e 2b       	or	r18, r30
    4556:	28 83       	st	Y, r18
		SREG = oldSREG;
    4558:	8f bf       	out	0x3f, r24	; 63
	}
}
    455a:	df 91       	pop	r29
    455c:	cf 91       	pop	r28
    455e:	08 95       	ret

00004560 <digitalWrite>:
		#endif
	}
}

void digitalWrite(uint8_t pin, uint8_t val)
{
    4560:	1f 93       	push	r17
    4562:	cf 93       	push	r28
    4564:	df 93       	push	r29
	uint8_t timer = digitalPinToTimer(pin);
    4566:	28 2f       	mov	r18, r24
    4568:	30 e0       	ldi	r19, 0x00	; 0
    456a:	f9 01       	movw	r30, r18
    456c:	ee 54       	subi	r30, 0x4E	; 78
    456e:	ff 4f       	sbci	r31, 0xFF	; 255
    4570:	84 91       	lpm	r24, Z
	uint8_t bit = digitalPinToBitMask(pin);
    4572:	f9 01       	movw	r30, r18
    4574:	ea 53       	subi	r30, 0x3A	; 58
    4576:	ff 4f       	sbci	r31, 0xFF	; 255
    4578:	d4 91       	lpm	r29, Z
	uint8_t port = digitalPinToPort(pin);
    457a:	f9 01       	movw	r30, r18
    457c:	e6 52       	subi	r30, 0x26	; 38
    457e:	ff 4f       	sbci	r31, 0xFF	; 255
    4580:	c4 91       	lpm	r28, Z
	volatile uint8_t *out;

	if (port == NOT_A_PIN) return;
    4582:	cc 23       	and	r28, r28
    4584:	c1 f0       	breq	.+48     	; 0x45b6 <digitalWrite+0x56>
    4586:	16 2f       	mov	r17, r22

	// If the pin that support PWM output, we need to turn it off
	// before doing a digital write.
	if (timer != NOT_ON_TIMER) turnOffPWM(timer);
    4588:	81 11       	cpse	r24, r1
    458a:	0e 94 4b 22 	call	0x4496	; 0x4496 <turnOffPWM>

	out = portOutputRegister(port);
    458e:	ec 2f       	mov	r30, r28
    4590:	f0 e0       	ldi	r31, 0x00	; 0
    4592:	ee 0f       	add	r30, r30
    4594:	ff 1f       	adc	r31, r31
    4596:	e8 50       	subi	r30, 0x08	; 8
    4598:	ff 4f       	sbci	r31, 0xFF	; 255
    459a:	a5 91       	lpm	r26, Z+
    459c:	b4 91       	lpm	r27, Z

	uint8_t oldSREG = SREG;
    459e:	9f b7       	in	r25, 0x3f	; 63
	cli();
    45a0:	f8 94       	cli

	if (val == LOW) {
    45a2:	11 11       	cpse	r17, r1
    45a4:	04 c0       	rjmp	.+8      	; 0x45ae <digitalWrite+0x4e>
		*out &= ~bit;
    45a6:	8c 91       	ld	r24, X
    45a8:	d0 95       	com	r29
    45aa:	d8 23       	and	r29, r24
    45ac:	02 c0       	rjmp	.+4      	; 0x45b2 <digitalWrite+0x52>
	} else {
		*out |= bit;
    45ae:	ec 91       	ld	r30, X
    45b0:	de 2b       	or	r29, r30
    45b2:	dc 93       	st	X, r29
	}

	SREG = oldSREG;
    45b4:	9f bf       	out	0x3f, r25	; 63
}
    45b6:	df 91       	pop	r29
    45b8:	cf 91       	pop	r28
    45ba:	1f 91       	pop	r17
    45bc:	08 95       	ret

000045be <_ZN14FreqCountClass5beginEj>:
static uint16_t gate_index;


void FreqCountClass::begin(uint16_t msec)
{
	if (msec < 1) return;
    45be:	00 97       	sbiw	r24, 0x00	; 0
    45c0:	09 f4       	brne	.+2      	; 0x45c4 <_ZN14FreqCountClass5beginEj+0x6>
    45c2:	74 c0       	rjmp	.+232    	; 0x46ac <L_130_loop+0xc>
	gate_index = 0;
    45c4:	10 92 fb 04 	sts	0x04FB, r1	; 0x8004fb <_ZL10gate_index+0x1>
    45c8:	10 92 fa 04 	sts	0x04FA, r1	; 0x8004fa <_ZL10gate_index>
	count_msw = 0;
    45cc:	10 92 08 05 	sts	0x0508, r1	; 0x800508 <_ZL9count_msw+0x1>
    45d0:	10 92 07 05 	sts	0x0507, r1	; 0x800507 <_ZL9count_msw>
	count_prev = 0;
    45d4:	10 92 03 05 	sts	0x0503, r1	; 0x800503 <_ZL10count_prev>
    45d8:	10 92 04 05 	sts	0x0504, r1	; 0x800504 <_ZL10count_prev+0x1>
    45dc:	10 92 05 05 	sts	0x0505, r1	; 0x800505 <_ZL10count_prev+0x2>
    45e0:	10 92 06 05 	sts	0x0506, r1	; 0x800506 <_ZL10count_prev+0x3>
	count_ready = 0;
    45e4:	10 92 fe 04 	sts	0x04FE, r1	; 0x8004fe <_ZL11count_ready>

static uint8_t saveTCCR1A, saveTCCR1B;

static inline void counter_init(void)
{
	saveTCCR1A = TCCR1A;
    45e8:	20 91 80 00 	lds	r18, 0x0080	; 0x800080 <__DATA_REGION_ORIGIN__+0x20>
    45ec:	20 93 0d 05 	sts	0x050D, r18	; 0x80050d <_ZL10saveTCCR1A>
	saveTCCR1B = TCCR1B;
    45f0:	20 91 81 00 	lds	r18, 0x0081	; 0x800081 <__DATA_REGION_ORIGIN__+0x21>
    45f4:	20 93 0c 05 	sts	0x050C, r18	; 0x80050c <_ZL10saveTCCR1B>
	TCCR1B = 0;
    45f8:	10 92 81 00 	sts	0x0081, r1	; 0x800081 <__DATA_REGION_ORIGIN__+0x21>
	TCCR1A = 0;
    45fc:	10 92 80 00 	sts	0x0080, r1	; 0x800080 <__DATA_REGION_ORIGIN__+0x20>
	TCNT1 = 0;
    4600:	10 92 85 00 	sts	0x0085, r1	; 0x800085 <__DATA_REGION_ORIGIN__+0x25>
    4604:	10 92 84 00 	sts	0x0084, r1	; 0x800084 <__DATA_REGION_ORIGIN__+0x24>
	TIFR1 = (1<<TOV1);
    4608:	21 e0       	ldi	r18, 0x01	; 1
    460a:	26 bb       	out	0x16, r18	; 22
	TIMSK1 = 0;
    460c:	10 92 6f 00 	sts	0x006F, r1	; 0x80006f <__DATA_REGION_ORIGIN__+0xf>

static inline uint16_t timer_init(uint16_t msec)
{
	uint16_t gate_len;

	saveTCCR2A = TCCR2A;
    4610:	20 91 b0 00 	lds	r18, 0x00B0	; 0x8000b0 <__DATA_REGION_ORIGIN__+0x50>
    4614:	20 93 0b 05 	sts	0x050B, r18	; 0x80050b <_ZL10saveTCCR2A>
	saveTCCR2B = TCCR2B;
    4618:	20 91 b1 00 	lds	r18, 0x00B1	; 0x8000b1 <__DATA_REGION_ORIGIN__+0x51>
    461c:	20 93 0a 05 	sts	0x050A, r18	; 0x80050a <_ZL10saveTCCR2B>
	TCCR2B = 0;
    4620:	10 92 b1 00 	sts	0x00B1, r1	; 0x8000b1 <__DATA_REGION_ORIGIN__+0x51>
	TCCR2A = (1<<WGM21);
    4624:	22 e0       	ldi	r18, 0x02	; 2
    4626:	20 93 b0 00 	sts	0x00B0, r18	; 0x8000b0 <__DATA_REGION_ORIGIN__+0x50>
	if ((msec & 7) == 0) {
    462a:	9c 01       	movw	r18, r24
    462c:	27 70       	andi	r18, 0x07	; 7
    462e:	33 27       	eor	r19, r19
    4630:	23 2b       	or	r18, r19
    4632:	51 f4       	brne	.+20     	; 0x4648 <_ZN14FreqCountClass5beginEj+0x8a>
		gate_len = msec >> 3;
    4634:	43 e0       	ldi	r20, 0x03	; 3
    4636:	96 95       	lsr	r25
    4638:	87 95       	ror	r24
    463a:	4a 95       	dec	r20
    463c:	e1 f7       	brne	.-8      	; 0x4636 <_ZN14FreqCountClass5beginEj+0x78>
		OCR2A = TIMER2_OCR2A_8MS_VAL;
    463e:	2c e7       	ldi	r18, 0x7C	; 124
    4640:	20 93 b3 00 	sts	0x00B3, r18	; 0x8000b3 <__DATA_REGION_ORIGIN__+0x53>
		startTCCR2B = TIMER2_TCCR2B_8MS_VAL;
    4644:	27 e0       	ldi	r18, 0x07	; 7
    4646:	18 c0       	rjmp	.+48     	; 0x4678 <_ZN14FreqCountClass5beginEj+0xba>
	} else if ((msec & 3) == 0) {
    4648:	9c 01       	movw	r18, r24
    464a:	23 70       	andi	r18, 0x03	; 3
    464c:	33 27       	eor	r19, r19
    464e:	23 2b       	or	r18, r19
    4650:	31 f4       	brne	.+12     	; 0x465e <_ZN14FreqCountClass5beginEj+0xa0>
		gate_len = msec >> 2;
    4652:	96 95       	lsr	r25
    4654:	87 95       	ror	r24
    4656:	96 95       	lsr	r25
    4658:	87 95       	ror	r24
		OCR2A = TIMER2_OCR2A_4MS_VAL;
    465a:	29 ef       	ldi	r18, 0xF9	; 249
    465c:	05 c0       	rjmp	.+10     	; 0x4668 <_ZN14FreqCountClass5beginEj+0xaa>
		startTCCR2B = TIMER2_TCCR2B_4MS_VAL;
	} else if ((msec & 1) == 0) {
    465e:	80 fd       	sbrc	r24, 0
    4660:	07 c0       	rjmp	.+14     	; 0x4670 <_ZN14FreqCountClass5beginEj+0xb2>
		gate_len = msec >> 1;
    4662:	96 95       	lsr	r25
    4664:	87 95       	ror	r24
		OCR2A = TIMER2_OCR2A_2MS_VAL;
    4666:	2c e7       	ldi	r18, 0x7C	; 124
    4668:	20 93 b3 00 	sts	0x00B3, r18	; 0x8000b3 <__DATA_REGION_ORIGIN__+0x53>
		startTCCR2B = TIMER2_TCCR2B_2MS_VAL;
    466c:	26 e0       	ldi	r18, 0x06	; 6
    466e:	04 c0       	rjmp	.+8      	; 0x4678 <_ZN14FreqCountClass5beginEj+0xba>
	} else {
		gate_len = msec;
		OCR2A = TIMER2_OCR2A_1MS_VAL;
    4670:	2c e7       	ldi	r18, 0x7C	; 124
    4672:	20 93 b3 00 	sts	0x00B3, r18	; 0x8000b3 <__DATA_REGION_ORIGIN__+0x53>
		startTCCR2B = TIMER2_TCCR2B_1MS_VAL;
    4676:	25 e0       	ldi	r18, 0x05	; 5
    4678:	20 93 09 05 	sts	0x0509, r18	; 0x800509 <_ZL11startTCCR2B>
	}
	TIFR2 = (1<<OCF2A);
    467c:	22 e0       	ldi	r18, 0x02	; 2
    467e:	27 bb       	out	0x17, r18	; 23
	TCNT2 = 0;
    4680:	10 92 b2 00 	sts	0x00B2, r1	; 0x8000b2 <__DATA_REGION_ORIGIN__+0x52>
	counter_init();
	gate_length = timer_init(msec);
    4684:	90 93 fd 04 	sts	0x04FD, r25	; 0x8004fd <_ZL11gate_length+0x1>
    4688:	80 93 fc 04 	sts	0x04FC, r24	; 0x8004fc <_ZL11gate_length>
	uint8_t status = SREG;
    468c:	9f b7       	in	r25, 0x3f	; 63
	cli();
    468e:	f8 94       	cli
	return gate_len;
}

static inline void timer_start(void)
{
	GTCCR = (1<<PSRASY);
    4690:	23 bd       	out	0x23, r18	; 35
	TCCR2B = startTCCR2B;
    4692:	80 91 09 05 	lds	r24, 0x0509	; 0x800509 <_ZL11startTCCR2B>
    4696:	80 93 b1 00 	sts	0x00B1, r24	; 0x8000b1 <__DATA_REGION_ORIGIN__+0x51>
	TIMSK2 = (1<<OCIE2A);
    469a:	20 93 70 00 	sts	0x0070, r18	; 0x800070 <__DATA_REGION_ORIGIN__+0x10>
		"L_%=_loop:"
		"subi   %0, 1"		"\n\t"
		"brne   L_%=_loop"	"\n\t"
		: "+d" (cycles_times_3)
		: "0" (cycles_times_3)
	);
    469e:	8b e0       	ldi	r24, 0x0B	; 11

000046a0 <L_130_loop>:
    46a0:	81 50       	subi	r24, 0x01	; 1
    46a2:	f1 f7       	brne	.-4      	; 0x46a0 <L_130_loop>
	TIMSK1 = 0;
}

static inline void counter_start(void)
{
	TCCR1B = (1<<CS12) | (1<<CS11) | (1<<CS10);
    46a4:	87 e0       	ldi	r24, 0x07	; 7
    46a6:	80 93 81 00 	sts	0x0081, r24	; 0x800081 <__DATA_REGION_ORIGIN__+0x21>
	timer_start();
	timer_isr_latency_delay();
	counter_start();
	SREG = status;
    46aa:	9f bf       	out	0x3f, r25	; 63
    46ac:	08 95       	ret

000046ae <_ZN14FreqCountClass9availableEv>:
}

uint8_t FreqCountClass::available(void)
{
	return count_ready;
    46ae:	80 91 fe 04 	lds	r24, 0x04FE	; 0x8004fe <_ZL11count_ready>
}
    46b2:	08 95       	ret

000046b4 <_ZN14FreqCountClass4readEv>:
uint32_t FreqCountClass::read(void)
{
	uint32_t count;
	uint8_t status;

	status = SREG;
    46b4:	2f b7       	in	r18, 0x3f	; 63
	cli();
    46b6:	f8 94       	cli
	count = count_output;
    46b8:	60 91 ff 04 	lds	r22, 0x04FF	; 0x8004ff <_ZL12count_output>
    46bc:	70 91 00 05 	lds	r23, 0x0500	; 0x800500 <_ZL12count_output+0x1>
    46c0:	80 91 01 05 	lds	r24, 0x0501	; 0x800501 <_ZL12count_output+0x2>
    46c4:	90 91 02 05 	lds	r25, 0x0502	; 0x800502 <_ZL12count_output+0x3>
	count_ready = 0;
    46c8:	10 92 fe 04 	sts	0x04FE, r1	; 0x8004fe <_ZL11count_ready>
	SREG = status;
    46cc:	2f bf       	out	0x3f, r18	; 63
	return count;
}
    46ce:	08 95       	ret

000046d0 <_ZN14FreqCountClass3endEv>:
	TIMSK2 = (1<<OCIE2A);
}

static inline void timer_shutdown(void)
{
	TCCR2B = 0;
    46d0:	e1 eb       	ldi	r30, 0xB1	; 177
    46d2:	f0 e0       	ldi	r31, 0x00	; 0
    46d4:	10 82       	st	Z, r1
	TIMSK2 = 0;
    46d6:	10 92 70 00 	sts	0x0070, r1	; 0x800070 <__DATA_REGION_ORIGIN__+0x10>
	TCCR2A = saveTCCR2A;
    46da:	80 91 0b 05 	lds	r24, 0x050B	; 0x80050b <_ZL10saveTCCR2A>
    46de:	80 93 b0 00 	sts	0x00B0, r24	; 0x8000b0 <__DATA_REGION_ORIGIN__+0x50>
	TCCR2B = saveTCCR2B;
    46e2:	80 91 0a 05 	lds	r24, 0x050A	; 0x80050a <_ZL10saveTCCR2B>
    46e6:	80 83       	st	Z, r24
	TCCR1B = (1<<CS12) | (1<<CS11) | (1<<CS10);
}

static inline void counter_shutdown(void)
{
	TCCR1B = 0;
    46e8:	e1 e8       	ldi	r30, 0x81	; 129
    46ea:	f0 e0       	ldi	r31, 0x00	; 0
    46ec:	10 82       	st	Z, r1
	TCCR1A = saveTCCR1A;
    46ee:	80 91 0d 05 	lds	r24, 0x050D	; 0x80050d <_ZL10saveTCCR1A>
    46f2:	80 93 80 00 	sts	0x0080, r24	; 0x800080 <__DATA_REGION_ORIGIN__+0x20>
	TCCR1B = saveTCCR1B;
    46f6:	80 91 0c 05 	lds	r24, 0x050C	; 0x80050c <_ZL10saveTCCR1B>
    46fa:	80 83       	st	Z, r24
    46fc:	08 95       	ret

000046fe <__vector_7>:
	counter_shutdown();
}


ISR(TIMER_ISR_VECTOR)
{
    46fe:	1f 92       	push	r1
    4700:	0f 92       	push	r0
    4702:	0f b6       	in	r0, 0x3f	; 63
    4704:	0f 92       	push	r0
    4706:	11 24       	eor	r1, r1
    4708:	0f 93       	push	r16
    470a:	1f 93       	push	r17
    470c:	2f 93       	push	r18
    470e:	3f 93       	push	r19
    4710:	4f 93       	push	r20
    4712:	5f 93       	push	r21
    4714:	6f 93       	push	r22
    4716:	7f 93       	push	r23
    4718:	8f 93       	push	r24
    471a:	9f 93       	push	r25
    471c:	af 93       	push	r26
    471e:	bf 93       	push	r27
}

static inline uint16_t counter_read(void)
{
	return TCNT1;
    4720:	20 91 84 00 	lds	r18, 0x0084	; 0x800084 <__DATA_REGION_ORIGIN__+0x24>
    4724:	30 91 85 00 	lds	r19, 0x0085	; 0x800085 <__DATA_REGION_ORIGIN__+0x25>
	uint16_t count_lsw;
	uint32_t count;
	uint16_t index, length;

	count_lsw = counter_read();
	if (counter_overflow()) {
    4728:	b0 9b       	sbis	0x16, 0	; 22
    472a:	0b c0       	rjmp	.+22     	; 0x4742 <__vector_7+0x44>
	return TIFR1 & (1<<TOV1);
}

static inline void counter_overflow_reset(void)
{
	TIFR1 = (1<<TOV1);
    472c:	81 e0       	ldi	r24, 0x01	; 1
    472e:	86 bb       	out	0x16, r24	; 22
		counter_overflow_reset();
		count_msw++;
    4730:	80 91 07 05 	lds	r24, 0x0507	; 0x800507 <_ZL9count_msw>
    4734:	90 91 08 05 	lds	r25, 0x0508	; 0x800508 <_ZL9count_msw+0x1>
    4738:	01 96       	adiw	r24, 0x01	; 1
    473a:	90 93 08 05 	sts	0x0508, r25	; 0x800508 <_ZL9count_msw+0x1>
    473e:	80 93 07 05 	sts	0x0507, r24	; 0x800507 <_ZL9count_msw>
	}
	index = gate_index + 1;
    4742:	80 91 fa 04 	lds	r24, 0x04FA	; 0x8004fa <_ZL10gate_index>
    4746:	90 91 fb 04 	lds	r25, 0x04FB	; 0x8004fb <_ZL10gate_index+0x1>
    474a:	01 96       	adiw	r24, 0x01	; 1
	length = gate_length;
	if (index >= length) {
    474c:	40 91 fc 04 	lds	r20, 0x04FC	; 0x8004fc <_ZL11gate_length>
    4750:	50 91 fd 04 	lds	r21, 0x04FD	; 0x8004fd <_ZL11gate_length+0x1>
    4754:	84 17       	cp	r24, r20
    4756:	95 07       	cpc	r25, r21
    4758:	98 f1       	brcs	.+102    	; 0x47c0 <__vector_7+0xc2>
		gate_index = 0;
    475a:	10 92 fb 04 	sts	0x04FB, r1	; 0x8004fb <_ZL10gate_index+0x1>
    475e:	10 92 fa 04 	sts	0x04FA, r1	; 0x8004fa <_ZL10gate_index>
		count = ((uint32_t)count_msw << 16) + count_lsw;
    4762:	80 91 07 05 	lds	r24, 0x0507	; 0x800507 <_ZL9count_msw>
    4766:	90 91 08 05 	lds	r25, 0x0508	; 0x800508 <_ZL9count_msw+0x1>
    476a:	a0 e0       	ldi	r26, 0x00	; 0
    476c:	b0 e0       	ldi	r27, 0x00	; 0
    476e:	dc 01       	movw	r26, r24
    4770:	99 27       	eor	r25, r25
    4772:	88 27       	eor	r24, r24
    4774:	82 0f       	add	r24, r18
    4776:	93 1f       	adc	r25, r19
    4778:	a1 1d       	adc	r26, r1
    477a:	b1 1d       	adc	r27, r1
		count_output = count - count_prev;
    477c:	40 91 03 05 	lds	r20, 0x0503	; 0x800503 <_ZL10count_prev>
    4780:	50 91 04 05 	lds	r21, 0x0504	; 0x800504 <_ZL10count_prev+0x1>
    4784:	60 91 05 05 	lds	r22, 0x0505	; 0x800505 <_ZL10count_prev+0x2>
    4788:	70 91 06 05 	lds	r23, 0x0506	; 0x800506 <_ZL10count_prev+0x3>
    478c:	8c 01       	movw	r16, r24
    478e:	9d 01       	movw	r18, r26
    4790:	04 1b       	sub	r16, r20
    4792:	15 0b       	sbc	r17, r21
    4794:	26 0b       	sbc	r18, r22
    4796:	37 0b       	sbc	r19, r23
    4798:	00 93 ff 04 	sts	0x04FF, r16	; 0x8004ff <_ZL12count_output>
    479c:	10 93 00 05 	sts	0x0500, r17	; 0x800500 <_ZL12count_output+0x1>
    47a0:	20 93 01 05 	sts	0x0501, r18	; 0x800501 <_ZL12count_output+0x2>
    47a4:	30 93 02 05 	sts	0x0502, r19	; 0x800502 <_ZL12count_output+0x3>
		count_prev = count;
    47a8:	80 93 03 05 	sts	0x0503, r24	; 0x800503 <_ZL10count_prev>
    47ac:	90 93 04 05 	sts	0x0504, r25	; 0x800504 <_ZL10count_prev+0x1>
    47b0:	a0 93 05 05 	sts	0x0505, r26	; 0x800505 <_ZL10count_prev+0x2>
    47b4:	b0 93 06 05 	sts	0x0506, r27	; 0x800506 <_ZL10count_prev+0x3>
		count_ready = 1;
    47b8:	81 e0       	ldi	r24, 0x01	; 1
    47ba:	80 93 fe 04 	sts	0x04FE, r24	; 0x8004fe <_ZL11count_ready>
    47be:	04 c0       	rjmp	.+8      	; 0x47c8 <__vector_7+0xca>
		restore_other_interrupts();
	} else {
		if (index == length - 1) disable_other_interrupts();
		gate_index = index;
    47c0:	90 93 fb 04 	sts	0x04FB, r25	; 0x8004fb <_ZL10gate_index+0x1>
    47c4:	80 93 fa 04 	sts	0x04FA, r24	; 0x8004fa <_ZL10gate_index>
	}
}
    47c8:	bf 91       	pop	r27
    47ca:	af 91       	pop	r26
    47cc:	9f 91       	pop	r25
    47ce:	8f 91       	pop	r24
    47d0:	7f 91       	pop	r23
    47d2:	6f 91       	pop	r22
    47d4:	5f 91       	pop	r21
    47d6:	4f 91       	pop	r20
    47d8:	3f 91       	pop	r19
    47da:	2f 91       	pop	r18
    47dc:	1f 91       	pop	r17
    47de:	0f 91       	pop	r16
    47e0:	0f 90       	pop	r0
    47e2:	0f be       	out	0x3f, r0	; 63
    47e4:	0f 90       	pop	r0
    47e6:	1f 90       	pop	r1
    47e8:	18 95       	reti

000047ea <yield>:
 * libraries or sketches that supports cooperative threads.
 *
 * Its defined as a weak symbol and it can be redefined to implement a
 * real cooperative scheduler.
 */
static void __empty() {
    47ea:	08 95       	ret

000047ec <__divmodhi4>:
    47ec:	97 fb       	bst	r25, 7
    47ee:	07 2e       	mov	r0, r23
    47f0:	16 f4       	brtc	.+4      	; 0x47f6 <__divmodhi4+0xa>
    47f2:	00 94       	com	r0
    47f4:	07 d0       	rcall	.+14     	; 0x4804 <__divmodhi4_neg1>
    47f6:	77 fd       	sbrc	r23, 7
    47f8:	09 d0       	rcall	.+18     	; 0x480c <__divmodhi4_neg2>
    47fa:	0e 94 5c 24 	call	0x48b8	; 0x48b8 <__udivmodhi4>
    47fe:	07 fc       	sbrc	r0, 7
    4800:	05 d0       	rcall	.+10     	; 0x480c <__divmodhi4_neg2>
    4802:	3e f4       	brtc	.+14     	; 0x4812 <__divmodhi4_exit>

00004804 <__divmodhi4_neg1>:
    4804:	90 95       	com	r25
    4806:	81 95       	neg	r24
    4808:	9f 4f       	sbci	r25, 0xFF	; 255
    480a:	08 95       	ret

0000480c <__divmodhi4_neg2>:
    480c:	70 95       	com	r23
    480e:	61 95       	neg	r22
    4810:	7f 4f       	sbci	r23, 0xFF	; 255

00004812 <__divmodhi4_exit>:
    4812:	08 95       	ret

00004814 <__udivmodsi4>:
    4814:	a1 e2       	ldi	r26, 0x21	; 33
    4816:	1a 2e       	mov	r1, r26
    4818:	aa 1b       	sub	r26, r26
    481a:	bb 1b       	sub	r27, r27
    481c:	fd 01       	movw	r30, r26
    481e:	0d c0       	rjmp	.+26     	; 0x483a <__udivmodsi4_ep>

00004820 <__udivmodsi4_loop>:
    4820:	aa 1f       	adc	r26, r26
    4822:	bb 1f       	adc	r27, r27
    4824:	ee 1f       	adc	r30, r30
    4826:	ff 1f       	adc	r31, r31
    4828:	a2 17       	cp	r26, r18
    482a:	b3 07       	cpc	r27, r19
    482c:	e4 07       	cpc	r30, r20
    482e:	f5 07       	cpc	r31, r21
    4830:	20 f0       	brcs	.+8      	; 0x483a <__udivmodsi4_ep>
    4832:	a2 1b       	sub	r26, r18
    4834:	b3 0b       	sbc	r27, r19
    4836:	e4 0b       	sbc	r30, r20
    4838:	f5 0b       	sbc	r31, r21

0000483a <__udivmodsi4_ep>:
    483a:	66 1f       	adc	r22, r22
    483c:	77 1f       	adc	r23, r23
    483e:	88 1f       	adc	r24, r24
    4840:	99 1f       	adc	r25, r25
    4842:	1a 94       	dec	r1
    4844:	69 f7       	brne	.-38     	; 0x4820 <__udivmodsi4_loop>
    4846:	60 95       	com	r22
    4848:	70 95       	com	r23
    484a:	80 95       	com	r24
    484c:	90 95       	com	r25
    484e:	9b 01       	movw	r18, r22
    4850:	ac 01       	movw	r20, r24
    4852:	bd 01       	movw	r22, r26
    4854:	cf 01       	movw	r24, r30
    4856:	08 95       	ret

00004858 <__divmodsi4>:
    4858:	05 2e       	mov	r0, r21
    485a:	97 fb       	bst	r25, 7
    485c:	1e f4       	brtc	.+6      	; 0x4864 <__divmodsi4+0xc>
    485e:	00 94       	com	r0
    4860:	0e 94 43 24 	call	0x4886	; 0x4886 <__negsi2>
    4864:	57 fd       	sbrc	r21, 7
    4866:	07 d0       	rcall	.+14     	; 0x4876 <__divmodsi4_neg2>
    4868:	0e 94 0a 24 	call	0x4814	; 0x4814 <__udivmodsi4>
    486c:	07 fc       	sbrc	r0, 7
    486e:	03 d0       	rcall	.+6      	; 0x4876 <__divmodsi4_neg2>
    4870:	4e f4       	brtc	.+18     	; 0x4884 <__divmodsi4_exit>
    4872:	0c 94 43 24 	jmp	0x4886	; 0x4886 <__negsi2>

00004876 <__divmodsi4_neg2>:
    4876:	50 95       	com	r21
    4878:	40 95       	com	r20
    487a:	30 95       	com	r19
    487c:	21 95       	neg	r18
    487e:	3f 4f       	sbci	r19, 0xFF	; 255
    4880:	4f 4f       	sbci	r20, 0xFF	; 255
    4882:	5f 4f       	sbci	r21, 0xFF	; 255

00004884 <__divmodsi4_exit>:
    4884:	08 95       	ret

00004886 <__negsi2>:
    4886:	90 95       	com	r25
    4888:	80 95       	com	r24
    488a:	70 95       	com	r23
    488c:	61 95       	neg	r22
    488e:	7f 4f       	sbci	r23, 0xFF	; 255
    4890:	8f 4f       	sbci	r24, 0xFF	; 255
    4892:	9f 4f       	sbci	r25, 0xFF	; 255
    4894:	08 95       	ret

00004896 <__tablejump2__>:
    4896:	ee 0f       	add	r30, r30
    4898:	ff 1f       	adc	r31, r31
    489a:	05 90       	lpm	r0, Z+
    489c:	f4 91       	lpm	r31, Z
    489e:	e0 2d       	mov	r30, r0
    48a0:	09 94       	ijmp

000048a2 <__muluhisi3>:
    48a2:	0e 94 70 24 	call	0x48e0	; 0x48e0 <__umulhisi3>
    48a6:	a5 9f       	mul	r26, r21
    48a8:	90 0d       	add	r25, r0
    48aa:	b4 9f       	mul	r27, r20
    48ac:	90 0d       	add	r25, r0
    48ae:	a4 9f       	mul	r26, r20
    48b0:	80 0d       	add	r24, r0
    48b2:	91 1d       	adc	r25, r1
    48b4:	11 24       	eor	r1, r1
    48b6:	08 95       	ret

000048b8 <__udivmodhi4>:
    48b8:	aa 1b       	sub	r26, r26
    48ba:	bb 1b       	sub	r27, r27
    48bc:	51 e1       	ldi	r21, 0x11	; 17
    48be:	07 c0       	rjmp	.+14     	; 0x48ce <__udivmodhi4_ep>

000048c0 <__udivmodhi4_loop>:
    48c0:	aa 1f       	adc	r26, r26
    48c2:	bb 1f       	adc	r27, r27
    48c4:	a6 17       	cp	r26, r22
    48c6:	b7 07       	cpc	r27, r23
    48c8:	10 f0       	brcs	.+4      	; 0x48ce <__udivmodhi4_ep>
    48ca:	a6 1b       	sub	r26, r22
    48cc:	b7 0b       	sbc	r27, r23

000048ce <__udivmodhi4_ep>:
    48ce:	88 1f       	adc	r24, r24
    48d0:	99 1f       	adc	r25, r25
    48d2:	5a 95       	dec	r21
    48d4:	a9 f7       	brne	.-22     	; 0x48c0 <__udivmodhi4_loop>
    48d6:	80 95       	com	r24
    48d8:	90 95       	com	r25
    48da:	bc 01       	movw	r22, r24
    48dc:	cd 01       	movw	r24, r26
    48de:	08 95       	ret

000048e0 <__umulhisi3>:
    48e0:	a2 9f       	mul	r26, r18
    48e2:	b0 01       	movw	r22, r0
    48e4:	b3 9f       	mul	r27, r19
    48e6:	c0 01       	movw	r24, r0
    48e8:	a3 9f       	mul	r26, r19
    48ea:	70 0d       	add	r23, r0
    48ec:	81 1d       	adc	r24, r1
    48ee:	11 24       	eor	r1, r1
    48f0:	91 1d       	adc	r25, r1
    48f2:	b2 9f       	mul	r27, r18
    48f4:	70 0d       	add	r23, r0
    48f6:	81 1d       	adc	r24, r1
    48f8:	11 24       	eor	r1, r1
    48fa:	91 1d       	adc	r25, r1
    48fc:	08 95       	ret

000048fe <malloc>:
    48fe:	0f 93       	push	r16
    4900:	1f 93       	push	r17
    4902:	cf 93       	push	r28
    4904:	df 93       	push	r29
    4906:	82 30       	cpi	r24, 0x02	; 2
    4908:	91 05       	cpc	r25, r1
    490a:	10 f4       	brcc	.+4      	; 0x4910 <malloc+0x12>
    490c:	82 e0       	ldi	r24, 0x02	; 2
    490e:	90 e0       	ldi	r25, 0x00	; 0
    4910:	e0 91 10 05 	lds	r30, 0x0510	; 0x800510 <__flp>
    4914:	f0 91 11 05 	lds	r31, 0x0511	; 0x800511 <__flp+0x1>
    4918:	20 e0       	ldi	r18, 0x00	; 0
    491a:	30 e0       	ldi	r19, 0x00	; 0
    491c:	a0 e0       	ldi	r26, 0x00	; 0
    491e:	b0 e0       	ldi	r27, 0x00	; 0
    4920:	30 97       	sbiw	r30, 0x00	; 0
    4922:	19 f1       	breq	.+70     	; 0x496a <malloc+0x6c>
    4924:	40 81       	ld	r20, Z
    4926:	51 81       	ldd	r21, Z+1	; 0x01
    4928:	02 81       	ldd	r16, Z+2	; 0x02
    492a:	13 81       	ldd	r17, Z+3	; 0x03
    492c:	48 17       	cp	r20, r24
    492e:	59 07       	cpc	r21, r25
    4930:	c8 f0       	brcs	.+50     	; 0x4964 <malloc+0x66>
    4932:	84 17       	cp	r24, r20
    4934:	95 07       	cpc	r25, r21
    4936:	69 f4       	brne	.+26     	; 0x4952 <malloc+0x54>
    4938:	10 97       	sbiw	r26, 0x00	; 0
    493a:	31 f0       	breq	.+12     	; 0x4948 <malloc+0x4a>
    493c:	12 96       	adiw	r26, 0x02	; 2
    493e:	0c 93       	st	X, r16
    4940:	12 97       	sbiw	r26, 0x02	; 2
    4942:	13 96       	adiw	r26, 0x03	; 3
    4944:	1c 93       	st	X, r17
    4946:	27 c0       	rjmp	.+78     	; 0x4996 <malloc+0x98>
    4948:	00 93 10 05 	sts	0x0510, r16	; 0x800510 <__flp>
    494c:	10 93 11 05 	sts	0x0511, r17	; 0x800511 <__flp+0x1>
    4950:	22 c0       	rjmp	.+68     	; 0x4996 <malloc+0x98>
    4952:	21 15       	cp	r18, r1
    4954:	31 05       	cpc	r19, r1
    4956:	19 f0       	breq	.+6      	; 0x495e <malloc+0x60>
    4958:	42 17       	cp	r20, r18
    495a:	53 07       	cpc	r21, r19
    495c:	18 f4       	brcc	.+6      	; 0x4964 <malloc+0x66>
    495e:	9a 01       	movw	r18, r20
    4960:	bd 01       	movw	r22, r26
    4962:	ef 01       	movw	r28, r30
    4964:	df 01       	movw	r26, r30
    4966:	f8 01       	movw	r30, r16
    4968:	db cf       	rjmp	.-74     	; 0x4920 <malloc+0x22>
    496a:	21 15       	cp	r18, r1
    496c:	31 05       	cpc	r19, r1
    496e:	f9 f0       	breq	.+62     	; 0x49ae <malloc+0xb0>
    4970:	28 1b       	sub	r18, r24
    4972:	39 0b       	sbc	r19, r25
    4974:	24 30       	cpi	r18, 0x04	; 4
    4976:	31 05       	cpc	r19, r1
    4978:	80 f4       	brcc	.+32     	; 0x499a <malloc+0x9c>
    497a:	8a 81       	ldd	r24, Y+2	; 0x02
    497c:	9b 81       	ldd	r25, Y+3	; 0x03
    497e:	61 15       	cp	r22, r1
    4980:	71 05       	cpc	r23, r1
    4982:	21 f0       	breq	.+8      	; 0x498c <malloc+0x8e>
    4984:	fb 01       	movw	r30, r22
    4986:	93 83       	std	Z+3, r25	; 0x03
    4988:	82 83       	std	Z+2, r24	; 0x02
    498a:	04 c0       	rjmp	.+8      	; 0x4994 <malloc+0x96>
    498c:	90 93 11 05 	sts	0x0511, r25	; 0x800511 <__flp+0x1>
    4990:	80 93 10 05 	sts	0x0510, r24	; 0x800510 <__flp>
    4994:	fe 01       	movw	r30, r28
    4996:	32 96       	adiw	r30, 0x02	; 2
    4998:	44 c0       	rjmp	.+136    	; 0x4a22 <malloc+0x124>
    499a:	fe 01       	movw	r30, r28
    499c:	e2 0f       	add	r30, r18
    499e:	f3 1f       	adc	r31, r19
    49a0:	81 93       	st	Z+, r24
    49a2:	91 93       	st	Z+, r25
    49a4:	22 50       	subi	r18, 0x02	; 2
    49a6:	31 09       	sbc	r19, r1
    49a8:	39 83       	std	Y+1, r19	; 0x01
    49aa:	28 83       	st	Y, r18
    49ac:	3a c0       	rjmp	.+116    	; 0x4a22 <malloc+0x124>
    49ae:	20 91 0e 05 	lds	r18, 0x050E	; 0x80050e <__brkval>
    49b2:	30 91 0f 05 	lds	r19, 0x050F	; 0x80050f <__brkval+0x1>
    49b6:	23 2b       	or	r18, r19
    49b8:	41 f4       	brne	.+16     	; 0x49ca <malloc+0xcc>
    49ba:	20 91 02 01 	lds	r18, 0x0102	; 0x800102 <__malloc_heap_start>
    49be:	30 91 03 01 	lds	r19, 0x0103	; 0x800103 <__malloc_heap_start+0x1>
    49c2:	30 93 0f 05 	sts	0x050F, r19	; 0x80050f <__brkval+0x1>
    49c6:	20 93 0e 05 	sts	0x050E, r18	; 0x80050e <__brkval>
    49ca:	20 91 00 01 	lds	r18, 0x0100	; 0x800100 <__data_start>
    49ce:	30 91 01 01 	lds	r19, 0x0101	; 0x800101 <__data_start+0x1>
    49d2:	21 15       	cp	r18, r1
    49d4:	31 05       	cpc	r19, r1
    49d6:	41 f4       	brne	.+16     	; 0x49e8 <malloc+0xea>
    49d8:	2d b7       	in	r18, 0x3d	; 61
    49da:	3e b7       	in	r19, 0x3e	; 62
    49dc:	40 91 04 01 	lds	r20, 0x0104	; 0x800104 <__malloc_margin>
    49e0:	50 91 05 01 	lds	r21, 0x0105	; 0x800105 <__malloc_margin+0x1>
    49e4:	24 1b       	sub	r18, r20
    49e6:	35 0b       	sbc	r19, r21
    49e8:	e0 91 0e 05 	lds	r30, 0x050E	; 0x80050e <__brkval>
    49ec:	f0 91 0f 05 	lds	r31, 0x050F	; 0x80050f <__brkval+0x1>
    49f0:	e2 17       	cp	r30, r18
    49f2:	f3 07       	cpc	r31, r19
    49f4:	a0 f4       	brcc	.+40     	; 0x4a1e <malloc+0x120>
    49f6:	2e 1b       	sub	r18, r30
    49f8:	3f 0b       	sbc	r19, r31
    49fa:	28 17       	cp	r18, r24
    49fc:	39 07       	cpc	r19, r25
    49fe:	78 f0       	brcs	.+30     	; 0x4a1e <malloc+0x120>
    4a00:	ac 01       	movw	r20, r24
    4a02:	4e 5f       	subi	r20, 0xFE	; 254
    4a04:	5f 4f       	sbci	r21, 0xFF	; 255
    4a06:	24 17       	cp	r18, r20
    4a08:	35 07       	cpc	r19, r21
    4a0a:	48 f0       	brcs	.+18     	; 0x4a1e <malloc+0x120>
    4a0c:	4e 0f       	add	r20, r30
    4a0e:	5f 1f       	adc	r21, r31
    4a10:	50 93 0f 05 	sts	0x050F, r21	; 0x80050f <__brkval+0x1>
    4a14:	40 93 0e 05 	sts	0x050E, r20	; 0x80050e <__brkval>
    4a18:	81 93       	st	Z+, r24
    4a1a:	91 93       	st	Z+, r25
    4a1c:	02 c0       	rjmp	.+4      	; 0x4a22 <malloc+0x124>
    4a1e:	e0 e0       	ldi	r30, 0x00	; 0
    4a20:	f0 e0       	ldi	r31, 0x00	; 0
    4a22:	cf 01       	movw	r24, r30
    4a24:	df 91       	pop	r29
    4a26:	cf 91       	pop	r28
    4a28:	1f 91       	pop	r17
    4a2a:	0f 91       	pop	r16
    4a2c:	08 95       	ret

00004a2e <free>:
    4a2e:	cf 93       	push	r28
    4a30:	df 93       	push	r29
    4a32:	00 97       	sbiw	r24, 0x00	; 0
    4a34:	09 f4       	brne	.+2      	; 0x4a38 <free+0xa>
    4a36:	81 c0       	rjmp	.+258    	; 0x4b3a <free+0x10c>
    4a38:	fc 01       	movw	r30, r24
    4a3a:	32 97       	sbiw	r30, 0x02	; 2
    4a3c:	13 82       	std	Z+3, r1	; 0x03
    4a3e:	12 82       	std	Z+2, r1	; 0x02
    4a40:	a0 91 10 05 	lds	r26, 0x0510	; 0x800510 <__flp>
    4a44:	b0 91 11 05 	lds	r27, 0x0511	; 0x800511 <__flp+0x1>
    4a48:	10 97       	sbiw	r26, 0x00	; 0
    4a4a:	81 f4       	brne	.+32     	; 0x4a6c <free+0x3e>
    4a4c:	20 81       	ld	r18, Z
    4a4e:	31 81       	ldd	r19, Z+1	; 0x01
    4a50:	82 0f       	add	r24, r18
    4a52:	93 1f       	adc	r25, r19
    4a54:	20 91 0e 05 	lds	r18, 0x050E	; 0x80050e <__brkval>
    4a58:	30 91 0f 05 	lds	r19, 0x050F	; 0x80050f <__brkval+0x1>
    4a5c:	28 17       	cp	r18, r24
    4a5e:	39 07       	cpc	r19, r25
    4a60:	51 f5       	brne	.+84     	; 0x4ab6 <free+0x88>
    4a62:	f0 93 0f 05 	sts	0x050F, r31	; 0x80050f <__brkval+0x1>
    4a66:	e0 93 0e 05 	sts	0x050E, r30	; 0x80050e <__brkval>
    4a6a:	67 c0       	rjmp	.+206    	; 0x4b3a <free+0x10c>
    4a6c:	ed 01       	movw	r28, r26
    4a6e:	20 e0       	ldi	r18, 0x00	; 0
    4a70:	30 e0       	ldi	r19, 0x00	; 0
    4a72:	ce 17       	cp	r28, r30
    4a74:	df 07       	cpc	r29, r31
    4a76:	40 f4       	brcc	.+16     	; 0x4a88 <free+0x5a>
    4a78:	4a 81       	ldd	r20, Y+2	; 0x02
    4a7a:	5b 81       	ldd	r21, Y+3	; 0x03
    4a7c:	9e 01       	movw	r18, r28
    4a7e:	41 15       	cp	r20, r1
    4a80:	51 05       	cpc	r21, r1
    4a82:	f1 f0       	breq	.+60     	; 0x4ac0 <free+0x92>
    4a84:	ea 01       	movw	r28, r20
    4a86:	f5 cf       	rjmp	.-22     	; 0x4a72 <free+0x44>
    4a88:	d3 83       	std	Z+3, r29	; 0x03
    4a8a:	c2 83       	std	Z+2, r28	; 0x02
    4a8c:	40 81       	ld	r20, Z
    4a8e:	51 81       	ldd	r21, Z+1	; 0x01
    4a90:	84 0f       	add	r24, r20
    4a92:	95 1f       	adc	r25, r21
    4a94:	c8 17       	cp	r28, r24
    4a96:	d9 07       	cpc	r29, r25
    4a98:	59 f4       	brne	.+22     	; 0x4ab0 <free+0x82>
    4a9a:	88 81       	ld	r24, Y
    4a9c:	99 81       	ldd	r25, Y+1	; 0x01
    4a9e:	84 0f       	add	r24, r20
    4aa0:	95 1f       	adc	r25, r21
    4aa2:	02 96       	adiw	r24, 0x02	; 2
    4aa4:	91 83       	std	Z+1, r25	; 0x01
    4aa6:	80 83       	st	Z, r24
    4aa8:	8a 81       	ldd	r24, Y+2	; 0x02
    4aaa:	9b 81       	ldd	r25, Y+3	; 0x03
    4aac:	93 83       	std	Z+3, r25	; 0x03
    4aae:	82 83       	std	Z+2, r24	; 0x02
    4ab0:	21 15       	cp	r18, r1
    4ab2:	31 05       	cpc	r19, r1
    4ab4:	29 f4       	brne	.+10     	; 0x4ac0 <free+0x92>
    4ab6:	f0 93 11 05 	sts	0x0511, r31	; 0x800511 <__flp+0x1>
    4aba:	e0 93 10 05 	sts	0x0510, r30	; 0x800510 <__flp>
    4abe:	3d c0       	rjmp	.+122    	; 0x4b3a <free+0x10c>
    4ac0:	e9 01       	movw	r28, r18
    4ac2:	fb 83       	std	Y+3, r31	; 0x03
    4ac4:	ea 83       	std	Y+2, r30	; 0x02
    4ac6:	49 91       	ld	r20, Y+
    4ac8:	59 91       	ld	r21, Y+
    4aca:	c4 0f       	add	r28, r20
    4acc:	d5 1f       	adc	r29, r21
    4ace:	ec 17       	cp	r30, r28
    4ad0:	fd 07       	cpc	r31, r29
    4ad2:	61 f4       	brne	.+24     	; 0x4aec <free+0xbe>
    4ad4:	80 81       	ld	r24, Z
    4ad6:	91 81       	ldd	r25, Z+1	; 0x01
    4ad8:	84 0f       	add	r24, r20
    4ada:	95 1f       	adc	r25, r21
    4adc:	02 96       	adiw	r24, 0x02	; 2
    4ade:	e9 01       	movw	r28, r18
    4ae0:	99 83       	std	Y+1, r25	; 0x01
    4ae2:	88 83       	st	Y, r24
    4ae4:	82 81       	ldd	r24, Z+2	; 0x02
    4ae6:	93 81       	ldd	r25, Z+3	; 0x03
    4ae8:	9b 83       	std	Y+3, r25	; 0x03
    4aea:	8a 83       	std	Y+2, r24	; 0x02
    4aec:	e0 e0       	ldi	r30, 0x00	; 0
    4aee:	f0 e0       	ldi	r31, 0x00	; 0
    4af0:	12 96       	adiw	r26, 0x02	; 2
    4af2:	8d 91       	ld	r24, X+
    4af4:	9c 91       	ld	r25, X
    4af6:	13 97       	sbiw	r26, 0x03	; 3
    4af8:	00 97       	sbiw	r24, 0x00	; 0
    4afa:	19 f0       	breq	.+6      	; 0x4b02 <free+0xd4>
    4afc:	fd 01       	movw	r30, r26
    4afe:	dc 01       	movw	r26, r24
    4b00:	f7 cf       	rjmp	.-18     	; 0x4af0 <free+0xc2>
    4b02:	8d 91       	ld	r24, X+
    4b04:	9c 91       	ld	r25, X
    4b06:	11 97       	sbiw	r26, 0x01	; 1
    4b08:	9d 01       	movw	r18, r26
    4b0a:	2e 5f       	subi	r18, 0xFE	; 254
    4b0c:	3f 4f       	sbci	r19, 0xFF	; 255
    4b0e:	82 0f       	add	r24, r18
    4b10:	93 1f       	adc	r25, r19
    4b12:	20 91 0e 05 	lds	r18, 0x050E	; 0x80050e <__brkval>
    4b16:	30 91 0f 05 	lds	r19, 0x050F	; 0x80050f <__brkval+0x1>
    4b1a:	28 17       	cp	r18, r24
    4b1c:	39 07       	cpc	r19, r25
    4b1e:	69 f4       	brne	.+26     	; 0x4b3a <free+0x10c>
    4b20:	30 97       	sbiw	r30, 0x00	; 0
    4b22:	29 f4       	brne	.+10     	; 0x4b2e <free+0x100>
    4b24:	10 92 11 05 	sts	0x0511, r1	; 0x800511 <__flp+0x1>
    4b28:	10 92 10 05 	sts	0x0510, r1	; 0x800510 <__flp>
    4b2c:	02 c0       	rjmp	.+4      	; 0x4b32 <free+0x104>
    4b2e:	13 82       	std	Z+3, r1	; 0x03
    4b30:	12 82       	std	Z+2, r1	; 0x02
    4b32:	b0 93 0f 05 	sts	0x050F, r27	; 0x80050f <__brkval+0x1>
    4b36:	a0 93 0e 05 	sts	0x050E, r26	; 0x80050e <__brkval>
    4b3a:	df 91       	pop	r29
    4b3c:	cf 91       	pop	r28
    4b3e:	08 95       	ret

00004b40 <atoi>:
    4b40:	fc 01       	movw	r30, r24
    4b42:	88 27       	eor	r24, r24
    4b44:	99 27       	eor	r25, r25
    4b46:	e8 94       	clt
    4b48:	21 91       	ld	r18, Z+
    4b4a:	20 32       	cpi	r18, 0x20	; 32
    4b4c:	e9 f3       	breq	.-6      	; 0x4b48 <atoi+0x8>
    4b4e:	29 30       	cpi	r18, 0x09	; 9
    4b50:	10 f0       	brcs	.+4      	; 0x4b56 <atoi+0x16>
    4b52:	2e 30       	cpi	r18, 0x0E	; 14
    4b54:	c8 f3       	brcs	.-14     	; 0x4b48 <atoi+0x8>
    4b56:	2b 32       	cpi	r18, 0x2B	; 43
    4b58:	41 f0       	breq	.+16     	; 0x4b6a <atoi+0x2a>
    4b5a:	2d 32       	cpi	r18, 0x2D	; 45
    4b5c:	39 f4       	brne	.+14     	; 0x4b6c <atoi+0x2c>
    4b5e:	68 94       	set
    4b60:	04 c0       	rjmp	.+8      	; 0x4b6a <atoi+0x2a>
    4b62:	0e 94 ce 25 	call	0x4b9c	; 0x4b9c <__mulhi_const_10>
    4b66:	82 0f       	add	r24, r18
    4b68:	91 1d       	adc	r25, r1
    4b6a:	21 91       	ld	r18, Z+
    4b6c:	20 53       	subi	r18, 0x30	; 48
    4b6e:	2a 30       	cpi	r18, 0x0A	; 10
    4b70:	c0 f3       	brcs	.-16     	; 0x4b62 <atoi+0x22>
    4b72:	1e f4       	brtc	.+6      	; 0x4b7a <atoi+0x3a>
    4b74:	90 95       	com	r25
    4b76:	81 95       	neg	r24
    4b78:	9f 4f       	sbci	r25, 0xFF	; 255
    4b7a:	08 95       	ret

00004b7c <memcpy>:
    4b7c:	fb 01       	movw	r30, r22
    4b7e:	dc 01       	movw	r26, r24
    4b80:	02 c0       	rjmp	.+4      	; 0x4b86 <memcpy+0xa>
    4b82:	01 90       	ld	r0, Z+
    4b84:	0d 92       	st	X+, r0
    4b86:	41 50       	subi	r20, 0x01	; 1
    4b88:	50 40       	sbci	r21, 0x00	; 0
    4b8a:	d8 f7       	brcc	.-10     	; 0x4b82 <memcpy+0x6>
    4b8c:	08 95       	ret

00004b8e <memset>:
    4b8e:	dc 01       	movw	r26, r24
    4b90:	01 c0       	rjmp	.+2      	; 0x4b94 <memset+0x6>
    4b92:	6d 93       	st	X+, r22
    4b94:	41 50       	subi	r20, 0x01	; 1
    4b96:	50 40       	sbci	r21, 0x00	; 0
    4b98:	e0 f7       	brcc	.-8      	; 0x4b92 <memset+0x4>
    4b9a:	08 95       	ret

00004b9c <__mulhi_const_10>:
    4b9c:	7a e0       	ldi	r23, 0x0A	; 10
    4b9e:	97 9f       	mul	r25, r23
    4ba0:	90 2d       	mov	r25, r0
    4ba2:	87 9f       	mul	r24, r23
    4ba4:	80 2d       	mov	r24, r0
    4ba6:	91 0d       	add	r25, r1
    4ba8:	11 24       	eor	r1, r1
    4baa:	08 95       	ret

00004bac <__do_global_dtors>:
    4bac:	10 e0       	ldi	r17, 0x00	; 0
    4bae:	ca e8       	ldi	r28, 0x8A	; 138
    4bb0:	d0 e0       	ldi	r29, 0x00	; 0
    4bb2:	04 c0       	rjmp	.+8      	; 0x4bbc <__do_global_dtors+0x10>
    4bb4:	fe 01       	movw	r30, r28
    4bb6:	0e 94 4b 24 	call	0x4896	; 0x4896 <__tablejump2__>
    4bba:	21 96       	adiw	r28, 0x01	; 1
    4bbc:	cc 38       	cpi	r28, 0x8C	; 140
    4bbe:	d1 07       	cpc	r29, r17
    4bc0:	c9 f7       	brne	.-14     	; 0x4bb4 <__do_global_dtors+0x8>
    4bc2:	f8 94       	cli

00004bc4 <__stop_program>:
    4bc4:	ff cf       	rjmp	.-2      	; 0x4bc4 <__stop_program>
