
lil_fish_tanks_arduino.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000116  00800100  00004af0  00004b84  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00004af0  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          000002cb  00800216  00800216  00004c9a  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00004c9a  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00004ccc  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 000009d0  00000000  00000000  00004d0c  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00013cc6  00000000  00000000  000056dc  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00003c9e  00000000  00000000  000193a2  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00006965  00000000  00000000  0001d040  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00001e18  00000000  00000000  000239a8  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00004a7f  00000000  00000000  000257c0  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    0000b67a  00000000  00000000  0002a23f  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000948  00000000  00000000  000358b9  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 89 00 	jmp	0x112	; 0x112 <__dtors_end>
       4:	0c 94 4b 20 	jmp	0x4096	; 0x4096 <__vector_1>
       8:	0c 94 72 20 	jmp	0x40e4	; 0x40e4 <__vector_2>
       c:	0c 94 49 19 	jmp	0x3292	; 0x3292 <__vector_3>
      10:	0c 94 49 19 	jmp	0x3292	; 0x3292 <__vector_3>
      14:	0c 94 49 19 	jmp	0x3292	; 0x3292 <__vector_3>
      18:	0c 94 6c 0b 	jmp	0x16d8	; 0x16d8 <__vector_6>
      1c:	0c 94 3a 23 	jmp	0x4674	; 0x4674 <__vector_7>
      20:	0c 94 b1 00 	jmp	0x162	; 0x162 <__bad_interrupt>
      24:	0c 94 b1 00 	jmp	0x162	; 0x162 <__bad_interrupt>
      28:	0c 94 b1 00 	jmp	0x162	; 0x162 <__bad_interrupt>
      2c:	0c 94 b1 00 	jmp	0x162	; 0x162 <__bad_interrupt>
      30:	0c 94 b1 00 	jmp	0x162	; 0x162 <__bad_interrupt>
      34:	0c 94 b1 00 	jmp	0x162	; 0x162 <__bad_interrupt>
      38:	0c 94 b1 00 	jmp	0x162	; 0x162 <__bad_interrupt>
      3c:	0c 94 b1 00 	jmp	0x162	; 0x162 <__bad_interrupt>
      40:	0c 94 99 20 	jmp	0x4132	; 0x4132 <__vector_16>
      44:	0c 94 b1 00 	jmp	0x162	; 0x162 <__bad_interrupt>
      48:	0c 94 4f 1e 	jmp	0x3c9e	; 0x3c9e <__vector_18>
      4c:	0c 94 81 1e 	jmp	0x3d02	; 0x3d02 <__vector_19>
      50:	0c 94 b1 00 	jmp	0x162	; 0x162 <__bad_interrupt>
      54:	0c 94 b1 00 	jmp	0x162	; 0x162 <__bad_interrupt>
      58:	0c 94 b1 00 	jmp	0x162	; 0x162 <__bad_interrupt>
      5c:	0c 94 b1 00 	jmp	0x162	; 0x162 <__bad_interrupt>
      60:	0c 94 b1 00 	jmp	0x162	; 0x162 <__bad_interrupt>
      64:	0c 94 b1 00 	jmp	0x162	; 0x162 <__bad_interrupt>
      68:	53 16       	cp	r5, r19
      6a:	53 16       	cp	r5, r19
      6c:	53 16       	cp	r5, r19
      6e:	92 16       	cp	r9, r18
      70:	7d 16       	cp	r7, r29
      72:	8c 16       	cp	r8, r28
      74:	53 16       	cp	r5, r19
      76:	53 16       	cp	r5, r19
      78:	92 16       	cp	r9, r18
      7a:	7d 16       	cp	r7, r29

0000007c <__trampolines_end>:
      7c:	0a 46       	sbci	r16, 0x6A	; 106
      7e:	6f 75       	andi	r22, 0x5F	; 95
      80:	6e 64       	ori	r22, 0x4E	; 78
      82:	20 4d       	sbci	r18, 0xD0	; 208
      84:	61 74       	andi	r22, 0x41	; 65
      86:	63 68       	ori	r22, 0x83	; 131
      88:	69 6e       	ori	r22, 0xE9	; 233
      8a:	67 20       	and	r6, r7
      8c:	43 6f       	ori	r20, 0xF3	; 243
      8e:	6c 6f       	ori	r22, 0xFC	; 252
      90:	72 00       	.word	0x0072	; ????

00000092 <_ZL15dscrc2x16_table>:
      92:	00 5e bc e2 61 3f dd 83 c2 9c 7e 20 a3 fd 1f 41     .^..a?....~ ...A
      a2:	00 9d 23 be 46 db 65 f8 8c 11 af 32 ca 57 e9 74     ..#.F.e....2.W.t

000000b2 <digital_pin_to_timer_PGM>:
      b2:	00 00 00 08 00 02 01 00 00 03 04 07 00 00 00 00     ................
      c2:	00 00 00 00                                         ....

000000c6 <digital_pin_to_bit_mask_PGM>:
      c6:	01 02 04 08 10 20 40 80 01 02 04 08 10 20 01 02     ..... @...... ..
      d6:	04 08 10 20                                         ... 

000000da <digital_pin_to_port_PGM>:
      da:	04 04 04 04 04 04 04 04 02 02 02 02 02 02 03 03     ................
      ea:	03 03 03 03                                         ....

000000ee <port_to_input_PGM>:
      ee:	00 00 00 00 23 00 26 00 29 00                       ....#.&.).

000000f8 <port_to_output_PGM>:
      f8:	00 00 00 00 25 00 28 00 2b 00                       ....%.(.+.

00000102 <port_to_mode_PGM>:
     102:	00 00 00 00 24 00 27 00 2a 00                       ....$.'.*.

0000010c <__ctors_start>:
     10c:	5c 06       	cpc	r5, r28
     10e:	b1 1e       	adc	r11, r17

00000110 <__ctors_end>:
     110:	6f 06       	cpc	r6, r31

00000112 <__dtors_end>:
     112:	11 24       	eor	r1, r1
     114:	1f be       	out	0x3f, r1	; 63
     116:	cf ef       	ldi	r28, 0xFF	; 255
     118:	d8 e0       	ldi	r29, 0x08	; 8
     11a:	de bf       	out	0x3e, r29	; 62
     11c:	cd bf       	out	0x3d, r28	; 61

0000011e <__do_copy_data>:
     11e:	12 e0       	ldi	r17, 0x02	; 2
     120:	a0 e0       	ldi	r26, 0x00	; 0
     122:	b1 e0       	ldi	r27, 0x01	; 1
     124:	e0 ef       	ldi	r30, 0xF0	; 240
     126:	fa e4       	ldi	r31, 0x4A	; 74
     128:	02 c0       	rjmp	.+4      	; 0x12e <__do_copy_data+0x10>
     12a:	05 90       	lpm	r0, Z+
     12c:	0d 92       	st	X+, r0
     12e:	a6 31       	cpi	r26, 0x16	; 22
     130:	b1 07       	cpc	r27, r17
     132:	d9 f7       	brne	.-10     	; 0x12a <__do_copy_data+0xc>

00000134 <__do_clear_bss>:
     134:	24 e0       	ldi	r18, 0x04	; 4
     136:	a6 e1       	ldi	r26, 0x16	; 22
     138:	b2 e0       	ldi	r27, 0x02	; 2
     13a:	01 c0       	rjmp	.+2      	; 0x13e <.do_clear_bss_start>

0000013c <.do_clear_bss_loop>:
     13c:	1d 92       	st	X+, r1

0000013e <.do_clear_bss_start>:
     13e:	a1 3e       	cpi	r26, 0xE1	; 225
     140:	b2 07       	cpc	r27, r18
     142:	e1 f7       	brne	.-8      	; 0x13c <.do_clear_bss_loop>

00000144 <__do_global_ctors>:
     144:	10 e0       	ldi	r17, 0x00	; 0
     146:	c8 e8       	ldi	r28, 0x88	; 136
     148:	d0 e0       	ldi	r29, 0x00	; 0
     14a:	04 c0       	rjmp	.+8      	; 0x154 <__do_global_ctors+0x10>
     14c:	21 97       	sbiw	r28, 0x01	; 1
     14e:	fe 01       	movw	r30, r28
     150:	0e 94 06 24 	call	0x480c	; 0x480c <__tablejump2__>
     154:	c6 38       	cpi	r28, 0x86	; 134
     156:	d1 07       	cpc	r29, r17
     158:	c9 f7       	brne	.-14     	; 0x14c <__do_global_ctors+0x8>
     15a:	0e 94 de 1e 	call	0x3dbc	; 0x3dbc <main>
     15e:	0c 94 6b 25 	jmp	0x4ad6	; 0x4ad6 <__do_global_dtors>

00000162 <__bad_interrupt>:
     162:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000166 <_ZN5Print5writeEPKc>:
    int getWriteError() { return write_error; }
    void clearWriteError() { setWriteError(0); }
  
    virtual size_t write(uint8_t) = 0;
    size_t write(const char *str) {
      if (str == NULL) return 0;
     166:	61 15       	cp	r22, r1
     168:	71 05       	cpc	r23, r1
     16a:	79 f0       	breq	.+30     	; 0x18a <_ZN5Print5writeEPKc+0x24>
      return write((const uint8_t *)str, strlen(str));
     16c:	fb 01       	movw	r30, r22
     16e:	01 90       	ld	r0, Z+
     170:	00 20       	and	r0, r0
     172:	e9 f7       	brne	.-6      	; 0x16e <_ZN5Print5writeEPKc+0x8>
     174:	31 97       	sbiw	r30, 0x01	; 1
     176:	af 01       	movw	r20, r30
     178:	46 1b       	sub	r20, r22
     17a:	57 0b       	sbc	r21, r23
     17c:	dc 01       	movw	r26, r24
     17e:	ed 91       	ld	r30, X+
     180:	fc 91       	ld	r31, X
     182:	02 80       	ldd	r0, Z+2	; 0x02
     184:	f3 81       	ldd	r31, Z+3	; 0x03
     186:	e0 2d       	mov	r30, r0
     188:	09 94       	ijmp
    }
     18a:	80 e0       	ldi	r24, 0x00	; 0
     18c:	90 e0       	ldi	r25, 0x00	; 0
     18e:	08 95       	ret

00000190 <_Z11measureTempv>:

OneWire ds(TEMP_PIN); // Temp sensor on pin 6


/* measureTemp() returns the measured temperature in degrees Celsius */
float measureTemp() {
     190:	ef 92       	push	r14
     192:	ff 92       	push	r15
     194:	0f 93       	push	r16
     196:	1f 93       	push	r17
     198:	cf 93       	push	r28
     19a:	df 93       	push	r29
     19c:	cd b7       	in	r28, 0x3d	; 61
     19e:	de b7       	in	r29, 0x3e	; 62
     1a0:	64 97       	sbiw	r28, 0x14	; 20
     1a2:	0f b6       	in	r0, 0x3f	; 63
     1a4:	f8 94       	cli
     1a6:	de bf       	out	0x3e, r29	; 62
     1a8:	0f be       	out	0x3f, r0	; 63
     1aa:	cd bf       	out	0x3d, r28	; 61
	//byte type_s;
	byte data[12];
	byte addr[8];
	float celsius; //, fahrenheit;
	
	ds.reset_search();
     1ac:	8e e4       	ldi	r24, 0x4E	; 78
     1ae:	93 e0       	ldi	r25, 0x03	; 3
     1b0:	0e 94 3a 08 	call	0x1074	; 0x1074 <_ZN7OneWire12reset_searchEv>
	delay(250);
     1b4:	6a ef       	ldi	r22, 0xFA	; 250
     1b6:	70 e0       	ldi	r23, 0x00	; 0
     1b8:	80 e0       	ldi	r24, 0x00	; 0
     1ba:	90 e0       	ldi	r25, 0x00	; 0
     1bc:	0e 94 08 21 	call	0x4210	; 0x4210 <delay>
	ds.search(addr);
     1c0:	41 e0       	ldi	r20, 0x01	; 1
     1c2:	be 01       	movw	r22, r28
     1c4:	63 5f       	subi	r22, 0xF3	; 243
     1c6:	7f 4f       	sbci	r23, 0xFF	; 255
     1c8:	8e e4       	ldi	r24, 0x4E	; 78
     1ca:	93 e0       	ldi	r25, 0x03	; 3
     1cc:	0e 94 69 08 	call	0x10d2	; 0x10d2 <_ZN7OneWire6searchEPhb>

	if (OneWire::crc8(addr, 7) != addr[7]) {
     1d0:	67 e0       	ldi	r22, 0x07	; 7
     1d2:	ce 01       	movw	r24, r28
     1d4:	0d 96       	adiw	r24, 0x0d	; 13
     1d6:	0e 94 f0 08 	call	0x11e0	; 0x11e0 <_ZN7OneWire4crc8EPKhh>
     1da:	9c 89       	ldd	r25, Y+20	; 0x14
     1dc:	89 13       	cpse	r24, r25
     1de:	54 c0       	rjmp	.+168    	; 0x288 <_Z11measureTempv+0xf8>
		default:
		Serial.println("Device is not a DS18x20 family device.");
		return -1;
	} */

	ds.reset();
     1e0:	8e e4       	ldi	r24, 0x4E	; 78
     1e2:	93 e0       	ldi	r25, 0x03	; 3
     1e4:	0e 94 2e 07 	call	0xe5c	; 0xe5c <_ZN7OneWire5resetEv>
	ds.select(addr);
     1e8:	be 01       	movw	r22, r28
     1ea:	63 5f       	subi	r22, 0xF3	; 243
     1ec:	7f 4f       	sbci	r23, 0xFF	; 255
     1ee:	8e e4       	ldi	r24, 0x4E	; 78
     1f0:	93 e0       	ldi	r25, 0x03	; 3
     1f2:	0e 94 1b 08 	call	0x1036	; 0x1036 <_ZN7OneWire6selectEPKh>
	ds.write(0x44, 1);        // start conversion, with parasite power on at the end
     1f6:	41 e0       	ldi	r20, 0x01	; 1
     1f8:	64 e4       	ldi	r22, 0x44	; 68
     1fa:	8e e4       	ldi	r24, 0x4E	; 78
     1fc:	93 e0       	ldi	r25, 0x03	; 3
     1fe:	0e 94 cb 07 	call	0xf96	; 0xf96 <_ZN7OneWire5writeEhh>
	
	delay(1000);     // maybe 750ms is enough, maybe not
     202:	68 ee       	ldi	r22, 0xE8	; 232
     204:	73 e0       	ldi	r23, 0x03	; 3
     206:	80 e0       	ldi	r24, 0x00	; 0
     208:	90 e0       	ldi	r25, 0x00	; 0
     20a:	0e 94 08 21 	call	0x4210	; 0x4210 <delay>
	// we might do a ds.depower() here, but the reset will take care of it.
	
	ds.reset();
     20e:	8e e4       	ldi	r24, 0x4E	; 78
     210:	93 e0       	ldi	r25, 0x03	; 3
     212:	0e 94 2e 07 	call	0xe5c	; 0xe5c <_ZN7OneWire5resetEv>
	ds.select(addr);
     216:	be 01       	movw	r22, r28
     218:	63 5f       	subi	r22, 0xF3	; 243
     21a:	7f 4f       	sbci	r23, 0xFF	; 255
     21c:	8e e4       	ldi	r24, 0x4E	; 78
     21e:	93 e0       	ldi	r25, 0x03	; 3
     220:	0e 94 1b 08 	call	0x1036	; 0x1036 <_ZN7OneWire6selectEPKh>
	ds.write(0xBE);         // Read Scratchpad
     224:	40 e0       	ldi	r20, 0x00	; 0
     226:	6e eb       	ldi	r22, 0xBE	; 190
     228:	8e e4       	ldi	r24, 0x4E	; 78
     22a:	93 e0       	ldi	r25, 0x03	; 3
     22c:	0e 94 cb 07 	call	0xf96	; 0xf96 <_ZN7OneWire5writeEhh>
     230:	8e 01       	movw	r16, r28
     232:	0f 5f       	subi	r16, 0xFF	; 255
     234:	1f 4f       	sbci	r17, 0xFF	; 255
     236:	7e 01       	movw	r14, r28
     238:	8a e0       	ldi	r24, 0x0A	; 10
     23a:	e8 0e       	add	r14, r24
     23c:	f1 1c       	adc	r15, r1

	//Serial.print("  Data = ");
	//Serial.print(present, HEX);
	//Serial.print(" ");
	for ( i = 0; i < 9; i++) {           // we need 9 bytes
		data[i] = ds.read();
     23e:	8e e4       	ldi	r24, 0x4E	; 78
     240:	93 e0       	ldi	r25, 0x03	; 3
     242:	0e 94 ff 07 	call	0xffe	; 0xffe <_ZN7OneWire4readEv>
     246:	f8 01       	movw	r30, r16
     248:	81 93       	st	Z+, r24
     24a:	8f 01       	movw	r16, r30
	ds.write(0xBE);         // Read Scratchpad

	//Serial.print("  Data = ");
	//Serial.print(present, HEX);
	//Serial.print(" ");
	for ( i = 0; i < 9; i++) {           // we need 9 bytes
     24c:	ee 15       	cp	r30, r14
     24e:	ff 05       	cpc	r31, r15
     250:	b1 f7       	brne	.-20     	; 0x23e <_Z11measureTempv+0xae>

	// Convert the data to actual temperature
	// because the result is a 16 bit signed integer, it should
	// be stored to an "int16_t" type, which is always 16 bits
	// even when compiled on a 32 bit processor.
	int16_t raw = (data[1] << 8) | data[0];
     252:	69 81       	ldd	r22, Y+1	; 0x01
     254:	7a 81       	ldd	r23, Y+2	; 0x02
		if (data[7] == 0x10) {
			// "count remain" gives full 12 bit resolution
			raw = (raw & 0xFFF0) + 12 - data[6];
		}
	} else { */
	byte cfg = (data[4] & 0x60);
     256:	8d 81       	ldd	r24, Y+5	; 0x05
     258:	80 76       	andi	r24, 0x60	; 96
	// at lower res, the low bits are undefined, so let's zero them
	if (cfg == 0x00) raw = raw & ~7;  // 9 bit resolution, 93.75 ms
     25a:	11 f4       	brne	.+4      	; 0x260 <_Z11measureTempv+0xd0>
     25c:	68 7f       	andi	r22, 0xF8	; 248
     25e:	07 c0       	rjmp	.+14     	; 0x26e <_Z11measureTempv+0xde>
	else if (cfg == 0x20) raw = raw & ~3; // 10 bit res, 187.5 ms
     260:	80 32       	cpi	r24, 0x20	; 32
     262:	11 f4       	brne	.+4      	; 0x268 <_Z11measureTempv+0xd8>
     264:	6c 7f       	andi	r22, 0xFC	; 252
     266:	03 c0       	rjmp	.+6      	; 0x26e <_Z11measureTempv+0xde>
	else if (cfg == 0x40) raw = raw & ~1; // 11 bit res, 375 ms
     268:	80 34       	cpi	r24, 0x40	; 64
     26a:	09 f4       	brne	.+2      	; 0x26e <_Z11measureTempv+0xde>
     26c:	6e 7f       	andi	r22, 0xFE	; 254
	//// default is 12 bit resolution, 750 ms conversion time
	//} 
	
	//Serial.println("RAW");
	//Serial.println(raw);
	celsius = (float)raw / 16.0;
     26e:	07 2e       	mov	r0, r23
     270:	00 0c       	add	r0, r0
     272:	88 0b       	sbc	r24, r24
     274:	99 0b       	sbc	r25, r25
     276:	0e 94 f1 1b 	call	0x37e2	; 0x37e2 <__floatsisf>
     27a:	20 e0       	ldi	r18, 0x00	; 0
     27c:	30 e0       	ldi	r19, 0x00	; 0
     27e:	40 e8       	ldi	r20, 0x80	; 128
     280:	5d e3       	ldi	r21, 0x3D	; 61
     282:	0e 94 a1 1c 	call	0x3942	; 0x3942 <__mulsf3>
	//Serial.print("  Temperature = ");
	//Serial.print(celsius);
	//Serial.print(" Celsius, ");
	//Serial.print(fahrenheit);
	//Serial.println(" Fahrenheit");
	return celsius;
     286:	04 c0       	rjmp	.+8      	; 0x290 <_Z11measureTempv+0x100>
	delay(250);
	ds.search(addr);

	if (OneWire::crc8(addr, 7) != addr[7]) {
		//Serial.println("CRC is not valid!");
		return -1;
     288:	60 e0       	ldi	r22, 0x00	; 0
     28a:	70 e0       	ldi	r23, 0x00	; 0
     28c:	80 e8       	ldi	r24, 0x80	; 128
     28e:	9f eb       	ldi	r25, 0xBF	; 191
	//Serial.print(celsius);
	//Serial.print(" Celsius, ");
	//Serial.print(fahrenheit);
	//Serial.println(" Fahrenheit");
	return celsius;
     290:	64 96       	adiw	r28, 0x14	; 20
     292:	0f b6       	in	r0, 0x3f	; 63
     294:	f8 94       	cli
     296:	de bf       	out	0x3e, r29	; 62
     298:	0f be       	out	0x3f, r0	; 63
     29a:	cd bf       	out	0x3d, r28	; 61
     29c:	df 91       	pop	r29
     29e:	cf 91       	pop	r28
     2a0:	1f 91       	pop	r17
     2a2:	0f 91       	pop	r16
     2a4:	ff 90       	pop	r15
     2a6:	ef 90       	pop	r14
     2a8:	08 95       	ret

000002aa <_Z9addColorsv>:
MD_TCS230  CS(S2, S3, OE);


// add possible color strip values to specific arrays
void addColors()
{
     2aa:	0f 93       	push	r16
     2ac:	1f 93       	push	r17
     2ae:	cf 93       	push	r28
     2b0:	df 93       	push	r29
	int index = 0;
	Color c;
	c.ppm = 0.0;
	c.p = {55, 55, 80};
	Ammonia[index] = c;
     2b2:	cb e1       	ldi	r28, 0x1B	; 27
     2b4:	d3 e0       	ldi	r29, 0x03	; 3
     2b6:	18 82       	st	Y, r1
     2b8:	19 82       	std	Y+1, r1	; 0x01
     2ba:	1a 82       	std	Y+2, r1	; 0x02
     2bc:	1b 82       	std	Y+3, r1	; 0x03
     2be:	87 e3       	ldi	r24, 0x37	; 55
     2c0:	90 e0       	ldi	r25, 0x00	; 0
     2c2:	9d 83       	std	Y+5, r25	; 0x05
     2c4:	8c 83       	std	Y+4, r24	; 0x04
     2c6:	9f 83       	std	Y+7, r25	; 0x07
     2c8:	8e 83       	std	Y+6, r24	; 0x06
     2ca:	80 e5       	ldi	r24, 0x50	; 80
     2cc:	90 e0       	ldi	r25, 0x00	; 0
     2ce:	99 87       	std	Y+9, r25	; 0x09
     2d0:	88 87       	std	Y+8, r24	; 0x08

	c.ppm = 0.0;
	c.p = {65, 65, 110};
	Nitrite[index] = c;
     2d2:	a5 ed       	ldi	r26, 0xD5	; 213
     2d4:	b2 e0       	ldi	r27, 0x02	; 2
     2d6:	1d 92       	st	X+, r1
     2d8:	1d 92       	st	X+, r1
     2da:	1d 92       	st	X+, r1
     2dc:	1c 92       	st	X, r1
     2de:	13 97       	sbiw	r26, 0x03	; 3
     2e0:	81 e4       	ldi	r24, 0x41	; 65
     2e2:	90 e0       	ldi	r25, 0x00	; 0
     2e4:	15 96       	adiw	r26, 0x05	; 5
     2e6:	9c 93       	st	X, r25
     2e8:	8e 93       	st	-X, r24
     2ea:	14 97       	sbiw	r26, 0x04	; 4
     2ec:	17 96       	adiw	r26, 0x07	; 7
     2ee:	9c 93       	st	X, r25
     2f0:	8e 93       	st	-X, r24
     2f2:	16 97       	sbiw	r26, 0x06	; 6
     2f4:	8e e6       	ldi	r24, 0x6E	; 110
     2f6:	90 e0       	ldi	r25, 0x00	; 0
     2f8:	19 96       	adiw	r26, 0x09	; 9
     2fa:	9c 93       	st	X, r25
     2fc:	8e 93       	st	-X, r24
     2fe:	18 97       	sbiw	r26, 0x08	; 8

	c.ppm = 0.0;
	c.p = {49, 50, 90};
	Nitrate[index] = c;
     300:	ef e8       	ldi	r30, 0x8F	; 143
     302:	f2 e0       	ldi	r31, 0x02	; 2
     304:	10 82       	st	Z, r1
     306:	11 82       	std	Z+1, r1	; 0x01
     308:	12 82       	std	Z+2, r1	; 0x02
     30a:	13 82       	std	Z+3, r1	; 0x03
     30c:	81 e3       	ldi	r24, 0x31	; 49
     30e:	90 e0       	ldi	r25, 0x00	; 0
     310:	95 83       	std	Z+5, r25	; 0x05
     312:	84 83       	std	Z+4, r24	; 0x04
     314:	82 e3       	ldi	r24, 0x32	; 50
     316:	90 e0       	ldi	r25, 0x00	; 0
     318:	97 83       	std	Z+7, r25	; 0x07
     31a:	86 83       	std	Z+6, r24	; 0x06
     31c:	8a e5       	ldi	r24, 0x5A	; 90
     31e:	90 e0       	ldi	r25, 0x00	; 0
     320:	91 87       	std	Z+9, r25	; 0x09
     322:	80 87       	std	Z+8, r24	; 0x08

	++index;

	c.ppm = 0.5;
	c.p = {0, 0, 0};
	Ammonia[index] = c;
     324:	40 e0       	ldi	r20, 0x00	; 0
     326:	50 e0       	ldi	r21, 0x00	; 0
     328:	60 e0       	ldi	r22, 0x00	; 0
     32a:	7f e3       	ldi	r23, 0x3F	; 63
     32c:	4a 87       	std	Y+10, r20	; 0x0a
     32e:	5b 87       	std	Y+11, r21	; 0x0b
     330:	6c 87       	std	Y+12, r22	; 0x0c
     332:	7d 87       	std	Y+13, r23	; 0x0d
     334:	1f 86       	std	Y+15, r1	; 0x0f
     336:	1e 86       	std	Y+14, r1	; 0x0e
     338:	19 8a       	std	Y+17, r1	; 0x11
     33a:	18 8a       	std	Y+16, r1	; 0x10
     33c:	1b 8a       	std	Y+19, r1	; 0x13
     33e:	1a 8a       	std	Y+18, r1	; 0x12

	c.ppm = 0.15;
	c.p = {0, 0, 0};
	Nitrite[index] = c;
     340:	0a e9       	ldi	r16, 0x9A	; 154
     342:	19 e9       	ldi	r17, 0x99	; 153
     344:	29 e1       	ldi	r18, 0x19	; 25
     346:	3e e3       	ldi	r19, 0x3E	; 62
     348:	1a 96       	adiw	r26, 0x0a	; 10
     34a:	0d 93       	st	X+, r16
     34c:	1d 93       	st	X+, r17
     34e:	2d 93       	st	X+, r18
     350:	3c 93       	st	X, r19
     352:	1d 97       	sbiw	r26, 0x0d	; 13
     354:	1f 96       	adiw	r26, 0x0f	; 15
     356:	1c 92       	st	X, r1
     358:	1e 92       	st	-X, r1
     35a:	1e 97       	sbiw	r26, 0x0e	; 14
     35c:	51 96       	adiw	r26, 0x11	; 17
     35e:	1c 92       	st	X, r1
     360:	1e 92       	st	-X, r1
     362:	50 97       	sbiw	r26, 0x10	; 16
     364:	53 96       	adiw	r26, 0x13	; 19
     366:	1c 92       	st	X, r1
     368:	1e 92       	st	-X, r1
     36a:	52 97       	sbiw	r26, 0x12	; 18

	c.ppm = 0.5;
	c.p = {0, 0, 0};
	Nitrate[index] = c;
     36c:	42 87       	std	Z+10, r20	; 0x0a
     36e:	53 87       	std	Z+11, r21	; 0x0b
     370:	64 87       	std	Z+12, r22	; 0x0c
     372:	75 87       	std	Z+13, r23	; 0x0d
     374:	17 86       	std	Z+15, r1	; 0x0f
     376:	16 86       	std	Z+14, r1	; 0x0e
     378:	11 8a       	std	Z+17, r1	; 0x11
     37a:	10 8a       	std	Z+16, r1	; 0x10
     37c:	13 8a       	std	Z+19, r1	; 0x13
     37e:	12 8a       	std	Z+18, r1	; 0x12

	++index;

	c.ppm = 1.0;
	c.p = {57, 58, 85};
	Ammonia[index] = c;
     380:	40 e0       	ldi	r20, 0x00	; 0
     382:	50 e0       	ldi	r21, 0x00	; 0
     384:	60 e8       	ldi	r22, 0x80	; 128
     386:	7f e3       	ldi	r23, 0x3F	; 63
     388:	4c 8b       	std	Y+20, r20	; 0x14
     38a:	5d 8b       	std	Y+21, r21	; 0x15
     38c:	6e 8b       	std	Y+22, r22	; 0x16
     38e:	7f 8b       	std	Y+23, r23	; 0x17
     390:	89 e3       	ldi	r24, 0x39	; 57
     392:	90 e0       	ldi	r25, 0x00	; 0
     394:	99 8f       	std	Y+25, r25	; 0x19
     396:	88 8f       	std	Y+24, r24	; 0x18
     398:	8a e3       	ldi	r24, 0x3A	; 58
     39a:	90 e0       	ldi	r25, 0x00	; 0
     39c:	9b 8f       	std	Y+27, r25	; 0x1b
     39e:	8a 8f       	std	Y+26, r24	; 0x1a
     3a0:	85 e5       	ldi	r24, 0x55	; 85
     3a2:	90 e0       	ldi	r25, 0x00	; 0
     3a4:	9d 8f       	std	Y+29, r25	; 0x1d
     3a6:	8c 8f       	std	Y+28, r24	; 0x1c

	c.ppm = 0.3;
	c.p = {0, 0, 0};
	Nitrite[index] = c;
     3a8:	0a e9       	ldi	r16, 0x9A	; 154
     3aa:	19 e9       	ldi	r17, 0x99	; 153
     3ac:	29 e9       	ldi	r18, 0x99	; 153
     3ae:	3e e3       	ldi	r19, 0x3E	; 62
     3b0:	54 96       	adiw	r26, 0x14	; 20
     3b2:	0d 93       	st	X+, r16
     3b4:	1d 93       	st	X+, r17
     3b6:	2d 93       	st	X+, r18
     3b8:	3c 93       	st	X, r19
     3ba:	57 97       	sbiw	r26, 0x17	; 23
     3bc:	59 96       	adiw	r26, 0x19	; 25
     3be:	1c 92       	st	X, r1
     3c0:	1e 92       	st	-X, r1
     3c2:	58 97       	sbiw	r26, 0x18	; 24
     3c4:	5b 96       	adiw	r26, 0x1b	; 27
     3c6:	1c 92       	st	X, r1
     3c8:	1e 92       	st	-X, r1
     3ca:	5a 97       	sbiw	r26, 0x1a	; 26
     3cc:	5d 96       	adiw	r26, 0x1d	; 29
     3ce:	1c 92       	st	X, r1
     3d0:	1e 92       	st	-X, r1
     3d2:	5c 97       	sbiw	r26, 0x1c	; 28

	c.ppm = 2.0;
	c.p = {0, 0, 0};
	Nitrate[index] = c;
     3d4:	00 e0       	ldi	r16, 0x00	; 0
     3d6:	10 e0       	ldi	r17, 0x00	; 0
     3d8:	20 e0       	ldi	r18, 0x00	; 0
     3da:	30 e4       	ldi	r19, 0x40	; 64
     3dc:	04 8b       	std	Z+20, r16	; 0x14
     3de:	15 8b       	std	Z+21, r17	; 0x15
     3e0:	26 8b       	std	Z+22, r18	; 0x16
     3e2:	37 8b       	std	Z+23, r19	; 0x17
     3e4:	11 8e       	std	Z+25, r1	; 0x19
     3e6:	10 8e       	std	Z+24, r1	; 0x18
     3e8:	13 8e       	std	Z+27, r1	; 0x1b
     3ea:	12 8e       	std	Z+26, r1	; 0x1a
     3ec:	15 8e       	std	Z+29, r1	; 0x1d
     3ee:	14 8e       	std	Z+28, r1	; 0x1c

	++index;

	c.ppm = 3.0;
	c.p = {0, 0, 0};
	Ammonia[index] = c;
     3f0:	00 e0       	ldi	r16, 0x00	; 0
     3f2:	10 e0       	ldi	r17, 0x00	; 0
     3f4:	20 e4       	ldi	r18, 0x40	; 64
     3f6:	30 e4       	ldi	r19, 0x40	; 64
     3f8:	0e 8f       	std	Y+30, r16	; 0x1e
     3fa:	1f 8f       	std	Y+31, r17	; 0x1f
     3fc:	28 a3       	std	Y+32, r18	; 0x20
     3fe:	39 a3       	std	Y+33, r19	; 0x21
     400:	1b a2       	std	Y+35, r1	; 0x23
     402:	1a a2       	std	Y+34, r1	; 0x22
     404:	1d a2       	std	Y+37, r1	; 0x25
     406:	1c a2       	std	Y+36, r1	; 0x24
     408:	1f a2       	std	Y+39, r1	; 0x27
     40a:	1e a2       	std	Y+38, r1	; 0x26

	c.ppm = 1.0;
	c.p = {0, 0, 0};
	Nitrite[index] = c;
     40c:	5e 96       	adiw	r26, 0x1e	; 30
     40e:	4d 93       	st	X+, r20
     410:	5d 93       	st	X+, r21
     412:	6d 93       	st	X+, r22
     414:	7c 93       	st	X, r23
     416:	91 97       	sbiw	r26, 0x21	; 33
     418:	93 96       	adiw	r26, 0x23	; 35
     41a:	1c 92       	st	X, r1
     41c:	1e 92       	st	-X, r1
     41e:	92 97       	sbiw	r26, 0x22	; 34
     420:	95 96       	adiw	r26, 0x25	; 37
     422:	1c 92       	st	X, r1
     424:	1e 92       	st	-X, r1
     426:	94 97       	sbiw	r26, 0x24	; 36
     428:	97 96       	adiw	r26, 0x27	; 39
     42a:	1c 92       	st	X, r1
     42c:	1e 92       	st	-X, r1
     42e:	96 97       	sbiw	r26, 0x26	; 38

	c.ppm = 5.0;
	c.p = {0, 0, 0};
	Nitrate[index] = c;
     430:	40 e0       	ldi	r20, 0x00	; 0
     432:	50 e0       	ldi	r21, 0x00	; 0
     434:	60 ea       	ldi	r22, 0xA0	; 160
     436:	70 e4       	ldi	r23, 0x40	; 64
     438:	46 8f       	std	Z+30, r20	; 0x1e
     43a:	57 8f       	std	Z+31, r21	; 0x1f
     43c:	60 a3       	std	Z+32, r22	; 0x20
     43e:	71 a3       	std	Z+33, r23	; 0x21
     440:	13 a2       	std	Z+35, r1	; 0x23
     442:	12 a2       	std	Z+34, r1	; 0x22
     444:	15 a2       	std	Z+37, r1	; 0x25
     446:	14 a2       	std	Z+36, r1	; 0x24
     448:	17 a2       	std	Z+39, r1	; 0x27
     44a:	16 a2       	std	Z+38, r1	; 0x26

	++index;

	c.ppm = 6.0;
	c.p = {0, 0, 0};
	Ammonia[index] = c;
     44c:	40 e0       	ldi	r20, 0x00	; 0
     44e:	50 e0       	ldi	r21, 0x00	; 0
     450:	60 ec       	ldi	r22, 0xC0	; 192
     452:	70 e4       	ldi	r23, 0x40	; 64
     454:	48 a7       	std	Y+40, r20	; 0x28
     456:	59 a7       	std	Y+41, r21	; 0x29
     458:	6a a7       	std	Y+42, r22	; 0x2a
     45a:	7b a7       	std	Y+43, r23	; 0x2b
     45c:	1d a6       	std	Y+45, r1	; 0x2d
     45e:	1c a6       	std	Y+44, r1	; 0x2c
     460:	1f a6       	std	Y+47, r1	; 0x2f
     462:	1e a6       	std	Y+46, r1	; 0x2e
     464:	19 aa       	std	Y+49, r1	; 0x31
     466:	18 aa       	std	Y+48, r1	; 0x30

	c.ppm = 1.5;
	c.p = {0, 0, 0};
	Nitrite[index] = c;
     468:	40 e0       	ldi	r20, 0x00	; 0
     46a:	50 e0       	ldi	r21, 0x00	; 0
     46c:	60 ec       	ldi	r22, 0xC0	; 192
     46e:	7f e3       	ldi	r23, 0x3F	; 63
     470:	98 96       	adiw	r26, 0x28	; 40
     472:	4d 93       	st	X+, r20
     474:	5d 93       	st	X+, r21
     476:	6d 93       	st	X+, r22
     478:	7c 93       	st	X, r23
     47a:	9b 97       	sbiw	r26, 0x2b	; 43
     47c:	9d 96       	adiw	r26, 0x2d	; 45
     47e:	1c 92       	st	X, r1
     480:	1e 92       	st	-X, r1
     482:	9c 97       	sbiw	r26, 0x2c	; 44
     484:	9f 96       	adiw	r26, 0x2f	; 47
     486:	1c 92       	st	X, r1
     488:	1e 92       	st	-X, r1
     48a:	9e 97       	sbiw	r26, 0x2e	; 46
     48c:	d1 96       	adiw	r26, 0x31	; 49
     48e:	1c 92       	st	X, r1
     490:	1e 92       	st	-X, r1
     492:	d0 97       	sbiw	r26, 0x30	; 48

	c.ppm = 10.0;
	c.p = {0, 0, 0};
	Nitrate[index] = c;
     494:	40 e0       	ldi	r20, 0x00	; 0
     496:	50 e0       	ldi	r21, 0x00	; 0
     498:	60 e2       	ldi	r22, 0x20	; 32
     49a:	71 e4       	ldi	r23, 0x41	; 65
     49c:	40 a7       	std	Z+40, r20	; 0x28
     49e:	51 a7       	std	Z+41, r21	; 0x29
     4a0:	62 a7       	std	Z+42, r22	; 0x2a
     4a2:	73 a7       	std	Z+43, r23	; 0x2b
     4a4:	15 a6       	std	Z+45, r1	; 0x2d
     4a6:	14 a6       	std	Z+44, r1	; 0x2c
     4a8:	17 a6       	std	Z+47, r1	; 0x2f
     4aa:	16 a6       	std	Z+46, r1	; 0x2e
     4ac:	11 aa       	std	Z+49, r1	; 0x31
     4ae:	10 aa       	std	Z+48, r1	; 0x30

	++index;

	c.ppm = 3.0;
	c.p = {0, 0, 0};
	Nitrite[index] = c;
     4b0:	d2 96       	adiw	r26, 0x32	; 50
     4b2:	0d 93       	st	X+, r16
     4b4:	1d 93       	st	X+, r17
     4b6:	2d 93       	st	X+, r18
     4b8:	3c 93       	st	X, r19
     4ba:	d5 97       	sbiw	r26, 0x35	; 53
     4bc:	d7 96       	adiw	r26, 0x37	; 55
     4be:	1c 92       	st	X, r1
     4c0:	1e 92       	st	-X, r1
     4c2:	d6 97       	sbiw	r26, 0x36	; 54
     4c4:	d9 96       	adiw	r26, 0x39	; 57
     4c6:	1c 92       	st	X, r1
     4c8:	1e 92       	st	-X, r1
     4ca:	d8 97       	sbiw	r26, 0x38	; 56
     4cc:	db 96       	adiw	r26, 0x3b	; 59
     4ce:	1c 92       	st	X, r1
     4d0:	1e 92       	st	-X, r1
     4d2:	da 97       	sbiw	r26, 0x3a	; 58

	c.ppm = 20.0;
	c.p = {0, 0, 0};
	Nitrate[index] = c;
     4d4:	00 e0       	ldi	r16, 0x00	; 0
     4d6:	10 e0       	ldi	r17, 0x00	; 0
     4d8:	20 ea       	ldi	r18, 0xA0	; 160
     4da:	31 e4       	ldi	r19, 0x41	; 65
     4dc:	02 ab       	std	Z+50, r16	; 0x32
     4de:	13 ab       	std	Z+51, r17	; 0x33
     4e0:	24 ab       	std	Z+52, r18	; 0x34
     4e2:	35 ab       	std	Z+53, r19	; 0x35
     4e4:	17 aa       	std	Z+55, r1	; 0x37
     4e6:	16 aa       	std	Z+54, r1	; 0x36
     4e8:	11 ae       	std	Z+57, r1	; 0x39
     4ea:	10 ae       	std	Z+56, r1	; 0x38
     4ec:	13 ae       	std	Z+59, r1	; 0x3b
     4ee:	12 ae       	std	Z+58, r1	; 0x3a

	++index;

	c.ppm = 10.0;
	c.p = {0, 0, 0};
	Nitrite[index] = c;
     4f0:	dc 96       	adiw	r26, 0x3c	; 60
     4f2:	4d 93       	st	X+, r20
     4f4:	5d 93       	st	X+, r21
     4f6:	6d 93       	st	X+, r22
     4f8:	7c 93       	st	X, r23
     4fa:	df 97       	sbiw	r26, 0x3f	; 63
     4fc:	10 92 16 03 	sts	0x0316, r1	; 0x800316 <Nitrite+0x41>
     500:	10 92 15 03 	sts	0x0315, r1	; 0x800315 <Nitrite+0x40>
     504:	10 92 18 03 	sts	0x0318, r1	; 0x800318 <Nitrite+0x43>
     508:	10 92 17 03 	sts	0x0317, r1	; 0x800317 <Nitrite+0x42>
     50c:	10 92 1a 03 	sts	0x031A, r1	; 0x80031a <Nitrite+0x45>
     510:	10 92 19 03 	sts	0x0319, r1	; 0x800319 <Nitrite+0x44>

	c.ppm = 50.0;
	c.p = {0, 0, 0};
	Nitrate[index] = c;
     514:	80 e0       	ldi	r24, 0x00	; 0
     516:	90 e0       	ldi	r25, 0x00	; 0
     518:	a8 e4       	ldi	r26, 0x48	; 72
     51a:	b2 e4       	ldi	r27, 0x42	; 66
     51c:	84 af       	std	Z+60, r24	; 0x3c
     51e:	95 af       	std	Z+61, r25	; 0x3d
     520:	a6 af       	std	Z+62, r26	; 0x3e
     522:	b7 af       	std	Z+63, r27	; 0x3f
     524:	10 92 d0 02 	sts	0x02D0, r1	; 0x8002d0 <Nitrate+0x41>
     528:	10 92 cf 02 	sts	0x02CF, r1	; 0x8002cf <Nitrate+0x40>
     52c:	10 92 d2 02 	sts	0x02D2, r1	; 0x8002d2 <Nitrate+0x43>
     530:	10 92 d1 02 	sts	0x02D1, r1	; 0x8002d1 <Nitrate+0x42>
     534:	10 92 d4 02 	sts	0x02D4, r1	; 0x8002d4 <Nitrate+0x45>
     538:	10 92 d3 02 	sts	0x02D3, r1	; 0x8002d3 <Nitrate+0x44>
}
     53c:	df 91       	pop	r29
     53e:	cf 91       	pop	r28
     540:	1f 91       	pop	r17
     542:	0f 91       	pop	r16
     544:	08 95       	ret

00000546 <_Z9SameColorv>:


bool SameColor()
{
	Serial.print("c: ");
     546:	62 e4       	ldi	r22, 0x42	; 66
     548:	71 e0       	ldi	r23, 0x01	; 1
     54a:	83 e2       	ldi	r24, 0x23	; 35
     54c:	94 e0       	ldi	r25, 0x04	; 4
     54e:	0e 94 3b 1f 	call	0x3e76	; 0x3e76 <_ZN5Print5printEPKc>
	Serial.print(c.p.R);
     552:	60 91 86 02 	lds	r22, 0x0286	; 0x800286 <c+0x4>
     556:	70 91 87 02 	lds	r23, 0x0287	; 0x800287 <c+0x5>
     55a:	4a e0       	ldi	r20, 0x0A	; 10
     55c:	50 e0       	ldi	r21, 0x00	; 0
     55e:	83 e2       	ldi	r24, 0x23	; 35
     560:	94 e0       	ldi	r25, 0x04	; 4
     562:	0e 94 11 20 	call	0x4022	; 0x4022 <_ZN5Print5printEii>
	Serial.print(" ");
     566:	64 e4       	ldi	r22, 0x44	; 68
     568:	71 e0       	ldi	r23, 0x01	; 1
     56a:	83 e2       	ldi	r24, 0x23	; 35
     56c:	94 e0       	ldi	r25, 0x04	; 4
     56e:	0e 94 3b 1f 	call	0x3e76	; 0x3e76 <_ZN5Print5printEPKc>
	Serial.print(c.p.G);
     572:	60 91 88 02 	lds	r22, 0x0288	; 0x800288 <c+0x6>
     576:	70 91 89 02 	lds	r23, 0x0289	; 0x800289 <c+0x7>
     57a:	4a e0       	ldi	r20, 0x0A	; 10
     57c:	50 e0       	ldi	r21, 0x00	; 0
     57e:	83 e2       	ldi	r24, 0x23	; 35
     580:	94 e0       	ldi	r25, 0x04	; 4
     582:	0e 94 11 20 	call	0x4022	; 0x4022 <_ZN5Print5printEii>
	Serial.print(" ");
     586:	64 e4       	ldi	r22, 0x44	; 68
     588:	71 e0       	ldi	r23, 0x01	; 1
     58a:	83 e2       	ldi	r24, 0x23	; 35
     58c:	94 e0       	ldi	r25, 0x04	; 4
     58e:	0e 94 3b 1f 	call	0x3e76	; 0x3e76 <_ZN5Print5printEPKc>
	Serial.print(c.p.B);
     592:	60 91 8a 02 	lds	r22, 0x028A	; 0x80028a <c+0x8>
     596:	70 91 8b 02 	lds	r23, 0x028B	; 0x80028b <c+0x9>
     59a:	4a e0       	ldi	r20, 0x0A	; 10
     59c:	50 e0       	ldi	r21, 0x00	; 0
     59e:	83 e2       	ldi	r24, 0x23	; 35
     5a0:	94 e0       	ldi	r25, 0x04	; 4
     5a2:	0e 94 11 20 	call	0x4022	; 0x4022 <_ZN5Print5printEii>
	Serial.print("read_in: ");
     5a6:	66 e4       	ldi	r22, 0x46	; 70
     5a8:	71 e0       	ldi	r23, 0x01	; 1
     5aa:	83 e2       	ldi	r24, 0x23	; 35
     5ac:	94 e0       	ldi	r25, 0x04	; 4
     5ae:	0e 94 3b 1f 	call	0x3e76	; 0x3e76 <_ZN5Print5printEPKc>
	Serial.print(redScanned);
     5b2:	4a e0       	ldi	r20, 0x0A	; 10
     5b4:	50 e0       	ldi	r21, 0x00	; 0
     5b6:	60 91 80 02 	lds	r22, 0x0280	; 0x800280 <redScanned>
     5ba:	83 e2       	ldi	r24, 0x23	; 35
     5bc:	94 e0       	ldi	r25, 0x04	; 4
     5be:	0e 94 b0 1f 	call	0x3f60	; 0x3f60 <_ZN5Print5printEhi>
	Serial.print(" ");
     5c2:	64 e4       	ldi	r22, 0x44	; 68
     5c4:	71 e0       	ldi	r23, 0x01	; 1
     5c6:	83 e2       	ldi	r24, 0x23	; 35
     5c8:	94 e0       	ldi	r25, 0x04	; 4
     5ca:	0e 94 3b 1f 	call	0x3e76	; 0x3e76 <_ZN5Print5printEPKc>
	Serial.print(greenScanned);
     5ce:	4a e0       	ldi	r20, 0x0A	; 10
     5d0:	50 e0       	ldi	r21, 0x00	; 0
     5d2:	60 91 81 02 	lds	r22, 0x0281	; 0x800281 <greenScanned>
     5d6:	83 e2       	ldi	r24, 0x23	; 35
     5d8:	94 e0       	ldi	r25, 0x04	; 4
     5da:	0e 94 b0 1f 	call	0x3f60	; 0x3f60 <_ZN5Print5printEhi>
	Serial.print(" ");
     5de:	64 e4       	ldi	r22, 0x44	; 68
     5e0:	71 e0       	ldi	r23, 0x01	; 1
     5e2:	83 e2       	ldi	r24, 0x23	; 35
     5e4:	94 e0       	ldi	r25, 0x04	; 4
     5e6:	0e 94 3b 1f 	call	0x3e76	; 0x3e76 <_ZN5Print5printEPKc>
	Serial.print(blueScanned);
     5ea:	4a e0       	ldi	r20, 0x0A	; 10
     5ec:	50 e0       	ldi	r21, 0x00	; 0
     5ee:	60 91 7f 02 	lds	r22, 0x027F	; 0x80027f <blueScanned>
     5f2:	83 e2       	ldi	r24, 0x23	; 35
     5f4:	94 e0       	ldi	r25, 0x04	; 4
     5f6:	0e 94 b0 1f 	call	0x3f60	; 0x3f60 <_ZN5Print5printEhi>
	// check if RGB values are within range specified by tolerance
	if (redScanned < (c.p.R - TOLERANCE) || redScanned > (c.p.R + TOLERANCE))
     5fa:	20 91 80 02 	lds	r18, 0x0280	; 0x800280 <redScanned>
     5fe:	30 e0       	ldi	r19, 0x00	; 0
     600:	80 91 86 02 	lds	r24, 0x0286	; 0x800286 <c+0x4>
     604:	90 91 87 02 	lds	r25, 0x0287	; 0x800287 <c+0x5>
     608:	ac 01       	movw	r20, r24
     60a:	45 50       	subi	r20, 0x05	; 5
     60c:	51 09       	sbc	r21, r1
     60e:	24 17       	cp	r18, r20
     610:	35 07       	cpc	r19, r21
     612:	74 f1       	brlt	.+92     	; 0x670 <_Z9SameColorv+0x12a>
     614:	05 96       	adiw	r24, 0x05	; 5
     616:	82 17       	cp	r24, r18
     618:	93 07       	cpc	r25, r19
     61a:	54 f1       	brlt	.+84     	; 0x670 <_Z9SameColorv+0x12a>
		return false;
	if (greenScanned < (c.p.G - TOLERANCE) || greenScanned > (c.p.G + TOLERANCE))
     61c:	20 91 81 02 	lds	r18, 0x0281	; 0x800281 <greenScanned>
     620:	30 e0       	ldi	r19, 0x00	; 0
     622:	80 91 88 02 	lds	r24, 0x0288	; 0x800288 <c+0x6>
     626:	90 91 89 02 	lds	r25, 0x0289	; 0x800289 <c+0x7>
     62a:	ac 01       	movw	r20, r24
     62c:	45 50       	subi	r20, 0x05	; 5
     62e:	51 09       	sbc	r21, r1
     630:	24 17       	cp	r18, r20
     632:	35 07       	cpc	r19, r21
     634:	ec f0       	brlt	.+58     	; 0x670 <_Z9SameColorv+0x12a>
     636:	05 96       	adiw	r24, 0x05	; 5
     638:	82 17       	cp	r24, r18
     63a:	93 07       	cpc	r25, r19
     63c:	cc f0       	brlt	.+50     	; 0x670 <_Z9SameColorv+0x12a>
		return false;
	if (blueScanned < (c.p.B - TOLERANCE) || blueScanned > (c.p.B + TOLERANCE))
     63e:	20 91 7f 02 	lds	r18, 0x027F	; 0x80027f <blueScanned>
     642:	30 e0       	ldi	r19, 0x00	; 0
     644:	80 91 8a 02 	lds	r24, 0x028A	; 0x80028a <c+0x8>
     648:	90 91 8b 02 	lds	r25, 0x028B	; 0x80028b <c+0x9>
     64c:	ac 01       	movw	r20, r24
     64e:	45 50       	subi	r20, 0x05	; 5
     650:	51 09       	sbc	r21, r1
     652:	24 17       	cp	r18, r20
     654:	35 07       	cpc	r19, r21
     656:	64 f0       	brlt	.+24     	; 0x670 <_Z9SameColorv+0x12a>
     658:	05 96       	adiw	r24, 0x05	; 5
     65a:	82 17       	cp	r24, r18
     65c:	93 07       	cpc	r25, r19
     65e:	44 f0       	brlt	.+16     	; 0x670 <_Z9SameColorv+0x12a>
		return false;
	
	Serial.print(F("\nFound Matching Color"));
     660:	6c e7       	ldi	r22, 0x7C	; 124
     662:	70 e0       	ldi	r23, 0x00	; 0
     664:	83 e2       	ldi	r24, 0x23	; 35
     666:	94 e0       	ldi	r25, 0x04	; 4
     668:	0e 94 17 1f 	call	0x3e2e	; 0x3e2e <_ZN5Print5printEPK19__FlashStringHelper>
	return true;
     66c:	81 e0       	ldi	r24, 0x01	; 1
     66e:	08 95       	ret
	Serial.print(greenScanned);
	Serial.print(" ");
	Serial.print(blueScanned);
	// check if RGB values are within range specified by tolerance
	if (redScanned < (c.p.R - TOLERANCE) || redScanned > (c.p.R + TOLERANCE))
		return false;
     670:	80 e0       	ldi	r24, 0x00	; 0
	if (blueScanned < (c.p.B - TOLERANCE) || blueScanned > (c.p.B + TOLERANCE))
		return false;
	
	Serial.print(F("\nFound Matching Color"));
	return true;
}
     672:	08 95       	ret

00000674 <_Z9FindMatchv>:

double FindMatch()
{
     674:	0f 93       	push	r16
     676:	1f 93       	push	r17
     678:	cf 93       	push	r28
     67a:	df 93       	push	r29
	switch(typeToRead)
     67c:	80 91 4d 03 	lds	r24, 0x034D	; 0x80034d <typeToRead>
     680:	81 30       	cpi	r24, 0x01	; 1
     682:	09 f4       	brne	.+2      	; 0x686 <_Z9FindMatchv+0x12>
     684:	48 c0       	rjmp	.+144    	; 0x716 <_Z9FindMatchv+0xa2>
     686:	40 f0       	brcs	.+16     	; 0x698 <_Z9FindMatchv+0x24>
     688:	82 30       	cpi	r24, 0x02	; 2
     68a:	09 f0       	breq	.+2      	; 0x68e <_Z9FindMatchv+0x1a>
     68c:	6e c0       	rjmp	.+220    	; 0x76a <_Z9FindMatchv+0xf6>
     68e:	05 ed       	ldi	r16, 0xD5	; 213
     690:	12 e0       	ldi	r17, 0x02	; 2
     692:	c6 e0       	ldi	r28, 0x06	; 6
     694:	d0 e0       	ldi	r29, 0x00	; 0
     696:	29 c0       	rjmp	.+82     	; 0x6ea <_Z9FindMatchv+0x76>
     698:	0b e1       	ldi	r16, 0x1B	; 27
     69a:	13 e0       	ldi	r17, 0x03	; 3
     69c:	c4 e0       	ldi	r28, 0x04	; 4
     69e:	d0 e0       	ldi	r29, 0x00	; 0
		case AMMONIA:
		{
			// start at highest ammonia level - false positive better than false negative
			for(int i = MAX_AMMONIA_COLORS - 1; i >= 0; --i)
			{
				c = Ammonia[i];
     6a0:	8a e0       	ldi	r24, 0x0A	; 10
     6a2:	f8 01       	movw	r30, r16
     6a4:	b8 96       	adiw	r30, 0x28	; 40
     6a6:	a2 e8       	ldi	r26, 0x82	; 130
     6a8:	b2 e0       	ldi	r27, 0x02	; 2
     6aa:	01 90       	ld	r0, Z+
     6ac:	0d 92       	st	X+, r0
     6ae:	8a 95       	dec	r24
     6b0:	e1 f7       	brne	.-8      	; 0x6aa <_Z9FindMatchv+0x36>
				if(SameColor())
     6b2:	0e 94 a3 02 	call	0x546	; 0x546 <_Z9SameColorv>
     6b6:	88 23       	and	r24, r24
     6b8:	49 f0       	breq	.+18     	; 0x6cc <_Z9FindMatchv+0x58>
				return Ammonia[i].ppm;
     6ba:	8a e0       	ldi	r24, 0x0A	; 10
     6bc:	8c 9f       	mul	r24, r28
     6be:	f0 01       	movw	r30, r0
     6c0:	8d 9f       	mul	r24, r29
     6c2:	f0 0d       	add	r31, r0
     6c4:	11 24       	eor	r1, r1
     6c6:	e5 5e       	subi	r30, 0xE5	; 229
     6c8:	fc 4f       	sbci	r31, 0xFC	; 252
     6ca:	3e c0       	rjmp	.+124    	; 0x748 <_Z9FindMatchv+0xd4>
	switch(typeToRead)
	{
		case AMMONIA:
		{
			// start at highest ammonia level - false positive better than false negative
			for(int i = MAX_AMMONIA_COLORS - 1; i >= 0; --i)
     6cc:	21 97       	sbiw	r28, 0x01	; 1
     6ce:	0a 50       	subi	r16, 0x0A	; 10
     6d0:	11 09       	sbc	r17, r1
     6d2:	cf 3f       	cpi	r28, 0xFF	; 255
     6d4:	8f ef       	ldi	r24, 0xFF	; 255
     6d6:	d8 07       	cpc	r29, r24
     6d8:	19 f7       	brne	.-58     	; 0x6a0 <_Z9FindMatchv+0x2c>
     6da:	42 c0       	rjmp	.+132    	; 0x760 <_Z9FindMatchv+0xec>
			break;
		}
		case NITRITE:
		{
			// start at highest nitrite level - false positive better than false negative
			for(int i = MAX_NITRITE_NITRATE_COLORS - 1; i >= 0; --i)
     6dc:	21 97       	sbiw	r28, 0x01	; 1
     6de:	0a 50       	subi	r16, 0x0A	; 10
     6e0:	11 09       	sbc	r17, r1
     6e2:	cf 3f       	cpi	r28, 0xFF	; 255
     6e4:	8f ef       	ldi	r24, 0xFF	; 255
     6e6:	d8 07       	cpc	r29, r24
     6e8:	d9 f1       	breq	.+118    	; 0x760 <_Z9FindMatchv+0xec>
			{
				c = Nitrite[i];
     6ea:	8a e0       	ldi	r24, 0x0A	; 10
     6ec:	f8 01       	movw	r30, r16
     6ee:	fc 96       	adiw	r30, 0x3c	; 60
     6f0:	a2 e8       	ldi	r26, 0x82	; 130
     6f2:	b2 e0       	ldi	r27, 0x02	; 2
     6f4:	01 90       	ld	r0, Z+
     6f6:	0d 92       	st	X+, r0
     6f8:	8a 95       	dec	r24
     6fa:	e1 f7       	brne	.-8      	; 0x6f4 <_Z9FindMatchv+0x80>
				if(SameColor())
     6fc:	0e 94 a3 02 	call	0x546	; 0x546 <_Z9SameColorv>
     700:	88 23       	and	r24, r24
     702:	61 f3       	breq	.-40     	; 0x6dc <_Z9FindMatchv+0x68>
				return Nitrite[i].ppm;
     704:	8a e0       	ldi	r24, 0x0A	; 10
     706:	8c 9f       	mul	r24, r28
     708:	f0 01       	movw	r30, r0
     70a:	8d 9f       	mul	r24, r29
     70c:	f0 0d       	add	r31, r0
     70e:	11 24       	eor	r1, r1
     710:	eb 52       	subi	r30, 0x2B	; 43
     712:	fd 4f       	sbci	r31, 0xFD	; 253
     714:	19 c0       	rjmp	.+50     	; 0x748 <_Z9FindMatchv+0xd4>
     716:	0f e8       	ldi	r16, 0x8F	; 143
     718:	12 e0       	ldi	r17, 0x02	; 2
	return true;
}

double FindMatch()
{
	switch(typeToRead)
     71a:	c6 e0       	ldi	r28, 0x06	; 6
     71c:	d0 e0       	ldi	r29, 0x00	; 0
		case NITRATE:
		{
			// start at highest nitrate level - false positive better than false negative
			for(int i = MAX_NITRITE_NITRATE_COLORS - 1; i >= 0; --i)
			{
				c = Nitrate[i];
     71e:	8a e0       	ldi	r24, 0x0A	; 10
     720:	f8 01       	movw	r30, r16
     722:	fc 96       	adiw	r30, 0x3c	; 60
     724:	a2 e8       	ldi	r26, 0x82	; 130
     726:	b2 e0       	ldi	r27, 0x02	; 2
     728:	01 90       	ld	r0, Z+
     72a:	0d 92       	st	X+, r0
     72c:	8a 95       	dec	r24
     72e:	e1 f7       	brne	.-8      	; 0x728 <_Z9FindMatchv+0xb4>
				if(SameColor())
     730:	0e 94 a3 02 	call	0x546	; 0x546 <_Z9SameColorv>
     734:	88 23       	and	r24, r24
     736:	69 f0       	breq	.+26     	; 0x752 <_Z9FindMatchv+0xde>
				return Nitrate[i].ppm;
     738:	8a e0       	ldi	r24, 0x0A	; 10
     73a:	8c 9f       	mul	r24, r28
     73c:	f0 01       	movw	r30, r0
     73e:	8d 9f       	mul	r24, r29
     740:	f0 0d       	add	r31, r0
     742:	11 24       	eor	r1, r1
     744:	e1 57       	subi	r30, 0x71	; 113
     746:	fd 4f       	sbci	r31, 0xFD	; 253
     748:	30 81       	ld	r19, Z
     74a:	21 81       	ldd	r18, Z+1	; 0x01
     74c:	92 81       	ldd	r25, Z+2	; 0x02
     74e:	83 81       	ldd	r24, Z+3	; 0x03
     750:	0b c0       	rjmp	.+22     	; 0x768 <_Z9FindMatchv+0xf4>
			break;
		}
		case NITRATE:
		{
			// start at highest nitrate level - false positive better than false negative
			for(int i = MAX_NITRITE_NITRATE_COLORS - 1; i >= 0; --i)
     752:	21 97       	sbiw	r28, 0x01	; 1
     754:	0a 50       	subi	r16, 0x0A	; 10
     756:	11 09       	sbc	r17, r1
     758:	cf 3f       	cpi	r28, 0xFF	; 255
     75a:	8f ef       	ldi	r24, 0xFF	; 255
     75c:	d8 07       	cpc	r29, r24
     75e:	f9 f6       	brne	.-66     	; 0x71e <_Z9FindMatchv+0xaa>
			{
				c = Ammonia[i];
				if(SameColor())
				return Ammonia[i].ppm;
			}
			return -1;
     760:	30 e0       	ldi	r19, 0x00	; 0
     762:	20 e0       	ldi	r18, 0x00	; 0
     764:	90 e8       	ldi	r25, 0x80	; 128
     766:	8f eb       	ldi	r24, 0xBF	; 191
     768:	ac 01       	movw	r20, r24
			}
			return -1;
			break;
		}
	}
}
     76a:	63 2f       	mov	r22, r19
     76c:	72 2f       	mov	r23, r18
     76e:	85 2f       	mov	r24, r21
     770:	94 2f       	mov	r25, r20
     772:	df 91       	pop	r29
     774:	cf 91       	pop	r28
     776:	1f 91       	pop	r17
     778:	0f 91       	pop	r16
     77a:	08 95       	ret

0000077c <_Z9ScanColorv>:

long ScanColor()
{
	CS.read();
     77c:	80 e5       	ldi	r24, 0x50	; 80
     77e:	92 e0       	ldi	r25, 0x02	; 2
     780:	0e 94 4d 18 	call	0x309a	; 0x309a <_ZN9MD_TCS2304readEv>
	while(CS.available() == 0);  // wait for read to complete
     784:	80 e5       	ldi	r24, 0x50	; 80
     786:	92 e0       	ldi	r25, 0x02	; 2
     788:	0e 94 57 18 	call	0x30ae	; 0x30ae <_ZN9MD_TCS2309availableEv>
     78c:	88 23       	and	r24, r24
     78e:	d1 f3       	breq	.-12     	; 0x784 <_Z9ScanColorv+0x8>
	CS.getRGB(&rgb);
     790:	6c e8       	ldi	r22, 0x8C	; 140
     792:	72 e0       	ldi	r23, 0x02	; 2
     794:	80 e5       	ldi	r24, 0x50	; 80
     796:	92 e0       	ldi	r25, 0x02	; 2
     798:	0e 94 83 17 	call	0x2f06	; 0x2f06 <_ZN9MD_TCS2306getRGBEP9colorData>
	greenScanned = rgb.value[TCS230_RGB_G];
     79c:	80 91 8d 02 	lds	r24, 0x028D	; 0x80028d <rgb+0x1>
     7a0:	80 93 81 02 	sts	0x0281, r24	; 0x800281 <greenScanned>
	redScanned = rgb.value[TCS230_RGB_R];
     7a4:	80 91 8c 02 	lds	r24, 0x028C	; 0x80028c <rgb>
     7a8:	80 93 80 02 	sts	0x0280, r24	; 0x800280 <redScanned>
	blueScanned = rgb.value[TCS230_RGB_B];
     7ac:	80 91 8e 02 	lds	r24, 0x028E	; 0x80028e <rgb+0x2>
     7b0:	80 93 7f 02 	sts	0x027F, r24	; 0x80027f <blueScanned>
	// look for match
	Serial.println("RGB");
     7b4:	60 e5       	ldi	r22, 0x50	; 80
     7b6:	71 e0       	ldi	r23, 0x01	; 1
     7b8:	83 e2       	ldi	r24, 0x23	; 35
     7ba:	94 e0       	ldi	r25, 0x04	; 4
     7bc:	0e 94 48 1f 	call	0x3e90	; 0x3e90 <_ZN5Print7printlnEPKc>
	Serial.println(redScanned);
     7c0:	4a e0       	ldi	r20, 0x0A	; 10
     7c2:	50 e0       	ldi	r21, 0x00	; 0
     7c4:	60 91 80 02 	lds	r22, 0x0280	; 0x800280 <redScanned>
     7c8:	83 e2       	ldi	r24, 0x23	; 35
     7ca:	94 e0       	ldi	r25, 0x04	; 4
     7cc:	0e 94 b7 1f 	call	0x3f6e	; 0x3f6e <_ZN5Print7printlnEhi>
	Serial.println(greenScanned);
     7d0:	4a e0       	ldi	r20, 0x0A	; 10
     7d2:	50 e0       	ldi	r21, 0x00	; 0
     7d4:	60 91 81 02 	lds	r22, 0x0281	; 0x800281 <greenScanned>
     7d8:	83 e2       	ldi	r24, 0x23	; 35
     7da:	94 e0       	ldi	r25, 0x04	; 4
     7dc:	0e 94 b7 1f 	call	0x3f6e	; 0x3f6e <_ZN5Print7printlnEhi>
	Serial.println(blueScanned);
     7e0:	4a e0       	ldi	r20, 0x0A	; 10
     7e2:	50 e0       	ldi	r21, 0x00	; 0
     7e4:	60 91 7f 02 	lds	r22, 0x027F	; 0x80027f <blueScanned>
     7e8:	83 e2       	ldi	r24, 0x23	; 35
     7ea:	94 e0       	ldi	r25, 0x04	; 4
     7ec:	0e 94 b7 1f 	call	0x3f6e	; 0x3f6e <_ZN5Print7printlnEhi>
	//return FindMatch();
}
     7f0:	08 95       	ret

000007f2 <_Z13findTestStripv>:

bool findTestStrip()
{
     7f2:	cf 93       	push	r28
	// Scan for color
	CS.read();
     7f4:	80 e5       	ldi	r24, 0x50	; 80
     7f6:	92 e0       	ldi	r25, 0x02	; 2
     7f8:	0e 94 4d 18 	call	0x309a	; 0x309a <_ZN9MD_TCS2304readEv>
	while (CS.available() == 0);
     7fc:	80 e5       	ldi	r24, 0x50	; 80
     7fe:	92 e0       	ldi	r25, 0x02	; 2
     800:	0e 94 57 18 	call	0x30ae	; 0x30ae <_ZN9MD_TCS2309availableEv>
     804:	88 23       	and	r24, r24
     806:	d1 f3       	breq	.-12     	; 0x7fc <_Z13findTestStripv+0xa>
	CS.getRGB(&rgb);
     808:	6c e8       	ldi	r22, 0x8C	; 140
     80a:	72 e0       	ldi	r23, 0x02	; 2
     80c:	80 e5       	ldi	r24, 0x50	; 80
     80e:	92 e0       	ldi	r25, 0x02	; 2
     810:	0e 94 83 17 	call	0x2f06	; 0x2f06 <_ZN9MD_TCS2306getRGBEP9colorData>
	greenScanned = rgb.value[TCS230_RGB_G];
     814:	80 91 8d 02 	lds	r24, 0x028D	; 0x80028d <rgb+0x1>
     818:	80 93 81 02 	sts	0x0281, r24	; 0x800281 <greenScanned>
	redScanned = rgb.value[TCS230_RGB_R];
     81c:	80 91 8c 02 	lds	r24, 0x028C	; 0x80028c <rgb>
     820:	80 93 80 02 	sts	0x0280, r24	; 0x800280 <redScanned>
	blueScanned = rgb.value[TCS230_RGB_B];
     824:	80 91 8e 02 	lds	r24, 0x028E	; 0x80028e <rgb+0x2>
     828:	80 93 7f 02 	sts	0x027F, r24	; 0x80027f <blueScanned>
	// look for match against black
	c = EmptyTestBox;
     82c:	8a e0       	ldi	r24, 0x0A	; 10
     82e:	eb e2       	ldi	r30, 0x2B	; 43
     830:	f1 e0       	ldi	r31, 0x01	; 1
     832:	a2 e8       	ldi	r26, 0x82	; 130
     834:	b2 e0       	ldi	r27, 0x02	; 2
     836:	01 90       	ld	r0, Z+
     838:	0d 92       	st	X+, r0
     83a:	8a 95       	dec	r24
     83c:	e1 f7       	brne	.-8      	; 0x836 <_Z13findTestStripv+0x44>
	bool foundEmptyBox = SameColor();
     83e:	0e 94 a3 02 	call	0x546	; 0x546 <_Z9SameColorv>
     842:	c8 2f       	mov	r28, r24
	Serial.print(" foundEmptyBox ");
     844:	64 e5       	ldi	r22, 0x54	; 84
     846:	71 e0       	ldi	r23, 0x01	; 1
     848:	83 e2       	ldi	r24, 0x23	; 35
     84a:	94 e0       	ldi	r25, 0x04	; 4
     84c:	0e 94 3b 1f 	call	0x3e76	; 0x3e76 <_ZN5Print5printEPKc>
	Serial.println(foundEmptyBox);
     850:	6c 2f       	mov	r22, r28
     852:	70 e0       	ldi	r23, 0x00	; 0
     854:	4a e0       	ldi	r20, 0x0A	; 10
     856:	50 e0       	ldi	r21, 0x00	; 0
     858:	83 e2       	ldi	r24, 0x23	; 35
     85a:	94 e0       	ldi	r25, 0x04	; 4
     85c:	0e 94 18 20 	call	0x4030	; 0x4030 <_ZN5Print7printlnEii>
	Serial.print("\n");
     860:	68 e0       	ldi	r22, 0x08	; 8
     862:	72 e0       	ldi	r23, 0x02	; 2
     864:	83 e2       	ldi	r24, 0x23	; 35
     866:	94 e0       	ldi	r25, 0x04	; 4
     868:	0e 94 3b 1f 	call	0x3e76	; 0x3e76 <_ZN5Print5printEPKc>
	c = WhiteTestStrip;
     86c:	8a e0       	ldi	r24, 0x0A	; 10
     86e:	e1 e2       	ldi	r30, 0x21	; 33
     870:	f1 e0       	ldi	r31, 0x01	; 1
     872:	a2 e8       	ldi	r26, 0x82	; 130
     874:	b2 e0       	ldi	r27, 0x02	; 2
     876:	01 90       	ld	r0, Z+
     878:	0d 92       	st	X+, r0
     87a:	8a 95       	dec	r24
     87c:	e1 f7       	brne	.-8      	; 0x876 <_Z13findTestStripv+0x84>
	foundEmptyBox =  foundEmptyBox || SameColor();
     87e:	c1 11       	cpse	r28, r1
     880:	03 c0       	rjmp	.+6      	; 0x888 <_Z13findTestStripv+0x96>
     882:	0e 94 a3 02 	call	0x546	; 0x546 <_Z9SameColorv>
     886:	c8 2f       	mov	r28, r24
	Serial.print(" foundEmptyBoxOrTestStrip ");
     888:	64 e6       	ldi	r22, 0x64	; 100
     88a:	71 e0       	ldi	r23, 0x01	; 1
     88c:	83 e2       	ldi	r24, 0x23	; 35
     88e:	94 e0       	ldi	r25, 0x04	; 4
     890:	0e 94 3b 1f 	call	0x3e76	; 0x3e76 <_ZN5Print5printEPKc>
	Serial.println(foundEmptyBox);
     894:	6c 2f       	mov	r22, r28
     896:	70 e0       	ldi	r23, 0x00	; 0
     898:	4a e0       	ldi	r20, 0x0A	; 10
     89a:	50 e0       	ldi	r21, 0x00	; 0
     89c:	83 e2       	ldi	r24, 0x23	; 35
     89e:	94 e0       	ldi	r25, 0x04	; 4
     8a0:	0e 94 18 20 	call	0x4030	; 0x4030 <_ZN5Print7printlnEii>
	Serial.print("\n");
     8a4:	68 e0       	ldi	r22, 0x08	; 8
     8a6:	72 e0       	ldi	r23, 0x02	; 2
     8a8:	83 e2       	ldi	r24, 0x23	; 35
     8aa:	94 e0       	ldi	r25, 0x04	; 4
     8ac:	0e 94 3b 1f 	call	0x3e76	; 0x3e76 <_ZN5Print5printEPKc>
	return foundEmptyBox && (FindMatch() == -1);
     8b0:	cc 23       	and	r28, r28
     8b2:	51 f0       	breq	.+20     	; 0x8c8 <_Z13findTestStripv+0xd6>
     8b4:	0e 94 3a 03 	call	0x674	; 0x674 <_Z9FindMatchv>
     8b8:	c1 e0       	ldi	r28, 0x01	; 1
     8ba:	20 e0       	ldi	r18, 0x00	; 0
     8bc:	30 e0       	ldi	r19, 0x00	; 0
     8be:	40 e8       	ldi	r20, 0x80	; 128
     8c0:	5f eb       	ldi	r21, 0xBF	; 191
     8c2:	0e 94 42 1b 	call	0x3684	; 0x3684 <__cmpsf2>
     8c6:	81 11       	cpse	r24, r1
     8c8:	c0 e0       	ldi	r28, 0x00	; 0
     8ca:	8c 2f       	mov	r24, r28
     8cc:	cf 91       	pop	r28
     8ce:	08 95       	ret

000008d0 <_Z6setLED8LEDColor>:
LEDColor White = {255, 255, 255};
LEDColor Off = {0, 0, 0};


void setLED(LEDColor c)
{
     8d0:	cf 93       	push	r28
     8d2:	df 93       	push	r29
     8d4:	00 d0       	rcall	.+0      	; 0x8d6 <_Z6setLED8LEDColor+0x6>
     8d6:	00 d0       	rcall	.+0      	; 0x8d8 <_Z6setLED8LEDColor+0x8>
     8d8:	00 d0       	rcall	.+0      	; 0x8da <_Z6setLED8LEDColor+0xa>
     8da:	cd b7       	in	r28, 0x3d	; 61
     8dc:	de b7       	in	r29, 0x3e	; 62
     8de:	49 83       	std	Y+1, r20	; 0x01
     8e0:	5a 83       	std	Y+2, r21	; 0x02
     8e2:	6b 83       	std	Y+3, r22	; 0x03
     8e4:	7c 83       	std	Y+4, r23	; 0x04
     8e6:	8d 83       	std	Y+5, r24	; 0x05
     8e8:	9e 83       	std	Y+6, r25	; 0x06
	analogWrite(R_LED, c.r);
     8ea:	69 81       	ldd	r22, Y+1	; 0x01
     8ec:	7a 81       	ldd	r23, Y+2	; 0x02
     8ee:	8f e0       	ldi	r24, 0x0F	; 15
     8f0:	0e 94 a7 21 	call	0x434e	; 0x434e <analogWrite>
	analogWrite(G_LED, c.g);
     8f4:	6b 81       	ldd	r22, Y+3	; 0x03
     8f6:	7c 81       	ldd	r23, Y+4	; 0x04
     8f8:	80 e1       	ldi	r24, 0x10	; 16
     8fa:	0e 94 a7 21 	call	0x434e	; 0x434e <analogWrite>
	analogWrite(B_LED, c.b);
     8fe:	6d 81       	ldd	r22, Y+5	; 0x05
     900:	7e 81       	ldd	r23, Y+6	; 0x06
     902:	81 e1       	ldi	r24, 0x11	; 17
}
     904:	26 96       	adiw	r28, 0x06	; 6
     906:	0f b6       	in	r0, 0x3f	; 63
     908:	f8 94       	cli
     90a:	de bf       	out	0x3e, r29	; 62
     90c:	0f be       	out	0x3f, r0	; 63
     90e:	cd bf       	out	0x3d, r28	; 61
     910:	df 91       	pop	r29
     912:	cf 91       	pop	r28

void setLED(LEDColor c)
{
	analogWrite(R_LED, c.r);
	analogWrite(G_LED, c.g);
	analogWrite(B_LED, c.b);
     914:	0c 94 a7 21 	jmp	0x434e	; 0x434e <analogWrite>

00000918 <_Z15TaskColorSensorPv>:
// get Ammonia, Nitrite, and Nitrate reading from color sensor
void TaskColorSensor(void *pvParameters)
{
	(void) pvParameters;
  
	TickType_t xLastWakeTime = xTaskGetTickCount();
     918:	0e 94 12 11 	call	0x2224	; 0x2224 <xTaskGetTickCount>
				typeToRead = NITRATE;
				while (findTestStrip());
				setLED(Green);
				delay(250); // allow user to see LED and stop moving test strip

				nitrateValue = ScanColor() * 100;
     91c:	c4 e6       	ldi	r28, 0x64	; 100
				
				setLED(Off);
				
				typeToRead = NITRITE;
     91e:	12 e0       	ldi	r17, 0x02	; 2
	TickType_t xLastWakeTime = xTaskGetTickCount();
	for (;;) // A Task shall never return or exit.
	{
		//Serial.println("Inside dead task");
		//vTaskDelayUntil( &xLastWakeTime, 500 / portTICK_PERIOD_MS );
		if ( xSemaphoreTake( xSerialSemaphoreColorSensor, ( TickType_t ) 100 ) == pdTRUE )
     920:	64 e6       	ldi	r22, 0x64	; 100
     922:	70 e0       	ldi	r23, 0x00	; 0
     924:	80 91 39 02 	lds	r24, 0x0239	; 0x800239 <xSerialSemaphoreColorSensor>
     928:	90 91 3a 02 	lds	r25, 0x023A	; 0x80023a <xSerialSemaphoreColorSensor+0x1>
     92c:	0e 94 06 0e 	call	0x1c0c	; 0x1c0c <xQueueSemaphoreTake>
     930:	d8 2f       	mov	r29, r24
     932:	81 30       	cpi	r24, 0x01	; 1
     934:	09 f0       	breq	.+2      	; 0x938 <_Z15TaskColorSensorPv+0x20>
     936:	8c c0       	rjmp	.+280    	; 0xa50 <_Z15TaskColorSensorPv+0x138>
		{
			setLED(White);
     938:	40 91 09 01 	lds	r20, 0x0109	; 0x800109 <White>
     93c:	50 91 0a 01 	lds	r21, 0x010A	; 0x80010a <White+0x1>
     940:	60 91 0b 01 	lds	r22, 0x010B	; 0x80010b <White+0x2>
     944:	70 91 0c 01 	lds	r23, 0x010C	; 0x80010c <White+0x3>
     948:	80 91 0d 01 	lds	r24, 0x010D	; 0x80010d <White+0x4>
     94c:	90 91 0e 01 	lds	r25, 0x010E	; 0x80010e <White+0x5>
     950:	0e 94 68 04 	call	0x8d0	; 0x8d0 <_Z6setLED8LEDColor>
			//Serial.println("checking color");
			if (colorToRead == 'a')
     954:	80 91 06 01 	lds	r24, 0x0106	; 0x800106 <colorToRead>
     958:	81 36       	cpi	r24, 0x61	; 97
     95a:	a1 f4       	brne	.+40     	; 0x984 <_Z15TaskColorSensorPv+0x6c>
			{
				
				
				//while (findTestStrip());
				//setLED(Green);
				delay(1000); // let user see LED and stop moving before measuring
     95c:	68 ee       	ldi	r22, 0xE8	; 232
     95e:	73 e0       	ldi	r23, 0x03	; 3
     960:	80 e0       	ldi	r24, 0x00	; 0
     962:	90 e0       	ldi	r25, 0x00	; 0
     964:	0e 94 08 21 	call	0x4210	; 0x4210 <delay>
				
				typeToRead = AMMONIA;
     968:	10 92 4d 03 	sts	0x034D, r1	; 0x80034d <typeToRead>
				ammoniaValue = ScanColor() * 100;
     96c:	0e 94 be 03 	call	0x77c	; 0x77c <_Z9ScanColorv>
     970:	c6 9f       	mul	r28, r22
     972:	90 01       	movw	r18, r0
     974:	c7 9f       	mul	r28, r23
     976:	30 0d       	add	r19, r0
     978:	11 24       	eor	r1, r1
     97a:	30 93 43 02 	sts	0x0243, r19	; 0x800243 <ammoniaValue+0x1>
     97e:	20 93 42 02 	sts	0x0242, r18	; 0x800242 <ammoniaValue>
     982:	58 c0       	rjmp	.+176    	; 0xa34 <_Z15TaskColorSensorPv+0x11c>
			}
			else
			{
				setLED(Red);
     984:	40 91 1b 01 	lds	r20, 0x011B	; 0x80011b <Red>
     988:	50 91 1c 01 	lds	r21, 0x011C	; 0x80011c <Red+0x1>
     98c:	60 91 1d 01 	lds	r22, 0x011D	; 0x80011d <Red+0x2>
     990:	70 91 1e 01 	lds	r23, 0x011E	; 0x80011e <Red+0x3>
     994:	80 91 1f 01 	lds	r24, 0x011F	; 0x80011f <Red+0x4>
     998:	90 91 20 01 	lds	r25, 0x0120	; 0x800120 <Red+0x5>
     99c:	0e 94 68 04 	call	0x8d0	; 0x8d0 <_Z6setLED8LEDColor>
				typeToRead = NITRATE;
     9a0:	d0 93 4d 03 	sts	0x034D, r29	; 0x80034d <typeToRead>
				while (findTestStrip());
     9a4:	0e 94 f9 03 	call	0x7f2	; 0x7f2 <_Z13findTestStripv>
     9a8:	81 11       	cpse	r24, r1
     9aa:	fc cf       	rjmp	.-8      	; 0x9a4 <_Z15TaskColorSensorPv+0x8c>
				setLED(Green);
     9ac:	40 91 15 01 	lds	r20, 0x0115	; 0x800115 <Green>
     9b0:	50 91 16 01 	lds	r21, 0x0116	; 0x800116 <Green+0x1>
     9b4:	60 91 17 01 	lds	r22, 0x0117	; 0x800117 <Green+0x2>
     9b8:	70 91 18 01 	lds	r23, 0x0118	; 0x800118 <Green+0x3>
     9bc:	80 91 19 01 	lds	r24, 0x0119	; 0x800119 <Green+0x4>
     9c0:	90 91 1a 01 	lds	r25, 0x011A	; 0x80011a <Green+0x5>
     9c4:	0e 94 68 04 	call	0x8d0	; 0x8d0 <_Z6setLED8LEDColor>
				delay(250); // allow user to see LED and stop moving test strip
     9c8:	6a ef       	ldi	r22, 0xFA	; 250
     9ca:	70 e0       	ldi	r23, 0x00	; 0
     9cc:	80 e0       	ldi	r24, 0x00	; 0
     9ce:	90 e0       	ldi	r25, 0x00	; 0
     9d0:	0e 94 08 21 	call	0x4210	; 0x4210 <delay>

				nitrateValue = ScanColor() * 100;
     9d4:	0e 94 be 03 	call	0x77c	; 0x77c <_Z9ScanColorv>
     9d8:	c6 9f       	mul	r28, r22
     9da:	90 01       	movw	r18, r0
     9dc:	c7 9f       	mul	r28, r23
     9de:	30 0d       	add	r19, r0
     9e0:	11 24       	eor	r1, r1
     9e2:	30 93 41 02 	sts	0x0241, r19	; 0x800241 <nitrateValue+0x1>
     9e6:	20 93 40 02 	sts	0x0240, r18	; 0x800240 <nitrateValue>
				
				setLED(Off);
     9ea:	40 91 4a 02 	lds	r20, 0x024A	; 0x80024a <Off>
     9ee:	50 91 4b 02 	lds	r21, 0x024B	; 0x80024b <Off+0x1>
     9f2:	60 91 4c 02 	lds	r22, 0x024C	; 0x80024c <Off+0x2>
     9f6:	70 91 4d 02 	lds	r23, 0x024D	; 0x80024d <Off+0x3>
     9fa:	80 91 4e 02 	lds	r24, 0x024E	; 0x80024e <Off+0x4>
     9fe:	90 91 4f 02 	lds	r25, 0x024F	; 0x80024f <Off+0x5>
     a02:	0e 94 68 04 	call	0x8d0	; 0x8d0 <_Z6setLED8LEDColor>
				
				typeToRead = NITRITE;
     a06:	10 93 4d 03 	sts	0x034D, r17	; 0x80034d <typeToRead>
				while (findTestStrip());
     a0a:	0e 94 f9 03 	call	0x7f2	; 0x7f2 <_Z13findTestStripv>
     a0e:	81 11       	cpse	r24, r1
     a10:	fc cf       	rjmp	.-8      	; 0xa0a <_Z15TaskColorSensorPv+0xf2>
				//setLED(Blue);
				delay(250);
     a12:	6a ef       	ldi	r22, 0xFA	; 250
     a14:	70 e0       	ldi	r23, 0x00	; 0
     a16:	80 e0       	ldi	r24, 0x00	; 0
     a18:	90 e0       	ldi	r25, 0x00	; 0
     a1a:	0e 94 08 21 	call	0x4210	; 0x4210 <delay>
				
				nitriteValue = ScanColor() * 100;
     a1e:	0e 94 be 03 	call	0x77c	; 0x77c <_Z9ScanColorv>
     a22:	c6 9f       	mul	r28, r22
     a24:	90 01       	movw	r18, r0
     a26:	c7 9f       	mul	r28, r23
     a28:	30 0d       	add	r19, r0
     a2a:	11 24       	eor	r1, r1
     a2c:	30 93 3f 02 	sts	0x023F, r19	; 0x80023f <nitriteValue+0x1>
     a30:	20 93 3e 02 	sts	0x023E, r18	; 0x80023e <nitriteValue>
			}
			setLED(Off);	  
     a34:	40 91 4a 02 	lds	r20, 0x024A	; 0x80024a <Off>
     a38:	50 91 4b 02 	lds	r21, 0x024B	; 0x80024b <Off+0x1>
     a3c:	60 91 4c 02 	lds	r22, 0x024C	; 0x80024c <Off+0x2>
     a40:	70 91 4d 02 	lds	r23, 0x024D	; 0x80024d <Off+0x3>
     a44:	80 91 4e 02 	lds	r24, 0x024E	; 0x80024e <Off+0x4>
     a48:	90 91 4f 02 	lds	r25, 0x024F	; 0x80024f <Off+0x5>
     a4c:	0e 94 68 04 	call	0x8d0	; 0x8d0 <_Z6setLED8LEDColor>
			//xSemaphoreGive( xSerialSemaphoreColorSensor );
		}
		vTaskDelay(1); // 1 tick delay between reads for stability*/
     a50:	81 e0       	ldi	r24, 0x01	; 1
     a52:	90 e0       	ldi	r25, 0x00	; 0
     a54:	0e 94 6f 12 	call	0x24de	; 0x24de <vTaskDelay>
void TaskColorSensor(void *pvParameters)
{
	(void) pvParameters;
  
	TickType_t xLastWakeTime = xTaskGetTickCount();
	for (;;) // A Task shall never return or exit.
     a58:	63 cf       	rjmp	.-314    	; 0x920 <_Z15TaskColorSensorPv+0x8>

00000a5a <_Z20TaskPHandTemperaturePv>:
}


// get pH and temp reading from sensors
void TaskPHandTemperature(void *pvParameters)
{
     a5a:	cf 93       	push	r28
     a5c:	df 93       	push	r29
     a5e:	00 d0       	rcall	.+0      	; 0xa60 <_Z20TaskPHandTemperaturePv+0x6>
     a60:	cd b7       	in	r28, 0x3d	; 61
     a62:	de b7       	in	r29, 0x3e	; 62
  (void) pvParameters;
  
  TickType_t xLastWakeTime = xTaskGetTickCount();
     a64:	0e 94 12 11 	call	0x2224	; 0x2224 <xTaskGetTickCount>
     a68:	9a 83       	std	Y+2, r25	; 0x02
     a6a:	89 83       	std	Y+1, r24	; 0x01
  for (;;) // A Task shall never return or exit.
  {
	// Gets pH value
	//delay(500);
	setLED(Green);
     a6c:	40 91 15 01 	lds	r20, 0x0115	; 0x800115 <Green>
     a70:	50 91 16 01 	lds	r21, 0x0116	; 0x800116 <Green+0x1>
     a74:	60 91 17 01 	lds	r22, 0x0117	; 0x800117 <Green+0x2>
     a78:	70 91 18 01 	lds	r23, 0x0118	; 0x800118 <Green+0x3>
     a7c:	80 91 19 01 	lds	r24, 0x0119	; 0x800119 <Green+0x4>
     a80:	90 91 1a 01 	lds	r25, 0x011A	; 0x80011a <Green+0x5>
     a84:	0e 94 68 04 	call	0x8d0	; 0x8d0 <_Z6setLED8LEDColor>
	//Serial.print("p\n");
	phValue = calcPH() * 100;
     a88:	0e 94 08 09 	call	0x1210	; 0x1210 <_Z6calcPHv>
     a8c:	20 e0       	ldi	r18, 0x00	; 0
     a8e:	30 e0       	ldi	r19, 0x00	; 0
     a90:	48 ec       	ldi	r20, 0xC8	; 200
     a92:	52 e4       	ldi	r21, 0x42	; 66
     a94:	0e 94 a1 1c 	call	0x3942	; 0x3942 <__mulsf3>
     a98:	0e 94 b9 1b 	call	0x3772	; 0x3772 <__fixsfsi>
     a9c:	60 93 46 02 	sts	0x0246, r22	; 0x800246 <phValue>
     aa0:	70 93 47 02 	sts	0x0247, r23	; 0x800247 <phValue+0x1>
     aa4:	80 93 48 02 	sts	0x0248, r24	; 0x800248 <phValue+0x2>
     aa8:	90 93 49 02 	sts	0x0249, r25	; 0x800249 <phValue+0x3>
	//Serial.print("\npH Value:");
	//Serial.print(phValue);
	delay(250);
     aac:	6a ef       	ldi	r22, 0xFA	; 250
     aae:	70 e0       	ldi	r23, 0x00	; 0
     ab0:	80 e0       	ldi	r24, 0x00	; 0
     ab2:	90 e0       	ldi	r25, 0x00	; 0
     ab4:	0e 94 08 21 	call	0x4210	; 0x4210 <delay>
	setLED(Off);
     ab8:	40 91 4a 02 	lds	r20, 0x024A	; 0x80024a <Off>
     abc:	50 91 4b 02 	lds	r21, 0x024B	; 0x80024b <Off+0x1>
     ac0:	60 91 4c 02 	lds	r22, 0x024C	; 0x80024c <Off+0x2>
     ac4:	70 91 4d 02 	lds	r23, 0x024D	; 0x80024d <Off+0x3>
     ac8:	80 91 4e 02 	lds	r24, 0x024E	; 0x80024e <Off+0x4>
     acc:	90 91 4f 02 	lds	r25, 0x024F	; 0x80024f <Off+0x5>
     ad0:	0e 94 68 04 	call	0x8d0	; 0x8d0 <_Z6setLED8LEDColor>
	
	setLED(Red);
     ad4:	40 91 1b 01 	lds	r20, 0x011B	; 0x80011b <Red>
     ad8:	50 91 1c 01 	lds	r21, 0x011C	; 0x80011c <Red+0x1>
     adc:	60 91 1d 01 	lds	r22, 0x011D	; 0x80011d <Red+0x2>
     ae0:	70 91 1e 01 	lds	r23, 0x011E	; 0x80011e <Red+0x3>
     ae4:	80 91 1f 01 	lds	r24, 0x011F	; 0x80011f <Red+0x4>
     ae8:	90 91 20 01 	lds	r25, 0x0120	; 0x800120 <Red+0x5>
     aec:	0e 94 68 04 	call	0x8d0	; 0x8d0 <_Z6setLED8LEDColor>
	// Gets temperature value in Celsius
	tempValue = measureTemp() * 100;
     af0:	0e 94 c8 00 	call	0x190	; 0x190 <_Z11measureTempv>
     af4:	20 e0       	ldi	r18, 0x00	; 0
     af6:	30 e0       	ldi	r19, 0x00	; 0
     af8:	48 ec       	ldi	r20, 0xC8	; 200
     afa:	52 e4       	ldi	r21, 0x42	; 66
     afc:	0e 94 a1 1c 	call	0x3942	; 0x3942 <__mulsf3>
     b00:	0e 94 b9 1b 	call	0x3772	; 0x3772 <__fixsfsi>
     b04:	9b 01       	movw	r18, r22
     b06:	70 93 45 02 	sts	0x0245, r23	; 0x800245 <tempValue+0x1>
     b0a:	60 93 44 02 	sts	0x0244, r22	; 0x800244 <tempValue>
	//Serial.print("t\n");
	//Serial.print(tempValue);

	// RELAY LOGIC (switching on 0.5 C above and below temperature threshold)
	if (tempValue < (tempThreshold - 50)) {
     b0e:	80 91 07 01 	lds	r24, 0x0107	; 0x800107 <tempThreshold>
     b12:	90 91 08 01 	lds	r25, 0x0108	; 0x800108 <tempThreshold+0x1>
     b16:	ac 01       	movw	r20, r24
     b18:	42 53       	subi	r20, 0x32	; 50
     b1a:	51 09       	sbc	r21, r1
     b1c:	24 17       	cp	r18, r20
     b1e:	35 07       	cpc	r19, r21
     b20:	14 f4       	brge	.+4      	; 0xb26 <_Z20TaskPHandTemperaturePv+0xcc>
		digitalWrite(relay, HIGH);
     b22:	61 e0       	ldi	r22, 0x01	; 1
     b24:	05 c0       	rjmp	.+10     	; 0xb30 <_Z20TaskPHandTemperaturePv+0xd6>
	} else if (tempValue > (tempThreshold + 50)) {
     b26:	c2 96       	adiw	r24, 0x32	; 50
     b28:	82 17       	cp	r24, r18
     b2a:	93 07       	cpc	r25, r19
     b2c:	24 f4       	brge	.+8      	; 0xb36 <_Z20TaskPHandTemperaturePv+0xdc>
		digitalWrite(relay, LOW);
     b2e:	60 e0       	ldi	r22, 0x00	; 0
     b30:	84 e0       	ldi	r24, 0x04	; 4
     b32:	0e 94 6b 22 	call	0x44d6	; 0x44d6 <digitalWrite>
	}
	                             
	delay(100);
     b36:	64 e6       	ldi	r22, 0x64	; 100
     b38:	70 e0       	ldi	r23, 0x00	; 0
     b3a:	80 e0       	ldi	r24, 0x00	; 0
     b3c:	90 e0       	ldi	r25, 0x00	; 0
     b3e:	0e 94 08 21 	call	0x4210	; 0x4210 <delay>
	setLED(Off);
     b42:	40 91 4a 02 	lds	r20, 0x024A	; 0x80024a <Off>
     b46:	50 91 4b 02 	lds	r21, 0x024B	; 0x80024b <Off+0x1>
     b4a:	60 91 4c 02 	lds	r22, 0x024C	; 0x80024c <Off+0x2>
     b4e:	70 91 4d 02 	lds	r23, 0x024D	; 0x80024d <Off+0x3>
     b52:	80 91 4e 02 	lds	r24, 0x024E	; 0x80024e <Off+0x4>
     b56:	90 91 4f 02 	lds	r25, 0x024F	; 0x80024f <Off+0x5>
     b5a:	0e 94 68 04 	call	0x8d0	; 0x8d0 <_Z6setLED8LEDColor>
    // check pH and temp every 15 min
    vTaskDelayUntil( &xLastWakeTime, 5000 / portTICK_PERIOD_MS );
     b5e:	68 e3       	ldi	r22, 0x38	; 56
     b60:	71 e0       	ldi	r23, 0x01	; 1
     b62:	ce 01       	movw	r24, r28
     b64:	01 96       	adiw	r24, 0x01	; 1
     b66:	0e 94 37 12 	call	0x246e	; 0x246e <vTaskDelayUntil>
void TaskPHandTemperature(void *pvParameters)
{
  (void) pvParameters;
  
  TickType_t xLastWakeTime = xTaskGetTickCount();
  for (;;) // A Task shall never return or exit.
     b6a:	80 cf       	rjmp	.-256    	; 0xa6c <_Z20TaskPHandTemperaturePv+0x12>

00000b6c <_Z8setupLEDv>:
}

void setupLED()
{
	pinMode(R_LED, OUTPUT);
     b6c:	61 e0       	ldi	r22, 0x01	; 1
     b6e:	8f e0       	ldi	r24, 0x0F	; 15
     b70:	0e 94 2f 22 	call	0x445e	; 0x445e <pinMode>
	pinMode(G_LED, OUTPUT);
     b74:	61 e0       	ldi	r22, 0x01	; 1
     b76:	80 e1       	ldi	r24, 0x10	; 16
     b78:	0e 94 2f 22 	call	0x445e	; 0x445e <pinMode>
	pinMode(B_LED, OUTPUT);
     b7c:	61 e0       	ldi	r22, 0x01	; 1
     b7e:	81 e1       	ldi	r24, 0x11	; 17
     b80:	0e 94 2f 22 	call	0x445e	; 0x445e <pinMode>
	setLED(Off);
     b84:	40 91 4a 02 	lds	r20, 0x024A	; 0x80024a <Off>
     b88:	50 91 4b 02 	lds	r21, 0x024B	; 0x80024b <Off+0x1>
     b8c:	60 91 4c 02 	lds	r22, 0x024C	; 0x80024c <Off+0x2>
     b90:	70 91 4d 02 	lds	r23, 0x024D	; 0x80024d <Off+0x3>
     b94:	80 91 4e 02 	lds	r24, 0x024E	; 0x80024e <Off+0x4>
     b98:	90 91 4f 02 	lds	r25, 0x024F	; 0x80024f <Off+0x5>
     b9c:	0c 94 68 04 	jmp	0x8d0	; 0x8d0 <_Z6setLED8LEDColor>

00000ba0 <setup>:
TaskHandle_t xPHandTemperature;

SoftwareSerial serial(rxPin, txPin);

// the setup function runs once when you press reset or power the board
void setup() {  
     ba0:	ef 92       	push	r14
     ba2:	ff 92       	push	r15
     ba4:	0f 93       	push	r16
	// initialize serial communication at 115200 bits per second:
	serial.begin(115200);
     ba6:	40 e0       	ldi	r20, 0x00	; 0
     ba8:	52 ec       	ldi	r21, 0xC2	; 194
     baa:	61 e0       	ldi	r22, 0x01	; 1
     bac:	70 e0       	ldi	r23, 0x00	; 0
     bae:	86 e1       	ldi	r24, 0x16	; 22
     bb0:	92 e0       	ldi	r25, 0x02	; 2
     bb2:	0e 94 47 1a 	call	0x348e	; 0x348e <_ZN14SoftwareSerial5beginEl>
	pinMode(wifiRst, OUTPUT);
     bb6:	61 e0       	ldi	r22, 0x01	; 1
     bb8:	8a e0       	ldi	r24, 0x0A	; 10
     bba:	0e 94 2f 22 	call	0x445e	; 0x445e <pinMode>
	pinMode(relay, OUTPUT);
     bbe:	61 e0       	ldi	r22, 0x01	; 1
     bc0:	84 e0       	ldi	r24, 0x04	; 4
     bc2:	0e 94 2f 22 	call	0x445e	; 0x445e <pinMode>
  public:
    inline HardwareSerial(
      volatile uint8_t *ubrrh, volatile uint8_t *ubrrl,
      volatile uint8_t *ucsra, volatile uint8_t *ucsrb,
      volatile uint8_t *ucsrc, volatile uint8_t *udr);
    void begin(unsigned long baud) { begin(baud, SERIAL_8N1); }
     bc6:	26 e0       	ldi	r18, 0x06	; 6
     bc8:	40 e0       	ldi	r20, 0x00	; 0
     bca:	52 ec       	ldi	r21, 0xC2	; 194
     bcc:	61 e0       	ldi	r22, 0x01	; 1
     bce:	70 e0       	ldi	r23, 0x00	; 0
     bd0:	83 e2       	ldi	r24, 0x23	; 35
     bd2:	94 e0       	ldi	r25, 0x04	; 4
     bd4:	0e 94 ea 1d 	call	0x3bd4	; 0x3bd4 <_ZN14HardwareSerial5beginEmh>
		; // wait for serial port to connect. Needed for native USB, on LEONARDO, MICRO, YUN, and other 32u4 based boards.
	}
  
	// initialize Wifi module (Maybe?)
	// drive Wifi Enable pin High
	digitalWrite(wifiRst, HIGH);
     bd8:	61 e0       	ldi	r22, 0x01	; 1
     bda:	8a e0       	ldi	r24, 0x0A	; 10
     bdc:	0e 94 6b 22 	call	0x44d6	; 0x44d6 <digitalWrite>
	// load test strip color data and initialize indicator LED
	CS.begin();
     be0:	80 e5       	ldi	r24, 0x50	; 80
     be2:	92 e0       	ldi	r25, 0x02	; 2
     be4:	0e 94 58 17 	call	0x2eb0	; 0x2eb0 <_ZN9MD_TCS2305beginEv>
	addColors();
     be8:	0e 94 55 01 	call	0x2aa	; 0x2aa <_Z9addColorsv>
	setupLED();
     bec:	0e 94 b6 05 	call	0xb6c	; 0xb6c <_Z8setupLEDv>
	//Serial.println("Starting setup");
	
	setLED(Blue);
     bf0:	40 91 0f 01 	lds	r20, 0x010F	; 0x80010f <Blue>
     bf4:	50 91 10 01 	lds	r21, 0x0110	; 0x800110 <Blue+0x1>
     bf8:	60 91 11 01 	lds	r22, 0x0111	; 0x800111 <Blue+0x2>
     bfc:	70 91 12 01 	lds	r23, 0x0112	; 0x800112 <Blue+0x3>
     c00:	80 91 13 01 	lds	r24, 0x0113	; 0x800113 <Blue+0x4>
     c04:	90 91 14 01 	lds	r25, 0x0114	; 0x800114 <Blue+0x5>
     c08:	0e 94 68 04 	call	0x8d0	; 0x8d0 <_Z6setLED8LEDColor>
  
	// initialize pH sensor
	//phInit();
 
	// TODO: Not sure how Wifi module indicates that it is getting data - replace that with the interrupt from pin2 
	attachInterrupt(digitalPinToInterrupt(2), fromWifi, RISING);
     c0c:	43 e0       	ldi	r20, 0x03	; 3
     c0e:	50 e0       	ldi	r21, 0x00	; 0
     c10:	67 e7       	ldi	r22, 0x77	; 119
     c12:	76 e0       	ldi	r23, 0x06	; 6
     c14:	80 e0       	ldi	r24, 0x00	; 0
     c16:	0e 94 2b 20 	call	0x4056	; 0x4056 <attachInterrupt>
	
	if (xSerialSemaphoreColorSensor == NULL)
     c1a:	80 91 39 02 	lds	r24, 0x0239	; 0x800239 <xSerialSemaphoreColorSensor>
     c1e:	90 91 3a 02 	lds	r25, 0x023A	; 0x80023a <xSerialSemaphoreColorSensor+0x1>
     c22:	89 2b       	or	r24, r25
     c24:	91 f4       	brne	.+36     	; 0xc4a <setup+0xaa>
	{
		//xSerialSemaphoreColorSensor = xSemaphoreCreateBinary();
		vSemaphoreCreateBinary(xSerialSemaphoreColorSensor);
     c26:	43 e0       	ldi	r20, 0x03	; 3
     c28:	60 e0       	ldi	r22, 0x00	; 0
     c2a:	81 e0       	ldi	r24, 0x01	; 1
     c2c:	0e 94 64 0c 	call	0x18c8	; 0x18c8 <xQueueGenericCreate>
     c30:	90 93 3a 02 	sts	0x023A, r25	; 0x80023a <xSerialSemaphoreColorSensor+0x1>
     c34:	80 93 39 02 	sts	0x0239, r24	; 0x800239 <xSerialSemaphoreColorSensor>
     c38:	00 97       	sbiw	r24, 0x00	; 0
     c3a:	39 f0       	breq	.+14     	; 0xc4a <setup+0xaa>
     c3c:	20 e0       	ldi	r18, 0x00	; 0
     c3e:	40 e0       	ldi	r20, 0x00	; 0
     c40:	50 e0       	ldi	r21, 0x00	; 0
     c42:	60 e0       	ldi	r22, 0x00	; 0
     c44:	70 e0       	ldi	r23, 0x00	; 0
     c46:	0e 94 8c 0c 	call	0x1918	; 0x1918 <xQueueGenericSend>
	TaskColorSensor
	,  (const portCHAR *)"ColorSensor"
	,  128
	,  NULL
	,  2
	,  &xColorSensor ); 
     c4a:	87 e3       	ldi	r24, 0x37	; 55
     c4c:	e8 2e       	mov	r14, r24
     c4e:	82 e0       	ldi	r24, 0x02	; 2
     c50:	f8 2e       	mov	r15, r24
     c52:	02 e0       	ldi	r16, 0x02	; 2
     c54:	20 e0       	ldi	r18, 0x00	; 0
     c56:	30 e0       	ldi	r19, 0x00	; 0
     c58:	40 e8       	ldi	r20, 0x80	; 128
     c5a:	50 e0       	ldi	r21, 0x00	; 0
     c5c:	6f e7       	ldi	r22, 0x7F	; 127
     c5e:	71 e0       	ldi	r23, 0x01	; 1
     c60:	8c e8       	ldi	r24, 0x8C	; 140
     c62:	94 e0       	ldi	r25, 0x04	; 4
     c64:	0e 94 89 0f 	call	0x1f12	; 0x1f12 <xTaskCreate>
	TaskPHandTemperature
	,  (const portCHAR *) "PHandTemperature"
	,  128
	,  NULL
	,  2
	,  &xPHandTemperature );
     c68:	95 e3       	ldi	r25, 0x35	; 53
     c6a:	e9 2e       	mov	r14, r25
     c6c:	92 e0       	ldi	r25, 0x02	; 2
     c6e:	f9 2e       	mov	r15, r25
     c70:	20 e0       	ldi	r18, 0x00	; 0
     c72:	30 e0       	ldi	r19, 0x00	; 0
     c74:	40 e8       	ldi	r20, 0x80	; 128
     c76:	50 e0       	ldi	r21, 0x00	; 0
     c78:	6b e8       	ldi	r22, 0x8B	; 139
     c7a:	71 e0       	ldi	r23, 0x01	; 1
     c7c:	8d e2       	ldi	r24, 0x2D	; 45
     c7e:	95 e0       	ldi	r25, 0x05	; 5
     c80:	0e 94 89 0f 	call	0x1f12	; 0x1f12 <xTaskCreate>
	
	
	delay(1000);
     c84:	68 ee       	ldi	r22, 0xE8	; 232
     c86:	73 e0       	ldi	r23, 0x03	; 3
     c88:	80 e0       	ldi	r24, 0x00	; 0
     c8a:	90 e0       	ldi	r25, 0x00	; 0
     c8c:	0e 94 08 21 	call	0x4210	; 0x4210 <delay>
	setLED(Off);
     c90:	40 91 4a 02 	lds	r20, 0x024A	; 0x80024a <Off>
     c94:	50 91 4b 02 	lds	r21, 0x024B	; 0x80024b <Off+0x1>
     c98:	60 91 4c 02 	lds	r22, 0x024C	; 0x80024c <Off+0x2>
     c9c:	70 91 4d 02 	lds	r23, 0x024D	; 0x80024d <Off+0x3>
     ca0:	80 91 4e 02 	lds	r24, 0x024E	; 0x80024e <Off+0x4>
     ca4:	90 91 4f 02 	lds	r25, 0x024F	; 0x80024f <Off+0x5>
     ca8:	0e 94 68 04 	call	0x8d0	; 0x8d0 <_Z6setLED8LEDColor>
	//Serial.print("Inside setup");

	// Now the task scheduler, which takes over control of scheduling individual tasks, is automatically started.
	vTaskStartScheduler();
}
     cac:	0f 91       	pop	r16
     cae:	ff 90       	pop	r15
     cb0:	ef 90       	pop	r14
	delay(1000);
	setLED(Off);
	//Serial.print("Inside setup");

	// Now the task scheduler, which takes over control of scheduling individual tasks, is automatically started.
	vTaskStartScheduler();
     cb2:	0c 94 de 10 	jmp	0x21bc	; 0x21bc <vTaskStartScheduler>

00000cb6 <loop>:
}

void loop()
{
     cb6:	08 95       	ret

00000cb8 <_GLOBAL__sub_I_ds>:
    bool LastDeviceFlag;
#endif

  public:
    OneWire() { }
    OneWire(uint8_t pin) { begin(pin); }
     cb8:	66 e0       	ldi	r22, 0x06	; 6
     cba:	8e e4       	ldi	r24, 0x4E	; 78
     cbc:	93 e0       	ldi	r25, 0x03	; 3
     cbe:	0e 94 46 08 	call	0x108c	; 0x108c <_ZN7OneWire5beginEh>

uint8_t greenScanned;
uint8_t redScanned;
uint8_t blueScanned;

MD_TCS230  CS(S2, S3, OE);
     cc2:	28 e0       	ldi	r18, 0x08	; 8
     cc4:	4d e0       	ldi	r20, 0x0D	; 13
     cc6:	6c e0       	ldi	r22, 0x0C	; 12
     cc8:	80 e5       	ldi	r24, 0x50	; 80
     cca:	92 e0       	ldi	r25, 0x02	; 2
     ccc:	0e 94 e6 16 	call	0x2dcc	; 0x2dcc <_ZN9MD_TCS230C1Ehhh>
SemaphoreHandle_t xSerialSemaphoreColorSensor;

TaskHandle_t xColorSensor;
TaskHandle_t xPHandTemperature;

SoftwareSerial serial(rxPin, txPin);
     cd0:	20 e0       	ldi	r18, 0x00	; 0
     cd2:	43 e0       	ldi	r20, 0x03	; 3
     cd4:	62 e0       	ldi	r22, 0x02	; 2
     cd6:	86 e1       	ldi	r24, 0x16	; 22
     cd8:	92 e0       	ldi	r25, 0x02	; 2
     cda:	0c 94 1c 1a 	jmp	0x3438	; 0x3438 <_ZN14SoftwareSerialC1Ehhb>

00000cde <_GLOBAL__sub_D_ds>:
     cde:	86 e1       	ldi	r24, 0x16	; 22
     ce0:	92 e0       	ldi	r25, 0x02	; 2
     ce2:	0e 94 c3 19 	call	0x3386	; 0x3386 <_ZN14SoftwareSerialD1Ev>
     ce6:	80 e5       	ldi	r24, 0x50	; 80
     ce8:	92 e0       	ldi	r25, 0x02	; 2
     cea:	0c 94 fa 16 	jmp	0x2df4	; 0x2df4 <_ZN9MD_TCS230D1Ev>

00000cee <_Z8fromWifiv>:
  }
}


void fromWifi()
{
     cee:	cf 93       	push	r28
	int i = 0;
	char action = '\0';
	// check for data from Wifi
	if (serial.available())
     cf0:	86 e1       	ldi	r24, 0x16	; 22
     cf2:	92 e0       	ldi	r25, 0x02	; 2
     cf4:	0e 94 f2 18 	call	0x31e4	; 0x31e4 <_ZN14SoftwareSerial9availableEv>
     cf8:	89 2b       	or	r24, r25
     cfa:	99 f0       	breq	.+38     	; 0xd22 <_Z8fromWifiv+0x34>
	{
		delay(100); // allows all serial sent to be received together
     cfc:	64 e6       	ldi	r22, 0x64	; 100
     cfe:	70 e0       	ldi	r23, 0x00	; 0
     d00:	80 e0       	ldi	r24, 0x00	; 0
     d02:	90 e0       	ldi	r25, 0x00	; 0
     d04:	0e 94 08 21 	call	0x4210	; 0x4210 <delay>


void fromWifi()
{
	int i = 0;
	char action = '\0';
     d08:	c0 e0       	ldi	r28, 0x00	; 0
	// check for data from Wifi
	if (serial.available())
	{
		delay(100); // allows all serial sent to be received together
		while (serial.available())
     d0a:	86 e1       	ldi	r24, 0x16	; 22
     d0c:	92 e0       	ldi	r25, 0x02	; 2
     d0e:	0e 94 f2 18 	call	0x31e4	; 0x31e4 <_ZN14SoftwareSerial9availableEv>
     d12:	89 2b       	or	r24, r25
     d14:	39 f0       	breq	.+14     	; 0xd24 <_Z8fromWifiv+0x36>
		{
			action = serial.read();
     d16:	86 e1       	ldi	r24, 0x16	; 22
     d18:	92 e0       	ldi	r25, 0x02	; 2
     d1a:	0e 94 68 18 	call	0x30d0	; 0x30d0 <_ZN14SoftwareSerial4readEv>
     d1e:	c8 2f       	mov	r28, r24
	char action = '\0';
	// check for data from Wifi
	if (serial.available())
	{
		delay(100); // allows all serial sent to be received together
		while (serial.available())
     d20:	f4 cf       	rjmp	.-24     	; 0xd0a <_Z8fromWifiv+0x1c>


void fromWifi()
{
	int i = 0;
	char action = '\0';
     d22:	c0 e0       	ldi	r28, 0x00	; 0
		while (serial.available())
		{
			action = serial.read();
		}
	}
	if (alreadyStarted){
     d24:	80 91 3d 02 	lds	r24, 0x023D	; 0x80023d <alreadyStarted>
     d28:	88 23       	and	r24, r24
     d2a:	69 f0       	breq	.+26     	; 0xd46 <_Z8fromWifiv+0x58>
		action = 'a';
		//Serial.println("already started");
		++count;
     d2c:	80 91 3b 02 	lds	r24, 0x023B	; 0x80023b <count>
     d30:	90 91 3c 02 	lds	r25, 0x023C	; 0x80023c <count+0x1>
     d34:	01 96       	adiw	r24, 0x01	; 1
		//Serial.println(count);
		if (count == 10)
     d36:	8a 30       	cpi	r24, 0x0A	; 10
     d38:	91 05       	cpc	r25, r1
     d3a:	29 f5       	brne	.+74     	; 0xd86 <_Z8fromWifiv+0x98>
		{
			count = 0;
     d3c:	10 92 3c 02 	sts	0x023C, r1	; 0x80023c <count+0x1>
     d40:	10 92 3b 02 	sts	0x023B, r1	; 0x80023b <count>
     d44:	08 c0       	rjmp	.+16     	; 0xd56 <_Z8fromWifiv+0x68>
			action = 'p';
		}
	}

	switch(action)
     d46:	ce 36       	cpi	r28, 0x6E	; 110
     d48:	a9 f0       	breq	.+42     	; 0xd74 <_Z8fromWifiv+0x86>
     d4a:	c0 37       	cpi	r28, 0x70	; 112
     d4c:	21 f0       	breq	.+8      	; 0xd56 <_Z8fromWifiv+0x68>
     d4e:	c1 36       	cpi	r28, 0x61	; 97
     d50:	09 f0       	breq	.+2      	; 0xd54 <_Z8fromWifiv+0x66>
     d52:	82 c0       	rjmp	.+260    	; 0xe58 <_Z8fromWifiv+0x16a>
     d54:	1c c0       	rjmp	.+56     	; 0xd8e <_Z8fromWifiv+0xa0>
	{
	case 'p':
	{
		//Serial.println("inside case color");
		colorToRead = 'a';
     d56:	81 e6       	ldi	r24, 0x61	; 97
     d58:	80 93 06 01 	sts	0x0106, r24	; 0x800106 <colorToRead>
		alreadyStarted = true;
     d5c:	81 e0       	ldi	r24, 0x01	; 1
     d5e:	80 93 3d 02 	sts	0x023D, r24	; 0x80023d <alreadyStarted>
		//static BaseType_t xHigherPriorityTaskWoken;
		//xHigherPriorityTaskWoken = pdFALSE;

		xSemaphoreGiveFromISR(xSerialSemaphoreColorSensor, pdFALSE);
     d62:	60 e0       	ldi	r22, 0x00	; 0
     d64:	70 e0       	ldi	r23, 0x00	; 0
     d66:	80 91 39 02 	lds	r24, 0x0239	; 0x800239 <xSerialSemaphoreColorSensor>
     d6a:	90 91 3a 02 	lds	r25, 0x023A	; 0x80023a <xSerialSemaphoreColorSensor+0x1>
		break;
	}
	default:
		break;
	}
}
     d6e:	cf 91       	pop	r28
		colorToRead = 'a';
		alreadyStarted = true;
		//static BaseType_t xHigherPriorityTaskWoken;
		//xHigherPriorityTaskWoken = pdFALSE;

		xSemaphoreGiveFromISR(xSerialSemaphoreColorSensor, pdFALSE);
     d70:	0c 94 51 0d 	jmp	0x1aa2	; 0x1aa2 <xQueueGiveFromISR>
		setLED(Off);*/
		break;
	}
	case 'n':
	{
		colorToRead = 'n';
     d74:	c0 93 06 01 	sts	0x0106, r28	; 0x800106 <colorToRead>
		vTaskResume(xColorSensor);
     d78:	80 91 37 02 	lds	r24, 0x0237	; 0x800237 <xColorSensor>
     d7c:	90 91 38 02 	lds	r25, 0x0238	; 0x800238 <xColorSensor+0x1>
		break;
	}
	default:
		break;
	}
}
     d80:	cf 91       	pop	r28
		break;
	}
	case 'n':
	{
		colorToRead = 'n';
		vTaskResume(xColorSensor);
     d82:	0c 94 95 10 	jmp	0x212a	; 0x212a <vTaskResume>
		}
	}
	if (alreadyStarted){
		action = 'a';
		//Serial.println("already started");
		++count;
     d86:	90 93 3c 02 	sts	0x023C, r25	; 0x80023c <count+0x1>
     d8a:	80 93 3b 02 	sts	0x023B, r24	; 0x80023b <count>
		vTaskResume(xColorSensor);
		break;
	}
	case 'a':
	{
		serial.println("inside case print");
     d8e:	6c e9       	ldi	r22, 0x9C	; 156
     d90:	71 e0       	ldi	r23, 0x01	; 1
     d92:	86 e1       	ldi	r24, 0x16	; 22
     d94:	92 e0       	ldi	r25, 0x02	; 2
     d96:	0e 94 48 1f 	call	0x3e90	; 0x3e90 <_ZN5Print7printlnEPKc>
		setLED(Blue);
     d9a:	40 91 0f 01 	lds	r20, 0x010F	; 0x80010f <Blue>
     d9e:	50 91 10 01 	lds	r21, 0x0110	; 0x800110 <Blue+0x1>
     da2:	60 91 11 01 	lds	r22, 0x0111	; 0x800111 <Blue+0x2>
     da6:	70 91 12 01 	lds	r23, 0x0112	; 0x800112 <Blue+0x3>
     daa:	80 91 13 01 	lds	r24, 0x0113	; 0x800113 <Blue+0x4>
     dae:	90 91 14 01 	lds	r25, 0x0114	; 0x800114 <Blue+0x5>
     db2:	0e 94 68 04 	call	0x8d0	; 0x8d0 <_Z6setLED8LEDColor>
		serial.write("ph:");
     db6:	6e ea       	ldi	r22, 0xAE	; 174
     db8:	71 e0       	ldi	r23, 0x01	; 1
     dba:	86 e1       	ldi	r24, 0x16	; 22
     dbc:	92 e0       	ldi	r25, 0x02	; 2
     dbe:	0e 94 b3 00 	call	0x166	; 0x166 <_ZN5Print5writeEPKc>
		serial.write(phValue);
     dc2:	60 91 46 02 	lds	r22, 0x0246	; 0x800246 <phValue>
     dc6:	86 e1       	ldi	r24, 0x16	; 22
     dc8:	92 e0       	ldi	r25, 0x02	; 2
     dca:	0e 94 89 18 	call	0x3112	; 0x3112 <_ZN14SoftwareSerial5writeEh>
		serial.write("temp:");
     dce:	62 eb       	ldi	r22, 0xB2	; 178
     dd0:	71 e0       	ldi	r23, 0x01	; 1
     dd2:	86 e1       	ldi	r24, 0x16	; 22
     dd4:	92 e0       	ldi	r25, 0x02	; 2
     dd6:	0e 94 b3 00 	call	0x166	; 0x166 <_ZN5Print5writeEPKc>
		serial.write(tempValue);
     dda:	60 91 44 02 	lds	r22, 0x0244	; 0x800244 <tempValue>
     dde:	86 e1       	ldi	r24, 0x16	; 22
     de0:	92 e0       	ldi	r25, 0x02	; 2
     de2:	0e 94 89 18 	call	0x3112	; 0x3112 <_ZN14SoftwareSerial5writeEh>
		serial.write("ammonia:");
     de6:	68 eb       	ldi	r22, 0xB8	; 184
     de8:	71 e0       	ldi	r23, 0x01	; 1
     dea:	86 e1       	ldi	r24, 0x16	; 22
     dec:	92 e0       	ldi	r25, 0x02	; 2
     dee:	0e 94 b3 00 	call	0x166	; 0x166 <_ZN5Print5writeEPKc>
		serial.write(ammoniaValue);
     df2:	60 91 42 02 	lds	r22, 0x0242	; 0x800242 <ammoniaValue>
     df6:	86 e1       	ldi	r24, 0x16	; 22
     df8:	92 e0       	ldi	r25, 0x02	; 2
     dfa:	0e 94 89 18 	call	0x3112	; 0x3112 <_ZN14SoftwareSerial5writeEh>
		serial.write("nitrite:");
     dfe:	61 ec       	ldi	r22, 0xC1	; 193
     e00:	71 e0       	ldi	r23, 0x01	; 1
     e02:	86 e1       	ldi	r24, 0x16	; 22
     e04:	92 e0       	ldi	r25, 0x02	; 2
     e06:	0e 94 b3 00 	call	0x166	; 0x166 <_ZN5Print5writeEPKc>
		serial.write(nitriteValue);
     e0a:	60 91 3e 02 	lds	r22, 0x023E	; 0x80023e <nitriteValue>
     e0e:	86 e1       	ldi	r24, 0x16	; 22
     e10:	92 e0       	ldi	r25, 0x02	; 2
     e12:	0e 94 89 18 	call	0x3112	; 0x3112 <_ZN14SoftwareSerial5writeEh>
		serial.write("nitrate:");
     e16:	6a ec       	ldi	r22, 0xCA	; 202
     e18:	71 e0       	ldi	r23, 0x01	; 1
     e1a:	86 e1       	ldi	r24, 0x16	; 22
     e1c:	92 e0       	ldi	r25, 0x02	; 2
     e1e:	0e 94 b3 00 	call	0x166	; 0x166 <_ZN5Print5writeEPKc>
		serial.write(nitrateValue);
     e22:	60 91 40 02 	lds	r22, 0x0240	; 0x800240 <nitrateValue>
     e26:	86 e1       	ldi	r24, 0x16	; 22
     e28:	92 e0       	ldi	r25, 0x02	; 2
     e2a:	0e 94 89 18 	call	0x3112	; 0x3112 <_ZN14SoftwareSerial5writeEh>
		delay(200);
     e2e:	68 ec       	ldi	r22, 0xC8	; 200
     e30:	70 e0       	ldi	r23, 0x00	; 0
     e32:	80 e0       	ldi	r24, 0x00	; 0
     e34:	90 e0       	ldi	r25, 0x00	; 0
     e36:	0e 94 08 21 	call	0x4210	; 0x4210 <delay>
		setLED(Off);
     e3a:	40 91 4a 02 	lds	r20, 0x024A	; 0x80024a <Off>
     e3e:	50 91 4b 02 	lds	r21, 0x024B	; 0x80024b <Off+0x1>
     e42:	60 91 4c 02 	lds	r22, 0x024C	; 0x80024c <Off+0x2>
     e46:	70 91 4d 02 	lds	r23, 0x024D	; 0x80024d <Off+0x3>
     e4a:	80 91 4e 02 	lds	r24, 0x024E	; 0x80024e <Off+0x4>
     e4e:	90 91 4f 02 	lds	r25, 0x024F	; 0x80024f <Off+0x5>
		break;
	}
	default:
		break;
	}
}
     e52:	cf 91       	pop	r28
		serial.write("nitrite:");
		serial.write(nitriteValue);
		serial.write("nitrate:");
		serial.write(nitrateValue);
		delay(200);
		setLED(Off);
     e54:	0c 94 68 04 	jmp	0x8d0	; 0x8d0 <_Z6setLED8LEDColor>
		break;
	}
	default:
		break;
	}
}
     e58:	cf 91       	pop	r28
     e5a:	08 95       	ret

00000e5c <_ZN7OneWire5resetEv>:
   ROM_NO[0] = family_code;
   for (uint8_t i = 1; i < 8; i++)
      ROM_NO[i] = 0;
   LastDiscrepancy = 64;
   LastFamilyDiscrepancy = 0;
   LastDeviceFlag = false;
     e5c:	ff 92       	push	r15
     e5e:	0f 93       	push	r16
     e60:	1f 93       	push	r17
     e62:	cf 93       	push	r28
     e64:	df 93       	push	r29
     e66:	fc 01       	movw	r30, r24
     e68:	f0 80       	ld	r15, Z
     e6a:	c1 81       	ldd	r28, Z+1	; 0x01
     e6c:	d2 81       	ldd	r29, Z+2	; 0x02
     e6e:	f8 94       	cli
     e70:	89 81       	ldd	r24, Y+1	; 0x01
     e72:	0f 2d       	mov	r16, r15
     e74:	00 95       	com	r16
     e76:	80 23       	and	r24, r16
     e78:	89 83       	std	Y+1, r24	; 0x01
     e7a:	78 94       	sei
     e7c:	1d e7       	ldi	r17, 0x7D	; 125
     e7e:	11 50       	subi	r17, 0x01	; 1
     e80:	29 f1       	breq	.+74     	; 0xecc <_ZN7OneWire5resetEv+0x70>
     e82:	82 e0       	ldi	r24, 0x02	; 2
     e84:	90 e0       	ldi	r25, 0x00	; 0
     e86:	0e 94 44 21 	call	0x4288	; 0x4288 <delayMicroseconds>
     e8a:	88 81       	ld	r24, Y
     e8c:	8f 21       	and	r24, r15
     e8e:	b9 f3       	breq	.-18     	; 0xe7e <_ZN7OneWire5resetEv+0x22>
     e90:	f8 94       	cli
     e92:	8a 81       	ldd	r24, Y+2	; 0x02
     e94:	80 23       	and	r24, r16
     e96:	8a 83       	std	Y+2, r24	; 0x02
     e98:	89 81       	ldd	r24, Y+1	; 0x01
     e9a:	8f 29       	or	r24, r15
     e9c:	89 83       	std	Y+1, r24	; 0x01
     e9e:	78 94       	sei
     ea0:	80 ee       	ldi	r24, 0xE0	; 224
     ea2:	91 e0       	ldi	r25, 0x01	; 1
     ea4:	0e 94 44 21 	call	0x4288	; 0x4288 <delayMicroseconds>
     ea8:	f8 94       	cli
     eaa:	89 81       	ldd	r24, Y+1	; 0x01
     eac:	08 23       	and	r16, r24
     eae:	09 83       	std	Y+1, r16	; 0x01
     eb0:	86 e4       	ldi	r24, 0x46	; 70
     eb2:	90 e0       	ldi	r25, 0x00	; 0
     eb4:	0e 94 44 21 	call	0x4288	; 0x4288 <delayMicroseconds>
     eb8:	88 81       	ld	r24, Y
     eba:	f8 22       	and	r15, r24
     ebc:	11 e0       	ldi	r17, 0x01	; 1
     ebe:	09 f0       	breq	.+2      	; 0xec2 <_ZN7OneWire5resetEv+0x66>
     ec0:	10 e0       	ldi	r17, 0x00	; 0
     ec2:	78 94       	sei
     ec4:	8a e9       	ldi	r24, 0x9A	; 154
     ec6:	91 e0       	ldi	r25, 0x01	; 1
     ec8:	0e 94 44 21 	call	0x4288	; 0x4288 <delayMicroseconds>
     ecc:	81 2f       	mov	r24, r17
     ece:	df 91       	pop	r29
     ed0:	cf 91       	pop	r28
     ed2:	1f 91       	pop	r17
     ed4:	0f 91       	pop	r16
     ed6:	ff 90       	pop	r15
     ed8:	08 95       	ret

00000eda <_ZN7OneWire9write_bitEh>:
     eda:	1f 93       	push	r17
     edc:	cf 93       	push	r28
     ede:	df 93       	push	r29
     ee0:	fc 01       	movw	r30, r24
     ee2:	10 81       	ld	r17, Z
     ee4:	c1 81       	ldd	r28, Z+1	; 0x01
     ee6:	d2 81       	ldd	r29, Z+2	; 0x02
     ee8:	81 2f       	mov	r24, r17
     eea:	80 95       	com	r24
     eec:	60 ff       	sbrs	r22, 0
     eee:	12 c0       	rjmp	.+36     	; 0xf14 <_ZN7OneWire9write_bitEh+0x3a>
     ef0:	f8 94       	cli
     ef2:	9a 81       	ldd	r25, Y+2	; 0x02
     ef4:	89 23       	and	r24, r25
     ef6:	8a 83       	std	Y+2, r24	; 0x02
     ef8:	89 81       	ldd	r24, Y+1	; 0x01
     efa:	81 2b       	or	r24, r17
     efc:	89 83       	std	Y+1, r24	; 0x01
     efe:	8a e0       	ldi	r24, 0x0A	; 10
     f00:	90 e0       	ldi	r25, 0x00	; 0
     f02:	0e 94 44 21 	call	0x4288	; 0x4288 <delayMicroseconds>
     f06:	8a 81       	ldd	r24, Y+2	; 0x02
     f08:	18 2b       	or	r17, r24
     f0a:	1a 83       	std	Y+2, r17	; 0x02
     f0c:	78 94       	sei
     f0e:	87 e3       	ldi	r24, 0x37	; 55
     f10:	90 e0       	ldi	r25, 0x00	; 0
     f12:	11 c0       	rjmp	.+34     	; 0xf36 <_ZN7OneWire9write_bitEh+0x5c>
     f14:	f8 94       	cli
     f16:	9a 81       	ldd	r25, Y+2	; 0x02
     f18:	89 23       	and	r24, r25
     f1a:	8a 83       	std	Y+2, r24	; 0x02
     f1c:	89 81       	ldd	r24, Y+1	; 0x01
     f1e:	81 2b       	or	r24, r17
     f20:	89 83       	std	Y+1, r24	; 0x01
     f22:	81 e4       	ldi	r24, 0x41	; 65
     f24:	90 e0       	ldi	r25, 0x00	; 0
     f26:	0e 94 44 21 	call	0x4288	; 0x4288 <delayMicroseconds>
     f2a:	8a 81       	ldd	r24, Y+2	; 0x02
     f2c:	18 2b       	or	r17, r24
     f2e:	1a 83       	std	Y+2, r17	; 0x02
     f30:	78 94       	sei
     f32:	85 e0       	ldi	r24, 0x05	; 5
     f34:	90 e0       	ldi	r25, 0x00	; 0
     f36:	df 91       	pop	r29
     f38:	cf 91       	pop	r28
     f3a:	1f 91       	pop	r17
     f3c:	0c 94 44 21 	jmp	0x4288	; 0x4288 <delayMicroseconds>

00000f40 <_ZN7OneWire8read_bitEv>:
     f40:	0f 93       	push	r16
     f42:	1f 93       	push	r17
     f44:	cf 93       	push	r28
     f46:	df 93       	push	r29
     f48:	fc 01       	movw	r30, r24
     f4a:	00 81       	ld	r16, Z
     f4c:	c1 81       	ldd	r28, Z+1	; 0x01
     f4e:	d2 81       	ldd	r29, Z+2	; 0x02
     f50:	f8 94       	cli
     f52:	89 81       	ldd	r24, Y+1	; 0x01
     f54:	80 2b       	or	r24, r16
     f56:	89 83       	std	Y+1, r24	; 0x01
     f58:	8a 81       	ldd	r24, Y+2	; 0x02
     f5a:	10 2f       	mov	r17, r16
     f5c:	10 95       	com	r17
     f5e:	81 23       	and	r24, r17
     f60:	8a 83       	std	Y+2, r24	; 0x02
     f62:	83 e0       	ldi	r24, 0x03	; 3
     f64:	90 e0       	ldi	r25, 0x00	; 0
     f66:	0e 94 44 21 	call	0x4288	; 0x4288 <delayMicroseconds>
     f6a:	89 81       	ldd	r24, Y+1	; 0x01
     f6c:	18 23       	and	r17, r24
     f6e:	19 83       	std	Y+1, r17	; 0x01
     f70:	8a e0       	ldi	r24, 0x0A	; 10
     f72:	90 e0       	ldi	r25, 0x00	; 0
     f74:	0e 94 44 21 	call	0x4288	; 0x4288 <delayMicroseconds>
     f78:	c8 81       	ld	r28, Y
     f7a:	78 94       	sei
     f7c:	85 e3       	ldi	r24, 0x35	; 53
     f7e:	90 e0       	ldi	r25, 0x00	; 0
     f80:	0e 94 44 21 	call	0x4288	; 0x4288 <delayMicroseconds>
     f84:	c0 23       	and	r28, r16
     f86:	81 e0       	ldi	r24, 0x01	; 1
     f88:	09 f4       	brne	.+2      	; 0xf8c <_ZN7OneWire8read_bitEv+0x4c>
     f8a:	80 e0       	ldi	r24, 0x00	; 0
     f8c:	df 91       	pop	r29
     f8e:	cf 91       	pop	r28
     f90:	1f 91       	pop	r17
     f92:	0f 91       	pop	r16
     f94:	08 95       	ret

00000f96 <_ZN7OneWire5writeEhh>:
     f96:	df 92       	push	r13
     f98:	ef 92       	push	r14
     f9a:	ff 92       	push	r15
     f9c:	0f 93       	push	r16
     f9e:	1f 93       	push	r17
     fa0:	cf 93       	push	r28
     fa2:	df 93       	push	r29
     fa4:	ec 01       	movw	r28, r24
     fa6:	d6 2e       	mov	r13, r22
     fa8:	e4 2e       	mov	r14, r20
     faa:	08 e0       	ldi	r16, 0x08	; 8
     fac:	10 e0       	ldi	r17, 0x00	; 0
     fae:	ff 24       	eor	r15, r15
     fb0:	f3 94       	inc	r15
     fb2:	61 e0       	ldi	r22, 0x01	; 1
     fb4:	8d 2d       	mov	r24, r13
     fb6:	8f 21       	and	r24, r15
     fb8:	09 f4       	brne	.+2      	; 0xfbc <_ZN7OneWire5writeEhh+0x26>
     fba:	60 e0       	ldi	r22, 0x00	; 0
     fbc:	ce 01       	movw	r24, r28
     fbe:	0e 94 6d 07 	call	0xeda	; 0xeda <_ZN7OneWire9write_bitEh>
     fc2:	ff 0c       	add	r15, r15
     fc4:	01 50       	subi	r16, 0x01	; 1
     fc6:	11 09       	sbc	r17, r1
     fc8:	a1 f7       	brne	.-24     	; 0xfb2 <_ZN7OneWire5writeEhh+0x1c>
     fca:	e1 10       	cpse	r14, r1
     fcc:	10 c0       	rjmp	.+32     	; 0xfee <_ZN7OneWire5writeEhh+0x58>
     fce:	f8 94       	cli
     fd0:	e9 81       	ldd	r30, Y+1	; 0x01
     fd2:	fa 81       	ldd	r31, Y+2	; 0x02
     fd4:	91 81       	ldd	r25, Z+1	; 0x01
     fd6:	88 81       	ld	r24, Y
     fd8:	80 95       	com	r24
     fda:	89 23       	and	r24, r25
     fdc:	81 83       	std	Z+1, r24	; 0x01
     fde:	e9 81       	ldd	r30, Y+1	; 0x01
     fe0:	fa 81       	ldd	r31, Y+2	; 0x02
     fe2:	92 81       	ldd	r25, Z+2	; 0x02
     fe4:	88 81       	ld	r24, Y
     fe6:	80 95       	com	r24
     fe8:	89 23       	and	r24, r25
     fea:	82 83       	std	Z+2, r24	; 0x02
     fec:	78 94       	sei
     fee:	df 91       	pop	r29
     ff0:	cf 91       	pop	r28
     ff2:	1f 91       	pop	r17
     ff4:	0f 91       	pop	r16
     ff6:	ff 90       	pop	r15
     ff8:	ef 90       	pop	r14
     ffa:	df 90       	pop	r13
     ffc:	08 95       	ret

00000ffe <_ZN7OneWire4readEv>:
     ffe:	ef 92       	push	r14
    1000:	ff 92       	push	r15
    1002:	0f 93       	push	r16
    1004:	1f 93       	push	r17
    1006:	cf 93       	push	r28
    1008:	df 93       	push	r29
    100a:	7c 01       	movw	r14, r24
    100c:	08 e0       	ldi	r16, 0x08	; 8
    100e:	10 e0       	ldi	r17, 0x00	; 0
    1010:	c0 e0       	ldi	r28, 0x00	; 0
    1012:	d1 e0       	ldi	r29, 0x01	; 1
    1014:	c7 01       	movw	r24, r14
    1016:	0e 94 a0 07 	call	0xf40	; 0xf40 <_ZN7OneWire8read_bitEv>
    101a:	81 11       	cpse	r24, r1
    101c:	cd 2b       	or	r28, r29
    101e:	dd 0f       	add	r29, r29
    1020:	01 50       	subi	r16, 0x01	; 1
    1022:	11 09       	sbc	r17, r1
    1024:	b9 f7       	brne	.-18     	; 0x1014 <_ZN7OneWire4readEv+0x16>
    1026:	8c 2f       	mov	r24, r28
    1028:	df 91       	pop	r29
    102a:	cf 91       	pop	r28
    102c:	1f 91       	pop	r17
    102e:	0f 91       	pop	r16
    1030:	ff 90       	pop	r15
    1032:	ef 90       	pop	r14
    1034:	08 95       	ret

00001036 <_ZN7OneWire6selectEPKh>:
    1036:	ef 92       	push	r14
    1038:	ff 92       	push	r15
    103a:	0f 93       	push	r16
    103c:	1f 93       	push	r17
    103e:	cf 93       	push	r28
    1040:	df 93       	push	r29
    1042:	8c 01       	movw	r16, r24
    1044:	7b 01       	movw	r14, r22
    1046:	40 e0       	ldi	r20, 0x00	; 0
    1048:	65 e5       	ldi	r22, 0x55	; 85
    104a:	0e 94 cb 07 	call	0xf96	; 0xf96 <_ZN7OneWire5writeEhh>
    104e:	e7 01       	movw	r28, r14
    1050:	88 e0       	ldi	r24, 0x08	; 8
    1052:	e8 0e       	add	r14, r24
    1054:	f1 1c       	adc	r15, r1
    1056:	69 91       	ld	r22, Y+
    1058:	40 e0       	ldi	r20, 0x00	; 0
    105a:	c8 01       	movw	r24, r16
    105c:	0e 94 cb 07 	call	0xf96	; 0xf96 <_ZN7OneWire5writeEhh>
    1060:	ce 15       	cp	r28, r14
    1062:	df 05       	cpc	r29, r15
    1064:	c1 f7       	brne	.-16     	; 0x1056 <_ZN7OneWire6selectEPKh+0x20>
    1066:	df 91       	pop	r29
    1068:	cf 91       	pop	r28
    106a:	1f 91       	pop	r17
    106c:	0f 91       	pop	r16
    106e:	ff 90       	pop	r15
    1070:	ef 90       	pop	r14
    1072:	08 95       	ret

00001074 <_ZN7OneWire12reset_searchEv>:
    1074:	fc 01       	movw	r30, r24
    1076:	13 86       	std	Z+11, r1	; 0x0b
    1078:	15 86       	std	Z+13, r1	; 0x0d
    107a:	14 86       	std	Z+12, r1	; 0x0c
    107c:	dc 01       	movw	r26, r24
    107e:	1b 96       	adiw	r26, 0x0b	; 11
    1080:	33 96       	adiw	r30, 0x03	; 3
    1082:	1e 92       	st	-X, r1
    1084:	ae 17       	cp	r26, r30
    1086:	bf 07       	cpc	r27, r31
    1088:	e1 f7       	brne	.-8      	; 0x1082 <_ZN7OneWire12reset_searchEv+0xe>
    108a:	08 95       	ret

0000108c <_ZN7OneWire5beginEh>:
    108c:	1f 93       	push	r17
    108e:	cf 93       	push	r28
    1090:	df 93       	push	r29
    1092:	ec 01       	movw	r28, r24
    1094:	16 2f       	mov	r17, r22
    1096:	60 e0       	ldi	r22, 0x00	; 0
    1098:	81 2f       	mov	r24, r17
    109a:	0e 94 2f 22 	call	0x445e	; 0x445e <pinMode>
    109e:	61 2f       	mov	r22, r17
    10a0:	70 e0       	ldi	r23, 0x00	; 0
    10a2:	fb 01       	movw	r30, r22
    10a4:	ea 53       	subi	r30, 0x3A	; 58
    10a6:	ff 4f       	sbci	r31, 0xFF	; 255
    10a8:	e4 91       	lpm	r30, Z
    10aa:	e8 83       	st	Y, r30
    10ac:	fb 01       	movw	r30, r22
    10ae:	e6 52       	subi	r30, 0x26	; 38
    10b0:	ff 4f       	sbci	r31, 0xFF	; 255
    10b2:	e4 91       	lpm	r30, Z
    10b4:	f0 e0       	ldi	r31, 0x00	; 0
    10b6:	ee 0f       	add	r30, r30
    10b8:	ff 1f       	adc	r31, r31
    10ba:	e2 51       	subi	r30, 0x12	; 18
    10bc:	ff 4f       	sbci	r31, 0xFF	; 255
    10be:	85 91       	lpm	r24, Z+
    10c0:	94 91       	lpm	r25, Z
    10c2:	9a 83       	std	Y+2, r25	; 0x02
    10c4:	89 83       	std	Y+1, r24	; 0x01
    10c6:	ce 01       	movw	r24, r28
    10c8:	df 91       	pop	r29
    10ca:	cf 91       	pop	r28
    10cc:	1f 91       	pop	r17
    10ce:	0c 94 3a 08 	jmp	0x1074	; 0x1074 <_ZN7OneWire12reset_searchEv>

000010d2 <_ZN7OneWire6searchEPhb>:
// search state.
// Return TRUE  : device found, ROM number in ROM_NO buffer
//        FALSE : device not found, end of search
//
bool OneWire::search(uint8_t *newAddr, bool search_mode /* = true */)
{
    10d2:	bf 92       	push	r11
    10d4:	cf 92       	push	r12
    10d6:	df 92       	push	r13
    10d8:	ef 92       	push	r14
    10da:	ff 92       	push	r15
    10dc:	0f 93       	push	r16
    10de:	1f 93       	push	r17
    10e0:	cf 93       	push	r28
    10e2:	df 93       	push	r29
    10e4:	ec 01       	movw	r28, r24
    10e6:	6b 01       	movw	r12, r22
    10e8:	14 2f       	mov	r17, r20
   rom_byte_number = 0;
   rom_byte_mask = 1;
   search_result = false;

   // if the last call was not the last one
   if (!LastDeviceFlag) {
    10ea:	8d 85       	ldd	r24, Y+13	; 0x0d
    10ec:	81 11       	cpse	r24, r1
    10ee:	05 c0       	rjmp	.+10     	; 0x10fa <_ZN7OneWire6searchEPhb+0x28>
      // 1-Wire reset
      if (!reset()) {
    10f0:	ce 01       	movw	r24, r28
    10f2:	0e 94 2e 07 	call	0xe5c	; 0xe5c <_ZN7OneWire5resetEv>
    10f6:	81 11       	cpse	r24, r1
    10f8:	05 c0       	rjmp	.+10     	; 0x1104 <_ZN7OneWire6searchEPhb+0x32>
         // reset the search
         LastDiscrepancy = 0;
    10fa:	1b 86       	std	Y+11, r1	; 0x0b
         LastDeviceFlag = false;
    10fc:	1d 86       	std	Y+13, r1	; 0x0d
         LastFamilyDiscrepancy = 0;
    10fe:	1c 86       	std	Y+12, r1	; 0x0c
         return false;
    1100:	80 e0       	ldi	r24, 0x00	; 0
    1102:	64 c0       	rjmp	.+200    	; 0x11cc <_ZN7OneWire6searchEPhb+0xfa>
      }

      // issue the search command
      if (search_mode == true) {
        write(0xF0);   // NORMAL SEARCH
    1104:	40 e0       	ldi	r20, 0x00	; 0
         LastFamilyDiscrepancy = 0;
         return false;
      }

      // issue the search command
      if (search_mode == true) {
    1106:	11 23       	and	r17, r17
    1108:	11 f0       	breq	.+4      	; 0x110e <_ZN7OneWire6searchEPhb+0x3c>
        write(0xF0);   // NORMAL SEARCH
    110a:	60 ef       	ldi	r22, 0xF0	; 240
    110c:	01 c0       	rjmp	.+2      	; 0x1110 <_ZN7OneWire6searchEPhb+0x3e>
      } else {
        write(0xEC);   // CONDITIONAL SEARCH
    110e:	6c ee       	ldi	r22, 0xEC	; 236
    1110:	ce 01       	movw	r24, r28
    1112:	0e 94 cb 07 	call	0xf96	; 0xf96 <_ZN7OneWire5writeEhh>
// search state.
// Return TRUE  : device found, ROM number in ROM_NO buffer
//        FALSE : device not found, end of search
//
bool OneWire::search(uint8_t *newAddr, bool search_mode /* = true */)
{
    1116:	01 e0       	ldi	r16, 0x01	; 1
    1118:	e1 2c       	mov	r14, r1
    111a:	b1 2c       	mov	r11, r1
    111c:	11 e0       	ldi	r17, 0x01	; 1

      // loop to do the search
      do
      {
         // read a bit and its complement
         id_bit = read_bit();
    111e:	ce 01       	movw	r24, r28
    1120:	0e 94 a0 07 	call	0xf40	; 0xf40 <_ZN7OneWire8read_bitEv>
    1124:	f8 2e       	mov	r15, r24
         cmp_id_bit = read_bit();
    1126:	ce 01       	movw	r24, r28
    1128:	0e 94 a0 07 	call	0xf40	; 0xf40 <_ZN7OneWire8read_bitEv>

         // check for no devices on 1-wire
         if ((id_bit == 1) && (cmp_id_bit == 1)) {
    112c:	91 e0       	ldi	r25, 0x01	; 1
    112e:	f9 12       	cpse	r15, r25
    1130:	03 c0       	rjmp	.+6      	; 0x1138 <_ZN7OneWire6searchEPhb+0x66>
    1132:	81 30       	cpi	r24, 0x01	; 1
    1134:	b1 f4       	brne	.+44     	; 0x1162 <_ZN7OneWire6searchEPhb+0x90>
    1136:	34 c0       	rjmp	.+104    	; 0x11a0 <_ZN7OneWire6searchEPhb+0xce>
    1138:	2e 2d       	mov	r18, r14
    113a:	30 e0       	ldi	r19, 0x00	; 0
            break;
         } else {
            // all devices coupled have 0 or 1
            if (id_bit != cmp_id_bit) {
    113c:	f8 12       	cpse	r15, r24
    113e:	1b c0       	rjmp	.+54     	; 0x1176 <_ZN7OneWire6searchEPhb+0xa4>
               search_direction = id_bit;  // bit write value for search
            } else {
               // if this discrepancy if before the Last Discrepancy
               // on a previous next then pick the same as last time
               if (id_bit_number < LastDiscrepancy) {
    1140:	8b 85       	ldd	r24, Y+11	; 0x0b
    1142:	18 17       	cp	r17, r24
    1144:	38 f4       	brcc	.+14     	; 0x1154 <_ZN7OneWire6searchEPhb+0x82>
                  search_direction = ((ROM_NO[rom_byte_number] & rom_byte_mask) > 0);
    1146:	fe 01       	movw	r30, r28
    1148:	e2 0f       	add	r30, r18
    114a:	f3 1f       	adc	r31, r19
    114c:	83 81       	ldd	r24, Z+3	; 0x03
    114e:	80 23       	and	r24, r16
    1150:	41 f4       	brne	.+16     	; 0x1162 <_ZN7OneWire6searchEPhb+0x90>
    1152:	02 c0       	rjmp	.+4      	; 0x1158 <_ZN7OneWire6searchEPhb+0x86>
               } else {
                  // if equal to last pick 1, if not then pick 0
                  search_direction = (id_bit_number == LastDiscrepancy);
    1154:	18 17       	cp	r17, r24
    1156:	29 f0       	breq	.+10     	; 0x1162 <_ZN7OneWire6searchEPhb+0x90>
    1158:	f1 2c       	mov	r15, r1
               // if 0 was picked then record its position in LastZero
               if (search_direction == 0) {
                  last_zero = id_bit_number;

                  // check for Last discrepancy in family
                  if (last_zero < 9)
    115a:	19 30       	cpi	r17, 0x09	; 9
    115c:	58 f4       	brcc	.+22     	; 0x1174 <_ZN7OneWire6searchEPhb+0xa2>
                     LastFamilyDiscrepancy = last_zero;
    115e:	1c 87       	std	Y+12, r17	; 0x0c
    1160:	09 c0       	rjmp	.+18     	; 0x1174 <_ZN7OneWire6searchEPhb+0xa2>
            }

            // set or clear the bit in the ROM byte rom_byte_number
            // with mask rom_byte_mask
            if (search_direction == 1)
              ROM_NO[rom_byte_number] |= rom_byte_mask;
    1162:	fe 01       	movw	r30, r28
    1164:	ee 0d       	add	r30, r14
    1166:	f1 1d       	adc	r31, r1
    1168:	83 81       	ldd	r24, Z+3	; 0x03
    116a:	80 2b       	or	r24, r16
    116c:	83 83       	std	Z+3, r24	; 0x03
    116e:	ff 24       	eor	r15, r15
    1170:	f3 94       	inc	r15
    1172:	09 c0       	rjmp	.+18     	; 0x1186 <_ZN7OneWire6searchEPhb+0xb4>
// search state.
// Return TRUE  : device found, ROM number in ROM_NO buffer
//        FALSE : device not found, end of search
//
bool OneWire::search(uint8_t *newAddr, bool search_mode /* = true */)
{
    1174:	b1 2e       	mov	r11, r17
            // set or clear the bit in the ROM byte rom_byte_number
            // with mask rom_byte_mask
            if (search_direction == 1)
              ROM_NO[rom_byte_number] |= rom_byte_mask;
            else
              ROM_NO[rom_byte_number] &= ~rom_byte_mask;
    1176:	fe 01       	movw	r30, r28
    1178:	e2 0f       	add	r30, r18
    117a:	f3 1f       	adc	r31, r19
    117c:	93 81       	ldd	r25, Z+3	; 0x03
    117e:	80 2f       	mov	r24, r16
    1180:	80 95       	com	r24
    1182:	89 23       	and	r24, r25
    1184:	83 83       	std	Z+3, r24	; 0x03

            // serial number search direction write bit
            write_bit(search_direction);
    1186:	6f 2d       	mov	r22, r15
    1188:	ce 01       	movw	r24, r28
    118a:	0e 94 6d 07 	call	0xeda	; 0xeda <_ZN7OneWire9write_bitEh>

            // increment the byte counter id_bit_number
            // and shift the mask rom_byte_mask
            id_bit_number++;
    118e:	1f 5f       	subi	r17, 0xFF	; 255
            rom_byte_mask <<= 1;
    1190:	00 0f       	add	r16, r16

            // if the mask is 0 then go to new SerialNum byte rom_byte_number and reset mask
            if (rom_byte_mask == 0) {
    1192:	11 f4       	brne	.+4      	; 0x1198 <_ZN7OneWire6searchEPhb+0xc6>
                rom_byte_number++;
    1194:	e3 94       	inc	r14
                rom_byte_mask = 1;
    1196:	01 e0       	ldi	r16, 0x01	; 1
            }
         }
      }
      while(rom_byte_number < 8);  // loop until through all ROM bytes 0-7
    1198:	87 e0       	ldi	r24, 0x07	; 7
    119a:	8e 15       	cp	r24, r14
    119c:	08 f0       	brcs	.+2      	; 0x11a0 <_ZN7OneWire6searchEPhb+0xce>
    119e:	bf cf       	rjmp	.-130    	; 0x111e <_ZN7OneWire6searchEPhb+0x4c>

      // if the search was successful then
      if (!(id_bit_number < 65)) {
    11a0:	11 34       	cpi	r17, 0x41	; 65
    11a2:	08 f4       	brcc	.+2      	; 0x11a6 <_ZN7OneWire6searchEPhb+0xd4>
    11a4:	aa cf       	rjmp	.-172    	; 0x10fa <_ZN7OneWire6searchEPhb+0x28>
         // search successful so set LastDiscrepancy,LastDeviceFlag,search_result
         LastDiscrepancy = last_zero;
    11a6:	bb 86       	std	Y+11, r11	; 0x0b

         // check for last device
         if (LastDiscrepancy == 0) {
    11a8:	b1 10       	cpse	r11, r1
    11aa:	02 c0       	rjmp	.+4      	; 0x11b0 <_ZN7OneWire6searchEPhb+0xde>
            LastDeviceFlag = true;
    11ac:	81 e0       	ldi	r24, 0x01	; 1
    11ae:	8d 87       	std	Y+13, r24	; 0x0d
         search_result = true;
      }
   }

   // if no device found then reset counters so next 'search' will be like a first
   if (!search_result || !ROM_NO[0]) {
    11b0:	8b 81       	ldd	r24, Y+3	; 0x03
    11b2:	88 23       	and	r24, r24
    11b4:	09 f4       	brne	.+2      	; 0x11b8 <_ZN7OneWire6searchEPhb+0xe6>
    11b6:	a1 cf       	rjmp	.-190    	; 0x10fa <_ZN7OneWire6searchEPhb+0x28>
    11b8:	de 01       	movw	r26, r28
    11ba:	13 96       	adiw	r26, 0x03	; 3
    11bc:	f6 01       	movw	r30, r12
    11be:	2b 96       	adiw	r28, 0x0b	; 11
      LastDiscrepancy = 0;
      LastDeviceFlag = false;
      LastFamilyDiscrepancy = 0;
      search_result = false;
   } else {
      for (int i = 0; i < 8; i++) newAddr[i] = ROM_NO[i];
    11c0:	8d 91       	ld	r24, X+
    11c2:	81 93       	st	Z+, r24
    11c4:	ca 17       	cp	r28, r26
    11c6:	db 07       	cpc	r29, r27
    11c8:	d9 f7       	brne	.-10     	; 0x11c0 <_ZN7OneWire6searchEPhb+0xee>
    11ca:	81 e0       	ldi	r24, 0x01	; 1
   }
   return search_result;
  }
    11cc:	df 91       	pop	r29
    11ce:	cf 91       	pop	r28
    11d0:	1f 91       	pop	r17
    11d2:	0f 91       	pop	r16
    11d4:	ff 90       	pop	r15
    11d6:	ef 90       	pop	r14
    11d8:	df 90       	pop	r13
    11da:	cf 90       	pop	r12
    11dc:	bf 90       	pop	r11
    11de:	08 95       	ret

000011e0 <_ZN7OneWire4crc8EPKhh>:
};

// Compute a Dallas Semiconductor 8 bit CRC. These show up in the ROM
// and the registers.  (Use tiny 2x16 entry CRC table)
uint8_t OneWire::crc8(const uint8_t *addr, uint8_t len)
{
    11e0:	dc 01       	movw	r26, r24
	uint8_t crc = 0;
    11e2:	80 e0       	ldi	r24, 0x00	; 0

	while (len--) {
    11e4:	61 50       	subi	r22, 0x01	; 1
    11e6:	98 f0       	brcs	.+38     	; 0x120e <_ZN7OneWire4crc8EPKhh+0x2e>
		crc = *addr++ ^ crc;  // just re-using crc as intermediate
    11e8:	2d 91       	ld	r18, X+
    11ea:	98 2f       	mov	r25, r24
    11ec:	92 27       	eor	r25, r18
		crc = pgm_read_byte(dscrc2x16_table + (crc & 0x0f)) ^
    11ee:	e9 2f       	mov	r30, r25
    11f0:	ef 70       	andi	r30, 0x0F	; 15
    11f2:	f0 e0       	ldi	r31, 0x00	; 0
    11f4:	ee 56       	subi	r30, 0x6E	; 110
    11f6:	ff 4f       	sbci	r31, 0xFF	; 255
    11f8:	24 91       	lpm	r18, Z
		pgm_read_byte(dscrc2x16_table + 16 + ((crc >> 4) & 0x0f));
    11fa:	92 95       	swap	r25
    11fc:	9f 70       	andi	r25, 0x0F	; 15
    11fe:	e9 2f       	mov	r30, r25
    1200:	f0 e0       	ldi	r31, 0x00	; 0
    1202:	ee 55       	subi	r30, 0x5E	; 94
    1204:	ff 4f       	sbci	r31, 0xFF	; 255
    1206:	e4 91       	lpm	r30, Z
    1208:	82 2f       	mov	r24, r18
    120a:	8e 27       	eor	r24, r30
// and the registers.  (Use tiny 2x16 entry CRC table)
uint8_t OneWire::crc8(const uint8_t *addr, uint8_t len)
{
	uint8_t crc = 0;

	while (len--) {
    120c:	eb cf       	rjmp	.-42     	; 0x11e4 <_ZN7OneWire4crc8EPKhh+0x4>
		crc = pgm_read_byte(dscrc2x16_table + (crc & 0x0f)) ^
		pgm_read_byte(dscrc2x16_table + 16 + ((crc >> 4) & 0x0f));
	}

	return crc;
}
    120e:	08 95       	ret

00001210 <_Z6calcPHv>:
float neutralVoltage = 404.0;
float acidVoltage = 166.0;


float calcPH()
{
    1210:	8f 92       	push	r8
    1212:	9f 92       	push	r9
    1214:	af 92       	push	r10
    1216:	bf 92       	push	r11
    1218:	cf 92       	push	r12
    121a:	df 92       	push	r13
    121c:	ef 92       	push	r14
    121e:	ff 92       	push	r15
    1220:	cf 93       	push	r28
    1222:	df 93       	push	r29
	float voltage = analogRead(PH_PIN);
    1224:	8e e0       	ldi	r24, 0x0E	; 14
    1226:	0e 94 8a 21 	call	0x4314	; 0x4314 <analogRead>
    122a:	ec 01       	movw	r28, r24
	float slope = (7.0 - 4.0)/(neutralVoltage - acidVoltage);
    122c:	80 90 39 01 	lds	r8, 0x0139	; 0x800139 <neutralVoltage>
    1230:	90 90 3a 01 	lds	r9, 0x013A	; 0x80013a <neutralVoltage+0x1>
    1234:	a0 90 3b 01 	lds	r10, 0x013B	; 0x80013b <neutralVoltage+0x2>
    1238:	b0 90 3c 01 	lds	r11, 0x013C	; 0x80013c <neutralVoltage+0x3>
    123c:	20 91 35 01 	lds	r18, 0x0135	; 0x800135 <acidVoltage>
    1240:	30 91 36 01 	lds	r19, 0x0136	; 0x800136 <acidVoltage+0x1>
    1244:	40 91 37 01 	lds	r20, 0x0137	; 0x800137 <acidVoltage+0x2>
    1248:	50 91 38 01 	lds	r21, 0x0138	; 0x800138 <acidVoltage+0x3>
    124c:	c5 01       	movw	r24, r10
    124e:	b4 01       	movw	r22, r8
    1250:	0e 94 d5 1a 	call	0x35aa	; 0x35aa <__subsf3>
    1254:	9b 01       	movw	r18, r22
    1256:	ac 01       	movw	r20, r24
    1258:	60 e0       	ldi	r22, 0x00	; 0
    125a:	70 e0       	ldi	r23, 0x00	; 0
    125c:	80 e4       	ldi	r24, 0x40	; 64
    125e:	90 e4       	ldi	r25, 0x40	; 64
    1260:	0e 94 47 1b 	call	0x368e	; 0x368e <__divsf3>
    1264:	6b 01       	movw	r12, r22
    1266:	7c 01       	movw	r14, r24
	Serial.print(neutralVoltage);
	Serial.write("\nAcid Voltage:");
	Serial.print(acidVoltage);
	Serial.write("\nVoltage Measured:");
	Serial.print(voltage);  */
	return (slope * voltage) + intercept;
    1268:	9b 01       	movw	r18, r22
    126a:	ac 01       	movw	r20, r24
    126c:	c5 01       	movw	r24, r10
    126e:	b4 01       	movw	r22, r8
    1270:	0e 94 a1 1c 	call	0x3942	; 0x3942 <__mulsf3>
    1274:	9b 01       	movw	r18, r22
    1276:	ac 01       	movw	r20, r24
    1278:	60 e0       	ldi	r22, 0x00	; 0
    127a:	70 e0       	ldi	r23, 0x00	; 0
    127c:	80 ee       	ldi	r24, 0xE0	; 224
    127e:	90 e4       	ldi	r25, 0x40	; 64
    1280:	0e 94 d5 1a 	call	0x35aa	; 0x35aa <__subsf3>
    1284:	4b 01       	movw	r8, r22
    1286:	5c 01       	movw	r10, r24
    1288:	be 01       	movw	r22, r28
    128a:	dd 0f       	add	r29, r29
    128c:	88 0b       	sbc	r24, r24
    128e:	99 0b       	sbc	r25, r25
    1290:	0e 94 f1 1b 	call	0x37e2	; 0x37e2 <__floatsisf>
    1294:	a7 01       	movw	r20, r14
    1296:	96 01       	movw	r18, r12
    1298:	0e 94 a1 1c 	call	0x3942	; 0x3942 <__mulsf3>
    129c:	9b 01       	movw	r18, r22
    129e:	ac 01       	movw	r20, r24
    12a0:	c5 01       	movw	r24, r10
    12a2:	b4 01       	movw	r22, r8
    12a4:	0e 94 d6 1a 	call	0x35ac	; 0x35ac <__addsf3>
    12a8:	df 91       	pop	r29
    12aa:	cf 91       	pop	r28
    12ac:	ff 90       	pop	r15
    12ae:	ef 90       	pop	r14
    12b0:	df 90       	pop	r13
    12b2:	cf 90       	pop	r12
    12b4:	bf 90       	pop	r11
    12b6:	af 90       	pop	r10
    12b8:	9f 90       	pop	r9
    12ba:	8f 90       	pop	r8
    12bc:	08 95       	ret

000012be <pvPortMalloc>:
#if( configSUPPORT_DYNAMIC_ALLOCATION > 0 )

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
    12be:	cf 93       	push	r28
    12c0:	df 93       	push	r29
    12c2:	ec 01       	movw	r28, r24
void *pvReturn;

    vTaskSuspendAll();
    12c4:	0e 94 0c 11 	call	0x2218	; 0x2218 <vTaskSuspendAll>
    {
        pvReturn = malloc( xWantedSize );
    12c8:	ce 01       	movw	r24, r28
    12ca:	0e 94 3a 24 	call	0x4874	; 0x4874 <malloc>
    12ce:	ec 01       	movw	r28, r24
        traceMALLOC( pvReturn, xWantedSize );
    }
    ( void ) xTaskResumeAll();
    12d0:	0e 94 c8 11 	call	0x2390	; 0x2390 <xTaskResumeAll>

    #if( configUSE_MALLOC_FAILED_HOOK == 1 )
    {
        if( pvReturn == NULL )
    12d4:	20 97       	sbiw	r28, 0x00	; 0
    12d6:	11 f4       	brne	.+4      	; 0x12dc <pvPortMalloc+0x1e>
        {
            extern void vApplicationMallocFailedHook( void );
            vApplicationMallocFailedHook();
    12d8:	0e 94 a5 16 	call	0x2d4a	; 0x2d4a <vApplicationMallocFailedHook>
        }
    }
    #endif

    return pvReturn;
}
    12dc:	ce 01       	movw	r24, r28
    12de:	df 91       	pop	r29
    12e0:	cf 91       	pop	r28
    12e2:	08 95       	ret

000012e4 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
    12e4:	cf 93       	push	r28
    12e6:	df 93       	push	r29
    if( pv )
    12e8:	00 97       	sbiw	r24, 0x00	; 0
    12ea:	51 f0       	breq	.+20     	; 0x1300 <vPortFree+0x1c>
    12ec:	ec 01       	movw	r28, r24
    {
        vTaskSuspendAll();
    12ee:	0e 94 0c 11 	call	0x2218	; 0x2218 <vTaskSuspendAll>
        {
            free( pv );
    12f2:	ce 01       	movw	r24, r28
    12f4:	0e 94 d2 24 	call	0x49a4	; 0x49a4 <free>
            traceFREE( pv, 0 );
        }
        ( void ) xTaskResumeAll();
    }
}
    12f8:	df 91       	pop	r29
    12fa:	cf 91       	pop	r28
        vTaskSuspendAll();
        {
            free( pv );
            traceFREE( pv, 0 );
        }
        ( void ) xTaskResumeAll();
    12fc:	0c 94 c8 11 	jmp	0x2390	; 0x2390 <xTaskResumeAll>
    }
}
    1300:	df 91       	pop	r29
    1302:	cf 91       	pop	r28
    1304:	08 95       	ret

00001306 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
    1306:	fc 01       	movw	r30, r24
    /* The list structure contains a list item which is used to mark the
    end of the list.  To initialise the list the list end is inserted
    as the only list entry. */
    pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );            /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    1308:	03 96       	adiw	r24, 0x03	; 3
    130a:	92 83       	std	Z+2, r25	; 0x02
    130c:	81 83       	std	Z+1, r24	; 0x01

    /* The list end value is the highest possible value in the list to
    ensure it remains at the end of the list. */
    pxList->xListEnd.xItemValue = portMAX_DELAY;
    130e:	2f ef       	ldi	r18, 0xFF	; 255
    1310:	3f ef       	ldi	r19, 0xFF	; 255
    1312:	34 83       	std	Z+4, r19	; 0x04
    1314:	23 83       	std	Z+3, r18	; 0x03

    /* The list end next and previous pointers point to itself so we know
    when the list is empty. */
    pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );    /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    1316:	96 83       	std	Z+6, r25	; 0x06
    1318:	85 83       	std	Z+5, r24	; 0x05
    pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    131a:	90 87       	std	Z+8, r25	; 0x08
    131c:	87 83       	std	Z+7, r24	; 0x07

    pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
    131e:	10 82       	st	Z, r1
    1320:	08 95       	ret

00001322 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
    /* Make sure the list item is not recorded as being on a list. */
    pxItem->pxContainer = NULL;
    1322:	fc 01       	movw	r30, r24
    1324:	11 86       	std	Z+9, r1	; 0x09
    1326:	10 86       	std	Z+8, r1	; 0x08
    1328:	08 95       	ret

0000132a <vListInsertEnd>:
    listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    132a:	cf 93       	push	r28
    132c:	df 93       	push	r29
    132e:	9c 01       	movw	r18, r24
    1330:	fb 01       	movw	r30, r22
ListItem_t * const pxIndex = pxList->pxIndex;
    1332:	dc 01       	movw	r26, r24
    1334:	11 96       	adiw	r26, 0x01	; 1
    1336:	cd 91       	ld	r28, X+
    1338:	dc 91       	ld	r29, X
    133a:	12 97       	sbiw	r26, 0x02	; 2
    listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

    /* Insert a new list item into pxList, but rather than sort the list,
    makes the new list item the last item to be removed by a call to
    listGET_OWNER_OF_NEXT_ENTRY(). */
    pxNewListItem->pxNext = pxIndex;
    133c:	d3 83       	std	Z+3, r29	; 0x03
    133e:	c2 83       	std	Z+2, r28	; 0x02
    pxNewListItem->pxPrevious = pxIndex->pxPrevious;
    1340:	8c 81       	ldd	r24, Y+4	; 0x04
    1342:	9d 81       	ldd	r25, Y+5	; 0x05
    1344:	95 83       	std	Z+5, r25	; 0x05
    1346:	84 83       	std	Z+4, r24	; 0x04

    /* Only used during decision coverage testing. */
    mtCOVERAGE_TEST_DELAY();

    pxIndex->pxPrevious->pxNext = pxNewListItem;
    1348:	8c 81       	ldd	r24, Y+4	; 0x04
    134a:	9d 81       	ldd	r25, Y+5	; 0x05
    134c:	dc 01       	movw	r26, r24
    134e:	13 96       	adiw	r26, 0x03	; 3
    1350:	7c 93       	st	X, r23
    1352:	6e 93       	st	-X, r22
    1354:	12 97       	sbiw	r26, 0x02	; 2
    pxIndex->pxPrevious = pxNewListItem;
    1356:	7d 83       	std	Y+5, r23	; 0x05
    1358:	6c 83       	std	Y+4, r22	; 0x04

    /* Remember which list the item is in. */
    pxNewListItem->pxContainer = pxList;
    135a:	31 87       	std	Z+9, r19	; 0x09
    135c:	20 87       	std	Z+8, r18	; 0x08

    ( pxList->uxNumberOfItems )++;
    135e:	f9 01       	movw	r30, r18
    1360:	80 81       	ld	r24, Z
    1362:	8f 5f       	subi	r24, 0xFF	; 255
    1364:	80 83       	st	Z, r24
}
    1366:	df 91       	pop	r29
    1368:	cf 91       	pop	r28
    136a:	08 95       	ret

0000136c <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    136c:	0f 93       	push	r16
    136e:	1f 93       	push	r17
    1370:	cf 93       	push	r28
    1372:	df 93       	push	r29
    1374:	8c 01       	movw	r16, r24
    1376:	fb 01       	movw	r30, r22
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
    1378:	80 81       	ld	r24, Z
    137a:	91 81       	ldd	r25, Z+1	; 0x01
    new list item should be placed after it.  This ensures that TCBs which are
    stored in ready lists (all of which have the same xItemValue value) get a
    share of the CPU.  However, if the xItemValue is the same as the back marker
    the iteration loop below will not end.  Therefore the value is checked
    first, and the algorithm slightly modified if necessary. */
    if( xValueOfInsertion == portMAX_DELAY )
    137c:	8f 3f       	cpi	r24, 0xFF	; 255
    137e:	2f ef       	ldi	r18, 0xFF	; 255
    1380:	92 07       	cpc	r25, r18
    1382:	21 f4       	brne	.+8      	; 0x138c <vListInsert+0x20>
    {
        pxIterator = pxList->xListEnd.pxPrevious;
    1384:	e8 01       	movw	r28, r16
    1386:	af 81       	ldd	r26, Y+7	; 0x07
    1388:	b8 85       	ldd	r27, Y+8	; 0x08
    138a:	0e c0       	rjmp	.+28     	; 0x13a8 <vListInsert+0x3c>
            4) Using a queue or semaphore before it has been initialised or
               before the scheduler has been started (are interrupts firing
               before vTaskStartScheduler() has been called?).
        **********************************************************************/

        for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. *//*lint !e440 The iterator moves to a different value, not xValueOfInsertion. */
    138c:	d8 01       	movw	r26, r16
    138e:	13 96       	adiw	r26, 0x03	; 3
    1390:	12 96       	adiw	r26, 0x02	; 2
    1392:	2d 91       	ld	r18, X+
    1394:	3c 91       	ld	r19, X
    1396:	13 97       	sbiw	r26, 0x03	; 3
    1398:	e9 01       	movw	r28, r18
    139a:	48 81       	ld	r20, Y
    139c:	59 81       	ldd	r21, Y+1	; 0x01
    139e:	84 17       	cp	r24, r20
    13a0:	95 07       	cpc	r25, r21
    13a2:	10 f0       	brcs	.+4      	; 0x13a8 <vListInsert+0x3c>
    13a4:	d9 01       	movw	r26, r18
    13a6:	f4 cf       	rjmp	.-24     	; 0x1390 <vListInsert+0x24>
            /* There is nothing to do here, just iterating to the wanted
            insertion position. */
        }
    }

    pxNewListItem->pxNext = pxIterator->pxNext;
    13a8:	12 96       	adiw	r26, 0x02	; 2
    13aa:	8d 91       	ld	r24, X+
    13ac:	9c 91       	ld	r25, X
    13ae:	13 97       	sbiw	r26, 0x03	; 3
    13b0:	93 83       	std	Z+3, r25	; 0x03
    13b2:	82 83       	std	Z+2, r24	; 0x02
    pxNewListItem->pxNext->pxPrevious = pxNewListItem;
    13b4:	ec 01       	movw	r28, r24
    13b6:	fd 83       	std	Y+5, r31	; 0x05
    13b8:	ec 83       	std	Y+4, r30	; 0x04
    pxNewListItem->pxPrevious = pxIterator;
    13ba:	b5 83       	std	Z+5, r27	; 0x05
    13bc:	a4 83       	std	Z+4, r26	; 0x04
    pxIterator->pxNext = pxNewListItem;
    13be:	13 96       	adiw	r26, 0x03	; 3
    13c0:	fc 93       	st	X, r31
    13c2:	ee 93       	st	-X, r30
    13c4:	12 97       	sbiw	r26, 0x02	; 2

    /* Remember which list the item is in.  This allows fast removal of the
    item later. */
    pxNewListItem->pxContainer = pxList;
    13c6:	11 87       	std	Z+9, r17	; 0x09
    13c8:	00 87       	std	Z+8, r16	; 0x08

    ( pxList->uxNumberOfItems )++;
    13ca:	f8 01       	movw	r30, r16
    13cc:	80 81       	ld	r24, Z
    13ce:	8f 5f       	subi	r24, 0xFF	; 255
    13d0:	80 83       	st	Z, r24
}
    13d2:	df 91       	pop	r29
    13d4:	cf 91       	pop	r28
    13d6:	1f 91       	pop	r17
    13d8:	0f 91       	pop	r16
    13da:	08 95       	ret

000013dc <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
    13dc:	cf 93       	push	r28
    13de:	df 93       	push	r29
    13e0:	fc 01       	movw	r30, r24
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = pxItemToRemove->pxContainer;
    13e2:	a0 85       	ldd	r26, Z+8	; 0x08
    13e4:	b1 85       	ldd	r27, Z+9	; 0x09

    pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    13e6:	82 81       	ldd	r24, Z+2	; 0x02
    13e8:	93 81       	ldd	r25, Z+3	; 0x03
    13ea:	24 81       	ldd	r18, Z+4	; 0x04
    13ec:	35 81       	ldd	r19, Z+5	; 0x05
    13ee:	ec 01       	movw	r28, r24
    13f0:	3d 83       	std	Y+5, r19	; 0x05
    13f2:	2c 83       	std	Y+4, r18	; 0x04
    pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    13f4:	c4 81       	ldd	r28, Z+4	; 0x04
    13f6:	d5 81       	ldd	r29, Z+5	; 0x05
    13f8:	9b 83       	std	Y+3, r25	; 0x03
    13fa:	8a 83       	std	Y+2, r24	; 0x02

    /* Only used during decision coverage testing. */
    mtCOVERAGE_TEST_DELAY();

    /* Make sure the index is left pointing to a valid item. */
    if( pxList->pxIndex == pxItemToRemove )
    13fc:	11 96       	adiw	r26, 0x01	; 1
    13fe:	8d 91       	ld	r24, X+
    1400:	9c 91       	ld	r25, X
    1402:	12 97       	sbiw	r26, 0x02	; 2
    1404:	e8 17       	cp	r30, r24
    1406:	f9 07       	cpc	r31, r25
    1408:	21 f4       	brne	.+8      	; 0x1412 <uxListRemove+0x36>
    {
        pxList->pxIndex = pxItemToRemove->pxPrevious;
    140a:	12 96       	adiw	r26, 0x02	; 2
    140c:	dc 93       	st	X, r29
    140e:	ce 93       	st	-X, r28
    1410:	11 97       	sbiw	r26, 0x01	; 1
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }

    pxItemToRemove->pxContainer = NULL;
    1412:	11 86       	std	Z+9, r1	; 0x09
    1414:	10 86       	std	Z+8, r1	; 0x08
    ( pxList->uxNumberOfItems )--;
    1416:	8c 91       	ld	r24, X
    1418:	81 50       	subi	r24, 0x01	; 1
    141a:	8c 93       	st	X, r24

    return pxList->uxNumberOfItems;
    141c:	8c 91       	ld	r24, X
}
    141e:	df 91       	pop	r29
    1420:	cf 91       	pop	r28
    1422:	08 95       	ret

00001424 <pxPortInitialiseStack>:
		);
	}
	else
	{
        uint8_t register temp_reg;
		__asm__ __volatile__ (
    1424:	31 e1       	ldi	r19, 0x11	; 17
    1426:	fc 01       	movw	r30, r24
    1428:	30 83       	st	Z, r19
    142a:	31 97       	sbiw	r30, 0x01	; 1
    142c:	22 e2       	ldi	r18, 0x22	; 34
    142e:	20 83       	st	Z, r18
    1430:	31 97       	sbiw	r30, 0x01	; 1
    1432:	a3 e3       	ldi	r26, 0x33	; 51
    1434:	a0 83       	st	Z, r26
    1436:	31 97       	sbiw	r30, 0x01	; 1
    1438:	60 83       	st	Z, r22
    143a:	31 97       	sbiw	r30, 0x01	; 1
    143c:	70 83       	st	Z, r23
    143e:	31 97       	sbiw	r30, 0x01	; 1
    1440:	10 82       	st	Z, r1
    1442:	31 97       	sbiw	r30, 0x01	; 1
    1444:	60 e8       	ldi	r22, 0x80	; 128
    1446:	60 83       	st	Z, r22
    1448:	31 97       	sbiw	r30, 0x01	; 1
    144a:	10 82       	st	Z, r1
    144c:	31 97       	sbiw	r30, 0x01	; 1
    144e:	62 e0       	ldi	r22, 0x02	; 2
    1450:	60 83       	st	Z, r22
    1452:	31 97       	sbiw	r30, 0x01	; 1
    1454:	63 e0       	ldi	r22, 0x03	; 3
    1456:	60 83       	st	Z, r22
    1458:	31 97       	sbiw	r30, 0x01	; 1
    145a:	64 e0       	ldi	r22, 0x04	; 4
    145c:	60 83       	st	Z, r22
    145e:	31 97       	sbiw	r30, 0x01	; 1
    1460:	65 e0       	ldi	r22, 0x05	; 5
    1462:	60 83       	st	Z, r22
    1464:	31 97       	sbiw	r30, 0x01	; 1
    1466:	66 e0       	ldi	r22, 0x06	; 6
    1468:	60 83       	st	Z, r22
    146a:	31 97       	sbiw	r30, 0x01	; 1
    146c:	67 e0       	ldi	r22, 0x07	; 7
    146e:	60 83       	st	Z, r22
    1470:	31 97       	sbiw	r30, 0x01	; 1
    1472:	68 e0       	ldi	r22, 0x08	; 8
    1474:	60 83       	st	Z, r22
    1476:	31 97       	sbiw	r30, 0x01	; 1
    1478:	69 e0       	ldi	r22, 0x09	; 9
    147a:	60 83       	st	Z, r22
    147c:	31 97       	sbiw	r30, 0x01	; 1
    147e:	60 e1       	ldi	r22, 0x10	; 16
    1480:	60 83       	st	Z, r22
    1482:	31 97       	sbiw	r30, 0x01	; 1
    1484:	30 83       	st	Z, r19
    1486:	31 97       	sbiw	r30, 0x01	; 1
    1488:	32 e1       	ldi	r19, 0x12	; 18
    148a:	30 83       	st	Z, r19
    148c:	31 97       	sbiw	r30, 0x01	; 1
    148e:	33 e1       	ldi	r19, 0x13	; 19
    1490:	30 83       	st	Z, r19
    1492:	31 97       	sbiw	r30, 0x01	; 1
    1494:	34 e1       	ldi	r19, 0x14	; 20
    1496:	30 83       	st	Z, r19
    1498:	31 97       	sbiw	r30, 0x01	; 1
    149a:	35 e1       	ldi	r19, 0x15	; 21
    149c:	30 83       	st	Z, r19
    149e:	31 97       	sbiw	r30, 0x01	; 1
    14a0:	36 e1       	ldi	r19, 0x16	; 22
    14a2:	30 83       	st	Z, r19
    14a4:	31 97       	sbiw	r30, 0x01	; 1
    14a6:	37 e1       	ldi	r19, 0x17	; 23
    14a8:	30 83       	st	Z, r19
    14aa:	31 97       	sbiw	r30, 0x01	; 1
    14ac:	38 e1       	ldi	r19, 0x18	; 24
    14ae:	30 83       	st	Z, r19
    14b0:	31 97       	sbiw	r30, 0x01	; 1
    14b2:	39 e1       	ldi	r19, 0x19	; 25
    14b4:	30 83       	st	Z, r19
    14b6:	31 97       	sbiw	r30, 0x01	; 1
    14b8:	30 e2       	ldi	r19, 0x20	; 32
    14ba:	30 83       	st	Z, r19
    14bc:	31 97       	sbiw	r30, 0x01	; 1
    14be:	31 e2       	ldi	r19, 0x21	; 33
    14c0:	30 83       	st	Z, r19
    14c2:	31 97       	sbiw	r30, 0x01	; 1
    14c4:	20 83       	st	Z, r18
    14c6:	31 97       	sbiw	r30, 0x01	; 1
    14c8:	23 e2       	ldi	r18, 0x23	; 35
    14ca:	20 83       	st	Z, r18
    14cc:	31 97       	sbiw	r30, 0x01	; 1
    14ce:	40 83       	st	Z, r20
    14d0:	31 97       	sbiw	r30, 0x01	; 1
    14d2:	50 83       	st	Z, r21
    14d4:	31 97       	sbiw	r30, 0x01	; 1
    14d6:	26 e2       	ldi	r18, 0x26	; 38
    14d8:	20 83       	st	Z, r18
    14da:	31 97       	sbiw	r30, 0x01	; 1
    14dc:	27 e2       	ldi	r18, 0x27	; 39
    14de:	20 83       	st	Z, r18
    14e0:	31 97       	sbiw	r30, 0x01	; 1
    14e2:	28 e2       	ldi	r18, 0x28	; 40
    14e4:	20 83       	st	Z, r18
    14e6:	31 97       	sbiw	r30, 0x01	; 1
    14e8:	29 e2       	ldi	r18, 0x29	; 41
    14ea:	20 83       	st	Z, r18
    14ec:	31 97       	sbiw	r30, 0x01	; 1
    14ee:	20 e3       	ldi	r18, 0x30	; 48
    14f0:	20 83       	st	Z, r18
    14f2:	31 97       	sbiw	r30, 0x01	; 1
    14f4:	21 e3       	ldi	r18, 0x31	; 49
    14f6:	20 83       	st	Z, r18
    14f8:	86 97       	sbiw	r24, 0x26	; 38
    14fa:	08 95       	ret

000014fc <xPortStartScheduler>:
    14fc:	a8 95       	wdr
    14fe:	90 ec       	ldi	r25, 0xC0	; 192
    1500:	88 e1       	ldi	r24, 0x18	; 24
    1502:	0f b6       	in	r0, 0x3f	; 63
    1504:	f8 94       	cli
    1506:	a8 95       	wdr
    1508:	80 93 60 00 	sts	0x0060, r24	; 0x800060 <__DATA_REGION_ORIGIN__>
    150c:	0f be       	out	0x3f, r0	; 63
    150e:	90 93 60 00 	sts	0x0060, r25	; 0x800060 <__DATA_REGION_ORIGIN__>
    1512:	a0 91 c0 03 	lds	r26, 0x03C0	; 0x8003c0 <pxCurrentTCB>
    1516:	b0 91 c1 03 	lds	r27, 0x03C1	; 0x8003c1 <pxCurrentTCB+0x1>
    151a:	cd 91       	ld	r28, X+
    151c:	cd bf       	out	0x3d, r28	; 61
    151e:	dd 91       	ld	r29, X+
    1520:	de bf       	out	0x3e, r29	; 62
    1522:	ff 91       	pop	r31
    1524:	ef 91       	pop	r30
    1526:	df 91       	pop	r29
    1528:	cf 91       	pop	r28
    152a:	bf 91       	pop	r27
    152c:	af 91       	pop	r26
    152e:	9f 91       	pop	r25
    1530:	8f 91       	pop	r24
    1532:	7f 91       	pop	r23
    1534:	6f 91       	pop	r22
    1536:	5f 91       	pop	r21
    1538:	4f 91       	pop	r20
    153a:	3f 91       	pop	r19
    153c:	2f 91       	pop	r18
    153e:	1f 91       	pop	r17
    1540:	0f 91       	pop	r16
    1542:	ff 90       	pop	r15
    1544:	ef 90       	pop	r14
    1546:	df 90       	pop	r13
    1548:	cf 90       	pop	r12
    154a:	bf 90       	pop	r11
    154c:	af 90       	pop	r10
    154e:	9f 90       	pop	r9
    1550:	8f 90       	pop	r8
    1552:	7f 90       	pop	r7
    1554:	6f 90       	pop	r6
    1556:	5f 90       	pop	r5
    1558:	4f 90       	pop	r4
    155a:	3f 90       	pop	r3
    155c:	2f 90       	pop	r2
    155e:	1f 90       	pop	r1
    1560:	0f 90       	pop	r0
    1562:	0f be       	out	0x3f, r0	; 63
    1564:	0f 90       	pop	r0
    1566:	08 95       	ret
    1568:	81 e0       	ldi	r24, 0x01	; 1
    156a:	08 95       	ret

0000156c <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( hot, flatten, naked ) );
void vPortYield( void )
{
    portSAVE_CONTEXT();
    156c:	0f 92       	push	r0
    156e:	0f b6       	in	r0, 0x3f	; 63
    1570:	f8 94       	cli
    1572:	0f 92       	push	r0
    1574:	1f 92       	push	r1
    1576:	11 24       	eor	r1, r1
    1578:	2f 92       	push	r2
    157a:	3f 92       	push	r3
    157c:	4f 92       	push	r4
    157e:	5f 92       	push	r5
    1580:	6f 92       	push	r6
    1582:	7f 92       	push	r7
    1584:	8f 92       	push	r8
    1586:	9f 92       	push	r9
    1588:	af 92       	push	r10
    158a:	bf 92       	push	r11
    158c:	cf 92       	push	r12
    158e:	df 92       	push	r13
    1590:	ef 92       	push	r14
    1592:	ff 92       	push	r15
    1594:	0f 93       	push	r16
    1596:	1f 93       	push	r17
    1598:	2f 93       	push	r18
    159a:	3f 93       	push	r19
    159c:	4f 93       	push	r20
    159e:	5f 93       	push	r21
    15a0:	6f 93       	push	r22
    15a2:	7f 93       	push	r23
    15a4:	8f 93       	push	r24
    15a6:	9f 93       	push	r25
    15a8:	af 93       	push	r26
    15aa:	bf 93       	push	r27
    15ac:	cf 93       	push	r28
    15ae:	df 93       	push	r29
    15b0:	ef 93       	push	r30
    15b2:	ff 93       	push	r31
    15b4:	a0 91 c0 03 	lds	r26, 0x03C0	; 0x8003c0 <pxCurrentTCB>
    15b8:	b0 91 c1 03 	lds	r27, 0x03C1	; 0x8003c1 <pxCurrentTCB+0x1>
    15bc:	0d b6       	in	r0, 0x3d	; 61
    15be:	0d 92       	st	X+, r0
    15c0:	0e b6       	in	r0, 0x3e	; 62
    15c2:	0d 92       	st	X+, r0
    vTaskSwitchContext();
    15c4:	0e 94 84 12 	call	0x2508	; 0x2508 <vTaskSwitchContext>
    portRESTORE_CONTEXT();
    15c8:	a0 91 c0 03 	lds	r26, 0x03C0	; 0x8003c0 <pxCurrentTCB>
    15cc:	b0 91 c1 03 	lds	r27, 0x03C1	; 0x8003c1 <pxCurrentTCB+0x1>
    15d0:	cd 91       	ld	r28, X+
    15d2:	cd bf       	out	0x3d, r28	; 61
    15d4:	dd 91       	ld	r29, X+
    15d6:	de bf       	out	0x3e, r29	; 62
    15d8:	ff 91       	pop	r31
    15da:	ef 91       	pop	r30
    15dc:	df 91       	pop	r29
    15de:	cf 91       	pop	r28
    15e0:	bf 91       	pop	r27
    15e2:	af 91       	pop	r26
    15e4:	9f 91       	pop	r25
    15e6:	8f 91       	pop	r24
    15e8:	7f 91       	pop	r23
    15ea:	6f 91       	pop	r22
    15ec:	5f 91       	pop	r21
    15ee:	4f 91       	pop	r20
    15f0:	3f 91       	pop	r19
    15f2:	2f 91       	pop	r18
    15f4:	1f 91       	pop	r17
    15f6:	0f 91       	pop	r16
    15f8:	ff 90       	pop	r15
    15fa:	ef 90       	pop	r14
    15fc:	df 90       	pop	r13
    15fe:	cf 90       	pop	r12
    1600:	bf 90       	pop	r11
    1602:	af 90       	pop	r10
    1604:	9f 90       	pop	r9
    1606:	8f 90       	pop	r8
    1608:	7f 90       	pop	r7
    160a:	6f 90       	pop	r6
    160c:	5f 90       	pop	r5
    160e:	4f 90       	pop	r4
    1610:	3f 90       	pop	r3
    1612:	2f 90       	pop	r2
    1614:	1f 90       	pop	r1
    1616:	0f 90       	pop	r0
    1618:	0f be       	out	0x3f, r0	; 63
    161a:	0f 90       	pop	r0

    __asm__ __volatile__ ( "ret" );
    161c:	08 95       	ret

0000161e <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( hot, flatten, naked ) );
void vPortYieldFromTick( void )
{
    portSAVE_CONTEXT();
    161e:	0f 92       	push	r0
    1620:	0f b6       	in	r0, 0x3f	; 63
    1622:	f8 94       	cli
    1624:	0f 92       	push	r0
    1626:	1f 92       	push	r1
    1628:	11 24       	eor	r1, r1
    162a:	2f 92       	push	r2
    162c:	3f 92       	push	r3
    162e:	4f 92       	push	r4
    1630:	5f 92       	push	r5
    1632:	6f 92       	push	r6
    1634:	7f 92       	push	r7
    1636:	8f 92       	push	r8
    1638:	9f 92       	push	r9
    163a:	af 92       	push	r10
    163c:	bf 92       	push	r11
    163e:	cf 92       	push	r12
    1640:	df 92       	push	r13
    1642:	ef 92       	push	r14
    1644:	ff 92       	push	r15
    1646:	0f 93       	push	r16
    1648:	1f 93       	push	r17
    164a:	2f 93       	push	r18
    164c:	3f 93       	push	r19
    164e:	4f 93       	push	r20
    1650:	5f 93       	push	r21
    1652:	6f 93       	push	r22
    1654:	7f 93       	push	r23
    1656:	8f 93       	push	r24
    1658:	9f 93       	push	r25
    165a:	af 93       	push	r26
    165c:	bf 93       	push	r27
    165e:	cf 93       	push	r28
    1660:	df 93       	push	r29
    1662:	ef 93       	push	r30
    1664:	ff 93       	push	r31
    1666:	a0 91 c0 03 	lds	r26, 0x03C0	; 0x8003c0 <pxCurrentTCB>
    166a:	b0 91 c1 03 	lds	r27, 0x03C1	; 0x8003c1 <pxCurrentTCB+0x1>
    166e:	0d b6       	in	r0, 0x3d	; 61
    1670:	0d 92       	st	X+, r0
    1672:	0e b6       	in	r0, 0x3e	; 62
    1674:	0d 92       	st	X+, r0

    sleep_reset();        //     reset the sleep_mode() faster than sleep_disable();
    1676:	13 be       	out	0x33, r1	; 51

    if( xTaskIncrementTick() != pdFALSE )
    1678:	0e 94 1c 11 	call	0x2238	; 0x2238 <xTaskIncrementTick>
    167c:	81 11       	cpse	r24, r1
    {
        vTaskSwitchContext();
    167e:	0e 94 84 12 	call	0x2508	; 0x2508 <vTaskSwitchContext>
    }

    portRESTORE_CONTEXT();
    1682:	a0 91 c0 03 	lds	r26, 0x03C0	; 0x8003c0 <pxCurrentTCB>
    1686:	b0 91 c1 03 	lds	r27, 0x03C1	; 0x8003c1 <pxCurrentTCB+0x1>
    168a:	cd 91       	ld	r28, X+
    168c:	cd bf       	out	0x3d, r28	; 61
    168e:	dd 91       	ld	r29, X+
    1690:	de bf       	out	0x3e, r29	; 62
    1692:	ff 91       	pop	r31
    1694:	ef 91       	pop	r30
    1696:	df 91       	pop	r29
    1698:	cf 91       	pop	r28
    169a:	bf 91       	pop	r27
    169c:	af 91       	pop	r26
    169e:	9f 91       	pop	r25
    16a0:	8f 91       	pop	r24
    16a2:	7f 91       	pop	r23
    16a4:	6f 91       	pop	r22
    16a6:	5f 91       	pop	r21
    16a8:	4f 91       	pop	r20
    16aa:	3f 91       	pop	r19
    16ac:	2f 91       	pop	r18
    16ae:	1f 91       	pop	r17
    16b0:	0f 91       	pop	r16
    16b2:	ff 90       	pop	r15
    16b4:	ef 90       	pop	r14
    16b6:	df 90       	pop	r13
    16b8:	cf 90       	pop	r12
    16ba:	bf 90       	pop	r11
    16bc:	af 90       	pop	r10
    16be:	9f 90       	pop	r9
    16c0:	8f 90       	pop	r8
    16c2:	7f 90       	pop	r7
    16c4:	6f 90       	pop	r6
    16c6:	5f 90       	pop	r5
    16c8:	4f 90       	pop	r4
    16ca:	3f 90       	pop	r3
    16cc:	2f 90       	pop	r2
    16ce:	1f 90       	pop	r1
    16d0:	0f 90       	pop	r0
    16d2:	0f be       	out	0x3f, r0	; 63
    16d4:	0f 90       	pop	r0

    __asm__ __volatile__ ( "ret" );
    16d6:	08 95       	ret

000016d8 <__vector_6>:
     */
    ISR(portSCHEDULER_ISR, ISR_NAKED) __attribute__ ((hot, flatten));
//  ISR(portSCHEDULER_ISR, ISR_NAKED ISR_NOBLOCK) __attribute__ ((hot, flatten));
    ISR(portSCHEDULER_ISR)
    {
        vPortYieldFromTick();
    16d8:	0e 94 0f 0b 	call	0x161e	; 0x161e <vPortYieldFromTick>
        __asm__ __volatile__ ( "reti" );
    16dc:	18 95       	reti

000016de <prvIsQueueEmpty>:
    {
        xReturn = pdFALSE;
    }

    return xReturn;
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
    16de:	0f b6       	in	r0, 0x3f	; 63
    16e0:	f8 94       	cli
    16e2:	0f 92       	push	r0
    16e4:	fc 01       	movw	r30, r24
    16e6:	92 8d       	ldd	r25, Z+26	; 0x1a
    16e8:	0f 90       	pop	r0
    16ea:	0f be       	out	0x3f, r0	; 63
    16ec:	81 e0       	ldi	r24, 0x01	; 1
    16ee:	91 11       	cpse	r25, r1
    16f0:	80 e0       	ldi	r24, 0x00	; 0
    16f2:	08 95       	ret

000016f4 <prvCopyDataToQueue>:
    16f4:	0f 93       	push	r16
    16f6:	1f 93       	push	r17
    16f8:	cf 93       	push	r28
    16fa:	df 93       	push	r29
    16fc:	ec 01       	movw	r28, r24
    16fe:	04 2f       	mov	r16, r20
    1700:	1a 8d       	ldd	r17, Y+26	; 0x1a
    1702:	4c 8d       	ldd	r20, Y+28	; 0x1c
    1704:	41 11       	cpse	r20, r1
    1706:	0b c0       	rjmp	.+22     	; 0x171e <prvCopyDataToQueue+0x2a>
    1708:	88 81       	ld	r24, Y
    170a:	99 81       	ldd	r25, Y+1	; 0x01
    170c:	89 2b       	or	r24, r25
    170e:	e9 f5       	brne	.+122    	; 0x178a <prvCopyDataToQueue+0x96>
    1710:	8c 81       	ldd	r24, Y+4	; 0x04
    1712:	9d 81       	ldd	r25, Y+5	; 0x05
    1714:	0e 94 fe 13 	call	0x27fc	; 0x27fc <xTaskPriorityDisinherit>
    1718:	1d 82       	std	Y+5, r1	; 0x05
    171a:	1c 82       	std	Y+4, r1	; 0x04
    171c:	37 c0       	rjmp	.+110    	; 0x178c <prvCopyDataToQueue+0x98>
    171e:	50 e0       	ldi	r21, 0x00	; 0
    1720:	01 11       	cpse	r16, r1
    1722:	15 c0       	rjmp	.+42     	; 0x174e <prvCopyDataToQueue+0x5a>
    1724:	8a 81       	ldd	r24, Y+2	; 0x02
    1726:	9b 81       	ldd	r25, Y+3	; 0x03
    1728:	0e 94 5b 25 	call	0x4ab6	; 0x4ab6 <memcpy>
    172c:	2c 8d       	ldd	r18, Y+28	; 0x1c
    172e:	8a 81       	ldd	r24, Y+2	; 0x02
    1730:	9b 81       	ldd	r25, Y+3	; 0x03
    1732:	82 0f       	add	r24, r18
    1734:	91 1d       	adc	r25, r1
    1736:	9b 83       	std	Y+3, r25	; 0x03
    1738:	8a 83       	std	Y+2, r24	; 0x02
    173a:	2c 81       	ldd	r18, Y+4	; 0x04
    173c:	3d 81       	ldd	r19, Y+5	; 0x05
    173e:	82 17       	cp	r24, r18
    1740:	93 07       	cpc	r25, r19
    1742:	18 f1       	brcs	.+70     	; 0x178a <prvCopyDataToQueue+0x96>
    1744:	88 81       	ld	r24, Y
    1746:	99 81       	ldd	r25, Y+1	; 0x01
    1748:	9b 83       	std	Y+3, r25	; 0x03
    174a:	8a 83       	std	Y+2, r24	; 0x02
    174c:	1e c0       	rjmp	.+60     	; 0x178a <prvCopyDataToQueue+0x96>
    174e:	8e 81       	ldd	r24, Y+6	; 0x06
    1750:	9f 81       	ldd	r25, Y+7	; 0x07
    1752:	0e 94 5b 25 	call	0x4ab6	; 0x4ab6 <memcpy>
    1756:	8c 8d       	ldd	r24, Y+28	; 0x1c
    1758:	90 e0       	ldi	r25, 0x00	; 0
    175a:	91 95       	neg	r25
    175c:	81 95       	neg	r24
    175e:	91 09       	sbc	r25, r1
    1760:	2e 81       	ldd	r18, Y+6	; 0x06
    1762:	3f 81       	ldd	r19, Y+7	; 0x07
    1764:	28 0f       	add	r18, r24
    1766:	39 1f       	adc	r19, r25
    1768:	3f 83       	std	Y+7, r19	; 0x07
    176a:	2e 83       	std	Y+6, r18	; 0x06
    176c:	48 81       	ld	r20, Y
    176e:	59 81       	ldd	r21, Y+1	; 0x01
    1770:	24 17       	cp	r18, r20
    1772:	35 07       	cpc	r19, r21
    1774:	30 f4       	brcc	.+12     	; 0x1782 <prvCopyDataToQueue+0x8e>
    1776:	2c 81       	ldd	r18, Y+4	; 0x04
    1778:	3d 81       	ldd	r19, Y+5	; 0x05
    177a:	82 0f       	add	r24, r18
    177c:	93 1f       	adc	r25, r19
    177e:	9f 83       	std	Y+7, r25	; 0x07
    1780:	8e 83       	std	Y+6, r24	; 0x06
    1782:	02 30       	cpi	r16, 0x02	; 2
    1784:	11 f4       	brne	.+4      	; 0x178a <prvCopyDataToQueue+0x96>
    1786:	11 11       	cpse	r17, r1
    1788:	11 50       	subi	r17, 0x01	; 1
    178a:	80 e0       	ldi	r24, 0x00	; 0
    178c:	1f 5f       	subi	r17, 0xFF	; 255
    178e:	1a 8f       	std	Y+26, r17	; 0x1a
    1790:	df 91       	pop	r29
    1792:	cf 91       	pop	r28
    1794:	1f 91       	pop	r17
    1796:	0f 91       	pop	r16
    1798:	08 95       	ret

0000179a <prvCopyDataFromQueue>:
    179a:	fc 01       	movw	r30, r24
    179c:	cb 01       	movw	r24, r22
    179e:	44 8d       	ldd	r20, Z+28	; 0x1c
    17a0:	44 23       	and	r20, r20
    17a2:	a1 f0       	breq	.+40     	; 0x17cc <prvCopyDataFromQueue+0x32>
    17a4:	50 e0       	ldi	r21, 0x00	; 0
    17a6:	26 81       	ldd	r18, Z+6	; 0x06
    17a8:	37 81       	ldd	r19, Z+7	; 0x07
    17aa:	24 0f       	add	r18, r20
    17ac:	35 1f       	adc	r19, r21
    17ae:	37 83       	std	Z+7, r19	; 0x07
    17b0:	26 83       	std	Z+6, r18	; 0x06
    17b2:	64 81       	ldd	r22, Z+4	; 0x04
    17b4:	75 81       	ldd	r23, Z+5	; 0x05
    17b6:	26 17       	cp	r18, r22
    17b8:	37 07       	cpc	r19, r23
    17ba:	20 f0       	brcs	.+8      	; 0x17c4 <prvCopyDataFromQueue+0x2a>
    17bc:	20 81       	ld	r18, Z
    17be:	31 81       	ldd	r19, Z+1	; 0x01
    17c0:	37 83       	std	Z+7, r19	; 0x07
    17c2:	26 83       	std	Z+6, r18	; 0x06
    17c4:	66 81       	ldd	r22, Z+6	; 0x06
    17c6:	77 81       	ldd	r23, Z+7	; 0x07
    17c8:	0c 94 5b 25 	jmp	0x4ab6	; 0x4ab6 <memcpy>
    17cc:	08 95       	ret

000017ce <prvUnlockQueue>:
    17ce:	ef 92       	push	r14
    17d0:	ff 92       	push	r15
    17d2:	1f 93       	push	r17
    17d4:	cf 93       	push	r28
    17d6:	df 93       	push	r29
    17d8:	ec 01       	movw	r28, r24
    17da:	0f b6       	in	r0, 0x3f	; 63
    17dc:	f8 94       	cli
    17de:	0f 92       	push	r0
    17e0:	1e 8d       	ldd	r17, Y+30	; 0x1e
    17e2:	7c 01       	movw	r14, r24
    17e4:	81 e1       	ldi	r24, 0x11	; 17
    17e6:	e8 0e       	add	r14, r24
    17e8:	f1 1c       	adc	r15, r1
    17ea:	11 16       	cp	r1, r17
    17ec:	5c f4       	brge	.+22     	; 0x1804 <prvUnlockQueue+0x36>
    17ee:	89 89       	ldd	r24, Y+17	; 0x11
    17f0:	88 23       	and	r24, r24
    17f2:	41 f0       	breq	.+16     	; 0x1804 <prvUnlockQueue+0x36>
    17f4:	c7 01       	movw	r24, r14
    17f6:	0e 94 0b 13 	call	0x2616	; 0x2616 <xTaskRemoveFromEventList>
    17fa:	81 11       	cpse	r24, r1
    17fc:	0e 94 89 13 	call	0x2712	; 0x2712 <vTaskMissedYield>
    1800:	11 50       	subi	r17, 0x01	; 1
    1802:	f3 cf       	rjmp	.-26     	; 0x17ea <prvUnlockQueue+0x1c>
    1804:	8f ef       	ldi	r24, 0xFF	; 255
    1806:	8e 8f       	std	Y+30, r24	; 0x1e
    1808:	0f 90       	pop	r0
    180a:	0f be       	out	0x3f, r0	; 63
    180c:	0f b6       	in	r0, 0x3f	; 63
    180e:	f8 94       	cli
    1810:	0f 92       	push	r0
    1812:	1d 8d       	ldd	r17, Y+29	; 0x1d
    1814:	7e 01       	movw	r14, r28
    1816:	88 e0       	ldi	r24, 0x08	; 8
    1818:	e8 0e       	add	r14, r24
    181a:	f1 1c       	adc	r15, r1
    181c:	11 16       	cp	r1, r17
    181e:	5c f4       	brge	.+22     	; 0x1836 <prvUnlockQueue+0x68>
    1820:	88 85       	ldd	r24, Y+8	; 0x08
    1822:	88 23       	and	r24, r24
    1824:	41 f0       	breq	.+16     	; 0x1836 <prvUnlockQueue+0x68>
    1826:	c7 01       	movw	r24, r14
    1828:	0e 94 0b 13 	call	0x2616	; 0x2616 <xTaskRemoveFromEventList>
    182c:	81 11       	cpse	r24, r1
    182e:	0e 94 89 13 	call	0x2712	; 0x2712 <vTaskMissedYield>
    1832:	11 50       	subi	r17, 0x01	; 1
    1834:	f3 cf       	rjmp	.-26     	; 0x181c <prvUnlockQueue+0x4e>
    1836:	8f ef       	ldi	r24, 0xFF	; 255
    1838:	8d 8f       	std	Y+29, r24	; 0x1d
    183a:	0f 90       	pop	r0
    183c:	0f be       	out	0x3f, r0	; 63
    183e:	df 91       	pop	r29
    1840:	cf 91       	pop	r28
    1842:	1f 91       	pop	r17
    1844:	ff 90       	pop	r15
    1846:	ef 90       	pop	r14
    1848:	08 95       	ret

0000184a <xQueueGenericReset>:
    184a:	cf 93       	push	r28
    184c:	df 93       	push	r29
    184e:	ec 01       	movw	r28, r24
    1850:	0f b6       	in	r0, 0x3f	; 63
    1852:	f8 94       	cli
    1854:	0f 92       	push	r0
    1856:	48 81       	ld	r20, Y
    1858:	59 81       	ldd	r21, Y+1	; 0x01
    185a:	8b 8d       	ldd	r24, Y+27	; 0x1b
    185c:	7c 8d       	ldd	r23, Y+28	; 0x1c
    185e:	9a 01       	movw	r18, r20
    1860:	87 9f       	mul	r24, r23
    1862:	20 0d       	add	r18, r0
    1864:	31 1d       	adc	r19, r1
    1866:	11 24       	eor	r1, r1
    1868:	3d 83       	std	Y+5, r19	; 0x05
    186a:	2c 83       	std	Y+4, r18	; 0x04
    186c:	1a 8e       	std	Y+26, r1	; 0x1a
    186e:	5b 83       	std	Y+3, r21	; 0x03
    1870:	4a 83       	std	Y+2, r20	; 0x02
    1872:	90 e0       	ldi	r25, 0x00	; 0
    1874:	01 97       	sbiw	r24, 0x01	; 1
    1876:	78 9f       	mul	r23, r24
    1878:	90 01       	movw	r18, r0
    187a:	79 9f       	mul	r23, r25
    187c:	30 0d       	add	r19, r0
    187e:	11 24       	eor	r1, r1
    1880:	ca 01       	movw	r24, r20
    1882:	82 0f       	add	r24, r18
    1884:	93 1f       	adc	r25, r19
    1886:	9f 83       	std	Y+7, r25	; 0x07
    1888:	8e 83       	std	Y+6, r24	; 0x06
    188a:	8f ef       	ldi	r24, 0xFF	; 255
    188c:	8d 8f       	std	Y+29, r24	; 0x1d
    188e:	8e 8f       	std	Y+30, r24	; 0x1e
    1890:	61 11       	cpse	r22, r1
    1892:	0c c0       	rjmp	.+24     	; 0x18ac <xQueueGenericReset+0x62>
    1894:	88 85       	ldd	r24, Y+8	; 0x08
    1896:	88 23       	and	r24, r24
    1898:	89 f0       	breq	.+34     	; 0x18bc <xQueueGenericReset+0x72>
    189a:	ce 01       	movw	r24, r28
    189c:	08 96       	adiw	r24, 0x08	; 8
    189e:	0e 94 0b 13 	call	0x2616	; 0x2616 <xTaskRemoveFromEventList>
    18a2:	88 23       	and	r24, r24
    18a4:	59 f0       	breq	.+22     	; 0x18bc <xQueueGenericReset+0x72>
    18a6:	0e 94 b6 0a 	call	0x156c	; 0x156c <vPortYield>
    18aa:	08 c0       	rjmp	.+16     	; 0x18bc <xQueueGenericReset+0x72>
    18ac:	ce 01       	movw	r24, r28
    18ae:	08 96       	adiw	r24, 0x08	; 8
    18b0:	0e 94 83 09 	call	0x1306	; 0x1306 <vListInitialise>
    18b4:	ce 01       	movw	r24, r28
    18b6:	41 96       	adiw	r24, 0x11	; 17
    18b8:	0e 94 83 09 	call	0x1306	; 0x1306 <vListInitialise>
    18bc:	0f 90       	pop	r0
    18be:	0f be       	out	0x3f, r0	; 63
    18c0:	81 e0       	ldi	r24, 0x01	; 1
    18c2:	df 91       	pop	r29
    18c4:	cf 91       	pop	r28
    18c6:	08 95       	ret

000018c8 <xQueueGenericCreate>:
    18c8:	0f 93       	push	r16
    18ca:	1f 93       	push	r17
    18cc:	cf 93       	push	r28
    18ce:	df 93       	push	r29
    18d0:	08 2f       	mov	r16, r24
    18d2:	16 2f       	mov	r17, r22
    18d4:	66 23       	and	r22, r22
    18d6:	21 f0       	breq	.+8      	; 0x18e0 <xQueueGenericCreate+0x18>
    18d8:	86 9f       	mul	r24, r22
    18da:	c0 01       	movw	r24, r0
    18dc:	11 24       	eor	r1, r1
    18de:	02 c0       	rjmp	.+4      	; 0x18e4 <xQueueGenericCreate+0x1c>
    18e0:	80 e0       	ldi	r24, 0x00	; 0
    18e2:	90 e0       	ldi	r25, 0x00	; 0
    18e4:	4f 96       	adiw	r24, 0x1f	; 31
    18e6:	0e 94 5f 09 	call	0x12be	; 0x12be <pvPortMalloc>
    18ea:	ec 01       	movw	r28, r24
    18ec:	00 97       	sbiw	r24, 0x00	; 0
    18ee:	71 f0       	breq	.+28     	; 0x190c <xQueueGenericCreate+0x44>
    18f0:	11 11       	cpse	r17, r1
    18f2:	03 c0       	rjmp	.+6      	; 0x18fa <xQueueGenericCreate+0x32>
    18f4:	99 83       	std	Y+1, r25	; 0x01
    18f6:	88 83       	st	Y, r24
    18f8:	03 c0       	rjmp	.+6      	; 0x1900 <xQueueGenericCreate+0x38>
    18fa:	4f 96       	adiw	r24, 0x1f	; 31
    18fc:	99 83       	std	Y+1, r25	; 0x01
    18fe:	88 83       	st	Y, r24
    1900:	0b 8f       	std	Y+27, r16	; 0x1b
    1902:	1c 8f       	std	Y+28, r17	; 0x1c
    1904:	61 e0       	ldi	r22, 0x01	; 1
    1906:	ce 01       	movw	r24, r28
    1908:	0e 94 25 0c 	call	0x184a	; 0x184a <xQueueGenericReset>
    190c:	ce 01       	movw	r24, r28
    190e:	df 91       	pop	r29
    1910:	cf 91       	pop	r28
    1912:	1f 91       	pop	r17
    1914:	0f 91       	pop	r16
    1916:	08 95       	ret

00001918 <xQueueGenericSend>:
    1918:	af 92       	push	r10
    191a:	bf 92       	push	r11
    191c:	cf 92       	push	r12
    191e:	df 92       	push	r13
    1920:	ff 92       	push	r15
    1922:	0f 93       	push	r16
    1924:	1f 93       	push	r17
    1926:	cf 93       	push	r28
    1928:	df 93       	push	r29
    192a:	00 d0       	rcall	.+0      	; 0x192c <xQueueGenericSend+0x14>
    192c:	00 d0       	rcall	.+0      	; 0x192e <xQueueGenericSend+0x16>
    192e:	1f 92       	push	r1
    1930:	cd b7       	in	r28, 0x3d	; 61
    1932:	de b7       	in	r29, 0x3e	; 62
    1934:	8c 01       	movw	r16, r24
    1936:	6b 01       	movw	r12, r22
    1938:	5d 83       	std	Y+5, r21	; 0x05
    193a:	4c 83       	std	Y+4, r20	; 0x04
    193c:	f2 2e       	mov	r15, r18
    193e:	80 e0       	ldi	r24, 0x00	; 0
    1940:	58 01       	movw	r10, r16
    1942:	98 e0       	ldi	r25, 0x08	; 8
    1944:	a9 0e       	add	r10, r25
    1946:	b1 1c       	adc	r11, r1
    1948:	0f b6       	in	r0, 0x3f	; 63
    194a:	f8 94       	cli
    194c:	0f 92       	push	r0
    194e:	f8 01       	movw	r30, r16
    1950:	22 8d       	ldd	r18, Z+26	; 0x1a
    1952:	93 8d       	ldd	r25, Z+27	; 0x1b
    1954:	29 17       	cp	r18, r25
    1956:	18 f0       	brcs	.+6      	; 0x195e <xQueueGenericSend+0x46>
    1958:	f2 e0       	ldi	r31, 0x02	; 2
    195a:	ff 12       	cpse	r15, r31
    195c:	14 c0       	rjmp	.+40     	; 0x1986 <xQueueGenericSend+0x6e>
    195e:	4f 2d       	mov	r20, r15
    1960:	b6 01       	movw	r22, r12
    1962:	c8 01       	movw	r24, r16
    1964:	0e 94 7a 0b 	call	0x16f4	; 0x16f4 <prvCopyDataToQueue>
    1968:	f8 01       	movw	r30, r16
    196a:	91 89       	ldd	r25, Z+17	; 0x11
    196c:	99 23       	and	r25, r25
    196e:	21 f0       	breq	.+8      	; 0x1978 <xQueueGenericSend+0x60>
    1970:	c8 01       	movw	r24, r16
    1972:	41 96       	adiw	r24, 0x11	; 17
    1974:	0e 94 0b 13 	call	0x2616	; 0x2616 <xTaskRemoveFromEventList>
    1978:	81 11       	cpse	r24, r1
    197a:	0e 94 b6 0a 	call	0x156c	; 0x156c <vPortYield>
    197e:	0f 90       	pop	r0
    1980:	0f be       	out	0x3f, r0	; 63
    1982:	81 e0       	ldi	r24, 0x01	; 1
    1984:	50 c0       	rjmp	.+160    	; 0x1a26 <xQueueGenericSend+0x10e>
    1986:	2c 81       	ldd	r18, Y+4	; 0x04
    1988:	3d 81       	ldd	r19, Y+5	; 0x05
    198a:	23 2b       	or	r18, r19
    198c:	19 f4       	brne	.+6      	; 0x1994 <xQueueGenericSend+0x7c>
    198e:	0f 90       	pop	r0
    1990:	0f be       	out	0x3f, r0	; 63
    1992:	48 c0       	rjmp	.+144    	; 0x1a24 <xQueueGenericSend+0x10c>
    1994:	81 11       	cpse	r24, r1
    1996:	04 c0       	rjmp	.+8      	; 0x19a0 <xQueueGenericSend+0x88>
    1998:	ce 01       	movw	r24, r28
    199a:	01 96       	adiw	r24, 0x01	; 1
    199c:	0e 94 4b 13 	call	0x2696	; 0x2696 <vTaskInternalSetTimeOutState>
    19a0:	0f 90       	pop	r0
    19a2:	0f be       	out	0x3f, r0	; 63
    19a4:	0e 94 0c 11 	call	0x2218	; 0x2218 <vTaskSuspendAll>
    19a8:	0f b6       	in	r0, 0x3f	; 63
    19aa:	f8 94       	cli
    19ac:	0f 92       	push	r0
    19ae:	f8 01       	movw	r30, r16
    19b0:	85 8d       	ldd	r24, Z+29	; 0x1d
    19b2:	8f 3f       	cpi	r24, 0xFF	; 255
    19b4:	09 f4       	brne	.+2      	; 0x19b8 <xQueueGenericSend+0xa0>
    19b6:	15 8e       	std	Z+29, r1	; 0x1d
    19b8:	f8 01       	movw	r30, r16
    19ba:	86 8d       	ldd	r24, Z+30	; 0x1e
    19bc:	8f 3f       	cpi	r24, 0xFF	; 255
    19be:	09 f4       	brne	.+2      	; 0x19c2 <xQueueGenericSend+0xaa>
    19c0:	16 8e       	std	Z+30, r1	; 0x1e
    19c2:	0f 90       	pop	r0
    19c4:	0f be       	out	0x3f, r0	; 63
    19c6:	be 01       	movw	r22, r28
    19c8:	6c 5f       	subi	r22, 0xFC	; 252
    19ca:	7f 4f       	sbci	r23, 0xFF	; 255
    19cc:	ce 01       	movw	r24, r28
    19ce:	01 96       	adiw	r24, 0x01	; 1
    19d0:	0e 94 56 13 	call	0x26ac	; 0x26ac <xTaskCheckForTimeOut>
    19d4:	81 11       	cpse	r24, r1
    19d6:	21 c0       	rjmp	.+66     	; 0x1a1a <xQueueGenericSend+0x102>
    19d8:	0f b6       	in	r0, 0x3f	; 63
    19da:	f8 94       	cli
    19dc:	0f 92       	push	r0
    19de:	f8 01       	movw	r30, r16
    19e0:	92 8d       	ldd	r25, Z+26	; 0x1a
    19e2:	83 8d       	ldd	r24, Z+27	; 0x1b
    19e4:	0f 90       	pop	r0
    19e6:	0f be       	out	0x3f, r0	; 63
    19e8:	98 13       	cpse	r25, r24
    19ea:	11 c0       	rjmp	.+34     	; 0x1a0e <xQueueGenericSend+0xf6>
    19ec:	6c 81       	ldd	r22, Y+4	; 0x04
    19ee:	7d 81       	ldd	r23, Y+5	; 0x05
    19f0:	c5 01       	movw	r24, r10
    19f2:	0e 94 e2 12 	call	0x25c4	; 0x25c4 <vTaskPlaceOnEventList>
    19f6:	c8 01       	movw	r24, r16
    19f8:	0e 94 e7 0b 	call	0x17ce	; 0x17ce <prvUnlockQueue>
    19fc:	0e 94 c8 11 	call	0x2390	; 0x2390 <xTaskResumeAll>
    1a00:	88 23       	and	r24, r24
    1a02:	11 f0       	breq	.+4      	; 0x1a08 <xQueueGenericSend+0xf0>
    1a04:	81 e0       	ldi	r24, 0x01	; 1
    1a06:	a0 cf       	rjmp	.-192    	; 0x1948 <xQueueGenericSend+0x30>
    1a08:	0e 94 b6 0a 	call	0x156c	; 0x156c <vPortYield>
    1a0c:	fb cf       	rjmp	.-10     	; 0x1a04 <xQueueGenericSend+0xec>
    1a0e:	c8 01       	movw	r24, r16
    1a10:	0e 94 e7 0b 	call	0x17ce	; 0x17ce <prvUnlockQueue>
    1a14:	0e 94 c8 11 	call	0x2390	; 0x2390 <xTaskResumeAll>
    1a18:	f5 cf       	rjmp	.-22     	; 0x1a04 <xQueueGenericSend+0xec>
    1a1a:	c8 01       	movw	r24, r16
    1a1c:	0e 94 e7 0b 	call	0x17ce	; 0x17ce <prvUnlockQueue>
    1a20:	0e 94 c8 11 	call	0x2390	; 0x2390 <xTaskResumeAll>
    1a24:	80 e0       	ldi	r24, 0x00	; 0
    1a26:	0f 90       	pop	r0
    1a28:	0f 90       	pop	r0
    1a2a:	0f 90       	pop	r0
    1a2c:	0f 90       	pop	r0
    1a2e:	0f 90       	pop	r0
    1a30:	df 91       	pop	r29
    1a32:	cf 91       	pop	r28
    1a34:	1f 91       	pop	r17
    1a36:	0f 91       	pop	r16
    1a38:	ff 90       	pop	r15
    1a3a:	df 90       	pop	r13
    1a3c:	cf 90       	pop	r12
    1a3e:	bf 90       	pop	r11
    1a40:	af 90       	pop	r10
    1a42:	08 95       	ret

00001a44 <xQueueGenericSendFromISR>:
    1a44:	ef 92       	push	r14
    1a46:	ff 92       	push	r15
    1a48:	1f 93       	push	r17
    1a4a:	cf 93       	push	r28
    1a4c:	df 93       	push	r29
    1a4e:	ec 01       	movw	r28, r24
    1a50:	9a 8d       	ldd	r25, Y+26	; 0x1a
    1a52:	8b 8d       	ldd	r24, Y+27	; 0x1b
    1a54:	98 17       	cp	r25, r24
    1a56:	10 f0       	brcs	.+4      	; 0x1a5c <xQueueGenericSendFromISR+0x18>
    1a58:	22 30       	cpi	r18, 0x02	; 2
    1a5a:	e1 f4       	brne	.+56     	; 0x1a94 <xQueueGenericSendFromISR+0x50>
    1a5c:	7a 01       	movw	r14, r20
    1a5e:	1e 8d       	ldd	r17, Y+30	; 0x1e
    1a60:	42 2f       	mov	r20, r18
    1a62:	ce 01       	movw	r24, r28
    1a64:	0e 94 7a 0b 	call	0x16f4	; 0x16f4 <prvCopyDataToQueue>
    1a68:	1f 3f       	cpi	r17, 0xFF	; 255
    1a6a:	81 f4       	brne	.+32     	; 0x1a8c <xQueueGenericSendFromISR+0x48>
    1a6c:	89 89       	ldd	r24, Y+17	; 0x11
    1a6e:	88 23       	and	r24, r24
    1a70:	79 f0       	breq	.+30     	; 0x1a90 <xQueueGenericSendFromISR+0x4c>
    1a72:	ce 01       	movw	r24, r28
    1a74:	41 96       	adiw	r24, 0x11	; 17
    1a76:	0e 94 0b 13 	call	0x2616	; 0x2616 <xTaskRemoveFromEventList>
    1a7a:	88 23       	and	r24, r24
    1a7c:	49 f0       	breq	.+18     	; 0x1a90 <xQueueGenericSendFromISR+0x4c>
    1a7e:	e1 14       	cp	r14, r1
    1a80:	f1 04       	cpc	r15, r1
    1a82:	31 f0       	breq	.+12     	; 0x1a90 <xQueueGenericSendFromISR+0x4c>
    1a84:	81 e0       	ldi	r24, 0x01	; 1
    1a86:	f7 01       	movw	r30, r14
    1a88:	80 83       	st	Z, r24
    1a8a:	05 c0       	rjmp	.+10     	; 0x1a96 <xQueueGenericSendFromISR+0x52>
    1a8c:	1f 5f       	subi	r17, 0xFF	; 255
    1a8e:	1e 8f       	std	Y+30, r17	; 0x1e
    1a90:	81 e0       	ldi	r24, 0x01	; 1
    1a92:	01 c0       	rjmp	.+2      	; 0x1a96 <xQueueGenericSendFromISR+0x52>
    1a94:	80 e0       	ldi	r24, 0x00	; 0
    1a96:	df 91       	pop	r29
    1a98:	cf 91       	pop	r28
    1a9a:	1f 91       	pop	r17
    1a9c:	ff 90       	pop	r15
    1a9e:	ef 90       	pop	r14
    1aa0:	08 95       	ret

00001aa2 <xQueueGiveFromISR>:
    1aa2:	cf 93       	push	r28
    1aa4:	df 93       	push	r29
    1aa6:	fc 01       	movw	r30, r24
    1aa8:	92 8d       	ldd	r25, Z+26	; 0x1a
    1aaa:	83 8d       	ldd	r24, Z+27	; 0x1b
    1aac:	98 17       	cp	r25, r24
    1aae:	c0 f4       	brcc	.+48     	; 0x1ae0 <xQueueGiveFromISR+0x3e>
    1ab0:	86 8d       	ldd	r24, Z+30	; 0x1e
    1ab2:	9f 5f       	subi	r25, 0xFF	; 255
    1ab4:	92 8f       	std	Z+26, r25	; 0x1a
    1ab6:	8f 3f       	cpi	r24, 0xFF	; 255
    1ab8:	79 f4       	brne	.+30     	; 0x1ad8 <xQueueGiveFromISR+0x36>
    1aba:	81 89       	ldd	r24, Z+17	; 0x11
    1abc:	88 23       	and	r24, r24
    1abe:	71 f0       	breq	.+28     	; 0x1adc <xQueueGiveFromISR+0x3a>
    1ac0:	eb 01       	movw	r28, r22
    1ac2:	cf 01       	movw	r24, r30
    1ac4:	41 96       	adiw	r24, 0x11	; 17
    1ac6:	0e 94 0b 13 	call	0x2616	; 0x2616 <xTaskRemoveFromEventList>
    1aca:	88 23       	and	r24, r24
    1acc:	39 f0       	breq	.+14     	; 0x1adc <xQueueGiveFromISR+0x3a>
    1ace:	20 97       	sbiw	r28, 0x00	; 0
    1ad0:	29 f0       	breq	.+10     	; 0x1adc <xQueueGiveFromISR+0x3a>
    1ad2:	81 e0       	ldi	r24, 0x01	; 1
    1ad4:	88 83       	st	Y, r24
    1ad6:	05 c0       	rjmp	.+10     	; 0x1ae2 <xQueueGiveFromISR+0x40>
    1ad8:	8f 5f       	subi	r24, 0xFF	; 255
    1ada:	86 8f       	std	Z+30, r24	; 0x1e
    1adc:	81 e0       	ldi	r24, 0x01	; 1
    1ade:	01 c0       	rjmp	.+2      	; 0x1ae2 <xQueueGiveFromISR+0x40>
    1ae0:	80 e0       	ldi	r24, 0x00	; 0
    1ae2:	df 91       	pop	r29
    1ae4:	cf 91       	pop	r28
    1ae6:	08 95       	ret

00001ae8 <xQueueReceive>:
    1ae8:	af 92       	push	r10
    1aea:	bf 92       	push	r11
    1aec:	cf 92       	push	r12
    1aee:	df 92       	push	r13
    1af0:	ff 92       	push	r15
    1af2:	0f 93       	push	r16
    1af4:	1f 93       	push	r17
    1af6:	cf 93       	push	r28
    1af8:	df 93       	push	r29
    1afa:	00 d0       	rcall	.+0      	; 0x1afc <xQueueReceive+0x14>
    1afc:	00 d0       	rcall	.+0      	; 0x1afe <xQueueReceive+0x16>
    1afe:	1f 92       	push	r1
    1b00:	cd b7       	in	r28, 0x3d	; 61
    1b02:	de b7       	in	r29, 0x3e	; 62
    1b04:	8c 01       	movw	r16, r24
    1b06:	6b 01       	movw	r12, r22
    1b08:	5d 83       	std	Y+5, r21	; 0x05
    1b0a:	4c 83       	std	Y+4, r20	; 0x04
    1b0c:	80 e0       	ldi	r24, 0x00	; 0
    1b0e:	58 01       	movw	r10, r16
    1b10:	91 e1       	ldi	r25, 0x11	; 17
    1b12:	a9 0e       	add	r10, r25
    1b14:	b1 1c       	adc	r11, r1
    1b16:	0f b6       	in	r0, 0x3f	; 63
    1b18:	f8 94       	cli
    1b1a:	0f 92       	push	r0
    1b1c:	f8 01       	movw	r30, r16
    1b1e:	f2 8c       	ldd	r15, Z+26	; 0x1a
    1b20:	ff 20       	and	r15, r15
    1b22:	a9 f0       	breq	.+42     	; 0x1b4e <xQueueReceive+0x66>
    1b24:	b6 01       	movw	r22, r12
    1b26:	c8 01       	movw	r24, r16
    1b28:	0e 94 cd 0b 	call	0x179a	; 0x179a <prvCopyDataFromQueue>
    1b2c:	fa 94       	dec	r15
    1b2e:	f8 01       	movw	r30, r16
    1b30:	f2 8e       	std	Z+26, r15	; 0x1a
    1b32:	80 85       	ldd	r24, Z+8	; 0x08
    1b34:	88 23       	and	r24, r24
    1b36:	39 f0       	breq	.+14     	; 0x1b46 <xQueueReceive+0x5e>
    1b38:	c8 01       	movw	r24, r16
    1b3a:	08 96       	adiw	r24, 0x08	; 8
    1b3c:	0e 94 0b 13 	call	0x2616	; 0x2616 <xTaskRemoveFromEventList>
    1b40:	81 11       	cpse	r24, r1
    1b42:	0e 94 b6 0a 	call	0x156c	; 0x156c <vPortYield>
    1b46:	0f 90       	pop	r0
    1b48:	0f be       	out	0x3f, r0	; 63
    1b4a:	81 e0       	ldi	r24, 0x01	; 1
    1b4c:	50 c0       	rjmp	.+160    	; 0x1bee <xQueueReceive+0x106>
    1b4e:	2c 81       	ldd	r18, Y+4	; 0x04
    1b50:	3d 81       	ldd	r19, Y+5	; 0x05
    1b52:	23 2b       	or	r18, r19
    1b54:	19 f4       	brne	.+6      	; 0x1b5c <xQueueReceive+0x74>
    1b56:	0f 90       	pop	r0
    1b58:	0f be       	out	0x3f, r0	; 63
    1b5a:	48 c0       	rjmp	.+144    	; 0x1bec <xQueueReceive+0x104>
    1b5c:	81 11       	cpse	r24, r1
    1b5e:	04 c0       	rjmp	.+8      	; 0x1b68 <xQueueReceive+0x80>
    1b60:	ce 01       	movw	r24, r28
    1b62:	01 96       	adiw	r24, 0x01	; 1
    1b64:	0e 94 4b 13 	call	0x2696	; 0x2696 <vTaskInternalSetTimeOutState>
    1b68:	0f 90       	pop	r0
    1b6a:	0f be       	out	0x3f, r0	; 63
    1b6c:	0e 94 0c 11 	call	0x2218	; 0x2218 <vTaskSuspendAll>
    1b70:	0f b6       	in	r0, 0x3f	; 63
    1b72:	f8 94       	cli
    1b74:	0f 92       	push	r0
    1b76:	f8 01       	movw	r30, r16
    1b78:	85 8d       	ldd	r24, Z+29	; 0x1d
    1b7a:	8f 3f       	cpi	r24, 0xFF	; 255
    1b7c:	09 f4       	brne	.+2      	; 0x1b80 <xQueueReceive+0x98>
    1b7e:	15 8e       	std	Z+29, r1	; 0x1d
    1b80:	f8 01       	movw	r30, r16
    1b82:	86 8d       	ldd	r24, Z+30	; 0x1e
    1b84:	8f 3f       	cpi	r24, 0xFF	; 255
    1b86:	09 f4       	brne	.+2      	; 0x1b8a <xQueueReceive+0xa2>
    1b88:	16 8e       	std	Z+30, r1	; 0x1e
    1b8a:	0f 90       	pop	r0
    1b8c:	0f be       	out	0x3f, r0	; 63
    1b8e:	be 01       	movw	r22, r28
    1b90:	6c 5f       	subi	r22, 0xFC	; 252
    1b92:	7f 4f       	sbci	r23, 0xFF	; 255
    1b94:	ce 01       	movw	r24, r28
    1b96:	01 96       	adiw	r24, 0x01	; 1
    1b98:	0e 94 56 13 	call	0x26ac	; 0x26ac <xTaskCheckForTimeOut>
    1b9c:	81 11       	cpse	r24, r1
    1b9e:	1c c0       	rjmp	.+56     	; 0x1bd8 <xQueueReceive+0xf0>
    1ba0:	c8 01       	movw	r24, r16
    1ba2:	0e 94 6f 0b 	call	0x16de	; 0x16de <prvIsQueueEmpty>
    1ba6:	88 23       	and	r24, r24
    1ba8:	89 f0       	breq	.+34     	; 0x1bcc <xQueueReceive+0xe4>
    1baa:	6c 81       	ldd	r22, Y+4	; 0x04
    1bac:	7d 81       	ldd	r23, Y+5	; 0x05
    1bae:	c5 01       	movw	r24, r10
    1bb0:	0e 94 e2 12 	call	0x25c4	; 0x25c4 <vTaskPlaceOnEventList>
    1bb4:	c8 01       	movw	r24, r16
    1bb6:	0e 94 e7 0b 	call	0x17ce	; 0x17ce <prvUnlockQueue>
    1bba:	0e 94 c8 11 	call	0x2390	; 0x2390 <xTaskResumeAll>
    1bbe:	88 23       	and	r24, r24
    1bc0:	11 f0       	breq	.+4      	; 0x1bc6 <xQueueReceive+0xde>
    1bc2:	81 e0       	ldi	r24, 0x01	; 1
    1bc4:	a8 cf       	rjmp	.-176    	; 0x1b16 <xQueueReceive+0x2e>
    1bc6:	0e 94 b6 0a 	call	0x156c	; 0x156c <vPortYield>
    1bca:	fb cf       	rjmp	.-10     	; 0x1bc2 <xQueueReceive+0xda>
    1bcc:	c8 01       	movw	r24, r16
    1bce:	0e 94 e7 0b 	call	0x17ce	; 0x17ce <prvUnlockQueue>
    1bd2:	0e 94 c8 11 	call	0x2390	; 0x2390 <xTaskResumeAll>
    1bd6:	f5 cf       	rjmp	.-22     	; 0x1bc2 <xQueueReceive+0xda>
    1bd8:	c8 01       	movw	r24, r16
    1bda:	0e 94 e7 0b 	call	0x17ce	; 0x17ce <prvUnlockQueue>
    1bde:	0e 94 c8 11 	call	0x2390	; 0x2390 <xTaskResumeAll>
    1be2:	c8 01       	movw	r24, r16
    1be4:	0e 94 6f 0b 	call	0x16de	; 0x16de <prvIsQueueEmpty>
    1be8:	88 23       	and	r24, r24
    1bea:	59 f3       	breq	.-42     	; 0x1bc2 <xQueueReceive+0xda>
    1bec:	80 e0       	ldi	r24, 0x00	; 0
    1bee:	0f 90       	pop	r0
    1bf0:	0f 90       	pop	r0
    1bf2:	0f 90       	pop	r0
    1bf4:	0f 90       	pop	r0
    1bf6:	0f 90       	pop	r0
    1bf8:	df 91       	pop	r29
    1bfa:	cf 91       	pop	r28
    1bfc:	1f 91       	pop	r17
    1bfe:	0f 91       	pop	r16
    1c00:	ff 90       	pop	r15
    1c02:	df 90       	pop	r13
    1c04:	cf 90       	pop	r12
    1c06:	bf 90       	pop	r11
    1c08:	af 90       	pop	r10
    1c0a:	08 95       	ret

00001c0c <xQueueSemaphoreTake>:
    1c0c:	cf 92       	push	r12
    1c0e:	df 92       	push	r13
    1c10:	ff 92       	push	r15
    1c12:	0f 93       	push	r16
    1c14:	1f 93       	push	r17
    1c16:	cf 93       	push	r28
    1c18:	df 93       	push	r29
    1c1a:	00 d0       	rcall	.+0      	; 0x1c1c <xQueueSemaphoreTake+0x10>
    1c1c:	00 d0       	rcall	.+0      	; 0x1c1e <xQueueSemaphoreTake+0x12>
    1c1e:	1f 92       	push	r1
    1c20:	cd b7       	in	r28, 0x3d	; 61
    1c22:	de b7       	in	r29, 0x3e	; 62
    1c24:	8c 01       	movw	r16, r24
    1c26:	7d 83       	std	Y+5, r23	; 0x05
    1c28:	6c 83       	std	Y+4, r22	; 0x04
    1c2a:	f1 2c       	mov	r15, r1
    1c2c:	90 e0       	ldi	r25, 0x00	; 0
    1c2e:	68 01       	movw	r12, r16
    1c30:	81 e1       	ldi	r24, 0x11	; 17
    1c32:	c8 0e       	add	r12, r24
    1c34:	d1 1c       	adc	r13, r1
    1c36:	0f b6       	in	r0, 0x3f	; 63
    1c38:	f8 94       	cli
    1c3a:	0f 92       	push	r0
    1c3c:	d8 01       	movw	r26, r16
    1c3e:	5a 96       	adiw	r26, 0x1a	; 26
    1c40:	8c 91       	ld	r24, X
    1c42:	5a 97       	sbiw	r26, 0x1a	; 26
    1c44:	88 23       	and	r24, r24
    1c46:	e9 f0       	breq	.+58     	; 0x1c82 <xQueueSemaphoreTake+0x76>
    1c48:	81 50       	subi	r24, 0x01	; 1
    1c4a:	5a 96       	adiw	r26, 0x1a	; 26
    1c4c:	8c 93       	st	X, r24
    1c4e:	5a 97       	sbiw	r26, 0x1a	; 26
    1c50:	8d 91       	ld	r24, X+
    1c52:	9c 91       	ld	r25, X
    1c54:	89 2b       	or	r24, r25
    1c56:	29 f4       	brne	.+10     	; 0x1c62 <xQueueSemaphoreTake+0x56>
    1c58:	0e 94 7f 14 	call	0x28fe	; 0x28fe <pvTaskIncrementMutexHeldCount>
    1c5c:	f8 01       	movw	r30, r16
    1c5e:	95 83       	std	Z+5, r25	; 0x05
    1c60:	84 83       	std	Z+4, r24	; 0x04
    1c62:	d8 01       	movw	r26, r16
    1c64:	18 96       	adiw	r26, 0x08	; 8
    1c66:	8c 91       	ld	r24, X
    1c68:	88 23       	and	r24, r24
    1c6a:	39 f0       	breq	.+14     	; 0x1c7a <xQueueSemaphoreTake+0x6e>
    1c6c:	c8 01       	movw	r24, r16
    1c6e:	08 96       	adiw	r24, 0x08	; 8
    1c70:	0e 94 0b 13 	call	0x2616	; 0x2616 <xTaskRemoveFromEventList>
    1c74:	81 11       	cpse	r24, r1
    1c76:	0e 94 b6 0a 	call	0x156c	; 0x156c <vPortYield>
    1c7a:	0f 90       	pop	r0
    1c7c:	0f be       	out	0x3f, r0	; 63
    1c7e:	81 e0       	ldi	r24, 0x01	; 1
    1c80:	7a c0       	rjmp	.+244    	; 0x1d76 <xQueueSemaphoreTake+0x16a>
    1c82:	2c 81       	ldd	r18, Y+4	; 0x04
    1c84:	3d 81       	ldd	r19, Y+5	; 0x05
    1c86:	23 2b       	or	r18, r19
    1c88:	09 f4       	brne	.+2      	; 0x1c8c <xQueueSemaphoreTake+0x80>
    1c8a:	72 c0       	rjmp	.+228    	; 0x1d70 <xQueueSemaphoreTake+0x164>
    1c8c:	91 11       	cpse	r25, r1
    1c8e:	04 c0       	rjmp	.+8      	; 0x1c98 <xQueueSemaphoreTake+0x8c>
    1c90:	ce 01       	movw	r24, r28
    1c92:	01 96       	adiw	r24, 0x01	; 1
    1c94:	0e 94 4b 13 	call	0x2696	; 0x2696 <vTaskInternalSetTimeOutState>
    1c98:	0f 90       	pop	r0
    1c9a:	0f be       	out	0x3f, r0	; 63
    1c9c:	0e 94 0c 11 	call	0x2218	; 0x2218 <vTaskSuspendAll>
    1ca0:	0f b6       	in	r0, 0x3f	; 63
    1ca2:	f8 94       	cli
    1ca4:	0f 92       	push	r0
    1ca6:	f8 01       	movw	r30, r16
    1ca8:	85 8d       	ldd	r24, Z+29	; 0x1d
    1caa:	8f 3f       	cpi	r24, 0xFF	; 255
    1cac:	09 f4       	brne	.+2      	; 0x1cb0 <xQueueSemaphoreTake+0xa4>
    1cae:	15 8e       	std	Z+29, r1	; 0x1d
    1cb0:	d8 01       	movw	r26, r16
    1cb2:	5e 96       	adiw	r26, 0x1e	; 30
    1cb4:	8c 91       	ld	r24, X
    1cb6:	5e 97       	sbiw	r26, 0x1e	; 30
    1cb8:	8f 3f       	cpi	r24, 0xFF	; 255
    1cba:	11 f4       	brne	.+4      	; 0x1cc0 <xQueueSemaphoreTake+0xb4>
    1cbc:	5e 96       	adiw	r26, 0x1e	; 30
    1cbe:	1c 92       	st	X, r1
    1cc0:	0f 90       	pop	r0
    1cc2:	0f be       	out	0x3f, r0	; 63
    1cc4:	be 01       	movw	r22, r28
    1cc6:	6c 5f       	subi	r22, 0xFC	; 252
    1cc8:	7f 4f       	sbci	r23, 0xFF	; 255
    1cca:	ce 01       	movw	r24, r28
    1ccc:	01 96       	adiw	r24, 0x01	; 1
    1cce:	0e 94 56 13 	call	0x26ac	; 0x26ac <xTaskCheckForTimeOut>
    1cd2:	81 11       	cpse	r24, r1
    1cd4:	2b c0       	rjmp	.+86     	; 0x1d2c <xQueueSemaphoreTake+0x120>
    1cd6:	c8 01       	movw	r24, r16
    1cd8:	0e 94 6f 0b 	call	0x16de	; 0x16de <prvIsQueueEmpty>
    1cdc:	88 23       	and	r24, r24
    1cde:	01 f1       	breq	.+64     	; 0x1d20 <xQueueSemaphoreTake+0x114>
    1ce0:	f8 01       	movw	r30, r16
    1ce2:	80 81       	ld	r24, Z
    1ce4:	91 81       	ldd	r25, Z+1	; 0x01
    1ce6:	89 2b       	or	r24, r25
    1ce8:	51 f4       	brne	.+20     	; 0x1cfe <xQueueSemaphoreTake+0xf2>
    1cea:	0f b6       	in	r0, 0x3f	; 63
    1cec:	f8 94       	cli
    1cee:	0f 92       	push	r0
    1cf0:	84 81       	ldd	r24, Z+4	; 0x04
    1cf2:	95 81       	ldd	r25, Z+5	; 0x05
    1cf4:	0e 94 9b 13 	call	0x2736	; 0x2736 <xTaskPriorityInherit>
    1cf8:	f8 2e       	mov	r15, r24
    1cfa:	0f 90       	pop	r0
    1cfc:	0f be       	out	0x3f, r0	; 63
    1cfe:	6c 81       	ldd	r22, Y+4	; 0x04
    1d00:	7d 81       	ldd	r23, Y+5	; 0x05
    1d02:	c6 01       	movw	r24, r12
    1d04:	0e 94 e2 12 	call	0x25c4	; 0x25c4 <vTaskPlaceOnEventList>
    1d08:	c8 01       	movw	r24, r16
    1d0a:	0e 94 e7 0b 	call	0x17ce	; 0x17ce <prvUnlockQueue>
    1d0e:	0e 94 c8 11 	call	0x2390	; 0x2390 <xTaskResumeAll>
    1d12:	88 23       	and	r24, r24
    1d14:	11 f0       	breq	.+4      	; 0x1d1a <xQueueSemaphoreTake+0x10e>
    1d16:	91 e0       	ldi	r25, 0x01	; 1
    1d18:	8e cf       	rjmp	.-228    	; 0x1c36 <xQueueSemaphoreTake+0x2a>
    1d1a:	0e 94 b6 0a 	call	0x156c	; 0x156c <vPortYield>
    1d1e:	fb cf       	rjmp	.-10     	; 0x1d16 <xQueueSemaphoreTake+0x10a>
    1d20:	c8 01       	movw	r24, r16
    1d22:	0e 94 e7 0b 	call	0x17ce	; 0x17ce <prvUnlockQueue>
    1d26:	0e 94 c8 11 	call	0x2390	; 0x2390 <xTaskResumeAll>
    1d2a:	f5 cf       	rjmp	.-22     	; 0x1d16 <xQueueSemaphoreTake+0x10a>
    1d2c:	c8 01       	movw	r24, r16
    1d2e:	0e 94 e7 0b 	call	0x17ce	; 0x17ce <prvUnlockQueue>
    1d32:	0e 94 c8 11 	call	0x2390	; 0x2390 <xTaskResumeAll>
    1d36:	c8 01       	movw	r24, r16
    1d38:	0e 94 6f 0b 	call	0x16de	; 0x16de <prvIsQueueEmpty>
    1d3c:	88 23       	and	r24, r24
    1d3e:	59 f3       	breq	.-42     	; 0x1d16 <xQueueSemaphoreTake+0x10a>
    1d40:	ff 20       	and	r15, r15
    1d42:	c1 f0       	breq	.+48     	; 0x1d74 <xQueueSemaphoreTake+0x168>
    1d44:	0f b6       	in	r0, 0x3f	; 63
    1d46:	f8 94       	cli
    1d48:	0f 92       	push	r0
    1d4a:	f8 01       	movw	r30, r16
    1d4c:	81 89       	ldd	r24, Z+17	; 0x11
    1d4e:	88 23       	and	r24, r24
    1d50:	39 f0       	breq	.+14     	; 0x1d60 <xQueueSemaphoreTake+0x154>
    1d52:	06 88       	ldd	r0, Z+22	; 0x16
    1d54:	f7 89       	ldd	r31, Z+23	; 0x17
    1d56:	e0 2d       	mov	r30, r0
    1d58:	80 81       	ld	r24, Z
    1d5a:	64 e0       	ldi	r22, 0x04	; 4
    1d5c:	68 1b       	sub	r22, r24
    1d5e:	01 c0       	rjmp	.+2      	; 0x1d62 <xQueueSemaphoreTake+0x156>
    1d60:	60 e0       	ldi	r22, 0x00	; 0
    1d62:	d8 01       	movw	r26, r16
    1d64:	14 96       	adiw	r26, 0x04	; 4
    1d66:	8d 91       	ld	r24, X+
    1d68:	9c 91       	ld	r25, X
    1d6a:	15 97       	sbiw	r26, 0x05	; 5
    1d6c:	0e 94 38 14 	call	0x2870	; 0x2870 <vTaskPriorityDisinheritAfterTimeout>
    1d70:	0f 90       	pop	r0
    1d72:	0f be       	out	0x3f, r0	; 63
    1d74:	80 e0       	ldi	r24, 0x00	; 0
    1d76:	0f 90       	pop	r0
    1d78:	0f 90       	pop	r0
    1d7a:	0f 90       	pop	r0
    1d7c:	0f 90       	pop	r0
    1d7e:	0f 90       	pop	r0
    1d80:	df 91       	pop	r29
    1d82:	cf 91       	pop	r28
    1d84:	1f 91       	pop	r17
    1d86:	0f 91       	pop	r16
    1d88:	ff 90       	pop	r15
    1d8a:	df 90       	pop	r13
    1d8c:	cf 90       	pop	r12
    1d8e:	08 95       	ret

00001d90 <vQueueWaitForMessageRestricted>:
/*-----------------------------------------------------------*/

#if ( configUSE_TIMERS == 1 )

    void vQueueWaitForMessageRestricted( QueueHandle_t xQueue, TickType_t xTicksToWait, const BaseType_t xWaitIndefinitely )
    {
    1d90:	cf 93       	push	r28
    1d92:	df 93       	push	r29
    1d94:	ec 01       	movw	r28, r24
        will not actually cause the task to block, just place it on a blocked
        list.  It will not block until the scheduler is unlocked - at which
        time a yield will be performed.  If an item is added to the queue while
        the queue is locked, and the calling task blocks on the queue, then the
        calling task will be immediately unblocked when the queue is unlocked. */
        prvLockQueue( pxQueue );
    1d96:	0f b6       	in	r0, 0x3f	; 63
    1d98:	f8 94       	cli
    1d9a:	0f 92       	push	r0
    1d9c:	8d 8d       	ldd	r24, Y+29	; 0x1d
    1d9e:	8f 3f       	cpi	r24, 0xFF	; 255
    1da0:	09 f4       	brne	.+2      	; 0x1da4 <vQueueWaitForMessageRestricted+0x14>
    1da2:	1d 8e       	std	Y+29, r1	; 0x1d
    1da4:	8e 8d       	ldd	r24, Y+30	; 0x1e
    1da6:	8f 3f       	cpi	r24, 0xFF	; 255
    1da8:	09 f4       	brne	.+2      	; 0x1dac <vQueueWaitForMessageRestricted+0x1c>
    1daa:	1e 8e       	std	Y+30, r1	; 0x1e
    1dac:	0f 90       	pop	r0
    1dae:	0f be       	out	0x3f, r0	; 63
        if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0U )
    1db0:	8a 8d       	ldd	r24, Y+26	; 0x1a
    1db2:	81 11       	cpse	r24, r1
    1db4:	04 c0       	rjmp	.+8      	; 0x1dbe <vQueueWaitForMessageRestricted+0x2e>
        {
            /* There is nothing in the queue, block for the specified period. */
            vTaskPlaceOnEventListRestricted( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait, xWaitIndefinitely );
    1db6:	ce 01       	movw	r24, r28
    1db8:	41 96       	adiw	r24, 0x11	; 17
    1dba:	0e 94 f3 12 	call	0x25e6	; 0x25e6 <vTaskPlaceOnEventListRestricted>
        }
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }
        prvUnlockQueue( pxQueue );
    1dbe:	ce 01       	movw	r24, r28
    }
    1dc0:	df 91       	pop	r29
    1dc2:	cf 91       	pop	r28
        }
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }
        prvUnlockQueue( pxQueue );
    1dc4:	0c 94 e7 0b 	jmp	0x17ce	; 0x17ce <prvUnlockQueue>

00001dc8 <prvResetNextTaskUnblockTime>:
    /* Reset the event list item to its normal value - so it can be used with
    queues and semaphores. */
    listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */

    return uxReturn;
}
    1dc8:	e0 91 88 03 	lds	r30, 0x0388	; 0x800388 <pxDelayedTaskList>
    1dcc:	f0 91 89 03 	lds	r31, 0x0389	; 0x800389 <pxDelayedTaskList+0x1>
    1dd0:	80 81       	ld	r24, Z
    1dd2:	81 11       	cpse	r24, r1
    1dd4:	03 c0       	rjmp	.+6      	; 0x1ddc <prvResetNextTaskUnblockTime+0x14>
    1dd6:	8f ef       	ldi	r24, 0xFF	; 255
    1dd8:	9f ef       	ldi	r25, 0xFF	; 255
    1dda:	0c c0       	rjmp	.+24     	; 0x1df4 <prvResetNextTaskUnblockTime+0x2c>
    1ddc:	e0 91 88 03 	lds	r30, 0x0388	; 0x800388 <pxDelayedTaskList>
    1de0:	f0 91 89 03 	lds	r31, 0x0389	; 0x800389 <pxDelayedTaskList+0x1>
    1de4:	05 80       	ldd	r0, Z+5	; 0x05
    1de6:	f6 81       	ldd	r31, Z+6	; 0x06
    1de8:	e0 2d       	mov	r30, r0
    1dea:	06 80       	ldd	r0, Z+6	; 0x06
    1dec:	f7 81       	ldd	r31, Z+7	; 0x07
    1dee:	e0 2d       	mov	r30, r0
    1df0:	82 81       	ldd	r24, Z+2	; 0x02
    1df2:	93 81       	ldd	r25, Z+3	; 0x03
    1df4:	90 93 60 03 	sts	0x0360, r25	; 0x800360 <xNextTaskUnblockTime+0x1>
    1df8:	80 93 5f 03 	sts	0x035F, r24	; 0x80035f <xNextTaskUnblockTime>
    1dfc:	08 95       	ret

00001dfe <prvAddCurrentTaskToDelayedList>:
    1dfe:	ff 92       	push	r15
    1e00:	0f 93       	push	r16
    1e02:	1f 93       	push	r17
    1e04:	cf 93       	push	r28
    1e06:	df 93       	push	r29
    1e08:	ec 01       	movw	r28, r24
    1e0a:	f6 2e       	mov	r15, r22
    1e0c:	00 91 67 03 	lds	r16, 0x0367	; 0x800367 <xTickCount>
    1e10:	10 91 68 03 	lds	r17, 0x0368	; 0x800368 <xTickCount+0x1>
    1e14:	80 91 c0 03 	lds	r24, 0x03C0	; 0x8003c0 <pxCurrentTCB>
    1e18:	90 91 c1 03 	lds	r25, 0x03C1	; 0x8003c1 <pxCurrentTCB+0x1>
    1e1c:	02 96       	adiw	r24, 0x02	; 2
    1e1e:	0e 94 ee 09 	call	0x13dc	; 0x13dc <uxListRemove>
    1e22:	cf 3f       	cpi	r28, 0xFF	; 255
    1e24:	8f ef       	ldi	r24, 0xFF	; 255
    1e26:	d8 07       	cpc	r29, r24
    1e28:	89 f4       	brne	.+34     	; 0x1e4c <prvAddCurrentTaskToDelayedList+0x4e>
    1e2a:	ff 20       	and	r15, r15
    1e2c:	79 f0       	breq	.+30     	; 0x1e4c <prvAddCurrentTaskToDelayedList+0x4e>
    1e2e:	60 91 c0 03 	lds	r22, 0x03C0	; 0x8003c0 <pxCurrentTCB>
    1e32:	70 91 c1 03 	lds	r23, 0x03C1	; 0x8003c1 <pxCurrentTCB+0x1>
    1e36:	6e 5f       	subi	r22, 0xFE	; 254
    1e38:	7f 4f       	sbci	r23, 0xFF	; 255
    1e3a:	8a e6       	ldi	r24, 0x6A	; 106
    1e3c:	93 e0       	ldi	r25, 0x03	; 3
    1e3e:	df 91       	pop	r29
    1e40:	cf 91       	pop	r28
    1e42:	1f 91       	pop	r17
    1e44:	0f 91       	pop	r16
    1e46:	ff 90       	pop	r15
    1e48:	0c 94 95 09 	jmp	0x132a	; 0x132a <vListInsertEnd>
    1e4c:	c0 0f       	add	r28, r16
    1e4e:	d1 1f       	adc	r29, r17
    1e50:	e0 91 c0 03 	lds	r30, 0x03C0	; 0x8003c0 <pxCurrentTCB>
    1e54:	f0 91 c1 03 	lds	r31, 0x03C1	; 0x8003c1 <pxCurrentTCB+0x1>
    1e58:	d3 83       	std	Z+3, r29	; 0x03
    1e5a:	c2 83       	std	Z+2, r28	; 0x02
    1e5c:	60 91 c0 03 	lds	r22, 0x03C0	; 0x8003c0 <pxCurrentTCB>
    1e60:	70 91 c1 03 	lds	r23, 0x03C1	; 0x8003c1 <pxCurrentTCB+0x1>
    1e64:	c0 17       	cp	r28, r16
    1e66:	d1 07       	cpc	r29, r17
    1e68:	68 f4       	brcc	.+26     	; 0x1e84 <prvAddCurrentTaskToDelayedList+0x86>
    1e6a:	80 91 86 03 	lds	r24, 0x0386	; 0x800386 <pxOverflowDelayedTaskList>
    1e6e:	90 91 87 03 	lds	r25, 0x0387	; 0x800387 <pxOverflowDelayedTaskList+0x1>
    1e72:	6e 5f       	subi	r22, 0xFE	; 254
    1e74:	7f 4f       	sbci	r23, 0xFF	; 255
    1e76:	df 91       	pop	r29
    1e78:	cf 91       	pop	r28
    1e7a:	1f 91       	pop	r17
    1e7c:	0f 91       	pop	r16
    1e7e:	ff 90       	pop	r15
    1e80:	0c 94 b6 09 	jmp	0x136c	; 0x136c <vListInsert>
    1e84:	80 91 88 03 	lds	r24, 0x0388	; 0x800388 <pxDelayedTaskList>
    1e88:	90 91 89 03 	lds	r25, 0x0389	; 0x800389 <pxDelayedTaskList+0x1>
    1e8c:	6e 5f       	subi	r22, 0xFE	; 254
    1e8e:	7f 4f       	sbci	r23, 0xFF	; 255
    1e90:	0e 94 b6 09 	call	0x136c	; 0x136c <vListInsert>
    1e94:	80 91 5f 03 	lds	r24, 0x035F	; 0x80035f <xNextTaskUnblockTime>
    1e98:	90 91 60 03 	lds	r25, 0x0360	; 0x800360 <xNextTaskUnblockTime+0x1>
    1e9c:	c8 17       	cp	r28, r24
    1e9e:	d9 07       	cpc	r29, r25
    1ea0:	20 f4       	brcc	.+8      	; 0x1eaa <prvAddCurrentTaskToDelayedList+0xac>
    1ea2:	d0 93 60 03 	sts	0x0360, r29	; 0x800360 <xNextTaskUnblockTime+0x1>
    1ea6:	c0 93 5f 03 	sts	0x035F, r28	; 0x80035f <xNextTaskUnblockTime>
    1eaa:	df 91       	pop	r29
    1eac:	cf 91       	pop	r28
    1eae:	1f 91       	pop	r17
    1eb0:	0f 91       	pop	r16
    1eb2:	ff 90       	pop	r15
    1eb4:	08 95       	ret

00001eb6 <prvIdleTask>:
    1eb6:	80 91 73 03 	lds	r24, 0x0373	; 0x800373 <uxDeletedTasksWaitingCleanUp>
    1eba:	88 23       	and	r24, r24
    1ebc:	09 f1       	breq	.+66     	; 0x1f00 <prvIdleTask+0x4a>
    1ebe:	0f b6       	in	r0, 0x3f	; 63
    1ec0:	f8 94       	cli
    1ec2:	0f 92       	push	r0
    1ec4:	e0 91 79 03 	lds	r30, 0x0379	; 0x800379 <xTasksWaitingTermination+0x5>
    1ec8:	f0 91 7a 03 	lds	r31, 0x037A	; 0x80037a <xTasksWaitingTermination+0x6>
    1ecc:	c6 81       	ldd	r28, Z+6	; 0x06
    1ece:	d7 81       	ldd	r29, Z+7	; 0x07
    1ed0:	ce 01       	movw	r24, r28
    1ed2:	02 96       	adiw	r24, 0x02	; 2
    1ed4:	0e 94 ee 09 	call	0x13dc	; 0x13dc <uxListRemove>
    1ed8:	80 91 69 03 	lds	r24, 0x0369	; 0x800369 <uxCurrentNumberOfTasks>
    1edc:	81 50       	subi	r24, 0x01	; 1
    1ede:	80 93 69 03 	sts	0x0369, r24	; 0x800369 <uxCurrentNumberOfTasks>
    1ee2:	80 91 73 03 	lds	r24, 0x0373	; 0x800373 <uxDeletedTasksWaitingCleanUp>
    1ee6:	81 50       	subi	r24, 0x01	; 1
    1ee8:	80 93 73 03 	sts	0x0373, r24	; 0x800373 <uxDeletedTasksWaitingCleanUp>
    1eec:	0f 90       	pop	r0
    1eee:	0f be       	out	0x3f, r0	; 63
    1ef0:	8f 89       	ldd	r24, Y+23	; 0x17
    1ef2:	98 8d       	ldd	r25, Y+24	; 0x18
    1ef4:	0e 94 72 09 	call	0x12e4	; 0x12e4 <vPortFree>
    1ef8:	ce 01       	movw	r24, r28
    1efa:	0e 94 72 09 	call	0x12e4	; 0x12e4 <vPortFree>
    1efe:	db cf       	rjmp	.-74     	; 0x1eb6 <prvIdleTask>
    1f00:	80 91 9c 03 	lds	r24, 0x039C	; 0x80039c <pxReadyTasksLists>
    1f04:	82 30       	cpi	r24, 0x02	; 2
    1f06:	10 f0       	brcs	.+4      	; 0x1f0c <prvIdleTask+0x56>
    1f08:	0e 94 b6 0a 	call	0x156c	; 0x156c <vPortYield>
    1f0c:	0e 94 9c 16 	call	0x2d38	; 0x2d38 <vApplicationIdleHook>
    1f10:	d2 cf       	rjmp	.-92     	; 0x1eb6 <prvIdleTask>

00001f12 <xTaskCreate>:
    1f12:	5f 92       	push	r5
    1f14:	6f 92       	push	r6
    1f16:	7f 92       	push	r7
    1f18:	8f 92       	push	r8
    1f1a:	9f 92       	push	r9
    1f1c:	af 92       	push	r10
    1f1e:	bf 92       	push	r11
    1f20:	cf 92       	push	r12
    1f22:	df 92       	push	r13
    1f24:	ef 92       	push	r14
    1f26:	ff 92       	push	r15
    1f28:	0f 93       	push	r16
    1f2a:	1f 93       	push	r17
    1f2c:	cf 93       	push	r28
    1f2e:	df 93       	push	r29
    1f30:	3c 01       	movw	r6, r24
    1f32:	6b 01       	movw	r12, r22
    1f34:	5a 01       	movw	r10, r20
    1f36:	49 01       	movw	r8, r18
    1f38:	50 2e       	mov	r5, r16
    1f3a:	ca 01       	movw	r24, r20
    1f3c:	0e 94 5f 09 	call	0x12be	; 0x12be <pvPortMalloc>
    1f40:	8c 01       	movw	r16, r24
    1f42:	89 2b       	or	r24, r25
    1f44:	09 f4       	brne	.+2      	; 0x1f48 <xTaskCreate+0x36>
    1f46:	e0 c0       	rjmp	.+448    	; 0x2108 <xTaskCreate+0x1f6>
    1f48:	88 e2       	ldi	r24, 0x28	; 40
    1f4a:	90 e0       	ldi	r25, 0x00	; 0
    1f4c:	0e 94 5f 09 	call	0x12be	; 0x12be <pvPortMalloc>
    1f50:	ec 01       	movw	r28, r24
    1f52:	89 2b       	or	r24, r25
    1f54:	c9 f0       	breq	.+50     	; 0x1f88 <xTaskCreate+0x76>
    1f56:	18 8f       	std	Y+24, r17	; 0x18
    1f58:	0f 8b       	std	Y+23, r16	; 0x17
    1f5a:	a5 01       	movw	r20, r10
    1f5c:	65 ea       	ldi	r22, 0xA5	; 165
    1f5e:	70 e0       	ldi	r23, 0x00	; 0
    1f60:	c8 01       	movw	r24, r16
    1f62:	0e 94 64 25 	call	0x4ac8	; 0x4ac8 <memset>
    1f66:	21 e0       	ldi	r18, 0x01	; 1
    1f68:	a2 1a       	sub	r10, r18
    1f6a:	b1 08       	sbc	r11, r1
    1f6c:	8f 89       	ldd	r24, Y+23	; 0x17
    1f6e:	98 8d       	ldd	r25, Y+24	; 0x18
    1f70:	a8 0e       	add	r10, r24
    1f72:	b9 1e       	adc	r11, r25
    1f74:	c1 14       	cp	r12, r1
    1f76:	d1 04       	cpc	r13, r1
    1f78:	c9 f0       	breq	.+50     	; 0x1fac <xTaskCreate+0x9a>
    1f7a:	be 01       	movw	r22, r28
    1f7c:	67 5e       	subi	r22, 0xE7	; 231
    1f7e:	7f 4f       	sbci	r23, 0xFF	; 255
    1f80:	f6 01       	movw	r30, r12
    1f82:	c6 01       	movw	r24, r12
    1f84:	08 96       	adiw	r24, 0x08	; 8
    1f86:	07 c0       	rjmp	.+14     	; 0x1f96 <xTaskCreate+0x84>
    1f88:	c8 01       	movw	r24, r16
    1f8a:	0e 94 72 09 	call	0x12e4	; 0x12e4 <vPortFree>
    1f8e:	bc c0       	rjmp	.+376    	; 0x2108 <xTaskCreate+0x1f6>
    1f90:	e8 17       	cp	r30, r24
    1f92:	f9 07       	cpc	r31, r25
    1f94:	49 f0       	breq	.+18     	; 0x1fa8 <xTaskCreate+0x96>
    1f96:	9f 01       	movw	r18, r30
    1f98:	41 91       	ld	r20, Z+
    1f9a:	db 01       	movw	r26, r22
    1f9c:	4d 93       	st	X+, r20
    1f9e:	bd 01       	movw	r22, r26
    1fa0:	d9 01       	movw	r26, r18
    1fa2:	2c 91       	ld	r18, X
    1fa4:	21 11       	cpse	r18, r1
    1fa6:	f4 cf       	rjmp	.-24     	; 0x1f90 <xTaskCreate+0x7e>
    1fa8:	18 a2       	std	Y+32, r1	; 0x20
    1faa:	01 c0       	rjmp	.+2      	; 0x1fae <xTaskCreate+0x9c>
    1fac:	19 8e       	std	Y+25, r1	; 0x19
    1fae:	05 2d       	mov	r16, r5
    1fb0:	04 30       	cpi	r16, 0x04	; 4
    1fb2:	08 f0       	brcs	.+2      	; 0x1fb6 <xTaskCreate+0xa4>
    1fb4:	03 e0       	ldi	r16, 0x03	; 3
    1fb6:	0e 8b       	std	Y+22, r16	; 0x16
    1fb8:	09 a3       	std	Y+33, r16	; 0x21
    1fba:	1a a2       	std	Y+34, r1	; 0x22
    1fbc:	6e 01       	movw	r12, r28
    1fbe:	b2 e0       	ldi	r27, 0x02	; 2
    1fc0:	cb 0e       	add	r12, r27
    1fc2:	d1 1c       	adc	r13, r1
    1fc4:	c6 01       	movw	r24, r12
    1fc6:	0e 94 91 09 	call	0x1322	; 0x1322 <vListInitialiseItem>
    1fca:	ce 01       	movw	r24, r28
    1fcc:	0c 96       	adiw	r24, 0x0c	; 12
    1fce:	0e 94 91 09 	call	0x1322	; 0x1322 <vListInitialiseItem>
    1fd2:	d9 87       	std	Y+9, r29	; 0x09
    1fd4:	c8 87       	std	Y+8, r28	; 0x08
    1fd6:	84 e0       	ldi	r24, 0x04	; 4
    1fd8:	90 e0       	ldi	r25, 0x00	; 0
    1fda:	80 1b       	sub	r24, r16
    1fdc:	91 09       	sbc	r25, r1
    1fde:	9d 87       	std	Y+13, r25	; 0x0d
    1fe0:	8c 87       	std	Y+12, r24	; 0x0c
    1fe2:	db 8b       	std	Y+19, r29	; 0x13
    1fe4:	ca 8b       	std	Y+18, r28	; 0x12
    1fe6:	1b a2       	std	Y+35, r1	; 0x23
    1fe8:	1c a2       	std	Y+36, r1	; 0x24
    1fea:	1d a2       	std	Y+37, r1	; 0x25
    1fec:	1e a2       	std	Y+38, r1	; 0x26
    1fee:	1f a2       	std	Y+39, r1	; 0x27
    1ff0:	a4 01       	movw	r20, r8
    1ff2:	b3 01       	movw	r22, r6
    1ff4:	c5 01       	movw	r24, r10
    1ff6:	0e 94 12 0a 	call	0x1424	; 0x1424 <pxPortInitialiseStack>
    1ffa:	99 83       	std	Y+1, r25	; 0x01
    1ffc:	88 83       	st	Y, r24
    1ffe:	e1 14       	cp	r14, r1
    2000:	f1 04       	cpc	r15, r1
    2002:	19 f0       	breq	.+6      	; 0x200a <xTaskCreate+0xf8>
    2004:	f7 01       	movw	r30, r14
    2006:	d1 83       	std	Z+1, r29	; 0x01
    2008:	c0 83       	st	Z, r28
    200a:	0f b6       	in	r0, 0x3f	; 63
    200c:	f8 94       	cli
    200e:	0f 92       	push	r0
    2010:	80 91 69 03 	lds	r24, 0x0369	; 0x800369 <uxCurrentNumberOfTasks>
    2014:	8f 5f       	subi	r24, 0xFF	; 255
    2016:	80 93 69 03 	sts	0x0369, r24	; 0x800369 <uxCurrentNumberOfTasks>
    201a:	80 91 c0 03 	lds	r24, 0x03C0	; 0x8003c0 <pxCurrentTCB>
    201e:	90 91 c1 03 	lds	r25, 0x03C1	; 0x8003c1 <pxCurrentTCB+0x1>
    2022:	89 2b       	or	r24, r25
    2024:	d1 f5       	brne	.+116    	; 0x209a <xTaskCreate+0x188>
    2026:	d0 93 c1 03 	sts	0x03C1, r29	; 0x8003c1 <pxCurrentTCB+0x1>
    202a:	c0 93 c0 03 	sts	0x03C0, r28	; 0x8003c0 <pxCurrentTCB>
    202e:	80 91 69 03 	lds	r24, 0x0369	; 0x800369 <uxCurrentNumberOfTasks>
    2032:	81 30       	cpi	r24, 0x01	; 1
    2034:	09 f0       	breq	.+2      	; 0x2038 <xTaskCreate+0x126>
    2036:	41 c0       	rjmp	.+130    	; 0x20ba <xTaskCreate+0x1a8>
    2038:	8c e9       	ldi	r24, 0x9C	; 156
    203a:	93 e0       	ldi	r25, 0x03	; 3
    203c:	0e 94 83 09 	call	0x1306	; 0x1306 <vListInitialise>
    2040:	85 ea       	ldi	r24, 0xA5	; 165
    2042:	93 e0       	ldi	r25, 0x03	; 3
    2044:	0e 94 83 09 	call	0x1306	; 0x1306 <vListInitialise>
    2048:	8e ea       	ldi	r24, 0xAE	; 174
    204a:	93 e0       	ldi	r25, 0x03	; 3
    204c:	0e 94 83 09 	call	0x1306	; 0x1306 <vListInitialise>
    2050:	87 eb       	ldi	r24, 0xB7	; 183
    2052:	93 e0       	ldi	r25, 0x03	; 3
    2054:	0e 94 83 09 	call	0x1306	; 0x1306 <vListInitialise>
    2058:	83 e9       	ldi	r24, 0x93	; 147
    205a:	93 e0       	ldi	r25, 0x03	; 3
    205c:	0e 94 83 09 	call	0x1306	; 0x1306 <vListInitialise>
    2060:	8a e8       	ldi	r24, 0x8A	; 138
    2062:	93 e0       	ldi	r25, 0x03	; 3
    2064:	0e 94 83 09 	call	0x1306	; 0x1306 <vListInitialise>
    2068:	8d e7       	ldi	r24, 0x7D	; 125
    206a:	93 e0       	ldi	r25, 0x03	; 3
    206c:	0e 94 83 09 	call	0x1306	; 0x1306 <vListInitialise>
    2070:	84 e7       	ldi	r24, 0x74	; 116
    2072:	93 e0       	ldi	r25, 0x03	; 3
    2074:	0e 94 83 09 	call	0x1306	; 0x1306 <vListInitialise>
    2078:	8a e6       	ldi	r24, 0x6A	; 106
    207a:	93 e0       	ldi	r25, 0x03	; 3
    207c:	0e 94 83 09 	call	0x1306	; 0x1306 <vListInitialise>
    2080:	83 e9       	ldi	r24, 0x93	; 147
    2082:	93 e0       	ldi	r25, 0x03	; 3
    2084:	90 93 89 03 	sts	0x0389, r25	; 0x800389 <pxDelayedTaskList+0x1>
    2088:	80 93 88 03 	sts	0x0388, r24	; 0x800388 <pxDelayedTaskList>
    208c:	8a e8       	ldi	r24, 0x8A	; 138
    208e:	93 e0       	ldi	r25, 0x03	; 3
    2090:	90 93 87 03 	sts	0x0387, r25	; 0x800387 <pxOverflowDelayedTaskList+0x1>
    2094:	80 93 86 03 	sts	0x0386, r24	; 0x800386 <pxOverflowDelayedTaskList>
    2098:	10 c0       	rjmp	.+32     	; 0x20ba <xTaskCreate+0x1a8>
    209a:	80 91 65 03 	lds	r24, 0x0365	; 0x800365 <xSchedulerRunning>
    209e:	81 11       	cpse	r24, r1
    20a0:	0c c0       	rjmp	.+24     	; 0x20ba <xTaskCreate+0x1a8>
    20a2:	e0 91 c0 03 	lds	r30, 0x03C0	; 0x8003c0 <pxCurrentTCB>
    20a6:	f0 91 c1 03 	lds	r31, 0x03C1	; 0x8003c1 <pxCurrentTCB+0x1>
    20aa:	96 89       	ldd	r25, Z+22	; 0x16
    20ac:	8e 89       	ldd	r24, Y+22	; 0x16
    20ae:	89 17       	cp	r24, r25
    20b0:	20 f0       	brcs	.+8      	; 0x20ba <xTaskCreate+0x1a8>
    20b2:	d0 93 c1 03 	sts	0x03C1, r29	; 0x8003c1 <pxCurrentTCB+0x1>
    20b6:	c0 93 c0 03 	sts	0x03C0, r28	; 0x8003c0 <pxCurrentTCB>
    20ba:	80 91 61 03 	lds	r24, 0x0361	; 0x800361 <uxTaskNumber>
    20be:	8f 5f       	subi	r24, 0xFF	; 255
    20c0:	80 93 61 03 	sts	0x0361, r24	; 0x800361 <uxTaskNumber>
    20c4:	8e 89       	ldd	r24, Y+22	; 0x16
    20c6:	90 91 66 03 	lds	r25, 0x0366	; 0x800366 <uxTopReadyPriority>
    20ca:	98 17       	cp	r25, r24
    20cc:	10 f4       	brcc	.+4      	; 0x20d2 <xTaskCreate+0x1c0>
    20ce:	80 93 66 03 	sts	0x0366, r24	; 0x800366 <uxTopReadyPriority>
    20d2:	f9 e0       	ldi	r31, 0x09	; 9
    20d4:	8f 9f       	mul	r24, r31
    20d6:	c0 01       	movw	r24, r0
    20d8:	11 24       	eor	r1, r1
    20da:	b6 01       	movw	r22, r12
    20dc:	84 56       	subi	r24, 0x64	; 100
    20de:	9c 4f       	sbci	r25, 0xFC	; 252
    20e0:	0e 94 95 09 	call	0x132a	; 0x132a <vListInsertEnd>
    20e4:	0f 90       	pop	r0
    20e6:	0f be       	out	0x3f, r0	; 63
    20e8:	80 91 65 03 	lds	r24, 0x0365	; 0x800365 <xSchedulerRunning>
    20ec:	88 23       	and	r24, r24
    20ee:	51 f0       	breq	.+20     	; 0x2104 <xTaskCreate+0x1f2>
    20f0:	e0 91 c0 03 	lds	r30, 0x03C0	; 0x8003c0 <pxCurrentTCB>
    20f4:	f0 91 c1 03 	lds	r31, 0x03C1	; 0x8003c1 <pxCurrentTCB+0x1>
    20f8:	96 89       	ldd	r25, Z+22	; 0x16
    20fa:	8e 89       	ldd	r24, Y+22	; 0x16
    20fc:	98 17       	cp	r25, r24
    20fe:	10 f4       	brcc	.+4      	; 0x2104 <xTaskCreate+0x1f2>
    2100:	0e 94 b6 0a 	call	0x156c	; 0x156c <vPortYield>
    2104:	81 e0       	ldi	r24, 0x01	; 1
    2106:	01 c0       	rjmp	.+2      	; 0x210a <xTaskCreate+0x1f8>
    2108:	8f ef       	ldi	r24, 0xFF	; 255
    210a:	df 91       	pop	r29
    210c:	cf 91       	pop	r28
    210e:	1f 91       	pop	r17
    2110:	0f 91       	pop	r16
    2112:	ff 90       	pop	r15
    2114:	ef 90       	pop	r14
    2116:	df 90       	pop	r13
    2118:	cf 90       	pop	r12
    211a:	bf 90       	pop	r11
    211c:	af 90       	pop	r10
    211e:	9f 90       	pop	r9
    2120:	8f 90       	pop	r8
    2122:	7f 90       	pop	r7
    2124:	6f 90       	pop	r6
    2126:	5f 90       	pop	r5
    2128:	08 95       	ret

0000212a <vTaskResume>:
    212a:	0f 93       	push	r16
    212c:	1f 93       	push	r17
    212e:	cf 93       	push	r28
    2130:	df 93       	push	r29
    2132:	20 91 c0 03 	lds	r18, 0x03C0	; 0x8003c0 <pxCurrentTCB>
    2136:	30 91 c1 03 	lds	r19, 0x03C1	; 0x8003c1 <pxCurrentTCB+0x1>
    213a:	82 17       	cp	r24, r18
    213c:	93 07       	cpc	r25, r19
    213e:	09 f4       	brne	.+2      	; 0x2142 <vTaskResume+0x18>
    2140:	38 c0       	rjmp	.+112    	; 0x21b2 <vTaskResume+0x88>
    2142:	00 97       	sbiw	r24, 0x00	; 0
    2144:	09 f4       	brne	.+2      	; 0x2148 <vTaskResume+0x1e>
    2146:	35 c0       	rjmp	.+106    	; 0x21b2 <vTaskResume+0x88>
    2148:	0f b6       	in	r0, 0x3f	; 63
    214a:	f8 94       	cli
    214c:	0f 92       	push	r0
    214e:	fc 01       	movw	r30, r24
    2150:	22 85       	ldd	r18, Z+10	; 0x0a
    2152:	33 85       	ldd	r19, Z+11	; 0x0b
    2154:	2a 56       	subi	r18, 0x6A	; 106
    2156:	33 40       	sbci	r19, 0x03	; 3
    2158:	51 f5       	brne	.+84     	; 0x21ae <vTaskResume+0x84>
    215a:	fc 01       	movw	r30, r24
    215c:	24 89       	ldd	r18, Z+20	; 0x14
    215e:	35 89       	ldd	r19, Z+21	; 0x15
    2160:	f3 e0       	ldi	r31, 0x03	; 3
    2162:	2d 37       	cpi	r18, 0x7D	; 125
    2164:	3f 07       	cpc	r19, r31
    2166:	19 f1       	breq	.+70     	; 0x21ae <vTaskResume+0x84>
    2168:	23 2b       	or	r18, r19
    216a:	09 f5       	brne	.+66     	; 0x21ae <vTaskResume+0x84>
    216c:	ec 01       	movw	r28, r24
    216e:	8c 01       	movw	r16, r24
    2170:	0e 5f       	subi	r16, 0xFE	; 254
    2172:	1f 4f       	sbci	r17, 0xFF	; 255
    2174:	c8 01       	movw	r24, r16
    2176:	0e 94 ee 09 	call	0x13dc	; 0x13dc <uxListRemove>
    217a:	8e 89       	ldd	r24, Y+22	; 0x16
    217c:	90 91 66 03 	lds	r25, 0x0366	; 0x800366 <uxTopReadyPriority>
    2180:	98 17       	cp	r25, r24
    2182:	10 f4       	brcc	.+4      	; 0x2188 <vTaskResume+0x5e>
    2184:	80 93 66 03 	sts	0x0366, r24	; 0x800366 <uxTopReadyPriority>
    2188:	29 e0       	ldi	r18, 0x09	; 9
    218a:	82 9f       	mul	r24, r18
    218c:	c0 01       	movw	r24, r0
    218e:	11 24       	eor	r1, r1
    2190:	b8 01       	movw	r22, r16
    2192:	84 56       	subi	r24, 0x64	; 100
    2194:	9c 4f       	sbci	r25, 0xFC	; 252
    2196:	0e 94 95 09 	call	0x132a	; 0x132a <vListInsertEnd>
    219a:	e0 91 c0 03 	lds	r30, 0x03C0	; 0x8003c0 <pxCurrentTCB>
    219e:	f0 91 c1 03 	lds	r31, 0x03C1	; 0x8003c1 <pxCurrentTCB+0x1>
    21a2:	9e 89       	ldd	r25, Y+22	; 0x16
    21a4:	86 89       	ldd	r24, Z+22	; 0x16
    21a6:	98 17       	cp	r25, r24
    21a8:	10 f0       	brcs	.+4      	; 0x21ae <vTaskResume+0x84>
    21aa:	0e 94 b6 0a 	call	0x156c	; 0x156c <vPortYield>
    21ae:	0f 90       	pop	r0
    21b0:	0f be       	out	0x3f, r0	; 63
    21b2:	df 91       	pop	r29
    21b4:	cf 91       	pop	r28
    21b6:	1f 91       	pop	r17
    21b8:	0f 91       	pop	r16
    21ba:	08 95       	ret

000021bc <vTaskStartScheduler>:
    21bc:	ef 92       	push	r14
    21be:	ff 92       	push	r15
    21c0:	0f 93       	push	r16
    21c2:	8d e5       	ldi	r24, 0x5D	; 93
    21c4:	e8 2e       	mov	r14, r24
    21c6:	83 e0       	ldi	r24, 0x03	; 3
    21c8:	f8 2e       	mov	r15, r24
    21ca:	00 e0       	ldi	r16, 0x00	; 0
    21cc:	20 e0       	ldi	r18, 0x00	; 0
    21ce:	30 e0       	ldi	r19, 0x00	; 0
    21d0:	40 ec       	ldi	r20, 0xC0	; 192
    21d2:	50 e0       	ldi	r21, 0x00	; 0
    21d4:	63 ed       	ldi	r22, 0xD3	; 211
    21d6:	71 e0       	ldi	r23, 0x01	; 1
    21d8:	8b e5       	ldi	r24, 0x5B	; 91
    21da:	9f e0       	ldi	r25, 0x0F	; 15
    21dc:	0e 94 89 0f 	call	0x1f12	; 0x1f12 <xTaskCreate>
    21e0:	81 30       	cpi	r24, 0x01	; 1
    21e2:	b1 f4       	brne	.+44     	; 0x2210 <vTaskStartScheduler+0x54>
    21e4:	0e 94 e4 14 	call	0x29c8	; 0x29c8 <xTimerCreateTimerTask>
    21e8:	81 30       	cpi	r24, 0x01	; 1
    21ea:	91 f4       	brne	.+36     	; 0x2210 <vTaskStartScheduler+0x54>
    21ec:	f8 94       	cli
    21ee:	2f ef       	ldi	r18, 0xFF	; 255
    21f0:	3f ef       	ldi	r19, 0xFF	; 255
    21f2:	30 93 60 03 	sts	0x0360, r19	; 0x800360 <xNextTaskUnblockTime+0x1>
    21f6:	20 93 5f 03 	sts	0x035F, r18	; 0x80035f <xNextTaskUnblockTime>
    21fa:	80 93 65 03 	sts	0x0365, r24	; 0x800365 <xSchedulerRunning>
    21fe:	10 92 68 03 	sts	0x0368, r1	; 0x800368 <xTickCount+0x1>
    2202:	10 92 67 03 	sts	0x0367, r1	; 0x800367 <xTickCount>
    2206:	0f 91       	pop	r16
    2208:	ff 90       	pop	r15
    220a:	ef 90       	pop	r14
    220c:	0c 94 7e 0a 	jmp	0x14fc	; 0x14fc <xPortStartScheduler>
    2210:	0f 91       	pop	r16
    2212:	ff 90       	pop	r15
    2214:	ef 90       	pop	r14
    2216:	08 95       	ret

00002218 <vTaskSuspendAll>:
    2218:	80 91 5c 03 	lds	r24, 0x035C	; 0x80035c <uxSchedulerSuspended>
    221c:	8f 5f       	subi	r24, 0xFF	; 255
    221e:	80 93 5c 03 	sts	0x035C, r24	; 0x80035c <uxSchedulerSuspended>
    2222:	08 95       	ret

00002224 <xTaskGetTickCount>:
    2224:	0f b6       	in	r0, 0x3f	; 63
    2226:	f8 94       	cli
    2228:	0f 92       	push	r0
    222a:	80 91 67 03 	lds	r24, 0x0367	; 0x800367 <xTickCount>
    222e:	90 91 68 03 	lds	r25, 0x0368	; 0x800368 <xTickCount+0x1>
    2232:	0f 90       	pop	r0
    2234:	0f be       	out	0x3f, r0	; 63
    2236:	08 95       	ret

00002238 <xTaskIncrementTick>:
    2238:	cf 92       	push	r12
    223a:	df 92       	push	r13
    223c:	ef 92       	push	r14
    223e:	ff 92       	push	r15
    2240:	0f 93       	push	r16
    2242:	1f 93       	push	r17
    2244:	cf 93       	push	r28
    2246:	df 93       	push	r29
    2248:	80 91 5c 03 	lds	r24, 0x035C	; 0x80035c <uxSchedulerSuspended>
    224c:	81 11       	cpse	r24, r1
    224e:	8c c0       	rjmp	.+280    	; 0x2368 <xTaskIncrementTick+0x130>
    2250:	00 91 67 03 	lds	r16, 0x0367	; 0x800367 <xTickCount>
    2254:	10 91 68 03 	lds	r17, 0x0368	; 0x800368 <xTickCount+0x1>
    2258:	0f 5f       	subi	r16, 0xFF	; 255
    225a:	1f 4f       	sbci	r17, 0xFF	; 255
    225c:	10 93 68 03 	sts	0x0368, r17	; 0x800368 <xTickCount+0x1>
    2260:	00 93 67 03 	sts	0x0367, r16	; 0x800367 <xTickCount>
    2264:	01 15       	cp	r16, r1
    2266:	11 05       	cpc	r17, r1
    2268:	b9 f4       	brne	.+46     	; 0x2298 <xTaskIncrementTick+0x60>
    226a:	80 91 88 03 	lds	r24, 0x0388	; 0x800388 <pxDelayedTaskList>
    226e:	90 91 89 03 	lds	r25, 0x0389	; 0x800389 <pxDelayedTaskList+0x1>
    2272:	20 91 86 03 	lds	r18, 0x0386	; 0x800386 <pxOverflowDelayedTaskList>
    2276:	30 91 87 03 	lds	r19, 0x0387	; 0x800387 <pxOverflowDelayedTaskList+0x1>
    227a:	30 93 89 03 	sts	0x0389, r19	; 0x800389 <pxDelayedTaskList+0x1>
    227e:	20 93 88 03 	sts	0x0388, r18	; 0x800388 <pxDelayedTaskList>
    2282:	90 93 87 03 	sts	0x0387, r25	; 0x800387 <pxOverflowDelayedTaskList+0x1>
    2286:	80 93 86 03 	sts	0x0386, r24	; 0x800386 <pxOverflowDelayedTaskList>
    228a:	80 91 62 03 	lds	r24, 0x0362	; 0x800362 <xNumOfOverflows>
    228e:	8f 5f       	subi	r24, 0xFF	; 255
    2290:	80 93 62 03 	sts	0x0362, r24	; 0x800362 <xNumOfOverflows>
    2294:	0e 94 e4 0e 	call	0x1dc8	; 0x1dc8 <prvResetNextTaskUnblockTime>
    2298:	80 91 5f 03 	lds	r24, 0x035F	; 0x80035f <xNextTaskUnblockTime>
    229c:	90 91 60 03 	lds	r25, 0x0360	; 0x800360 <xNextTaskUnblockTime+0x1>
    22a0:	c0 e0       	ldi	r28, 0x00	; 0
    22a2:	08 17       	cp	r16, r24
    22a4:	19 07       	cpc	r17, r25
    22a6:	08 f4       	brcc	.+2      	; 0x22aa <xTaskIncrementTick+0x72>
    22a8:	4f c0       	rjmp	.+158    	; 0x2348 <xTaskIncrementTick+0x110>
    22aa:	d9 e0       	ldi	r29, 0x09	; 9
    22ac:	e0 91 88 03 	lds	r30, 0x0388	; 0x800388 <pxDelayedTaskList>
    22b0:	f0 91 89 03 	lds	r31, 0x0389	; 0x800389 <pxDelayedTaskList+0x1>
    22b4:	80 81       	ld	r24, Z
    22b6:	81 11       	cpse	r24, r1
    22b8:	03 c0       	rjmp	.+6      	; 0x22c0 <xTaskIncrementTick+0x88>
    22ba:	8f ef       	ldi	r24, 0xFF	; 255
    22bc:	9f ef       	ldi	r25, 0xFF	; 255
    22be:	11 c0       	rjmp	.+34     	; 0x22e2 <xTaskIncrementTick+0xaa>
    22c0:	e0 91 88 03 	lds	r30, 0x0388	; 0x800388 <pxDelayedTaskList>
    22c4:	f0 91 89 03 	lds	r31, 0x0389	; 0x800389 <pxDelayedTaskList+0x1>
    22c8:	05 80       	ldd	r0, Z+5	; 0x05
    22ca:	f6 81       	ldd	r31, Z+6	; 0x06
    22cc:	e0 2d       	mov	r30, r0
    22ce:	e6 80       	ldd	r14, Z+6	; 0x06
    22d0:	f7 80       	ldd	r15, Z+7	; 0x07
    22d2:	d7 01       	movw	r26, r14
    22d4:	12 96       	adiw	r26, 0x02	; 2
    22d6:	8d 91       	ld	r24, X+
    22d8:	9c 91       	ld	r25, X
    22da:	13 97       	sbiw	r26, 0x03	; 3
    22dc:	08 17       	cp	r16, r24
    22de:	19 07       	cpc	r17, r25
    22e0:	28 f4       	brcc	.+10     	; 0x22ec <xTaskIncrementTick+0xb4>
    22e2:	90 93 60 03 	sts	0x0360, r25	; 0x800360 <xNextTaskUnblockTime+0x1>
    22e6:	80 93 5f 03 	sts	0x035F, r24	; 0x80035f <xNextTaskUnblockTime>
    22ea:	2e c0       	rjmp	.+92     	; 0x2348 <xTaskIncrementTick+0x110>
    22ec:	67 01       	movw	r12, r14
    22ee:	b2 e0       	ldi	r27, 0x02	; 2
    22f0:	cb 0e       	add	r12, r27
    22f2:	d1 1c       	adc	r13, r1
    22f4:	c6 01       	movw	r24, r12
    22f6:	0e 94 ee 09 	call	0x13dc	; 0x13dc <uxListRemove>
    22fa:	f7 01       	movw	r30, r14
    22fc:	84 89       	ldd	r24, Z+20	; 0x14
    22fe:	95 89       	ldd	r25, Z+21	; 0x15
    2300:	89 2b       	or	r24, r25
    2302:	21 f0       	breq	.+8      	; 0x230c <xTaskIncrementTick+0xd4>
    2304:	c7 01       	movw	r24, r14
    2306:	0c 96       	adiw	r24, 0x0c	; 12
    2308:	0e 94 ee 09 	call	0x13dc	; 0x13dc <uxListRemove>
    230c:	d7 01       	movw	r26, r14
    230e:	56 96       	adiw	r26, 0x16	; 22
    2310:	8c 91       	ld	r24, X
    2312:	90 91 66 03 	lds	r25, 0x0366	; 0x800366 <uxTopReadyPriority>
    2316:	98 17       	cp	r25, r24
    2318:	10 f4       	brcc	.+4      	; 0x231e <xTaskIncrementTick+0xe6>
    231a:	80 93 66 03 	sts	0x0366, r24	; 0x800366 <uxTopReadyPriority>
    231e:	d8 9f       	mul	r29, r24
    2320:	c0 01       	movw	r24, r0
    2322:	11 24       	eor	r1, r1
    2324:	b6 01       	movw	r22, r12
    2326:	84 56       	subi	r24, 0x64	; 100
    2328:	9c 4f       	sbci	r25, 0xFC	; 252
    232a:	0e 94 95 09 	call	0x132a	; 0x132a <vListInsertEnd>
    232e:	e0 91 c0 03 	lds	r30, 0x03C0	; 0x8003c0 <pxCurrentTCB>
    2332:	f0 91 c1 03 	lds	r31, 0x03C1	; 0x8003c1 <pxCurrentTCB+0x1>
    2336:	d7 01       	movw	r26, r14
    2338:	56 96       	adiw	r26, 0x16	; 22
    233a:	9c 91       	ld	r25, X
    233c:	86 89       	ldd	r24, Z+22	; 0x16
    233e:	98 17       	cp	r25, r24
    2340:	08 f4       	brcc	.+2      	; 0x2344 <xTaskIncrementTick+0x10c>
    2342:	b4 cf       	rjmp	.-152    	; 0x22ac <xTaskIncrementTick+0x74>
    2344:	c1 e0       	ldi	r28, 0x01	; 1
    2346:	b2 cf       	rjmp	.-156    	; 0x22ac <xTaskIncrementTick+0x74>
    2348:	e0 91 c0 03 	lds	r30, 0x03C0	; 0x8003c0 <pxCurrentTCB>
    234c:	f0 91 c1 03 	lds	r31, 0x03C1	; 0x8003c1 <pxCurrentTCB+0x1>
    2350:	e6 89       	ldd	r30, Z+22	; 0x16
    2352:	b9 e0       	ldi	r27, 0x09	; 9
    2354:	eb 9f       	mul	r30, r27
    2356:	f0 01       	movw	r30, r0
    2358:	11 24       	eor	r1, r1
    235a:	e4 56       	subi	r30, 0x64	; 100
    235c:	fc 4f       	sbci	r31, 0xFC	; 252
    235e:	80 81       	ld	r24, Z
    2360:	82 30       	cpi	r24, 0x02	; 2
    2362:	40 f0       	brcs	.+16     	; 0x2374 <xTaskIncrementTick+0x13c>
    2364:	c1 e0       	ldi	r28, 0x01	; 1
    2366:	06 c0       	rjmp	.+12     	; 0x2374 <xTaskIncrementTick+0x13c>
    2368:	80 91 64 03 	lds	r24, 0x0364	; 0x800364 <uxPendedTicks>
    236c:	8f 5f       	subi	r24, 0xFF	; 255
    236e:	80 93 64 03 	sts	0x0364, r24	; 0x800364 <uxPendedTicks>
    2372:	c0 e0       	ldi	r28, 0x00	; 0
    2374:	80 91 63 03 	lds	r24, 0x0363	; 0x800363 <xYieldPending>
    2378:	81 11       	cpse	r24, r1
    237a:	c1 e0       	ldi	r28, 0x01	; 1
    237c:	8c 2f       	mov	r24, r28
    237e:	df 91       	pop	r29
    2380:	cf 91       	pop	r28
    2382:	1f 91       	pop	r17
    2384:	0f 91       	pop	r16
    2386:	ff 90       	pop	r15
    2388:	ef 90       	pop	r14
    238a:	df 90       	pop	r13
    238c:	cf 90       	pop	r12
    238e:	08 95       	ret

00002390 <xTaskResumeAll>:
    2390:	ef 92       	push	r14
    2392:	ff 92       	push	r15
    2394:	0f 93       	push	r16
    2396:	1f 93       	push	r17
    2398:	cf 93       	push	r28
    239a:	df 93       	push	r29
    239c:	0f b6       	in	r0, 0x3f	; 63
    239e:	f8 94       	cli
    23a0:	0f 92       	push	r0
    23a2:	80 91 5c 03 	lds	r24, 0x035C	; 0x80035c <uxSchedulerSuspended>
    23a6:	81 50       	subi	r24, 0x01	; 1
    23a8:	80 93 5c 03 	sts	0x035C, r24	; 0x80035c <uxSchedulerSuspended>
    23ac:	80 91 5c 03 	lds	r24, 0x035C	; 0x80035c <uxSchedulerSuspended>
    23b0:	88 23       	and	r24, r24
    23b2:	11 f0       	breq	.+4      	; 0x23b8 <xTaskResumeAll+0x28>
    23b4:	80 e0       	ldi	r24, 0x00	; 0
    23b6:	52 c0       	rjmp	.+164    	; 0x245c <xTaskResumeAll+0xcc>
    23b8:	80 91 69 03 	lds	r24, 0x0369	; 0x800369 <uxCurrentNumberOfTasks>
    23bc:	88 23       	and	r24, r24
    23be:	d1 f3       	breq	.-12     	; 0x23b4 <xTaskResumeAll+0x24>
    23c0:	c0 e0       	ldi	r28, 0x00	; 0
    23c2:	d0 e0       	ldi	r29, 0x00	; 0
    23c4:	89 e0       	ldi	r24, 0x09	; 9
    23c6:	f8 2e       	mov	r15, r24
    23c8:	ee 24       	eor	r14, r14
    23ca:	e3 94       	inc	r14
    23cc:	80 91 7d 03 	lds	r24, 0x037D	; 0x80037d <xPendingReadyList>
    23d0:	88 23       	and	r24, r24
    23d2:	51 f1       	breq	.+84     	; 0x2428 <xTaskResumeAll+0x98>
    23d4:	e0 91 82 03 	lds	r30, 0x0382	; 0x800382 <xPendingReadyList+0x5>
    23d8:	f0 91 83 03 	lds	r31, 0x0383	; 0x800383 <xPendingReadyList+0x6>
    23dc:	c6 81       	ldd	r28, Z+6	; 0x06
    23de:	d7 81       	ldd	r29, Z+7	; 0x07
    23e0:	ce 01       	movw	r24, r28
    23e2:	0c 96       	adiw	r24, 0x0c	; 12
    23e4:	0e 94 ee 09 	call	0x13dc	; 0x13dc <uxListRemove>
    23e8:	8e 01       	movw	r16, r28
    23ea:	0e 5f       	subi	r16, 0xFE	; 254
    23ec:	1f 4f       	sbci	r17, 0xFF	; 255
    23ee:	c8 01       	movw	r24, r16
    23f0:	0e 94 ee 09 	call	0x13dc	; 0x13dc <uxListRemove>
    23f4:	8e 89       	ldd	r24, Y+22	; 0x16
    23f6:	90 91 66 03 	lds	r25, 0x0366	; 0x800366 <uxTopReadyPriority>
    23fa:	98 17       	cp	r25, r24
    23fc:	10 f4       	brcc	.+4      	; 0x2402 <xTaskResumeAll+0x72>
    23fe:	80 93 66 03 	sts	0x0366, r24	; 0x800366 <uxTopReadyPriority>
    2402:	f8 9e       	mul	r15, r24
    2404:	c0 01       	movw	r24, r0
    2406:	11 24       	eor	r1, r1
    2408:	b8 01       	movw	r22, r16
    240a:	84 56       	subi	r24, 0x64	; 100
    240c:	9c 4f       	sbci	r25, 0xFC	; 252
    240e:	0e 94 95 09 	call	0x132a	; 0x132a <vListInsertEnd>
    2412:	e0 91 c0 03 	lds	r30, 0x03C0	; 0x8003c0 <pxCurrentTCB>
    2416:	f0 91 c1 03 	lds	r31, 0x03C1	; 0x8003c1 <pxCurrentTCB+0x1>
    241a:	9e 89       	ldd	r25, Y+22	; 0x16
    241c:	86 89       	ldd	r24, Z+22	; 0x16
    241e:	98 17       	cp	r25, r24
    2420:	a8 f2       	brcs	.-86     	; 0x23cc <xTaskResumeAll+0x3c>
    2422:	e0 92 63 03 	sts	0x0363, r14	; 0x800363 <xYieldPending>
    2426:	d2 cf       	rjmp	.-92     	; 0x23cc <xTaskResumeAll+0x3c>
    2428:	cd 2b       	or	r28, r29
    242a:	11 f0       	breq	.+4      	; 0x2430 <xTaskResumeAll+0xa0>
    242c:	0e 94 e4 0e 	call	0x1dc8	; 0x1dc8 <prvResetNextTaskUnblockTime>
    2430:	c0 91 64 03 	lds	r28, 0x0364	; 0x800364 <uxPendedTicks>
    2434:	cc 23       	and	r28, r28
    2436:	51 f0       	breq	.+20     	; 0x244c <xTaskResumeAll+0xbc>
    2438:	d1 e0       	ldi	r29, 0x01	; 1
    243a:	0e 94 1c 11 	call	0x2238	; 0x2238 <xTaskIncrementTick>
    243e:	81 11       	cpse	r24, r1
    2440:	d0 93 63 03 	sts	0x0363, r29	; 0x800363 <xYieldPending>
    2444:	c1 50       	subi	r28, 0x01	; 1
    2446:	c9 f7       	brne	.-14     	; 0x243a <xTaskResumeAll+0xaa>
    2448:	10 92 64 03 	sts	0x0364, r1	; 0x800364 <uxPendedTicks>
    244c:	80 91 63 03 	lds	r24, 0x0363	; 0x800363 <xYieldPending>
    2450:	88 23       	and	r24, r24
    2452:	09 f4       	brne	.+2      	; 0x2456 <xTaskResumeAll+0xc6>
    2454:	af cf       	rjmp	.-162    	; 0x23b4 <xTaskResumeAll+0x24>
    2456:	0e 94 b6 0a 	call	0x156c	; 0x156c <vPortYield>
    245a:	81 e0       	ldi	r24, 0x01	; 1
    245c:	0f 90       	pop	r0
    245e:	0f be       	out	0x3f, r0	; 63
    2460:	df 91       	pop	r29
    2462:	cf 91       	pop	r28
    2464:	1f 91       	pop	r17
    2466:	0f 91       	pop	r16
    2468:	ff 90       	pop	r15
    246a:	ef 90       	pop	r14
    246c:	08 95       	ret

0000246e <vTaskDelayUntil>:
    246e:	0f 93       	push	r16
    2470:	1f 93       	push	r17
    2472:	cf 93       	push	r28
    2474:	df 93       	push	r29
    2476:	8c 01       	movw	r16, r24
    2478:	eb 01       	movw	r28, r22
    247a:	0e 94 0c 11 	call	0x2218	; 0x2218 <vTaskSuspendAll>
    247e:	40 91 67 03 	lds	r20, 0x0367	; 0x800367 <xTickCount>
    2482:	50 91 68 03 	lds	r21, 0x0368	; 0x800368 <xTickCount+0x1>
    2486:	f8 01       	movw	r30, r16
    2488:	20 81       	ld	r18, Z
    248a:	31 81       	ldd	r19, Z+1	; 0x01
    248c:	c9 01       	movw	r24, r18
    248e:	8c 0f       	add	r24, r28
    2490:	9d 1f       	adc	r25, r29
    2492:	42 17       	cp	r20, r18
    2494:	53 07       	cpc	r21, r19
    2496:	20 f4       	brcc	.+8      	; 0x24a0 <vTaskDelayUntil+0x32>
    2498:	82 17       	cp	r24, r18
    249a:	93 07       	cpc	r25, r19
    249c:	40 f4       	brcc	.+16     	; 0x24ae <vTaskDelayUntil+0x40>
    249e:	03 c0       	rjmp	.+6      	; 0x24a6 <vTaskDelayUntil+0x38>
    24a0:	82 17       	cp	r24, r18
    24a2:	93 07       	cpc	r25, r19
    24a4:	30 f0       	brcs	.+12     	; 0x24b2 <vTaskDelayUntil+0x44>
    24a6:	21 e0       	ldi	r18, 0x01	; 1
    24a8:	48 17       	cp	r20, r24
    24aa:	59 07       	cpc	r21, r25
    24ac:	18 f0       	brcs	.+6      	; 0x24b4 <vTaskDelayUntil+0x46>
    24ae:	20 e0       	ldi	r18, 0x00	; 0
    24b0:	01 c0       	rjmp	.+2      	; 0x24b4 <vTaskDelayUntil+0x46>
    24b2:	21 e0       	ldi	r18, 0x01	; 1
    24b4:	f8 01       	movw	r30, r16
    24b6:	91 83       	std	Z+1, r25	; 0x01
    24b8:	80 83       	st	Z, r24
    24ba:	22 23       	and	r18, r18
    24bc:	29 f0       	breq	.+10     	; 0x24c8 <vTaskDelayUntil+0x5a>
    24be:	60 e0       	ldi	r22, 0x00	; 0
    24c0:	84 1b       	sub	r24, r20
    24c2:	95 0b       	sbc	r25, r21
    24c4:	0e 94 ff 0e 	call	0x1dfe	; 0x1dfe <prvAddCurrentTaskToDelayedList>
    24c8:	0e 94 c8 11 	call	0x2390	; 0x2390 <xTaskResumeAll>
    24cc:	81 11       	cpse	r24, r1
    24ce:	02 c0       	rjmp	.+4      	; 0x24d4 <vTaskDelayUntil+0x66>
    24d0:	0e 94 b6 0a 	call	0x156c	; 0x156c <vPortYield>
    24d4:	df 91       	pop	r29
    24d6:	cf 91       	pop	r28
    24d8:	1f 91       	pop	r17
    24da:	0f 91       	pop	r16
    24dc:	08 95       	ret

000024de <vTaskDelay>:
    24de:	cf 93       	push	r28
    24e0:	df 93       	push	r29
    24e2:	ec 01       	movw	r28, r24
    24e4:	89 2b       	or	r24, r25
    24e6:	19 f4       	brne	.+6      	; 0x24ee <vTaskDelay+0x10>
    24e8:	0e 94 b6 0a 	call	0x156c	; 0x156c <vPortYield>
    24ec:	0a c0       	rjmp	.+20     	; 0x2502 <vTaskDelay+0x24>
    24ee:	0e 94 0c 11 	call	0x2218	; 0x2218 <vTaskSuspendAll>
    24f2:	60 e0       	ldi	r22, 0x00	; 0
    24f4:	ce 01       	movw	r24, r28
    24f6:	0e 94 ff 0e 	call	0x1dfe	; 0x1dfe <prvAddCurrentTaskToDelayedList>
    24fa:	0e 94 c8 11 	call	0x2390	; 0x2390 <xTaskResumeAll>
    24fe:	88 23       	and	r24, r24
    2500:	99 f3       	breq	.-26     	; 0x24e8 <vTaskDelay+0xa>
    2502:	df 91       	pop	r29
    2504:	cf 91       	pop	r28
    2506:	08 95       	ret

00002508 <vTaskSwitchContext>:
    2508:	80 91 5c 03 	lds	r24, 0x035C	; 0x80035c <uxSchedulerSuspended>
    250c:	88 23       	and	r24, r24
    250e:	21 f0       	breq	.+8      	; 0x2518 <vTaskSwitchContext+0x10>
    2510:	81 e0       	ldi	r24, 0x01	; 1
    2512:	80 93 63 03 	sts	0x0363, r24	; 0x800363 <xYieldPending>
    2516:	08 95       	ret
    2518:	10 92 63 03 	sts	0x0363, r1	; 0x800363 <xYieldPending>
    251c:	a0 91 c0 03 	lds	r26, 0x03C0	; 0x8003c0 <pxCurrentTCB>
    2520:	b0 91 c1 03 	lds	r27, 0x03C1	; 0x8003c1 <pxCurrentTCB+0x1>
    2524:	e0 91 c0 03 	lds	r30, 0x03C0	; 0x8003c0 <pxCurrentTCB>
    2528:	f0 91 c1 03 	lds	r31, 0x03C1	; 0x8003c1 <pxCurrentTCB+0x1>
    252c:	2d 91       	ld	r18, X+
    252e:	3c 91       	ld	r19, X
    2530:	87 89       	ldd	r24, Z+23	; 0x17
    2532:	90 8d       	ldd	r25, Z+24	; 0x18
    2534:	82 17       	cp	r24, r18
    2536:	93 07       	cpc	r25, r19
    2538:	60 f0       	brcs	.+24     	; 0x2552 <vTaskSwitchContext+0x4a>
    253a:	60 91 c0 03 	lds	r22, 0x03C0	; 0x8003c0 <pxCurrentTCB>
    253e:	70 91 c1 03 	lds	r23, 0x03C1	; 0x8003c1 <pxCurrentTCB+0x1>
    2542:	80 91 c0 03 	lds	r24, 0x03C0	; 0x8003c0 <pxCurrentTCB>
    2546:	90 91 c1 03 	lds	r25, 0x03C1	; 0x8003c1 <pxCurrentTCB+0x1>
    254a:	67 5e       	subi	r22, 0xE7	; 231
    254c:	7f 4f       	sbci	r23, 0xFF	; 255
    254e:	0e 94 b2 16 	call	0x2d64	; 0x2d64 <vApplicationStackOverflowHook>
    2552:	80 91 66 03 	lds	r24, 0x0366	; 0x800366 <uxTopReadyPriority>
    2556:	69 e0       	ldi	r22, 0x09	; 9
    2558:	48 2f       	mov	r20, r24
    255a:	50 e0       	ldi	r21, 0x00	; 0
    255c:	64 9f       	mul	r22, r20
    255e:	90 01       	movw	r18, r0
    2560:	65 9f       	mul	r22, r21
    2562:	30 0d       	add	r19, r0
    2564:	11 24       	eor	r1, r1
    2566:	f9 01       	movw	r30, r18
    2568:	e4 56       	subi	r30, 0x64	; 100
    256a:	fc 4f       	sbci	r31, 0xFC	; 252
    256c:	90 81       	ld	r25, Z
    256e:	91 11       	cpse	r25, r1
    2570:	02 c0       	rjmp	.+4      	; 0x2576 <vTaskSwitchContext+0x6e>
    2572:	81 50       	subi	r24, 0x01	; 1
    2574:	f1 cf       	rjmp	.-30     	; 0x2558 <vTaskSwitchContext+0x50>
    2576:	a1 81       	ldd	r26, Z+1	; 0x01
    2578:	b2 81       	ldd	r27, Z+2	; 0x02
    257a:	12 96       	adiw	r26, 0x02	; 2
    257c:	0d 90       	ld	r0, X+
    257e:	bc 91       	ld	r27, X
    2580:	a0 2d       	mov	r26, r0
    2582:	b2 83       	std	Z+2, r27	; 0x02
    2584:	a1 83       	std	Z+1, r26	; 0x01
    2586:	21 56       	subi	r18, 0x61	; 97
    2588:	3c 4f       	sbci	r19, 0xFC	; 252
    258a:	a2 17       	cp	r26, r18
    258c:	b3 07       	cpc	r27, r19
    258e:	31 f4       	brne	.+12     	; 0x259c <vTaskSwitchContext+0x94>
    2590:	12 96       	adiw	r26, 0x02	; 2
    2592:	2d 91       	ld	r18, X+
    2594:	3c 91       	ld	r19, X
    2596:	13 97       	sbiw	r26, 0x03	; 3
    2598:	32 83       	std	Z+2, r19	; 0x02
    259a:	21 83       	std	Z+1, r18	; 0x01
    259c:	99 e0       	ldi	r25, 0x09	; 9
    259e:	94 9f       	mul	r25, r20
    25a0:	f0 01       	movw	r30, r0
    25a2:	95 9f       	mul	r25, r21
    25a4:	f0 0d       	add	r31, r0
    25a6:	11 24       	eor	r1, r1
    25a8:	e4 56       	subi	r30, 0x64	; 100
    25aa:	fc 4f       	sbci	r31, 0xFC	; 252
    25ac:	01 80       	ldd	r0, Z+1	; 0x01
    25ae:	f2 81       	ldd	r31, Z+2	; 0x02
    25b0:	e0 2d       	mov	r30, r0
    25b2:	26 81       	ldd	r18, Z+6	; 0x06
    25b4:	37 81       	ldd	r19, Z+7	; 0x07
    25b6:	30 93 c1 03 	sts	0x03C1, r19	; 0x8003c1 <pxCurrentTCB+0x1>
    25ba:	20 93 c0 03 	sts	0x03C0, r18	; 0x8003c0 <pxCurrentTCB>
    25be:	80 93 66 03 	sts	0x0366, r24	; 0x800366 <uxTopReadyPriority>
    25c2:	08 95       	ret

000025c4 <vTaskPlaceOnEventList>:
    25c4:	cf 93       	push	r28
    25c6:	df 93       	push	r29
    25c8:	eb 01       	movw	r28, r22
    25ca:	60 91 c0 03 	lds	r22, 0x03C0	; 0x8003c0 <pxCurrentTCB>
    25ce:	70 91 c1 03 	lds	r23, 0x03C1	; 0x8003c1 <pxCurrentTCB+0x1>
    25d2:	64 5f       	subi	r22, 0xF4	; 244
    25d4:	7f 4f       	sbci	r23, 0xFF	; 255
    25d6:	0e 94 b6 09 	call	0x136c	; 0x136c <vListInsert>
    25da:	61 e0       	ldi	r22, 0x01	; 1
    25dc:	ce 01       	movw	r24, r28
    25de:	df 91       	pop	r29
    25e0:	cf 91       	pop	r28
    25e2:	0c 94 ff 0e 	jmp	0x1dfe	; 0x1dfe <prvAddCurrentTaskToDelayedList>

000025e6 <vTaskPlaceOnEventListRestricted>:
    25e6:	1f 93       	push	r17
    25e8:	cf 93       	push	r28
    25ea:	df 93       	push	r29
    25ec:	eb 01       	movw	r28, r22
    25ee:	14 2f       	mov	r17, r20
    25f0:	60 91 c0 03 	lds	r22, 0x03C0	; 0x8003c0 <pxCurrentTCB>
    25f4:	70 91 c1 03 	lds	r23, 0x03C1	; 0x8003c1 <pxCurrentTCB+0x1>
    25f8:	64 5f       	subi	r22, 0xF4	; 244
    25fa:	7f 4f       	sbci	r23, 0xFF	; 255
    25fc:	0e 94 95 09 	call	0x132a	; 0x132a <vListInsertEnd>
    2600:	11 23       	and	r17, r17
    2602:	11 f0       	breq	.+4      	; 0x2608 <vTaskPlaceOnEventListRestricted+0x22>
    2604:	cf ef       	ldi	r28, 0xFF	; 255
    2606:	df ef       	ldi	r29, 0xFF	; 255
    2608:	61 2f       	mov	r22, r17
    260a:	ce 01       	movw	r24, r28
    260c:	df 91       	pop	r29
    260e:	cf 91       	pop	r28
    2610:	1f 91       	pop	r17
    2612:	0c 94 ff 0e 	jmp	0x1dfe	; 0x1dfe <prvAddCurrentTaskToDelayedList>

00002616 <xTaskRemoveFromEventList>:
    2616:	0f 93       	push	r16
    2618:	1f 93       	push	r17
    261a:	cf 93       	push	r28
    261c:	df 93       	push	r29
    261e:	dc 01       	movw	r26, r24
    2620:	15 96       	adiw	r26, 0x05	; 5
    2622:	ed 91       	ld	r30, X+
    2624:	fc 91       	ld	r31, X
    2626:	16 97       	sbiw	r26, 0x06	; 6
    2628:	c6 81       	ldd	r28, Z+6	; 0x06
    262a:	d7 81       	ldd	r29, Z+7	; 0x07
    262c:	8e 01       	movw	r16, r28
    262e:	04 5f       	subi	r16, 0xF4	; 244
    2630:	1f 4f       	sbci	r17, 0xFF	; 255
    2632:	c8 01       	movw	r24, r16
    2634:	0e 94 ee 09 	call	0x13dc	; 0x13dc <uxListRemove>
    2638:	80 91 5c 03 	lds	r24, 0x035C	; 0x80035c <uxSchedulerSuspended>
    263c:	81 11       	cpse	r24, r1
    263e:	14 c0       	rjmp	.+40     	; 0x2668 <xTaskRemoveFromEventList+0x52>
    2640:	0a 50       	subi	r16, 0x0A	; 10
    2642:	11 09       	sbc	r17, r1
    2644:	c8 01       	movw	r24, r16
    2646:	0e 94 ee 09 	call	0x13dc	; 0x13dc <uxListRemove>
    264a:	8e 89       	ldd	r24, Y+22	; 0x16
    264c:	90 91 66 03 	lds	r25, 0x0366	; 0x800366 <uxTopReadyPriority>
    2650:	98 17       	cp	r25, r24
    2652:	10 f4       	brcc	.+4      	; 0x2658 <xTaskRemoveFromEventList+0x42>
    2654:	80 93 66 03 	sts	0x0366, r24	; 0x800366 <uxTopReadyPriority>
    2658:	b9 e0       	ldi	r27, 0x09	; 9
    265a:	8b 9f       	mul	r24, r27
    265c:	c0 01       	movw	r24, r0
    265e:	11 24       	eor	r1, r1
    2660:	b8 01       	movw	r22, r16
    2662:	84 56       	subi	r24, 0x64	; 100
    2664:	9c 4f       	sbci	r25, 0xFC	; 252
    2666:	03 c0       	rjmp	.+6      	; 0x266e <xTaskRemoveFromEventList+0x58>
    2668:	b8 01       	movw	r22, r16
    266a:	8d e7       	ldi	r24, 0x7D	; 125
    266c:	93 e0       	ldi	r25, 0x03	; 3
    266e:	0e 94 95 09 	call	0x132a	; 0x132a <vListInsertEnd>
    2672:	e0 91 c0 03 	lds	r30, 0x03C0	; 0x8003c0 <pxCurrentTCB>
    2676:	f0 91 c1 03 	lds	r31, 0x03C1	; 0x8003c1 <pxCurrentTCB+0x1>
    267a:	9e 89       	ldd	r25, Y+22	; 0x16
    267c:	86 89       	ldd	r24, Z+22	; 0x16
    267e:	89 17       	cp	r24, r25
    2680:	20 f4       	brcc	.+8      	; 0x268a <xTaskRemoveFromEventList+0x74>
    2682:	81 e0       	ldi	r24, 0x01	; 1
    2684:	80 93 63 03 	sts	0x0363, r24	; 0x800363 <xYieldPending>
    2688:	01 c0       	rjmp	.+2      	; 0x268c <xTaskRemoveFromEventList+0x76>
    268a:	80 e0       	ldi	r24, 0x00	; 0
    268c:	df 91       	pop	r29
    268e:	cf 91       	pop	r28
    2690:	1f 91       	pop	r17
    2692:	0f 91       	pop	r16
    2694:	08 95       	ret

00002696 <vTaskInternalSetTimeOutState>:
    2696:	20 91 62 03 	lds	r18, 0x0362	; 0x800362 <xNumOfOverflows>
    269a:	fc 01       	movw	r30, r24
    269c:	20 83       	st	Z, r18
    269e:	20 91 67 03 	lds	r18, 0x0367	; 0x800367 <xTickCount>
    26a2:	30 91 68 03 	lds	r19, 0x0368	; 0x800368 <xTickCount+0x1>
    26a6:	32 83       	std	Z+2, r19	; 0x02
    26a8:	21 83       	std	Z+1, r18	; 0x01
    26aa:	08 95       	ret

000026ac <xTaskCheckForTimeOut>:
    26ac:	cf 93       	push	r28
    26ae:	df 93       	push	r29
    26b0:	0f b6       	in	r0, 0x3f	; 63
    26b2:	f8 94       	cli
    26b4:	0f 92       	push	r0
    26b6:	40 91 67 03 	lds	r20, 0x0367	; 0x800367 <xTickCount>
    26ba:	50 91 68 03 	lds	r21, 0x0368	; 0x800368 <xTickCount+0x1>
    26be:	db 01       	movw	r26, r22
    26c0:	2d 91       	ld	r18, X+
    26c2:	3c 91       	ld	r19, X
    26c4:	2f 3f       	cpi	r18, 0xFF	; 255
    26c6:	bf ef       	ldi	r27, 0xFF	; 255
    26c8:	3b 07       	cpc	r19, r27
    26ca:	d9 f0       	breq	.+54     	; 0x2702 <xTaskCheckForTimeOut+0x56>
    26cc:	ec 01       	movw	r28, r24
    26ce:	e9 81       	ldd	r30, Y+1	; 0x01
    26d0:	fa 81       	ldd	r31, Y+2	; 0x02
    26d2:	a0 91 62 03 	lds	r26, 0x0362	; 0x800362 <xNumOfOverflows>
    26d6:	b8 81       	ld	r27, Y
    26d8:	ba 17       	cp	r27, r26
    26da:	19 f0       	breq	.+6      	; 0x26e2 <xTaskCheckForTimeOut+0x36>
    26dc:	4e 17       	cp	r20, r30
    26de:	5f 07       	cpc	r21, r31
    26e0:	90 f4       	brcc	.+36     	; 0x2706 <xTaskCheckForTimeOut+0x5a>
    26e2:	4e 1b       	sub	r20, r30
    26e4:	5f 0b       	sbc	r21, r31
    26e6:	fb 01       	movw	r30, r22
    26e8:	42 17       	cp	r20, r18
    26ea:	53 07       	cpc	r21, r19
    26ec:	38 f4       	brcc	.+14     	; 0x26fc <xTaskCheckForTimeOut+0x50>
    26ee:	24 1b       	sub	r18, r20
    26f0:	35 0b       	sbc	r19, r21
    26f2:	31 83       	std	Z+1, r19	; 0x01
    26f4:	20 83       	st	Z, r18
    26f6:	0e 94 4b 13 	call	0x2696	; 0x2696 <vTaskInternalSetTimeOutState>
    26fa:	03 c0       	rjmp	.+6      	; 0x2702 <xTaskCheckForTimeOut+0x56>
    26fc:	11 82       	std	Z+1, r1	; 0x01
    26fe:	10 82       	st	Z, r1
    2700:	02 c0       	rjmp	.+4      	; 0x2706 <xTaskCheckForTimeOut+0x5a>
    2702:	80 e0       	ldi	r24, 0x00	; 0
    2704:	01 c0       	rjmp	.+2      	; 0x2708 <xTaskCheckForTimeOut+0x5c>
    2706:	81 e0       	ldi	r24, 0x01	; 1
    2708:	0f 90       	pop	r0
    270a:	0f be       	out	0x3f, r0	; 63
    270c:	df 91       	pop	r29
    270e:	cf 91       	pop	r28
    2710:	08 95       	ret

00002712 <vTaskMissedYield>:
    2712:	81 e0       	ldi	r24, 0x01	; 1
    2714:	80 93 63 03 	sts	0x0363, r24	; 0x800363 <xYieldPending>
    2718:	08 95       	ret

0000271a <xTaskGetSchedulerState>:
    271a:	80 91 65 03 	lds	r24, 0x0365	; 0x800365 <xSchedulerRunning>
    271e:	88 23       	and	r24, r24
    2720:	31 f0       	breq	.+12     	; 0x272e <xTaskGetSchedulerState+0x14>
    2722:	80 91 5c 03 	lds	r24, 0x035C	; 0x80035c <uxSchedulerSuspended>
    2726:	88 23       	and	r24, r24
    2728:	21 f0       	breq	.+8      	; 0x2732 <xTaskGetSchedulerState+0x18>
    272a:	80 e0       	ldi	r24, 0x00	; 0
    272c:	08 95       	ret
    272e:	81 e0       	ldi	r24, 0x01	; 1
    2730:	08 95       	ret
    2732:	82 e0       	ldi	r24, 0x02	; 2
    2734:	08 95       	ret

00002736 <xTaskPriorityInherit>:
    2736:	0f 93       	push	r16
    2738:	1f 93       	push	r17
    273a:	cf 93       	push	r28
    273c:	df 93       	push	r29
    273e:	fc 01       	movw	r30, r24
    2740:	89 2b       	or	r24, r25
    2742:	09 f4       	brne	.+2      	; 0x2746 <xTaskPriorityInherit+0x10>
    2744:	55 c0       	rjmp	.+170    	; 0x27f0 <xTaskPriorityInherit+0xba>
    2746:	86 89       	ldd	r24, Z+22	; 0x16
    2748:	a0 91 c0 03 	lds	r26, 0x03C0	; 0x8003c0 <pxCurrentTCB>
    274c:	b0 91 c1 03 	lds	r27, 0x03C1	; 0x8003c1 <pxCurrentTCB+0x1>
    2750:	56 96       	adiw	r26, 0x16	; 22
    2752:	9c 91       	ld	r25, X
    2754:	89 17       	cp	r24, r25
    2756:	08 f0       	brcs	.+2      	; 0x275a <xTaskPriorityInherit+0x24>
    2758:	41 c0       	rjmp	.+130    	; 0x27dc <xTaskPriorityInherit+0xa6>
    275a:	24 85       	ldd	r18, Z+12	; 0x0c
    275c:	35 85       	ldd	r19, Z+13	; 0x0d
    275e:	37 fd       	sbrc	r19, 7
    2760:	0c c0       	rjmp	.+24     	; 0x277a <xTaskPriorityInherit+0x44>
    2762:	a0 91 c0 03 	lds	r26, 0x03C0	; 0x8003c0 <pxCurrentTCB>
    2766:	b0 91 c1 03 	lds	r27, 0x03C1	; 0x8003c1 <pxCurrentTCB+0x1>
    276a:	56 96       	adiw	r26, 0x16	; 22
    276c:	9c 91       	ld	r25, X
    276e:	24 e0       	ldi	r18, 0x04	; 4
    2770:	30 e0       	ldi	r19, 0x00	; 0
    2772:	29 1b       	sub	r18, r25
    2774:	31 09       	sbc	r19, r1
    2776:	35 87       	std	Z+13, r19	; 0x0d
    2778:	24 87       	std	Z+12, r18	; 0x0c
    277a:	29 e0       	ldi	r18, 0x09	; 9
    277c:	82 9f       	mul	r24, r18
    277e:	c0 01       	movw	r24, r0
    2780:	11 24       	eor	r1, r1
    2782:	84 56       	subi	r24, 0x64	; 100
    2784:	9c 4f       	sbci	r25, 0xFC	; 252
    2786:	22 85       	ldd	r18, Z+10	; 0x0a
    2788:	33 85       	ldd	r19, Z+11	; 0x0b
    278a:	28 17       	cp	r18, r24
    278c:	39 07       	cpc	r19, r25
    278e:	e9 f4       	brne	.+58     	; 0x27ca <xTaskPriorityInherit+0x94>
    2790:	8f 01       	movw	r16, r30
    2792:	ef 01       	movw	r28, r30
    2794:	22 96       	adiw	r28, 0x02	; 2
    2796:	ce 01       	movw	r24, r28
    2798:	0e 94 ee 09 	call	0x13dc	; 0x13dc <uxListRemove>
    279c:	e0 91 c0 03 	lds	r30, 0x03C0	; 0x8003c0 <pxCurrentTCB>
    27a0:	f0 91 c1 03 	lds	r31, 0x03C1	; 0x8003c1 <pxCurrentTCB+0x1>
    27a4:	86 89       	ldd	r24, Z+22	; 0x16
    27a6:	f8 01       	movw	r30, r16
    27a8:	86 8b       	std	Z+22, r24	; 0x16
    27aa:	90 91 66 03 	lds	r25, 0x0366	; 0x800366 <uxTopReadyPriority>
    27ae:	98 17       	cp	r25, r24
    27b0:	10 f4       	brcc	.+4      	; 0x27b6 <xTaskPriorityInherit+0x80>
    27b2:	80 93 66 03 	sts	0x0366, r24	; 0x800366 <uxTopReadyPriority>
    27b6:	f9 e0       	ldi	r31, 0x09	; 9
    27b8:	8f 9f       	mul	r24, r31
    27ba:	c0 01       	movw	r24, r0
    27bc:	11 24       	eor	r1, r1
    27be:	be 01       	movw	r22, r28
    27c0:	84 56       	subi	r24, 0x64	; 100
    27c2:	9c 4f       	sbci	r25, 0xFC	; 252
    27c4:	0e 94 95 09 	call	0x132a	; 0x132a <vListInsertEnd>
    27c8:	07 c0       	rjmp	.+14     	; 0x27d8 <xTaskPriorityInherit+0xa2>
    27ca:	a0 91 c0 03 	lds	r26, 0x03C0	; 0x8003c0 <pxCurrentTCB>
    27ce:	b0 91 c1 03 	lds	r27, 0x03C1	; 0x8003c1 <pxCurrentTCB+0x1>
    27d2:	56 96       	adiw	r26, 0x16	; 22
    27d4:	8c 91       	ld	r24, X
    27d6:	86 8b       	std	Z+22, r24	; 0x16
    27d8:	81 e0       	ldi	r24, 0x01	; 1
    27da:	0b c0       	rjmp	.+22     	; 0x27f2 <xTaskPriorityInherit+0xbc>
    27dc:	a0 91 c0 03 	lds	r26, 0x03C0	; 0x8003c0 <pxCurrentTCB>
    27e0:	b0 91 c1 03 	lds	r27, 0x03C1	; 0x8003c1 <pxCurrentTCB+0x1>
    27e4:	81 e0       	ldi	r24, 0x01	; 1
    27e6:	21 a1       	ldd	r18, Z+33	; 0x21
    27e8:	56 96       	adiw	r26, 0x16	; 22
    27ea:	9c 91       	ld	r25, X
    27ec:	29 17       	cp	r18, r25
    27ee:	08 f0       	brcs	.+2      	; 0x27f2 <xTaskPriorityInherit+0xbc>
    27f0:	80 e0       	ldi	r24, 0x00	; 0
    27f2:	df 91       	pop	r29
    27f4:	cf 91       	pop	r28
    27f6:	1f 91       	pop	r17
    27f8:	0f 91       	pop	r16
    27fa:	08 95       	ret

000027fc <xTaskPriorityDisinherit>:
    27fc:	0f 93       	push	r16
    27fe:	1f 93       	push	r17
    2800:	cf 93       	push	r28
    2802:	df 93       	push	r29
    2804:	fc 01       	movw	r30, r24
    2806:	89 2b       	or	r24, r25
    2808:	11 f4       	brne	.+4      	; 0x280e <xTaskPriorityDisinherit+0x12>
    280a:	80 e0       	ldi	r24, 0x00	; 0
    280c:	2c c0       	rjmp	.+88     	; 0x2866 <xTaskPriorityDisinherit+0x6a>
    280e:	82 a1       	ldd	r24, Z+34	; 0x22
    2810:	81 50       	subi	r24, 0x01	; 1
    2812:	82 a3       	std	Z+34, r24	; 0x22
    2814:	26 89       	ldd	r18, Z+22	; 0x16
    2816:	91 a1       	ldd	r25, Z+33	; 0x21
    2818:	29 17       	cp	r18, r25
    281a:	b9 f3       	breq	.-18     	; 0x280a <xTaskPriorityDisinherit+0xe>
    281c:	81 11       	cpse	r24, r1
    281e:	f5 cf       	rjmp	.-22     	; 0x280a <xTaskPriorityDisinherit+0xe>
    2820:	ef 01       	movw	r28, r30
    2822:	8f 01       	movw	r16, r30
    2824:	0e 5f       	subi	r16, 0xFE	; 254
    2826:	1f 4f       	sbci	r17, 0xFF	; 255
    2828:	c8 01       	movw	r24, r16
    282a:	0e 94 ee 09 	call	0x13dc	; 0x13dc <uxListRemove>
    282e:	89 a1       	ldd	r24, Y+33	; 0x21
    2830:	8e 8b       	std	Y+22, r24	; 0x16
    2832:	48 2f       	mov	r20, r24
    2834:	50 e0       	ldi	r21, 0x00	; 0
    2836:	24 e0       	ldi	r18, 0x04	; 4
    2838:	30 e0       	ldi	r19, 0x00	; 0
    283a:	24 1b       	sub	r18, r20
    283c:	35 0b       	sbc	r19, r21
    283e:	3d 87       	std	Y+13, r19	; 0x0d
    2840:	2c 87       	std	Y+12, r18	; 0x0c
    2842:	90 91 66 03 	lds	r25, 0x0366	; 0x800366 <uxTopReadyPriority>
    2846:	98 17       	cp	r25, r24
    2848:	10 f4       	brcc	.+4      	; 0x284e <xTaskPriorityDisinherit+0x52>
    284a:	80 93 66 03 	sts	0x0366, r24	; 0x800366 <uxTopReadyPriority>
    284e:	29 e0       	ldi	r18, 0x09	; 9
    2850:	24 9f       	mul	r18, r20
    2852:	c0 01       	movw	r24, r0
    2854:	25 9f       	mul	r18, r21
    2856:	90 0d       	add	r25, r0
    2858:	11 24       	eor	r1, r1
    285a:	b8 01       	movw	r22, r16
    285c:	84 56       	subi	r24, 0x64	; 100
    285e:	9c 4f       	sbci	r25, 0xFC	; 252
    2860:	0e 94 95 09 	call	0x132a	; 0x132a <vListInsertEnd>
    2864:	81 e0       	ldi	r24, 0x01	; 1
    2866:	df 91       	pop	r29
    2868:	cf 91       	pop	r28
    286a:	1f 91       	pop	r17
    286c:	0f 91       	pop	r16
    286e:	08 95       	ret

00002870 <vTaskPriorityDisinheritAfterTimeout>:
    2870:	0f 93       	push	r16
    2872:	1f 93       	push	r17
    2874:	cf 93       	push	r28
    2876:	df 93       	push	r29
    2878:	fc 01       	movw	r30, r24
    287a:	89 2b       	or	r24, r25
    287c:	d9 f1       	breq	.+118    	; 0x28f4 <vTaskPriorityDisinheritAfterTimeout+0x84>
    287e:	91 a1       	ldd	r25, Z+33	; 0x21
    2880:	96 17       	cp	r25, r22
    2882:	08 f4       	brcc	.+2      	; 0x2886 <vTaskPriorityDisinheritAfterTimeout+0x16>
    2884:	96 2f       	mov	r25, r22
    2886:	86 89       	ldd	r24, Z+22	; 0x16
    2888:	89 17       	cp	r24, r25
    288a:	a1 f1       	breq	.+104    	; 0x28f4 <vTaskPriorityDisinheritAfterTimeout+0x84>
    288c:	22 a1       	ldd	r18, Z+34	; 0x22
    288e:	21 30       	cpi	r18, 0x01	; 1
    2890:	89 f5       	brne	.+98     	; 0x28f4 <vTaskPriorityDisinheritAfterTimeout+0x84>
    2892:	96 8b       	std	Z+22, r25	; 0x16
    2894:	24 85       	ldd	r18, Z+12	; 0x0c
    2896:	35 85       	ldd	r19, Z+13	; 0x0d
    2898:	37 fd       	sbrc	r19, 7
    289a:	06 c0       	rjmp	.+12     	; 0x28a8 <vTaskPriorityDisinheritAfterTimeout+0x38>
    289c:	24 e0       	ldi	r18, 0x04	; 4
    289e:	30 e0       	ldi	r19, 0x00	; 0
    28a0:	29 1b       	sub	r18, r25
    28a2:	31 09       	sbc	r19, r1
    28a4:	35 87       	std	Z+13, r19	; 0x0d
    28a6:	24 87       	std	Z+12, r18	; 0x0c
    28a8:	29 e0       	ldi	r18, 0x09	; 9
    28aa:	82 9f       	mul	r24, r18
    28ac:	c0 01       	movw	r24, r0
    28ae:	11 24       	eor	r1, r1
    28b0:	84 56       	subi	r24, 0x64	; 100
    28b2:	9c 4f       	sbci	r25, 0xFC	; 252
    28b4:	22 85       	ldd	r18, Z+10	; 0x0a
    28b6:	33 85       	ldd	r19, Z+11	; 0x0b
    28b8:	28 17       	cp	r18, r24
    28ba:	39 07       	cpc	r19, r25
    28bc:	d9 f4       	brne	.+54     	; 0x28f4 <vTaskPriorityDisinheritAfterTimeout+0x84>
    28be:	ef 01       	movw	r28, r30
    28c0:	8f 01       	movw	r16, r30
    28c2:	0e 5f       	subi	r16, 0xFE	; 254
    28c4:	1f 4f       	sbci	r17, 0xFF	; 255
    28c6:	c8 01       	movw	r24, r16
    28c8:	0e 94 ee 09 	call	0x13dc	; 0x13dc <uxListRemove>
    28cc:	8e 89       	ldd	r24, Y+22	; 0x16
    28ce:	90 91 66 03 	lds	r25, 0x0366	; 0x800366 <uxTopReadyPriority>
    28d2:	98 17       	cp	r25, r24
    28d4:	10 f4       	brcc	.+4      	; 0x28da <vTaskPriorityDisinheritAfterTimeout+0x6a>
    28d6:	80 93 66 03 	sts	0x0366, r24	; 0x800366 <uxTopReadyPriority>
    28da:	29 e0       	ldi	r18, 0x09	; 9
    28dc:	82 9f       	mul	r24, r18
    28de:	c0 01       	movw	r24, r0
    28e0:	11 24       	eor	r1, r1
    28e2:	b8 01       	movw	r22, r16
    28e4:	84 56       	subi	r24, 0x64	; 100
    28e6:	9c 4f       	sbci	r25, 0xFC	; 252
    28e8:	df 91       	pop	r29
    28ea:	cf 91       	pop	r28
    28ec:	1f 91       	pop	r17
    28ee:	0f 91       	pop	r16
    28f0:	0c 94 95 09 	jmp	0x132a	; 0x132a <vListInsertEnd>
    28f4:	df 91       	pop	r29
    28f6:	cf 91       	pop	r28
    28f8:	1f 91       	pop	r17
    28fa:	0f 91       	pop	r16
    28fc:	08 95       	ret

000028fe <pvTaskIncrementMutexHeldCount>:

    TaskHandle_t pvTaskIncrementMutexHeldCount( void )
    {
        /* If xSemaphoreCreateMutex() is called before any tasks have been created
        then pxCurrentTCB will be NULL. */
        if( pxCurrentTCB != NULL )
    28fe:	80 91 c0 03 	lds	r24, 0x03C0	; 0x8003c0 <pxCurrentTCB>
    2902:	90 91 c1 03 	lds	r25, 0x03C1	; 0x8003c1 <pxCurrentTCB+0x1>
    2906:	89 2b       	or	r24, r25
    2908:	39 f0       	breq	.+14     	; 0x2918 <pvTaskIncrementMutexHeldCount+0x1a>
        {
            ( pxCurrentTCB->uxMutexesHeld )++;
    290a:	e0 91 c0 03 	lds	r30, 0x03C0	; 0x8003c0 <pxCurrentTCB>
    290e:	f0 91 c1 03 	lds	r31, 0x03C1	; 0x8003c1 <pxCurrentTCB+0x1>
    2912:	82 a1       	ldd	r24, Z+34	; 0x22
    2914:	8f 5f       	subi	r24, 0xFF	; 255
    2916:	82 a3       	std	Z+34, r24	; 0x22
        }

        return pxCurrentTCB;
    2918:	80 91 c0 03 	lds	r24, 0x03C0	; 0x8003c0 <pxCurrentTCB>
    291c:	90 91 c1 03 	lds	r25, 0x03C1	; 0x8003c1 <pxCurrentTCB+0x1>
    }
    2920:	08 95       	ret

00002922 <prvCheckForValidListAndQueue>:
            pxNewTimer->ucStatus = 0x00;
            prvInitialiseNewTimer( pcTimerName, xTimerPeriodInTicks, uxAutoReload, pvTimerID, pxCallbackFunction, pxNewTimer );
        }

        return pxNewTimer;
    }
    2922:	0f b6       	in	r0, 0x3f	; 63
    2924:	f8 94       	cli
    2926:	0f 92       	push	r0
    2928:	80 91 c6 03 	lds	r24, 0x03C6	; 0x8003c6 <xTimerQueue>
    292c:	90 91 c7 03 	lds	r25, 0x03C7	; 0x8003c7 <xTimerQueue+0x1>
    2930:	89 2b       	or	r24, r25
    2932:	e9 f4       	brne	.+58     	; 0x296e <prvCheckForValidListAndQueue+0x4c>
    2934:	85 ed       	ldi	r24, 0xD5	; 213
    2936:	93 e0       	ldi	r25, 0x03	; 3
    2938:	0e 94 83 09 	call	0x1306	; 0x1306 <vListInitialise>
    293c:	8c ec       	ldi	r24, 0xCC	; 204
    293e:	93 e0       	ldi	r25, 0x03	; 3
    2940:	0e 94 83 09 	call	0x1306	; 0x1306 <vListInitialise>
    2944:	85 ed       	ldi	r24, 0xD5	; 213
    2946:	93 e0       	ldi	r25, 0x03	; 3
    2948:	90 93 cb 03 	sts	0x03CB, r25	; 0x8003cb <pxCurrentTimerList+0x1>
    294c:	80 93 ca 03 	sts	0x03CA, r24	; 0x8003ca <pxCurrentTimerList>
    2950:	8c ec       	ldi	r24, 0xCC	; 204
    2952:	93 e0       	ldi	r25, 0x03	; 3
    2954:	90 93 c9 03 	sts	0x03C9, r25	; 0x8003c9 <pxOverflowTimerList+0x1>
    2958:	80 93 c8 03 	sts	0x03C8, r24	; 0x8003c8 <pxOverflowTimerList>
    295c:	40 e0       	ldi	r20, 0x00	; 0
    295e:	65 e0       	ldi	r22, 0x05	; 5
    2960:	8a e0       	ldi	r24, 0x0A	; 10
    2962:	0e 94 64 0c 	call	0x18c8	; 0x18c8 <xQueueGenericCreate>
    2966:	90 93 c7 03 	sts	0x03C7, r25	; 0x8003c7 <xTimerQueue+0x1>
    296a:	80 93 c6 03 	sts	0x03C6, r24	; 0x8003c6 <xTimerQueue>
    296e:	0f 90       	pop	r0
    2970:	0f be       	out	0x3f, r0	; 63
    2972:	08 95       	ret

00002974 <prvInsertTimerInActiveList>:
    2974:	fc 01       	movw	r30, r24
    2976:	73 83       	std	Z+3, r23	; 0x03
    2978:	62 83       	std	Z+2, r22	; 0x02
    297a:	91 87       	std	Z+9, r25	; 0x09
    297c:	80 87       	std	Z+8, r24	; 0x08
    297e:	46 17       	cp	r20, r22
    2980:	57 07       	cpc	r21, r23
    2982:	78 f0       	brcs	.+30     	; 0x29a2 <prvInsertTimerInActiveList+0x2e>
    2984:	42 1b       	sub	r20, r18
    2986:	53 0b       	sbc	r21, r19
    2988:	84 85       	ldd	r24, Z+12	; 0x0c
    298a:	95 85       	ldd	r25, Z+13	; 0x0d
    298c:	48 17       	cp	r20, r24
    298e:	59 07       	cpc	r21, r25
    2990:	c8 f4       	brcc	.+50     	; 0x29c4 <prvInsertTimerInActiveList+0x50>
    2992:	bf 01       	movw	r22, r30
    2994:	6e 5f       	subi	r22, 0xFE	; 254
    2996:	7f 4f       	sbci	r23, 0xFF	; 255
    2998:	80 91 c8 03 	lds	r24, 0x03C8	; 0x8003c8 <pxOverflowTimerList>
    299c:	90 91 c9 03 	lds	r25, 0x03C9	; 0x8003c9 <pxOverflowTimerList+0x1>
    29a0:	0d c0       	rjmp	.+26     	; 0x29bc <prvInsertTimerInActiveList+0x48>
    29a2:	42 17       	cp	r20, r18
    29a4:	53 07       	cpc	r21, r19
    29a6:	18 f4       	brcc	.+6      	; 0x29ae <prvInsertTimerInActiveList+0x3a>
    29a8:	62 17       	cp	r22, r18
    29aa:	73 07       	cpc	r23, r19
    29ac:	58 f4       	brcc	.+22     	; 0x29c4 <prvInsertTimerInActiveList+0x50>
    29ae:	bf 01       	movw	r22, r30
    29b0:	6e 5f       	subi	r22, 0xFE	; 254
    29b2:	7f 4f       	sbci	r23, 0xFF	; 255
    29b4:	80 91 ca 03 	lds	r24, 0x03CA	; 0x8003ca <pxCurrentTimerList>
    29b8:	90 91 cb 03 	lds	r25, 0x03CB	; 0x8003cb <pxCurrentTimerList+0x1>
    29bc:	0e 94 b6 09 	call	0x136c	; 0x136c <vListInsert>
    29c0:	80 e0       	ldi	r24, 0x00	; 0
    29c2:	08 95       	ret
    29c4:	81 e0       	ldi	r24, 0x01	; 1
    29c6:	08 95       	ret

000029c8 <xTimerCreateTimerTask>:
    29c8:	ef 92       	push	r14
    29ca:	ff 92       	push	r15
    29cc:	0f 93       	push	r16
    29ce:	0e 94 91 14 	call	0x2922	; 0x2922 <prvCheckForValidListAndQueue>
    29d2:	80 91 c6 03 	lds	r24, 0x03C6	; 0x8003c6 <xTimerQueue>
    29d6:	90 91 c7 03 	lds	r25, 0x03C7	; 0x8003c7 <xTimerQueue+0x1>
    29da:	89 2b       	or	r24, r25
    29dc:	81 f0       	breq	.+32     	; 0x29fe <xTimerCreateTimerTask+0x36>
    29de:	84 ec       	ldi	r24, 0xC4	; 196
    29e0:	e8 2e       	mov	r14, r24
    29e2:	83 e0       	ldi	r24, 0x03	; 3
    29e4:	f8 2e       	mov	r15, r24
    29e6:	03 e0       	ldi	r16, 0x03	; 3
    29e8:	20 e0       	ldi	r18, 0x00	; 0
    29ea:	30 e0       	ldi	r19, 0x00	; 0
    29ec:	45 e5       	ldi	r20, 0x55	; 85
    29ee:	50 e0       	ldi	r21, 0x00	; 0
    29f0:	68 ed       	ldi	r22, 0xD8	; 216
    29f2:	71 e0       	ldi	r23, 0x01	; 1
    29f4:	84 e9       	ldi	r24, 0x94	; 148
    29f6:	95 e1       	ldi	r25, 0x15	; 21
    29f8:	0e 94 89 0f 	call	0x1f12	; 0x1f12 <xTaskCreate>
    29fc:	01 c0       	rjmp	.+2      	; 0x2a00 <xTimerCreateTimerTask+0x38>
    29fe:	80 e0       	ldi	r24, 0x00	; 0
    2a00:	0f 91       	pop	r16
    2a02:	ff 90       	pop	r15
    2a04:	ef 90       	pop	r14
    2a06:	08 95       	ret

00002a08 <xTimerGenericCommand>:
    }
}
/*-----------------------------------------------------------*/

BaseType_t xTimerGenericCommand( TimerHandle_t xTimer, const BaseType_t xCommandID, const TickType_t xOptionalValue, BaseType_t * const pxHigherPriorityTaskWoken, const TickType_t xTicksToWait )
{
    2a08:	0f 93       	push	r16
    2a0a:	1f 93       	push	r17
    2a0c:	cf 93       	push	r28
    2a0e:	df 93       	push	r29
    2a10:	00 d0       	rcall	.+0      	; 0x2a12 <xTimerGenericCommand+0xa>
    2a12:	00 d0       	rcall	.+0      	; 0x2a14 <xTimerGenericCommand+0xc>
    2a14:	1f 92       	push	r1
    2a16:	cd b7       	in	r28, 0x3d	; 61
    2a18:	de b7       	in	r29, 0x3e	; 62

    configASSERT( xTimer );

    /* Send a message to the timer service task to perform a particular action
    on a particular timer definition. */
    if( xTimerQueue != NULL )
    2a1a:	a0 91 c6 03 	lds	r26, 0x03C6	; 0x8003c6 <xTimerQueue>
    2a1e:	b0 91 c7 03 	lds	r27, 0x03C7	; 0x8003c7 <xTimerQueue+0x1>
    2a22:	10 97       	sbiw	r26, 0x00	; 0
    2a24:	29 f1       	breq	.+74     	; 0x2a70 <xTimerGenericCommand+0x68>
    2a26:	f9 01       	movw	r30, r18
    {
        /* Send a command to the timer service task to start the xTimer timer. */
        xMessage.xMessageID = xCommandID;
    2a28:	69 83       	std	Y+1, r22	; 0x01
        xMessage.u.xTimerParameters.xMessageValue = xOptionalValue;
    2a2a:	5b 83       	std	Y+3, r21	; 0x03
    2a2c:	4a 83       	std	Y+2, r20	; 0x02
        xMessage.u.xTimerParameters.pxTimer = xTimer;
    2a2e:	9d 83       	std	Y+5, r25	; 0x05
    2a30:	8c 83       	std	Y+4, r24	; 0x04

        if( xCommandID < tmrFIRST_FROM_ISR_COMMAND )
    2a32:	66 30       	cpi	r22, 0x06	; 6
    2a34:	a4 f4       	brge	.+40     	; 0x2a5e <xTimerGenericCommand+0x56>
        {
            if( xTaskGetSchedulerState() == taskSCHEDULER_RUNNING )
    2a36:	0e 94 8d 13 	call	0x271a	; 0x271a <xTaskGetSchedulerState>
    2a3a:	e0 91 c6 03 	lds	r30, 0x03C6	; 0x8003c6 <xTimerQueue>
    2a3e:	f0 91 c7 03 	lds	r31, 0x03C7	; 0x8003c7 <xTimerQueue+0x1>
            {
                xReturn = xQueueSendToBack( xTimerQueue, &xMessage, xTicksToWait );
    2a42:	20 e0       	ldi	r18, 0x00	; 0
        xMessage.u.xTimerParameters.xMessageValue = xOptionalValue;
        xMessage.u.xTimerParameters.pxTimer = xTimer;

        if( xCommandID < tmrFIRST_FROM_ISR_COMMAND )
        {
            if( xTaskGetSchedulerState() == taskSCHEDULER_RUNNING )
    2a44:	82 30       	cpi	r24, 0x02	; 2
    2a46:	11 f4       	brne	.+4      	; 0x2a4c <xTimerGenericCommand+0x44>
            {
                xReturn = xQueueSendToBack( xTimerQueue, &xMessage, xTicksToWait );
    2a48:	a8 01       	movw	r20, r16
    2a4a:	02 c0       	rjmp	.+4      	; 0x2a50 <xTimerGenericCommand+0x48>
            }
            else
            {
                xReturn = xQueueSendToBack( xTimerQueue, &xMessage, tmrNO_DELAY );
    2a4c:	40 e0       	ldi	r20, 0x00	; 0
    2a4e:	50 e0       	ldi	r21, 0x00	; 0
    2a50:	be 01       	movw	r22, r28
    2a52:	6f 5f       	subi	r22, 0xFF	; 255
    2a54:	7f 4f       	sbci	r23, 0xFF	; 255
    2a56:	cf 01       	movw	r24, r30
    2a58:	0e 94 8c 0c 	call	0x1918	; 0x1918 <xQueueGenericSend>
    2a5c:	0a c0       	rjmp	.+20     	; 0x2a72 <xTimerGenericCommand+0x6a>
            }
        }
        else
        {
            xReturn = xQueueSendToBackFromISR( xTimerQueue, &xMessage, pxHigherPriorityTaskWoken );
    2a5e:	20 e0       	ldi	r18, 0x00	; 0
    2a60:	af 01       	movw	r20, r30
    2a62:	be 01       	movw	r22, r28
    2a64:	6f 5f       	subi	r22, 0xFF	; 255
    2a66:	7f 4f       	sbci	r23, 0xFF	; 255
    2a68:	cd 01       	movw	r24, r26
    2a6a:	0e 94 22 0d 	call	0x1a44	; 0x1a44 <xQueueGenericSendFromISR>
    2a6e:	01 c0       	rjmp	.+2      	; 0x2a72 <xTimerGenericCommand+0x6a>
}
/*-----------------------------------------------------------*/

BaseType_t xTimerGenericCommand( TimerHandle_t xTimer, const BaseType_t xCommandID, const TickType_t xOptionalValue, BaseType_t * const pxHigherPriorityTaskWoken, const TickType_t xTicksToWait )
{
BaseType_t xReturn = pdFAIL;
    2a70:	80 e0       	ldi	r24, 0x00	; 0
    {
        mtCOVERAGE_TEST_MARKER();
    }

    return xReturn;
}
    2a72:	0f 90       	pop	r0
    2a74:	0f 90       	pop	r0
    2a76:	0f 90       	pop	r0
    2a78:	0f 90       	pop	r0
    2a7a:	0f 90       	pop	r0
    2a7c:	df 91       	pop	r29
    2a7e:	cf 91       	pop	r28
    2a80:	1f 91       	pop	r17
    2a82:	0f 91       	pop	r16
    2a84:	08 95       	ret

00002a86 <prvSwitchTimerLists>:
    }
}
/*-----------------------------------------------------------*/

static void prvSwitchTimerLists( void )
{
    2a86:	ef 92       	push	r14
    2a88:	ff 92       	push	r15
    2a8a:	0f 93       	push	r16
    2a8c:	1f 93       	push	r17
    2a8e:	cf 93       	push	r28
    2a90:	df 93       	push	r29

    /* The tick count has overflowed.  The timer lists must be switched.
    If there are any timers still referenced from the current timer list
    then they must have expired and should be processed before the lists
    are switched. */
    while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
    2a92:	e0 91 ca 03 	lds	r30, 0x03CA	; 0x8003ca <pxCurrentTimerList>
    2a96:	f0 91 cb 03 	lds	r31, 0x03CB	; 0x8003cb <pxCurrentTimerList+0x1>
    2a9a:	80 81       	ld	r24, Z
    2a9c:	88 23       	and	r24, r24
    2a9e:	89 f1       	breq	.+98     	; 0x2b02 <prvSwitchTimerLists+0x7c>
    {
        xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
    2aa0:	05 80       	ldd	r0, Z+5	; 0x05
    2aa2:	f6 81       	ldd	r31, Z+6	; 0x06
    2aa4:	e0 2d       	mov	r30, r0
    2aa6:	e0 80       	ld	r14, Z
    2aa8:	f1 80       	ldd	r15, Z+1	; 0x01

        /* Remove the timer from the list. */
        pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList ); /*lint !e9087 !e9079 void * is used as this macro is used with tasks and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    2aaa:	c6 81       	ldd	r28, Z+6	; 0x06
    2aac:	d7 81       	ldd	r29, Z+7	; 0x07
        ( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
    2aae:	8e 01       	movw	r16, r28
    2ab0:	0e 5f       	subi	r16, 0xFE	; 254
    2ab2:	1f 4f       	sbci	r17, 0xFF	; 255
    2ab4:	c8 01       	movw	r24, r16
    2ab6:	0e 94 ee 09 	call	0x13dc	; 0x13dc <uxListRemove>
        traceTIMER_EXPIRED( pxTimer );

        /* Execute its callback, then send a command to restart the timer if
        it is an auto-reload timer.  It cannot be restarted here as the lists
        have not yet been switched. */
        pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
    2aba:	e8 89       	ldd	r30, Y+16	; 0x10
    2abc:	f9 89       	ldd	r31, Y+17	; 0x11
    2abe:	ce 01       	movw	r24, r28
    2ac0:	09 95       	icall

        if( ( pxTimer->ucStatus & tmrSTATUS_IS_AUTORELOAD ) != 0 )
    2ac2:	8a 89       	ldd	r24, Y+18	; 0x12
    2ac4:	82 ff       	sbrs	r24, 2
    2ac6:	e5 cf       	rjmp	.-54     	; 0x2a92 <prvSwitchTimerLists+0xc>
            the timer going into the same timer list then it has already expired
            and the timer should be re-inserted into the current list so it is
            processed again within this loop.  Otherwise a command should be sent
            to restart the timer to ensure it is only inserted into a list after
            the lists have been swapped. */
            xReloadTime = ( xNextExpireTime + pxTimer->xTimerPeriodInTicks );
    2ac8:	8c 85       	ldd	r24, Y+12	; 0x0c
    2aca:	9d 85       	ldd	r25, Y+13	; 0x0d
    2acc:	8e 0d       	add	r24, r14
    2ace:	9f 1d       	adc	r25, r15
            if( xReloadTime > xNextExpireTime )
    2ad0:	e8 16       	cp	r14, r24
    2ad2:	f9 06       	cpc	r15, r25
    2ad4:	60 f4       	brcc	.+24     	; 0x2aee <prvSwitchTimerLists+0x68>
            {
                listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xReloadTime );
    2ad6:	9b 83       	std	Y+3, r25	; 0x03
    2ad8:	8a 83       	std	Y+2, r24	; 0x02
                listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
    2ada:	d9 87       	std	Y+9, r29	; 0x09
    2adc:	c8 87       	std	Y+8, r28	; 0x08
                vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
    2ade:	b8 01       	movw	r22, r16
    2ae0:	80 91 ca 03 	lds	r24, 0x03CA	; 0x8003ca <pxCurrentTimerList>
    2ae4:	90 91 cb 03 	lds	r25, 0x03CB	; 0x8003cb <pxCurrentTimerList+0x1>
    2ae8:	0e 94 b6 09 	call	0x136c	; 0x136c <vListInsert>
    2aec:	d2 cf       	rjmp	.-92     	; 0x2a92 <prvSwitchTimerLists+0xc>
            }
            else
            {
                xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY );
    2aee:	00 e0       	ldi	r16, 0x00	; 0
    2af0:	10 e0       	ldi	r17, 0x00	; 0
    2af2:	20 e0       	ldi	r18, 0x00	; 0
    2af4:	30 e0       	ldi	r19, 0x00	; 0
    2af6:	a7 01       	movw	r20, r14
    2af8:	60 e0       	ldi	r22, 0x00	; 0
    2afa:	ce 01       	movw	r24, r28
    2afc:	0e 94 04 15 	call	0x2a08	; 0x2a08 <xTimerGenericCommand>
    2b00:	c8 cf       	rjmp	.-112    	; 0x2a92 <prvSwitchTimerLists+0xc>
            mtCOVERAGE_TEST_MARKER();
        }
    }

    pxTemp = pxCurrentTimerList;
    pxCurrentTimerList = pxOverflowTimerList;
    2b02:	80 91 c8 03 	lds	r24, 0x03C8	; 0x8003c8 <pxOverflowTimerList>
    2b06:	90 91 c9 03 	lds	r25, 0x03C9	; 0x8003c9 <pxOverflowTimerList+0x1>
    2b0a:	90 93 cb 03 	sts	0x03CB, r25	; 0x8003cb <pxCurrentTimerList+0x1>
    2b0e:	80 93 ca 03 	sts	0x03CA, r24	; 0x8003ca <pxCurrentTimerList>
    pxOverflowTimerList = pxTemp;
    2b12:	f0 93 c9 03 	sts	0x03C9, r31	; 0x8003c9 <pxOverflowTimerList+0x1>
    2b16:	e0 93 c8 03 	sts	0x03C8, r30	; 0x8003c8 <pxOverflowTimerList>
}
    2b1a:	df 91       	pop	r29
    2b1c:	cf 91       	pop	r28
    2b1e:	1f 91       	pop	r17
    2b20:	0f 91       	pop	r16
    2b22:	ff 90       	pop	r15
    2b24:	ef 90       	pop	r14
    2b26:	08 95       	ret

00002b28 <prvTimerTask>:
    pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
}
/*-----------------------------------------------------------*/

static portTASK_FUNCTION( prvTimerTask, pvParameters )
{
    2b28:	cf 93       	push	r28
    2b2a:	df 93       	push	r29
    2b2c:	00 d0       	rcall	.+0      	; 0x2b2e <prvTimerTask+0x6>
    2b2e:	00 d0       	rcall	.+0      	; 0x2b30 <prvTimerTask+0x8>
    2b30:	1f 92       	push	r1
    2b32:	cd b7       	in	r28, 0x3d	; 61
    2b34:	de b7       	in	r29, 0x3e	; 62
    the timer with the nearest expiry time will expire.  If there are no
    active timers then just set the next expire time to 0.  That will cause
    this task to unblock when the tick count overflows, at which point the
    timer lists will be switched and the next expiry time can be
    re-assessed.  */
    *pxListWasEmpty = listLIST_IS_EMPTY( pxCurrentTimerList );
    2b36:	e0 91 ca 03 	lds	r30, 0x03CA	; 0x8003ca <pxCurrentTimerList>
    2b3a:	f0 91 cb 03 	lds	r31, 0x03CB	; 0x8003cb <pxCurrentTimerList+0x1>
    2b3e:	d0 80       	ld	r13, Z
    if( *pxListWasEmpty == pdFALSE )
    2b40:	dd 20       	and	r13, r13
    2b42:	31 f0       	breq	.+12     	; 0x2b50 <prvTimerTask+0x28>
    {
        xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
    2b44:	05 80       	ldd	r0, Z+5	; 0x05
    2b46:	f6 81       	ldd	r31, Z+6	; 0x06
    2b48:	e0 2d       	mov	r30, r0
    2b4a:	e0 80       	ld	r14, Z
    2b4c:	f1 80       	ldd	r15, Z+1	; 0x01
    2b4e:	02 c0       	rjmp	.+4      	; 0x2b54 <prvTimerTask+0x2c>
    }
    else
    {
        /* Ensure the task unblocks when the tick count rolls over. */
        xNextExpireTime = ( TickType_t ) 0U;
    2b50:	e1 2c       	mov	r14, r1
    2b52:	f1 2c       	mov	r15, r1
static void prvProcessTimerOrBlockTask( const TickType_t xNextExpireTime, BaseType_t xListWasEmpty )
{
TickType_t xTimeNow;
BaseType_t xTimerListsWereSwitched;

    vTaskSuspendAll();
    2b54:	0e 94 0c 11 	call	0x2218	; 0x2218 <vTaskSuspendAll>
static TickType_t prvSampleTimeNow( BaseType_t * const pxTimerListsWereSwitched )
{
TickType_t xTimeNow;
PRIVILEGED_DATA static TickType_t xLastTime = ( TickType_t ) 0U; /*lint !e956 Variable is only accessible to one task. */

    xTimeNow = xTaskGetTickCount();
    2b58:	0e 94 12 11 	call	0x2224	; 0x2224 <xTaskGetTickCount>
    2b5c:	8c 01       	movw	r16, r24

    if( xTimeNow < xLastTime )
    2b5e:	80 91 c2 03 	lds	r24, 0x03C2	; 0x8003c2 <xLastTime.2412>
    2b62:	90 91 c3 03 	lds	r25, 0x03C3	; 0x8003c3 <xLastTime.2412+0x1>
    2b66:	08 17       	cp	r16, r24
    2b68:	19 07       	cpc	r17, r25
    2b6a:	20 f4       	brcc	.+8      	; 0x2b74 <prvTimerTask+0x4c>
    {
        prvSwitchTimerLists();
    2b6c:	0e 94 43 15 	call	0x2a86	; 0x2a86 <prvSwitchTimerLists>
        *pxTimerListsWereSwitched = pdTRUE;
    2b70:	81 e0       	ldi	r24, 0x01	; 1
    2b72:	01 c0       	rjmp	.+2      	; 0x2b76 <prvTimerTask+0x4e>
    }
    else
    {
        *pxTimerListsWereSwitched = pdFALSE;
    2b74:	80 e0       	ldi	r24, 0x00	; 0
    }

    xLastTime = xTimeNow;
    2b76:	10 93 c3 03 	sts	0x03C3, r17	; 0x8003c3 <xLastTime.2412+0x1>
    2b7a:	00 93 c2 03 	sts	0x03C2, r16	; 0x8003c2 <xLastTime.2412>
        has expired or not.  If obtaining the time causes the lists to switch
        then don't process this timer as any timers that remained in the list
        when the lists were switched will have been processed within the
        prvSampleTimeNow() function. */
        xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
        if( xTimerListsWereSwitched == pdFALSE )
    2b7e:	81 11       	cpse	r24, r1
    2b80:	55 c0       	rjmp	.+170    	; 0x2c2c <prvTimerTask+0x104>
        {
            /* The tick count has not overflowed, has the timer expired? */
            if( ( xListWasEmpty == pdFALSE ) && ( xNextExpireTime <= xTimeNow ) )
    2b82:	dd 20       	and	r13, r13
    2b84:	d9 f1       	breq	.+118    	; 0x2bfc <prvTimerTask+0xd4>
    2b86:	0e 15       	cp	r16, r14
    2b88:	1f 05       	cpc	r17, r15
    2b8a:	08 f4       	brcc	.+2      	; 0x2b8e <prvTimerTask+0x66>
    2b8c:	3e c0       	rjmp	.+124    	; 0x2c0a <prvTimerTask+0xe2>
            {
                ( void ) xTaskResumeAll();
    2b8e:	0e 94 c8 11 	call	0x2390	; 0x2390 <xTaskResumeAll>
/*-----------------------------------------------------------*/

static void prvProcessExpiredTimer( const TickType_t xNextExpireTime, const TickType_t xTimeNow )
{
BaseType_t xResult;
Timer_t * const pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList ); /*lint !e9087 !e9079 void * is used as this macro is used with tasks and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    2b92:	e0 91 ca 03 	lds	r30, 0x03CA	; 0x8003ca <pxCurrentTimerList>
    2b96:	f0 91 cb 03 	lds	r31, 0x03CB	; 0x8003cb <pxCurrentTimerList+0x1>
    2b9a:	05 80       	ldd	r0, Z+5	; 0x05
    2b9c:	f6 81       	ldd	r31, Z+6	; 0x06
    2b9e:	e0 2d       	mov	r30, r0
    2ba0:	c6 80       	ldd	r12, Z+6	; 0x06
    2ba2:	d7 80       	ldd	r13, Z+7	; 0x07

    /* Remove the timer from the list of active timers.  A check has already
    been performed to ensure the list is not empty. */
    ( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
    2ba4:	c6 01       	movw	r24, r12
    2ba6:	02 96       	adiw	r24, 0x02	; 2
    2ba8:	0e 94 ee 09 	call	0x13dc	; 0x13dc <uxListRemove>
    traceTIMER_EXPIRED( pxTimer );

    /* If the timer is an auto reload timer then calculate the next
    expiry time and re-insert the timer in the list of active timers. */
    if( ( pxTimer->ucStatus & tmrSTATUS_IS_AUTORELOAD ) != 0 )
    2bac:	d6 01       	movw	r26, r12
    2bae:	52 96       	adiw	r26, 0x12	; 18
    2bb0:	8c 91       	ld	r24, X
    2bb2:	52 97       	sbiw	r26, 0x12	; 18
    2bb4:	82 ff       	sbrs	r24, 2
    2bb6:	17 c0       	rjmp	.+46     	; 0x2be6 <prvTimerTask+0xbe>
    {
        /* The timer is inserted into a list using a time relative to anything
        other than the current time.  It will therefore be inserted into the
        correct list relative to the time this task thinks it is now. */
        if( prvInsertTimerInActiveList( pxTimer, ( xNextExpireTime + pxTimer->xTimerPeriodInTicks ), xTimeNow, xNextExpireTime ) != pdFALSE )
    2bb8:	1c 96       	adiw	r26, 0x0c	; 12
    2bba:	6d 91       	ld	r22, X+
    2bbc:	7c 91       	ld	r23, X
    2bbe:	1d 97       	sbiw	r26, 0x0d	; 13
    2bc0:	6e 0d       	add	r22, r14
    2bc2:	7f 1d       	adc	r23, r15
    2bc4:	97 01       	movw	r18, r14
    2bc6:	a8 01       	movw	r20, r16
    2bc8:	c6 01       	movw	r24, r12
    2bca:	0e 94 ba 14 	call	0x2974	; 0x2974 <prvInsertTimerInActiveList>
    2bce:	88 23       	and	r24, r24
    2bd0:	69 f0       	breq	.+26     	; 0x2bec <prvTimerTask+0xc4>
        {
            /* The timer expired before it was added to the active timer
            list.  Reload it now.  */
            xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY );
    2bd2:	00 e0       	ldi	r16, 0x00	; 0
    2bd4:	10 e0       	ldi	r17, 0x00	; 0
    2bd6:	20 e0       	ldi	r18, 0x00	; 0
    2bd8:	30 e0       	ldi	r19, 0x00	; 0
    2bda:	a7 01       	movw	r20, r14
    2bdc:	60 e0       	ldi	r22, 0x00	; 0
    2bde:	c6 01       	movw	r24, r12
    2be0:	0e 94 04 15 	call	0x2a08	; 0x2a08 <xTimerGenericCommand>
    2be4:	03 c0       	rjmp	.+6      	; 0x2bec <prvTimerTask+0xc4>
            mtCOVERAGE_TEST_MARKER();
        }
    }
    else
    {
        pxTimer->ucStatus &= ~tmrSTATUS_IS_ACTIVE;
    2be6:	8e 7f       	andi	r24, 0xFE	; 254
    2be8:	f6 01       	movw	r30, r12
    2bea:	82 8b       	std	Z+18, r24	; 0x12
        mtCOVERAGE_TEST_MARKER();
    }

    /* Call the timer callback. */
    pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
    2bec:	d6 01       	movw	r26, r12
    2bee:	50 96       	adiw	r26, 0x10	; 16
    2bf0:	ed 91       	ld	r30, X+
    2bf2:	fc 91       	ld	r31, X
    2bf4:	51 97       	sbiw	r26, 0x11	; 17
    2bf6:	c6 01       	movw	r24, r12
    2bf8:	09 95       	icall
    2bfa:	1e c0       	rjmp	.+60     	; 0x2c38 <prvTimerTask+0x110>
                case when the current timer list is empty. */
                if( xListWasEmpty != pdFALSE )
                {
                    /* The current timer list is empty - is the overflow list
                    also empty? */
                    xListWasEmpty = listLIST_IS_EMPTY( pxOverflowTimerList );
    2bfc:	e0 91 c8 03 	lds	r30, 0x03C8	; 0x8003c8 <pxOverflowTimerList>
    2c00:	f0 91 c9 03 	lds	r31, 0x03C9	; 0x8003c9 <pxOverflowTimerList+0x1>
    2c04:	80 81       	ld	r24, Z
    2c06:	41 e0       	ldi	r20, 0x01	; 1
    2c08:	81 11       	cpse	r24, r1
        prvSampleTimeNow() function. */
        xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
        if( xTimerListsWereSwitched == pdFALSE )
        {
            /* The tick count has not overflowed, has the timer expired? */
            if( ( xListWasEmpty == pdFALSE ) && ( xNextExpireTime <= xTimeNow ) )
    2c0a:	40 e0       	ldi	r20, 0x00	; 0
                    /* The current timer list is empty - is the overflow list
                    also empty? */
                    xListWasEmpty = listLIST_IS_EMPTY( pxOverflowTimerList );
                }

                vQueueWaitForMessageRestricted( xTimerQueue, ( xNextExpireTime - xTimeNow ), xListWasEmpty );
    2c0c:	b7 01       	movw	r22, r14
    2c0e:	60 1b       	sub	r22, r16
    2c10:	71 0b       	sbc	r23, r17
    2c12:	80 91 c6 03 	lds	r24, 0x03C6	; 0x8003c6 <xTimerQueue>
    2c16:	90 91 c7 03 	lds	r25, 0x03C7	; 0x8003c7 <xTimerQueue+0x1>
    2c1a:	0e 94 c8 0e 	call	0x1d90	; 0x1d90 <vQueueWaitForMessageRestricted>

                if( xTaskResumeAll() == pdFALSE )
    2c1e:	0e 94 c8 11 	call	0x2390	; 0x2390 <xTaskResumeAll>
    2c22:	81 11       	cpse	r24, r1
    2c24:	09 c0       	rjmp	.+18     	; 0x2c38 <prvTimerTask+0x110>
                {
                    /* Yield to wait for either a command to arrive, or the
                    block time to expire.  If a command arrived between the
                    critical section being exited and this yield then the yield
                    will not cause the task to block. */
                    portYIELD_WITHIN_API();
    2c26:	0e 94 b6 0a 	call	0x156c	; 0x156c <vPortYield>
    2c2a:	06 c0       	rjmp	.+12     	; 0x2c38 <prvTimerTask+0x110>
                }
            }
        }
        else
        {
            ( void ) xTaskResumeAll();
    2c2c:	0e 94 c8 11 	call	0x2390	; 0x2390 <xTaskResumeAll>
    2c30:	03 c0       	rjmp	.+6      	; 0x2c38 <prvTimerTask+0x110>
        }
        #endif /* INCLUDE_xTimerPendFunctionCall */

        /* Commands that are positive are timer commands rather than pended
        function calls. */
        if( xMessage.xMessageID >= ( BaseType_t ) 0 )
    2c32:	89 81       	ldd	r24, Y+1	; 0x01
    2c34:	87 ff       	sbrs	r24, 7
    2c36:	0e c0       	rjmp	.+28     	; 0x2c54 <prvTimerTask+0x12c>
DaemonTaskMessage_t xMessage;
Timer_t *pxTimer;
BaseType_t xTimerListsWereSwitched, xResult;
TickType_t xTimeNow;

    while( xQueueReceive( xTimerQueue, &xMessage, tmrNO_DELAY ) != pdFAIL ) /*lint !e603 xMessage does not have to be initialised as it is passed out, not in, and it is not used unless xQueueReceive() returns pdTRUE. */
    2c38:	40 e0       	ldi	r20, 0x00	; 0
    2c3a:	50 e0       	ldi	r21, 0x00	; 0
    2c3c:	be 01       	movw	r22, r28
    2c3e:	6f 5f       	subi	r22, 0xFF	; 255
    2c40:	7f 4f       	sbci	r23, 0xFF	; 255
    2c42:	80 91 c6 03 	lds	r24, 0x03C6	; 0x8003c6 <xTimerQueue>
    2c46:	90 91 c7 03 	lds	r25, 0x03C7	; 0x8003c7 <xTimerQueue+0x1>
    2c4a:	0e 94 74 0d 	call	0x1ae8	; 0x1ae8 <xQueueReceive>
    2c4e:	81 11       	cpse	r24, r1
    2c50:	f0 cf       	rjmp	.-32     	; 0x2c32 <prvTimerTask+0x10a>
    2c52:	71 cf       	rjmp	.-286    	; 0x2b36 <prvTimerTask+0xe>
        function calls. */
        if( xMessage.xMessageID >= ( BaseType_t ) 0 )
        {
            /* The messages uses the xTimerParameters member to work on a
            software timer. */
            pxTimer = xMessage.u.xTimerParameters.pxTimer;
    2c54:	ec 80       	ldd	r14, Y+4	; 0x04
    2c56:	fd 80       	ldd	r15, Y+5	; 0x05

        if( listIS_CONTAINED_WITHIN( NULL, &( pxTimer->xTimerListItem ) ) == pdFALSE ) /*lint !e961. The cast is only redundant when NULL is passed into the macro. */
    2c58:	f7 01       	movw	r30, r14
    2c5a:	82 85       	ldd	r24, Z+10	; 0x0a
    2c5c:	93 85       	ldd	r25, Z+11	; 0x0b
    2c5e:	89 2b       	or	r24, r25
    2c60:	21 f0       	breq	.+8      	; 0x2c6a <prvTimerTask+0x142>
            {
                /* The timer is in a list, remove it. */
                ( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
    2c62:	c7 01       	movw	r24, r14
    2c64:	02 96       	adiw	r24, 0x02	; 2
    2c66:	0e 94 ee 09 	call	0x13dc	; 0x13dc <uxListRemove>
static TickType_t prvSampleTimeNow( BaseType_t * const pxTimerListsWereSwitched )
{
TickType_t xTimeNow;
PRIVILEGED_DATA static TickType_t xLastTime = ( TickType_t ) 0U; /*lint !e956 Variable is only accessible to one task. */

    xTimeNow = xTaskGetTickCount();
    2c6a:	0e 94 12 11 	call	0x2224	; 0x2224 <xTaskGetTickCount>
    2c6e:	6c 01       	movw	r12, r24

    if( xTimeNow < xLastTime )
    2c70:	80 91 c2 03 	lds	r24, 0x03C2	; 0x8003c2 <xLastTime.2412>
    2c74:	90 91 c3 03 	lds	r25, 0x03C3	; 0x8003c3 <xLastTime.2412+0x1>
    2c78:	c8 16       	cp	r12, r24
    2c7a:	d9 06       	cpc	r13, r25
    2c7c:	10 f4       	brcc	.+4      	; 0x2c82 <prvTimerTask+0x15a>
    {
        prvSwitchTimerLists();
    2c7e:	0e 94 43 15 	call	0x2a86	; 0x2a86 <prvSwitchTimerLists>
    else
    {
        *pxTimerListsWereSwitched = pdFALSE;
    }

    xLastTime = xTimeNow;
    2c82:	d0 92 c3 03 	sts	0x03C3, r13	; 0x8003c3 <xLastTime.2412+0x1>
    2c86:	c0 92 c2 03 	sts	0x03C2, r12	; 0x8003c2 <xLastTime.2412>
            possibility of a higher priority task adding a message to the message
            queue with a time that is ahead of the timer daemon task (because it
            pre-empted the timer daemon task after the xTimeNow value was set). */
            xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );

            switch( xMessage.xMessageID )
    2c8a:	e9 81       	ldd	r30, Y+1	; 0x01
    2c8c:	0e 2e       	mov	r0, r30
    2c8e:	00 0c       	add	r0, r0
    2c90:	ff 0b       	sbc	r31, r31
    2c92:	ea 30       	cpi	r30, 0x0A	; 10
    2c94:	f1 05       	cpc	r31, r1
    2c96:	80 f6       	brcc	.-96     	; 0x2c38 <prvTimerTask+0x110>
    2c98:	ec 5c       	subi	r30, 0xCC	; 204
    2c9a:	ff 4f       	sbci	r31, 0xFF	; 255
    2c9c:	d7 01       	movw	r26, r14
    2c9e:	52 96       	adiw	r26, 0x12	; 18
    2ca0:	8c 91       	ld	r24, X
    2ca2:	0c 94 06 24 	jmp	0x480c	; 0x480c <__tablejump2__>
                case tmrCOMMAND_START_FROM_ISR :
                case tmrCOMMAND_RESET :
                case tmrCOMMAND_RESET_FROM_ISR :
                case tmrCOMMAND_START_DONT_TRACE :
                    /* Start or restart a timer. */
                    pxTimer->ucStatus |= tmrSTATUS_IS_ACTIVE;
    2ca6:	81 60       	ori	r24, 0x01	; 1
    2ca8:	f7 01       	movw	r30, r14
    2caa:	82 8b       	std	Z+18, r24	; 0x12
                    if( prvInsertTimerInActiveList( pxTimer,  xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, xTimeNow, xMessage.u.xTimerParameters.xMessageValue ) != pdFALSE )
    2cac:	2a 81       	ldd	r18, Y+2	; 0x02
    2cae:	3b 81       	ldd	r19, Y+3	; 0x03
    2cb0:	64 85       	ldd	r22, Z+12	; 0x0c
    2cb2:	75 85       	ldd	r23, Z+13	; 0x0d
    2cb4:	62 0f       	add	r22, r18
    2cb6:	73 1f       	adc	r23, r19
    2cb8:	a6 01       	movw	r20, r12
    2cba:	c7 01       	movw	r24, r14
    2cbc:	0e 94 ba 14 	call	0x2974	; 0x2974 <prvInsertTimerInActiveList>
    2cc0:	88 23       	and	r24, r24
    2cc2:	09 f4       	brne	.+2      	; 0x2cc6 <prvTimerTask+0x19e>
    2cc4:	b9 cf       	rjmp	.-142    	; 0x2c38 <prvTimerTask+0x110>
                    {
                        /* The timer expired before it was added to the active
                        timer list.  Process it now. */
                        pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
    2cc6:	d7 01       	movw	r26, r14
    2cc8:	50 96       	adiw	r26, 0x10	; 16
    2cca:	ed 91       	ld	r30, X+
    2ccc:	fc 91       	ld	r31, X
    2cce:	51 97       	sbiw	r26, 0x11	; 17
    2cd0:	c7 01       	movw	r24, r14
    2cd2:	09 95       	icall
                        traceTIMER_EXPIRED( pxTimer );

                        if( ( pxTimer->ucStatus & tmrSTATUS_IS_AUTORELOAD ) != 0 )
    2cd4:	f7 01       	movw	r30, r14
    2cd6:	82 89       	ldd	r24, Z+18	; 0x12
    2cd8:	82 ff       	sbrs	r24, 2
    2cda:	ae cf       	rjmp	.-164    	; 0x2c38 <prvTimerTask+0x110>
                        {
                            xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, NULL, tmrNO_DELAY );
    2cdc:	4a 81       	ldd	r20, Y+2	; 0x02
    2cde:	5b 81       	ldd	r21, Y+3	; 0x03
    2ce0:	84 85       	ldd	r24, Z+12	; 0x0c
    2ce2:	95 85       	ldd	r25, Z+13	; 0x0d
    2ce4:	48 0f       	add	r20, r24
    2ce6:	59 1f       	adc	r21, r25
    2ce8:	00 e0       	ldi	r16, 0x00	; 0
    2cea:	10 e0       	ldi	r17, 0x00	; 0
    2cec:	20 e0       	ldi	r18, 0x00	; 0
    2cee:	30 e0       	ldi	r19, 0x00	; 0
    2cf0:	60 e0       	ldi	r22, 0x00	; 0
    2cf2:	c7 01       	movw	r24, r14
    2cf4:	0e 94 04 15 	call	0x2a08	; 0x2a08 <xTimerGenericCommand>
    2cf8:	9f cf       	rjmp	.-194    	; 0x2c38 <prvTimerTask+0x110>
                    pxTimer->ucStatus &= ~tmrSTATUS_IS_ACTIVE;
                    break;

                case tmrCOMMAND_CHANGE_PERIOD :
                case tmrCOMMAND_CHANGE_PERIOD_FROM_ISR :
                    pxTimer->ucStatus |= tmrSTATUS_IS_ACTIVE;
    2cfa:	81 60       	ori	r24, 0x01	; 1
    2cfc:	f7 01       	movw	r30, r14
    2cfe:	82 8b       	std	Z+18, r24	; 0x12
                    pxTimer->xTimerPeriodInTicks = xMessage.u.xTimerParameters.xMessageValue;
    2d00:	6a 81       	ldd	r22, Y+2	; 0x02
    2d02:	7b 81       	ldd	r23, Y+3	; 0x03
    2d04:	75 87       	std	Z+13, r23	; 0x0d
    2d06:	64 87       	std	Z+12, r22	; 0x0c
                    be longer or shorter than the old one.  The command time is
                    therefore set to the current time, and as the period cannot
                    be zero the next expiry time can only be in the future,
                    meaning (unlike for the xTimerStart() case above) there is
                    no fail case that needs to be handled here. */
                    ( void ) prvInsertTimerInActiveList( pxTimer, ( xTimeNow + pxTimer->xTimerPeriodInTicks ), xTimeNow, xTimeNow );
    2d08:	6c 0d       	add	r22, r12
    2d0a:	7d 1d       	adc	r23, r13
    2d0c:	96 01       	movw	r18, r12
    2d0e:	a6 01       	movw	r20, r12
    2d10:	c7 01       	movw	r24, r14
    2d12:	0e 94 ba 14 	call	0x2974	; 0x2974 <prvInsertTimerInActiveList>
    2d16:	90 cf       	rjmp	.-224    	; 0x2c38 <prvTimerTask+0x110>
                    #if ( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
                    {
                    /* The timer has already been removed from the active list,
                    just free up the memory if the memory was dynamically
                    allocated. */
                        if( ( pxTimer->ucStatus & tmrSTATUS_IS_STATICALLY_ALLOCATED ) == ( uint8_t ) 0 )
    2d18:	81 fd       	sbrc	r24, 1
    2d1a:	04 c0       	rjmp	.+8      	; 0x2d24 <prvTimerTask+0x1fc>
                        {
                            vPortFree( pxTimer );
    2d1c:	c7 01       	movw	r24, r14
    2d1e:	0e 94 72 09 	call	0x12e4	; 0x12e4 <vPortFree>
    2d22:	8a cf       	rjmp	.-236    	; 0x2c38 <prvTimerTask+0x110>
                        }
                        else
                        {
                            pxTimer->ucStatus &= ~tmrSTATUS_IS_ACTIVE;
    2d24:	8e 7f       	andi	r24, 0xFE	; 254
    2d26:	d7 01       	movw	r26, r14
    2d28:	52 96       	adiw	r26, 0x12	; 18
    2d2a:	8c 93       	st	X, r24
    2d2c:	85 cf       	rjmp	.-246    	; 0x2c38 <prvTimerTask+0x110>

00002d2e <initVariant>:
{
#if defined(USBCON)
    USBDevice.attach();
#endif

    setup();        // the normal Arduino setup() function is run here.
    2d2e:	0e 94 d0 05 	call	0xba0	; 0xba0 <setup>
    vTaskStartScheduler(); // initialise and run the freeRTOS scheduler. Execution should never return here.
    2d32:	0e 94 de 10 	call	0x21bc	; 0x21bc <vTaskStartScheduler>
    2d36:	08 95       	ret

00002d38 <vApplicationIdleHook>:
 */
void vApplicationIdleHook( void ) __attribute__((weak));

void vApplicationIdleHook( void )
{
    loop();        // the normal Arduino loop() function is run here.
    2d38:	0e 94 5b 06 	call	0xcb6	; 0xcb6 <loop>
    if (serialEventRun) serialEventRun();
    2d3c:	8b e4       	ldi	r24, 0x4B	; 75
    2d3e:	9d e1       	ldi	r25, 0x1D	; 29
    2d40:	89 2b       	or	r24, r25
    2d42:	11 f0       	breq	.+4      	; 0x2d48 <vApplicationIdleHook+0x10>
    2d44:	0c 94 4b 1d 	jmp	0x3a96	; 0x3a96 <_Z14serialEventRunv>
    2d48:	08 95       	ret

00002d4a <vApplicationMallocFailedHook>:
#elif defined(__AVR_ATmega644P__) || defined(__AVR_ATmega644PA__) || defined(__AVR_ATmega1284P__) || defined(__AVR_ATmega1284PA__) // Seeed Goldilocks with 1284p
    DDRB  |= _BV(DDB7);
    PORTB |= _BV(PORTB7);       // Main (red PB7) LED on. Main LED on.

#elif defined(__AVR_ATmega328P__) || defined(__AVR_ATmega168__) || defined(__AVR_ATmega8__) // assume we're using an Arduino Uno with 328p
    DDRB  |= _BV(DDB5);
    2d4a:	25 9a       	sbi	0x04, 5	; 4
    PORTB |= _BV(PORTB5);       // Main (red PB5) LED on. Main LED on.
    2d4c:	2d 9a       	sbi	0x05, 5	; 5
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    2d4e:	2f ef       	ldi	r18, 0xFF	; 255
    2d50:	80 e7       	ldi	r24, 0x70	; 112
    2d52:	92 e0       	ldi	r25, 0x02	; 2
    2d54:	21 50       	subi	r18, 0x01	; 1
    2d56:	80 40       	sbci	r24, 0x00	; 0
    2d58:	90 40       	sbci	r25, 0x00	; 0
    2d5a:	e1 f7       	brne	.-8      	; 0x2d54 <vApplicationMallocFailedHook+0xa>
    2d5c:	00 c0       	rjmp	.+0      	; 0x2d5e <vApplicationMallocFailedHook+0x14>
    2d5e:	00 00       	nop

#elif defined(__AVR_ATmega644P__) || defined(__AVR_ATmega644PA__) || defined(__AVR_ATmega1284P__) || defined(__AVR_ATmega1284PA__) // Seeed Goldilocks with 1284p
        PINB  |= _BV(PINB7);       // Main (red PB7) LED toggle. Main LED fast blink.

#elif defined(__AVR_ATmega328P__) || defined(__AVR_ATmega168__) || defined(__AVR_ATmega8__) // assume we're using an Arduino Uno with 328p
        PINB  |= _BV(PINB5);       // Main (red PB5) LED toggle. Main LED fast blink.
    2d60:	1d 9a       	sbi	0x03, 5	; 3
    2d62:	f5 cf       	rjmp	.-22     	; 0x2d4e <vApplicationMallocFailedHook+0x4>

00002d64 <vApplicationStackOverflowHook>:
#elif defined(__AVR_ATmega644P__) || defined(__AVR_ATmega644PA__) || defined(__AVR_ATmega1284P__) || defined(__AVR_ATmega1284PA__) // Seeed Goldilocks with 1284p
    DDRB  |= _BV(DDB7);
    PORTB |= _BV(PORTB7);       // Main (red PB7) LED on. Main LED on.

#elif defined(__AVR_ATmega328P__) || defined(__AVR_ATmega168__) || defined(__AVR_ATmega8__) // assume we're using an Arduino Uno with 328p
    DDRB  |= _BV(DDB5);
    2d64:	25 9a       	sbi	0x04, 5	; 4
    PORTB |= _BV(PORTB5);       // Main (red PB5) LED on. Main LED on.
    2d66:	2d 9a       	sbi	0x05, 5	; 5
    2d68:	2f ef       	ldi	r18, 0xFF	; 255
    2d6a:	87 ea       	ldi	r24, 0xA7	; 167
    2d6c:	91 e6       	ldi	r25, 0x61	; 97
    2d6e:	21 50       	subi	r18, 0x01	; 1
    2d70:	80 40       	sbci	r24, 0x00	; 0
    2d72:	90 40       	sbci	r25, 0x00	; 0
    2d74:	e1 f7       	brne	.-8      	; 0x2d6e <vApplicationStackOverflowHook+0xa>
    2d76:	00 c0       	rjmp	.+0      	; 0x2d78 <vApplicationStackOverflowHook+0x14>
    2d78:	00 00       	nop

#elif defined(__AVR_ATmega644P__) || defined(__AVR_ATmega644PA__) || defined(__AVR_ATmega1284P__) || defined(__AVR_ATmega1284PA__) // Seeed Goldilocks with 1284p
        PINB  |= _BV(PINB7);       // Main (red PB7) LED toggle. Main LED slow blink.

#elif defined(__AVR_ATmega328P__) || defined(__AVR_ATmega168__) || defined(__AVR_ATmega8__) // assume we're using an Arduino Uno with 328p
        PINB  |= _BV(PINB5);       // Main (red PB5) LED toggle. Main LED slow blink.
    2d7a:	1d 9a       	sbi	0x03, 5	; 3
    2d7c:	f5 cf       	rjmp	.-22     	; 0x2d68 <vApplicationStackOverflowHook+0x4>

00002d7e <_ZN9MD_TCS23010initialiseEv>:
  }
  FreqCount.end();      // stop
  DUMP("VALUE ", FreqCount.read());

  return(FreqCount.read() * _readDiv);
}
    2d7e:	0f 93       	push	r16
    2d80:	1f 93       	push	r17
    2d82:	fc 01       	movw	r30, r24
    2d84:	8f ef       	ldi	r24, 0xFF	; 255
    2d86:	80 83       	st	Z, r24
    2d88:	81 83       	std	Z+1, r24	; 0x01
    2d8a:	82 83       	std	Z+2, r24	; 0x02
    2d8c:	83 83       	std	Z+3, r24	; 0x03
    2d8e:	84 83       	std	Z+4, r24	; 0x04
    2d90:	8a e0       	ldi	r24, 0x0A	; 10
    2d92:	85 83       	std	Z+5, r24	; 0x05
    2d94:	16 82       	std	Z+6, r1	; 0x06
    2d96:	df 01       	movw	r26, r30
    2d98:	17 96       	adiw	r26, 0x07	; 7
    2d9a:	73 96       	adiw	r30, 0x13	; 19
    2d9c:	00 e7       	ldi	r16, 0x70	; 112
    2d9e:	17 e1       	ldi	r17, 0x17	; 23
    2da0:	20 e0       	ldi	r18, 0x00	; 0
    2da2:	30 e0       	ldi	r19, 0x00	; 0
    2da4:	48 ed       	ldi	r20, 0xD8	; 216
    2da6:	56 ed       	ldi	r21, 0xD6	; 214
    2da8:	60 e0       	ldi	r22, 0x00	; 0
    2daa:	70 e0       	ldi	r23, 0x00	; 0
    2dac:	0d 93       	st	X+, r16
    2dae:	1d 93       	st	X+, r17
    2db0:	2d 93       	st	X+, r18
    2db2:	3d 93       	st	X+, r19
    2db4:	18 96       	adiw	r26, 0x08	; 8
    2db6:	4d 93       	st	X+, r20
    2db8:	5d 93       	st	X+, r21
    2dba:	6d 93       	st	X+, r22
    2dbc:	7c 93       	st	X, r23
    2dbe:	1b 97       	sbiw	r26, 0x0b	; 11
    2dc0:	ae 17       	cp	r26, r30
    2dc2:	bf 07       	cpc	r27, r31
    2dc4:	99 f7       	brne	.-26     	; 0x2dac <_ZN9MD_TCS23010initialiseEv+0x2e>
    2dc6:	1f 91       	pop	r17
    2dc8:	0f 91       	pop	r16
    2dca:	08 95       	ret

00002dcc <_ZN9MD_TCS230C1Ehhh>:
    2dcc:	ff 92       	push	r15
    2dce:	0f 93       	push	r16
    2dd0:	1f 93       	push	r17
    2dd2:	cf 93       	push	r28
    2dd4:	df 93       	push	r29
    2dd6:	ec 01       	movw	r28, r24
    2dd8:	f6 2e       	mov	r15, r22
    2dda:	04 2f       	mov	r16, r20
    2ddc:	12 2f       	mov	r17, r18
    2dde:	0e 94 bf 16 	call	0x2d7e	; 0x2d7e <_ZN9MD_TCS23010initialiseEv>
    2de2:	fb 82       	std	Y+3, r15	; 0x03
    2de4:	0c 83       	std	Y+4, r16	; 0x04
    2de6:	18 83       	st	Y, r17
    2de8:	df 91       	pop	r29
    2dea:	cf 91       	pop	r28
    2dec:	1f 91       	pop	r17
    2dee:	0f 91       	pop	r16
    2df0:	ff 90       	pop	r15
    2df2:	08 95       	ret

00002df4 <_ZN9MD_TCS230D1Ev>:
    2df4:	08 95       	ret

00002df6 <_ZN9MD_TCS2309setFilterEh>:
    2df6:	cf 93       	push	r28
    2df8:	df 93       	push	r29
    2dfa:	ec 01       	movw	r28, r24
    2dfc:	8b 81       	ldd	r24, Y+3	; 0x03
    2dfe:	8f 3f       	cpi	r24, 0xFF	; 255
    2e00:	e9 f0       	breq	.+58     	; 0x2e3c <_ZN9MD_TCS2309setFilterEh+0x46>
    2e02:	9c 81       	ldd	r25, Y+4	; 0x04
    2e04:	9f 3f       	cpi	r25, 0xFF	; 255
    2e06:	d1 f0       	breq	.+52     	; 0x2e3c <_ZN9MD_TCS2309setFilterEh+0x46>
    2e08:	61 30       	cpi	r22, 0x01	; 1
    2e0a:	49 f0       	breq	.+18     	; 0x2e1e <_ZN9MD_TCS2309setFilterEh+0x28>
    2e0c:	30 f0       	brcs	.+12     	; 0x2e1a <_ZN9MD_TCS2309setFilterEh+0x24>
    2e0e:	62 30       	cpi	r22, 0x02	; 2
    2e10:	41 f0       	breq	.+16     	; 0x2e22 <_ZN9MD_TCS2309setFilterEh+0x2c>
    2e12:	63 30       	cpi	r22, 0x03	; 3
    2e14:	99 f4       	brne	.+38     	; 0x2e3c <_ZN9MD_TCS2309setFilterEh+0x46>
    2e16:	61 e0       	ldi	r22, 0x01	; 1
    2e18:	09 c0       	rjmp	.+18     	; 0x2e2c <_ZN9MD_TCS2309setFilterEh+0x36>
    2e1a:	60 e0       	ldi	r22, 0x00	; 0
    2e1c:	07 c0       	rjmp	.+14     	; 0x2e2c <_ZN9MD_TCS2309setFilterEh+0x36>
    2e1e:	61 e0       	ldi	r22, 0x01	; 1
    2e20:	01 c0       	rjmp	.+2      	; 0x2e24 <_ZN9MD_TCS2309setFilterEh+0x2e>
    2e22:	60 e0       	ldi	r22, 0x00	; 0
    2e24:	0e 94 6b 22 	call	0x44d6	; 0x44d6 <digitalWrite>
    2e28:	61 e0       	ldi	r22, 0x01	; 1
    2e2a:	03 c0       	rjmp	.+6      	; 0x2e32 <_ZN9MD_TCS2309setFilterEh+0x3c>
    2e2c:	0e 94 6b 22 	call	0x44d6	; 0x44d6 <digitalWrite>
    2e30:	60 e0       	ldi	r22, 0x00	; 0
    2e32:	8c 81       	ldd	r24, Y+4	; 0x04
    2e34:	df 91       	pop	r29
    2e36:	cf 91       	pop	r28
    2e38:	0c 94 6b 22 	jmp	0x44d6	; 0x44d6 <digitalWrite>
    2e3c:	df 91       	pop	r29
    2e3e:	cf 91       	pop	r28
    2e40:	08 95       	ret

00002e42 <_ZN9MD_TCS23013setFrequency2Eh>:
    2e42:	cf 93       	push	r28
    2e44:	df 93       	push	r29
    2e46:	ec 01       	movw	r28, r24
    2e48:	89 81       	ldd	r24, Y+1	; 0x01
    2e4a:	8f 3f       	cpi	r24, 0xFF	; 255
    2e4c:	e9 f0       	breq	.+58     	; 0x2e88 <_ZN9MD_TCS23013setFrequency2Eh+0x46>
    2e4e:	9a 81       	ldd	r25, Y+2	; 0x02
    2e50:	9f 3f       	cpi	r25, 0xFF	; 255
    2e52:	d1 f0       	breq	.+52     	; 0x2e88 <_ZN9MD_TCS23013setFrequency2Eh+0x46>
    2e54:	61 30       	cpi	r22, 0x01	; 1
    2e56:	49 f0       	breq	.+18     	; 0x2e6a <_ZN9MD_TCS23013setFrequency2Eh+0x28>
    2e58:	30 f0       	brcs	.+12     	; 0x2e66 <_ZN9MD_TCS23013setFrequency2Eh+0x24>
    2e5a:	62 30       	cpi	r22, 0x02	; 2
    2e5c:	41 f0       	breq	.+16     	; 0x2e6e <_ZN9MD_TCS23013setFrequency2Eh+0x2c>
    2e5e:	63 30       	cpi	r22, 0x03	; 3
    2e60:	99 f4       	brne	.+38     	; 0x2e88 <_ZN9MD_TCS23013setFrequency2Eh+0x46>
    2e62:	60 e0       	ldi	r22, 0x00	; 0
    2e64:	09 c0       	rjmp	.+18     	; 0x2e78 <_ZN9MD_TCS23013setFrequency2Eh+0x36>
    2e66:	61 e0       	ldi	r22, 0x01	; 1
    2e68:	03 c0       	rjmp	.+6      	; 0x2e70 <_ZN9MD_TCS23013setFrequency2Eh+0x2e>
    2e6a:	61 e0       	ldi	r22, 0x01	; 1
    2e6c:	05 c0       	rjmp	.+10     	; 0x2e78 <_ZN9MD_TCS23013setFrequency2Eh+0x36>
    2e6e:	60 e0       	ldi	r22, 0x00	; 0
    2e70:	0e 94 6b 22 	call	0x44d6	; 0x44d6 <digitalWrite>
    2e74:	61 e0       	ldi	r22, 0x01	; 1
    2e76:	03 c0       	rjmp	.+6      	; 0x2e7e <_ZN9MD_TCS23013setFrequency2Eh+0x3c>
    2e78:	0e 94 6b 22 	call	0x44d6	; 0x44d6 <digitalWrite>
    2e7c:	60 e0       	ldi	r22, 0x00	; 0
    2e7e:	8a 81       	ldd	r24, Y+2	; 0x02
    2e80:	df 91       	pop	r29
    2e82:	cf 91       	pop	r28
    2e84:	0c 94 6b 22 	jmp	0x44d6	; 0x44d6 <digitalWrite>
    2e88:	df 91       	pop	r29
    2e8a:	cf 91       	pop	r28
    2e8c:	08 95       	ret

00002e8e <_ZN9MD_TCS2309setEnableEb>:
    2e8e:	fc 01       	movw	r30, r24
    2e90:	20 81       	ld	r18, Z
    2e92:	2f 3f       	cpi	r18, 0xFF	; 255
    2e94:	29 f0       	breq	.+10     	; 0x2ea0 <_ZN9MD_TCS2309setEnableEb+0x12>
    2e96:	91 e0       	ldi	r25, 0x01	; 1
    2e98:	69 27       	eor	r22, r25
    2e9a:	82 2f       	mov	r24, r18
    2e9c:	0c 94 6b 22 	jmp	0x44d6	; 0x44d6 <digitalWrite>
    2ea0:	66 23       	and	r22, r22
    2ea2:	19 f0       	breq	.+6      	; 0x2eaa <_ZN9MD_TCS2309setEnableEb+0x1c>
    2ea4:	fc 01       	movw	r30, r24
    2ea6:	66 81       	ldd	r22, Z+6	; 0x06
    2ea8:	01 c0       	rjmp	.+2      	; 0x2eac <_ZN9MD_TCS2309setEnableEb+0x1e>
    2eaa:	63 e0       	ldi	r22, 0x03	; 3
    2eac:	0c 94 21 17 	jmp	0x2e42	; 0x2e42 <_ZN9MD_TCS23013setFrequency2Eh>

00002eb0 <_ZN9MD_TCS2305beginEv>:
    2eb0:	cf 93       	push	r28
    2eb2:	df 93       	push	r29
    2eb4:	ec 01       	movw	r28, r24
    2eb6:	89 81       	ldd	r24, Y+1	; 0x01
    2eb8:	8f 3f       	cpi	r24, 0xFF	; 255
    2eba:	19 f0       	breq	.+6      	; 0x2ec2 <_ZN9MD_TCS2305beginEv+0x12>
    2ebc:	61 e0       	ldi	r22, 0x01	; 1
    2ebe:	0e 94 2f 22 	call	0x445e	; 0x445e <pinMode>
    2ec2:	8a 81       	ldd	r24, Y+2	; 0x02
    2ec4:	8f 3f       	cpi	r24, 0xFF	; 255
    2ec6:	19 f0       	breq	.+6      	; 0x2ece <_ZN9MD_TCS2305beginEv+0x1e>
    2ec8:	61 e0       	ldi	r22, 0x01	; 1
    2eca:	0e 94 2f 22 	call	0x445e	; 0x445e <pinMode>
    2ece:	8b 81       	ldd	r24, Y+3	; 0x03
    2ed0:	8f 3f       	cpi	r24, 0xFF	; 255
    2ed2:	19 f0       	breq	.+6      	; 0x2eda <_ZN9MD_TCS2305beginEv+0x2a>
    2ed4:	61 e0       	ldi	r22, 0x01	; 1
    2ed6:	0e 94 2f 22 	call	0x445e	; 0x445e <pinMode>
    2eda:	8c 81       	ldd	r24, Y+4	; 0x04
    2edc:	8f 3f       	cpi	r24, 0xFF	; 255
    2ede:	19 f0       	breq	.+6      	; 0x2ee6 <_ZN9MD_TCS2305beginEv+0x36>
    2ee0:	61 e0       	ldi	r22, 0x01	; 1
    2ee2:	0e 94 2f 22 	call	0x445e	; 0x445e <pinMode>
    2ee6:	88 81       	ld	r24, Y
    2ee8:	8f 3f       	cpi	r24, 0xFF	; 255
    2eea:	19 f0       	breq	.+6      	; 0x2ef2 <_ZN9MD_TCS2305beginEv+0x42>
    2eec:	61 e0       	ldi	r22, 0x01	; 1
    2eee:	0e 94 2f 22 	call	0x445e	; 0x445e <pinMode>
    2ef2:	60 e0       	ldi	r22, 0x00	; 0
    2ef4:	ce 01       	movw	r24, r28
    2ef6:	0e 94 47 17 	call	0x2e8e	; 0x2e8e <_ZN9MD_TCS2309setEnableEb>
    2efa:	6e 81       	ldd	r22, Y+6	; 0x06
    2efc:	ce 01       	movw	r24, r28
    2efe:	df 91       	pop	r29
    2f00:	cf 91       	pop	r28
    2f02:	0c 94 21 17 	jmp	0x2e42	; 0x2e42 <_ZN9MD_TCS23013setFrequency2Eh>

00002f06 <_ZN9MD_TCS2306getRGBEP9colorData>:
    2f06:	dc 01       	movw	r26, r24
    2f08:	fb 01       	movw	r30, r22
    2f0a:	30 97       	sbiw	r30, 0x00	; 0
    2f0c:	59 f0       	breq	.+22     	; 0x2f24 <_ZN9MD_TCS2306getRGBEP9colorData+0x1e>
    2f0e:	9b 96       	adiw	r26, 0x2b	; 43
    2f10:	8c 91       	ld	r24, X
    2f12:	9b 97       	sbiw	r26, 0x2b	; 43
    2f14:	80 83       	st	Z, r24
    2f16:	9c 96       	adiw	r26, 0x2c	; 44
    2f18:	8c 91       	ld	r24, X
    2f1a:	9c 97       	sbiw	r26, 0x2c	; 44
    2f1c:	81 83       	std	Z+1, r24	; 0x01
    2f1e:	9d 96       	adiw	r26, 0x2d	; 45
    2f20:	8c 91       	ld	r24, X
    2f22:	82 83       	std	Z+2, r24	; 0x02
    2f24:	08 95       	ret

00002f26 <_ZN9MD_TCS23017RGBTransformationEv>:
  return(s);
}

void MD_TCS230::RGBTransformation(void)
// Exploiting linear relationship to remap the range 
{
    2f26:	4f 92       	push	r4
    2f28:	5f 92       	push	r5
    2f2a:	6f 92       	push	r6
    2f2c:	7f 92       	push	r7
    2f2e:	8f 92       	push	r8
    2f30:	9f 92       	push	r9
    2f32:	af 92       	push	r10
    2f34:	bf 92       	push	r11
    2f36:	df 92       	push	r13
    2f38:	ef 92       	push	r14
    2f3a:	ff 92       	push	r15
    2f3c:	0f 93       	push	r16
    2f3e:	1f 93       	push	r17
    2f40:	cf 93       	push	r28
    2f42:	df 93       	push	r29
    2f44:	8c 01       	movw	r16, r24
    2f46:	09 5f       	subi	r16, 0xF9	; 249
    2f48:	1f 4f       	sbci	r17, 0xFF	; 255
    2f4a:	ec 01       	movw	r28, r24
    2f4c:	7c 01       	movw	r14, r24
    2f4e:	83 e1       	ldi	r24, 0x13	; 19
    2f50:	e8 0e       	add	r14, r24
    2f52:	f1 1c       	adc	r15, r1
    x = (_Fo.value[i] - _Fd.value[i]) * 255;
    x /= (_Fw.value[i] - _Fd.value[i]);

    // copy results back into the global structures
    if (x < 0) _rgb.value[i] = 0; 
    else if (x > 255) _rgb.value[i] = 255;
    2f54:	dd 24       	eor	r13, r13
    2f56:	da 94       	dec	r13
    2f58:	f8 01       	movw	r30, r16
{
  int32_t x;

  for (uint8_t i=0; i<RGB_SIZE; i++)
  {
    x = (_Fo.value[i] - _Fd.value[i]) * 255;
    2f5a:	d8 01       	movw	r26, r16
    2f5c:	8d 90       	ld	r8, X+
    2f5e:	9d 90       	ld	r9, X+
    2f60:	ad 90       	ld	r10, X+
    2f62:	bd 90       	ld	r11, X+
    2f64:	8d 01       	movw	r16, r26
    2f66:	80 8d       	ldd	r24, Z+24	; 0x18
    2f68:	91 8d       	ldd	r25, Z+25	; 0x19
    2f6a:	a2 8d       	ldd	r26, Z+26	; 0x1a
    2f6c:	b3 8d       	ldd	r27, Z+27	; 0x1b
    2f6e:	9c 01       	movw	r18, r24
    2f70:	ad 01       	movw	r20, r26
    2f72:	28 19       	sub	r18, r8
    2f74:	39 09       	sbc	r19, r9
    2f76:	4a 09       	sbc	r20, r10
    2f78:	5b 09       	sbc	r21, r11
    2f7a:	af ef       	ldi	r26, 0xFF	; 255
    2f7c:	b0 e0       	ldi	r27, 0x00	; 0
    2f7e:	0e 94 0c 24 	call	0x4818	; 0x4818 <__muluhisi3>
    x /= (_Fw.value[i] - _Fd.value[i]);
    2f82:	f8 01       	movw	r30, r16
    2f84:	40 84       	ldd	r4, Z+8	; 0x08
    2f86:	51 84       	ldd	r5, Z+9	; 0x09
    2f88:	62 84       	ldd	r6, Z+10	; 0x0a
    2f8a:	73 84       	ldd	r7, Z+11	; 0x0b
    2f8c:	a3 01       	movw	r20, r6
    2f8e:	92 01       	movw	r18, r4
    2f90:	28 19       	sub	r18, r8
    2f92:	39 09       	sbc	r19, r9
    2f94:	4a 09       	sbc	r20, r10
    2f96:	5b 09       	sbc	r21, r11
    2f98:	0e 94 e7 23 	call	0x47ce	; 0x47ce <__divmodsi4>

    // copy results back into the global structures
    if (x < 0) _rgb.value[i] = 0; 
    2f9c:	57 ff       	sbrs	r21, 7
    2f9e:	02 c0       	rjmp	.+4      	; 0x2fa4 <_ZN9MD_TCS23017RGBTransformationEv+0x7e>
    2fa0:	1b a6       	std	Y+43, r1	; 0x2b
    2fa2:	09 c0       	rjmp	.+18     	; 0x2fb6 <_ZN9MD_TCS23017RGBTransformationEv+0x90>
    else if (x > 255) _rgb.value[i] = 255;
    2fa4:	2f 3f       	cpi	r18, 0xFF	; 255
    2fa6:	31 05       	cpc	r19, r1
    2fa8:	41 05       	cpc	r20, r1
    2faa:	51 05       	cpc	r21, r1
    2fac:	19 f0       	breq	.+6      	; 0x2fb4 <_ZN9MD_TCS23017RGBTransformationEv+0x8e>
    2fae:	14 f0       	brlt	.+4      	; 0x2fb4 <_ZN9MD_TCS23017RGBTransformationEv+0x8e>
    2fb0:	db a6       	std	Y+43, r13	; 0x2b
    2fb2:	01 c0       	rjmp	.+2      	; 0x2fb6 <_ZN9MD_TCS23017RGBTransformationEv+0x90>
    else _rgb.value[i] = x;
    2fb4:	2b a7       	std	Y+43, r18	; 0x2b
    2fb6:	21 96       	adiw	r28, 0x01	; 1
void MD_TCS230::RGBTransformation(void)
// Exploiting linear relationship to remap the range 
{
  int32_t x;

  for (uint8_t i=0; i<RGB_SIZE; i++)
    2fb8:	0e 15       	cp	r16, r14
    2fba:	1f 05       	cpc	r17, r15
    2fbc:	69 f6       	brne	.-102    	; 0x2f58 <_ZN9MD_TCS23017RGBTransformationEv+0x32>
    // copy results back into the global structures
    if (x < 0) _rgb.value[i] = 0; 
    else if (x > 255) _rgb.value[i] = 255;
    else _rgb.value[i] = x;
  }
}
    2fbe:	df 91       	pop	r29
    2fc0:	cf 91       	pop	r28
    2fc2:	1f 91       	pop	r17
    2fc4:	0f 91       	pop	r16
    2fc6:	ff 90       	pop	r15
    2fc8:	ef 90       	pop	r14
    2fca:	df 90       	pop	r13
    2fcc:	bf 90       	pop	r11
    2fce:	af 90       	pop	r10
    2fd0:	9f 90       	pop	r9
    2fd2:	8f 90       	pop	r8
    2fd4:	7f 90       	pop	r7
    2fd6:	6f 90       	pop	r6
    2fd8:	5f 90       	pop	r5
    2fda:	4f 90       	pop	r4
    2fdc:	08 95       	ret

00002fde <_ZN9MD_TCS2307readFSMEh>:
  return(_readState == 0);
}

uint8_t MD_TCS230::readFSM(uint8_t s)
// Finite State Machine to read a value (internal function)
{
    2fde:	0f 93       	push	r16
    2fe0:	1f 93       	push	r17
    2fe2:	cf 93       	push	r28
    2fe4:	df 93       	push	r29
    2fe6:	8c 01       	movw	r16, r24
    2fe8:	c6 2f       	mov	r28, r22
  static const uint8_t seq[] = { TCS230_RGB_R, TCS230_RGB_G, TCS230_RGB_B };
  static uint8_t       currCol;  // index for seq above

  switch(s)
    2fea:	61 30       	cpi	r22, 0x01	; 1
    2fec:	49 f0       	breq	.+18     	; 0x3000 <_ZN9MD_TCS2307readFSMEh+0x22>
    2fee:	18 f0       	brcs	.+6      	; 0x2ff6 <_ZN9MD_TCS2307readFSMEh+0x18>
    2ff0:	62 30       	cpi	r22, 0x02	; 2
    2ff2:	d9 f0       	breq	.+54     	; 0x302a <_ZN9MD_TCS2307readFSMEh+0x4c>
    2ff4:	4c c0       	rjmp	.+152    	; 0x308e <_ZN9MD_TCS2307readFSMEh+0xb0>
  {
  case 0: // enable the hardware for reading
    DUMPS("\n0");
    currCol = 0;  // RGB_R but we don't care
    2ff6:	10 92 de 03 	sts	0x03DE, r1	; 0x8003de <_ZZN9MD_TCS2307readFSMEhE7currCol>
    setEnable(true);
    2ffa:	61 e0       	ldi	r22, 0x01	; 1
    2ffc:	0e 94 47 17 	call	0x2e8e	; 0x2e8e <_ZN9MD_TCS2309setEnableEb>
    s++;
    // fall through to the next state

  case 1: // select a filter and start a reading
    DUMPS("\n1");
    setFilter(seq[currCol]);
    3000:	e0 91 de 03 	lds	r30, 0x03DE	; 0x8003de <_ZZN9MD_TCS2307readFSMEhE7currCol>
    3004:	f0 e0       	ldi	r31, 0x00	; 0
    3006:	e0 52       	subi	r30, 0x20	; 32
    3008:	fe 4f       	sbci	r31, 0xFE	; 254
    300a:	60 81       	ld	r22, Z
    300c:	c8 01       	movw	r24, r16
    300e:	0e 94 fb 16 	call	0x2df6	; 0x2df6 <_ZN9MD_TCS2309setFilterEh>
    FreqCount.begin(1000/_readDiv);
    3012:	f8 01       	movw	r30, r16
    3014:	65 81       	ldd	r22, Z+5	; 0x05
    3016:	70 e0       	ldi	r23, 0x00	; 0
    3018:	88 ee       	ldi	r24, 0xE8	; 232
    301a:	93 e0       	ldi	r25, 0x03	; 3
    301c:	0e 94 b1 23 	call	0x4762	; 0x4762 <__divmodhi4>
    3020:	cb 01       	movw	r24, r22
    3022:	0e 94 9a 22 	call	0x4534	; 0x4534 <_ZN14FreqCountClass5beginEj>
    s++;
    3026:	c2 e0       	ldi	r28, 0x02	; 2
    break;
    3028:	32 c0       	rjmp	.+100    	; 0x308e <_ZN9MD_TCS2307readFSMEh+0xb0>

  case 2: // see if a value is available
    DUMPS("2");
    if (FreqCount.available())
    302a:	0e 94 12 23 	call	0x4624	; 0x4624 <_ZN14FreqCountClass9availableEv>
    302e:	88 23       	and	r24, r24
    3030:	71 f1       	breq	.+92     	; 0x308e <_ZN9MD_TCS2307readFSMEh+0xb0>
    {
      DUMP(" VALUE ", FreqCount.read());
      // read the value and save it 
      _Fo.value[seq[currCol++]] = FreqCount.read() * _readDiv;
    3032:	e0 91 de 03 	lds	r30, 0x03DE	; 0x8003de <_ZZN9MD_TCS2307readFSMEhE7currCol>
    3036:	81 e0       	ldi	r24, 0x01	; 1
    3038:	8e 0f       	add	r24, r30
    303a:	80 93 de 03 	sts	0x03DE, r24	; 0x8003de <_ZZN9MD_TCS2307readFSMEhE7currCol>
    303e:	f0 e0       	ldi	r31, 0x00	; 0
    3040:	e0 52       	subi	r30, 0x20	; 32
    3042:	fe 4f       	sbci	r31, 0xFE	; 254
    3044:	c0 81       	ld	r28, Z
    3046:	d0 e0       	ldi	r29, 0x00	; 0
    3048:	0e 94 15 23 	call	0x462a	; 0x462a <_ZN14FreqCountClass4readEv>
    304c:	9b 01       	movw	r18, r22
    304e:	ac 01       	movw	r20, r24
    3050:	cc 0f       	add	r28, r28
    3052:	dd 1f       	adc	r29, r29
    3054:	cc 0f       	add	r28, r28
    3056:	dd 1f       	adc	r29, r29
    3058:	c0 0f       	add	r28, r16
    305a:	d1 1f       	adc	r29, r17
    305c:	f8 01       	movw	r30, r16
    305e:	a5 81       	ldd	r26, Z+5	; 0x05
    3060:	b0 e0       	ldi	r27, 0x00	; 0
    3062:	0e 94 0c 24 	call	0x4818	; 0x4818 <__muluhisi3>
    3066:	6f 8f       	std	Y+31, r22	; 0x1f
    3068:	78 a3       	std	Y+32, r23	; 0x20
    306a:	89 a3       	std	Y+33, r24	; 0x21
    306c:	9a a3       	std	Y+34, r25	; 0x22

      if (currCol < RGB_SIZE)
    306e:	80 91 de 03 	lds	r24, 0x03DE	; 0x8003de <_ZZN9MD_TCS2307readFSMEhE7currCol>
    3072:	83 30       	cpi	r24, 0x03	; 3
    3074:	58 f0       	brcs	.+22     	; 0x308c <_ZN9MD_TCS2307readFSMEh+0xae>
        s--;
      }
      else
      {
        // end this reading session
        FreqCount.end();
    3076:	0e 94 23 23 	call	0x4646	; 0x4646 <_ZN14FreqCountClass3endEv>
        setEnable(false);
    307a:	60 e0       	ldi	r22, 0x00	; 0
    307c:	c8 01       	movw	r24, r16
    307e:	0e 94 47 17 	call	0x2e8e	; 0x2e8e <_ZN9MD_TCS2309setEnableEb>
        RGBTransformation();
    3082:	c8 01       	movw	r24, r16
    3084:	0e 94 93 17 	call	0x2f26	; 0x2f26 <_ZN9MD_TCS23017RGBTransformationEv>
        s = 0;
    3088:	c0 e0       	ldi	r28, 0x00	; 0
    308a:	01 c0       	rjmp	.+2      	; 0x308e <_ZN9MD_TCS2307readFSMEh+0xb0>
      _Fo.value[seq[currCol++]] = FreqCount.read() * _readDiv;

      if (currCol < RGB_SIZE)
      {
        // loop around again on next call to available()
        s--;
    308c:	c1 e0       	ldi	r28, 0x01	; 1
    }
    break;
  }

  return(s);
}
    308e:	8c 2f       	mov	r24, r28
    3090:	df 91       	pop	r29
    3092:	cf 91       	pop	r28
    3094:	1f 91       	pop	r17
    3096:	0f 91       	pop	r16
    3098:	08 95       	ret

0000309a <_ZN9MD_TCS2304readEv>:
  return(FreqCount.read() * _readDiv);
}

void MD_TCS230::read(void)
// initiate the finite state machine for reading a value
{
    309a:	cf 93       	push	r28
    309c:	df 93       	push	r29
    309e:	ec 01       	movw	r28, r24
  _readState = readFSM(0);
    30a0:	60 e0       	ldi	r22, 0x00	; 0
    30a2:	0e 94 ef 17 	call	0x2fde	; 0x2fde <_ZN9MD_TCS2307readFSMEh>
    30a6:	8e a7       	std	Y+46, r24	; 0x2e
}
    30a8:	df 91       	pop	r29
    30aa:	cf 91       	pop	r28
    30ac:	08 95       	ret

000030ae <_ZN9MD_TCS2309availableEv>:

bool MD_TCS230::available(void)
// check if a value is ready. Called repeatedly until it is!
{
    30ae:	cf 93       	push	r28
    30b0:	df 93       	push	r29
    30b2:	ec 01       	movw	r28, r24
  _readState = readFSM(_readState);
    30b4:	6e a5       	ldd	r22, Y+46	; 0x2e
    30b6:	0e 94 ef 17 	call	0x2fde	; 0x2fde <_ZN9MD_TCS2307readFSMEh>
    30ba:	98 2f       	mov	r25, r24
    30bc:	8e a7       	std	Y+46, r24	; 0x2e

  return(_readState == 0);
    30be:	81 e0       	ldi	r24, 0x01	; 1
    30c0:	91 11       	cpse	r25, r1
    30c2:	80 e0       	ldi	r24, 0x00	; 0
}
    30c4:	df 91       	pop	r29
    30c6:	cf 91       	pop	r28
    30c8:	08 95       	ret

000030ca <_ZN5Print17availableForWriteEv>:
uint16_t SoftwareSerial::subtract_cap(uint16_t num, uint16_t sub) {
  if (num > sub)
    return num - sub;
  else
    return 1;
}
    30ca:	80 e0       	ldi	r24, 0x00	; 0
    30cc:	90 e0       	ldi	r25, 0x00	; 0
    30ce:	08 95       	ret

000030d0 <_ZN14SoftwareSerial4readEv>:
    30d0:	20 91 21 04 	lds	r18, 0x0421	; 0x800421 <_ZN14SoftwareSerial13active_objectE>
    30d4:	30 91 22 04 	lds	r19, 0x0422	; 0x800422 <_ZN14SoftwareSerial13active_objectE+0x1>
    30d8:	28 17       	cp	r18, r24
    30da:	39 07       	cpc	r19, r25
    30dc:	b9 f4       	brne	.+46     	; 0x310c <_ZN14SoftwareSerial4readEv+0x3c>
    30de:	90 91 df 03 	lds	r25, 0x03DF	; 0x8003df <_ZN14SoftwareSerial20_receive_buffer_headE>
    30e2:	80 91 e0 03 	lds	r24, 0x03E0	; 0x8003e0 <_ZN14SoftwareSerial20_receive_buffer_tailE>
    30e6:	98 17       	cp	r25, r24
    30e8:	89 f0       	breq	.+34     	; 0x310c <_ZN14SoftwareSerial4readEv+0x3c>
    30ea:	e0 91 df 03 	lds	r30, 0x03DF	; 0x8003df <_ZN14SoftwareSerial20_receive_buffer_headE>
    30ee:	f0 e0       	ldi	r31, 0x00	; 0
    30f0:	ef 51       	subi	r30, 0x1F	; 31
    30f2:	fc 4f       	sbci	r31, 0xFC	; 252
    30f4:	80 81       	ld	r24, Z
    30f6:	20 91 df 03 	lds	r18, 0x03DF	; 0x8003df <_ZN14SoftwareSerial20_receive_buffer_headE>
    30fa:	30 e0       	ldi	r19, 0x00	; 0
    30fc:	2f 5f       	subi	r18, 0xFF	; 255
    30fe:	3f 4f       	sbci	r19, 0xFF	; 255
    3100:	2f 73       	andi	r18, 0x3F	; 63
    3102:	33 27       	eor	r19, r19
    3104:	20 93 df 03 	sts	0x03DF, r18	; 0x8003df <_ZN14SoftwareSerial20_receive_buffer_headE>
    3108:	90 e0       	ldi	r25, 0x00	; 0
    310a:	08 95       	ret
    310c:	8f ef       	ldi	r24, 0xFF	; 255
    310e:	9f ef       	ldi	r25, 0xFF	; 255
    3110:	08 95       	ret

00003112 <_ZN14SoftwareSerial5writeEh>:
    3112:	1f 93       	push	r17
    3114:	cf 93       	push	r28
    3116:	df 93       	push	r29
    3118:	dc 01       	movw	r26, r24
    311a:	5c 96       	adiw	r26, 0x1c	; 28
    311c:	8d 91       	ld	r24, X+
    311e:	9c 91       	ld	r25, X
    3120:	5d 97       	sbiw	r26, 0x1d	; 29
    3122:	00 97       	sbiw	r24, 0x00	; 0
    3124:	39 f4       	brne	.+14     	; 0x3134 <_ZN14SoftwareSerial5writeEh+0x22>
    3126:	21 e0       	ldi	r18, 0x01	; 1
    3128:	30 e0       	ldi	r19, 0x00	; 0
    312a:	13 96       	adiw	r26, 0x03	; 3
    312c:	3c 93       	st	X, r19
    312e:	2e 93       	st	-X, r18
    3130:	12 97       	sbiw	r26, 0x02	; 2
    3132:	3b c0       	rjmp	.+118    	; 0x31aa <_ZN14SoftwareSerial5writeEh+0x98>
    3134:	51 96       	adiw	r26, 0x11	; 17
    3136:	ed 91       	ld	r30, X+
    3138:	fc 91       	ld	r31, X
    313a:	52 97       	sbiw	r26, 0x12	; 18
    313c:	50 96       	adiw	r26, 0x10	; 16
    313e:	2c 91       	ld	r18, X
    3140:	50 97       	sbiw	r26, 0x10	; 16
    3142:	32 2f       	mov	r19, r18
    3144:	30 95       	com	r19
    3146:	1f b7       	in	r17, 0x3f	; 63
    3148:	5e 96       	adiw	r26, 0x1e	; 30
    314a:	4c 91       	ld	r20, X
    314c:	5e 97       	sbiw	r26, 0x1e	; 30
    314e:	74 2f       	mov	r23, r20
    3150:	72 70       	andi	r23, 0x02	; 2
    3152:	41 fd       	sbrc	r20, 1
    3154:	60 95       	com	r22
    3156:	f8 94       	cli
    3158:	40 81       	ld	r20, Z
    315a:	77 23       	and	r23, r23
    315c:	11 f0       	breq	.+4      	; 0x3162 <_ZN14SoftwareSerial5writeEh+0x50>
    315e:	42 2b       	or	r20, r18
    3160:	01 c0       	rjmp	.+2      	; 0x3164 <_ZN14SoftwareSerial5writeEh+0x52>
    3162:	43 23       	and	r20, r19
    3164:	40 83       	st	Z, r20
    3166:	ec 01       	movw	r28, r24
    3168:	21 97       	sbiw	r28, 0x01	; 1
    316a:	f1 f7       	brne	.-4      	; 0x3168 <_ZN14SoftwareSerial5writeEh+0x56>
    316c:	48 e0       	ldi	r20, 0x08	; 8
    316e:	50 81       	ld	r21, Z
    3170:	60 ff       	sbrs	r22, 0
    3172:	02 c0       	rjmp	.+4      	; 0x3178 <_ZN14SoftwareSerial5writeEh+0x66>
    3174:	52 2b       	or	r21, r18
    3176:	01 c0       	rjmp	.+2      	; 0x317a <_ZN14SoftwareSerial5writeEh+0x68>
    3178:	53 23       	and	r21, r19
    317a:	50 83       	st	Z, r21
    317c:	ec 01       	movw	r28, r24
    317e:	21 97       	sbiw	r28, 0x01	; 1
    3180:	f1 f7       	brne	.-4      	; 0x317e <_ZN14SoftwareSerial5writeEh+0x6c>
    3182:	66 95       	lsr	r22
    3184:	41 50       	subi	r20, 0x01	; 1
    3186:	99 f7       	brne	.-26     	; 0x316e <_ZN14SoftwareSerial5writeEh+0x5c>
    3188:	80 81       	ld	r24, Z
    318a:	77 23       	and	r23, r23
    318c:	19 f0       	breq	.+6      	; 0x3194 <_ZN14SoftwareSerial5writeEh+0x82>
    318e:	83 23       	and	r24, r19
    3190:	80 83       	st	Z, r24
    3192:	02 c0       	rjmp	.+4      	; 0x3198 <_ZN14SoftwareSerial5writeEh+0x86>
    3194:	28 2b       	or	r18, r24
    3196:	20 83       	st	Z, r18
    3198:	1f bf       	out	0x3f, r17	; 63
    319a:	5c 96       	adiw	r26, 0x1c	; 28
    319c:	8d 91       	ld	r24, X+
    319e:	9c 91       	ld	r25, X
    31a0:	5d 97       	sbiw	r26, 0x1d	; 29
    31a2:	01 97       	sbiw	r24, 0x01	; 1
    31a4:	f1 f7       	brne	.-4      	; 0x31a2 <_ZN14SoftwareSerial5writeEh+0x90>
    31a6:	81 e0       	ldi	r24, 0x01	; 1
    31a8:	90 e0       	ldi	r25, 0x00	; 0
    31aa:	df 91       	pop	r29
    31ac:	cf 91       	pop	r28
    31ae:	1f 91       	pop	r17
    31b0:	08 95       	ret

000031b2 <_ZN14SoftwareSerial5flushEv>:
    31b2:	08 95       	ret

000031b4 <_ZN14SoftwareSerial4peekEv>:
    31b4:	20 91 21 04 	lds	r18, 0x0421	; 0x800421 <_ZN14SoftwareSerial13active_objectE>
    31b8:	30 91 22 04 	lds	r19, 0x0422	; 0x800422 <_ZN14SoftwareSerial13active_objectE+0x1>
    31bc:	28 17       	cp	r18, r24
    31be:	39 07       	cpc	r19, r25
    31c0:	71 f4       	brne	.+28     	; 0x31de <_ZN14SoftwareSerial4peekEv+0x2a>
    31c2:	90 91 df 03 	lds	r25, 0x03DF	; 0x8003df <_ZN14SoftwareSerial20_receive_buffer_headE>
    31c6:	80 91 e0 03 	lds	r24, 0x03E0	; 0x8003e0 <_ZN14SoftwareSerial20_receive_buffer_tailE>
    31ca:	98 17       	cp	r25, r24
    31cc:	41 f0       	breq	.+16     	; 0x31de <_ZN14SoftwareSerial4peekEv+0x2a>
    31ce:	e0 91 df 03 	lds	r30, 0x03DF	; 0x8003df <_ZN14SoftwareSerial20_receive_buffer_headE>
    31d2:	f0 e0       	ldi	r31, 0x00	; 0
    31d4:	ef 51       	subi	r30, 0x1F	; 31
    31d6:	fc 4f       	sbci	r31, 0xFC	; 252
    31d8:	80 81       	ld	r24, Z
    31da:	90 e0       	ldi	r25, 0x00	; 0
    31dc:	08 95       	ret
    31de:	8f ef       	ldi	r24, 0xFF	; 255
    31e0:	9f ef       	ldi	r25, 0xFF	; 255
    31e2:	08 95       	ret

000031e4 <_ZN14SoftwareSerial9availableEv>:
    31e4:	20 91 21 04 	lds	r18, 0x0421	; 0x800421 <_ZN14SoftwareSerial13active_objectE>
    31e8:	30 91 22 04 	lds	r19, 0x0422	; 0x800422 <_ZN14SoftwareSerial13active_objectE+0x1>
    31ec:	28 17       	cp	r18, r24
    31ee:	39 07       	cpc	r19, r25
    31f0:	71 f4       	brne	.+28     	; 0x320e <_ZN14SoftwareSerial9availableEv+0x2a>
    31f2:	80 91 e0 03 	lds	r24, 0x03E0	; 0x8003e0 <_ZN14SoftwareSerial20_receive_buffer_tailE>
    31f6:	20 91 df 03 	lds	r18, 0x03DF	; 0x8003df <_ZN14SoftwareSerial20_receive_buffer_headE>
    31fa:	90 e0       	ldi	r25, 0x00	; 0
    31fc:	80 5c       	subi	r24, 0xC0	; 192
    31fe:	9f 4f       	sbci	r25, 0xFF	; 255
    3200:	82 1b       	sub	r24, r18
    3202:	91 09       	sbc	r25, r1
    3204:	60 e4       	ldi	r22, 0x40	; 64
    3206:	70 e0       	ldi	r23, 0x00	; 0
    3208:	0e 94 b1 23 	call	0x4762	; 0x4762 <__divmodhi4>
    320c:	08 95       	ret
    320e:	80 e0       	ldi	r24, 0x00	; 0
    3210:	90 e0       	ldi	r25, 0x00	; 0
    3212:	08 95       	ret

00003214 <_ZN14SoftwareSerial13stopListeningEv>:
    3214:	e0 91 21 04 	lds	r30, 0x0421	; 0x800421 <_ZN14SoftwareSerial13active_objectE>
    3218:	f0 91 22 04 	lds	r31, 0x0422	; 0x800422 <_ZN14SoftwareSerial13active_objectE+0x1>
    321c:	e8 17       	cp	r30, r24
    321e:	f9 07       	cpc	r31, r25
    3220:	69 f4       	brne	.+26     	; 0x323c <_ZN14SoftwareSerial13stopListeningEv+0x28>
    3222:	a3 89       	ldd	r26, Z+19	; 0x13
    3224:	b4 89       	ldd	r27, Z+20	; 0x14
    3226:	9c 91       	ld	r25, X
    3228:	85 89       	ldd	r24, Z+21	; 0x15
    322a:	80 95       	com	r24
    322c:	89 23       	and	r24, r25
    322e:	8c 93       	st	X, r24
    3230:	10 92 22 04 	sts	0x0422, r1	; 0x800422 <_ZN14SoftwareSerial13active_objectE+0x1>
    3234:	10 92 21 04 	sts	0x0421, r1	; 0x800421 <_ZN14SoftwareSerial13active_objectE>
    3238:	81 e0       	ldi	r24, 0x01	; 1
    323a:	08 95       	ret
    323c:	80 e0       	ldi	r24, 0x00	; 0
    323e:	08 95       	ret

00003240 <_ZN14SoftwareSerial6listenEv>:
    3240:	cf 93       	push	r28
    3242:	df 93       	push	r29
    3244:	ec 01       	movw	r28, r24
    3246:	8a 8d       	ldd	r24, Y+26	; 0x1a
    3248:	9b 8d       	ldd	r25, Y+27	; 0x1b
    324a:	89 2b       	or	r24, r25
    324c:	f1 f0       	breq	.+60     	; 0x328a <_ZN14SoftwareSerial6listenEv+0x4a>
    324e:	80 91 21 04 	lds	r24, 0x0421	; 0x800421 <_ZN14SoftwareSerial13active_objectE>
    3252:	90 91 22 04 	lds	r25, 0x0422	; 0x800422 <_ZN14SoftwareSerial13active_objectE+0x1>
    3256:	c8 17       	cp	r28, r24
    3258:	d9 07       	cpc	r29, r25
    325a:	b9 f0       	breq	.+46     	; 0x328a <_ZN14SoftwareSerial6listenEv+0x4a>
    325c:	00 97       	sbiw	r24, 0x00	; 0
    325e:	11 f0       	breq	.+4      	; 0x3264 <_ZN14SoftwareSerial6listenEv+0x24>
    3260:	0e 94 0a 19 	call	0x3214	; 0x3214 <_ZN14SoftwareSerial13stopListeningEv>
    3264:	8e 8d       	ldd	r24, Y+30	; 0x1e
    3266:	8e 7f       	andi	r24, 0xFE	; 254
    3268:	8e 8f       	std	Y+30, r24	; 0x1e
    326a:	10 92 e0 03 	sts	0x03E0, r1	; 0x8003e0 <_ZN14SoftwareSerial20_receive_buffer_tailE>
    326e:	10 92 df 03 	sts	0x03DF, r1	; 0x8003df <_ZN14SoftwareSerial20_receive_buffer_headE>
    3272:	d0 93 22 04 	sts	0x0422, r29	; 0x800422 <_ZN14SoftwareSerial13active_objectE+0x1>
    3276:	c0 93 21 04 	sts	0x0421, r28	; 0x800421 <_ZN14SoftwareSerial13active_objectE>
    327a:	eb 89       	ldd	r30, Y+19	; 0x13
    327c:	fc 89       	ldd	r31, Y+20	; 0x14
    327e:	90 81       	ld	r25, Z
    3280:	8d 89       	ldd	r24, Y+21	; 0x15
    3282:	89 2b       	or	r24, r25
    3284:	80 83       	st	Z, r24
    3286:	81 e0       	ldi	r24, 0x01	; 1
    3288:	01 c0       	rjmp	.+2      	; 0x328c <_ZN14SoftwareSerial6listenEv+0x4c>
    328a:	80 e0       	ldi	r24, 0x00	; 0
    328c:	df 91       	pop	r29
    328e:	cf 91       	pop	r28
    3290:	08 95       	ret

00003292 <__vector_3>:
    3292:	1f 92       	push	r1
    3294:	0f 92       	push	r0
    3296:	0f b6       	in	r0, 0x3f	; 63
    3298:	0f 92       	push	r0
    329a:	11 24       	eor	r1, r1
    329c:	2f 93       	push	r18
    329e:	3f 93       	push	r19
    32a0:	4f 93       	push	r20
    32a2:	5f 93       	push	r21
    32a4:	6f 93       	push	r22
    32a6:	7f 93       	push	r23
    32a8:	8f 93       	push	r24
    32aa:	9f 93       	push	r25
    32ac:	af 93       	push	r26
    32ae:	bf 93       	push	r27
    32b0:	ef 93       	push	r30
    32b2:	ff 93       	push	r31
    32b4:	e0 91 21 04 	lds	r30, 0x0421	; 0x800421 <_ZN14SoftwareSerial13active_objectE>
    32b8:	f0 91 22 04 	lds	r31, 0x0422	; 0x800422 <_ZN14SoftwareSerial13active_objectE+0x1>
    32bc:	30 97       	sbiw	r30, 0x00	; 0
    32be:	09 f4       	brne	.+2      	; 0x32c2 <__vector_3+0x30>
    32c0:	51 c0       	rjmp	.+162    	; 0x3364 <__vector_3+0xd2>
    32c2:	96 8d       	ldd	r25, Z+30	; 0x1e
    32c4:	a6 85       	ldd	r26, Z+14	; 0x0e
    32c6:	b7 85       	ldd	r27, Z+15	; 0x0f
    32c8:	85 85       	ldd	r24, Z+13	; 0x0d
    32ca:	91 ff       	sbrs	r25, 1
    32cc:	04 c0       	rjmp	.+8      	; 0x32d6 <__vector_3+0x44>
    32ce:	9c 91       	ld	r25, X
    32d0:	89 23       	and	r24, r25
    32d2:	29 f4       	brne	.+10     	; 0x32de <__vector_3+0x4c>
    32d4:	47 c0       	rjmp	.+142    	; 0x3364 <__vector_3+0xd2>
    32d6:	9c 91       	ld	r25, X
    32d8:	89 23       	and	r24, r25
    32da:	09 f0       	breq	.+2      	; 0x32de <__vector_3+0x4c>
    32dc:	43 c0       	rjmp	.+134    	; 0x3364 <__vector_3+0xd2>
    32de:	a3 89       	ldd	r26, Z+19	; 0x13
    32e0:	b4 89       	ldd	r27, Z+20	; 0x14
    32e2:	9c 91       	ld	r25, X
    32e4:	85 89       	ldd	r24, Z+21	; 0x15
    32e6:	80 95       	com	r24
    32e8:	89 23       	and	r24, r25
    32ea:	8c 93       	st	X, r24
    32ec:	86 89       	ldd	r24, Z+22	; 0x16
    32ee:	97 89       	ldd	r25, Z+23	; 0x17
    32f0:	01 97       	sbiw	r24, 0x01	; 1
    32f2:	f1 f7       	brne	.-4      	; 0x32f0 <__vector_3+0x5e>
    32f4:	60 8d       	ldd	r22, Z+24	; 0x18
    32f6:	71 8d       	ldd	r23, Z+25	; 0x19
    32f8:	a6 85       	ldd	r26, Z+14	; 0x0e
    32fa:	b7 85       	ldd	r27, Z+15	; 0x0f
    32fc:	55 85       	ldd	r21, Z+13	; 0x0d
    32fe:	38 e0       	ldi	r19, 0x08	; 8
    3300:	20 e0       	ldi	r18, 0x00	; 0
    3302:	cb 01       	movw	r24, r22
    3304:	01 97       	sbiw	r24, 0x01	; 1
    3306:	f1 f7       	brne	.-4      	; 0x3304 <__vector_3+0x72>
    3308:	82 2f       	mov	r24, r18
    330a:	90 e0       	ldi	r25, 0x00	; 0
    330c:	95 95       	asr	r25
    330e:	87 95       	ror	r24
    3310:	28 2f       	mov	r18, r24
    3312:	4c 91       	ld	r20, X
    3314:	45 23       	and	r20, r21
    3316:	09 f0       	breq	.+2      	; 0x331a <__vector_3+0x88>
    3318:	20 68       	ori	r18, 0x80	; 128
    331a:	31 50       	subi	r19, 0x01	; 1
    331c:	91 f7       	brne	.-28     	; 0x3302 <__vector_3+0x70>
    331e:	86 8d       	ldd	r24, Z+30	; 0x1e
    3320:	81 fd       	sbrc	r24, 1
    3322:	20 95       	com	r18
    3324:	80 91 e0 03 	lds	r24, 0x03E0	; 0x8003e0 <_ZN14SoftwareSerial20_receive_buffer_tailE>
    3328:	90 e0       	ldi	r25, 0x00	; 0
    332a:	01 96       	adiw	r24, 0x01	; 1
    332c:	8f 73       	andi	r24, 0x3F	; 63
    332e:	99 27       	eor	r25, r25
    3330:	30 91 df 03 	lds	r19, 0x03DF	; 0x8003df <_ZN14SoftwareSerial20_receive_buffer_headE>
    3334:	38 17       	cp	r19, r24
    3336:	49 f0       	breq	.+18     	; 0x334a <__vector_3+0xb8>
    3338:	a0 91 e0 03 	lds	r26, 0x03E0	; 0x8003e0 <_ZN14SoftwareSerial20_receive_buffer_tailE>
    333c:	b0 e0       	ldi	r27, 0x00	; 0
    333e:	af 51       	subi	r26, 0x1F	; 31
    3340:	bc 4f       	sbci	r27, 0xFC	; 252
    3342:	2c 93       	st	X, r18
    3344:	80 93 e0 03 	sts	0x03E0, r24	; 0x8003e0 <_ZN14SoftwareSerial20_receive_buffer_tailE>
    3348:	03 c0       	rjmp	.+6      	; 0x3350 <__vector_3+0xbe>
    334a:	86 8d       	ldd	r24, Z+30	; 0x1e
    334c:	81 60       	ori	r24, 0x01	; 1
    334e:	86 8f       	std	Z+30, r24	; 0x1e
    3350:	82 8d       	ldd	r24, Z+26	; 0x1a
    3352:	93 8d       	ldd	r25, Z+27	; 0x1b
    3354:	01 97       	sbiw	r24, 0x01	; 1
    3356:	f1 f7       	brne	.-4      	; 0x3354 <__vector_3+0xc2>
    3358:	a3 89       	ldd	r26, Z+19	; 0x13
    335a:	b4 89       	ldd	r27, Z+20	; 0x14
    335c:	9c 91       	ld	r25, X
    335e:	85 89       	ldd	r24, Z+21	; 0x15
    3360:	89 2b       	or	r24, r25
    3362:	8c 93       	st	X, r24
    3364:	ff 91       	pop	r31
    3366:	ef 91       	pop	r30
    3368:	bf 91       	pop	r27
    336a:	af 91       	pop	r26
    336c:	9f 91       	pop	r25
    336e:	8f 91       	pop	r24
    3370:	7f 91       	pop	r23
    3372:	6f 91       	pop	r22
    3374:	5f 91       	pop	r21
    3376:	4f 91       	pop	r20
    3378:	3f 91       	pop	r19
    337a:	2f 91       	pop	r18
    337c:	0f 90       	pop	r0
    337e:	0f be       	out	0x3f, r0	; 63
    3380:	0f 90       	pop	r0
    3382:	1f 90       	pop	r1
    3384:	18 95       	reti

00003386 <_ZN14SoftwareSerialD1Ev>:
    3386:	27 ee       	ldi	r18, 0xE7	; 231
    3388:	31 e0       	ldi	r19, 0x01	; 1
    338a:	fc 01       	movw	r30, r24
    338c:	31 83       	std	Z+1, r19	; 0x01
    338e:	20 83       	st	Z, r18
    3390:	0c 94 0a 19 	jmp	0x3214	; 0x3214 <_ZN14SoftwareSerial13stopListeningEv>

00003394 <_ZN14SoftwareSerial5setTXEh>:
    3394:	1f 93       	push	r17
    3396:	cf 93       	push	r28
    3398:	df 93       	push	r29
    339a:	ec 01       	movw	r28, r24
    339c:	16 2f       	mov	r17, r22
    339e:	6e 8d       	ldd	r22, Y+30	; 0x1e
    33a0:	66 95       	lsr	r22
    33a2:	61 70       	andi	r22, 0x01	; 1
    33a4:	81 e0       	ldi	r24, 0x01	; 1
    33a6:	68 27       	eor	r22, r24
    33a8:	81 2f       	mov	r24, r17
    33aa:	0e 94 6b 22 	call	0x44d6	; 0x44d6 <digitalWrite>
    33ae:	61 e0       	ldi	r22, 0x01	; 1
    33b0:	81 2f       	mov	r24, r17
    33b2:	0e 94 2f 22 	call	0x445e	; 0x445e <pinMode>
    33b6:	81 2f       	mov	r24, r17
    33b8:	90 e0       	ldi	r25, 0x00	; 0
    33ba:	fc 01       	movw	r30, r24
    33bc:	ea 53       	subi	r30, 0x3A	; 58
    33be:	ff 4f       	sbci	r31, 0xFF	; 255
    33c0:	e4 91       	lpm	r30, Z
    33c2:	e8 8b       	std	Y+16, r30	; 0x10
    33c4:	fc 01       	movw	r30, r24
    33c6:	e6 52       	subi	r30, 0x26	; 38
    33c8:	ff 4f       	sbci	r31, 0xFF	; 255
    33ca:	e4 91       	lpm	r30, Z
    33cc:	f0 e0       	ldi	r31, 0x00	; 0
    33ce:	ee 0f       	add	r30, r30
    33d0:	ff 1f       	adc	r31, r31
    33d2:	e8 50       	subi	r30, 0x08	; 8
    33d4:	ff 4f       	sbci	r31, 0xFF	; 255
    33d6:	85 91       	lpm	r24, Z+
    33d8:	94 91       	lpm	r25, Z
    33da:	9a 8b       	std	Y+18, r25	; 0x12
    33dc:	89 8b       	std	Y+17, r24	; 0x11
    33de:	df 91       	pop	r29
    33e0:	cf 91       	pop	r28
    33e2:	1f 91       	pop	r17
    33e4:	08 95       	ret

000033e6 <_ZN14SoftwareSerial5setRXEh>:
    33e6:	1f 93       	push	r17
    33e8:	cf 93       	push	r28
    33ea:	df 93       	push	r29
    33ec:	ec 01       	movw	r28, r24
    33ee:	16 2f       	mov	r17, r22
    33f0:	60 e0       	ldi	r22, 0x00	; 0
    33f2:	81 2f       	mov	r24, r17
    33f4:	0e 94 2f 22 	call	0x445e	; 0x445e <pinMode>
    33f8:	8e 8d       	ldd	r24, Y+30	; 0x1e
    33fa:	81 fd       	sbrc	r24, 1
    33fc:	04 c0       	rjmp	.+8      	; 0x3406 <_ZN14SoftwareSerial5setRXEh+0x20>
    33fe:	61 e0       	ldi	r22, 0x01	; 1
    3400:	81 2f       	mov	r24, r17
    3402:	0e 94 6b 22 	call	0x44d6	; 0x44d6 <digitalWrite>
    3406:	1c 87       	std	Y+12, r17	; 0x0c
    3408:	81 2f       	mov	r24, r17
    340a:	90 e0       	ldi	r25, 0x00	; 0
    340c:	fc 01       	movw	r30, r24
    340e:	ea 53       	subi	r30, 0x3A	; 58
    3410:	ff 4f       	sbci	r31, 0xFF	; 255
    3412:	e4 91       	lpm	r30, Z
    3414:	ed 87       	std	Y+13, r30	; 0x0d
    3416:	fc 01       	movw	r30, r24
    3418:	e6 52       	subi	r30, 0x26	; 38
    341a:	ff 4f       	sbci	r31, 0xFF	; 255
    341c:	e4 91       	lpm	r30, Z
    341e:	f0 e0       	ldi	r31, 0x00	; 0
    3420:	ee 0f       	add	r30, r30
    3422:	ff 1f       	adc	r31, r31
    3424:	e2 51       	subi	r30, 0x12	; 18
    3426:	ff 4f       	sbci	r31, 0xFF	; 255
    3428:	85 91       	lpm	r24, Z+
    342a:	94 91       	lpm	r25, Z
    342c:	9f 87       	std	Y+15, r25	; 0x0f
    342e:	8e 87       	std	Y+14, r24	; 0x0e
    3430:	df 91       	pop	r29
    3432:	cf 91       	pop	r28
    3434:	1f 91       	pop	r17
    3436:	08 95       	ret

00003438 <_ZN14SoftwareSerialC1Ehhb>:
    3438:	1f 93       	push	r17
    343a:	cf 93       	push	r28
    343c:	df 93       	push	r29
    343e:	ec 01       	movw	r28, r24
    3440:	16 2f       	mov	r17, r22
    3442:	1b 82       	std	Y+3, r1	; 0x03
    3444:	1a 82       	std	Y+2, r1	; 0x02
    3446:	88 ee       	ldi	r24, 0xE8	; 232
    3448:	93 e0       	ldi	r25, 0x03	; 3
    344a:	a0 e0       	ldi	r26, 0x00	; 0
    344c:	b0 e0       	ldi	r27, 0x00	; 0
    344e:	8c 83       	std	Y+4, r24	; 0x04
    3450:	9d 83       	std	Y+5, r25	; 0x05
    3452:	ae 83       	std	Y+6, r26	; 0x06
    3454:	bf 83       	std	Y+7, r27	; 0x07
    3456:	87 ee       	ldi	r24, 0xE7	; 231
    3458:	91 e0       	ldi	r25, 0x01	; 1
    345a:	99 83       	std	Y+1, r25	; 0x01
    345c:	88 83       	st	Y, r24
    345e:	1f 8a       	std	Y+23, r1	; 0x17
    3460:	1e 8a       	std	Y+22, r1	; 0x16
    3462:	19 8e       	std	Y+25, r1	; 0x19
    3464:	18 8e       	std	Y+24, r1	; 0x18
    3466:	1b 8e       	std	Y+27, r1	; 0x1b
    3468:	1a 8e       	std	Y+26, r1	; 0x1a
    346a:	1d 8e       	std	Y+29, r1	; 0x1d
    346c:	1c 8e       	std	Y+28, r1	; 0x1c
    346e:	8e 8d       	ldd	r24, Y+30	; 0x1e
    3470:	8e 7f       	andi	r24, 0xFE	; 254
    3472:	20 fb       	bst	r18, 0
    3474:	81 f9       	bld	r24, 1
    3476:	8e 8f       	std	Y+30, r24	; 0x1e
    3478:	64 2f       	mov	r22, r20
    347a:	ce 01       	movw	r24, r28
    347c:	0e 94 ca 19 	call	0x3394	; 0x3394 <_ZN14SoftwareSerial5setTXEh>
    3480:	61 2f       	mov	r22, r17
    3482:	ce 01       	movw	r24, r28
    3484:	df 91       	pop	r29
    3486:	cf 91       	pop	r28
    3488:	1f 91       	pop	r17
    348a:	0c 94 f3 19 	jmp	0x33e6	; 0x33e6 <_ZN14SoftwareSerial5setRXEh>

0000348e <_ZN14SoftwareSerial5beginEl>:
//
// Public methods
//

void SoftwareSerial::begin(long speed)
{
    348e:	cf 93       	push	r28
    3490:	df 93       	push	r29
    3492:	ec 01       	movw	r28, r24
    3494:	9a 01       	movw	r18, r20
    3496:	ab 01       	movw	r20, r22
  _rx_delay_centering = _rx_delay_intrabit = _rx_delay_stopbit = _tx_delay = 0;
    3498:	1b 8e       	std	Y+27, r1	; 0x1b
    349a:	1a 8e       	std	Y+26, r1	; 0x1a
    349c:	19 8e       	std	Y+25, r1	; 0x19
    349e:	18 8e       	std	Y+24, r1	; 0x18
    34a0:	1f 8a       	std	Y+23, r1	; 0x17
    34a2:	1e 8a       	std	Y+22, r1	; 0x16

  // Precalculate the various delays, in number of 4-cycle delays
  uint16_t bit_delay = (F_CPU / speed) / 4;
    34a4:	60 e0       	ldi	r22, 0x00	; 0
    34a6:	79 e0       	ldi	r23, 0x09	; 9
    34a8:	8d e3       	ldi	r24, 0x3D	; 61
    34aa:	90 e0       	ldi	r25, 0x00	; 0
    34ac:	0e 94 e7 23 	call	0x47ce	; 0x47ce <__divmodsi4>
    34b0:	f9 01       	movw	r30, r18
  uint8_t port = digitalPinToPort(rx);
  _receivePortRegister = portInputRegister(port);
}

uint16_t SoftwareSerial::subtract_cap(uint16_t num, uint16_t sub) {
  if (num > sub)
    34b2:	24 30       	cpi	r18, 0x04	; 4
    34b4:	31 05       	cpc	r19, r1
    34b6:	18 f0       	brcs	.+6      	; 0x34be <_ZN14SoftwareSerial5beginEl+0x30>
    return num - sub;
    34b8:	c9 01       	movw	r24, r18
    34ba:	03 97       	sbiw	r24, 0x03	; 3
    34bc:	02 c0       	rjmp	.+4      	; 0x34c2 <_ZN14SoftwareSerial5beginEl+0x34>
  else
    return 1;
    34be:	81 e0       	ldi	r24, 0x01	; 1
    34c0:	90 e0       	ldi	r25, 0x00	; 0
  // 12 (gcc 4.8.2) or 13 (gcc 4.3.2) cycles from start bit to first bit,
  // 15 (gcc 4.8.2) or 16 (gcc 4.3.2) cycles between bits,
  // 12 (gcc 4.8.2) or 14 (gcc 4.3.2) cycles from last bit to stop bit
  // These are all close enough to just use 15 cycles, since the inter-bit
  // timings are the most critical (deviations stack 8 times)
  _tx_delay = subtract_cap(bit_delay, 15 / 4);
    34c2:	9d 8f       	std	Y+29, r25	; 0x1d
    34c4:	8c 8f       	std	Y+28, r24	; 0x1c

  // Only setup rx when we have a valid PCINT for this pin
  if (digitalPinToPCICR(_receivePin)) {
    34c6:	6c 85       	ldd	r22, Y+12	; 0x0c
    34c8:	66 31       	cpi	r22, 0x16	; 22
    34ca:	08 f0       	brcs	.+2      	; 0x34ce <_ZN14SoftwareSerial5beginEl+0x40>
    34cc:	69 c0       	rjmp	.+210    	; 0x35a0 <_ZN14SoftwareSerial5beginEl+0x112>
    // are 17 more cycles until the pin value is read (excluding the
    // delay in the loop).
    // We want to have a total delay of 1.5 bit time. Inside the loop,
    // we already wait for 1 bit time - 23 cycles, so here we wait for
    // 0.5 bit time - (71 + 18 - 22) cycles.
    _rx_delay_centering = subtract_cap(bit_delay / 2, (4 + 4 + 75 + 17 - 23) / 4);
    34ce:	c9 01       	movw	r24, r18
    34d0:	96 95       	lsr	r25
    34d2:	87 95       	ror	r24
  uint8_t port = digitalPinToPort(rx);
  _receivePortRegister = portInputRegister(port);
}

uint16_t SoftwareSerial::subtract_cap(uint16_t num, uint16_t sub) {
  if (num > sub)
    34d4:	84 31       	cpi	r24, 0x14	; 20
    34d6:	91 05       	cpc	r25, r1
    34d8:	10 f0       	brcs	.+4      	; 0x34de <_ZN14SoftwareSerial5beginEl+0x50>
    return num - sub;
    34da:	43 97       	sbiw	r24, 0x13	; 19
    34dc:	02 c0       	rjmp	.+4      	; 0x34e2 <_ZN14SoftwareSerial5beginEl+0x54>
  else
    return 1;
    34de:	81 e0       	ldi	r24, 0x01	; 1
    34e0:	90 e0       	ldi	r25, 0x00	; 0
    // are 17 more cycles until the pin value is read (excluding the
    // delay in the loop).
    // We want to have a total delay of 1.5 bit time. Inside the loop,
    // we already wait for 1 bit time - 23 cycles, so here we wait for
    // 0.5 bit time - (71 + 18 - 22) cycles.
    _rx_delay_centering = subtract_cap(bit_delay / 2, (4 + 4 + 75 + 17 - 23) / 4);
    34e2:	9f 8b       	std	Y+23, r25	; 0x17
    34e4:	8e 8b       	std	Y+22, r24	; 0x16
  uint8_t port = digitalPinToPort(rx);
  _receivePortRegister = portInputRegister(port);
}

uint16_t SoftwareSerial::subtract_cap(uint16_t num, uint16_t sub) {
  if (num > sub)
    34e6:	36 97       	sbiw	r30, 0x06	; 6
    34e8:	18 f0       	brcs	.+6      	; 0x34f0 <_ZN14SoftwareSerial5beginEl+0x62>
    return num - sub;
    34ea:	c9 01       	movw	r24, r18
    34ec:	05 97       	sbiw	r24, 0x05	; 5
    34ee:	02 c0       	rjmp	.+4      	; 0x34f4 <_ZN14SoftwareSerial5beginEl+0x66>
  else
    return 1;
    34f0:	81 e0       	ldi	r24, 0x01	; 1
    34f2:	90 e0       	ldi	r25, 0x00	; 0
    // we already wait for 1 bit time - 23 cycles, so here we wait for
    // 0.5 bit time - (71 + 18 - 22) cycles.
    _rx_delay_centering = subtract_cap(bit_delay / 2, (4 + 4 + 75 + 17 - 23) / 4);

    // There are 23 cycles in each loop iteration (excluding the delay)
    _rx_delay_intrabit = subtract_cap(bit_delay, 23 / 4);
    34f4:	99 8f       	std	Y+25, r25	; 0x19
    34f6:	88 8f       	std	Y+24, r24	; 0x18
    // mask is enabled again (which _must_ happen during the stopbit).
    // This delay aims at 3/4 of a bit time, meaning the end of the
    // delay will be at 1/4th of the stopbit. This allows some extra
    // time for ISR cleanup, which makes 115200 baud at 16Mhz work more
    // reliably
    _rx_delay_stopbit = subtract_cap(bit_delay * 3 / 4, (37 + 11) / 4);
    34f8:	c9 01       	movw	r24, r18
    34fa:	88 0f       	add	r24, r24
    34fc:	99 1f       	adc	r25, r25
    34fe:	28 0f       	add	r18, r24
    3500:	39 1f       	adc	r19, r25
    3502:	36 95       	lsr	r19
    3504:	27 95       	ror	r18
    3506:	36 95       	lsr	r19
    3508:	27 95       	ror	r18
  uint8_t port = digitalPinToPort(rx);
  _receivePortRegister = portInputRegister(port);
}

uint16_t SoftwareSerial::subtract_cap(uint16_t num, uint16_t sub) {
  if (num > sub)
    350a:	2d 30       	cpi	r18, 0x0D	; 13
    350c:	31 05       	cpc	r19, r1
    350e:	18 f0       	brcs	.+6      	; 0x3516 <_ZN14SoftwareSerial5beginEl+0x88>
    return num - sub;
    3510:	2c 50       	subi	r18, 0x0C	; 12
    3512:	31 09       	sbc	r19, r1
    3514:	02 c0       	rjmp	.+4      	; 0x351a <_ZN14SoftwareSerial5beginEl+0x8c>
  else
    return 1;
    3516:	21 e0       	ldi	r18, 0x01	; 1
    3518:	30 e0       	ldi	r19, 0x00	; 0
    // mask is enabled again (which _must_ happen during the stopbit).
    // This delay aims at 3/4 of a bit time, meaning the end of the
    // delay will be at 1/4th of the stopbit. This allows some extra
    // time for ISR cleanup, which makes 115200 baud at 16Mhz work more
    // reliably
    _rx_delay_stopbit = subtract_cap(bit_delay * 3 / 4, (37 + 11) / 4);
    351a:	3b 8f       	std	Y+27, r19	; 0x1b
    351c:	2a 8f       	std	Y+26, r18	; 0x1a


    // Enable the PCINT for the entire port here, but never disable it
    // (others might also need it, so we disable the interrupt by using
    // the per-pin PCMSK register).
    *digitalPinToPCICR(_receivePin) |= _BV(digitalPinToPCICRbit(_receivePin));
    351e:	90 91 68 00 	lds	r25, 0x0068	; 0x800068 <__DATA_REGION_ORIGIN__+0x8>
    3522:	68 30       	cpi	r22, 0x08	; 8
    3524:	50 f0       	brcs	.+20     	; 0x353a <_ZN14SoftwareSerial5beginEl+0xac>
    3526:	21 e0       	ldi	r18, 0x01	; 1
    3528:	6e 30       	cpi	r22, 0x0E	; 14
    352a:	08 f4       	brcc	.+2      	; 0x352e <_ZN14SoftwareSerial5beginEl+0xa0>
    352c:	20 e0       	ldi	r18, 0x00	; 0
    352e:	81 e0       	ldi	r24, 0x01	; 1
    3530:	01 c0       	rjmp	.+2      	; 0x3534 <_ZN14SoftwareSerial5beginEl+0xa6>
    3532:	88 0f       	add	r24, r24
    3534:	2a 95       	dec	r18
    3536:	ea f7       	brpl	.-6      	; 0x3532 <_ZN14SoftwareSerial5beginEl+0xa4>
    3538:	01 c0       	rjmp	.+2      	; 0x353c <_ZN14SoftwareSerial5beginEl+0xae>
    353a:	84 e0       	ldi	r24, 0x04	; 4
    353c:	89 2b       	or	r24, r25
    353e:	80 93 68 00 	sts	0x0068, r24	; 0x800068 <__DATA_REGION_ORIGIN__+0x8>
    // Precalculate the pcint mask register and value, so setRxIntMask
    // can be used inside the ISR without costing too much time.
    _pcint_maskreg = digitalPinToPCMSK(_receivePin);
    3542:	9c 85       	ldd	r25, Y+12	; 0x0c
    3544:	98 30       	cpi	r25, 0x08	; 8
    3546:	38 f0       	brcs	.+14     	; 0x3556 <_ZN14SoftwareSerial5beginEl+0xc8>
    3548:	9e 30       	cpi	r25, 0x0E	; 14
    354a:	40 f0       	brcs	.+16     	; 0x355c <_ZN14SoftwareSerial5beginEl+0xce>
    354c:	96 31       	cpi	r25, 0x16	; 22
    354e:	48 f0       	brcs	.+18     	; 0x3562 <_ZN14SoftwareSerial5beginEl+0xd4>
    3550:	20 e0       	ldi	r18, 0x00	; 0
    3552:	30 e0       	ldi	r19, 0x00	; 0
    3554:	08 c0       	rjmp	.+16     	; 0x3566 <_ZN14SoftwareSerial5beginEl+0xd8>
    3556:	2d e6       	ldi	r18, 0x6D	; 109
    3558:	30 e0       	ldi	r19, 0x00	; 0
    355a:	05 c0       	rjmp	.+10     	; 0x3566 <_ZN14SoftwareSerial5beginEl+0xd8>
    355c:	2b e6       	ldi	r18, 0x6B	; 107
    355e:	30 e0       	ldi	r19, 0x00	; 0
    3560:	02 c0       	rjmp	.+4      	; 0x3566 <_ZN14SoftwareSerial5beginEl+0xd8>
    3562:	2c e6       	ldi	r18, 0x6C	; 108
    3564:	30 e0       	ldi	r19, 0x00	; 0
    3566:	3c 8b       	std	Y+20, r19	; 0x14
    3568:	2b 8b       	std	Y+19, r18	; 0x13
    _pcint_maskvalue = _BV(digitalPinToPCMSKbit(_receivePin));
    356a:	98 30       	cpi	r25, 0x08	; 8
    356c:	30 f4       	brcc	.+12     	; 0x357a <_ZN14SoftwareSerial5beginEl+0xec>
    356e:	81 e0       	ldi	r24, 0x01	; 1
    3570:	01 c0       	rjmp	.+2      	; 0x3574 <_ZN14SoftwareSerial5beginEl+0xe6>
    3572:	88 0f       	add	r24, r24
    3574:	9a 95       	dec	r25
    3576:	ea f7       	brpl	.-6      	; 0x3572 <_ZN14SoftwareSerial5beginEl+0xe4>
    3578:	0e c0       	rjmp	.+28     	; 0x3596 <_ZN14SoftwareSerial5beginEl+0x108>
    357a:	29 2f       	mov	r18, r25
    357c:	30 e0       	ldi	r19, 0x00	; 0
    357e:	9e 30       	cpi	r25, 0x0E	; 14
    3580:	18 f4       	brcc	.+6      	; 0x3588 <_ZN14SoftwareSerial5beginEl+0xfa>
    3582:	28 50       	subi	r18, 0x08	; 8
    3584:	31 09       	sbc	r19, r1
    3586:	02 c0       	rjmp	.+4      	; 0x358c <_ZN14SoftwareSerial5beginEl+0xfe>
    3588:	2e 50       	subi	r18, 0x0E	; 14
    358a:	31 09       	sbc	r19, r1
    358c:	81 e0       	ldi	r24, 0x01	; 1
    358e:	01 c0       	rjmp	.+2      	; 0x3592 <_ZN14SoftwareSerial5beginEl+0x104>
    3590:	88 0f       	add	r24, r24
    3592:	2a 95       	dec	r18
    3594:	ea f7       	brpl	.-6      	; 0x3590 <_ZN14SoftwareSerial5beginEl+0x102>
    3596:	8d 8b       	std	Y+21, r24	; 0x15
	__asm__ volatile (
		"1: sbiw %0,1" "\n\t"
		"brne 1b"
		: "=w" (__count)
		: "0" (__count)
	);
    3598:	8c 8d       	ldd	r24, Y+28	; 0x1c
    359a:	9d 8d       	ldd	r25, Y+29	; 0x1d
    359c:	01 97       	sbiw	r24, 0x01	; 1
    359e:	f1 f7       	brne	.-4      	; 0x359c <_ZN14SoftwareSerial5beginEl+0x10e>
#if _DEBUG
  pinMode(_DEBUG_PIN1, OUTPUT);
  pinMode(_DEBUG_PIN2, OUTPUT);
#endif

  listen();
    35a0:	ce 01       	movw	r24, r28
}
    35a2:	df 91       	pop	r29
    35a4:	cf 91       	pop	r28
#if _DEBUG
  pinMode(_DEBUG_PIN1, OUTPUT);
  pinMode(_DEBUG_PIN2, OUTPUT);
#endif

  listen();
    35a6:	0c 94 20 19 	jmp	0x3240	; 0x3240 <_ZN14SoftwareSerial6listenEv>

000035aa <__subsf3>:
    35aa:	50 58       	subi	r21, 0x80	; 128

000035ac <__addsf3>:
    35ac:	bb 27       	eor	r27, r27
    35ae:	aa 27       	eor	r26, r26
    35b0:	0e 94 ed 1a 	call	0x35da	; 0x35da <__addsf3x>
    35b4:	0c 94 67 1c 	jmp	0x38ce	; 0x38ce <__fp_round>
    35b8:	0e 94 59 1c 	call	0x38b2	; 0x38b2 <__fp_pscA>
    35bc:	38 f0       	brcs	.+14     	; 0x35cc <__addsf3+0x20>
    35be:	0e 94 60 1c 	call	0x38c0	; 0x38c0 <__fp_pscB>
    35c2:	20 f0       	brcs	.+8      	; 0x35cc <__addsf3+0x20>
    35c4:	39 f4       	brne	.+14     	; 0x35d4 <__addsf3+0x28>
    35c6:	9f 3f       	cpi	r25, 0xFF	; 255
    35c8:	19 f4       	brne	.+6      	; 0x35d0 <__addsf3+0x24>
    35ca:	26 f4       	brtc	.+8      	; 0x35d4 <__addsf3+0x28>
    35cc:	0c 94 56 1c 	jmp	0x38ac	; 0x38ac <__fp_nan>
    35d0:	0e f4       	brtc	.+2      	; 0x35d4 <__addsf3+0x28>
    35d2:	e0 95       	com	r30
    35d4:	e7 fb       	bst	r30, 7
    35d6:	0c 94 50 1c 	jmp	0x38a0	; 0x38a0 <__fp_inf>

000035da <__addsf3x>:
    35da:	e9 2f       	mov	r30, r25
    35dc:	0e 94 78 1c 	call	0x38f0	; 0x38f0 <__fp_split3>
    35e0:	58 f3       	brcs	.-42     	; 0x35b8 <__addsf3+0xc>
    35e2:	ba 17       	cp	r27, r26
    35e4:	62 07       	cpc	r22, r18
    35e6:	73 07       	cpc	r23, r19
    35e8:	84 07       	cpc	r24, r20
    35ea:	95 07       	cpc	r25, r21
    35ec:	20 f0       	brcs	.+8      	; 0x35f6 <__addsf3x+0x1c>
    35ee:	79 f4       	brne	.+30     	; 0x360e <__addsf3x+0x34>
    35f0:	a6 f5       	brtc	.+104    	; 0x365a <__addsf3x+0x80>
    35f2:	0c 94 9a 1c 	jmp	0x3934	; 0x3934 <__fp_zero>
    35f6:	0e f4       	brtc	.+2      	; 0x35fa <__addsf3x+0x20>
    35f8:	e0 95       	com	r30
    35fa:	0b 2e       	mov	r0, r27
    35fc:	ba 2f       	mov	r27, r26
    35fe:	a0 2d       	mov	r26, r0
    3600:	0b 01       	movw	r0, r22
    3602:	b9 01       	movw	r22, r18
    3604:	90 01       	movw	r18, r0
    3606:	0c 01       	movw	r0, r24
    3608:	ca 01       	movw	r24, r20
    360a:	a0 01       	movw	r20, r0
    360c:	11 24       	eor	r1, r1
    360e:	ff 27       	eor	r31, r31
    3610:	59 1b       	sub	r21, r25
    3612:	99 f0       	breq	.+38     	; 0x363a <__addsf3x+0x60>
    3614:	59 3f       	cpi	r21, 0xF9	; 249
    3616:	50 f4       	brcc	.+20     	; 0x362c <__addsf3x+0x52>
    3618:	50 3e       	cpi	r21, 0xE0	; 224
    361a:	68 f1       	brcs	.+90     	; 0x3676 <__addsf3x+0x9c>
    361c:	1a 16       	cp	r1, r26
    361e:	f0 40       	sbci	r31, 0x00	; 0
    3620:	a2 2f       	mov	r26, r18
    3622:	23 2f       	mov	r18, r19
    3624:	34 2f       	mov	r19, r20
    3626:	44 27       	eor	r20, r20
    3628:	58 5f       	subi	r21, 0xF8	; 248
    362a:	f3 cf       	rjmp	.-26     	; 0x3612 <__addsf3x+0x38>
    362c:	46 95       	lsr	r20
    362e:	37 95       	ror	r19
    3630:	27 95       	ror	r18
    3632:	a7 95       	ror	r26
    3634:	f0 40       	sbci	r31, 0x00	; 0
    3636:	53 95       	inc	r21
    3638:	c9 f7       	brne	.-14     	; 0x362c <__addsf3x+0x52>
    363a:	7e f4       	brtc	.+30     	; 0x365a <__addsf3x+0x80>
    363c:	1f 16       	cp	r1, r31
    363e:	ba 0b       	sbc	r27, r26
    3640:	62 0b       	sbc	r22, r18
    3642:	73 0b       	sbc	r23, r19
    3644:	84 0b       	sbc	r24, r20
    3646:	ba f0       	brmi	.+46     	; 0x3676 <__addsf3x+0x9c>
    3648:	91 50       	subi	r25, 0x01	; 1
    364a:	a1 f0       	breq	.+40     	; 0x3674 <__addsf3x+0x9a>
    364c:	ff 0f       	add	r31, r31
    364e:	bb 1f       	adc	r27, r27
    3650:	66 1f       	adc	r22, r22
    3652:	77 1f       	adc	r23, r23
    3654:	88 1f       	adc	r24, r24
    3656:	c2 f7       	brpl	.-16     	; 0x3648 <__addsf3x+0x6e>
    3658:	0e c0       	rjmp	.+28     	; 0x3676 <__addsf3x+0x9c>
    365a:	ba 0f       	add	r27, r26
    365c:	62 1f       	adc	r22, r18
    365e:	73 1f       	adc	r23, r19
    3660:	84 1f       	adc	r24, r20
    3662:	48 f4       	brcc	.+18     	; 0x3676 <__addsf3x+0x9c>
    3664:	87 95       	ror	r24
    3666:	77 95       	ror	r23
    3668:	67 95       	ror	r22
    366a:	b7 95       	ror	r27
    366c:	f7 95       	ror	r31
    366e:	9e 3f       	cpi	r25, 0xFE	; 254
    3670:	08 f0       	brcs	.+2      	; 0x3674 <__addsf3x+0x9a>
    3672:	b0 cf       	rjmp	.-160    	; 0x35d4 <__addsf3+0x28>
    3674:	93 95       	inc	r25
    3676:	88 0f       	add	r24, r24
    3678:	08 f0       	brcs	.+2      	; 0x367c <__addsf3x+0xa2>
    367a:	99 27       	eor	r25, r25
    367c:	ee 0f       	add	r30, r30
    367e:	97 95       	ror	r25
    3680:	87 95       	ror	r24
    3682:	08 95       	ret

00003684 <__cmpsf2>:
    3684:	0e 94 2c 1c 	call	0x3858	; 0x3858 <__fp_cmp>
    3688:	08 f4       	brcc	.+2      	; 0x368c <__cmpsf2+0x8>
    368a:	81 e0       	ldi	r24, 0x01	; 1
    368c:	08 95       	ret

0000368e <__divsf3>:
    368e:	0e 94 5b 1b 	call	0x36b6	; 0x36b6 <__divsf3x>
    3692:	0c 94 67 1c 	jmp	0x38ce	; 0x38ce <__fp_round>
    3696:	0e 94 60 1c 	call	0x38c0	; 0x38c0 <__fp_pscB>
    369a:	58 f0       	brcs	.+22     	; 0x36b2 <__divsf3+0x24>
    369c:	0e 94 59 1c 	call	0x38b2	; 0x38b2 <__fp_pscA>
    36a0:	40 f0       	brcs	.+16     	; 0x36b2 <__divsf3+0x24>
    36a2:	29 f4       	brne	.+10     	; 0x36ae <__divsf3+0x20>
    36a4:	5f 3f       	cpi	r21, 0xFF	; 255
    36a6:	29 f0       	breq	.+10     	; 0x36b2 <__divsf3+0x24>
    36a8:	0c 94 50 1c 	jmp	0x38a0	; 0x38a0 <__fp_inf>
    36ac:	51 11       	cpse	r21, r1
    36ae:	0c 94 9b 1c 	jmp	0x3936	; 0x3936 <__fp_szero>
    36b2:	0c 94 56 1c 	jmp	0x38ac	; 0x38ac <__fp_nan>

000036b6 <__divsf3x>:
    36b6:	0e 94 78 1c 	call	0x38f0	; 0x38f0 <__fp_split3>
    36ba:	68 f3       	brcs	.-38     	; 0x3696 <__divsf3+0x8>

000036bc <__divsf3_pse>:
    36bc:	99 23       	and	r25, r25
    36be:	b1 f3       	breq	.-20     	; 0x36ac <__divsf3+0x1e>
    36c0:	55 23       	and	r21, r21
    36c2:	91 f3       	breq	.-28     	; 0x36a8 <__divsf3+0x1a>
    36c4:	95 1b       	sub	r25, r21
    36c6:	55 0b       	sbc	r21, r21
    36c8:	bb 27       	eor	r27, r27
    36ca:	aa 27       	eor	r26, r26
    36cc:	62 17       	cp	r22, r18
    36ce:	73 07       	cpc	r23, r19
    36d0:	84 07       	cpc	r24, r20
    36d2:	38 f0       	brcs	.+14     	; 0x36e2 <__divsf3_pse+0x26>
    36d4:	9f 5f       	subi	r25, 0xFF	; 255
    36d6:	5f 4f       	sbci	r21, 0xFF	; 255
    36d8:	22 0f       	add	r18, r18
    36da:	33 1f       	adc	r19, r19
    36dc:	44 1f       	adc	r20, r20
    36de:	aa 1f       	adc	r26, r26
    36e0:	a9 f3       	breq	.-22     	; 0x36cc <__divsf3_pse+0x10>
    36e2:	35 d0       	rcall	.+106    	; 0x374e <__divsf3_pse+0x92>
    36e4:	0e 2e       	mov	r0, r30
    36e6:	3a f0       	brmi	.+14     	; 0x36f6 <__divsf3_pse+0x3a>
    36e8:	e0 e8       	ldi	r30, 0x80	; 128
    36ea:	32 d0       	rcall	.+100    	; 0x3750 <__divsf3_pse+0x94>
    36ec:	91 50       	subi	r25, 0x01	; 1
    36ee:	50 40       	sbci	r21, 0x00	; 0
    36f0:	e6 95       	lsr	r30
    36f2:	00 1c       	adc	r0, r0
    36f4:	ca f7       	brpl	.-14     	; 0x36e8 <__divsf3_pse+0x2c>
    36f6:	2b d0       	rcall	.+86     	; 0x374e <__divsf3_pse+0x92>
    36f8:	fe 2f       	mov	r31, r30
    36fa:	29 d0       	rcall	.+82     	; 0x374e <__divsf3_pse+0x92>
    36fc:	66 0f       	add	r22, r22
    36fe:	77 1f       	adc	r23, r23
    3700:	88 1f       	adc	r24, r24
    3702:	bb 1f       	adc	r27, r27
    3704:	26 17       	cp	r18, r22
    3706:	37 07       	cpc	r19, r23
    3708:	48 07       	cpc	r20, r24
    370a:	ab 07       	cpc	r26, r27
    370c:	b0 e8       	ldi	r27, 0x80	; 128
    370e:	09 f0       	breq	.+2      	; 0x3712 <__divsf3_pse+0x56>
    3710:	bb 0b       	sbc	r27, r27
    3712:	80 2d       	mov	r24, r0
    3714:	bf 01       	movw	r22, r30
    3716:	ff 27       	eor	r31, r31
    3718:	93 58       	subi	r25, 0x83	; 131
    371a:	5f 4f       	sbci	r21, 0xFF	; 255
    371c:	3a f0       	brmi	.+14     	; 0x372c <__divsf3_pse+0x70>
    371e:	9e 3f       	cpi	r25, 0xFE	; 254
    3720:	51 05       	cpc	r21, r1
    3722:	78 f0       	brcs	.+30     	; 0x3742 <__divsf3_pse+0x86>
    3724:	0c 94 50 1c 	jmp	0x38a0	; 0x38a0 <__fp_inf>
    3728:	0c 94 9b 1c 	jmp	0x3936	; 0x3936 <__fp_szero>
    372c:	5f 3f       	cpi	r21, 0xFF	; 255
    372e:	e4 f3       	brlt	.-8      	; 0x3728 <__divsf3_pse+0x6c>
    3730:	98 3e       	cpi	r25, 0xE8	; 232
    3732:	d4 f3       	brlt	.-12     	; 0x3728 <__divsf3_pse+0x6c>
    3734:	86 95       	lsr	r24
    3736:	77 95       	ror	r23
    3738:	67 95       	ror	r22
    373a:	b7 95       	ror	r27
    373c:	f7 95       	ror	r31
    373e:	9f 5f       	subi	r25, 0xFF	; 255
    3740:	c9 f7       	brne	.-14     	; 0x3734 <__divsf3_pse+0x78>
    3742:	88 0f       	add	r24, r24
    3744:	91 1d       	adc	r25, r1
    3746:	96 95       	lsr	r25
    3748:	87 95       	ror	r24
    374a:	97 f9       	bld	r25, 7
    374c:	08 95       	ret
    374e:	e1 e0       	ldi	r30, 0x01	; 1
    3750:	66 0f       	add	r22, r22
    3752:	77 1f       	adc	r23, r23
    3754:	88 1f       	adc	r24, r24
    3756:	bb 1f       	adc	r27, r27
    3758:	62 17       	cp	r22, r18
    375a:	73 07       	cpc	r23, r19
    375c:	84 07       	cpc	r24, r20
    375e:	ba 07       	cpc	r27, r26
    3760:	20 f0       	brcs	.+8      	; 0x376a <__divsf3_pse+0xae>
    3762:	62 1b       	sub	r22, r18
    3764:	73 0b       	sbc	r23, r19
    3766:	84 0b       	sbc	r24, r20
    3768:	ba 0b       	sbc	r27, r26
    376a:	ee 1f       	adc	r30, r30
    376c:	88 f7       	brcc	.-30     	; 0x3750 <__divsf3_pse+0x94>
    376e:	e0 95       	com	r30
    3770:	08 95       	ret

00003772 <__fixsfsi>:
    3772:	0e 94 c0 1b 	call	0x3780	; 0x3780 <__fixunssfsi>
    3776:	68 94       	set
    3778:	b1 11       	cpse	r27, r1
    377a:	0c 94 9b 1c 	jmp	0x3936	; 0x3936 <__fp_szero>
    377e:	08 95       	ret

00003780 <__fixunssfsi>:
    3780:	0e 94 80 1c 	call	0x3900	; 0x3900 <__fp_splitA>
    3784:	88 f0       	brcs	.+34     	; 0x37a8 <__fixunssfsi+0x28>
    3786:	9f 57       	subi	r25, 0x7F	; 127
    3788:	98 f0       	brcs	.+38     	; 0x37b0 <__fixunssfsi+0x30>
    378a:	b9 2f       	mov	r27, r25
    378c:	99 27       	eor	r25, r25
    378e:	b7 51       	subi	r27, 0x17	; 23
    3790:	b0 f0       	brcs	.+44     	; 0x37be <__fixunssfsi+0x3e>
    3792:	e1 f0       	breq	.+56     	; 0x37cc <__fixunssfsi+0x4c>
    3794:	66 0f       	add	r22, r22
    3796:	77 1f       	adc	r23, r23
    3798:	88 1f       	adc	r24, r24
    379a:	99 1f       	adc	r25, r25
    379c:	1a f0       	brmi	.+6      	; 0x37a4 <__fixunssfsi+0x24>
    379e:	ba 95       	dec	r27
    37a0:	c9 f7       	brne	.-14     	; 0x3794 <__fixunssfsi+0x14>
    37a2:	14 c0       	rjmp	.+40     	; 0x37cc <__fixunssfsi+0x4c>
    37a4:	b1 30       	cpi	r27, 0x01	; 1
    37a6:	91 f0       	breq	.+36     	; 0x37cc <__fixunssfsi+0x4c>
    37a8:	0e 94 9a 1c 	call	0x3934	; 0x3934 <__fp_zero>
    37ac:	b1 e0       	ldi	r27, 0x01	; 1
    37ae:	08 95       	ret
    37b0:	0c 94 9a 1c 	jmp	0x3934	; 0x3934 <__fp_zero>
    37b4:	67 2f       	mov	r22, r23
    37b6:	78 2f       	mov	r23, r24
    37b8:	88 27       	eor	r24, r24
    37ba:	b8 5f       	subi	r27, 0xF8	; 248
    37bc:	39 f0       	breq	.+14     	; 0x37cc <__fixunssfsi+0x4c>
    37be:	b9 3f       	cpi	r27, 0xF9	; 249
    37c0:	cc f3       	brlt	.-14     	; 0x37b4 <__fixunssfsi+0x34>
    37c2:	86 95       	lsr	r24
    37c4:	77 95       	ror	r23
    37c6:	67 95       	ror	r22
    37c8:	b3 95       	inc	r27
    37ca:	d9 f7       	brne	.-10     	; 0x37c2 <__fixunssfsi+0x42>
    37cc:	3e f4       	brtc	.+14     	; 0x37dc <__fixunssfsi+0x5c>
    37ce:	90 95       	com	r25
    37d0:	80 95       	com	r24
    37d2:	70 95       	com	r23
    37d4:	61 95       	neg	r22
    37d6:	7f 4f       	sbci	r23, 0xFF	; 255
    37d8:	8f 4f       	sbci	r24, 0xFF	; 255
    37da:	9f 4f       	sbci	r25, 0xFF	; 255
    37dc:	08 95       	ret

000037de <__floatunsisf>:
    37de:	e8 94       	clt
    37e0:	09 c0       	rjmp	.+18     	; 0x37f4 <__floatsisf+0x12>

000037e2 <__floatsisf>:
    37e2:	97 fb       	bst	r25, 7
    37e4:	3e f4       	brtc	.+14     	; 0x37f4 <__floatsisf+0x12>
    37e6:	90 95       	com	r25
    37e8:	80 95       	com	r24
    37ea:	70 95       	com	r23
    37ec:	61 95       	neg	r22
    37ee:	7f 4f       	sbci	r23, 0xFF	; 255
    37f0:	8f 4f       	sbci	r24, 0xFF	; 255
    37f2:	9f 4f       	sbci	r25, 0xFF	; 255
    37f4:	99 23       	and	r25, r25
    37f6:	a9 f0       	breq	.+42     	; 0x3822 <__floatsisf+0x40>
    37f8:	f9 2f       	mov	r31, r25
    37fa:	96 e9       	ldi	r25, 0x96	; 150
    37fc:	bb 27       	eor	r27, r27
    37fe:	93 95       	inc	r25
    3800:	f6 95       	lsr	r31
    3802:	87 95       	ror	r24
    3804:	77 95       	ror	r23
    3806:	67 95       	ror	r22
    3808:	b7 95       	ror	r27
    380a:	f1 11       	cpse	r31, r1
    380c:	f8 cf       	rjmp	.-16     	; 0x37fe <__floatsisf+0x1c>
    380e:	fa f4       	brpl	.+62     	; 0x384e <__floatsisf+0x6c>
    3810:	bb 0f       	add	r27, r27
    3812:	11 f4       	brne	.+4      	; 0x3818 <__floatsisf+0x36>
    3814:	60 ff       	sbrs	r22, 0
    3816:	1b c0       	rjmp	.+54     	; 0x384e <__floatsisf+0x6c>
    3818:	6f 5f       	subi	r22, 0xFF	; 255
    381a:	7f 4f       	sbci	r23, 0xFF	; 255
    381c:	8f 4f       	sbci	r24, 0xFF	; 255
    381e:	9f 4f       	sbci	r25, 0xFF	; 255
    3820:	16 c0       	rjmp	.+44     	; 0x384e <__floatsisf+0x6c>
    3822:	88 23       	and	r24, r24
    3824:	11 f0       	breq	.+4      	; 0x382a <__floatsisf+0x48>
    3826:	96 e9       	ldi	r25, 0x96	; 150
    3828:	11 c0       	rjmp	.+34     	; 0x384c <__floatsisf+0x6a>
    382a:	77 23       	and	r23, r23
    382c:	21 f0       	breq	.+8      	; 0x3836 <__floatsisf+0x54>
    382e:	9e e8       	ldi	r25, 0x8E	; 142
    3830:	87 2f       	mov	r24, r23
    3832:	76 2f       	mov	r23, r22
    3834:	05 c0       	rjmp	.+10     	; 0x3840 <__floatsisf+0x5e>
    3836:	66 23       	and	r22, r22
    3838:	71 f0       	breq	.+28     	; 0x3856 <__floatsisf+0x74>
    383a:	96 e8       	ldi	r25, 0x86	; 134
    383c:	86 2f       	mov	r24, r22
    383e:	70 e0       	ldi	r23, 0x00	; 0
    3840:	60 e0       	ldi	r22, 0x00	; 0
    3842:	2a f0       	brmi	.+10     	; 0x384e <__floatsisf+0x6c>
    3844:	9a 95       	dec	r25
    3846:	66 0f       	add	r22, r22
    3848:	77 1f       	adc	r23, r23
    384a:	88 1f       	adc	r24, r24
    384c:	da f7       	brpl	.-10     	; 0x3844 <__floatsisf+0x62>
    384e:	88 0f       	add	r24, r24
    3850:	96 95       	lsr	r25
    3852:	87 95       	ror	r24
    3854:	97 f9       	bld	r25, 7
    3856:	08 95       	ret

00003858 <__fp_cmp>:
    3858:	99 0f       	add	r25, r25
    385a:	00 08       	sbc	r0, r0
    385c:	55 0f       	add	r21, r21
    385e:	aa 0b       	sbc	r26, r26
    3860:	e0 e8       	ldi	r30, 0x80	; 128
    3862:	fe ef       	ldi	r31, 0xFE	; 254
    3864:	16 16       	cp	r1, r22
    3866:	17 06       	cpc	r1, r23
    3868:	e8 07       	cpc	r30, r24
    386a:	f9 07       	cpc	r31, r25
    386c:	c0 f0       	brcs	.+48     	; 0x389e <__fp_cmp+0x46>
    386e:	12 16       	cp	r1, r18
    3870:	13 06       	cpc	r1, r19
    3872:	e4 07       	cpc	r30, r20
    3874:	f5 07       	cpc	r31, r21
    3876:	98 f0       	brcs	.+38     	; 0x389e <__fp_cmp+0x46>
    3878:	62 1b       	sub	r22, r18
    387a:	73 0b       	sbc	r23, r19
    387c:	84 0b       	sbc	r24, r20
    387e:	95 0b       	sbc	r25, r21
    3880:	39 f4       	brne	.+14     	; 0x3890 <__fp_cmp+0x38>
    3882:	0a 26       	eor	r0, r26
    3884:	61 f0       	breq	.+24     	; 0x389e <__fp_cmp+0x46>
    3886:	23 2b       	or	r18, r19
    3888:	24 2b       	or	r18, r20
    388a:	25 2b       	or	r18, r21
    388c:	21 f4       	brne	.+8      	; 0x3896 <__fp_cmp+0x3e>
    388e:	08 95       	ret
    3890:	0a 26       	eor	r0, r26
    3892:	09 f4       	brne	.+2      	; 0x3896 <__fp_cmp+0x3e>
    3894:	a1 40       	sbci	r26, 0x01	; 1
    3896:	a6 95       	lsr	r26
    3898:	8f ef       	ldi	r24, 0xFF	; 255
    389a:	81 1d       	adc	r24, r1
    389c:	81 1d       	adc	r24, r1
    389e:	08 95       	ret

000038a0 <__fp_inf>:
    38a0:	97 f9       	bld	r25, 7
    38a2:	9f 67       	ori	r25, 0x7F	; 127
    38a4:	80 e8       	ldi	r24, 0x80	; 128
    38a6:	70 e0       	ldi	r23, 0x00	; 0
    38a8:	60 e0       	ldi	r22, 0x00	; 0
    38aa:	08 95       	ret

000038ac <__fp_nan>:
    38ac:	9f ef       	ldi	r25, 0xFF	; 255
    38ae:	80 ec       	ldi	r24, 0xC0	; 192
    38b0:	08 95       	ret

000038b2 <__fp_pscA>:
    38b2:	00 24       	eor	r0, r0
    38b4:	0a 94       	dec	r0
    38b6:	16 16       	cp	r1, r22
    38b8:	17 06       	cpc	r1, r23
    38ba:	18 06       	cpc	r1, r24
    38bc:	09 06       	cpc	r0, r25
    38be:	08 95       	ret

000038c0 <__fp_pscB>:
    38c0:	00 24       	eor	r0, r0
    38c2:	0a 94       	dec	r0
    38c4:	12 16       	cp	r1, r18
    38c6:	13 06       	cpc	r1, r19
    38c8:	14 06       	cpc	r1, r20
    38ca:	05 06       	cpc	r0, r21
    38cc:	08 95       	ret

000038ce <__fp_round>:
    38ce:	09 2e       	mov	r0, r25
    38d0:	03 94       	inc	r0
    38d2:	00 0c       	add	r0, r0
    38d4:	11 f4       	brne	.+4      	; 0x38da <__fp_round+0xc>
    38d6:	88 23       	and	r24, r24
    38d8:	52 f0       	brmi	.+20     	; 0x38ee <__fp_round+0x20>
    38da:	bb 0f       	add	r27, r27
    38dc:	40 f4       	brcc	.+16     	; 0x38ee <__fp_round+0x20>
    38de:	bf 2b       	or	r27, r31
    38e0:	11 f4       	brne	.+4      	; 0x38e6 <__fp_round+0x18>
    38e2:	60 ff       	sbrs	r22, 0
    38e4:	04 c0       	rjmp	.+8      	; 0x38ee <__fp_round+0x20>
    38e6:	6f 5f       	subi	r22, 0xFF	; 255
    38e8:	7f 4f       	sbci	r23, 0xFF	; 255
    38ea:	8f 4f       	sbci	r24, 0xFF	; 255
    38ec:	9f 4f       	sbci	r25, 0xFF	; 255
    38ee:	08 95       	ret

000038f0 <__fp_split3>:
    38f0:	57 fd       	sbrc	r21, 7
    38f2:	90 58       	subi	r25, 0x80	; 128
    38f4:	44 0f       	add	r20, r20
    38f6:	55 1f       	adc	r21, r21
    38f8:	59 f0       	breq	.+22     	; 0x3910 <__fp_splitA+0x10>
    38fa:	5f 3f       	cpi	r21, 0xFF	; 255
    38fc:	71 f0       	breq	.+28     	; 0x391a <__fp_splitA+0x1a>
    38fe:	47 95       	ror	r20

00003900 <__fp_splitA>:
    3900:	88 0f       	add	r24, r24
    3902:	97 fb       	bst	r25, 7
    3904:	99 1f       	adc	r25, r25
    3906:	61 f0       	breq	.+24     	; 0x3920 <__fp_splitA+0x20>
    3908:	9f 3f       	cpi	r25, 0xFF	; 255
    390a:	79 f0       	breq	.+30     	; 0x392a <__fp_splitA+0x2a>
    390c:	87 95       	ror	r24
    390e:	08 95       	ret
    3910:	12 16       	cp	r1, r18
    3912:	13 06       	cpc	r1, r19
    3914:	14 06       	cpc	r1, r20
    3916:	55 1f       	adc	r21, r21
    3918:	f2 cf       	rjmp	.-28     	; 0x38fe <__fp_split3+0xe>
    391a:	46 95       	lsr	r20
    391c:	f1 df       	rcall	.-30     	; 0x3900 <__fp_splitA>
    391e:	08 c0       	rjmp	.+16     	; 0x3930 <__fp_splitA+0x30>
    3920:	16 16       	cp	r1, r22
    3922:	17 06       	cpc	r1, r23
    3924:	18 06       	cpc	r1, r24
    3926:	99 1f       	adc	r25, r25
    3928:	f1 cf       	rjmp	.-30     	; 0x390c <__fp_splitA+0xc>
    392a:	86 95       	lsr	r24
    392c:	71 05       	cpc	r23, r1
    392e:	61 05       	cpc	r22, r1
    3930:	08 94       	sec
    3932:	08 95       	ret

00003934 <__fp_zero>:
    3934:	e8 94       	clt

00003936 <__fp_szero>:
    3936:	bb 27       	eor	r27, r27
    3938:	66 27       	eor	r22, r22
    393a:	77 27       	eor	r23, r23
    393c:	cb 01       	movw	r24, r22
    393e:	97 f9       	bld	r25, 7
    3940:	08 95       	ret

00003942 <__mulsf3>:
    3942:	0e 94 b4 1c 	call	0x3968	; 0x3968 <__mulsf3x>
    3946:	0c 94 67 1c 	jmp	0x38ce	; 0x38ce <__fp_round>
    394a:	0e 94 59 1c 	call	0x38b2	; 0x38b2 <__fp_pscA>
    394e:	38 f0       	brcs	.+14     	; 0x395e <__mulsf3+0x1c>
    3950:	0e 94 60 1c 	call	0x38c0	; 0x38c0 <__fp_pscB>
    3954:	20 f0       	brcs	.+8      	; 0x395e <__mulsf3+0x1c>
    3956:	95 23       	and	r25, r21
    3958:	11 f0       	breq	.+4      	; 0x395e <__mulsf3+0x1c>
    395a:	0c 94 50 1c 	jmp	0x38a0	; 0x38a0 <__fp_inf>
    395e:	0c 94 56 1c 	jmp	0x38ac	; 0x38ac <__fp_nan>
    3962:	11 24       	eor	r1, r1
    3964:	0c 94 9b 1c 	jmp	0x3936	; 0x3936 <__fp_szero>

00003968 <__mulsf3x>:
    3968:	0e 94 78 1c 	call	0x38f0	; 0x38f0 <__fp_split3>
    396c:	70 f3       	brcs	.-36     	; 0x394a <__mulsf3+0x8>

0000396e <__mulsf3_pse>:
    396e:	95 9f       	mul	r25, r21
    3970:	c1 f3       	breq	.-16     	; 0x3962 <__mulsf3+0x20>
    3972:	95 0f       	add	r25, r21
    3974:	50 e0       	ldi	r21, 0x00	; 0
    3976:	55 1f       	adc	r21, r21
    3978:	62 9f       	mul	r22, r18
    397a:	f0 01       	movw	r30, r0
    397c:	72 9f       	mul	r23, r18
    397e:	bb 27       	eor	r27, r27
    3980:	f0 0d       	add	r31, r0
    3982:	b1 1d       	adc	r27, r1
    3984:	63 9f       	mul	r22, r19
    3986:	aa 27       	eor	r26, r26
    3988:	f0 0d       	add	r31, r0
    398a:	b1 1d       	adc	r27, r1
    398c:	aa 1f       	adc	r26, r26
    398e:	64 9f       	mul	r22, r20
    3990:	66 27       	eor	r22, r22
    3992:	b0 0d       	add	r27, r0
    3994:	a1 1d       	adc	r26, r1
    3996:	66 1f       	adc	r22, r22
    3998:	82 9f       	mul	r24, r18
    399a:	22 27       	eor	r18, r18
    399c:	b0 0d       	add	r27, r0
    399e:	a1 1d       	adc	r26, r1
    39a0:	62 1f       	adc	r22, r18
    39a2:	73 9f       	mul	r23, r19
    39a4:	b0 0d       	add	r27, r0
    39a6:	a1 1d       	adc	r26, r1
    39a8:	62 1f       	adc	r22, r18
    39aa:	83 9f       	mul	r24, r19
    39ac:	a0 0d       	add	r26, r0
    39ae:	61 1d       	adc	r22, r1
    39b0:	22 1f       	adc	r18, r18
    39b2:	74 9f       	mul	r23, r20
    39b4:	33 27       	eor	r19, r19
    39b6:	a0 0d       	add	r26, r0
    39b8:	61 1d       	adc	r22, r1
    39ba:	23 1f       	adc	r18, r19
    39bc:	84 9f       	mul	r24, r20
    39be:	60 0d       	add	r22, r0
    39c0:	21 1d       	adc	r18, r1
    39c2:	82 2f       	mov	r24, r18
    39c4:	76 2f       	mov	r23, r22
    39c6:	6a 2f       	mov	r22, r26
    39c8:	11 24       	eor	r1, r1
    39ca:	9f 57       	subi	r25, 0x7F	; 127
    39cc:	50 40       	sbci	r21, 0x00	; 0
    39ce:	9a f0       	brmi	.+38     	; 0x39f6 <__mulsf3_pse+0x88>
    39d0:	f1 f0       	breq	.+60     	; 0x3a0e <__mulsf3_pse+0xa0>
    39d2:	88 23       	and	r24, r24
    39d4:	4a f0       	brmi	.+18     	; 0x39e8 <__mulsf3_pse+0x7a>
    39d6:	ee 0f       	add	r30, r30
    39d8:	ff 1f       	adc	r31, r31
    39da:	bb 1f       	adc	r27, r27
    39dc:	66 1f       	adc	r22, r22
    39de:	77 1f       	adc	r23, r23
    39e0:	88 1f       	adc	r24, r24
    39e2:	91 50       	subi	r25, 0x01	; 1
    39e4:	50 40       	sbci	r21, 0x00	; 0
    39e6:	a9 f7       	brne	.-22     	; 0x39d2 <__mulsf3_pse+0x64>
    39e8:	9e 3f       	cpi	r25, 0xFE	; 254
    39ea:	51 05       	cpc	r21, r1
    39ec:	80 f0       	brcs	.+32     	; 0x3a0e <__mulsf3_pse+0xa0>
    39ee:	0c 94 50 1c 	jmp	0x38a0	; 0x38a0 <__fp_inf>
    39f2:	0c 94 9b 1c 	jmp	0x3936	; 0x3936 <__fp_szero>
    39f6:	5f 3f       	cpi	r21, 0xFF	; 255
    39f8:	e4 f3       	brlt	.-8      	; 0x39f2 <__mulsf3_pse+0x84>
    39fa:	98 3e       	cpi	r25, 0xE8	; 232
    39fc:	d4 f3       	brlt	.-12     	; 0x39f2 <__mulsf3_pse+0x84>
    39fe:	86 95       	lsr	r24
    3a00:	77 95       	ror	r23
    3a02:	67 95       	ror	r22
    3a04:	b7 95       	ror	r27
    3a06:	f7 95       	ror	r31
    3a08:	e7 95       	ror	r30
    3a0a:	9f 5f       	subi	r25, 0xFF	; 255
    3a0c:	c1 f7       	brne	.-16     	; 0x39fe <__mulsf3_pse+0x90>
    3a0e:	fe 2b       	or	r31, r30
    3a10:	88 0f       	add	r24, r24
    3a12:	91 1d       	adc	r25, r1
    3a14:	96 95       	lsr	r25
    3a16:	87 95       	ror	r24
    3a18:	97 f9       	bld	r25, 7
    3a1a:	08 95       	ret

00003a1c <_ZN14HardwareSerial9availableEv>:
  // clear any received data
  _rx_buffer_head = _rx_buffer_tail;
}

int HardwareSerial::available(void)
{
    3a1c:	fc 01       	movw	r30, r24
  return ((unsigned int)(SERIAL_RX_BUFFER_SIZE + _rx_buffer_head - _rx_buffer_tail)) % SERIAL_RX_BUFFER_SIZE;
    3a1e:	91 8d       	ldd	r25, Z+25	; 0x19
    3a20:	22 8d       	ldd	r18, Z+26	; 0x1a
    3a22:	89 2f       	mov	r24, r25
    3a24:	90 e0       	ldi	r25, 0x00	; 0
    3a26:	80 5c       	subi	r24, 0xC0	; 192
    3a28:	9f 4f       	sbci	r25, 0xFF	; 255
    3a2a:	82 1b       	sub	r24, r18
    3a2c:	91 09       	sbc	r25, r1
}
    3a2e:	8f 73       	andi	r24, 0x3F	; 63
    3a30:	99 27       	eor	r25, r25
    3a32:	08 95       	ret

00003a34 <_ZN14HardwareSerial4peekEv>:

int HardwareSerial::peek(void)
{
    3a34:	fc 01       	movw	r30, r24
  if (_rx_buffer_head == _rx_buffer_tail) {
    3a36:	91 8d       	ldd	r25, Z+25	; 0x19
    3a38:	82 8d       	ldd	r24, Z+26	; 0x1a
    3a3a:	98 17       	cp	r25, r24
    3a3c:	31 f0       	breq	.+12     	; 0x3a4a <_ZN14HardwareSerial4peekEv+0x16>
    return -1;
  } else {
    return _rx_buffer[_rx_buffer_tail];
    3a3e:	82 8d       	ldd	r24, Z+26	; 0x1a
    3a40:	e8 0f       	add	r30, r24
    3a42:	f1 1d       	adc	r31, r1
    3a44:	85 8d       	ldd	r24, Z+29	; 0x1d
    3a46:	90 e0       	ldi	r25, 0x00	; 0
    3a48:	08 95       	ret
}

int HardwareSerial::peek(void)
{
  if (_rx_buffer_head == _rx_buffer_tail) {
    return -1;
    3a4a:	8f ef       	ldi	r24, 0xFF	; 255
    3a4c:	9f ef       	ldi	r25, 0xFF	; 255
  } else {
    return _rx_buffer[_rx_buffer_tail];
  }
}
    3a4e:	08 95       	ret

00003a50 <_ZN14HardwareSerial4readEv>:

int HardwareSerial::read(void)
{
    3a50:	fc 01       	movw	r30, r24
  // if the head isn't ahead of the tail, we don't have any characters
  if (_rx_buffer_head == _rx_buffer_tail) {
    3a52:	91 8d       	ldd	r25, Z+25	; 0x19
    3a54:	82 8d       	ldd	r24, Z+26	; 0x1a
    3a56:	98 17       	cp	r25, r24
    3a58:	61 f0       	breq	.+24     	; 0x3a72 <_ZN14HardwareSerial4readEv+0x22>
    return -1;
  } else {
    unsigned char c = _rx_buffer[_rx_buffer_tail];
    3a5a:	82 8d       	ldd	r24, Z+26	; 0x1a
    3a5c:	df 01       	movw	r26, r30
    3a5e:	a8 0f       	add	r26, r24
    3a60:	b1 1d       	adc	r27, r1
    3a62:	5d 96       	adiw	r26, 0x1d	; 29
    3a64:	8c 91       	ld	r24, X
    _rx_buffer_tail = (rx_buffer_index_t)(_rx_buffer_tail + 1) % SERIAL_RX_BUFFER_SIZE;
    3a66:	92 8d       	ldd	r25, Z+26	; 0x1a
    3a68:	9f 5f       	subi	r25, 0xFF	; 255
    3a6a:	9f 73       	andi	r25, 0x3F	; 63
    3a6c:	92 8f       	std	Z+26, r25	; 0x1a
    return c;
    3a6e:	90 e0       	ldi	r25, 0x00	; 0
    3a70:	08 95       	ret

int HardwareSerial::read(void)
{
  // if the head isn't ahead of the tail, we don't have any characters
  if (_rx_buffer_head == _rx_buffer_tail) {
    return -1;
    3a72:	8f ef       	ldi	r24, 0xFF	; 255
    3a74:	9f ef       	ldi	r25, 0xFF	; 255
  } else {
    unsigned char c = _rx_buffer[_rx_buffer_tail];
    _rx_buffer_tail = (rx_buffer_index_t)(_rx_buffer_tail + 1) % SERIAL_RX_BUFFER_SIZE;
    return c;
  }
}
    3a76:	08 95       	ret

00003a78 <_ZN14HardwareSerial17availableForWriteEv>:
{
  tx_buffer_index_t head;
  tx_buffer_index_t tail;

  TX_BUFFER_ATOMIC {
    head = _tx_buffer_head;
    3a78:	fc 01       	movw	r30, r24
    3a7a:	53 8d       	ldd	r21, Z+27	; 0x1b
    tail = _tx_buffer_tail;
    3a7c:	44 8d       	ldd	r20, Z+28	; 0x1c
    3a7e:	25 2f       	mov	r18, r21
    3a80:	30 e0       	ldi	r19, 0x00	; 0
    3a82:	84 2f       	mov	r24, r20
    3a84:	90 e0       	ldi	r25, 0x00	; 0
  }
  if (head >= tail) return SERIAL_TX_BUFFER_SIZE - 1 - head + tail;
    3a86:	82 1b       	sub	r24, r18
    3a88:	93 0b       	sbc	r25, r19
    3a8a:	54 17       	cp	r21, r20
    3a8c:	10 f0       	brcs	.+4      	; 0x3a92 <_ZN14HardwareSerial17availableForWriteEv+0x1a>
    3a8e:	cf 96       	adiw	r24, 0x3f	; 63
    3a90:	08 95       	ret
  return tail - head - 1;
    3a92:	01 97       	sbiw	r24, 0x01	; 1
}
    3a94:	08 95       	ret

00003a96 <_Z14serialEventRunv>:
#endif

void serialEventRun(void)
{
#if defined(HAVE_HWSERIAL0)
  if (Serial0_available && serialEvent && Serial0_available()) serialEvent();
    3a96:	87 ea       	ldi	r24, 0xA7	; 167
    3a98:	9e e1       	ldi	r25, 0x1E	; 30
    3a9a:	89 2b       	or	r24, r25
    3a9c:	49 f0       	breq	.+18     	; 0x3ab0 <_Z14serialEventRunv+0x1a>
    3a9e:	80 e0       	ldi	r24, 0x00	; 0
    3aa0:	90 e0       	ldi	r25, 0x00	; 0
    3aa2:	89 2b       	or	r24, r25
    3aa4:	29 f0       	breq	.+10     	; 0x3ab0 <_Z14serialEventRunv+0x1a>
    3aa6:	0e 94 a7 1e 	call	0x3d4e	; 0x3d4e <_Z17Serial0_availablev>
    3aaa:	81 11       	cpse	r24, r1
    3aac:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>
    3ab0:	08 95       	ret

00003ab2 <_ZN14HardwareSerial17_tx_udr_empty_irqEv>:
#endif

// Actual interrupt handlers //////////////////////////////////////////////////////////////

void HardwareSerial::_tx_udr_empty_irq(void)
{
    3ab2:	fc 01       	movw	r30, r24
  // If interrupts are enabled, there must be more data in the output
  // buffer. Send the next byte
  unsigned char c = _tx_buffer[_tx_buffer_tail];
    3ab4:	84 8d       	ldd	r24, Z+28	; 0x1c
    3ab6:	df 01       	movw	r26, r30
    3ab8:	a8 0f       	add	r26, r24
    3aba:	b1 1d       	adc	r27, r1
    3abc:	a3 5a       	subi	r26, 0xA3	; 163
    3abe:	bf 4f       	sbci	r27, 0xFF	; 255
    3ac0:	2c 91       	ld	r18, X
  _tx_buffer_tail = (_tx_buffer_tail + 1) % SERIAL_TX_BUFFER_SIZE;
    3ac2:	84 8d       	ldd	r24, Z+28	; 0x1c
    3ac4:	90 e0       	ldi	r25, 0x00	; 0
    3ac6:	01 96       	adiw	r24, 0x01	; 1
    3ac8:	8f 73       	andi	r24, 0x3F	; 63
    3aca:	99 27       	eor	r25, r25
    3acc:	84 8f       	std	Z+28, r24	; 0x1c

  *_udr = c;
    3ace:	a6 89       	ldd	r26, Z+22	; 0x16
    3ad0:	b7 89       	ldd	r27, Z+23	; 0x17
    3ad2:	2c 93       	st	X, r18
  // location". This makes sure flush() won't return until the bytes
  // actually got written. Other r/w bits are preserved, and zeroes
  // written to the rest.

#ifdef MPCM0
  *_ucsra = ((*_ucsra) & ((1 << U2X0) | (1 << MPCM0))) | (1 << TXC0);
    3ad4:	a0 89       	ldd	r26, Z+16	; 0x10
    3ad6:	b1 89       	ldd	r27, Z+17	; 0x11
    3ad8:	8c 91       	ld	r24, X
    3ada:	83 70       	andi	r24, 0x03	; 3
    3adc:	80 64       	ori	r24, 0x40	; 64
    3ade:	8c 93       	st	X, r24
#else
  *_ucsra = ((*_ucsra) & ((1 << U2X0) | (1 << TXC0)));
#endif

  if (_tx_buffer_head == _tx_buffer_tail) {
    3ae0:	93 8d       	ldd	r25, Z+27	; 0x1b
    3ae2:	84 8d       	ldd	r24, Z+28	; 0x1c
    3ae4:	98 13       	cpse	r25, r24
    3ae6:	06 c0       	rjmp	.+12     	; 0x3af4 <_ZN14HardwareSerial17_tx_udr_empty_irqEv+0x42>
    // Buffer empty, so disable interrupts
    cbi(*_ucsrb, UDRIE0);
    3ae8:	02 88       	ldd	r0, Z+18	; 0x12
    3aea:	f3 89       	ldd	r31, Z+19	; 0x13
    3aec:	e0 2d       	mov	r30, r0
    3aee:	80 81       	ld	r24, Z
    3af0:	8f 7d       	andi	r24, 0xDF	; 223
    3af2:	80 83       	st	Z, r24
    3af4:	08 95       	ret

00003af6 <_ZN14HardwareSerial5writeEh>:
  // If we get here, nothing is queued anymore (DRIE is disabled) and
  // the hardware finished tranmission (TXC is set).
}

size_t HardwareSerial::write(uint8_t c)
{
    3af6:	ef 92       	push	r14
    3af8:	ff 92       	push	r15
    3afa:	0f 93       	push	r16
    3afc:	1f 93       	push	r17
    3afe:	cf 93       	push	r28
    3b00:	df 93       	push	r29
    3b02:	ec 01       	movw	r28, r24
  _written = true;
    3b04:	81 e0       	ldi	r24, 0x01	; 1
    3b06:	88 8f       	std	Y+24, r24	; 0x18
  // If the buffer and the data register is empty, just write the byte
  // to the data register and be done. This shortcut helps
  // significantly improve the effective datarate at high (>
  // 500kbit/s) bitrates, where interrupt overhead becomes a slowdown.
  if (_tx_buffer_head == _tx_buffer_tail && bit_is_set(*_ucsra, UDRE0)) {
    3b08:	9b 8d       	ldd	r25, Y+27	; 0x1b
    3b0a:	8c 8d       	ldd	r24, Y+28	; 0x1c
    3b0c:	98 13       	cpse	r25, r24
    3b0e:	05 c0       	rjmp	.+10     	; 0x3b1a <_ZN14HardwareSerial5writeEh+0x24>
    3b10:	e8 89       	ldd	r30, Y+16	; 0x10
    3b12:	f9 89       	ldd	r31, Y+17	; 0x11
    3b14:	80 81       	ld	r24, Z
    3b16:	85 fd       	sbrc	r24, 5
    3b18:	26 c0       	rjmp	.+76     	; 0x3b66 <_ZN14HardwareSerial5writeEh+0x70>
    3b1a:	f6 2e       	mov	r15, r22
      *_ucsra = ((*_ucsra) & ((1 << U2X0) | (1 << TXC0)));
#endif
    }
    return 1;
  }
  tx_buffer_index_t i = (_tx_buffer_head + 1) % SERIAL_TX_BUFFER_SIZE;
    3b1c:	0b 8d       	ldd	r16, Y+27	; 0x1b
    3b1e:	10 e0       	ldi	r17, 0x00	; 0
    3b20:	0f 5f       	subi	r16, 0xFF	; 255
    3b22:	1f 4f       	sbci	r17, 0xFF	; 255
    3b24:	0f 73       	andi	r16, 0x3F	; 63
    3b26:	11 27       	eor	r17, r17
    3b28:	e0 2e       	mov	r14, r16
	
  // If the output buffer is full, there's nothing for it other than to 
  // wait for the interrupt handler to empty it a bit
  while (i == _tx_buffer_tail) {
    3b2a:	8c 8d       	ldd	r24, Y+28	; 0x1c
    3b2c:	e8 12       	cpse	r14, r24
    3b2e:	0c c0       	rjmp	.+24     	; 0x3b48 <_ZN14HardwareSerial5writeEh+0x52>
    if (bit_is_clear(SREG, SREG_I)) {
    3b30:	0f b6       	in	r0, 0x3f	; 63
    3b32:	07 fc       	sbrc	r0, 7
    3b34:	fa cf       	rjmp	.-12     	; 0x3b2a <_ZN14HardwareSerial5writeEh+0x34>
      // Interrupts are disabled, so we'll have to poll the data
      // register empty flag ourselves. If it is set, pretend an
      // interrupt has happened and call the handler to free up
      // space for us.
      if(bit_is_set(*_ucsra, UDRE0))
    3b36:	e8 89       	ldd	r30, Y+16	; 0x10
    3b38:	f9 89       	ldd	r31, Y+17	; 0x11
    3b3a:	80 81       	ld	r24, Z
    3b3c:	85 ff       	sbrs	r24, 5
    3b3e:	f5 cf       	rjmp	.-22     	; 0x3b2a <_ZN14HardwareSerial5writeEh+0x34>
	_tx_udr_empty_irq();
    3b40:	ce 01       	movw	r24, r28
    3b42:	0e 94 59 1d 	call	0x3ab2	; 0x3ab2 <_ZN14HardwareSerial17_tx_udr_empty_irqEv>
    3b46:	f1 cf       	rjmp	.-30     	; 0x3b2a <_ZN14HardwareSerial5writeEh+0x34>
    } else {
      // nop, the interrupt handler will free up space for us
    }
  }

  _tx_buffer[_tx_buffer_head] = c;
    3b48:	8b 8d       	ldd	r24, Y+27	; 0x1b
    3b4a:	fe 01       	movw	r30, r28
    3b4c:	e8 0f       	add	r30, r24
    3b4e:	f1 1d       	adc	r31, r1
    3b50:	e3 5a       	subi	r30, 0xA3	; 163
    3b52:	ff 4f       	sbci	r31, 0xFF	; 255
    3b54:	f0 82       	st	Z, r15

  // make atomic to prevent execution of ISR between setting the
  // head pointer and setting the interrupt flag resulting in buffer
  // retransmission
  ATOMIC_BLOCK(ATOMIC_RESTORESTATE) {
    3b56:	9f b7       	in	r25, 0x3f	; 63
    return 1;
}

static __inline__ uint8_t __iCliRetVal(void)
{
    cli();
    3b58:	f8 94       	cli
    _tx_buffer_head = i;
    3b5a:	0b 8f       	std	Y+27, r16	; 0x1b
    sbi(*_ucsrb, UDRIE0);
    3b5c:	ea 89       	ldd	r30, Y+18	; 0x12
    3b5e:	fb 89       	ldd	r31, Y+19	; 0x13
    3b60:	80 81       	ld	r24, Z
    3b62:	80 62       	ori	r24, 0x20	; 32
    3b64:	0a c0       	rjmp	.+20     	; 0x3b7a <_ZN14HardwareSerial5writeEh+0x84>
    // So writing UDR must happen first.
    // Writing UDR and clearing TC must be done atomically, otherwise
    // interrupts might delay the TXC clear so the byte written to UDR
    // is transmitted (setting TXC) before clearing TXC. Then TXC will
    // be cleared when no bytes are left, causing flush() to hang
    ATOMIC_BLOCK(ATOMIC_RESTORESTATE) {
    3b66:	9f b7       	in	r25, 0x3f	; 63
    3b68:	f8 94       	cli
      *_udr = c;
    3b6a:	ee 89       	ldd	r30, Y+22	; 0x16
    3b6c:	ff 89       	ldd	r31, Y+23	; 0x17
    3b6e:	60 83       	st	Z, r22
#ifdef MPCM0
      *_ucsra = ((*_ucsra) & ((1 << U2X0) | (1 << MPCM0))) | (1 << TXC0);
    3b70:	e8 89       	ldd	r30, Y+16	; 0x10
    3b72:	f9 89       	ldd	r31, Y+17	; 0x11
    3b74:	80 81       	ld	r24, Z
    3b76:	83 70       	andi	r24, 0x03	; 3
    3b78:	80 64       	ori	r24, 0x40	; 64
    3b7a:	80 83       	st	Z, r24
    (void)__s;
}

static __inline__ void __iRestore(const  uint8_t *__s)
{
    SREG = *__s;
    3b7c:	9f bf       	out	0x3f, r25	; 63
    _tx_buffer_head = i;
    sbi(*_ucsrb, UDRIE0);
  }
  
  return 1;
}
    3b7e:	81 e0       	ldi	r24, 0x01	; 1
    3b80:	90 e0       	ldi	r25, 0x00	; 0
    3b82:	df 91       	pop	r29
    3b84:	cf 91       	pop	r28
    3b86:	1f 91       	pop	r17
    3b88:	0f 91       	pop	r16
    3b8a:	ff 90       	pop	r15
    3b8c:	ef 90       	pop	r14
    3b8e:	08 95       	ret

00003b90 <_ZN14HardwareSerial5flushEv>:
  if (head >= tail) return SERIAL_TX_BUFFER_SIZE - 1 - head + tail;
  return tail - head - 1;
}

void HardwareSerial::flush()
{
    3b90:	cf 93       	push	r28
    3b92:	df 93       	push	r29
    3b94:	ec 01       	movw	r28, r24
  // If we have never written a byte, no need to flush. This special
  // case is needed since there is no way to force the TXC (transmit
  // complete) bit to 1 during initialization
  if (!_written)
    3b96:	88 8d       	ldd	r24, Y+24	; 0x18
    3b98:	88 23       	and	r24, r24
    3b9a:	c9 f0       	breq	.+50     	; 0x3bce <_ZN14HardwareSerial5flushEv+0x3e>
    return;

  while (bit_is_set(*_ucsrb, UDRIE0) || bit_is_clear(*_ucsra, TXC0)) {
    3b9c:	ea 89       	ldd	r30, Y+18	; 0x12
    3b9e:	fb 89       	ldd	r31, Y+19	; 0x13
    3ba0:	80 81       	ld	r24, Z
    3ba2:	85 fd       	sbrc	r24, 5
    3ba4:	05 c0       	rjmp	.+10     	; 0x3bb0 <_ZN14HardwareSerial5flushEv+0x20>
    3ba6:	a8 89       	ldd	r26, Y+16	; 0x10
    3ba8:	b9 89       	ldd	r27, Y+17	; 0x11
    3baa:	8c 91       	ld	r24, X
    3bac:	86 fd       	sbrc	r24, 6
    3bae:	0f c0       	rjmp	.+30     	; 0x3bce <_ZN14HardwareSerial5flushEv+0x3e>
    if (bit_is_clear(SREG, SREG_I) && bit_is_set(*_ucsrb, UDRIE0))
    3bb0:	0f b6       	in	r0, 0x3f	; 63
    3bb2:	07 fc       	sbrc	r0, 7
    3bb4:	f5 cf       	rjmp	.-22     	; 0x3ba0 <_ZN14HardwareSerial5flushEv+0x10>
    3bb6:	80 81       	ld	r24, Z
    3bb8:	85 ff       	sbrs	r24, 5
    3bba:	f2 cf       	rjmp	.-28     	; 0x3ba0 <_ZN14HardwareSerial5flushEv+0x10>
	// Interrupts are globally disabled, but the DR empty
	// interrupt should be enabled, so poll the DR empty flag to
	// prevent deadlock
	if (bit_is_set(*_ucsra, UDRE0))
    3bbc:	a8 89       	ldd	r26, Y+16	; 0x10
    3bbe:	b9 89       	ldd	r27, Y+17	; 0x11
    3bc0:	8c 91       	ld	r24, X
    3bc2:	85 ff       	sbrs	r24, 5
    3bc4:	ed cf       	rjmp	.-38     	; 0x3ba0 <_ZN14HardwareSerial5flushEv+0x10>
	  _tx_udr_empty_irq();
    3bc6:	ce 01       	movw	r24, r28
    3bc8:	0e 94 59 1d 	call	0x3ab2	; 0x3ab2 <_ZN14HardwareSerial17_tx_udr_empty_irqEv>
    3bcc:	e7 cf       	rjmp	.-50     	; 0x3b9c <_ZN14HardwareSerial5flushEv+0xc>
  }
  // If we get here, nothing is queued anymore (DRIE is disabled) and
  // the hardware finished tranmission (TXC is set).
}
    3bce:	df 91       	pop	r29
    3bd0:	cf 91       	pop	r28
    3bd2:	08 95       	ret

00003bd4 <_ZN14HardwareSerial5beginEmh>:
}

// Public Methods //////////////////////////////////////////////////////////////

void HardwareSerial::begin(unsigned long baud, byte config)
{
    3bd4:	cf 92       	push	r12
    3bd6:	df 92       	push	r13
    3bd8:	ef 92       	push	r14
    3bda:	ff 92       	push	r15
    3bdc:	1f 93       	push	r17
    3bde:	cf 93       	push	r28
    3be0:	df 93       	push	r29
    3be2:	ec 01       	movw	r28, r24
    3be4:	6a 01       	movw	r12, r20
    3be6:	7b 01       	movw	r14, r22
    3be8:	12 2f       	mov	r17, r18
  // Try u2x mode first
  uint16_t baud_setting = (F_CPU / 4 / baud - 1) / 2;
  *_ucsra = 1 << U2X0;
    3bea:	e8 89       	ldd	r30, Y+16	; 0x10
    3bec:	f9 89       	ldd	r31, Y+17	; 0x11
    3bee:	82 e0       	ldi	r24, 0x02	; 2
    3bf0:	80 83       	st	Z, r24
  // hardcoded exception for 57600 for compatibility with the bootloader
  // shipped with the Duemilanove and previous boards and the firmware
  // on the 8U2 on the Uno and Mega 2560. Also, The baud_setting cannot
  // be > 4095, so switch back to non-u2x mode if the baud rate is too
  // low.
  if (((F_CPU == 16000000UL) && (baud == 57600)) || (baud_setting >4095))
    3bf2:	41 15       	cp	r20, r1
    3bf4:	51 4e       	sbci	r21, 0xE1	; 225
    3bf6:	61 05       	cpc	r22, r1
    3bf8:	71 05       	cpc	r23, r1
    3bfa:	b1 f0       	breq	.+44     	; 0x3c28 <_ZN14HardwareSerial5beginEmh+0x54>
// Public Methods //////////////////////////////////////////////////////////////

void HardwareSerial::begin(unsigned long baud, byte config)
{
  // Try u2x mode first
  uint16_t baud_setting = (F_CPU / 4 / baud - 1) / 2;
    3bfc:	60 e0       	ldi	r22, 0x00	; 0
    3bfe:	79 e0       	ldi	r23, 0x09	; 9
    3c00:	8d e3       	ldi	r24, 0x3D	; 61
    3c02:	90 e0       	ldi	r25, 0x00	; 0
    3c04:	a7 01       	movw	r20, r14
    3c06:	96 01       	movw	r18, r12
    3c08:	0e 94 c5 23 	call	0x478a	; 0x478a <__udivmodsi4>
    3c0c:	da 01       	movw	r26, r20
    3c0e:	c9 01       	movw	r24, r18
    3c10:	01 97       	sbiw	r24, 0x01	; 1
    3c12:	a1 09       	sbc	r26, r1
    3c14:	b1 09       	sbc	r27, r1
    3c16:	b6 95       	lsr	r27
    3c18:	a7 95       	ror	r26
    3c1a:	97 95       	ror	r25
    3c1c:	87 95       	ror	r24
    3c1e:	9c 01       	movw	r18, r24
  // hardcoded exception for 57600 for compatibility with the bootloader
  // shipped with the Duemilanove and previous boards and the firmware
  // on the 8U2 on the Uno and Mega 2560. Also, The baud_setting cannot
  // be > 4095, so switch back to non-u2x mode if the baud rate is too
  // low.
  if (((F_CPU == 16000000UL) && (baud == 57600)) || (baud_setting >4095))
    3c20:	21 15       	cp	r18, r1
    3c22:	80 e1       	ldi	r24, 0x10	; 16
    3c24:	38 07       	cpc	r19, r24
    3c26:	a8 f0       	brcs	.+42     	; 0x3c52 <_ZN14HardwareSerial5beginEmh+0x7e>
  {
    *_ucsra = 0;
    3c28:	e8 89       	ldd	r30, Y+16	; 0x10
    3c2a:	f9 89       	ldd	r31, Y+17	; 0x11
    3c2c:	10 82       	st	Z, r1
    baud_setting = (F_CPU / 8 / baud - 1) / 2;
    3c2e:	60 e8       	ldi	r22, 0x80	; 128
    3c30:	74 e8       	ldi	r23, 0x84	; 132
    3c32:	8e e1       	ldi	r24, 0x1E	; 30
    3c34:	90 e0       	ldi	r25, 0x00	; 0
    3c36:	a7 01       	movw	r20, r14
    3c38:	96 01       	movw	r18, r12
    3c3a:	0e 94 c5 23 	call	0x478a	; 0x478a <__udivmodsi4>
    3c3e:	da 01       	movw	r26, r20
    3c40:	c9 01       	movw	r24, r18
    3c42:	01 97       	sbiw	r24, 0x01	; 1
    3c44:	a1 09       	sbc	r26, r1
    3c46:	b1 09       	sbc	r27, r1
    3c48:	b6 95       	lsr	r27
    3c4a:	a7 95       	ror	r26
    3c4c:	97 95       	ror	r25
    3c4e:	87 95       	ror	r24
    3c50:	9c 01       	movw	r18, r24
  }

  // assign the baud_setting, a.k.a. ubrr (USART Baud Rate Register)
  *_ubrrh = baud_setting >> 8;
    3c52:	ec 85       	ldd	r30, Y+12	; 0x0c
    3c54:	fd 85       	ldd	r31, Y+13	; 0x0d
    3c56:	30 83       	st	Z, r19
  *_ubrrl = baud_setting;
    3c58:	ee 85       	ldd	r30, Y+14	; 0x0e
    3c5a:	ff 85       	ldd	r31, Y+15	; 0x0f
    3c5c:	20 83       	st	Z, r18

  _written = false;
    3c5e:	18 8e       	std	Y+24, r1	; 0x18

  //set the data bits, parity, and stop bits
#if defined(__AVR_ATmega8__)
  config |= 0x80; // select UCSRC register (shared with UBRRH)
#endif
  *_ucsrc = config;
    3c60:	ec 89       	ldd	r30, Y+20	; 0x14
    3c62:	fd 89       	ldd	r31, Y+21	; 0x15
    3c64:	10 83       	st	Z, r17
  
  sbi(*_ucsrb, RXEN0);
    3c66:	ea 89       	ldd	r30, Y+18	; 0x12
    3c68:	fb 89       	ldd	r31, Y+19	; 0x13
    3c6a:	80 81       	ld	r24, Z
    3c6c:	80 61       	ori	r24, 0x10	; 16
    3c6e:	80 83       	st	Z, r24
  sbi(*_ucsrb, TXEN0);
    3c70:	ea 89       	ldd	r30, Y+18	; 0x12
    3c72:	fb 89       	ldd	r31, Y+19	; 0x13
    3c74:	80 81       	ld	r24, Z
    3c76:	88 60       	ori	r24, 0x08	; 8
    3c78:	80 83       	st	Z, r24
  sbi(*_ucsrb, RXCIE0);
    3c7a:	ea 89       	ldd	r30, Y+18	; 0x12
    3c7c:	fb 89       	ldd	r31, Y+19	; 0x13
    3c7e:	80 81       	ld	r24, Z
    3c80:	80 68       	ori	r24, 0x80	; 128
    3c82:	80 83       	st	Z, r24
  cbi(*_ucsrb, UDRIE0);
    3c84:	ea 89       	ldd	r30, Y+18	; 0x12
    3c86:	fb 89       	ldd	r31, Y+19	; 0x13
    3c88:	80 81       	ld	r24, Z
    3c8a:	8f 7d       	andi	r24, 0xDF	; 223
    3c8c:	80 83       	st	Z, r24
}
    3c8e:	df 91       	pop	r29
    3c90:	cf 91       	pop	r28
    3c92:	1f 91       	pop	r17
    3c94:	ff 90       	pop	r15
    3c96:	ef 90       	pop	r14
    3c98:	df 90       	pop	r13
    3c9a:	cf 90       	pop	r12
    3c9c:	08 95       	ret

00003c9e <__vector_18>:
#elif defined(USART_RXC_vect)
  ISR(USART_RXC_vect) // ATmega8
#else
  #error "Don't know what the Data Received vector is called for Serial"
#endif
  {
    3c9e:	1f 92       	push	r1
    3ca0:	0f 92       	push	r0
    3ca2:	0f b6       	in	r0, 0x3f	; 63
    3ca4:	0f 92       	push	r0
    3ca6:	11 24       	eor	r1, r1
    3ca8:	2f 93       	push	r18
    3caa:	8f 93       	push	r24
    3cac:	9f 93       	push	r25
    3cae:	ef 93       	push	r30
    3cb0:	ff 93       	push	r31

// Actual interrupt handlers //////////////////////////////////////////////////////////////

void HardwareSerial::_rx_complete_irq(void)
{
  if (bit_is_clear(*_ucsra, UPE0)) {
    3cb2:	e0 91 33 04 	lds	r30, 0x0433	; 0x800433 <Serial+0x10>
    3cb6:	f0 91 34 04 	lds	r31, 0x0434	; 0x800434 <Serial+0x11>
    3cba:	80 81       	ld	r24, Z
    3cbc:	e0 91 39 04 	lds	r30, 0x0439	; 0x800439 <Serial+0x16>
    3cc0:	f0 91 3a 04 	lds	r31, 0x043A	; 0x80043a <Serial+0x17>
    3cc4:	82 fd       	sbrc	r24, 2
    3cc6:	12 c0       	rjmp	.+36     	; 0x3cec <__vector_18+0x4e>
    // No Parity error, read byte and store it in the buffer if there is
    // room
    unsigned char c = *_udr;
    3cc8:	90 81       	ld	r25, Z
    rx_buffer_index_t i = (unsigned int)(_rx_buffer_head + 1) % SERIAL_RX_BUFFER_SIZE;
    3cca:	80 91 3c 04 	lds	r24, 0x043C	; 0x80043c <Serial+0x19>
    3cce:	8f 5f       	subi	r24, 0xFF	; 255
    3cd0:	8f 73       	andi	r24, 0x3F	; 63

    // if we should be storing the received character into the location
    // just before the tail (meaning that the head would advance to the
    // current location of the tail), we're about to overflow the buffer
    // and so we don't write the character or advance the head.
    if (i != _rx_buffer_tail) {
    3cd2:	20 91 3d 04 	lds	r18, 0x043D	; 0x80043d <Serial+0x1a>
    3cd6:	82 17       	cp	r24, r18
    3cd8:	51 f0       	breq	.+20     	; 0x3cee <__vector_18+0x50>
      _rx_buffer[_rx_buffer_head] = c;
    3cda:	e0 91 3c 04 	lds	r30, 0x043C	; 0x80043c <Serial+0x19>
    3cde:	f0 e0       	ldi	r31, 0x00	; 0
    3ce0:	ed 5d       	subi	r30, 0xDD	; 221
    3ce2:	fb 4f       	sbci	r31, 0xFB	; 251
    3ce4:	95 8f       	std	Z+29, r25	; 0x1d
      _rx_buffer_head = i;
    3ce6:	80 93 3c 04 	sts	0x043C, r24	; 0x80043c <Serial+0x19>
    3cea:	01 c0       	rjmp	.+2      	; 0x3cee <__vector_18+0x50>
    }
  } else {
    // Parity error, read byte but discard it
    *_udr;
    3cec:	80 81       	ld	r24, Z
    Serial._rx_complete_irq();
  }
    3cee:	ff 91       	pop	r31
    3cf0:	ef 91       	pop	r30
    3cf2:	9f 91       	pop	r25
    3cf4:	8f 91       	pop	r24
    3cf6:	2f 91       	pop	r18
    3cf8:	0f 90       	pop	r0
    3cfa:	0f be       	out	0x3f, r0	; 63
    3cfc:	0f 90       	pop	r0
    3cfe:	1f 90       	pop	r1
    3d00:	18 95       	reti

00003d02 <__vector_19>:
#elif defined(USART_UDRE_vect)
ISR(USART_UDRE_vect)
#else
  #error "Don't know what the Data Register Empty vector is called for Serial"
#endif
{
    3d02:	1f 92       	push	r1
    3d04:	0f 92       	push	r0
    3d06:	0f b6       	in	r0, 0x3f	; 63
    3d08:	0f 92       	push	r0
    3d0a:	11 24       	eor	r1, r1
    3d0c:	2f 93       	push	r18
    3d0e:	3f 93       	push	r19
    3d10:	4f 93       	push	r20
    3d12:	5f 93       	push	r21
    3d14:	6f 93       	push	r22
    3d16:	7f 93       	push	r23
    3d18:	8f 93       	push	r24
    3d1a:	9f 93       	push	r25
    3d1c:	af 93       	push	r26
    3d1e:	bf 93       	push	r27
    3d20:	ef 93       	push	r30
    3d22:	ff 93       	push	r31
  Serial._tx_udr_empty_irq();
    3d24:	83 e2       	ldi	r24, 0x23	; 35
    3d26:	94 e0       	ldi	r25, 0x04	; 4
    3d28:	0e 94 59 1d 	call	0x3ab2	; 0x3ab2 <_ZN14HardwareSerial17_tx_udr_empty_irqEv>
}
    3d2c:	ff 91       	pop	r31
    3d2e:	ef 91       	pop	r30
    3d30:	bf 91       	pop	r27
    3d32:	af 91       	pop	r26
    3d34:	9f 91       	pop	r25
    3d36:	8f 91       	pop	r24
    3d38:	7f 91       	pop	r23
    3d3a:	6f 91       	pop	r22
    3d3c:	5f 91       	pop	r21
    3d3e:	4f 91       	pop	r20
    3d40:	3f 91       	pop	r19
    3d42:	2f 91       	pop	r18
    3d44:	0f 90       	pop	r0
    3d46:	0f be       	out	0x3f, r0	; 63
    3d48:	0f 90       	pop	r0
    3d4a:	1f 90       	pop	r1
    3d4c:	18 95       	reti

00003d4e <_Z17Serial0_availablev>:
#endif

// Function that can be weakly referenced by serialEventRun to prevent
// pulling in this file if it's not otherwise used.
bool Serial0_available() {
  return Serial.available();
    3d4e:	83 e2       	ldi	r24, 0x23	; 35
    3d50:	94 e0       	ldi	r25, 0x04	; 4
    3d52:	0e 94 0e 1d 	call	0x3a1c	; 0x3a1c <_ZN14HardwareSerial9availableEv>
    3d56:	21 e0       	ldi	r18, 0x01	; 1
    3d58:	89 2b       	or	r24, r25
    3d5a:	09 f4       	brne	.+2      	; 0x3d5e <_Z17Serial0_availablev+0x10>
    3d5c:	20 e0       	ldi	r18, 0x00	; 0
}
    3d5e:	82 2f       	mov	r24, r18
    3d60:	08 95       	ret

00003d62 <_GLOBAL__sub_I___vector_18>:
    size_t printNumber(unsigned long, uint8_t);
    size_t printFloat(double, uint8_t);
  protected:
    void setWriteError(int err = 1) { write_error = err; }
  public:
    Print() : write_error(0) {}
    3d62:	e3 e2       	ldi	r30, 0x23	; 35
    3d64:	f4 e0       	ldi	r31, 0x04	; 4
    3d66:	13 82       	std	Z+3, r1	; 0x03
    3d68:	12 82       	std	Z+2, r1	; 0x02
  public:
    virtual int available() = 0;
    virtual int read() = 0;
    virtual int peek() = 0;

    Stream() {_timeout=1000;}
    3d6a:	88 ee       	ldi	r24, 0xE8	; 232
    3d6c:	93 e0       	ldi	r25, 0x03	; 3
    3d6e:	a0 e0       	ldi	r26, 0x00	; 0
    3d70:	b0 e0       	ldi	r27, 0x00	; 0
    3d72:	84 83       	std	Z+4, r24	; 0x04
    3d74:	95 83       	std	Z+5, r25	; 0x05
    3d76:	a6 83       	std	Z+6, r26	; 0x06
    3d78:	b7 83       	std	Z+7, r27	; 0x07
  volatile uint8_t *ucsrc, volatile uint8_t *udr) :
    _ubrrh(ubrrh), _ubrrl(ubrrl),
    _ucsra(ucsra), _ucsrb(ucsrb), _ucsrc(ucsrc),
    _udr(udr),
    _rx_buffer_head(0), _rx_buffer_tail(0),
    _tx_buffer_head(0), _tx_buffer_tail(0)
    3d7a:	89 ef       	ldi	r24, 0xF9	; 249
    3d7c:	91 e0       	ldi	r25, 0x01	; 1
    3d7e:	91 83       	std	Z+1, r25	; 0x01
    3d80:	80 83       	st	Z, r24
    3d82:	85 ec       	ldi	r24, 0xC5	; 197
    3d84:	90 e0       	ldi	r25, 0x00	; 0
    3d86:	95 87       	std	Z+13, r25	; 0x0d
    3d88:	84 87       	std	Z+12, r24	; 0x0c
    3d8a:	84 ec       	ldi	r24, 0xC4	; 196
    3d8c:	90 e0       	ldi	r25, 0x00	; 0
    3d8e:	97 87       	std	Z+15, r25	; 0x0f
    3d90:	86 87       	std	Z+14, r24	; 0x0e
    3d92:	80 ec       	ldi	r24, 0xC0	; 192
    3d94:	90 e0       	ldi	r25, 0x00	; 0
    3d96:	91 8b       	std	Z+17, r25	; 0x11
    3d98:	80 8b       	std	Z+16, r24	; 0x10
    3d9a:	81 ec       	ldi	r24, 0xC1	; 193
    3d9c:	90 e0       	ldi	r25, 0x00	; 0
    3d9e:	93 8b       	std	Z+19, r25	; 0x13
    3da0:	82 8b       	std	Z+18, r24	; 0x12
    3da2:	82 ec       	ldi	r24, 0xC2	; 194
    3da4:	90 e0       	ldi	r25, 0x00	; 0
    3da6:	95 8b       	std	Z+21, r25	; 0x15
    3da8:	84 8b       	std	Z+20, r24	; 0x14
    3daa:	86 ec       	ldi	r24, 0xC6	; 198
    3dac:	90 e0       	ldi	r25, 0x00	; 0
    3dae:	97 8b       	std	Z+23, r25	; 0x17
    3db0:	86 8b       	std	Z+22, r24	; 0x16
    3db2:	11 8e       	std	Z+25, r1	; 0x19
    3db4:	12 8e       	std	Z+26, r1	; 0x1a
    3db6:	13 8e       	std	Z+27, r1	; 0x1b
    3db8:	14 8e       	std	Z+28, r1	; 0x1c
    3dba:	08 95       	ret

00003dbc <main>:
void setupUSB() __attribute__((weak));
void setupUSB() { }

int main(void)
{
	init();
    3dbc:	0e 94 4f 21 	call	0x429e	; 0x429e <init>

	initVariant();
    3dc0:	0e 94 97 16 	call	0x2d2e	; 0x2d2e <initVariant>

#if defined(USBCON)
	USBDevice.attach();
#endif
	
	setup();
    3dc4:	0e 94 d0 05 	call	0xba0	; 0xba0 <setup>
    
	for (;;) {
		loop();
		if (serialEventRun) serialEventRun();
    3dc8:	cb e4       	ldi	r28, 0x4B	; 75
    3dca:	dd e1       	ldi	r29, 0x1D	; 29
#endif
	
	setup();
    
	for (;;) {
		loop();
    3dcc:	0e 94 5b 06 	call	0xcb6	; 0xcb6 <loop>
		if (serialEventRun) serialEventRun();
    3dd0:	20 97       	sbiw	r28, 0x00	; 0
    3dd2:	e1 f3       	breq	.-8      	; 0x3dcc <main+0x10>
    3dd4:	0e 94 4b 1d 	call	0x3a96	; 0x3a96 <_Z14serialEventRunv>
    3dd8:	f9 cf       	rjmp	.-14     	; 0x3dcc <main+0x10>

00003dda <_ZN5Print5writeEPKhj>:
size_t Print::println(unsigned long num, int base)
{
  size_t n = print(num, base);
  n += println();
  return n;
}
    3dda:	cf 92       	push	r12
    3ddc:	df 92       	push	r13
    3dde:	ef 92       	push	r14
    3de0:	ff 92       	push	r15
    3de2:	0f 93       	push	r16
    3de4:	1f 93       	push	r17
    3de6:	cf 93       	push	r28
    3de8:	df 93       	push	r29
    3dea:	6c 01       	movw	r12, r24
    3dec:	7a 01       	movw	r14, r20
    3dee:	8b 01       	movw	r16, r22
    3df0:	c0 e0       	ldi	r28, 0x00	; 0
    3df2:	d0 e0       	ldi	r29, 0x00	; 0
    3df4:	ce 15       	cp	r28, r14
    3df6:	df 05       	cpc	r29, r15
    3df8:	81 f0       	breq	.+32     	; 0x3e1a <_ZN5Print5writeEPKhj+0x40>
    3dfa:	d8 01       	movw	r26, r16
    3dfc:	6d 91       	ld	r22, X+
    3dfe:	8d 01       	movw	r16, r26
    3e00:	d6 01       	movw	r26, r12
    3e02:	ed 91       	ld	r30, X+
    3e04:	fc 91       	ld	r31, X
    3e06:	01 90       	ld	r0, Z+
    3e08:	f0 81       	ld	r31, Z
    3e0a:	e0 2d       	mov	r30, r0
    3e0c:	c6 01       	movw	r24, r12
    3e0e:	09 95       	icall
    3e10:	89 2b       	or	r24, r25
    3e12:	11 f0       	breq	.+4      	; 0x3e18 <_ZN5Print5writeEPKhj+0x3e>
    3e14:	21 96       	adiw	r28, 0x01	; 1
    3e16:	ee cf       	rjmp	.-36     	; 0x3df4 <_ZN5Print5writeEPKhj+0x1a>
    3e18:	7e 01       	movw	r14, r28
    3e1a:	c7 01       	movw	r24, r14
    3e1c:	df 91       	pop	r29
    3e1e:	cf 91       	pop	r28
    3e20:	1f 91       	pop	r17
    3e22:	0f 91       	pop	r16
    3e24:	ff 90       	pop	r15
    3e26:	ef 90       	pop	r14
    3e28:	df 90       	pop	r13
    3e2a:	cf 90       	pop	r12
    3e2c:	08 95       	ret

00003e2e <_ZN5Print5printEPK19__FlashStringHelper>:
    3e2e:	ef 92       	push	r14
    3e30:	ff 92       	push	r15
    3e32:	0f 93       	push	r16
    3e34:	1f 93       	push	r17
    3e36:	cf 93       	push	r28
    3e38:	df 93       	push	r29
    3e3a:	8c 01       	movw	r16, r24
    3e3c:	7b 01       	movw	r14, r22
    3e3e:	c0 e0       	ldi	r28, 0x00	; 0
    3e40:	d0 e0       	ldi	r29, 0x00	; 0
    3e42:	f7 01       	movw	r30, r14
    3e44:	ec 0f       	add	r30, r28
    3e46:	fd 1f       	adc	r31, r29
    3e48:	64 91       	lpm	r22, Z
    3e4a:	66 23       	and	r22, r22
    3e4c:	61 f0       	breq	.+24     	; 0x3e66 <_ZN5Print5printEPK19__FlashStringHelper+0x38>
    3e4e:	d8 01       	movw	r26, r16
    3e50:	ed 91       	ld	r30, X+
    3e52:	fc 91       	ld	r31, X
    3e54:	01 90       	ld	r0, Z+
    3e56:	f0 81       	ld	r31, Z
    3e58:	e0 2d       	mov	r30, r0
    3e5a:	c8 01       	movw	r24, r16
    3e5c:	09 95       	icall
    3e5e:	89 2b       	or	r24, r25
    3e60:	11 f0       	breq	.+4      	; 0x3e66 <_ZN5Print5printEPK19__FlashStringHelper+0x38>
    3e62:	21 96       	adiw	r28, 0x01	; 1
    3e64:	ee cf       	rjmp	.-36     	; 0x3e42 <_ZN5Print5printEPK19__FlashStringHelper+0x14>
    3e66:	ce 01       	movw	r24, r28
    3e68:	df 91       	pop	r29
    3e6a:	cf 91       	pop	r28
    3e6c:	1f 91       	pop	r17
    3e6e:	0f 91       	pop	r16
    3e70:	ff 90       	pop	r15
    3e72:	ef 90       	pop	r14
    3e74:	08 95       	ret

00003e76 <_ZN5Print5printEPKc>:
    3e76:	0c 94 b3 00 	jmp	0x166	; 0x166 <_ZN5Print5writeEPKc>

00003e7a <_ZN5Print5printEc>:
    3e7a:	dc 01       	movw	r26, r24
    3e7c:	ed 91       	ld	r30, X+
    3e7e:	fc 91       	ld	r31, X
    3e80:	01 90       	ld	r0, Z+
    3e82:	f0 81       	ld	r31, Z
    3e84:	e0 2d       	mov	r30, r0
    3e86:	09 94       	ijmp

00003e88 <_ZN5Print7printlnEv>:
    3e88:	67 e0       	ldi	r22, 0x07	; 7
    3e8a:	72 e0       	ldi	r23, 0x02	; 2
    3e8c:	0c 94 b3 00 	jmp	0x166	; 0x166 <_ZN5Print5writeEPKc>

00003e90 <_ZN5Print7printlnEPKc>:
    3e90:	0f 93       	push	r16
    3e92:	1f 93       	push	r17
    3e94:	cf 93       	push	r28
    3e96:	df 93       	push	r29
    3e98:	ec 01       	movw	r28, r24
    3e9a:	0e 94 b3 00 	call	0x166	; 0x166 <_ZN5Print5writeEPKc>
    3e9e:	8c 01       	movw	r16, r24
    3ea0:	ce 01       	movw	r24, r28
    3ea2:	0e 94 44 1f 	call	0x3e88	; 0x3e88 <_ZN5Print7printlnEv>
    3ea6:	80 0f       	add	r24, r16
    3ea8:	91 1f       	adc	r25, r17
    3eaa:	df 91       	pop	r29
    3eac:	cf 91       	pop	r28
    3eae:	1f 91       	pop	r17
    3eb0:	0f 91       	pop	r16
    3eb2:	08 95       	ret

00003eb4 <_ZN5Print11printNumberEmh>:
    3eb4:	8f 92       	push	r8
    3eb6:	9f 92       	push	r9
    3eb8:	af 92       	push	r10
    3eba:	bf 92       	push	r11
    3ebc:	ef 92       	push	r14
    3ebe:	ff 92       	push	r15
    3ec0:	0f 93       	push	r16
    3ec2:	1f 93       	push	r17
    3ec4:	cf 93       	push	r28
    3ec6:	df 93       	push	r29
    3ec8:	cd b7       	in	r28, 0x3d	; 61
    3eca:	de b7       	in	r29, 0x3e	; 62
    3ecc:	a1 97       	sbiw	r28, 0x21	; 33
    3ece:	0f b6       	in	r0, 0x3f	; 63
    3ed0:	f8 94       	cli
    3ed2:	de bf       	out	0x3e, r29	; 62
    3ed4:	0f be       	out	0x3f, r0	; 63
    3ed6:	cd bf       	out	0x3d, r28	; 61
    3ed8:	7c 01       	movw	r14, r24
    3eda:	fa 01       	movw	r30, r20
    3edc:	cb 01       	movw	r24, r22
    3ede:	19 a2       	std	Y+33, r1	; 0x21
    3ee0:	22 30       	cpi	r18, 0x02	; 2
    3ee2:	08 f4       	brcc	.+2      	; 0x3ee6 <_ZN5Print11printNumberEmh+0x32>
    3ee4:	2a e0       	ldi	r18, 0x0A	; 10
    3ee6:	8e 01       	movw	r16, r28
    3ee8:	0f 5d       	subi	r16, 0xDF	; 223
    3eea:	1f 4f       	sbci	r17, 0xFF	; 255
    3eec:	82 2e       	mov	r8, r18
    3eee:	91 2c       	mov	r9, r1
    3ef0:	a1 2c       	mov	r10, r1
    3ef2:	b1 2c       	mov	r11, r1
    3ef4:	bf 01       	movw	r22, r30
    3ef6:	a5 01       	movw	r20, r10
    3ef8:	94 01       	movw	r18, r8
    3efa:	0e 94 c5 23 	call	0x478a	; 0x478a <__udivmodsi4>
    3efe:	f9 01       	movw	r30, r18
    3f00:	ca 01       	movw	r24, r20
    3f02:	01 50       	subi	r16, 0x01	; 1
    3f04:	11 09       	sbc	r17, r1
    3f06:	6a 30       	cpi	r22, 0x0A	; 10
    3f08:	10 f4       	brcc	.+4      	; 0x3f0e <_ZN5Print11printNumberEmh+0x5a>
    3f0a:	60 5d       	subi	r22, 0xD0	; 208
    3f0c:	01 c0       	rjmp	.+2      	; 0x3f10 <_ZN5Print11printNumberEmh+0x5c>
    3f0e:	69 5c       	subi	r22, 0xC9	; 201
    3f10:	d8 01       	movw	r26, r16
    3f12:	6c 93       	st	X, r22
    3f14:	23 2b       	or	r18, r19
    3f16:	24 2b       	or	r18, r20
    3f18:	25 2b       	or	r18, r21
    3f1a:	61 f7       	brne	.-40     	; 0x3ef4 <_ZN5Print11printNumberEmh+0x40>
    3f1c:	b8 01       	movw	r22, r16
    3f1e:	c7 01       	movw	r24, r14
    3f20:	0e 94 b3 00 	call	0x166	; 0x166 <_ZN5Print5writeEPKc>
    3f24:	a1 96       	adiw	r28, 0x21	; 33
    3f26:	0f b6       	in	r0, 0x3f	; 63
    3f28:	f8 94       	cli
    3f2a:	de bf       	out	0x3e, r29	; 62
    3f2c:	0f be       	out	0x3f, r0	; 63
    3f2e:	cd bf       	out	0x3d, r28	; 61
    3f30:	df 91       	pop	r29
    3f32:	cf 91       	pop	r28
    3f34:	1f 91       	pop	r17
    3f36:	0f 91       	pop	r16
    3f38:	ff 90       	pop	r15
    3f3a:	ef 90       	pop	r14
    3f3c:	bf 90       	pop	r11
    3f3e:	af 90       	pop	r10
    3f40:	9f 90       	pop	r9
    3f42:	8f 90       	pop	r8
    3f44:	08 95       	ret

00003f46 <_ZN5Print5printEmi>:
    3f46:	21 15       	cp	r18, r1
    3f48:	31 05       	cpc	r19, r1
    3f4a:	41 f4       	brne	.+16     	; 0x3f5c <_ZN5Print5printEmi+0x16>
    3f4c:	dc 01       	movw	r26, r24
    3f4e:	ed 91       	ld	r30, X+
    3f50:	fc 91       	ld	r31, X
    3f52:	01 90       	ld	r0, Z+
    3f54:	f0 81       	ld	r31, Z
    3f56:	e0 2d       	mov	r30, r0
    3f58:	64 2f       	mov	r22, r20
    3f5a:	09 94       	ijmp
    3f5c:	0c 94 5a 1f 	jmp	0x3eb4	; 0x3eb4 <_ZN5Print11printNumberEmh>

00003f60 <_ZN5Print5printEhi>:
    3f60:	9a 01       	movw	r18, r20
    3f62:	46 2f       	mov	r20, r22
    3f64:	50 e0       	ldi	r21, 0x00	; 0
    3f66:	60 e0       	ldi	r22, 0x00	; 0
    3f68:	70 e0       	ldi	r23, 0x00	; 0
    3f6a:	0c 94 a3 1f 	jmp	0x3f46	; 0x3f46 <_ZN5Print5printEmi>

00003f6e <_ZN5Print7printlnEhi>:
    3f6e:	0f 93       	push	r16
    3f70:	1f 93       	push	r17
    3f72:	cf 93       	push	r28
    3f74:	df 93       	push	r29
    3f76:	ec 01       	movw	r28, r24
    3f78:	0e 94 b0 1f 	call	0x3f60	; 0x3f60 <_ZN5Print5printEhi>
    3f7c:	8c 01       	movw	r16, r24
    3f7e:	ce 01       	movw	r24, r28
    3f80:	0e 94 44 1f 	call	0x3e88	; 0x3e88 <_ZN5Print7printlnEv>
    3f84:	80 0f       	add	r24, r16
    3f86:	91 1f       	adc	r25, r17
    3f88:	df 91       	pop	r29
    3f8a:	cf 91       	pop	r28
    3f8c:	1f 91       	pop	r17
    3f8e:	0f 91       	pop	r16
    3f90:	08 95       	ret

00003f92 <_ZN5Print5printEli>:
{
  return print((unsigned long) n, base);
}

size_t Print::print(long n, int base)
{
    3f92:	cf 92       	push	r12
    3f94:	df 92       	push	r13
    3f96:	ef 92       	push	r14
    3f98:	ff 92       	push	r15
    3f9a:	0f 93       	push	r16
    3f9c:	1f 93       	push	r17
    3f9e:	cf 93       	push	r28
    3fa0:	df 93       	push	r29
  if (base == 0) {
    3fa2:	21 15       	cp	r18, r1
    3fa4:	31 05       	cpc	r19, r1
    3fa6:	81 f4       	brne	.+32     	; 0x3fc8 <_ZN5Print5printEli+0x36>
    return write(n);
    3fa8:	dc 01       	movw	r26, r24
    3faa:	ed 91       	ld	r30, X+
    3fac:	fc 91       	ld	r31, X
    3fae:	01 90       	ld	r0, Z+
    3fb0:	f0 81       	ld	r31, Z
    3fb2:	e0 2d       	mov	r30, r0
    3fb4:	64 2f       	mov	r22, r20
    }
    return printNumber(n, 10);
  } else {
    return printNumber(n, base);
  }
}
    3fb6:	df 91       	pop	r29
    3fb8:	cf 91       	pop	r28
    3fba:	1f 91       	pop	r17
    3fbc:	0f 91       	pop	r16
    3fbe:	ff 90       	pop	r15
    3fc0:	ef 90       	pop	r14
    3fc2:	df 90       	pop	r13
    3fc4:	cf 90       	pop	r12
}

size_t Print::print(long n, int base)
{
  if (base == 0) {
    return write(n);
    3fc6:	09 94       	ijmp
  } else if (base == 10) {
    3fc8:	2a 30       	cpi	r18, 0x0A	; 10
    3fca:	31 05       	cpc	r19, r1
    3fcc:	01 f5       	brne	.+64     	; 0x400e <_ZN5Print5printEli+0x7c>
    if (n < 0) {
    3fce:	77 ff       	sbrs	r23, 7
    3fd0:	1d c0       	rjmp	.+58     	; 0x400c <_ZN5Print5printEli+0x7a>
    3fd2:	6a 01       	movw	r12, r20
    3fd4:	7b 01       	movw	r14, r22
    3fd6:	ec 01       	movw	r28, r24
      int t = print('-');
    3fd8:	6d e2       	ldi	r22, 0x2D	; 45
    3fda:	0e 94 3d 1f 	call	0x3e7a	; 0x3e7a <_ZN5Print5printEc>
    3fde:	8c 01       	movw	r16, r24
      n = -n;
      return printNumber(n, 10) + t;
    3fe0:	44 27       	eor	r20, r20
    3fe2:	55 27       	eor	r21, r21
    3fe4:	ba 01       	movw	r22, r20
    3fe6:	4c 19       	sub	r20, r12
    3fe8:	5d 09       	sbc	r21, r13
    3fea:	6e 09       	sbc	r22, r14
    3fec:	7f 09       	sbc	r23, r15
    3fee:	2a e0       	ldi	r18, 0x0A	; 10
    3ff0:	ce 01       	movw	r24, r28
    3ff2:	0e 94 5a 1f 	call	0x3eb4	; 0x3eb4 <_ZN5Print11printNumberEmh>
    3ff6:	80 0f       	add	r24, r16
    3ff8:	91 1f       	adc	r25, r17
    }
    return printNumber(n, 10);
  } else {
    return printNumber(n, base);
  }
}
    3ffa:	df 91       	pop	r29
    3ffc:	cf 91       	pop	r28
    3ffe:	1f 91       	pop	r17
    4000:	0f 91       	pop	r16
    4002:	ff 90       	pop	r15
    4004:	ef 90       	pop	r14
    4006:	df 90       	pop	r13
    4008:	cf 90       	pop	r12
    400a:	08 95       	ret
    if (n < 0) {
      int t = print('-');
      n = -n;
      return printNumber(n, 10) + t;
    }
    return printNumber(n, 10);
    400c:	2a e0       	ldi	r18, 0x0A	; 10
  } else {
    return printNumber(n, base);
  }
}
    400e:	df 91       	pop	r29
    4010:	cf 91       	pop	r28
    4012:	1f 91       	pop	r17
    4014:	0f 91       	pop	r16
    4016:	ff 90       	pop	r15
    4018:	ef 90       	pop	r14
    401a:	df 90       	pop	r13
    401c:	cf 90       	pop	r12
      n = -n;
      return printNumber(n, 10) + t;
    }
    return printNumber(n, 10);
  } else {
    return printNumber(n, base);
    401e:	0c 94 5a 1f 	jmp	0x3eb4	; 0x3eb4 <_ZN5Print11printNumberEmh>

00004022 <_ZN5Print5printEii>:
{
  return print((unsigned long) b, base);
}

size_t Print::print(int n, int base)
{
    4022:	9a 01       	movw	r18, r20
  return print((long) n, base);
    4024:	ab 01       	movw	r20, r22
    4026:	77 0f       	add	r23, r23
    4028:	66 0b       	sbc	r22, r22
    402a:	77 0b       	sbc	r23, r23
    402c:	0c 94 c9 1f 	jmp	0x3f92	; 0x3f92 <_ZN5Print5printEli>

00004030 <_ZN5Print7printlnEii>:
  n += println();
  return n;
}

size_t Print::println(int num, int base)
{
    4030:	0f 93       	push	r16
    4032:	1f 93       	push	r17
    4034:	cf 93       	push	r28
    4036:	df 93       	push	r29
    4038:	ec 01       	movw	r28, r24
  size_t n = print(num, base);
    403a:	0e 94 11 20 	call	0x4022	; 0x4022 <_ZN5Print5printEii>
    403e:	8c 01       	movw	r16, r24
  n += println();
    4040:	ce 01       	movw	r24, r28
    4042:	0e 94 44 1f 	call	0x3e88	; 0x3e88 <_ZN5Print7printlnEv>
  return n;
}
    4046:	80 0f       	add	r24, r16
    4048:	91 1f       	adc	r25, r17
    404a:	df 91       	pop	r29
    404c:	cf 91       	pop	r28
    404e:	1f 91       	pop	r17
    4050:	0f 91       	pop	r16
    4052:	08 95       	ret

00004054 <nothing>:
    #endif
      break;       
#endif
    }
      
    intFunc[interruptNum] = nothing;
    4054:	08 95       	ret

00004056 <attachInterrupt>:
    4056:	82 30       	cpi	r24, 0x02	; 2
    4058:	e8 f4       	brcc	.+58     	; 0x4094 <attachInterrupt+0x3e>
    405a:	e8 2f       	mov	r30, r24
    405c:	f0 e0       	ldi	r31, 0x00	; 0
    405e:	ee 0f       	add	r30, r30
    4060:	ff 1f       	adc	r31, r31
    4062:	e3 5c       	subi	r30, 0xC3	; 195
    4064:	fe 4f       	sbci	r31, 0xFE	; 254
    4066:	71 83       	std	Z+1, r23	; 0x01
    4068:	60 83       	st	Z, r22
    406a:	81 30       	cpi	r24, 0x01	; 1
    406c:	41 f0       	breq	.+16     	; 0x407e <attachInterrupt+0x28>
    406e:	80 91 69 00 	lds	r24, 0x0069	; 0x800069 <__DATA_REGION_ORIGIN__+0x9>
    4072:	8c 7f       	andi	r24, 0xFC	; 252
    4074:	48 2b       	or	r20, r24
    4076:	40 93 69 00 	sts	0x0069, r20	; 0x800069 <__DATA_REGION_ORIGIN__+0x9>
    407a:	e8 9a       	sbi	0x1d, 0	; 29
    407c:	08 95       	ret
    407e:	80 91 69 00 	lds	r24, 0x0069	; 0x800069 <__DATA_REGION_ORIGIN__+0x9>
    4082:	83 7f       	andi	r24, 0xF3	; 243
    4084:	44 0f       	add	r20, r20
    4086:	55 1f       	adc	r21, r21
    4088:	44 0f       	add	r20, r20
    408a:	55 1f       	adc	r21, r21
    408c:	48 2b       	or	r20, r24
    408e:	40 93 69 00 	sts	0x0069, r20	; 0x800069 <__DATA_REGION_ORIGIN__+0x9>
    4092:	e9 9a       	sbi	0x1d, 1	; 29
    4094:	08 95       	ret

00004096 <__vector_1>:
IMPLEMENT_ISR(INT6_vect, EXTERNAL_INT_6)
IMPLEMENT_ISR(INT7_vect, EXTERNAL_INT_7)

#else

IMPLEMENT_ISR(INT0_vect, EXTERNAL_INT_0)
    4096:	1f 92       	push	r1
    4098:	0f 92       	push	r0
    409a:	0f b6       	in	r0, 0x3f	; 63
    409c:	0f 92       	push	r0
    409e:	11 24       	eor	r1, r1
    40a0:	2f 93       	push	r18
    40a2:	3f 93       	push	r19
    40a4:	4f 93       	push	r20
    40a6:	5f 93       	push	r21
    40a8:	6f 93       	push	r22
    40aa:	7f 93       	push	r23
    40ac:	8f 93       	push	r24
    40ae:	9f 93       	push	r25
    40b0:	af 93       	push	r26
    40b2:	bf 93       	push	r27
    40b4:	ef 93       	push	r30
    40b6:	ff 93       	push	r31
    40b8:	e0 91 3d 01 	lds	r30, 0x013D	; 0x80013d <intFunc>
    40bc:	f0 91 3e 01 	lds	r31, 0x013E	; 0x80013e <intFunc+0x1>
    40c0:	09 95       	icall
    40c2:	ff 91       	pop	r31
    40c4:	ef 91       	pop	r30
    40c6:	bf 91       	pop	r27
    40c8:	af 91       	pop	r26
    40ca:	9f 91       	pop	r25
    40cc:	8f 91       	pop	r24
    40ce:	7f 91       	pop	r23
    40d0:	6f 91       	pop	r22
    40d2:	5f 91       	pop	r21
    40d4:	4f 91       	pop	r20
    40d6:	3f 91       	pop	r19
    40d8:	2f 91       	pop	r18
    40da:	0f 90       	pop	r0
    40dc:	0f be       	out	0x3f, r0	; 63
    40de:	0f 90       	pop	r0
    40e0:	1f 90       	pop	r1
    40e2:	18 95       	reti

000040e4 <__vector_2>:
IMPLEMENT_ISR(INT1_vect, EXTERNAL_INT_1)
    40e4:	1f 92       	push	r1
    40e6:	0f 92       	push	r0
    40e8:	0f b6       	in	r0, 0x3f	; 63
    40ea:	0f 92       	push	r0
    40ec:	11 24       	eor	r1, r1
    40ee:	2f 93       	push	r18
    40f0:	3f 93       	push	r19
    40f2:	4f 93       	push	r20
    40f4:	5f 93       	push	r21
    40f6:	6f 93       	push	r22
    40f8:	7f 93       	push	r23
    40fa:	8f 93       	push	r24
    40fc:	9f 93       	push	r25
    40fe:	af 93       	push	r26
    4100:	bf 93       	push	r27
    4102:	ef 93       	push	r30
    4104:	ff 93       	push	r31
    4106:	e0 91 3f 01 	lds	r30, 0x013F	; 0x80013f <intFunc+0x2>
    410a:	f0 91 40 01 	lds	r31, 0x0140	; 0x800140 <intFunc+0x3>
    410e:	09 95       	icall
    4110:	ff 91       	pop	r31
    4112:	ef 91       	pop	r30
    4114:	bf 91       	pop	r27
    4116:	af 91       	pop	r26
    4118:	9f 91       	pop	r25
    411a:	8f 91       	pop	r24
    411c:	7f 91       	pop	r23
    411e:	6f 91       	pop	r22
    4120:	5f 91       	pop	r21
    4122:	4f 91       	pop	r20
    4124:	3f 91       	pop	r19
    4126:	2f 91       	pop	r18
    4128:	0f 90       	pop	r0
    412a:	0f be       	out	0x3f, r0	; 63
    412c:	0f 90       	pop	r0
    412e:	1f 90       	pop	r1
    4130:	18 95       	reti

00004132 <__vector_16>:
	cli();
	m = timer0_millis;
	SREG = oldSREG;

	return m;
}
    4132:	1f 92       	push	r1
    4134:	0f 92       	push	r0
    4136:	0f b6       	in	r0, 0x3f	; 63
    4138:	0f 92       	push	r0
    413a:	11 24       	eor	r1, r1
    413c:	2f 93       	push	r18
    413e:	3f 93       	push	r19
    4140:	8f 93       	push	r24
    4142:	9f 93       	push	r25
    4144:	af 93       	push	r26
    4146:	bf 93       	push	r27
    4148:	80 91 c1 04 	lds	r24, 0x04C1	; 0x8004c1 <timer0_millis>
    414c:	90 91 c2 04 	lds	r25, 0x04C2	; 0x8004c2 <timer0_millis+0x1>
    4150:	a0 91 c3 04 	lds	r26, 0x04C3	; 0x8004c3 <timer0_millis+0x2>
    4154:	b0 91 c4 04 	lds	r27, 0x04C4	; 0x8004c4 <timer0_millis+0x3>
    4158:	30 91 c0 04 	lds	r19, 0x04C0	; 0x8004c0 <timer0_fract>
    415c:	23 e0       	ldi	r18, 0x03	; 3
    415e:	23 0f       	add	r18, r19
    4160:	2d 37       	cpi	r18, 0x7D	; 125
    4162:	20 f4       	brcc	.+8      	; 0x416c <__vector_16+0x3a>
    4164:	01 96       	adiw	r24, 0x01	; 1
    4166:	a1 1d       	adc	r26, r1
    4168:	b1 1d       	adc	r27, r1
    416a:	05 c0       	rjmp	.+10     	; 0x4176 <__vector_16+0x44>
    416c:	26 e8       	ldi	r18, 0x86	; 134
    416e:	23 0f       	add	r18, r19
    4170:	02 96       	adiw	r24, 0x02	; 2
    4172:	a1 1d       	adc	r26, r1
    4174:	b1 1d       	adc	r27, r1
    4176:	20 93 c0 04 	sts	0x04C0, r18	; 0x8004c0 <timer0_fract>
    417a:	80 93 c1 04 	sts	0x04C1, r24	; 0x8004c1 <timer0_millis>
    417e:	90 93 c2 04 	sts	0x04C2, r25	; 0x8004c2 <timer0_millis+0x1>
    4182:	a0 93 c3 04 	sts	0x04C3, r26	; 0x8004c3 <timer0_millis+0x2>
    4186:	b0 93 c4 04 	sts	0x04C4, r27	; 0x8004c4 <timer0_millis+0x3>
    418a:	80 91 c5 04 	lds	r24, 0x04C5	; 0x8004c5 <timer0_overflow_count>
    418e:	90 91 c6 04 	lds	r25, 0x04C6	; 0x8004c6 <timer0_overflow_count+0x1>
    4192:	a0 91 c7 04 	lds	r26, 0x04C7	; 0x8004c7 <timer0_overflow_count+0x2>
    4196:	b0 91 c8 04 	lds	r27, 0x04C8	; 0x8004c8 <timer0_overflow_count+0x3>
    419a:	01 96       	adiw	r24, 0x01	; 1
    419c:	a1 1d       	adc	r26, r1
    419e:	b1 1d       	adc	r27, r1
    41a0:	80 93 c5 04 	sts	0x04C5, r24	; 0x8004c5 <timer0_overflow_count>
    41a4:	90 93 c6 04 	sts	0x04C6, r25	; 0x8004c6 <timer0_overflow_count+0x1>
    41a8:	a0 93 c7 04 	sts	0x04C7, r26	; 0x8004c7 <timer0_overflow_count+0x2>
    41ac:	b0 93 c8 04 	sts	0x04C8, r27	; 0x8004c8 <timer0_overflow_count+0x3>
    41b0:	bf 91       	pop	r27
    41b2:	af 91       	pop	r26
    41b4:	9f 91       	pop	r25
    41b6:	8f 91       	pop	r24
    41b8:	3f 91       	pop	r19
    41ba:	2f 91       	pop	r18
    41bc:	0f 90       	pop	r0
    41be:	0f be       	out	0x3f, r0	; 63
    41c0:	0f 90       	pop	r0
    41c2:	1f 90       	pop	r1
    41c4:	18 95       	reti

000041c6 <micros>:

unsigned long micros() {
	unsigned long m;
	uint8_t oldSREG = SREG, t;
    41c6:	3f b7       	in	r19, 0x3f	; 63
	
	cli();
    41c8:	f8 94       	cli
	m = timer0_overflow_count;
    41ca:	80 91 c5 04 	lds	r24, 0x04C5	; 0x8004c5 <timer0_overflow_count>
    41ce:	90 91 c6 04 	lds	r25, 0x04C6	; 0x8004c6 <timer0_overflow_count+0x1>
    41d2:	a0 91 c7 04 	lds	r26, 0x04C7	; 0x8004c7 <timer0_overflow_count+0x2>
    41d6:	b0 91 c8 04 	lds	r27, 0x04C8	; 0x8004c8 <timer0_overflow_count+0x3>
#if defined(TCNT0)
	t = TCNT0;
    41da:	26 b5       	in	r18, 0x26	; 38
#else
	#error TIMER 0 not defined
#endif

#ifdef TIFR0
	if ((TIFR0 & _BV(TOV0)) && (t < 255))
    41dc:	a8 9b       	sbis	0x15, 0	; 21
    41de:	05 c0       	rjmp	.+10     	; 0x41ea <micros+0x24>
    41e0:	2f 3f       	cpi	r18, 0xFF	; 255
    41e2:	19 f0       	breq	.+6      	; 0x41ea <micros+0x24>
		m++;
    41e4:	01 96       	adiw	r24, 0x01	; 1
    41e6:	a1 1d       	adc	r26, r1
    41e8:	b1 1d       	adc	r27, r1
#else
	if ((TIFR & _BV(TOV0)) && (t < 255))
		m++;
#endif

	SREG = oldSREG;
    41ea:	3f bf       	out	0x3f, r19	; 63
	
	return ((m << 8) + t) * (64 / clockCyclesPerMicrosecond());
    41ec:	ba 2f       	mov	r27, r26
    41ee:	a9 2f       	mov	r26, r25
    41f0:	98 2f       	mov	r25, r24
    41f2:	88 27       	eor	r24, r24
    41f4:	82 0f       	add	r24, r18
    41f6:	91 1d       	adc	r25, r1
    41f8:	a1 1d       	adc	r26, r1
    41fa:	b1 1d       	adc	r27, r1
    41fc:	bc 01       	movw	r22, r24
    41fe:	cd 01       	movw	r24, r26
    4200:	42 e0       	ldi	r20, 0x02	; 2
    4202:	66 0f       	add	r22, r22
    4204:	77 1f       	adc	r23, r23
    4206:	88 1f       	adc	r24, r24
    4208:	99 1f       	adc	r25, r25
    420a:	4a 95       	dec	r20
    420c:	d1 f7       	brne	.-12     	; 0x4202 <micros+0x3c>
}
    420e:	08 95       	ret

00004210 <delay>:

void delay(unsigned long ms)
{
    4210:	8f 92       	push	r8
    4212:	9f 92       	push	r9
    4214:	af 92       	push	r10
    4216:	bf 92       	push	r11
    4218:	cf 92       	push	r12
    421a:	df 92       	push	r13
    421c:	ef 92       	push	r14
    421e:	ff 92       	push	r15
    4220:	6b 01       	movw	r12, r22
    4222:	7c 01       	movw	r14, r24
	uint32_t start = micros();
    4224:	0e 94 e3 20 	call	0x41c6	; 0x41c6 <micros>
    4228:	4b 01       	movw	r8, r22
    422a:	5c 01       	movw	r10, r24

	while (ms > 0) {
    422c:	c1 14       	cp	r12, r1
    422e:	d1 04       	cpc	r13, r1
    4230:	e1 04       	cpc	r14, r1
    4232:	f1 04       	cpc	r15, r1
    4234:	01 f1       	breq	.+64     	; 0x4276 <delay+0x66>
		yield();
    4236:	0e 94 b0 23 	call	0x4760	; 0x4760 <yield>
		while ( ms > 0 && (micros() - start) >= 1000) {
    423a:	0e 94 e3 20 	call	0x41c6	; 0x41c6 <micros>
    423e:	dc 01       	movw	r26, r24
    4240:	cb 01       	movw	r24, r22
    4242:	88 19       	sub	r24, r8
    4244:	99 09       	sbc	r25, r9
    4246:	aa 09       	sbc	r26, r10
    4248:	bb 09       	sbc	r27, r11
    424a:	88 3e       	cpi	r24, 0xE8	; 232
    424c:	93 40       	sbci	r25, 0x03	; 3
    424e:	a1 05       	cpc	r26, r1
    4250:	b1 05       	cpc	r27, r1
    4252:	60 f3       	brcs	.-40     	; 0x422c <delay+0x1c>
			ms--;
    4254:	21 e0       	ldi	r18, 0x01	; 1
    4256:	c2 1a       	sub	r12, r18
    4258:	d1 08       	sbc	r13, r1
    425a:	e1 08       	sbc	r14, r1
    425c:	f1 08       	sbc	r15, r1
			start += 1000;
    425e:	88 ee       	ldi	r24, 0xE8	; 232
    4260:	88 0e       	add	r8, r24
    4262:	83 e0       	ldi	r24, 0x03	; 3
    4264:	98 1e       	adc	r9, r24
    4266:	a1 1c       	adc	r10, r1
    4268:	b1 1c       	adc	r11, r1
{
	uint32_t start = micros();

	while (ms > 0) {
		yield();
		while ( ms > 0 && (micros() - start) >= 1000) {
    426a:	c1 14       	cp	r12, r1
    426c:	d1 04       	cpc	r13, r1
    426e:	e1 04       	cpc	r14, r1
    4270:	f1 04       	cpc	r15, r1
    4272:	19 f7       	brne	.-58     	; 0x423a <delay+0x2a>
    4274:	db cf       	rjmp	.-74     	; 0x422c <delay+0x1c>
			ms--;
			start += 1000;
		}
	}
}
    4276:	ff 90       	pop	r15
    4278:	ef 90       	pop	r14
    427a:	df 90       	pop	r13
    427c:	cf 90       	pop	r12
    427e:	bf 90       	pop	r11
    4280:	af 90       	pop	r10
    4282:	9f 90       	pop	r9
    4284:	8f 90       	pop	r8
    4286:	08 95       	ret

00004288 <delayMicroseconds>:
#elif F_CPU >= 16000000L
	// for the 16 MHz clock on most Arduino boards

	// for a one-microsecond delay, simply return.  the overhead
	// of the function call takes 14 (16) cycles, which is 1us
	if (us <= 1) return; //  = 3 cycles, (4 when true)
    4288:	82 30       	cpi	r24, 0x02	; 2
    428a:	91 05       	cpc	r25, r1
    428c:	38 f0       	brcs	.+14     	; 0x429c <delayMicroseconds+0x14>

	// the following loop takes 1/4 of a microsecond (4 cycles)
	// per iteration, so execute it four times for each microsecond of
	// delay requested.
	us <<= 2; // x4 us, = 4 cycles
    428e:	88 0f       	add	r24, r24
    4290:	99 1f       	adc	r25, r25
    4292:	88 0f       	add	r24, r24
    4294:	99 1f       	adc	r25, r25

	// account for the time taken in the preceeding commands.
	// we just burned 19 (21) cycles above, remove 5, (5*4=20)
	// us is at least 8 so we can substract 5
	us -= 5; // = 2 cycles,
    4296:	05 97       	sbiw	r24, 0x05	; 5
	

#endif

	// busy wait
	__asm__ __volatile__ (
    4298:	01 97       	sbiw	r24, 0x01	; 1
    429a:	f1 f7       	brne	.-4      	; 0x4298 <delayMicroseconds+0x10>
    429c:	08 95       	ret

0000429e <init>:

void init()
{
	// this needs to be called before setup() or some functions won't
	// work there
	sei();
    429e:	78 94       	sei
	
	// on the ATmega168, timer 0 is also used for fast hardware pwm
	// (using phase-correct PWM would mean that timer 0 overflowed half as often
	// resulting in different millis() behavior on the ATmega8 and ATmega168)
#if defined(TCCR0A) && defined(WGM01)
	sbi(TCCR0A, WGM01);
    42a0:	84 b5       	in	r24, 0x24	; 36
    42a2:	82 60       	ori	r24, 0x02	; 2
    42a4:	84 bd       	out	0x24, r24	; 36
	sbi(TCCR0A, WGM00);
    42a6:	84 b5       	in	r24, 0x24	; 36
    42a8:	81 60       	ori	r24, 0x01	; 1
    42aa:	84 bd       	out	0x24, r24	; 36
	// this combination is for the standard atmega8
	sbi(TCCR0, CS01);
	sbi(TCCR0, CS00);
#elif defined(TCCR0B) && defined(CS01) && defined(CS00)
	// this combination is for the standard 168/328/1280/2560
	sbi(TCCR0B, CS01);
    42ac:	85 b5       	in	r24, 0x25	; 37
    42ae:	82 60       	ori	r24, 0x02	; 2
    42b0:	85 bd       	out	0x25, r24	; 37
	sbi(TCCR0B, CS00);
    42b2:	85 b5       	in	r24, 0x25	; 37
    42b4:	81 60       	ori	r24, 0x01	; 1
    42b6:	85 bd       	out	0x25, r24	; 37

	// enable timer 0 overflow interrupt
#if defined(TIMSK) && defined(TOIE0)
	sbi(TIMSK, TOIE0);
#elif defined(TIMSK0) && defined(TOIE0)
	sbi(TIMSK0, TOIE0);
    42b8:	ee e6       	ldi	r30, 0x6E	; 110
    42ba:	f0 e0       	ldi	r31, 0x00	; 0
    42bc:	80 81       	ld	r24, Z
    42be:	81 60       	ori	r24, 0x01	; 1
    42c0:	80 83       	st	Z, r24
	// this is better for motors as it ensures an even waveform
	// note, however, that fast pwm mode can achieve a frequency of up
	// 8 MHz (with a 16 MHz clock) at 50% duty cycle

#if defined(TCCR1B) && defined(CS11) && defined(CS10)
	TCCR1B = 0;
    42c2:	e1 e8       	ldi	r30, 0x81	; 129
    42c4:	f0 e0       	ldi	r31, 0x00	; 0
    42c6:	10 82       	st	Z, r1

	// set timer 1 prescale factor to 64
	sbi(TCCR1B, CS11);
    42c8:	80 81       	ld	r24, Z
    42ca:	82 60       	ori	r24, 0x02	; 2
    42cc:	80 83       	st	Z, r24
#if F_CPU >= 8000000L
	sbi(TCCR1B, CS10);
    42ce:	80 81       	ld	r24, Z
    42d0:	81 60       	ori	r24, 0x01	; 1
    42d2:	80 83       	st	Z, r24
	sbi(TCCR1, CS10);
#endif
#endif
	// put timer 1 in 8-bit phase correct pwm mode
#if defined(TCCR1A) && defined(WGM10)
	sbi(TCCR1A, WGM10);
    42d4:	e0 e8       	ldi	r30, 0x80	; 128
    42d6:	f0 e0       	ldi	r31, 0x00	; 0
    42d8:	80 81       	ld	r24, Z
    42da:	81 60       	ori	r24, 0x01	; 1
    42dc:	80 83       	st	Z, r24

	// set timer 2 prescale factor to 64
#if defined(TCCR2) && defined(CS22)
	sbi(TCCR2, CS22);
#elif defined(TCCR2B) && defined(CS22)
	sbi(TCCR2B, CS22);
    42de:	e1 eb       	ldi	r30, 0xB1	; 177
    42e0:	f0 e0       	ldi	r31, 0x00	; 0
    42e2:	80 81       	ld	r24, Z
    42e4:	84 60       	ori	r24, 0x04	; 4
    42e6:	80 83       	st	Z, r24

	// configure timer 2 for phase correct pwm (8-bit)
#if defined(TCCR2) && defined(WGM20)
	sbi(TCCR2, WGM20);
#elif defined(TCCR2A) && defined(WGM20)
	sbi(TCCR2A, WGM20);
    42e8:	e0 eb       	ldi	r30, 0xB0	; 176
    42ea:	f0 e0       	ldi	r31, 0x00	; 0
    42ec:	80 81       	ld	r24, Z
    42ee:	81 60       	ori	r24, 0x01	; 1
    42f0:	80 83       	st	Z, r24
#endif

#if defined(ADCSRA)
	// set a2d prescaler so we are inside the desired 50-200 KHz range.
	#if F_CPU >= 16000000 // 16 MHz / 128 = 125 KHz
		sbi(ADCSRA, ADPS2);
    42f2:	ea e7       	ldi	r30, 0x7A	; 122
    42f4:	f0 e0       	ldi	r31, 0x00	; 0
    42f6:	80 81       	ld	r24, Z
    42f8:	84 60       	ori	r24, 0x04	; 4
    42fa:	80 83       	st	Z, r24
		sbi(ADCSRA, ADPS1);
    42fc:	80 81       	ld	r24, Z
    42fe:	82 60       	ori	r24, 0x02	; 2
    4300:	80 83       	st	Z, r24
		sbi(ADCSRA, ADPS0);
    4302:	80 81       	ld	r24, Z
    4304:	81 60       	ori	r24, 0x01	; 1
    4306:	80 83       	st	Z, r24
		cbi(ADCSRA, ADPS2);
		cbi(ADCSRA, ADPS1);
		sbi(ADCSRA, ADPS0);
	#endif
	// enable a2d conversions
	sbi(ADCSRA, ADEN);
    4308:	80 81       	ld	r24, Z
    430a:	80 68       	ori	r24, 0x80	; 128
    430c:	80 83       	st	Z, r24
	// here so they can be used as normal digital i/o; they will be
	// reconnected in Serial.begin()
#if defined(UCSRB)
	UCSRB = 0;
#elif defined(UCSR0B)
	UCSR0B = 0;
    430e:	10 92 c1 00 	sts	0x00C1, r1	; 0x8000c1 <__DATA_REGION_ORIGIN__+0x61>
    4312:	08 95       	ret

00004314 <analogRead>:
#elif defined(__AVR_ATmega32U4__)
	if (pin >= 18) pin -= 18; // allow for channel or pin numbers
#elif defined(__AVR_ATmega1284__) || defined(__AVR_ATmega1284P__) || defined(__AVR_ATmega644__) || defined(__AVR_ATmega644A__) || defined(__AVR_ATmega644P__) || defined(__AVR_ATmega644PA__)
	if (pin >= 24) pin -= 24; // allow for channel or pin numbers
#else
	if (pin >= 14) pin -= 14; // allow for channel or pin numbers
    4314:	8e 30       	cpi	r24, 0x0E	; 14
    4316:	08 f0       	brcs	.+2      	; 0x431a <analogRead+0x6>
    4318:	8e 50       	subi	r24, 0x0E	; 14
	// to 0 (the default).
#if defined(ADMUX)
#if defined(__AVR_ATtiny25__) || defined(__AVR_ATtiny45__) || defined(__AVR_ATtiny85__)
	ADMUX = (analog_reference << 4) | (pin & 0x07);
#else
	ADMUX = (analog_reference << 6) | (pin & 0x07);
    431a:	20 91 41 01 	lds	r18, 0x0141	; 0x800141 <analog_reference>
    431e:	90 e4       	ldi	r25, 0x40	; 64
    4320:	29 9f       	mul	r18, r25
    4322:	90 01       	movw	r18, r0
    4324:	11 24       	eor	r1, r1
    4326:	87 70       	andi	r24, 0x07	; 7
    4328:	82 2b       	or	r24, r18
    432a:	80 93 7c 00 	sts	0x007C, r24	; 0x80007c <__DATA_REGION_ORIGIN__+0x1c>
	// without a delay, we seem to read from the wrong channel
	//delay(1);

#if defined(ADCSRA) && defined(ADCL)
	// start the conversion
	sbi(ADCSRA, ADSC);
    432e:	80 91 7a 00 	lds	r24, 0x007A	; 0x80007a <__DATA_REGION_ORIGIN__+0x1a>
    4332:	80 64       	ori	r24, 0x40	; 64
    4334:	80 93 7a 00 	sts	0x007A, r24	; 0x80007a <__DATA_REGION_ORIGIN__+0x1a>

	// ADSC is cleared when the conversion finishes
	while (bit_is_set(ADCSRA, ADSC));
    4338:	80 91 7a 00 	lds	r24, 0x007A	; 0x80007a <__DATA_REGION_ORIGIN__+0x1a>
    433c:	86 fd       	sbrc	r24, 6
    433e:	fc cf       	rjmp	.-8      	; 0x4338 <analogRead+0x24>

	// we have to read ADCL first; doing so locks both ADCL
	// and ADCH until ADCH is read.  reading ADCL second would
	// cause the results of each conversion to be discarded,
	// as ADCL and ADCH would be locked when it completed.
	low  = ADCL;
    4340:	80 91 78 00 	lds	r24, 0x0078	; 0x800078 <__DATA_REGION_ORIGIN__+0x18>
	high = ADCH;
    4344:	20 91 79 00 	lds	r18, 0x0079	; 0x800079 <__DATA_REGION_ORIGIN__+0x19>
	low  = 0;
	high = 0;
#endif

	// combine the two bytes
	return (high << 8) | low;
    4348:	90 e0       	ldi	r25, 0x00	; 0
}
    434a:	92 2b       	or	r25, r18
    434c:	08 95       	ret

0000434e <analogWrite>:
// Right now, PWM output only works on the pins with
// hardware support.  These are defined in the appropriate
// pins_*.c file.  For the rest of the pins, we default
// to digital output.
void analogWrite(uint8_t pin, int val)
{
    434e:	1f 93       	push	r17
    4350:	cf 93       	push	r28
    4352:	df 93       	push	r29
    4354:	18 2f       	mov	r17, r24
    4356:	eb 01       	movw	r28, r22
	// We need to make sure the PWM output is enabled for those pins
	// that support it, as we turn it off when digitally reading or
	// writing with them.  Also, make sure the pin is in output mode
	// for consistenty with Wiring, which doesn't require a pinMode
	// call for the analog output pins.
	pinMode(pin, OUTPUT);
    4358:	61 e0       	ldi	r22, 0x01	; 1
    435a:	0e 94 2f 22 	call	0x445e	; 0x445e <pinMode>
	if (val == 0)
    435e:	20 97       	sbiw	r28, 0x00	; 0
    4360:	11 f4       	brne	.+4      	; 0x4366 <analogWrite+0x18>
	{
		digitalWrite(pin, LOW);
    4362:	60 e0       	ldi	r22, 0x00	; 0
    4364:	04 c0       	rjmp	.+8      	; 0x436e <analogWrite+0x20>
	}
	else if (val == 255)
    4366:	cf 3f       	cpi	r28, 0xFF	; 255
    4368:	d1 05       	cpc	r29, r1
    436a:	39 f4       	brne	.+14     	; 0x437a <analogWrite+0x2c>
	{
		digitalWrite(pin, HIGH);
    436c:	61 e0       	ldi	r22, 0x01	; 1
    436e:	81 2f       	mov	r24, r17
				} else {
					digitalWrite(pin, HIGH);
				}
		}
	}
}
    4370:	df 91       	pop	r29
    4372:	cf 91       	pop	r28
    4374:	1f 91       	pop	r17
	{
		digitalWrite(pin, LOW);
	}
	else if (val == 255)
	{
		digitalWrite(pin, HIGH);
    4376:	0c 94 6b 22 	jmp	0x44d6	; 0x44d6 <digitalWrite>
	}
	else
	{
		switch(digitalPinToTimer(pin))
    437a:	e1 2f       	mov	r30, r17
    437c:	f0 e0       	ldi	r31, 0x00	; 0
    437e:	ee 54       	subi	r30, 0x4E	; 78
    4380:	ff 4f       	sbci	r31, 0xFF	; 255
    4382:	e4 91       	lpm	r30, Z
    4384:	e3 30       	cpi	r30, 0x03	; 3
    4386:	f9 f0       	breq	.+62     	; 0x43c6 <analogWrite+0x78>
    4388:	48 f4       	brcc	.+18     	; 0x439c <analogWrite+0x4e>
    438a:	e1 30       	cpi	r30, 0x01	; 1
    438c:	b9 f0       	breq	.+46     	; 0x43bc <analogWrite+0x6e>
    438e:	e2 30       	cpi	r30, 0x02	; 2
    4390:	a1 f5       	brne	.+104    	; 0x43fa <analogWrite+0xac>
			#endif

			#if defined(TCCR0A) && defined(COM0B1)
			case TIMER0B:
				// connect pwm to pin on timer 0, channel B
				sbi(TCCR0A, COM0B1);
    4392:	84 b5       	in	r24, 0x24	; 36
    4394:	80 62       	ori	r24, 0x20	; 32
    4396:	84 bd       	out	0x24, r24	; 36
				OCR0B = val; // set pwm duty
    4398:	c8 bd       	out	0x28, r28	; 40
				break;
    439a:	34 c0       	rjmp	.+104    	; 0x4404 <analogWrite+0xb6>
	{
		digitalWrite(pin, HIGH);
	}
	else
	{
		switch(digitalPinToTimer(pin))
    439c:	e7 30       	cpi	r30, 0x07	; 7
    439e:	e9 f0       	breq	.+58     	; 0x43da <analogWrite+0x8c>
    43a0:	e8 30       	cpi	r30, 0x08	; 8
    43a2:	19 f1       	breq	.+70     	; 0x43ea <analogWrite+0x9c>
    43a4:	e4 30       	cpi	r30, 0x04	; 4
    43a6:	49 f5       	brne	.+82     	; 0x43fa <analogWrite+0xac>
			#endif

			#if defined(TCCR1A) && defined(COM1B1)
			case TIMER1B:
				// connect pwm to pin on timer 1, channel B
				sbi(TCCR1A, COM1B1);
    43a8:	80 91 80 00 	lds	r24, 0x0080	; 0x800080 <__DATA_REGION_ORIGIN__+0x20>
    43ac:	80 62       	ori	r24, 0x20	; 32
    43ae:	80 93 80 00 	sts	0x0080, r24	; 0x800080 <__DATA_REGION_ORIGIN__+0x20>
				OCR1B = val; // set pwm duty
    43b2:	d0 93 8b 00 	sts	0x008B, r29	; 0x80008b <__DATA_REGION_ORIGIN__+0x2b>
    43b6:	c0 93 8a 00 	sts	0x008A, r28	; 0x80008a <__DATA_REGION_ORIGIN__+0x2a>
				break;
    43ba:	24 c0       	rjmp	.+72     	; 0x4404 <analogWrite+0xb6>
			#endif

			#if defined(TCCR0A) && defined(COM0A1)
			case TIMER0A:
				// connect pwm to pin on timer 0, channel A
				sbi(TCCR0A, COM0A1);
    43bc:	84 b5       	in	r24, 0x24	; 36
    43be:	80 68       	ori	r24, 0x80	; 128
    43c0:	84 bd       	out	0x24, r24	; 36
				OCR0A = val; // set pwm duty
    43c2:	c7 bd       	out	0x27, r28	; 39
				break;
    43c4:	1f c0       	rjmp	.+62     	; 0x4404 <analogWrite+0xb6>
			#endif

			#if defined(TCCR1A) && defined(COM1A1)
			case TIMER1A:
				// connect pwm to pin on timer 1, channel A
				sbi(TCCR1A, COM1A1);
    43c6:	80 91 80 00 	lds	r24, 0x0080	; 0x800080 <__DATA_REGION_ORIGIN__+0x20>
    43ca:	80 68       	ori	r24, 0x80	; 128
    43cc:	80 93 80 00 	sts	0x0080, r24	; 0x800080 <__DATA_REGION_ORIGIN__+0x20>
				OCR1A = val; // set pwm duty
    43d0:	d0 93 89 00 	sts	0x0089, r29	; 0x800089 <__DATA_REGION_ORIGIN__+0x29>
    43d4:	c0 93 88 00 	sts	0x0088, r28	; 0x800088 <__DATA_REGION_ORIGIN__+0x28>
				break;
    43d8:	15 c0       	rjmp	.+42     	; 0x4404 <analogWrite+0xb6>
			#endif

			#if defined(TCCR2A) && defined(COM2A1)
			case TIMER2A:
				// connect pwm to pin on timer 2, channel A
				sbi(TCCR2A, COM2A1);
    43da:	80 91 b0 00 	lds	r24, 0x00B0	; 0x8000b0 <__DATA_REGION_ORIGIN__+0x50>
    43de:	80 68       	ori	r24, 0x80	; 128
    43e0:	80 93 b0 00 	sts	0x00B0, r24	; 0x8000b0 <__DATA_REGION_ORIGIN__+0x50>
				OCR2A = val; // set pwm duty
    43e4:	c0 93 b3 00 	sts	0x00B3, r28	; 0x8000b3 <__DATA_REGION_ORIGIN__+0x53>
				break;
    43e8:	0d c0       	rjmp	.+26     	; 0x4404 <analogWrite+0xb6>
			#endif

			#if defined(TCCR2A) && defined(COM2B1)
			case TIMER2B:
				// connect pwm to pin on timer 2, channel B
				sbi(TCCR2A, COM2B1);
    43ea:	80 91 b0 00 	lds	r24, 0x00B0	; 0x8000b0 <__DATA_REGION_ORIGIN__+0x50>
    43ee:	80 62       	ori	r24, 0x20	; 32
    43f0:	80 93 b0 00 	sts	0x00B0, r24	; 0x8000b0 <__DATA_REGION_ORIGIN__+0x50>
				OCR2B = val; // set pwm duty
    43f4:	c0 93 b4 00 	sts	0x00B4, r28	; 0x8000b4 <__DATA_REGION_ORIGIN__+0x54>
				break;
    43f8:	05 c0       	rjmp	.+10     	; 0x4404 <analogWrite+0xb6>
				break;
			#endif

			case NOT_ON_TIMER:
			default:
				if (val < 128) {
    43fa:	c0 38       	cpi	r28, 0x80	; 128
    43fc:	d1 05       	cpc	r29, r1
    43fe:	0c f0       	brlt	.+2      	; 0x4402 <analogWrite+0xb4>
    4400:	b5 cf       	rjmp	.-150    	; 0x436c <analogWrite+0x1e>
    4402:	af cf       	rjmp	.-162    	; 0x4362 <analogWrite+0x14>
				} else {
					digitalWrite(pin, HIGH);
				}
		}
	}
}
    4404:	df 91       	pop	r29
    4406:	cf 91       	pop	r28
    4408:	1f 91       	pop	r17
    440a:	08 95       	ret

0000440c <turnOffPWM>:
//
//static inline void turnOffPWM(uint8_t timer) __attribute__ ((always_inline));
//static inline void turnOffPWM(uint8_t timer)
static void turnOffPWM(uint8_t timer)
{
	switch (timer)
    440c:	83 30       	cpi	r24, 0x03	; 3
    440e:	81 f0       	breq	.+32     	; 0x4430 <turnOffPWM+0x24>
    4410:	28 f4       	brcc	.+10     	; 0x441c <turnOffPWM+0x10>
    4412:	81 30       	cpi	r24, 0x01	; 1
    4414:	99 f0       	breq	.+38     	; 0x443c <turnOffPWM+0x30>
    4416:	82 30       	cpi	r24, 0x02	; 2
    4418:	a1 f0       	breq	.+40     	; 0x4442 <turnOffPWM+0x36>
    441a:	08 95       	ret
    441c:	87 30       	cpi	r24, 0x07	; 7
    441e:	a9 f0       	breq	.+42     	; 0x444a <turnOffPWM+0x3e>
    4420:	88 30       	cpi	r24, 0x08	; 8
    4422:	b9 f0       	breq	.+46     	; 0x4452 <turnOffPWM+0x46>
    4424:	84 30       	cpi	r24, 0x04	; 4
    4426:	d1 f4       	brne	.+52     	; 0x445c <turnOffPWM+0x50>
	{
		#if defined(TCCR1A) && defined(COM1A1)
		case TIMER1A:   cbi(TCCR1A, COM1A1);    break;
		#endif
		#if defined(TCCR1A) && defined(COM1B1)
		case TIMER1B:   cbi(TCCR1A, COM1B1);    break;
    4428:	80 91 80 00 	lds	r24, 0x0080	; 0x800080 <__DATA_REGION_ORIGIN__+0x20>
    442c:	8f 7d       	andi	r24, 0xDF	; 223
    442e:	03 c0       	rjmp	.+6      	; 0x4436 <turnOffPWM+0x2a>
static void turnOffPWM(uint8_t timer)
{
	switch (timer)
	{
		#if defined(TCCR1A) && defined(COM1A1)
		case TIMER1A:   cbi(TCCR1A, COM1A1);    break;
    4430:	80 91 80 00 	lds	r24, 0x0080	; 0x800080 <__DATA_REGION_ORIGIN__+0x20>
    4434:	8f 77       	andi	r24, 0x7F	; 127
		#endif
		#if defined(TCCR1A) && defined(COM1B1)
		case TIMER1B:   cbi(TCCR1A, COM1B1);    break;
    4436:	80 93 80 00 	sts	0x0080, r24	; 0x800080 <__DATA_REGION_ORIGIN__+0x20>
    443a:	08 95       	ret
		#if defined(TCCR2) && defined(COM21)
		case  TIMER2:   cbi(TCCR2, COM21);      break;
		#endif
		
		#if defined(TCCR0A) && defined(COM0A1)
		case  TIMER0A:  cbi(TCCR0A, COM0A1);    break;
    443c:	84 b5       	in	r24, 0x24	; 36
    443e:	8f 77       	andi	r24, 0x7F	; 127
    4440:	02 c0       	rjmp	.+4      	; 0x4446 <turnOffPWM+0x3a>
		#endif
		
		#if defined(TCCR0A) && defined(COM0B1)
		case  TIMER0B:  cbi(TCCR0A, COM0B1);    break;
    4442:	84 b5       	in	r24, 0x24	; 36
    4444:	8f 7d       	andi	r24, 0xDF	; 223
    4446:	84 bd       	out	0x24, r24	; 36
    4448:	08 95       	ret
		#endif
		#if defined(TCCR2A) && defined(COM2A1)
		case  TIMER2A:  cbi(TCCR2A, COM2A1);    break;
    444a:	80 91 b0 00 	lds	r24, 0x00B0	; 0x8000b0 <__DATA_REGION_ORIGIN__+0x50>
    444e:	8f 77       	andi	r24, 0x7F	; 127
    4450:	03 c0       	rjmp	.+6      	; 0x4458 <turnOffPWM+0x4c>
		#endif
		#if defined(TCCR2A) && defined(COM2B1)
		case  TIMER2B:  cbi(TCCR2A, COM2B1);    break;
    4452:	80 91 b0 00 	lds	r24, 0x00B0	; 0x8000b0 <__DATA_REGION_ORIGIN__+0x50>
    4456:	8f 7d       	andi	r24, 0xDF	; 223
    4458:	80 93 b0 00 	sts	0x00B0, r24	; 0x8000b0 <__DATA_REGION_ORIGIN__+0x50>
    445c:	08 95       	ret

0000445e <pinMode>:
#define ARDUINO_MAIN
#include "wiring_private.h"
#include "pins_arduino.h"

void pinMode(uint8_t pin, uint8_t mode)
{
    445e:	cf 93       	push	r28
    4460:	df 93       	push	r29
	uint8_t bit = digitalPinToBitMask(pin);
    4462:	90 e0       	ldi	r25, 0x00	; 0
    4464:	fc 01       	movw	r30, r24
    4466:	ea 53       	subi	r30, 0x3A	; 58
    4468:	ff 4f       	sbci	r31, 0xFF	; 255
    446a:	24 91       	lpm	r18, Z
	uint8_t port = digitalPinToPort(pin);
    446c:	fc 01       	movw	r30, r24
    446e:	e6 52       	subi	r30, 0x26	; 38
    4470:	ff 4f       	sbci	r31, 0xFF	; 255
    4472:	84 91       	lpm	r24, Z
	volatile uint8_t *reg, *out;

	if (port == NOT_A_PIN) return;
    4474:	88 23       	and	r24, r24
    4476:	61 f1       	breq	.+88     	; 0x44d0 <pinMode+0x72>

	// JWS: can I let the optimizer do this?
	reg = portModeRegister(port);
    4478:	90 e0       	ldi	r25, 0x00	; 0
    447a:	88 0f       	add	r24, r24
    447c:	99 1f       	adc	r25, r25
    447e:	fc 01       	movw	r30, r24
    4480:	ee 5f       	subi	r30, 0xFE	; 254
    4482:	fe 4f       	sbci	r31, 0xFE	; 254
    4484:	c5 91       	lpm	r28, Z+
    4486:	d4 91       	lpm	r29, Z
	out = portOutputRegister(port);
    4488:	fc 01       	movw	r30, r24
    448a:	e8 50       	subi	r30, 0x08	; 8
    448c:	ff 4f       	sbci	r31, 0xFF	; 255
    448e:	a5 91       	lpm	r26, Z+
    4490:	b4 91       	lpm	r27, Z

	if (mode == INPUT) { 
    4492:	61 11       	cpse	r22, r1
    4494:	09 c0       	rjmp	.+18     	; 0x44a8 <pinMode+0x4a>
		uint8_t oldSREG = SREG;
    4496:	9f b7       	in	r25, 0x3f	; 63
                cli();
    4498:	f8 94       	cli
		*reg &= ~bit;
    449a:	88 81       	ld	r24, Y
    449c:	20 95       	com	r18
    449e:	82 23       	and	r24, r18
    44a0:	88 83       	st	Y, r24
		*out &= ~bit;
    44a2:	ec 91       	ld	r30, X
    44a4:	2e 23       	and	r18, r30
    44a6:	0b c0       	rjmp	.+22     	; 0x44be <pinMode+0x60>
		SREG = oldSREG;
	} else if (mode == INPUT_PULLUP) {
    44a8:	62 30       	cpi	r22, 0x02	; 2
    44aa:	61 f4       	brne	.+24     	; 0x44c4 <pinMode+0x66>
		uint8_t oldSREG = SREG;
    44ac:	9f b7       	in	r25, 0x3f	; 63
                cli();
    44ae:	f8 94       	cli
		*reg &= ~bit;
    44b0:	88 81       	ld	r24, Y
    44b2:	32 2f       	mov	r19, r18
    44b4:	30 95       	com	r19
    44b6:	83 23       	and	r24, r19
    44b8:	88 83       	st	Y, r24
		*out |= bit;
    44ba:	ec 91       	ld	r30, X
    44bc:	2e 2b       	or	r18, r30
    44be:	2c 93       	st	X, r18
		SREG = oldSREG;
    44c0:	9f bf       	out	0x3f, r25	; 63
    44c2:	06 c0       	rjmp	.+12     	; 0x44d0 <pinMode+0x72>
	} else {
		uint8_t oldSREG = SREG;
    44c4:	8f b7       	in	r24, 0x3f	; 63
                cli();
    44c6:	f8 94       	cli
		*reg |= bit;
    44c8:	e8 81       	ld	r30, Y
    44ca:	2e 2b       	or	r18, r30
    44cc:	28 83       	st	Y, r18
		SREG = oldSREG;
    44ce:	8f bf       	out	0x3f, r24	; 63
	}
}
    44d0:	df 91       	pop	r29
    44d2:	cf 91       	pop	r28
    44d4:	08 95       	ret

000044d6 <digitalWrite>:
		#endif
	}
}

void digitalWrite(uint8_t pin, uint8_t val)
{
    44d6:	1f 93       	push	r17
    44d8:	cf 93       	push	r28
    44da:	df 93       	push	r29
	uint8_t timer = digitalPinToTimer(pin);
    44dc:	28 2f       	mov	r18, r24
    44de:	30 e0       	ldi	r19, 0x00	; 0
    44e0:	f9 01       	movw	r30, r18
    44e2:	ee 54       	subi	r30, 0x4E	; 78
    44e4:	ff 4f       	sbci	r31, 0xFF	; 255
    44e6:	84 91       	lpm	r24, Z
	uint8_t bit = digitalPinToBitMask(pin);
    44e8:	f9 01       	movw	r30, r18
    44ea:	ea 53       	subi	r30, 0x3A	; 58
    44ec:	ff 4f       	sbci	r31, 0xFF	; 255
    44ee:	d4 91       	lpm	r29, Z
	uint8_t port = digitalPinToPort(pin);
    44f0:	f9 01       	movw	r30, r18
    44f2:	e6 52       	subi	r30, 0x26	; 38
    44f4:	ff 4f       	sbci	r31, 0xFF	; 255
    44f6:	c4 91       	lpm	r28, Z
	volatile uint8_t *out;

	if (port == NOT_A_PIN) return;
    44f8:	cc 23       	and	r28, r28
    44fa:	c1 f0       	breq	.+48     	; 0x452c <digitalWrite+0x56>
    44fc:	16 2f       	mov	r17, r22

	// If the pin that support PWM output, we need to turn it off
	// before doing a digital write.
	if (timer != NOT_ON_TIMER) turnOffPWM(timer);
    44fe:	81 11       	cpse	r24, r1
    4500:	0e 94 06 22 	call	0x440c	; 0x440c <turnOffPWM>

	out = portOutputRegister(port);
    4504:	ec 2f       	mov	r30, r28
    4506:	f0 e0       	ldi	r31, 0x00	; 0
    4508:	ee 0f       	add	r30, r30
    450a:	ff 1f       	adc	r31, r31
    450c:	e8 50       	subi	r30, 0x08	; 8
    450e:	ff 4f       	sbci	r31, 0xFF	; 255
    4510:	a5 91       	lpm	r26, Z+
    4512:	b4 91       	lpm	r27, Z

	uint8_t oldSREG = SREG;
    4514:	9f b7       	in	r25, 0x3f	; 63
	cli();
    4516:	f8 94       	cli

	if (val == LOW) {
    4518:	11 11       	cpse	r17, r1
    451a:	04 c0       	rjmp	.+8      	; 0x4524 <digitalWrite+0x4e>
		*out &= ~bit;
    451c:	8c 91       	ld	r24, X
    451e:	d0 95       	com	r29
    4520:	d8 23       	and	r29, r24
    4522:	02 c0       	rjmp	.+4      	; 0x4528 <digitalWrite+0x52>
	} else {
		*out |= bit;
    4524:	ec 91       	ld	r30, X
    4526:	de 2b       	or	r29, r30
    4528:	dc 93       	st	X, r29
	}

	SREG = oldSREG;
    452a:	9f bf       	out	0x3f, r25	; 63
}
    452c:	df 91       	pop	r29
    452e:	cf 91       	pop	r28
    4530:	1f 91       	pop	r17
    4532:	08 95       	ret

00004534 <_ZN14FreqCountClass5beginEj>:
static uint16_t gate_index;


void FreqCountClass::begin(uint16_t msec)
{
	if (msec < 1) return;
    4534:	00 97       	sbiw	r24, 0x00	; 0
    4536:	09 f4       	brne	.+2      	; 0x453a <_ZN14FreqCountClass5beginEj+0x6>
    4538:	74 c0       	rjmp	.+232    	; 0x4622 <L_130_loop+0xc>
	gate_index = 0;
    453a:	10 92 ca 04 	sts	0x04CA, r1	; 0x8004ca <_ZL10gate_index+0x1>
    453e:	10 92 c9 04 	sts	0x04C9, r1	; 0x8004c9 <_ZL10gate_index>
	count_msw = 0;
    4542:	10 92 d7 04 	sts	0x04D7, r1	; 0x8004d7 <_ZL9count_msw+0x1>
    4546:	10 92 d6 04 	sts	0x04D6, r1	; 0x8004d6 <_ZL9count_msw>
	count_prev = 0;
    454a:	10 92 d2 04 	sts	0x04D2, r1	; 0x8004d2 <_ZL10count_prev>
    454e:	10 92 d3 04 	sts	0x04D3, r1	; 0x8004d3 <_ZL10count_prev+0x1>
    4552:	10 92 d4 04 	sts	0x04D4, r1	; 0x8004d4 <_ZL10count_prev+0x2>
    4556:	10 92 d5 04 	sts	0x04D5, r1	; 0x8004d5 <_ZL10count_prev+0x3>
	count_ready = 0;
    455a:	10 92 cd 04 	sts	0x04CD, r1	; 0x8004cd <_ZL11count_ready>

static uint8_t saveTCCR1A, saveTCCR1B;

static inline void counter_init(void)
{
	saveTCCR1A = TCCR1A;
    455e:	20 91 80 00 	lds	r18, 0x0080	; 0x800080 <__DATA_REGION_ORIGIN__+0x20>
    4562:	20 93 dc 04 	sts	0x04DC, r18	; 0x8004dc <_ZL10saveTCCR1A>
	saveTCCR1B = TCCR1B;
    4566:	20 91 81 00 	lds	r18, 0x0081	; 0x800081 <__DATA_REGION_ORIGIN__+0x21>
    456a:	20 93 db 04 	sts	0x04DB, r18	; 0x8004db <_ZL10saveTCCR1B>
	TCCR1B = 0;
    456e:	10 92 81 00 	sts	0x0081, r1	; 0x800081 <__DATA_REGION_ORIGIN__+0x21>
	TCCR1A = 0;
    4572:	10 92 80 00 	sts	0x0080, r1	; 0x800080 <__DATA_REGION_ORIGIN__+0x20>
	TCNT1 = 0;
    4576:	10 92 85 00 	sts	0x0085, r1	; 0x800085 <__DATA_REGION_ORIGIN__+0x25>
    457a:	10 92 84 00 	sts	0x0084, r1	; 0x800084 <__DATA_REGION_ORIGIN__+0x24>
	TIFR1 = (1<<TOV1);
    457e:	21 e0       	ldi	r18, 0x01	; 1
    4580:	26 bb       	out	0x16, r18	; 22
	TIMSK1 = 0;
    4582:	10 92 6f 00 	sts	0x006F, r1	; 0x80006f <__DATA_REGION_ORIGIN__+0xf>

static inline uint16_t timer_init(uint16_t msec)
{
	uint16_t gate_len;

	saveTCCR2A = TCCR2A;
    4586:	20 91 b0 00 	lds	r18, 0x00B0	; 0x8000b0 <__DATA_REGION_ORIGIN__+0x50>
    458a:	20 93 da 04 	sts	0x04DA, r18	; 0x8004da <_ZL10saveTCCR2A>
	saveTCCR2B = TCCR2B;
    458e:	20 91 b1 00 	lds	r18, 0x00B1	; 0x8000b1 <__DATA_REGION_ORIGIN__+0x51>
    4592:	20 93 d9 04 	sts	0x04D9, r18	; 0x8004d9 <_ZL10saveTCCR2B>
	TCCR2B = 0;
    4596:	10 92 b1 00 	sts	0x00B1, r1	; 0x8000b1 <__DATA_REGION_ORIGIN__+0x51>
	TCCR2A = (1<<WGM21);
    459a:	22 e0       	ldi	r18, 0x02	; 2
    459c:	20 93 b0 00 	sts	0x00B0, r18	; 0x8000b0 <__DATA_REGION_ORIGIN__+0x50>
	if ((msec & 7) == 0) {
    45a0:	9c 01       	movw	r18, r24
    45a2:	27 70       	andi	r18, 0x07	; 7
    45a4:	33 27       	eor	r19, r19
    45a6:	23 2b       	or	r18, r19
    45a8:	51 f4       	brne	.+20     	; 0x45be <_ZN14FreqCountClass5beginEj+0x8a>
		gate_len = msec >> 3;
    45aa:	43 e0       	ldi	r20, 0x03	; 3
    45ac:	96 95       	lsr	r25
    45ae:	87 95       	ror	r24
    45b0:	4a 95       	dec	r20
    45b2:	e1 f7       	brne	.-8      	; 0x45ac <_ZN14FreqCountClass5beginEj+0x78>
		OCR2A = TIMER2_OCR2A_8MS_VAL;
    45b4:	2c e7       	ldi	r18, 0x7C	; 124
    45b6:	20 93 b3 00 	sts	0x00B3, r18	; 0x8000b3 <__DATA_REGION_ORIGIN__+0x53>
		startTCCR2B = TIMER2_TCCR2B_8MS_VAL;
    45ba:	27 e0       	ldi	r18, 0x07	; 7
    45bc:	18 c0       	rjmp	.+48     	; 0x45ee <_ZN14FreqCountClass5beginEj+0xba>
	} else if ((msec & 3) == 0) {
    45be:	9c 01       	movw	r18, r24
    45c0:	23 70       	andi	r18, 0x03	; 3
    45c2:	33 27       	eor	r19, r19
    45c4:	23 2b       	or	r18, r19
    45c6:	31 f4       	brne	.+12     	; 0x45d4 <_ZN14FreqCountClass5beginEj+0xa0>
		gate_len = msec >> 2;
    45c8:	96 95       	lsr	r25
    45ca:	87 95       	ror	r24
    45cc:	96 95       	lsr	r25
    45ce:	87 95       	ror	r24
		OCR2A = TIMER2_OCR2A_4MS_VAL;
    45d0:	29 ef       	ldi	r18, 0xF9	; 249
    45d2:	05 c0       	rjmp	.+10     	; 0x45de <_ZN14FreqCountClass5beginEj+0xaa>
		startTCCR2B = TIMER2_TCCR2B_4MS_VAL;
	} else if ((msec & 1) == 0) {
    45d4:	80 fd       	sbrc	r24, 0
    45d6:	07 c0       	rjmp	.+14     	; 0x45e6 <_ZN14FreqCountClass5beginEj+0xb2>
		gate_len = msec >> 1;
    45d8:	96 95       	lsr	r25
    45da:	87 95       	ror	r24
		OCR2A = TIMER2_OCR2A_2MS_VAL;
    45dc:	2c e7       	ldi	r18, 0x7C	; 124
    45de:	20 93 b3 00 	sts	0x00B3, r18	; 0x8000b3 <__DATA_REGION_ORIGIN__+0x53>
		startTCCR2B = TIMER2_TCCR2B_2MS_VAL;
    45e2:	26 e0       	ldi	r18, 0x06	; 6
    45e4:	04 c0       	rjmp	.+8      	; 0x45ee <_ZN14FreqCountClass5beginEj+0xba>
	} else {
		gate_len = msec;
		OCR2A = TIMER2_OCR2A_1MS_VAL;
    45e6:	2c e7       	ldi	r18, 0x7C	; 124
    45e8:	20 93 b3 00 	sts	0x00B3, r18	; 0x8000b3 <__DATA_REGION_ORIGIN__+0x53>
		startTCCR2B = TIMER2_TCCR2B_1MS_VAL;
    45ec:	25 e0       	ldi	r18, 0x05	; 5
    45ee:	20 93 d8 04 	sts	0x04D8, r18	; 0x8004d8 <_ZL11startTCCR2B>
	}
	TIFR2 = (1<<OCF2A);
    45f2:	22 e0       	ldi	r18, 0x02	; 2
    45f4:	27 bb       	out	0x17, r18	; 23
	TCNT2 = 0;
    45f6:	10 92 b2 00 	sts	0x00B2, r1	; 0x8000b2 <__DATA_REGION_ORIGIN__+0x52>
	counter_init();
	gate_length = timer_init(msec);
    45fa:	90 93 cc 04 	sts	0x04CC, r25	; 0x8004cc <_ZL11gate_length+0x1>
    45fe:	80 93 cb 04 	sts	0x04CB, r24	; 0x8004cb <_ZL11gate_length>
	uint8_t status = SREG;
    4602:	9f b7       	in	r25, 0x3f	; 63
	cli();
    4604:	f8 94       	cli
	return gate_len;
}

static inline void timer_start(void)
{
	GTCCR = (1<<PSRASY);
    4606:	23 bd       	out	0x23, r18	; 35
	TCCR2B = startTCCR2B;
    4608:	80 91 d8 04 	lds	r24, 0x04D8	; 0x8004d8 <_ZL11startTCCR2B>
    460c:	80 93 b1 00 	sts	0x00B1, r24	; 0x8000b1 <__DATA_REGION_ORIGIN__+0x51>
	TIMSK2 = (1<<OCIE2A);
    4610:	20 93 70 00 	sts	0x0070, r18	; 0x800070 <__DATA_REGION_ORIGIN__+0x10>
		"L_%=_loop:"
		"subi   %0, 1"		"\n\t"
		"brne   L_%=_loop"	"\n\t"
		: "+d" (cycles_times_3)
		: "0" (cycles_times_3)
	);
    4614:	8b e0       	ldi	r24, 0x0B	; 11

00004616 <L_130_loop>:
    4616:	81 50       	subi	r24, 0x01	; 1
    4618:	f1 f7       	brne	.-4      	; 0x4616 <L_130_loop>
	TIMSK1 = 0;
}

static inline void counter_start(void)
{
	TCCR1B = (1<<CS12) | (1<<CS11) | (1<<CS10);
    461a:	87 e0       	ldi	r24, 0x07	; 7
    461c:	80 93 81 00 	sts	0x0081, r24	; 0x800081 <__DATA_REGION_ORIGIN__+0x21>
	timer_start();
	timer_isr_latency_delay();
	counter_start();
	SREG = status;
    4620:	9f bf       	out	0x3f, r25	; 63
    4622:	08 95       	ret

00004624 <_ZN14FreqCountClass9availableEv>:
}

uint8_t FreqCountClass::available(void)
{
	return count_ready;
    4624:	80 91 cd 04 	lds	r24, 0x04CD	; 0x8004cd <_ZL11count_ready>
}
    4628:	08 95       	ret

0000462a <_ZN14FreqCountClass4readEv>:
uint32_t FreqCountClass::read(void)
{
	uint32_t count;
	uint8_t status;

	status = SREG;
    462a:	2f b7       	in	r18, 0x3f	; 63
	cli();
    462c:	f8 94       	cli
	count = count_output;
    462e:	60 91 ce 04 	lds	r22, 0x04CE	; 0x8004ce <_ZL12count_output>
    4632:	70 91 cf 04 	lds	r23, 0x04CF	; 0x8004cf <_ZL12count_output+0x1>
    4636:	80 91 d0 04 	lds	r24, 0x04D0	; 0x8004d0 <_ZL12count_output+0x2>
    463a:	90 91 d1 04 	lds	r25, 0x04D1	; 0x8004d1 <_ZL12count_output+0x3>
	count_ready = 0;
    463e:	10 92 cd 04 	sts	0x04CD, r1	; 0x8004cd <_ZL11count_ready>
	SREG = status;
    4642:	2f bf       	out	0x3f, r18	; 63
	return count;
}
    4644:	08 95       	ret

00004646 <_ZN14FreqCountClass3endEv>:
	TIMSK2 = (1<<OCIE2A);
}

static inline void timer_shutdown(void)
{
	TCCR2B = 0;
    4646:	e1 eb       	ldi	r30, 0xB1	; 177
    4648:	f0 e0       	ldi	r31, 0x00	; 0
    464a:	10 82       	st	Z, r1
	TIMSK2 = 0;
    464c:	10 92 70 00 	sts	0x0070, r1	; 0x800070 <__DATA_REGION_ORIGIN__+0x10>
	TCCR2A = saveTCCR2A;
    4650:	80 91 da 04 	lds	r24, 0x04DA	; 0x8004da <_ZL10saveTCCR2A>
    4654:	80 93 b0 00 	sts	0x00B0, r24	; 0x8000b0 <__DATA_REGION_ORIGIN__+0x50>
	TCCR2B = saveTCCR2B;
    4658:	80 91 d9 04 	lds	r24, 0x04D9	; 0x8004d9 <_ZL10saveTCCR2B>
    465c:	80 83       	st	Z, r24
	TCCR1B = (1<<CS12) | (1<<CS11) | (1<<CS10);
}

static inline void counter_shutdown(void)
{
	TCCR1B = 0;
    465e:	e1 e8       	ldi	r30, 0x81	; 129
    4660:	f0 e0       	ldi	r31, 0x00	; 0
    4662:	10 82       	st	Z, r1
	TCCR1A = saveTCCR1A;
    4664:	80 91 dc 04 	lds	r24, 0x04DC	; 0x8004dc <_ZL10saveTCCR1A>
    4668:	80 93 80 00 	sts	0x0080, r24	; 0x800080 <__DATA_REGION_ORIGIN__+0x20>
	TCCR1B = saveTCCR1B;
    466c:	80 91 db 04 	lds	r24, 0x04DB	; 0x8004db <_ZL10saveTCCR1B>
    4670:	80 83       	st	Z, r24
    4672:	08 95       	ret

00004674 <__vector_7>:
	counter_shutdown();
}


ISR(TIMER_ISR_VECTOR)
{
    4674:	1f 92       	push	r1
    4676:	0f 92       	push	r0
    4678:	0f b6       	in	r0, 0x3f	; 63
    467a:	0f 92       	push	r0
    467c:	11 24       	eor	r1, r1
    467e:	0f 93       	push	r16
    4680:	1f 93       	push	r17
    4682:	2f 93       	push	r18
    4684:	3f 93       	push	r19
    4686:	4f 93       	push	r20
    4688:	5f 93       	push	r21
    468a:	6f 93       	push	r22
    468c:	7f 93       	push	r23
    468e:	8f 93       	push	r24
    4690:	9f 93       	push	r25
    4692:	af 93       	push	r26
    4694:	bf 93       	push	r27
}

static inline uint16_t counter_read(void)
{
	return TCNT1;
    4696:	20 91 84 00 	lds	r18, 0x0084	; 0x800084 <__DATA_REGION_ORIGIN__+0x24>
    469a:	30 91 85 00 	lds	r19, 0x0085	; 0x800085 <__DATA_REGION_ORIGIN__+0x25>
	uint16_t count_lsw;
	uint32_t count;
	uint16_t index, length;

	count_lsw = counter_read();
	if (counter_overflow()) {
    469e:	b0 9b       	sbis	0x16, 0	; 22
    46a0:	0b c0       	rjmp	.+22     	; 0x46b8 <__vector_7+0x44>
	return TIFR1 & (1<<TOV1);
}

static inline void counter_overflow_reset(void)
{
	TIFR1 = (1<<TOV1);
    46a2:	81 e0       	ldi	r24, 0x01	; 1
    46a4:	86 bb       	out	0x16, r24	; 22
		counter_overflow_reset();
		count_msw++;
    46a6:	80 91 d6 04 	lds	r24, 0x04D6	; 0x8004d6 <_ZL9count_msw>
    46aa:	90 91 d7 04 	lds	r25, 0x04D7	; 0x8004d7 <_ZL9count_msw+0x1>
    46ae:	01 96       	adiw	r24, 0x01	; 1
    46b0:	90 93 d7 04 	sts	0x04D7, r25	; 0x8004d7 <_ZL9count_msw+0x1>
    46b4:	80 93 d6 04 	sts	0x04D6, r24	; 0x8004d6 <_ZL9count_msw>
	}
	index = gate_index + 1;
    46b8:	80 91 c9 04 	lds	r24, 0x04C9	; 0x8004c9 <_ZL10gate_index>
    46bc:	90 91 ca 04 	lds	r25, 0x04CA	; 0x8004ca <_ZL10gate_index+0x1>
    46c0:	01 96       	adiw	r24, 0x01	; 1
	length = gate_length;
	if (index >= length) {
    46c2:	40 91 cb 04 	lds	r20, 0x04CB	; 0x8004cb <_ZL11gate_length>
    46c6:	50 91 cc 04 	lds	r21, 0x04CC	; 0x8004cc <_ZL11gate_length+0x1>
    46ca:	84 17       	cp	r24, r20
    46cc:	95 07       	cpc	r25, r21
    46ce:	98 f1       	brcs	.+102    	; 0x4736 <__vector_7+0xc2>
		gate_index = 0;
    46d0:	10 92 ca 04 	sts	0x04CA, r1	; 0x8004ca <_ZL10gate_index+0x1>
    46d4:	10 92 c9 04 	sts	0x04C9, r1	; 0x8004c9 <_ZL10gate_index>
		count = ((uint32_t)count_msw << 16) + count_lsw;
    46d8:	80 91 d6 04 	lds	r24, 0x04D6	; 0x8004d6 <_ZL9count_msw>
    46dc:	90 91 d7 04 	lds	r25, 0x04D7	; 0x8004d7 <_ZL9count_msw+0x1>
    46e0:	a0 e0       	ldi	r26, 0x00	; 0
    46e2:	b0 e0       	ldi	r27, 0x00	; 0
    46e4:	dc 01       	movw	r26, r24
    46e6:	99 27       	eor	r25, r25
    46e8:	88 27       	eor	r24, r24
    46ea:	82 0f       	add	r24, r18
    46ec:	93 1f       	adc	r25, r19
    46ee:	a1 1d       	adc	r26, r1
    46f0:	b1 1d       	adc	r27, r1
		count_output = count - count_prev;
    46f2:	40 91 d2 04 	lds	r20, 0x04D2	; 0x8004d2 <_ZL10count_prev>
    46f6:	50 91 d3 04 	lds	r21, 0x04D3	; 0x8004d3 <_ZL10count_prev+0x1>
    46fa:	60 91 d4 04 	lds	r22, 0x04D4	; 0x8004d4 <_ZL10count_prev+0x2>
    46fe:	70 91 d5 04 	lds	r23, 0x04D5	; 0x8004d5 <_ZL10count_prev+0x3>
    4702:	8c 01       	movw	r16, r24
    4704:	9d 01       	movw	r18, r26
    4706:	04 1b       	sub	r16, r20
    4708:	15 0b       	sbc	r17, r21
    470a:	26 0b       	sbc	r18, r22
    470c:	37 0b       	sbc	r19, r23
    470e:	00 93 ce 04 	sts	0x04CE, r16	; 0x8004ce <_ZL12count_output>
    4712:	10 93 cf 04 	sts	0x04CF, r17	; 0x8004cf <_ZL12count_output+0x1>
    4716:	20 93 d0 04 	sts	0x04D0, r18	; 0x8004d0 <_ZL12count_output+0x2>
    471a:	30 93 d1 04 	sts	0x04D1, r19	; 0x8004d1 <_ZL12count_output+0x3>
		count_prev = count;
    471e:	80 93 d2 04 	sts	0x04D2, r24	; 0x8004d2 <_ZL10count_prev>
    4722:	90 93 d3 04 	sts	0x04D3, r25	; 0x8004d3 <_ZL10count_prev+0x1>
    4726:	a0 93 d4 04 	sts	0x04D4, r26	; 0x8004d4 <_ZL10count_prev+0x2>
    472a:	b0 93 d5 04 	sts	0x04D5, r27	; 0x8004d5 <_ZL10count_prev+0x3>
		count_ready = 1;
    472e:	81 e0       	ldi	r24, 0x01	; 1
    4730:	80 93 cd 04 	sts	0x04CD, r24	; 0x8004cd <_ZL11count_ready>
    4734:	04 c0       	rjmp	.+8      	; 0x473e <__vector_7+0xca>
		restore_other_interrupts();
	} else {
		if (index == length - 1) disable_other_interrupts();
		gate_index = index;
    4736:	90 93 ca 04 	sts	0x04CA, r25	; 0x8004ca <_ZL10gate_index+0x1>
    473a:	80 93 c9 04 	sts	0x04C9, r24	; 0x8004c9 <_ZL10gate_index>
	}
}
    473e:	bf 91       	pop	r27
    4740:	af 91       	pop	r26
    4742:	9f 91       	pop	r25
    4744:	8f 91       	pop	r24
    4746:	7f 91       	pop	r23
    4748:	6f 91       	pop	r22
    474a:	5f 91       	pop	r21
    474c:	4f 91       	pop	r20
    474e:	3f 91       	pop	r19
    4750:	2f 91       	pop	r18
    4752:	1f 91       	pop	r17
    4754:	0f 91       	pop	r16
    4756:	0f 90       	pop	r0
    4758:	0f be       	out	0x3f, r0	; 63
    475a:	0f 90       	pop	r0
    475c:	1f 90       	pop	r1
    475e:	18 95       	reti

00004760 <yield>:
 * libraries or sketches that supports cooperative threads.
 *
 * Its defined as a weak symbol and it can be redefined to implement a
 * real cooperative scheduler.
 */
static void __empty() {
    4760:	08 95       	ret

00004762 <__divmodhi4>:
    4762:	97 fb       	bst	r25, 7
    4764:	07 2e       	mov	r0, r23
    4766:	16 f4       	brtc	.+4      	; 0x476c <__divmodhi4+0xa>
    4768:	00 94       	com	r0
    476a:	07 d0       	rcall	.+14     	; 0x477a <__divmodhi4_neg1>
    476c:	77 fd       	sbrc	r23, 7
    476e:	09 d0       	rcall	.+18     	; 0x4782 <__divmodhi4_neg2>
    4770:	0e 94 17 24 	call	0x482e	; 0x482e <__udivmodhi4>
    4774:	07 fc       	sbrc	r0, 7
    4776:	05 d0       	rcall	.+10     	; 0x4782 <__divmodhi4_neg2>
    4778:	3e f4       	brtc	.+14     	; 0x4788 <__divmodhi4_exit>

0000477a <__divmodhi4_neg1>:
    477a:	90 95       	com	r25
    477c:	81 95       	neg	r24
    477e:	9f 4f       	sbci	r25, 0xFF	; 255
    4780:	08 95       	ret

00004782 <__divmodhi4_neg2>:
    4782:	70 95       	com	r23
    4784:	61 95       	neg	r22
    4786:	7f 4f       	sbci	r23, 0xFF	; 255

00004788 <__divmodhi4_exit>:
    4788:	08 95       	ret

0000478a <__udivmodsi4>:
    478a:	a1 e2       	ldi	r26, 0x21	; 33
    478c:	1a 2e       	mov	r1, r26
    478e:	aa 1b       	sub	r26, r26
    4790:	bb 1b       	sub	r27, r27
    4792:	fd 01       	movw	r30, r26
    4794:	0d c0       	rjmp	.+26     	; 0x47b0 <__udivmodsi4_ep>

00004796 <__udivmodsi4_loop>:
    4796:	aa 1f       	adc	r26, r26
    4798:	bb 1f       	adc	r27, r27
    479a:	ee 1f       	adc	r30, r30
    479c:	ff 1f       	adc	r31, r31
    479e:	a2 17       	cp	r26, r18
    47a0:	b3 07       	cpc	r27, r19
    47a2:	e4 07       	cpc	r30, r20
    47a4:	f5 07       	cpc	r31, r21
    47a6:	20 f0       	brcs	.+8      	; 0x47b0 <__udivmodsi4_ep>
    47a8:	a2 1b       	sub	r26, r18
    47aa:	b3 0b       	sbc	r27, r19
    47ac:	e4 0b       	sbc	r30, r20
    47ae:	f5 0b       	sbc	r31, r21

000047b0 <__udivmodsi4_ep>:
    47b0:	66 1f       	adc	r22, r22
    47b2:	77 1f       	adc	r23, r23
    47b4:	88 1f       	adc	r24, r24
    47b6:	99 1f       	adc	r25, r25
    47b8:	1a 94       	dec	r1
    47ba:	69 f7       	brne	.-38     	; 0x4796 <__udivmodsi4_loop>
    47bc:	60 95       	com	r22
    47be:	70 95       	com	r23
    47c0:	80 95       	com	r24
    47c2:	90 95       	com	r25
    47c4:	9b 01       	movw	r18, r22
    47c6:	ac 01       	movw	r20, r24
    47c8:	bd 01       	movw	r22, r26
    47ca:	cf 01       	movw	r24, r30
    47cc:	08 95       	ret

000047ce <__divmodsi4>:
    47ce:	05 2e       	mov	r0, r21
    47d0:	97 fb       	bst	r25, 7
    47d2:	1e f4       	brtc	.+6      	; 0x47da <__divmodsi4+0xc>
    47d4:	00 94       	com	r0
    47d6:	0e 94 fe 23 	call	0x47fc	; 0x47fc <__negsi2>
    47da:	57 fd       	sbrc	r21, 7
    47dc:	07 d0       	rcall	.+14     	; 0x47ec <__divmodsi4_neg2>
    47de:	0e 94 c5 23 	call	0x478a	; 0x478a <__udivmodsi4>
    47e2:	07 fc       	sbrc	r0, 7
    47e4:	03 d0       	rcall	.+6      	; 0x47ec <__divmodsi4_neg2>
    47e6:	4e f4       	brtc	.+18     	; 0x47fa <__divmodsi4_exit>
    47e8:	0c 94 fe 23 	jmp	0x47fc	; 0x47fc <__negsi2>

000047ec <__divmodsi4_neg2>:
    47ec:	50 95       	com	r21
    47ee:	40 95       	com	r20
    47f0:	30 95       	com	r19
    47f2:	21 95       	neg	r18
    47f4:	3f 4f       	sbci	r19, 0xFF	; 255
    47f6:	4f 4f       	sbci	r20, 0xFF	; 255
    47f8:	5f 4f       	sbci	r21, 0xFF	; 255

000047fa <__divmodsi4_exit>:
    47fa:	08 95       	ret

000047fc <__negsi2>:
    47fc:	90 95       	com	r25
    47fe:	80 95       	com	r24
    4800:	70 95       	com	r23
    4802:	61 95       	neg	r22
    4804:	7f 4f       	sbci	r23, 0xFF	; 255
    4806:	8f 4f       	sbci	r24, 0xFF	; 255
    4808:	9f 4f       	sbci	r25, 0xFF	; 255
    480a:	08 95       	ret

0000480c <__tablejump2__>:
    480c:	ee 0f       	add	r30, r30
    480e:	ff 1f       	adc	r31, r31
    4810:	05 90       	lpm	r0, Z+
    4812:	f4 91       	lpm	r31, Z
    4814:	e0 2d       	mov	r30, r0
    4816:	09 94       	ijmp

00004818 <__muluhisi3>:
    4818:	0e 94 2b 24 	call	0x4856	; 0x4856 <__umulhisi3>
    481c:	a5 9f       	mul	r26, r21
    481e:	90 0d       	add	r25, r0
    4820:	b4 9f       	mul	r27, r20
    4822:	90 0d       	add	r25, r0
    4824:	a4 9f       	mul	r26, r20
    4826:	80 0d       	add	r24, r0
    4828:	91 1d       	adc	r25, r1
    482a:	11 24       	eor	r1, r1
    482c:	08 95       	ret

0000482e <__udivmodhi4>:
    482e:	aa 1b       	sub	r26, r26
    4830:	bb 1b       	sub	r27, r27
    4832:	51 e1       	ldi	r21, 0x11	; 17
    4834:	07 c0       	rjmp	.+14     	; 0x4844 <__udivmodhi4_ep>

00004836 <__udivmodhi4_loop>:
    4836:	aa 1f       	adc	r26, r26
    4838:	bb 1f       	adc	r27, r27
    483a:	a6 17       	cp	r26, r22
    483c:	b7 07       	cpc	r27, r23
    483e:	10 f0       	brcs	.+4      	; 0x4844 <__udivmodhi4_ep>
    4840:	a6 1b       	sub	r26, r22
    4842:	b7 0b       	sbc	r27, r23

00004844 <__udivmodhi4_ep>:
    4844:	88 1f       	adc	r24, r24
    4846:	99 1f       	adc	r25, r25
    4848:	5a 95       	dec	r21
    484a:	a9 f7       	brne	.-22     	; 0x4836 <__udivmodhi4_loop>
    484c:	80 95       	com	r24
    484e:	90 95       	com	r25
    4850:	bc 01       	movw	r22, r24
    4852:	cd 01       	movw	r24, r26
    4854:	08 95       	ret

00004856 <__umulhisi3>:
    4856:	a2 9f       	mul	r26, r18
    4858:	b0 01       	movw	r22, r0
    485a:	b3 9f       	mul	r27, r19
    485c:	c0 01       	movw	r24, r0
    485e:	a3 9f       	mul	r26, r19
    4860:	70 0d       	add	r23, r0
    4862:	81 1d       	adc	r24, r1
    4864:	11 24       	eor	r1, r1
    4866:	91 1d       	adc	r25, r1
    4868:	b2 9f       	mul	r27, r18
    486a:	70 0d       	add	r23, r0
    486c:	81 1d       	adc	r24, r1
    486e:	11 24       	eor	r1, r1
    4870:	91 1d       	adc	r25, r1
    4872:	08 95       	ret

00004874 <malloc>:
    4874:	0f 93       	push	r16
    4876:	1f 93       	push	r17
    4878:	cf 93       	push	r28
    487a:	df 93       	push	r29
    487c:	82 30       	cpi	r24, 0x02	; 2
    487e:	91 05       	cpc	r25, r1
    4880:	10 f4       	brcc	.+4      	; 0x4886 <malloc+0x12>
    4882:	82 e0       	ldi	r24, 0x02	; 2
    4884:	90 e0       	ldi	r25, 0x00	; 0
    4886:	e0 91 df 04 	lds	r30, 0x04DF	; 0x8004df <__flp>
    488a:	f0 91 e0 04 	lds	r31, 0x04E0	; 0x8004e0 <__flp+0x1>
    488e:	20 e0       	ldi	r18, 0x00	; 0
    4890:	30 e0       	ldi	r19, 0x00	; 0
    4892:	a0 e0       	ldi	r26, 0x00	; 0
    4894:	b0 e0       	ldi	r27, 0x00	; 0
    4896:	30 97       	sbiw	r30, 0x00	; 0
    4898:	19 f1       	breq	.+70     	; 0x48e0 <malloc+0x6c>
    489a:	40 81       	ld	r20, Z
    489c:	51 81       	ldd	r21, Z+1	; 0x01
    489e:	02 81       	ldd	r16, Z+2	; 0x02
    48a0:	13 81       	ldd	r17, Z+3	; 0x03
    48a2:	48 17       	cp	r20, r24
    48a4:	59 07       	cpc	r21, r25
    48a6:	c8 f0       	brcs	.+50     	; 0x48da <malloc+0x66>
    48a8:	84 17       	cp	r24, r20
    48aa:	95 07       	cpc	r25, r21
    48ac:	69 f4       	brne	.+26     	; 0x48c8 <malloc+0x54>
    48ae:	10 97       	sbiw	r26, 0x00	; 0
    48b0:	31 f0       	breq	.+12     	; 0x48be <malloc+0x4a>
    48b2:	12 96       	adiw	r26, 0x02	; 2
    48b4:	0c 93       	st	X, r16
    48b6:	12 97       	sbiw	r26, 0x02	; 2
    48b8:	13 96       	adiw	r26, 0x03	; 3
    48ba:	1c 93       	st	X, r17
    48bc:	27 c0       	rjmp	.+78     	; 0x490c <malloc+0x98>
    48be:	00 93 df 04 	sts	0x04DF, r16	; 0x8004df <__flp>
    48c2:	10 93 e0 04 	sts	0x04E0, r17	; 0x8004e0 <__flp+0x1>
    48c6:	22 c0       	rjmp	.+68     	; 0x490c <malloc+0x98>
    48c8:	21 15       	cp	r18, r1
    48ca:	31 05       	cpc	r19, r1
    48cc:	19 f0       	breq	.+6      	; 0x48d4 <malloc+0x60>
    48ce:	42 17       	cp	r20, r18
    48d0:	53 07       	cpc	r21, r19
    48d2:	18 f4       	brcc	.+6      	; 0x48da <malloc+0x66>
    48d4:	9a 01       	movw	r18, r20
    48d6:	bd 01       	movw	r22, r26
    48d8:	ef 01       	movw	r28, r30
    48da:	df 01       	movw	r26, r30
    48dc:	f8 01       	movw	r30, r16
    48de:	db cf       	rjmp	.-74     	; 0x4896 <malloc+0x22>
    48e0:	21 15       	cp	r18, r1
    48e2:	31 05       	cpc	r19, r1
    48e4:	f9 f0       	breq	.+62     	; 0x4924 <malloc+0xb0>
    48e6:	28 1b       	sub	r18, r24
    48e8:	39 0b       	sbc	r19, r25
    48ea:	24 30       	cpi	r18, 0x04	; 4
    48ec:	31 05       	cpc	r19, r1
    48ee:	80 f4       	brcc	.+32     	; 0x4910 <malloc+0x9c>
    48f0:	8a 81       	ldd	r24, Y+2	; 0x02
    48f2:	9b 81       	ldd	r25, Y+3	; 0x03
    48f4:	61 15       	cp	r22, r1
    48f6:	71 05       	cpc	r23, r1
    48f8:	21 f0       	breq	.+8      	; 0x4902 <malloc+0x8e>
    48fa:	fb 01       	movw	r30, r22
    48fc:	93 83       	std	Z+3, r25	; 0x03
    48fe:	82 83       	std	Z+2, r24	; 0x02
    4900:	04 c0       	rjmp	.+8      	; 0x490a <malloc+0x96>
    4902:	90 93 e0 04 	sts	0x04E0, r25	; 0x8004e0 <__flp+0x1>
    4906:	80 93 df 04 	sts	0x04DF, r24	; 0x8004df <__flp>
    490a:	fe 01       	movw	r30, r28
    490c:	32 96       	adiw	r30, 0x02	; 2
    490e:	44 c0       	rjmp	.+136    	; 0x4998 <malloc+0x124>
    4910:	fe 01       	movw	r30, r28
    4912:	e2 0f       	add	r30, r18
    4914:	f3 1f       	adc	r31, r19
    4916:	81 93       	st	Z+, r24
    4918:	91 93       	st	Z+, r25
    491a:	22 50       	subi	r18, 0x02	; 2
    491c:	31 09       	sbc	r19, r1
    491e:	39 83       	std	Y+1, r19	; 0x01
    4920:	28 83       	st	Y, r18
    4922:	3a c0       	rjmp	.+116    	; 0x4998 <malloc+0x124>
    4924:	20 91 dd 04 	lds	r18, 0x04DD	; 0x8004dd <__brkval>
    4928:	30 91 de 04 	lds	r19, 0x04DE	; 0x8004de <__brkval+0x1>
    492c:	23 2b       	or	r18, r19
    492e:	41 f4       	brne	.+16     	; 0x4940 <malloc+0xcc>
    4930:	20 91 02 01 	lds	r18, 0x0102	; 0x800102 <__malloc_heap_start>
    4934:	30 91 03 01 	lds	r19, 0x0103	; 0x800103 <__malloc_heap_start+0x1>
    4938:	30 93 de 04 	sts	0x04DE, r19	; 0x8004de <__brkval+0x1>
    493c:	20 93 dd 04 	sts	0x04DD, r18	; 0x8004dd <__brkval>
    4940:	20 91 00 01 	lds	r18, 0x0100	; 0x800100 <__data_start>
    4944:	30 91 01 01 	lds	r19, 0x0101	; 0x800101 <__data_start+0x1>
    4948:	21 15       	cp	r18, r1
    494a:	31 05       	cpc	r19, r1
    494c:	41 f4       	brne	.+16     	; 0x495e <malloc+0xea>
    494e:	2d b7       	in	r18, 0x3d	; 61
    4950:	3e b7       	in	r19, 0x3e	; 62
    4952:	40 91 04 01 	lds	r20, 0x0104	; 0x800104 <__malloc_margin>
    4956:	50 91 05 01 	lds	r21, 0x0105	; 0x800105 <__malloc_margin+0x1>
    495a:	24 1b       	sub	r18, r20
    495c:	35 0b       	sbc	r19, r21
    495e:	e0 91 dd 04 	lds	r30, 0x04DD	; 0x8004dd <__brkval>
    4962:	f0 91 de 04 	lds	r31, 0x04DE	; 0x8004de <__brkval+0x1>
    4966:	e2 17       	cp	r30, r18
    4968:	f3 07       	cpc	r31, r19
    496a:	a0 f4       	brcc	.+40     	; 0x4994 <malloc+0x120>
    496c:	2e 1b       	sub	r18, r30
    496e:	3f 0b       	sbc	r19, r31
    4970:	28 17       	cp	r18, r24
    4972:	39 07       	cpc	r19, r25
    4974:	78 f0       	brcs	.+30     	; 0x4994 <malloc+0x120>
    4976:	ac 01       	movw	r20, r24
    4978:	4e 5f       	subi	r20, 0xFE	; 254
    497a:	5f 4f       	sbci	r21, 0xFF	; 255
    497c:	24 17       	cp	r18, r20
    497e:	35 07       	cpc	r19, r21
    4980:	48 f0       	brcs	.+18     	; 0x4994 <malloc+0x120>
    4982:	4e 0f       	add	r20, r30
    4984:	5f 1f       	adc	r21, r31
    4986:	50 93 de 04 	sts	0x04DE, r21	; 0x8004de <__brkval+0x1>
    498a:	40 93 dd 04 	sts	0x04DD, r20	; 0x8004dd <__brkval>
    498e:	81 93       	st	Z+, r24
    4990:	91 93       	st	Z+, r25
    4992:	02 c0       	rjmp	.+4      	; 0x4998 <malloc+0x124>
    4994:	e0 e0       	ldi	r30, 0x00	; 0
    4996:	f0 e0       	ldi	r31, 0x00	; 0
    4998:	cf 01       	movw	r24, r30
    499a:	df 91       	pop	r29
    499c:	cf 91       	pop	r28
    499e:	1f 91       	pop	r17
    49a0:	0f 91       	pop	r16
    49a2:	08 95       	ret

000049a4 <free>:
    49a4:	cf 93       	push	r28
    49a6:	df 93       	push	r29
    49a8:	00 97       	sbiw	r24, 0x00	; 0
    49aa:	09 f4       	brne	.+2      	; 0x49ae <free+0xa>
    49ac:	81 c0       	rjmp	.+258    	; 0x4ab0 <free+0x10c>
    49ae:	fc 01       	movw	r30, r24
    49b0:	32 97       	sbiw	r30, 0x02	; 2
    49b2:	13 82       	std	Z+3, r1	; 0x03
    49b4:	12 82       	std	Z+2, r1	; 0x02
    49b6:	a0 91 df 04 	lds	r26, 0x04DF	; 0x8004df <__flp>
    49ba:	b0 91 e0 04 	lds	r27, 0x04E0	; 0x8004e0 <__flp+0x1>
    49be:	10 97       	sbiw	r26, 0x00	; 0
    49c0:	81 f4       	brne	.+32     	; 0x49e2 <free+0x3e>
    49c2:	20 81       	ld	r18, Z
    49c4:	31 81       	ldd	r19, Z+1	; 0x01
    49c6:	82 0f       	add	r24, r18
    49c8:	93 1f       	adc	r25, r19
    49ca:	20 91 dd 04 	lds	r18, 0x04DD	; 0x8004dd <__brkval>
    49ce:	30 91 de 04 	lds	r19, 0x04DE	; 0x8004de <__brkval+0x1>
    49d2:	28 17       	cp	r18, r24
    49d4:	39 07       	cpc	r19, r25
    49d6:	51 f5       	brne	.+84     	; 0x4a2c <free+0x88>
    49d8:	f0 93 de 04 	sts	0x04DE, r31	; 0x8004de <__brkval+0x1>
    49dc:	e0 93 dd 04 	sts	0x04DD, r30	; 0x8004dd <__brkval>
    49e0:	67 c0       	rjmp	.+206    	; 0x4ab0 <free+0x10c>
    49e2:	ed 01       	movw	r28, r26
    49e4:	20 e0       	ldi	r18, 0x00	; 0
    49e6:	30 e0       	ldi	r19, 0x00	; 0
    49e8:	ce 17       	cp	r28, r30
    49ea:	df 07       	cpc	r29, r31
    49ec:	40 f4       	brcc	.+16     	; 0x49fe <free+0x5a>
    49ee:	4a 81       	ldd	r20, Y+2	; 0x02
    49f0:	5b 81       	ldd	r21, Y+3	; 0x03
    49f2:	9e 01       	movw	r18, r28
    49f4:	41 15       	cp	r20, r1
    49f6:	51 05       	cpc	r21, r1
    49f8:	f1 f0       	breq	.+60     	; 0x4a36 <free+0x92>
    49fa:	ea 01       	movw	r28, r20
    49fc:	f5 cf       	rjmp	.-22     	; 0x49e8 <free+0x44>
    49fe:	d3 83       	std	Z+3, r29	; 0x03
    4a00:	c2 83       	std	Z+2, r28	; 0x02
    4a02:	40 81       	ld	r20, Z
    4a04:	51 81       	ldd	r21, Z+1	; 0x01
    4a06:	84 0f       	add	r24, r20
    4a08:	95 1f       	adc	r25, r21
    4a0a:	c8 17       	cp	r28, r24
    4a0c:	d9 07       	cpc	r29, r25
    4a0e:	59 f4       	brne	.+22     	; 0x4a26 <free+0x82>
    4a10:	88 81       	ld	r24, Y
    4a12:	99 81       	ldd	r25, Y+1	; 0x01
    4a14:	84 0f       	add	r24, r20
    4a16:	95 1f       	adc	r25, r21
    4a18:	02 96       	adiw	r24, 0x02	; 2
    4a1a:	91 83       	std	Z+1, r25	; 0x01
    4a1c:	80 83       	st	Z, r24
    4a1e:	8a 81       	ldd	r24, Y+2	; 0x02
    4a20:	9b 81       	ldd	r25, Y+3	; 0x03
    4a22:	93 83       	std	Z+3, r25	; 0x03
    4a24:	82 83       	std	Z+2, r24	; 0x02
    4a26:	21 15       	cp	r18, r1
    4a28:	31 05       	cpc	r19, r1
    4a2a:	29 f4       	brne	.+10     	; 0x4a36 <free+0x92>
    4a2c:	f0 93 e0 04 	sts	0x04E0, r31	; 0x8004e0 <__flp+0x1>
    4a30:	e0 93 df 04 	sts	0x04DF, r30	; 0x8004df <__flp>
    4a34:	3d c0       	rjmp	.+122    	; 0x4ab0 <free+0x10c>
    4a36:	e9 01       	movw	r28, r18
    4a38:	fb 83       	std	Y+3, r31	; 0x03
    4a3a:	ea 83       	std	Y+2, r30	; 0x02
    4a3c:	49 91       	ld	r20, Y+
    4a3e:	59 91       	ld	r21, Y+
    4a40:	c4 0f       	add	r28, r20
    4a42:	d5 1f       	adc	r29, r21
    4a44:	ec 17       	cp	r30, r28
    4a46:	fd 07       	cpc	r31, r29
    4a48:	61 f4       	brne	.+24     	; 0x4a62 <free+0xbe>
    4a4a:	80 81       	ld	r24, Z
    4a4c:	91 81       	ldd	r25, Z+1	; 0x01
    4a4e:	84 0f       	add	r24, r20
    4a50:	95 1f       	adc	r25, r21
    4a52:	02 96       	adiw	r24, 0x02	; 2
    4a54:	e9 01       	movw	r28, r18
    4a56:	99 83       	std	Y+1, r25	; 0x01
    4a58:	88 83       	st	Y, r24
    4a5a:	82 81       	ldd	r24, Z+2	; 0x02
    4a5c:	93 81       	ldd	r25, Z+3	; 0x03
    4a5e:	9b 83       	std	Y+3, r25	; 0x03
    4a60:	8a 83       	std	Y+2, r24	; 0x02
    4a62:	e0 e0       	ldi	r30, 0x00	; 0
    4a64:	f0 e0       	ldi	r31, 0x00	; 0
    4a66:	12 96       	adiw	r26, 0x02	; 2
    4a68:	8d 91       	ld	r24, X+
    4a6a:	9c 91       	ld	r25, X
    4a6c:	13 97       	sbiw	r26, 0x03	; 3
    4a6e:	00 97       	sbiw	r24, 0x00	; 0
    4a70:	19 f0       	breq	.+6      	; 0x4a78 <free+0xd4>
    4a72:	fd 01       	movw	r30, r26
    4a74:	dc 01       	movw	r26, r24
    4a76:	f7 cf       	rjmp	.-18     	; 0x4a66 <free+0xc2>
    4a78:	8d 91       	ld	r24, X+
    4a7a:	9c 91       	ld	r25, X
    4a7c:	11 97       	sbiw	r26, 0x01	; 1
    4a7e:	9d 01       	movw	r18, r26
    4a80:	2e 5f       	subi	r18, 0xFE	; 254
    4a82:	3f 4f       	sbci	r19, 0xFF	; 255
    4a84:	82 0f       	add	r24, r18
    4a86:	93 1f       	adc	r25, r19
    4a88:	20 91 dd 04 	lds	r18, 0x04DD	; 0x8004dd <__brkval>
    4a8c:	30 91 de 04 	lds	r19, 0x04DE	; 0x8004de <__brkval+0x1>
    4a90:	28 17       	cp	r18, r24
    4a92:	39 07       	cpc	r19, r25
    4a94:	69 f4       	brne	.+26     	; 0x4ab0 <free+0x10c>
    4a96:	30 97       	sbiw	r30, 0x00	; 0
    4a98:	29 f4       	brne	.+10     	; 0x4aa4 <free+0x100>
    4a9a:	10 92 e0 04 	sts	0x04E0, r1	; 0x8004e0 <__flp+0x1>
    4a9e:	10 92 df 04 	sts	0x04DF, r1	; 0x8004df <__flp>
    4aa2:	02 c0       	rjmp	.+4      	; 0x4aa8 <free+0x104>
    4aa4:	13 82       	std	Z+3, r1	; 0x03
    4aa6:	12 82       	std	Z+2, r1	; 0x02
    4aa8:	b0 93 de 04 	sts	0x04DE, r27	; 0x8004de <__brkval+0x1>
    4aac:	a0 93 dd 04 	sts	0x04DD, r26	; 0x8004dd <__brkval>
    4ab0:	df 91       	pop	r29
    4ab2:	cf 91       	pop	r28
    4ab4:	08 95       	ret

00004ab6 <memcpy>:
    4ab6:	fb 01       	movw	r30, r22
    4ab8:	dc 01       	movw	r26, r24
    4aba:	02 c0       	rjmp	.+4      	; 0x4ac0 <memcpy+0xa>
    4abc:	01 90       	ld	r0, Z+
    4abe:	0d 92       	st	X+, r0
    4ac0:	41 50       	subi	r20, 0x01	; 1
    4ac2:	50 40       	sbci	r21, 0x00	; 0
    4ac4:	d8 f7       	brcc	.-10     	; 0x4abc <memcpy+0x6>
    4ac6:	08 95       	ret

00004ac8 <memset>:
    4ac8:	dc 01       	movw	r26, r24
    4aca:	01 c0       	rjmp	.+2      	; 0x4ace <memset+0x6>
    4acc:	6d 93       	st	X+, r22
    4ace:	41 50       	subi	r20, 0x01	; 1
    4ad0:	50 40       	sbci	r21, 0x00	; 0
    4ad2:	e0 f7       	brcc	.-8      	; 0x4acc <memset+0x4>
    4ad4:	08 95       	ret

00004ad6 <__do_global_dtors>:
    4ad6:	10 e0       	ldi	r17, 0x00	; 0
    4ad8:	c8 e8       	ldi	r28, 0x88	; 136
    4ada:	d0 e0       	ldi	r29, 0x00	; 0
    4adc:	04 c0       	rjmp	.+8      	; 0x4ae6 <__do_global_dtors+0x10>
    4ade:	fe 01       	movw	r30, r28
    4ae0:	0e 94 06 24 	call	0x480c	; 0x480c <__tablejump2__>
    4ae4:	21 96       	adiw	r28, 0x01	; 1
    4ae6:	c9 38       	cpi	r28, 0x89	; 137
    4ae8:	d1 07       	cpc	r29, r17
    4aea:	c9 f7       	brne	.-14     	; 0x4ade <__do_global_dtors+0x8>
    4aec:	f8 94       	cli

00004aee <__stop_program>:
    4aee:	ff cf       	rjmp	.-2      	; 0x4aee <__stop_program>
