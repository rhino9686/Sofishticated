
lil_fish_tanks_arduino.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000184  00800100  000046fe  00004792  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         000046fe  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000286  00800284  00800284  00004916  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00004916  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00004948  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000a10  00000000  00000000  00004988  2**3
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00013994  00000000  00000000  00005398  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00003d4b  00000000  00000000  00018d2c  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   0000696d  00000000  00000000  0001ca77  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00001ed0  00000000  00000000  000233e4  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00004b41  00000000  00000000  000252b4  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    0000b7b2  00000000  00000000  00029df5  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000930  00000000  00000000  000355a7  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 8b 00 	jmp	0x116	; 0x116 <__dtors_end>
       4:	0c 94 91 10 	jmp	0x2122	; 0x2122 <__vector_1>
       8:	0c 94 b8 10 	jmp	0x2170	; 0x2170 <__vector_2>
       c:	0c 94 b3 00 	jmp	0x166	; 0x166 <__bad_interrupt>
      10:	0c 94 b3 00 	jmp	0x166	; 0x166 <__bad_interrupt>
      14:	0c 94 b3 00 	jmp	0x166	; 0x166 <__bad_interrupt>
      18:	0c 94 84 20 	jmp	0x4108	; 0x4108 <__vector_6>
      1c:	0c 94 27 21 	jmp	0x424e	; 0x424e <__vector_7>
      20:	0c 94 b3 00 	jmp	0x166	; 0x166 <__bad_interrupt>
      24:	0c 94 b3 00 	jmp	0x166	; 0x166 <__bad_interrupt>
      28:	0c 94 b3 00 	jmp	0x166	; 0x166 <__bad_interrupt>
      2c:	0c 94 b3 00 	jmp	0x166	; 0x166 <__bad_interrupt>
      30:	0c 94 b3 00 	jmp	0x166	; 0x166 <__bad_interrupt>
      34:	0c 94 b3 00 	jmp	0x166	; 0x166 <__bad_interrupt>
      38:	0c 94 b3 00 	jmp	0x166	; 0x166 <__bad_interrupt>
      3c:	0c 94 b3 00 	jmp	0x166	; 0x166 <__bad_interrupt>
      40:	0c 94 df 10 	jmp	0x21be	; 0x21be <__vector_16>
      44:	0c 94 b3 00 	jmp	0x166	; 0x166 <__bad_interrupt>
      48:	0c 94 b4 0d 	jmp	0x1b68	; 0x1b68 <__vector_18>
      4c:	0c 94 e6 0d 	jmp	0x1bcc	; 0x1bcc <__vector_19>
      50:	0c 94 b3 00 	jmp	0x166	; 0x166 <__bad_interrupt>
      54:	0c 94 b3 00 	jmp	0x166	; 0x166 <__bad_interrupt>
      58:	0c 94 b3 00 	jmp	0x166	; 0x166 <__bad_interrupt>
      5c:	0c 94 b3 00 	jmp	0x166	; 0x166 <__bad_interrupt>
      60:	0c 94 b3 00 	jmp	0x166	; 0x166 <__bad_interrupt>
      64:	0c 94 b3 00 	jmp	0x166	; 0x166 <__bad_interrupt>
      68:	64 1c       	adc	r6, r4
      6a:	64 1c       	adc	r6, r4
      6c:	64 1c       	adc	r6, r4
      6e:	a3 1c       	adc	r10, r3
      70:	8e 1c       	adc	r8, r14
      72:	9d 1c       	adc	r9, r13
      74:	64 1c       	adc	r6, r4
      76:	64 1c       	adc	r6, r4
      78:	a3 1c       	adc	r10, r3
      7a:	8e 1c       	adc	r8, r14

0000007c <__trampolines_end>:
      7c:	0a 46       	sbci	r16, 0x6A	; 106
      7e:	6f 75       	andi	r22, 0x5F	; 95
      80:	6e 64       	ori	r22, 0x4E	; 78
      82:	20 4d       	sbci	r18, 0xD0	; 208
      84:	61 74       	andi	r22, 0x41	; 65
      86:	63 68       	ori	r22, 0x83	; 131
      88:	69 6e       	ori	r22, 0xE9	; 233
      8a:	67 20       	and	r6, r7
      8c:	43 6f       	ori	r20, 0xF3	; 243
      8e:	6c 6f       	ori	r22, 0xFC	; 252
      90:	72 00       	.word	0x0072	; ????

00000092 <_ZL15dscrc2x16_table>:
      92:	00 5e bc e2 61 3f dd 83 c2 9c 7e 20 a3 fd 1f 41     .^..a?....~ ...A
      a2:	00 9d 23 be 46 db 65 f8 8c 11 af 32 ca 57 e9 74     ..#.F.e....2.W.t

000000b2 <digital_pin_to_timer_PGM>:
      b2:	00 00 00 08 00 02 01 00 00 03 04 07 00 00 00 00     ................
      c2:	00 00 00 00                                         ....

000000c6 <digital_pin_to_bit_mask_PGM>:
      c6:	01 02 04 08 10 20 40 80 01 02 04 08 10 20 01 02     ..... @...... ..
      d6:	04 08 10 20                                         ... 

000000da <digital_pin_to_port_PGM>:
      da:	04 04 04 04 04 04 04 04 02 02 02 02 02 02 03 03     ................
      ea:	03 03 03 03                                         ....

000000ee <port_to_input_PGM>:
      ee:	00 00 00 00 23 00 26 00 29 00                       ....#.&.).

000000f8 <port_to_output_PGM>:
      f8:	00 00 00 00 25 00 28 00 2b 00                       ....%.(.+.

00000102 <port_to_mode_PGM>:
     102:	00 00 00 00 24 00 27 00 2a 00                       ....$.'.*.

0000010c <__ctors_start>:
     10c:	91 07       	cpc	r25, r17
     10e:	2d 0a       	sbc	r2, r29
     110:	16 0e       	add	r1, r22

00000112 <__ctors_end>:
     112:	9d 07       	cpc	r25, r29
     114:	31 0a       	sbc	r3, r17

00000116 <__dtors_end>:
     116:	11 24       	eor	r1, r1
     118:	1f be       	out	0x3f, r1	; 63
     11a:	cf ef       	ldi	r28, 0xFF	; 255
     11c:	d8 e0       	ldi	r29, 0x08	; 8
     11e:	de bf       	out	0x3e, r29	; 62
     120:	cd bf       	out	0x3d, r28	; 61

00000122 <__do_copy_data>:
     122:	12 e0       	ldi	r17, 0x02	; 2
     124:	a0 e0       	ldi	r26, 0x00	; 0
     126:	b1 e0       	ldi	r27, 0x01	; 1
     128:	ee ef       	ldi	r30, 0xFE	; 254
     12a:	f6 e4       	ldi	r31, 0x46	; 70
     12c:	02 c0       	rjmp	.+4      	; 0x132 <__do_copy_data+0x10>
     12e:	05 90       	lpm	r0, Z+
     130:	0d 92       	st	X+, r0
     132:	a4 38       	cpi	r26, 0x84	; 132
     134:	b1 07       	cpc	r27, r17
     136:	d9 f7       	brne	.-10     	; 0x12e <__do_copy_data+0xc>

00000138 <__do_clear_bss>:
     138:	25 e0       	ldi	r18, 0x05	; 5
     13a:	a4 e8       	ldi	r26, 0x84	; 132
     13c:	b2 e0       	ldi	r27, 0x02	; 2
     13e:	01 c0       	rjmp	.+2      	; 0x142 <.do_clear_bss_start>

00000140 <.do_clear_bss_loop>:
     140:	1d 92       	st	X+, r1

00000142 <.do_clear_bss_start>:
     142:	aa 30       	cpi	r26, 0x0A	; 10
     144:	b2 07       	cpc	r27, r18
     146:	e1 f7       	brne	.-8      	; 0x140 <.do_clear_bss_loop>

00000148 <__do_global_ctors>:
     148:	10 e0       	ldi	r17, 0x00	; 0
     14a:	c9 e8       	ldi	r28, 0x89	; 137
     14c:	d0 e0       	ldi	r29, 0x00	; 0
     14e:	04 c0       	rjmp	.+8      	; 0x158 <__do_global_ctors+0x10>
     150:	21 97       	sbiw	r28, 0x01	; 1
     152:	fe 01       	movw	r30, r28
     154:	0e 94 f7 21 	call	0x43ee	; 0x43ee <__tablejump2__>
     158:	c6 38       	cpi	r28, 0x86	; 134
     15a:	d1 07       	cpc	r29, r17
     15c:	c9 f7       	brne	.-14     	; 0x150 <__do_global_ctors+0x8>
     15e:	0e 94 43 0e 	call	0x1c86	; 0x1c86 <main>
     162:	0c 94 72 23 	jmp	0x46e4	; 0x46e4 <__do_global_dtors>

00000166 <__bad_interrupt>:
     166:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

0000016a <_ZN11EEPROMClass4readEi.isra.0>:

    EERef( const int index )
        : index( index )                 {}
    
    //Access/read members.
    uint8_t operator*() const            { return eeprom_read_byte( (uint8_t*) index ); }
     16a:	0c 94 5c 23 	jmp	0x46b8	; 0x46b8 <eeprom_read_byte>

0000016e <_ZN10DFRobot_PHC1Ev>:
#define EEPROM_read(address, p)  {int i = 0; byte *pp = (byte*)&(p);for(; i < sizeof(p); i++) pp[i]=EEPROM.read(address+i);}

#define PHVALUEADDR 0x00    //the start address of the pH calibration parameters stored in the EEPROM


DFRobot_PH::DFRobot_PH()
     16e:	fc 01       	movw	r30, r24
{
    this->_temperature    = 25.0;
     170:	80 e0       	ldi	r24, 0x00	; 0
     172:	90 e0       	ldi	r25, 0x00	; 0
     174:	a8 ec       	ldi	r26, 0xC8	; 200
     176:	b1 e4       	ldi	r27, 0x41	; 65
     178:	80 8b       	std	Z+16, r24	; 0x10
     17a:	91 8b       	std	Z+17, r25	; 0x11
     17c:	a2 8b       	std	Z+18, r26	; 0x12
     17e:	b3 8b       	std	Z+19, r27	; 0x13
    this->_phValue        = 7.0;
     180:	80 e0       	ldi	r24, 0x00	; 0
     182:	90 e0       	ldi	r25, 0x00	; 0
     184:	a0 ee       	ldi	r26, 0xE0	; 224
     186:	b0 e4       	ldi	r27, 0x40	; 64
     188:	80 83       	st	Z, r24
     18a:	91 83       	std	Z+1, r25	; 0x01
     18c:	a2 83       	std	Z+2, r26	; 0x02
     18e:	b3 83       	std	Z+3, r27	; 0x03
    this->_acidVoltage    = 2032.44;    //buffer solution 4.0 at 25C
     190:	84 e1       	ldi	r24, 0x14	; 20
     192:	9e e0       	ldi	r25, 0x0E	; 14
     194:	ae ef       	ldi	r26, 0xFE	; 254
     196:	b4 e4       	ldi	r27, 0x44	; 68
     198:	84 83       	std	Z+4, r24	; 0x04
     19a:	95 83       	std	Z+5, r25	; 0x05
     19c:	a6 83       	std	Z+6, r26	; 0x06
     19e:	b7 83       	std	Z+7, r27	; 0x07
    this->_neutralVoltage = 1500.0;     //buffer solution 7.0 at 25C
     1a0:	80 e0       	ldi	r24, 0x00	; 0
     1a2:	90 e8       	ldi	r25, 0x80	; 128
     1a4:	ab eb       	ldi	r26, 0xBB	; 187
     1a6:	b4 e4       	ldi	r27, 0x44	; 68
     1a8:	80 87       	std	Z+8, r24	; 0x08
     1aa:	91 87       	std	Z+9, r25	; 0x09
     1ac:	a2 87       	std	Z+10, r26	; 0x0a
     1ae:	b3 87       	std	Z+11, r27	; 0x0b
    this->_voltage        = 1500.0;
     1b0:	84 87       	std	Z+12, r24	; 0x0c
     1b2:	95 87       	std	Z+13, r25	; 0x0d
     1b4:	a6 87       	std	Z+14, r26	; 0x0e
     1b6:	b7 87       	std	Z+15, r27	; 0x0f
     1b8:	08 95       	ret

000001ba <_ZN10DFRobot_PHD1Ev>:
}

DFRobot_PH::~DFRobot_PH()
     1ba:	08 95       	ret

000001bc <_ZN10DFRobot_PH5beginEv>:
{

}

void DFRobot_PH::begin()
{
     1bc:	cf 92       	push	r12
     1be:	df 92       	push	r13
     1c0:	ef 92       	push	r14
     1c2:	ff 92       	push	r15
     1c4:	0f 93       	push	r16
     1c6:	1f 93       	push	r17
     1c8:	cf 93       	push	r28
     1ca:	df 93       	push	r29
     1cc:	ec 01       	movw	r28, r24
    EEPROM_read(PHVALUEADDR, this->_neutralVoltage);  //load the neutral (pH = 7.0)voltage of the pH board from the EEPROM
     1ce:	7c 01       	movw	r14, r24
     1d0:	88 e0       	ldi	r24, 0x08	; 8
     1d2:	e8 0e       	add	r14, r24
     1d4:	f1 1c       	adc	r15, r1
     1d6:	67 01       	movw	r12, r14
     1d8:	00 e0       	ldi	r16, 0x00	; 0
     1da:	10 e0       	ldi	r17, 0x00	; 0
     1dc:	c8 01       	movw	r24, r16
     1de:	0e 94 b5 00 	call	0x16a	; 0x16a <_ZN11EEPROMClass4readEi.isra.0>
     1e2:	f6 01       	movw	r30, r12
     1e4:	81 93       	st	Z+, r24
     1e6:	6f 01       	movw	r12, r30
     1e8:	0f 5f       	subi	r16, 0xFF	; 255
     1ea:	1f 4f       	sbci	r17, 0xFF	; 255
     1ec:	04 30       	cpi	r16, 0x04	; 4
     1ee:	11 05       	cpc	r17, r1
     1f0:	a9 f7       	brne	.-22     	; 0x1dc <_ZN10DFRobot_PH5beginEv+0x20>
    Serial.print("_neutralVoltage:");
     1f2:	61 e3       	ldi	r22, 0x31	; 49
     1f4:	71 e0       	ldi	r23, 0x01	; 1
     1f6:	89 ec       	ldi	r24, 0xC9	; 201
     1f8:	93 e0       	ldi	r25, 0x03	; 3
     1fa:	0e 94 a0 0e 	call	0x1d40	; 0x1d40 <_ZN5Print5printEPKc>
    Serial.println(this->_neutralVoltage);
     1fe:	48 85       	ldd	r20, Y+8	; 0x08
     200:	59 85       	ldd	r21, Y+9	; 0x09
     202:	6a 85       	ldd	r22, Y+10	; 0x0a
     204:	7b 85       	ldd	r23, Y+11	; 0x0b
     206:	22 e0       	ldi	r18, 0x02	; 2
     208:	30 e0       	ldi	r19, 0x00	; 0
     20a:	89 ec       	ldi	r24, 0xC9	; 201
     20c:	93 e0       	ldi	r25, 0x03	; 3
     20e:	0e 94 5e 10 	call	0x20bc	; 0x20bc <_ZN5Print7printlnEdi>
    if(EEPROM.read(PHVALUEADDR)==0xFF && EEPROM.read(PHVALUEADDR+1)==0xFF && EEPROM.read(PHVALUEADDR+2)==0xFF && EEPROM.read(PHVALUEADDR+3)==0xFF){
     212:	80 e0       	ldi	r24, 0x00	; 0
     214:	90 e0       	ldi	r25, 0x00	; 0
     216:	0e 94 b5 00 	call	0x16a	; 0x16a <_ZN11EEPROMClass4readEi.isra.0>
     21a:	8f 3f       	cpi	r24, 0xFF	; 255
     21c:	39 f5       	brne	.+78     	; 0x26c <_ZN10DFRobot_PH5beginEv+0xb0>
     21e:	81 e0       	ldi	r24, 0x01	; 1
     220:	90 e0       	ldi	r25, 0x00	; 0
     222:	0e 94 b5 00 	call	0x16a	; 0x16a <_ZN11EEPROMClass4readEi.isra.0>
     226:	8f 3f       	cpi	r24, 0xFF	; 255
     228:	09 f5       	brne	.+66     	; 0x26c <_ZN10DFRobot_PH5beginEv+0xb0>
     22a:	82 e0       	ldi	r24, 0x02	; 2
     22c:	90 e0       	ldi	r25, 0x00	; 0
     22e:	0e 94 b5 00 	call	0x16a	; 0x16a <_ZN11EEPROMClass4readEi.isra.0>
     232:	8f 3f       	cpi	r24, 0xFF	; 255
     234:	d9 f4       	brne	.+54     	; 0x26c <_ZN10DFRobot_PH5beginEv+0xb0>
     236:	83 e0       	ldi	r24, 0x03	; 3
     238:	90 e0       	ldi	r25, 0x00	; 0
     23a:	0e 94 b5 00 	call	0x16a	; 0x16a <_ZN11EEPROMClass4readEi.isra.0>
     23e:	8f 3f       	cpi	r24, 0xFF	; 255
     240:	a9 f4       	brne	.+42     	; 0x26c <_ZN10DFRobot_PH5beginEv+0xb0>
        this->_neutralVoltage = 1500.0;  // new EEPROM, write typical voltage
     242:	80 e0       	ldi	r24, 0x00	; 0
     244:	90 e8       	ldi	r25, 0x80	; 128
     246:	ab eb       	ldi	r26, 0xBB	; 187
     248:	b4 e4       	ldi	r27, 0x44	; 68
     24a:	88 87       	std	Y+8, r24	; 0x08
     24c:	99 87       	std	Y+9, r25	; 0x09
     24e:	aa 87       	std	Y+10, r26	; 0x0a
     250:	bb 87       	std	Y+11, r27	; 0x0b
        EEPROM_write(PHVALUEADDR, this->_neutralVoltage);
     252:	00 e0       	ldi	r16, 0x00	; 0
     254:	10 e0       	ldi	r17, 0x00	; 0
     256:	f7 01       	movw	r30, r14
     258:	61 91       	ld	r22, Z+
     25a:	7f 01       	movw	r14, r30
    operator uint8_t() const             { return **this; }
    
    //Assignment/write members.
    EERef &operator=( const EERef &ref ) { return *this = *ref; }
    EERef &operator=( uint8_t in )       { return eeprom_write_byte( (uint8_t*) index, in ), *this;  }
     25c:	c8 01       	movw	r24, r16
     25e:	0e 94 64 23 	call	0x46c8	; 0x46c8 <eeprom_write_byte>
     262:	0f 5f       	subi	r16, 0xFF	; 255
     264:	1f 4f       	sbci	r17, 0xFF	; 255
     266:	04 30       	cpi	r16, 0x04	; 4
     268:	11 05       	cpc	r17, r1
     26a:	a9 f7       	brne	.-22     	; 0x256 <_ZN10DFRobot_PH5beginEv+0x9a>
    }
    EEPROM_read(PHVALUEADDR+4, this->_acidVoltage);//load the acid (pH = 4.0) voltage of the pH board from the EEPROM
     26c:	7e 01       	movw	r14, r28
     26e:	f4 e0       	ldi	r31, 0x04	; 4
     270:	ef 0e       	add	r14, r31
     272:	f1 1c       	adc	r15, r1
     274:	67 01       	movw	r12, r14
     276:	04 e0       	ldi	r16, 0x04	; 4
     278:	10 e0       	ldi	r17, 0x00	; 0
     27a:	c8 01       	movw	r24, r16
     27c:	0e 94 b5 00 	call	0x16a	; 0x16a <_ZN11EEPROMClass4readEi.isra.0>
     280:	f6 01       	movw	r30, r12
     282:	81 93       	st	Z+, r24
     284:	6f 01       	movw	r12, r30
     286:	0f 5f       	subi	r16, 0xFF	; 255
     288:	1f 4f       	sbci	r17, 0xFF	; 255
     28a:	08 30       	cpi	r16, 0x08	; 8
     28c:	11 05       	cpc	r17, r1
     28e:	a9 f7       	brne	.-22     	; 0x27a <_ZN10DFRobot_PH5beginEv+0xbe>
    Serial.print("_acidVoltage:");
     290:	62 e4       	ldi	r22, 0x42	; 66
     292:	71 e0       	ldi	r23, 0x01	; 1
     294:	89 ec       	ldi	r24, 0xC9	; 201
     296:	93 e0       	ldi	r25, 0x03	; 3
     298:	0e 94 a0 0e 	call	0x1d40	; 0x1d40 <_ZN5Print5printEPKc>
    Serial.println(this->_acidVoltage);
     29c:	4c 81       	ldd	r20, Y+4	; 0x04
     29e:	5d 81       	ldd	r21, Y+5	; 0x05
     2a0:	6e 81       	ldd	r22, Y+6	; 0x06
     2a2:	7f 81       	ldd	r23, Y+7	; 0x07
     2a4:	22 e0       	ldi	r18, 0x02	; 2
     2a6:	30 e0       	ldi	r19, 0x00	; 0
     2a8:	89 ec       	ldi	r24, 0xC9	; 201
     2aa:	93 e0       	ldi	r25, 0x03	; 3
     2ac:	0e 94 5e 10 	call	0x20bc	; 0x20bc <_ZN5Print7printlnEdi>
    if(EEPROM.read(PHVALUEADDR+4)==0xFF && EEPROM.read(PHVALUEADDR+5)==0xFF && EEPROM.read(PHVALUEADDR+6)==0xFF && EEPROM.read(PHVALUEADDR+7)==0xFF){
     2b0:	84 e0       	ldi	r24, 0x04	; 4
     2b2:	90 e0       	ldi	r25, 0x00	; 0
     2b4:	0e 94 b5 00 	call	0x16a	; 0x16a <_ZN11EEPROMClass4readEi.isra.0>
     2b8:	8f 3f       	cpi	r24, 0xFF	; 255
     2ba:	31 f5       	brne	.+76     	; 0x308 <_ZN10DFRobot_PH5beginEv+0x14c>
     2bc:	85 e0       	ldi	r24, 0x05	; 5
     2be:	90 e0       	ldi	r25, 0x00	; 0
     2c0:	0e 94 b5 00 	call	0x16a	; 0x16a <_ZN11EEPROMClass4readEi.isra.0>
     2c4:	8f 3f       	cpi	r24, 0xFF	; 255
     2c6:	01 f5       	brne	.+64     	; 0x308 <_ZN10DFRobot_PH5beginEv+0x14c>
     2c8:	86 e0       	ldi	r24, 0x06	; 6
     2ca:	90 e0       	ldi	r25, 0x00	; 0
     2cc:	0e 94 b5 00 	call	0x16a	; 0x16a <_ZN11EEPROMClass4readEi.isra.0>
     2d0:	8f 3f       	cpi	r24, 0xFF	; 255
     2d2:	d1 f4       	brne	.+52     	; 0x308 <_ZN10DFRobot_PH5beginEv+0x14c>
     2d4:	87 e0       	ldi	r24, 0x07	; 7
     2d6:	90 e0       	ldi	r25, 0x00	; 0
     2d8:	0e 94 b5 00 	call	0x16a	; 0x16a <_ZN11EEPROMClass4readEi.isra.0>
     2dc:	8f 3f       	cpi	r24, 0xFF	; 255
     2de:	a1 f4       	brne	.+40     	; 0x308 <_ZN10DFRobot_PH5beginEv+0x14c>
        this->_acidVoltage = 2032.44;  // new EEPROM, write typical voltage
     2e0:	84 e1       	ldi	r24, 0x14	; 20
     2e2:	9e e0       	ldi	r25, 0x0E	; 14
     2e4:	ae ef       	ldi	r26, 0xFE	; 254
     2e6:	b4 e4       	ldi	r27, 0x44	; 68
     2e8:	8c 83       	std	Y+4, r24	; 0x04
     2ea:	9d 83       	std	Y+5, r25	; 0x05
     2ec:	ae 83       	std	Y+6, r26	; 0x06
     2ee:	bf 83       	std	Y+7, r27	; 0x07
     2f0:	c4 e0       	ldi	r28, 0x04	; 4
     2f2:	d0 e0       	ldi	r29, 0x00	; 0
        EEPROM_write(PHVALUEADDR+4, this->_acidVoltage);
     2f4:	f7 01       	movw	r30, r14
     2f6:	61 91       	ld	r22, Z+
     2f8:	7f 01       	movw	r14, r30
     2fa:	ce 01       	movw	r24, r28
     2fc:	0e 94 64 23 	call	0x46c8	; 0x46c8 <eeprom_write_byte>
     300:	21 96       	adiw	r28, 0x01	; 1
     302:	c8 30       	cpi	r28, 0x08	; 8
     304:	d1 05       	cpc	r29, r1
     306:	b1 f7       	brne	.-20     	; 0x2f4 <_ZN10DFRobot_PH5beginEv+0x138>
    }
}
     308:	df 91       	pop	r29
     30a:	cf 91       	pop	r28
     30c:	1f 91       	pop	r17
     30e:	0f 91       	pop	r16
     310:	ff 90       	pop	r15
     312:	ef 90       	pop	r14
     314:	df 90       	pop	r13
     316:	cf 90       	pop	r12
     318:	08 95       	ret

0000031a <_ZN10DFRobot_PH6readPHEff>:

float DFRobot_PH::readPH(float voltage, float temperature)
{
     31a:	4f 92       	push	r4
     31c:	5f 92       	push	r5
     31e:	6f 92       	push	r6
     320:	7f 92       	push	r7
     322:	8f 92       	push	r8
     324:	9f 92       	push	r9
     326:	af 92       	push	r10
     328:	bf 92       	push	r11
     32a:	cf 92       	push	r12
     32c:	df 92       	push	r13
     32e:	ef 92       	push	r14
     330:	ff 92       	push	r15
     332:	cf 93       	push	r28
     334:	df 93       	push	r29
     336:	ec 01       	movw	r28, r24
     338:	2a 01       	movw	r4, r20
     33a:	3b 01       	movw	r6, r22
    float slope = (7.0-4.0)/((this->_neutralVoltage-1500.0)/3.0 - (this->_acidVoltage-1500.0)/3.0);  // two point: (_neutralVoltage,7.0),(_acidVoltage,4.0)
     33c:	20 e0       	ldi	r18, 0x00	; 0
     33e:	30 e8       	ldi	r19, 0x80	; 128
     340:	4b eb       	ldi	r20, 0xBB	; 187
     342:	54 e4       	ldi	r21, 0x44	; 68
     344:	68 85       	ldd	r22, Y+8	; 0x08
     346:	79 85       	ldd	r23, Y+9	; 0x09
     348:	8a 85       	ldd	r24, Y+10	; 0x0a
     34a:	9b 85       	ldd	r25, Y+11	; 0x0b
     34c:	0e 94 35 0a 	call	0x146a	; 0x146a <__subsf3>
     350:	4b 01       	movw	r8, r22
     352:	5c 01       	movw	r10, r24
     354:	20 e0       	ldi	r18, 0x00	; 0
     356:	30 e0       	ldi	r19, 0x00	; 0
     358:	40 e4       	ldi	r20, 0x40	; 64
     35a:	50 e4       	ldi	r21, 0x40	; 64
     35c:	0e 94 a7 0a 	call	0x154e	; 0x154e <__divsf3>
     360:	6b 01       	movw	r12, r22
     362:	7c 01       	movw	r14, r24
     364:	20 e0       	ldi	r18, 0x00	; 0
     366:	30 e8       	ldi	r19, 0x80	; 128
     368:	4b eb       	ldi	r20, 0xBB	; 187
     36a:	54 e4       	ldi	r21, 0x44	; 68
     36c:	6c 81       	ldd	r22, Y+4	; 0x04
     36e:	7d 81       	ldd	r23, Y+5	; 0x05
     370:	8e 81       	ldd	r24, Y+6	; 0x06
     372:	9f 81       	ldd	r25, Y+7	; 0x07
     374:	0e 94 35 0a 	call	0x146a	; 0x146a <__subsf3>
     378:	20 e0       	ldi	r18, 0x00	; 0
     37a:	30 e0       	ldi	r19, 0x00	; 0
     37c:	40 e4       	ldi	r20, 0x40	; 64
     37e:	50 e4       	ldi	r21, 0x40	; 64
     380:	0e 94 a7 0a 	call	0x154e	; 0x154e <__divsf3>
     384:	9b 01       	movw	r18, r22
     386:	ac 01       	movw	r20, r24
     388:	c7 01       	movw	r24, r14
     38a:	b6 01       	movw	r22, r12
     38c:	0e 94 35 0a 	call	0x146a	; 0x146a <__subsf3>
     390:	9b 01       	movw	r18, r22
     392:	ac 01       	movw	r20, r24
     394:	60 e0       	ldi	r22, 0x00	; 0
     396:	70 e0       	ldi	r23, 0x00	; 0
     398:	80 e4       	ldi	r24, 0x40	; 64
     39a:	90 e4       	ldi	r25, 0x40	; 64
     39c:	0e 94 a7 0a 	call	0x154e	; 0x154e <__divsf3>
     3a0:	6b 01       	movw	r12, r22
     3a2:	7c 01       	movw	r14, r24
    float intercept =  7.0 - slope*(this->_neutralVoltage-1500.0)/3.0;
    //Serial.print("slope:");
    //Serial.print(slope);
    //Serial.print(",intercept:");
    //Serial.println(intercept);
    this->_phValue = slope*(voltage-1500.0)/3.0+intercept;  //y = k*x + b
     3a4:	9b 01       	movw	r18, r22
     3a6:	ac 01       	movw	r20, r24
     3a8:	c5 01       	movw	r24, r10
     3aa:	b4 01       	movw	r22, r8
     3ac:	0e 94 06 0c 	call	0x180c	; 0x180c <__mulsf3>
     3b0:	20 e0       	ldi	r18, 0x00	; 0
     3b2:	30 e0       	ldi	r19, 0x00	; 0
     3b4:	40 e4       	ldi	r20, 0x40	; 64
     3b6:	50 e4       	ldi	r21, 0x40	; 64
     3b8:	0e 94 a7 0a 	call	0x154e	; 0x154e <__divsf3>
     3bc:	9b 01       	movw	r18, r22
     3be:	ac 01       	movw	r20, r24
     3c0:	60 e0       	ldi	r22, 0x00	; 0
     3c2:	70 e0       	ldi	r23, 0x00	; 0
     3c4:	80 ee       	ldi	r24, 0xE0	; 224
     3c6:	90 e4       	ldi	r25, 0x40	; 64
     3c8:	0e 94 35 0a 	call	0x146a	; 0x146a <__subsf3>
     3cc:	4b 01       	movw	r8, r22
     3ce:	5c 01       	movw	r10, r24
     3d0:	20 e0       	ldi	r18, 0x00	; 0
     3d2:	30 e8       	ldi	r19, 0x80	; 128
     3d4:	4b eb       	ldi	r20, 0xBB	; 187
     3d6:	54 e4       	ldi	r21, 0x44	; 68
     3d8:	c3 01       	movw	r24, r6
     3da:	b2 01       	movw	r22, r4
     3dc:	0e 94 35 0a 	call	0x146a	; 0x146a <__subsf3>
     3e0:	a7 01       	movw	r20, r14
     3e2:	96 01       	movw	r18, r12
     3e4:	0e 94 06 0c 	call	0x180c	; 0x180c <__mulsf3>
     3e8:	20 e0       	ldi	r18, 0x00	; 0
     3ea:	30 e0       	ldi	r19, 0x00	; 0
     3ec:	40 e4       	ldi	r20, 0x40	; 64
     3ee:	50 e4       	ldi	r21, 0x40	; 64
     3f0:	0e 94 a7 0a 	call	0x154e	; 0x154e <__divsf3>
     3f4:	9b 01       	movw	r18, r22
     3f6:	ac 01       	movw	r20, r24
     3f8:	c5 01       	movw	r24, r10
     3fa:	b4 01       	movw	r22, r8
     3fc:	0e 94 36 0a 	call	0x146c	; 0x146c <__addsf3>
     400:	68 83       	st	Y, r22
     402:	79 83       	std	Y+1, r23	; 0x01
     404:	8a 83       	std	Y+2, r24	; 0x02
     406:	9b 83       	std	Y+3, r25	; 0x03
    return _phValue;
}
     408:	df 91       	pop	r29
     40a:	cf 91       	pop	r28
     40c:	ff 90       	pop	r15
     40e:	ef 90       	pop	r14
     410:	df 90       	pop	r13
     412:	cf 90       	pop	r12
     414:	bf 90       	pop	r11
     416:	af 90       	pop	r10
     418:	9f 90       	pop	r9
     41a:	8f 90       	pop	r8
     41c:	7f 90       	pop	r7
     41e:	6f 90       	pop	r6
     420:	5f 90       	pop	r5
     422:	4f 90       	pop	r4
     424:	08 95       	ret

00000426 <_ZN5Print5writeEPKc>:
{
	(void) pvParameters;
  
	TickType_t xLastWakeTime = xTaskGetTickCount();
	pinMode(LED_BUILTIN, OUTPUT);
	for (;;) // A Task shall never return or exit.
     426:	61 15       	cp	r22, r1
     428:	71 05       	cpc	r23, r1
     42a:	79 f0       	breq	.+30     	; 0x44a <_ZN5Print5writeEPKc+0x24>
     42c:	fb 01       	movw	r30, r22
     42e:	01 90       	ld	r0, Z+
     430:	00 20       	and	r0, r0
     432:	e9 f7       	brne	.-6      	; 0x42e <_ZN5Print5writeEPKc+0x8>
     434:	31 97       	sbiw	r30, 0x01	; 1
     436:	af 01       	movw	r20, r30
     438:	46 1b       	sub	r20, r22
     43a:	57 0b       	sbc	r21, r23
     43c:	dc 01       	movw	r26, r24
     43e:	ed 91       	ld	r30, X+
     440:	fc 91       	ld	r31, X
     442:	02 80       	ldd	r0, Z+2	; 0x02
     444:	f3 81       	ldd	r31, Z+3	; 0x03
     446:	e0 2d       	mov	r30, r0
     448:	09 94       	ijmp
     44a:	80 e0       	ldi	r24, 0x00	; 0
     44c:	90 e0       	ldi	r25, 0x00	; 0
     44e:	08 95       	ret

00000450 <_ZN14HardwareSerial5writeEi>:
     450:	dc 01       	movw	r26, r24
     452:	ed 91       	ld	r30, X+
     454:	fc 91       	ld	r31, X
     456:	01 90       	ld	r0, Z+
     458:	f0 81       	ld	r31, Z
     45a:	e0 2d       	mov	r30, r0
     45c:	09 94       	ijmp

0000045e <_Z11measureTempv>:
     45e:	cf 92       	push	r12
     460:	df 92       	push	r13
     462:	ff 92       	push	r15
     464:	0f 93       	push	r16
     466:	1f 93       	push	r17
     468:	cf 93       	push	r28
     46a:	df 93       	push	r29
     46c:	cd b7       	in	r28, 0x3d	; 61
     46e:	de b7       	in	r29, 0x3e	; 62
     470:	64 97       	sbiw	r28, 0x14	; 20
     472:	0f b6       	in	r0, 0x3f	; 63
     474:	f8 94       	cli
     476:	de bf       	out	0x3e, r29	; 62
     478:	0f be       	out	0x3f, r0	; 63
     47a:	cd bf       	out	0x3d, r28	; 61
     47c:	8c e9       	ldi	r24, 0x9C	; 156
     47e:	93 e0       	ldi	r25, 0x03	; 3
     480:	0e 94 24 09 	call	0x1248	; 0x1248 <_ZN7OneWire12reset_searchEv>
     484:	6a ef       	ldi	r22, 0xFA	; 250
     486:	70 e0       	ldi	r23, 0x00	; 0
     488:	80 e0       	ldi	r24, 0x00	; 0
     48a:	90 e0       	ldi	r25, 0x00	; 0
     48c:	0e 94 4e 11 	call	0x229c	; 0x229c <delay>
     490:	41 e0       	ldi	r20, 0x01	; 1
     492:	be 01       	movw	r22, r28
     494:	63 5f       	subi	r22, 0xF3	; 243
     496:	7f 4f       	sbci	r23, 0xFF	; 255
     498:	8c e9       	ldi	r24, 0x9C	; 156
     49a:	93 e0       	ldi	r25, 0x03	; 3
     49c:	0e 94 53 09 	call	0x12a6	; 0x12a6 <_ZN7OneWire6searchEPhb>
     4a0:	67 e0       	ldi	r22, 0x07	; 7
     4a2:	ce 01       	movw	r24, r28
     4a4:	0d 96       	adiw	r24, 0x0d	; 13
     4a6:	0e 94 da 09 	call	0x13b4	; 0x13b4 <_ZN7OneWire4crc8EPKhh>
     4aa:	9c 89       	ldd	r25, Y+20	; 0x14
     4ac:	89 17       	cp	r24, r25
     4ae:	19 f0       	breq	.+6      	; 0x4b6 <_Z11measureTempv+0x58>
     4b0:	65 e6       	ldi	r22, 0x65	; 101
     4b2:	71 e0       	ldi	r23, 0x01	; 1
     4b4:	09 c0       	rjmp	.+18     	; 0x4c8 <_Z11measureTempv+0x6a>
     4b6:	8d 85       	ldd	r24, Y+13	; 0x0d
     4b8:	82 32       	cpi	r24, 0x22	; 34
     4ba:	91 f0       	breq	.+36     	; 0x4e0 <_Z11measureTempv+0x82>
     4bc:	88 32       	cpi	r24, 0x28	; 40
     4be:	81 f0       	breq	.+32     	; 0x4e0 <_Z11measureTempv+0x82>
     4c0:	80 31       	cpi	r24, 0x10	; 16
     4c2:	59 f0       	breq	.+22     	; 0x4da <_Z11measureTempv+0x7c>
     4c4:	67 e7       	ldi	r22, 0x77	; 119
     4c6:	71 e0       	ldi	r23, 0x01	; 1
     4c8:	89 ec       	ldi	r24, 0xC9	; 201
     4ca:	93 e0       	ldi	r25, 0x03	; 3
     4cc:	0e 94 ad 0e 	call	0x1d5a	; 0x1d5a <_ZN5Print7printlnEPKc>
     4d0:	60 e0       	ldi	r22, 0x00	; 0
     4d2:	70 e0       	ldi	r23, 0x00	; 0
     4d4:	80 e8       	ldi	r24, 0x80	; 128
     4d6:	9f eb       	ldi	r25, 0xBF	; 191
     4d8:	6a c0       	rjmp	.+212    	; 0x5ae <_Z11measureTempv+0x150>
     4da:	ff 24       	eor	r15, r15
     4dc:	f3 94       	inc	r15
     4de:	01 c0       	rjmp	.+2      	; 0x4e2 <_Z11measureTempv+0x84>
     4e0:	f1 2c       	mov	r15, r1
     4e2:	8c e9       	ldi	r24, 0x9C	; 156
     4e4:	93 e0       	ldi	r25, 0x03	; 3
     4e6:	0e 94 18 08 	call	0x1030	; 0x1030 <_ZN7OneWire5resetEv>
     4ea:	be 01       	movw	r22, r28
     4ec:	63 5f       	subi	r22, 0xF3	; 243
     4ee:	7f 4f       	sbci	r23, 0xFF	; 255
     4f0:	8c e9       	ldi	r24, 0x9C	; 156
     4f2:	93 e0       	ldi	r25, 0x03	; 3
     4f4:	0e 94 05 09 	call	0x120a	; 0x120a <_ZN7OneWire6selectEPKh>
     4f8:	41 e0       	ldi	r20, 0x01	; 1
     4fa:	64 e4       	ldi	r22, 0x44	; 68
     4fc:	8c e9       	ldi	r24, 0x9C	; 156
     4fe:	93 e0       	ldi	r25, 0x03	; 3
     500:	0e 94 b5 08 	call	0x116a	; 0x116a <_ZN7OneWire5writeEhh>
     504:	68 ee       	ldi	r22, 0xE8	; 232
     506:	73 e0       	ldi	r23, 0x03	; 3
     508:	80 e0       	ldi	r24, 0x00	; 0
     50a:	90 e0       	ldi	r25, 0x00	; 0
     50c:	0e 94 4e 11 	call	0x229c	; 0x229c <delay>
     510:	8c e9       	ldi	r24, 0x9C	; 156
     512:	93 e0       	ldi	r25, 0x03	; 3
     514:	0e 94 18 08 	call	0x1030	; 0x1030 <_ZN7OneWire5resetEv>
     518:	be 01       	movw	r22, r28
     51a:	63 5f       	subi	r22, 0xF3	; 243
     51c:	7f 4f       	sbci	r23, 0xFF	; 255
     51e:	8c e9       	ldi	r24, 0x9C	; 156
     520:	93 e0       	ldi	r25, 0x03	; 3
     522:	0e 94 05 09 	call	0x120a	; 0x120a <_ZN7OneWire6selectEPKh>
     526:	40 e0       	ldi	r20, 0x00	; 0
     528:	6e eb       	ldi	r22, 0xBE	; 190
     52a:	8c e9       	ldi	r24, 0x9C	; 156
     52c:	93 e0       	ldi	r25, 0x03	; 3
     52e:	0e 94 b5 08 	call	0x116a	; 0x116a <_ZN7OneWire5writeEhh>
     532:	8e 01       	movw	r16, r28
     534:	0f 5f       	subi	r16, 0xFF	; 255
     536:	1f 4f       	sbci	r17, 0xFF	; 255
     538:	6e 01       	movw	r12, r28
     53a:	8a e0       	ldi	r24, 0x0A	; 10
     53c:	c8 0e       	add	r12, r24
     53e:	d1 1c       	adc	r13, r1
     540:	8c e9       	ldi	r24, 0x9C	; 156
     542:	93 e0       	ldi	r25, 0x03	; 3
     544:	0e 94 e9 08 	call	0x11d2	; 0x11d2 <_ZN7OneWire4readEv>
     548:	f8 01       	movw	r30, r16
     54a:	81 93       	st	Z+, r24
     54c:	8f 01       	movw	r16, r30
     54e:	ec 15       	cp	r30, r12
     550:	fd 05       	cpc	r31, r13
     552:	b1 f7       	brne	.-20     	; 0x540 <_Z11measureTempv+0xe2>
     554:	69 81       	ldd	r22, Y+1	; 0x01
     556:	7a 81       	ldd	r23, Y+2	; 0x02
     558:	ff 20       	and	r15, r15
     55a:	89 f0       	breq	.+34     	; 0x57e <_Z11measureTempv+0x120>
     55c:	83 e0       	ldi	r24, 0x03	; 3
     55e:	66 0f       	add	r22, r22
     560:	77 1f       	adc	r23, r23
     562:	8a 95       	dec	r24
     564:	e1 f7       	brne	.-8      	; 0x55e <_Z11measureTempv+0x100>
     566:	88 85       	ldd	r24, Y+8	; 0x08
     568:	80 31       	cpi	r24, 0x10	; 16
     56a:	a9 f4       	brne	.+42     	; 0x596 <_Z11measureTempv+0x138>
     56c:	2f 81       	ldd	r18, Y+7	; 0x07
     56e:	8c e0       	ldi	r24, 0x0C	; 12
     570:	90 e0       	ldi	r25, 0x00	; 0
     572:	82 1b       	sub	r24, r18
     574:	91 09       	sbc	r25, r1
     576:	60 7f       	andi	r22, 0xF0	; 240
     578:	68 0f       	add	r22, r24
     57a:	79 1f       	adc	r23, r25
     57c:	0c c0       	rjmp	.+24     	; 0x596 <_Z11measureTempv+0x138>
     57e:	8d 81       	ldd	r24, Y+5	; 0x05
     580:	80 76       	andi	r24, 0x60	; 96
     582:	11 f4       	brne	.+4      	; 0x588 <_Z11measureTempv+0x12a>
     584:	68 7f       	andi	r22, 0xF8	; 248
     586:	07 c0       	rjmp	.+14     	; 0x596 <_Z11measureTempv+0x138>
     588:	80 32       	cpi	r24, 0x20	; 32
     58a:	11 f4       	brne	.+4      	; 0x590 <_Z11measureTempv+0x132>
     58c:	6c 7f       	andi	r22, 0xFC	; 252
     58e:	03 c0       	rjmp	.+6      	; 0x596 <_Z11measureTempv+0x138>
     590:	80 34       	cpi	r24, 0x40	; 64
     592:	09 f4       	brne	.+2      	; 0x596 <_Z11measureTempv+0x138>
     594:	6e 7f       	andi	r22, 0xFE	; 254
     596:	07 2e       	mov	r0, r23
     598:	00 0c       	add	r0, r0
     59a:	88 0b       	sbc	r24, r24
     59c:	99 0b       	sbc	r25, r25
     59e:	0e 94 51 0b 	call	0x16a2	; 0x16a2 <__floatsisf>
     5a2:	20 e0       	ldi	r18, 0x00	; 0
     5a4:	30 e0       	ldi	r19, 0x00	; 0
     5a6:	40 e8       	ldi	r20, 0x80	; 128
     5a8:	5d e3       	ldi	r21, 0x3D	; 61
     5aa:	0e 94 06 0c 	call	0x180c	; 0x180c <__mulsf3>
     5ae:	64 96       	adiw	r28, 0x14	; 20
     5b0:	0f b6       	in	r0, 0x3f	; 63
     5b2:	f8 94       	cli
     5b4:	de bf       	out	0x3e, r29	; 62
     5b6:	0f be       	out	0x3f, r0	; 63
     5b8:	cd bf       	out	0x3d, r28	; 61
     5ba:	df 91       	pop	r29
     5bc:	cf 91       	pop	r28
     5be:	1f 91       	pop	r17
     5c0:	0f 91       	pop	r16
     5c2:	ff 90       	pop	r15
     5c4:	df 90       	pop	r13
     5c6:	cf 90       	pop	r12
     5c8:	08 95       	ret

000005ca <_Z9addColorsv>:
     5ca:	0f 93       	push	r16
     5cc:	1f 93       	push	r17
     5ce:	cf 93       	push	r28
     5d0:	df 93       	push	r29
     5d2:	c9 e6       	ldi	r28, 0x69	; 105
     5d4:	d3 e0       	ldi	r29, 0x03	; 3
     5d6:	18 82       	st	Y, r1
     5d8:	19 82       	std	Y+1, r1	; 0x01
     5da:	1a 82       	std	Y+2, r1	; 0x02
     5dc:	1b 82       	std	Y+3, r1	; 0x03
     5de:	1d 82       	std	Y+5, r1	; 0x05
     5e0:	1c 82       	std	Y+4, r1	; 0x04
     5e2:	1f 82       	std	Y+7, r1	; 0x07
     5e4:	1e 82       	std	Y+6, r1	; 0x06
     5e6:	19 86       	std	Y+9, r1	; 0x09
     5e8:	18 86       	std	Y+8, r1	; 0x08
     5ea:	a3 e2       	ldi	r26, 0x23	; 35
     5ec:	b3 e0       	ldi	r27, 0x03	; 3
     5ee:	1d 92       	st	X+, r1
     5f0:	1d 92       	st	X+, r1
     5f2:	1d 92       	st	X+, r1
     5f4:	1c 92       	st	X, r1
     5f6:	13 97       	sbiw	r26, 0x03	; 3
     5f8:	2f ef       	ldi	r18, 0xFF	; 255
     5fa:	30 e0       	ldi	r19, 0x00	; 0
     5fc:	15 96       	adiw	r26, 0x05	; 5
     5fe:	3c 93       	st	X, r19
     600:	2e 93       	st	-X, r18
     602:	14 97       	sbiw	r26, 0x04	; 4
     604:	8f e5       	ldi	r24, 0x5F	; 95
     606:	90 e0       	ldi	r25, 0x00	; 0
     608:	17 96       	adiw	r26, 0x07	; 7
     60a:	9c 93       	st	X, r25
     60c:	8e 93       	st	-X, r24
     60e:	16 97       	sbiw	r26, 0x06	; 6
     610:	19 96       	adiw	r26, 0x09	; 9
     612:	9c 93       	st	X, r25
     614:	8e 93       	st	-X, r24
     616:	18 97       	sbiw	r26, 0x08	; 8
     618:	ed ed       	ldi	r30, 0xDD	; 221
     61a:	f2 e0       	ldi	r31, 0x02	; 2
     61c:	10 82       	st	Z, r1
     61e:	11 82       	std	Z+1, r1	; 0x01
     620:	12 82       	std	Z+2, r1	; 0x02
     622:	13 82       	std	Z+3, r1	; 0x03
     624:	35 83       	std	Z+5, r19	; 0x05
     626:	24 83       	std	Z+4, r18	; 0x04
     628:	97 83       	std	Z+7, r25	; 0x07
     62a:	86 83       	std	Z+6, r24	; 0x06
     62c:	91 87       	std	Z+9, r25	; 0x09
     62e:	80 87       	std	Z+8, r24	; 0x08
     630:	40 e0       	ldi	r20, 0x00	; 0
     632:	50 e0       	ldi	r21, 0x00	; 0
     634:	60 e8       	ldi	r22, 0x80	; 128
     636:	7e e3       	ldi	r23, 0x3E	; 62
     638:	4a 87       	std	Y+10, r20	; 0x0a
     63a:	5b 87       	std	Y+11, r21	; 0x0b
     63c:	6c 87       	std	Y+12, r22	; 0x0c
     63e:	7d 87       	std	Y+13, r23	; 0x0d
     640:	1f 86       	std	Y+15, r1	; 0x0f
     642:	1e 86       	std	Y+14, r1	; 0x0e
     644:	19 8a       	std	Y+17, r1	; 0x11
     646:	18 8a       	std	Y+16, r1	; 0x10
     648:	1b 8a       	std	Y+19, r1	; 0x13
     64a:	1a 8a       	std	Y+18, r1	; 0x12
     64c:	4a e9       	ldi	r20, 0x9A	; 154
     64e:	59 e9       	ldi	r21, 0x99	; 153
     650:	69 e1       	ldi	r22, 0x19	; 25
     652:	7e e3       	ldi	r23, 0x3E	; 62
     654:	1a 96       	adiw	r26, 0x0a	; 10
     656:	4d 93       	st	X+, r20
     658:	5d 93       	st	X+, r21
     65a:	6d 93       	st	X+, r22
     65c:	7c 93       	st	X, r23
     65e:	1d 97       	sbiw	r26, 0x0d	; 13
     660:	1f 96       	adiw	r26, 0x0f	; 15
     662:	1c 92       	st	X, r1
     664:	1e 92       	st	-X, r1
     666:	1e 97       	sbiw	r26, 0x0e	; 14
     668:	51 96       	adiw	r26, 0x11	; 17
     66a:	1c 92       	st	X, r1
     66c:	1e 92       	st	-X, r1
     66e:	50 97       	sbiw	r26, 0x10	; 16
     670:	53 96       	adiw	r26, 0x13	; 19
     672:	1c 92       	st	X, r1
     674:	1e 92       	st	-X, r1
     676:	52 97       	sbiw	r26, 0x12	; 18
     678:	40 e0       	ldi	r20, 0x00	; 0
     67a:	50 e0       	ldi	r21, 0x00	; 0
     67c:	60 e0       	ldi	r22, 0x00	; 0
     67e:	7f e3       	ldi	r23, 0x3F	; 63
     680:	42 87       	std	Z+10, r20	; 0x0a
     682:	53 87       	std	Z+11, r21	; 0x0b
     684:	64 87       	std	Z+12, r22	; 0x0c
     686:	75 87       	std	Z+13, r23	; 0x0d
     688:	17 86       	std	Z+15, r1	; 0x0f
     68a:	16 86       	std	Z+14, r1	; 0x0e
     68c:	11 8a       	std	Z+17, r1	; 0x11
     68e:	10 8a       	std	Z+16, r1	; 0x10
     690:	13 8a       	std	Z+19, r1	; 0x13
     692:	12 8a       	std	Z+18, r1	; 0x12
     694:	4c 8b       	std	Y+20, r20	; 0x14
     696:	5d 8b       	std	Y+21, r21	; 0x15
     698:	6e 8b       	std	Y+22, r22	; 0x16
     69a:	7f 8b       	std	Y+23, r23	; 0x17
     69c:	19 8e       	std	Y+25, r1	; 0x19
     69e:	18 8e       	std	Y+24, r1	; 0x18
     6a0:	1b 8e       	std	Y+27, r1	; 0x1b
     6a2:	1a 8e       	std	Y+26, r1	; 0x1a
     6a4:	1d 8e       	std	Y+29, r1	; 0x1d
     6a6:	1c 8e       	std	Y+28, r1	; 0x1c
     6a8:	4a e9       	ldi	r20, 0x9A	; 154
     6aa:	59 e9       	ldi	r21, 0x99	; 153
     6ac:	69 e9       	ldi	r22, 0x99	; 153
     6ae:	7e e3       	ldi	r23, 0x3E	; 62
     6b0:	54 96       	adiw	r26, 0x14	; 20
     6b2:	4d 93       	st	X+, r20
     6b4:	5d 93       	st	X+, r21
     6b6:	6d 93       	st	X+, r22
     6b8:	7c 93       	st	X, r23
     6ba:	57 97       	sbiw	r26, 0x17	; 23
     6bc:	59 96       	adiw	r26, 0x19	; 25
     6be:	1c 92       	st	X, r1
     6c0:	1e 92       	st	-X, r1
     6c2:	58 97       	sbiw	r26, 0x18	; 24
     6c4:	5b 96       	adiw	r26, 0x1b	; 27
     6c6:	1c 92       	st	X, r1
     6c8:	1e 92       	st	-X, r1
     6ca:	5a 97       	sbiw	r26, 0x1a	; 26
     6cc:	5d 96       	adiw	r26, 0x1d	; 29
     6ce:	1c 92       	st	X, r1
     6d0:	1e 92       	st	-X, r1
     6d2:	5c 97       	sbiw	r26, 0x1c	; 28
     6d4:	40 e0       	ldi	r20, 0x00	; 0
     6d6:	50 e0       	ldi	r21, 0x00	; 0
     6d8:	60 e0       	ldi	r22, 0x00	; 0
     6da:	70 e4       	ldi	r23, 0x40	; 64
     6dc:	44 8b       	std	Z+20, r20	; 0x14
     6de:	55 8b       	std	Z+21, r21	; 0x15
     6e0:	66 8b       	std	Z+22, r22	; 0x16
     6e2:	77 8b       	std	Z+23, r23	; 0x17
     6e4:	11 8e       	std	Z+25, r1	; 0x19
     6e6:	10 8e       	std	Z+24, r1	; 0x18
     6e8:	13 8e       	std	Z+27, r1	; 0x1b
     6ea:	12 8e       	std	Z+26, r1	; 0x1a
     6ec:	15 8e       	std	Z+29, r1	; 0x1d
     6ee:	14 8e       	std	Z+28, r1	; 0x1c
     6f0:	00 e0       	ldi	r16, 0x00	; 0
     6f2:	10 e0       	ldi	r17, 0x00	; 0
     6f4:	20 e4       	ldi	r18, 0x40	; 64
     6f6:	30 e4       	ldi	r19, 0x40	; 64
     6f8:	0e 8f       	std	Y+30, r16	; 0x1e
     6fa:	1f 8f       	std	Y+31, r17	; 0x1f
     6fc:	28 a3       	std	Y+32, r18	; 0x20
     6fe:	39 a3       	std	Y+33, r19	; 0x21
     700:	1b a2       	std	Y+35, r1	; 0x23
     702:	1a a2       	std	Y+34, r1	; 0x22
     704:	1d a2       	std	Y+37, r1	; 0x25
     706:	1c a2       	std	Y+36, r1	; 0x24
     708:	1f a2       	std	Y+39, r1	; 0x27
     70a:	1e a2       	std	Y+38, r1	; 0x26
     70c:	40 e0       	ldi	r20, 0x00	; 0
     70e:	50 e0       	ldi	r21, 0x00	; 0
     710:	60 e8       	ldi	r22, 0x80	; 128
     712:	7f e3       	ldi	r23, 0x3F	; 63
     714:	5e 96       	adiw	r26, 0x1e	; 30
     716:	4d 93       	st	X+, r20
     718:	5d 93       	st	X+, r21
     71a:	6d 93       	st	X+, r22
     71c:	7c 93       	st	X, r23
     71e:	91 97       	sbiw	r26, 0x21	; 33
     720:	93 96       	adiw	r26, 0x23	; 35
     722:	1c 92       	st	X, r1
     724:	1e 92       	st	-X, r1
     726:	92 97       	sbiw	r26, 0x22	; 34
     728:	95 96       	adiw	r26, 0x25	; 37
     72a:	1c 92       	st	X, r1
     72c:	1e 92       	st	-X, r1
     72e:	94 97       	sbiw	r26, 0x24	; 36
     730:	97 96       	adiw	r26, 0x27	; 39
     732:	1c 92       	st	X, r1
     734:	1e 92       	st	-X, r1
     736:	96 97       	sbiw	r26, 0x26	; 38
     738:	40 e0       	ldi	r20, 0x00	; 0
     73a:	50 e0       	ldi	r21, 0x00	; 0
     73c:	60 ea       	ldi	r22, 0xA0	; 160
     73e:	70 e4       	ldi	r23, 0x40	; 64
     740:	46 8f       	std	Z+30, r20	; 0x1e
     742:	57 8f       	std	Z+31, r21	; 0x1f
     744:	60 a3       	std	Z+32, r22	; 0x20
     746:	71 a3       	std	Z+33, r23	; 0x21
     748:	13 a2       	std	Z+35, r1	; 0x23
     74a:	12 a2       	std	Z+34, r1	; 0x22
     74c:	15 a2       	std	Z+37, r1	; 0x25
     74e:	14 a2       	std	Z+36, r1	; 0x24
     750:	17 a2       	std	Z+39, r1	; 0x27
     752:	16 a2       	std	Z+38, r1	; 0x26
     754:	40 e0       	ldi	r20, 0x00	; 0
     756:	50 e0       	ldi	r21, 0x00	; 0
     758:	60 ec       	ldi	r22, 0xC0	; 192
     75a:	70 e4       	ldi	r23, 0x40	; 64
     75c:	48 a7       	std	Y+40, r20	; 0x28
     75e:	59 a7       	std	Y+41, r21	; 0x29
     760:	6a a7       	std	Y+42, r22	; 0x2a
     762:	7b a7       	std	Y+43, r23	; 0x2b
     764:	1d a6       	std	Y+45, r1	; 0x2d
     766:	1c a6       	std	Y+44, r1	; 0x2c
     768:	1f a6       	std	Y+47, r1	; 0x2f
     76a:	1e a6       	std	Y+46, r1	; 0x2e
     76c:	19 aa       	std	Y+49, r1	; 0x31
     76e:	18 aa       	std	Y+48, r1	; 0x30
     770:	40 e0       	ldi	r20, 0x00	; 0
     772:	50 e0       	ldi	r21, 0x00	; 0
     774:	60 ec       	ldi	r22, 0xC0	; 192
     776:	7f e3       	ldi	r23, 0x3F	; 63
     778:	98 96       	adiw	r26, 0x28	; 40
     77a:	4d 93       	st	X+, r20
     77c:	5d 93       	st	X+, r21
     77e:	6d 93       	st	X+, r22
     780:	7c 93       	st	X, r23
     782:	9b 97       	sbiw	r26, 0x2b	; 43
     784:	9d 96       	adiw	r26, 0x2d	; 45
     786:	1c 92       	st	X, r1
     788:	1e 92       	st	-X, r1
     78a:	9c 97       	sbiw	r26, 0x2c	; 44
     78c:	9f 96       	adiw	r26, 0x2f	; 47
     78e:	1c 92       	st	X, r1
     790:	1e 92       	st	-X, r1
     792:	9e 97       	sbiw	r26, 0x2e	; 46
     794:	d1 96       	adiw	r26, 0x31	; 49
     796:	1c 92       	st	X, r1
     798:	1e 92       	st	-X, r1
     79a:	d0 97       	sbiw	r26, 0x30	; 48
     79c:	40 e0       	ldi	r20, 0x00	; 0
     79e:	50 e0       	ldi	r21, 0x00	; 0
     7a0:	60 e2       	ldi	r22, 0x20	; 32
     7a2:	71 e4       	ldi	r23, 0x41	; 65
     7a4:	40 a7       	std	Z+40, r20	; 0x28
     7a6:	51 a7       	std	Z+41, r21	; 0x29
     7a8:	62 a7       	std	Z+42, r22	; 0x2a
     7aa:	73 a7       	std	Z+43, r23	; 0x2b
     7ac:	15 a6       	std	Z+45, r1	; 0x2d
     7ae:	14 a6       	std	Z+44, r1	; 0x2c
     7b0:	17 a6       	std	Z+47, r1	; 0x2f
     7b2:	16 a6       	std	Z+46, r1	; 0x2e
     7b4:	11 aa       	std	Z+49, r1	; 0x31
     7b6:	10 aa       	std	Z+48, r1	; 0x30
     7b8:	d2 96       	adiw	r26, 0x32	; 50
     7ba:	0d 93       	st	X+, r16
     7bc:	1d 93       	st	X+, r17
     7be:	2d 93       	st	X+, r18
     7c0:	3c 93       	st	X, r19
     7c2:	d5 97       	sbiw	r26, 0x35	; 53
     7c4:	d7 96       	adiw	r26, 0x37	; 55
     7c6:	1c 92       	st	X, r1
     7c8:	1e 92       	st	-X, r1
     7ca:	d6 97       	sbiw	r26, 0x36	; 54
     7cc:	d9 96       	adiw	r26, 0x39	; 57
     7ce:	1c 92       	st	X, r1
     7d0:	1e 92       	st	-X, r1
     7d2:	d8 97       	sbiw	r26, 0x38	; 56
     7d4:	db 96       	adiw	r26, 0x3b	; 59
     7d6:	1c 92       	st	X, r1
     7d8:	1e 92       	st	-X, r1
     7da:	da 97       	sbiw	r26, 0x3a	; 58
     7dc:	00 e0       	ldi	r16, 0x00	; 0
     7de:	10 e0       	ldi	r17, 0x00	; 0
     7e0:	20 ea       	ldi	r18, 0xA0	; 160
     7e2:	31 e4       	ldi	r19, 0x41	; 65
     7e4:	02 ab       	std	Z+50, r16	; 0x32
     7e6:	13 ab       	std	Z+51, r17	; 0x33
     7e8:	24 ab       	std	Z+52, r18	; 0x34
     7ea:	35 ab       	std	Z+53, r19	; 0x35
     7ec:	17 aa       	std	Z+55, r1	; 0x37
     7ee:	16 aa       	std	Z+54, r1	; 0x36
     7f0:	11 ae       	std	Z+57, r1	; 0x39
     7f2:	10 ae       	std	Z+56, r1	; 0x38
     7f4:	13 ae       	std	Z+59, r1	; 0x3b
     7f6:	12 ae       	std	Z+58, r1	; 0x3a
     7f8:	dc 96       	adiw	r26, 0x3c	; 60
     7fa:	4d 93       	st	X+, r20
     7fc:	5d 93       	st	X+, r21
     7fe:	6d 93       	st	X+, r22
     800:	7c 93       	st	X, r23
     802:	df 97       	sbiw	r26, 0x3f	; 63
     804:	10 92 64 03 	sts	0x0364, r1	; 0x800364 <Nitrite+0x41>
     808:	10 92 63 03 	sts	0x0363, r1	; 0x800363 <Nitrite+0x40>
     80c:	10 92 66 03 	sts	0x0366, r1	; 0x800366 <Nitrite+0x43>
     810:	10 92 65 03 	sts	0x0365, r1	; 0x800365 <Nitrite+0x42>
     814:	10 92 68 03 	sts	0x0368, r1	; 0x800368 <Nitrite+0x45>
     818:	10 92 67 03 	sts	0x0367, r1	; 0x800367 <Nitrite+0x44>
     81c:	80 e0       	ldi	r24, 0x00	; 0
     81e:	90 e0       	ldi	r25, 0x00	; 0
     820:	a8 e4       	ldi	r26, 0x48	; 72
     822:	b2 e4       	ldi	r27, 0x42	; 66
     824:	84 af       	std	Z+60, r24	; 0x3c
     826:	95 af       	std	Z+61, r25	; 0x3d
     828:	a6 af       	std	Z+62, r26	; 0x3e
     82a:	b7 af       	std	Z+63, r27	; 0x3f
     82c:	10 92 1e 03 	sts	0x031E, r1	; 0x80031e <Nitrate+0x41>
     830:	10 92 1d 03 	sts	0x031D, r1	; 0x80031d <Nitrate+0x40>
     834:	10 92 20 03 	sts	0x0320, r1	; 0x800320 <Nitrate+0x43>
     838:	10 92 1f 03 	sts	0x031F, r1	; 0x80031f <Nitrate+0x42>
     83c:	10 92 22 03 	sts	0x0322, r1	; 0x800322 <Nitrate+0x45>
     840:	10 92 21 03 	sts	0x0321, r1	; 0x800321 <Nitrate+0x44>
     844:	df 91       	pop	r29
     846:	cf 91       	pop	r28
     848:	1f 91       	pop	r17
     84a:	0f 91       	pop	r16
     84c:	08 95       	ret

0000084e <_Z9SameColorv>:
     84e:	6e e9       	ldi	r22, 0x9E	; 158
     850:	71 e0       	ldi	r23, 0x01	; 1
     852:	89 ec       	ldi	r24, 0xC9	; 201
     854:	93 e0       	ldi	r25, 0x03	; 3
     856:	0e 94 a0 0e 	call	0x1d40	; 0x1d40 <_ZN5Print5printEPKc>
     85a:	60 91 d4 02 	lds	r22, 0x02D4	; 0x8002d4 <c+0x4>
     85e:	70 91 d5 02 	lds	r23, 0x02D5	; 0x8002d5 <c+0x5>
     862:	4a e0       	ldi	r20, 0x0A	; 10
     864:	50 e0       	ldi	r21, 0x00	; 0
     866:	89 ec       	ldi	r24, 0xC9	; 201
     868:	93 e0       	ldi	r25, 0x03	; 3
     86a:	0e 94 6a 0f 	call	0x1ed4	; 0x1ed4 <_ZN5Print5printEii>
     86e:	60 ea       	ldi	r22, 0xA0	; 160
     870:	71 e0       	ldi	r23, 0x01	; 1
     872:	89 ec       	ldi	r24, 0xC9	; 201
     874:	93 e0       	ldi	r25, 0x03	; 3
     876:	0e 94 a0 0e 	call	0x1d40	; 0x1d40 <_ZN5Print5printEPKc>
     87a:	60 91 d6 02 	lds	r22, 0x02D6	; 0x8002d6 <c+0x6>
     87e:	70 91 d7 02 	lds	r23, 0x02D7	; 0x8002d7 <c+0x7>
     882:	4a e0       	ldi	r20, 0x0A	; 10
     884:	50 e0       	ldi	r21, 0x00	; 0
     886:	89 ec       	ldi	r24, 0xC9	; 201
     888:	93 e0       	ldi	r25, 0x03	; 3
     88a:	0e 94 6a 0f 	call	0x1ed4	; 0x1ed4 <_ZN5Print5printEii>
     88e:	60 ea       	ldi	r22, 0xA0	; 160
     890:	71 e0       	ldi	r23, 0x01	; 1
     892:	89 ec       	ldi	r24, 0xC9	; 201
     894:	93 e0       	ldi	r25, 0x03	; 3
     896:	0e 94 a0 0e 	call	0x1d40	; 0x1d40 <_ZN5Print5printEPKc>
     89a:	60 91 d8 02 	lds	r22, 0x02D8	; 0x8002d8 <c+0x8>
     89e:	70 91 d9 02 	lds	r23, 0x02D9	; 0x8002d9 <c+0x9>
     8a2:	4a e0       	ldi	r20, 0x0A	; 10
     8a4:	50 e0       	ldi	r21, 0x00	; 0
     8a6:	89 ec       	ldi	r24, 0xC9	; 201
     8a8:	93 e0       	ldi	r25, 0x03	; 3
     8aa:	0e 94 6a 0f 	call	0x1ed4	; 0x1ed4 <_ZN5Print5printEii>
     8ae:	62 ea       	ldi	r22, 0xA2	; 162
     8b0:	71 e0       	ldi	r23, 0x01	; 1
     8b2:	89 ec       	ldi	r24, 0xC9	; 201
     8b4:	93 e0       	ldi	r25, 0x03	; 3
     8b6:	0e 94 a0 0e 	call	0x1d40	; 0x1d40 <_ZN5Print5printEPKc>
     8ba:	4a e0       	ldi	r20, 0x0A	; 10
     8bc:	50 e0       	ldi	r21, 0x00	; 0
     8be:	60 91 ce 02 	lds	r22, 0x02CE	; 0x8002ce <redScanned>
     8c2:	89 ec       	ldi	r24, 0xC9	; 201
     8c4:	93 e0       	ldi	r25, 0x03	; 3
     8c6:	0e 94 15 0f 	call	0x1e2a	; 0x1e2a <_ZN5Print5printEhi>
     8ca:	60 ea       	ldi	r22, 0xA0	; 160
     8cc:	71 e0       	ldi	r23, 0x01	; 1
     8ce:	89 ec       	ldi	r24, 0xC9	; 201
     8d0:	93 e0       	ldi	r25, 0x03	; 3
     8d2:	0e 94 a0 0e 	call	0x1d40	; 0x1d40 <_ZN5Print5printEPKc>
     8d6:	4a e0       	ldi	r20, 0x0A	; 10
     8d8:	50 e0       	ldi	r21, 0x00	; 0
     8da:	60 91 cf 02 	lds	r22, 0x02CF	; 0x8002cf <greenScanned>
     8de:	89 ec       	ldi	r24, 0xC9	; 201
     8e0:	93 e0       	ldi	r25, 0x03	; 3
     8e2:	0e 94 15 0f 	call	0x1e2a	; 0x1e2a <_ZN5Print5printEhi>
     8e6:	60 ea       	ldi	r22, 0xA0	; 160
     8e8:	71 e0       	ldi	r23, 0x01	; 1
     8ea:	89 ec       	ldi	r24, 0xC9	; 201
     8ec:	93 e0       	ldi	r25, 0x03	; 3
     8ee:	0e 94 a0 0e 	call	0x1d40	; 0x1d40 <_ZN5Print5printEPKc>
     8f2:	4a e0       	ldi	r20, 0x0A	; 10
     8f4:	50 e0       	ldi	r21, 0x00	; 0
     8f6:	60 91 cd 02 	lds	r22, 0x02CD	; 0x8002cd <blueScanned>
     8fa:	89 ec       	ldi	r24, 0xC9	; 201
     8fc:	93 e0       	ldi	r25, 0x03	; 3
     8fe:	0e 94 15 0f 	call	0x1e2a	; 0x1e2a <_ZN5Print5printEhi>
     902:	20 91 ce 02 	lds	r18, 0x02CE	; 0x8002ce <redScanned>
     906:	30 e0       	ldi	r19, 0x00	; 0
     908:	80 91 d4 02 	lds	r24, 0x02D4	; 0x8002d4 <c+0x4>
     90c:	90 91 d5 02 	lds	r25, 0x02D5	; 0x8002d5 <c+0x5>
     910:	ac 01       	movw	r20, r24
     912:	45 50       	subi	r20, 0x05	; 5
     914:	51 09       	sbc	r21, r1
     916:	24 17       	cp	r18, r20
     918:	35 07       	cpc	r19, r21
     91a:	74 f1       	brlt	.+92     	; 0x978 <__stack+0x79>
     91c:	05 96       	adiw	r24, 0x05	; 5
     91e:	82 17       	cp	r24, r18
     920:	93 07       	cpc	r25, r19
     922:	54 f1       	brlt	.+84     	; 0x978 <__stack+0x79>
     924:	20 91 cf 02 	lds	r18, 0x02CF	; 0x8002cf <greenScanned>
     928:	30 e0       	ldi	r19, 0x00	; 0
     92a:	80 91 d6 02 	lds	r24, 0x02D6	; 0x8002d6 <c+0x6>
     92e:	90 91 d7 02 	lds	r25, 0x02D7	; 0x8002d7 <c+0x7>
     932:	ac 01       	movw	r20, r24
     934:	45 50       	subi	r20, 0x05	; 5
     936:	51 09       	sbc	r21, r1
     938:	24 17       	cp	r18, r20
     93a:	35 07       	cpc	r19, r21
     93c:	ec f0       	brlt	.+58     	; 0x978 <__stack+0x79>
     93e:	05 96       	adiw	r24, 0x05	; 5
     940:	82 17       	cp	r24, r18
     942:	93 07       	cpc	r25, r19
     944:	cc f0       	brlt	.+50     	; 0x978 <__stack+0x79>
     946:	20 91 cd 02 	lds	r18, 0x02CD	; 0x8002cd <blueScanned>
     94a:	30 e0       	ldi	r19, 0x00	; 0
     94c:	80 91 d8 02 	lds	r24, 0x02D8	; 0x8002d8 <c+0x8>
     950:	90 91 d9 02 	lds	r25, 0x02D9	; 0x8002d9 <c+0x9>
     954:	ac 01       	movw	r20, r24
     956:	45 50       	subi	r20, 0x05	; 5
     958:	51 09       	sbc	r21, r1
     95a:	24 17       	cp	r18, r20
     95c:	35 07       	cpc	r19, r21
     95e:	64 f0       	brlt	.+24     	; 0x978 <__stack+0x79>
     960:	05 96       	adiw	r24, 0x05	; 5
     962:	82 17       	cp	r24, r18
     964:	93 07       	cpc	r25, r19
     966:	44 f0       	brlt	.+16     	; 0x978 <__stack+0x79>
     968:	6c e7       	ldi	r22, 0x7C	; 124
     96a:	70 e0       	ldi	r23, 0x00	; 0
     96c:	89 ec       	ldi	r24, 0xC9	; 201
     96e:	93 e0       	ldi	r25, 0x03	; 3
     970:	0e 94 7c 0e 	call	0x1cf8	; 0x1cf8 <_ZN5Print5printEPK19__FlashStringHelper>
     974:	81 e0       	ldi	r24, 0x01	; 1
     976:	08 95       	ret
     978:	80 e0       	ldi	r24, 0x00	; 0
     97a:	08 95       	ret

0000097c <_Z9FindMatchv>:
     97c:	0f 93       	push	r16
     97e:	1f 93       	push	r17
     980:	cf 93       	push	r28
     982:	df 93       	push	r29
     984:	80 91 9b 03 	lds	r24, 0x039B	; 0x80039b <typeToRead>
     988:	81 30       	cpi	r24, 0x01	; 1
     98a:	09 f4       	brne	.+2      	; 0x98e <_Z9FindMatchv+0x12>
     98c:	48 c0       	rjmp	.+144    	; 0xa1e <_Z9FindMatchv+0xa2>
     98e:	40 f0       	brcs	.+16     	; 0x9a0 <_Z9FindMatchv+0x24>
     990:	82 30       	cpi	r24, 0x02	; 2
     992:	09 f0       	breq	.+2      	; 0x996 <_Z9FindMatchv+0x1a>
     994:	6e c0       	rjmp	.+220    	; 0xa72 <_Z9FindMatchv+0xf6>
     996:	03 e2       	ldi	r16, 0x23	; 35
     998:	13 e0       	ldi	r17, 0x03	; 3
     99a:	c6 e0       	ldi	r28, 0x06	; 6
     99c:	d0 e0       	ldi	r29, 0x00	; 0
     99e:	29 c0       	rjmp	.+82     	; 0x9f2 <_Z9FindMatchv+0x76>
     9a0:	09 e6       	ldi	r16, 0x69	; 105
     9a2:	13 e0       	ldi	r17, 0x03	; 3
     9a4:	c4 e0       	ldi	r28, 0x04	; 4
     9a6:	d0 e0       	ldi	r29, 0x00	; 0
     9a8:	8a e0       	ldi	r24, 0x0A	; 10
     9aa:	f8 01       	movw	r30, r16
     9ac:	b8 96       	adiw	r30, 0x28	; 40
     9ae:	a0 ed       	ldi	r26, 0xD0	; 208
     9b0:	b2 e0       	ldi	r27, 0x02	; 2
     9b2:	01 90       	ld	r0, Z+
     9b4:	0d 92       	st	X+, r0
     9b6:	8a 95       	dec	r24
     9b8:	e1 f7       	brne	.-8      	; 0x9b2 <_Z9FindMatchv+0x36>
     9ba:	0e 94 27 04 	call	0x84e	; 0x84e <_Z9SameColorv>
     9be:	88 23       	and	r24, r24
     9c0:	49 f0       	breq	.+18     	; 0x9d4 <_Z9FindMatchv+0x58>
     9c2:	8a e0       	ldi	r24, 0x0A	; 10
     9c4:	8c 9f       	mul	r24, r28
     9c6:	f0 01       	movw	r30, r0
     9c8:	8d 9f       	mul	r24, r29
     9ca:	f0 0d       	add	r31, r0
     9cc:	11 24       	eor	r1, r1
     9ce:	e7 59       	subi	r30, 0x97	; 151
     9d0:	fc 4f       	sbci	r31, 0xFC	; 252
     9d2:	3e c0       	rjmp	.+124    	; 0xa50 <_Z9FindMatchv+0xd4>
     9d4:	21 97       	sbiw	r28, 0x01	; 1
     9d6:	0a 50       	subi	r16, 0x0A	; 10
     9d8:	11 09       	sbc	r17, r1
     9da:	cf 3f       	cpi	r28, 0xFF	; 255
     9dc:	8f ef       	ldi	r24, 0xFF	; 255
     9de:	d8 07       	cpc	r29, r24
     9e0:	19 f7       	brne	.-58     	; 0x9a8 <_Z9FindMatchv+0x2c>
     9e2:	42 c0       	rjmp	.+132    	; 0xa68 <_Z9FindMatchv+0xec>
     9e4:	21 97       	sbiw	r28, 0x01	; 1
     9e6:	0a 50       	subi	r16, 0x0A	; 10
     9e8:	11 09       	sbc	r17, r1
     9ea:	cf 3f       	cpi	r28, 0xFF	; 255
     9ec:	8f ef       	ldi	r24, 0xFF	; 255
     9ee:	d8 07       	cpc	r29, r24
     9f0:	d9 f1       	breq	.+118    	; 0xa68 <_Z9FindMatchv+0xec>
     9f2:	8a e0       	ldi	r24, 0x0A	; 10
     9f4:	f8 01       	movw	r30, r16
     9f6:	fc 96       	adiw	r30, 0x3c	; 60
     9f8:	a0 ed       	ldi	r26, 0xD0	; 208
     9fa:	b2 e0       	ldi	r27, 0x02	; 2
     9fc:	01 90       	ld	r0, Z+
     9fe:	0d 92       	st	X+, r0
     a00:	8a 95       	dec	r24
     a02:	e1 f7       	brne	.-8      	; 0x9fc <_Z9FindMatchv+0x80>
     a04:	0e 94 27 04 	call	0x84e	; 0x84e <_Z9SameColorv>
     a08:	88 23       	and	r24, r24
     a0a:	61 f3       	breq	.-40     	; 0x9e4 <_Z9FindMatchv+0x68>
     a0c:	8a e0       	ldi	r24, 0x0A	; 10
     a0e:	8c 9f       	mul	r24, r28
     a10:	f0 01       	movw	r30, r0
     a12:	8d 9f       	mul	r24, r29
     a14:	f0 0d       	add	r31, r0
     a16:	11 24       	eor	r1, r1
     a18:	ed 5d       	subi	r30, 0xDD	; 221
     a1a:	fc 4f       	sbci	r31, 0xFC	; 252
     a1c:	19 c0       	rjmp	.+50     	; 0xa50 <_Z9FindMatchv+0xd4>
     a1e:	0d ed       	ldi	r16, 0xDD	; 221
     a20:	12 e0       	ldi	r17, 0x02	; 2
     a22:	c6 e0       	ldi	r28, 0x06	; 6
     a24:	d0 e0       	ldi	r29, 0x00	; 0
     a26:	8a e0       	ldi	r24, 0x0A	; 10
     a28:	f8 01       	movw	r30, r16
     a2a:	fc 96       	adiw	r30, 0x3c	; 60
     a2c:	a0 ed       	ldi	r26, 0xD0	; 208
     a2e:	b2 e0       	ldi	r27, 0x02	; 2
     a30:	01 90       	ld	r0, Z+
     a32:	0d 92       	st	X+, r0
     a34:	8a 95       	dec	r24
     a36:	e1 f7       	brne	.-8      	; 0xa30 <_Z9FindMatchv+0xb4>
     a38:	0e 94 27 04 	call	0x84e	; 0x84e <_Z9SameColorv>
     a3c:	88 23       	and	r24, r24
     a3e:	69 f0       	breq	.+26     	; 0xa5a <_Z9FindMatchv+0xde>
     a40:	8a e0       	ldi	r24, 0x0A	; 10
     a42:	8c 9f       	mul	r24, r28
     a44:	f0 01       	movw	r30, r0
     a46:	8d 9f       	mul	r24, r29
     a48:	f0 0d       	add	r31, r0
     a4a:	11 24       	eor	r1, r1
     a4c:	e3 52       	subi	r30, 0x23	; 35
     a4e:	fd 4f       	sbci	r31, 0xFD	; 253
     a50:	30 81       	ld	r19, Z
     a52:	21 81       	ldd	r18, Z+1	; 0x01
     a54:	92 81       	ldd	r25, Z+2	; 0x02
     a56:	83 81       	ldd	r24, Z+3	; 0x03
     a58:	0b c0       	rjmp	.+22     	; 0xa70 <_Z9FindMatchv+0xf4>
     a5a:	21 97       	sbiw	r28, 0x01	; 1
     a5c:	0a 50       	subi	r16, 0x0A	; 10
     a5e:	11 09       	sbc	r17, r1
     a60:	cf 3f       	cpi	r28, 0xFF	; 255
     a62:	8f ef       	ldi	r24, 0xFF	; 255
     a64:	d8 07       	cpc	r29, r24
     a66:	f9 f6       	brne	.-66     	; 0xa26 <_Z9FindMatchv+0xaa>
     a68:	30 e0       	ldi	r19, 0x00	; 0
     a6a:	20 e0       	ldi	r18, 0x00	; 0
     a6c:	90 e8       	ldi	r25, 0x80	; 128
     a6e:	8f eb       	ldi	r24, 0xBF	; 191
     a70:	ac 01       	movw	r20, r24
     a72:	63 2f       	mov	r22, r19
     a74:	72 2f       	mov	r23, r18
     a76:	85 2f       	mov	r24, r21
     a78:	94 2f       	mov	r25, r20
     a7a:	df 91       	pop	r29
     a7c:	cf 91       	pop	r28
     a7e:	1f 91       	pop	r17
     a80:	0f 91       	pop	r16
     a82:	08 95       	ret

00000a84 <_Z9ScanColorv>:
     a84:	8e e9       	ldi	r24, 0x9E	; 158
     a86:	92 e0       	ldi	r25, 0x02	; 2
     a88:	0e 94 5e 1e 	call	0x3cbc	; 0x3cbc <_ZN9MD_TCS2304readEv>
     a8c:	8e e9       	ldi	r24, 0x9E	; 158
     a8e:	92 e0       	ldi	r25, 0x02	; 2
     a90:	0e 94 68 1e 	call	0x3cd0	; 0x3cd0 <_ZN9MD_TCS2309availableEv>
     a94:	88 23       	and	r24, r24
     a96:	d1 f3       	breq	.-12     	; 0xa8c <_Z9ScanColorv+0x8>
     a98:	6a ed       	ldi	r22, 0xDA	; 218
     a9a:	72 e0       	ldi	r23, 0x02	; 2
     a9c:	8e e9       	ldi	r24, 0x9E	; 158
     a9e:	92 e0       	ldi	r25, 0x02	; 2
     aa0:	0e 94 94 1d 	call	0x3b28	; 0x3b28 <_ZN9MD_TCS2306getRGBEP9colorData>
     aa4:	80 91 db 02 	lds	r24, 0x02DB	; 0x8002db <rgb+0x1>
     aa8:	80 93 cf 02 	sts	0x02CF, r24	; 0x8002cf <greenScanned>
     aac:	80 91 da 02 	lds	r24, 0x02DA	; 0x8002da <rgb>
     ab0:	80 93 ce 02 	sts	0x02CE, r24	; 0x8002ce <redScanned>
     ab4:	80 91 dc 02 	lds	r24, 0x02DC	; 0x8002dc <rgb+0x2>
     ab8:	80 93 cd 02 	sts	0x02CD, r24	; 0x8002cd <blueScanned>
     abc:	0e 94 be 04 	call	0x97c	; 0x97c <_Z9FindMatchv>
     ac0:	0e 94 19 0b 	call	0x1632	; 0x1632 <__fixsfsi>
     ac4:	08 95       	ret

00000ac6 <_Z13findTestStripv>:
     ac6:	cf 93       	push	r28
     ac8:	8e e9       	ldi	r24, 0x9E	; 158
     aca:	92 e0       	ldi	r25, 0x02	; 2
     acc:	0e 94 5e 1e 	call	0x3cbc	; 0x3cbc <_ZN9MD_TCS2304readEv>
     ad0:	8e e9       	ldi	r24, 0x9E	; 158
     ad2:	92 e0       	ldi	r25, 0x02	; 2
     ad4:	0e 94 68 1e 	call	0x3cd0	; 0x3cd0 <_ZN9MD_TCS2309availableEv>
     ad8:	88 23       	and	r24, r24
     ada:	d1 f3       	breq	.-12     	; 0xad0 <_Z13findTestStripv+0xa>
     adc:	6a ed       	ldi	r22, 0xDA	; 218
     ade:	72 e0       	ldi	r23, 0x02	; 2
     ae0:	8e e9       	ldi	r24, 0x9E	; 158
     ae2:	92 e0       	ldi	r25, 0x02	; 2
     ae4:	0e 94 94 1d 	call	0x3b28	; 0x3b28 <_ZN9MD_TCS2306getRGBEP9colorData>
     ae8:	80 91 db 02 	lds	r24, 0x02DB	; 0x8002db <rgb+0x1>
     aec:	80 93 cf 02 	sts	0x02CF, r24	; 0x8002cf <greenScanned>
     af0:	80 91 da 02 	lds	r24, 0x02DA	; 0x8002da <rgb>
     af4:	80 93 ce 02 	sts	0x02CE, r24	; 0x8002ce <redScanned>
     af8:	80 91 dc 02 	lds	r24, 0x02DC	; 0x8002dc <rgb+0x2>
     afc:	80 93 cd 02 	sts	0x02CD, r24	; 0x8002cd <blueScanned>
     b00:	8a e0       	ldi	r24, 0x0A	; 10
     b02:	e2 e2       	ldi	r30, 0x22	; 34
     b04:	f1 e0       	ldi	r31, 0x01	; 1
     b06:	a0 ed       	ldi	r26, 0xD0	; 208
     b08:	b2 e0       	ldi	r27, 0x02	; 2
     b0a:	01 90       	ld	r0, Z+
     b0c:	0d 92       	st	X+, r0
     b0e:	8a 95       	dec	r24
     b10:	e1 f7       	brne	.-8      	; 0xb0a <_Z13findTestStripv+0x44>
     b12:	0e 94 27 04 	call	0x84e	; 0x84e <_Z9SameColorv>
     b16:	c8 2f       	mov	r28, r24
     b18:	6c ea       	ldi	r22, 0xAC	; 172
     b1a:	71 e0       	ldi	r23, 0x01	; 1
     b1c:	89 ec       	ldi	r24, 0xC9	; 201
     b1e:	93 e0       	ldi	r25, 0x03	; 3
     b20:	0e 94 a0 0e 	call	0x1d40	; 0x1d40 <_ZN5Print5printEPKc>
     b24:	6c 2f       	mov	r22, r28
     b26:	70 e0       	ldi	r23, 0x00	; 0
     b28:	4a e0       	ldi	r20, 0x0A	; 10
     b2a:	50 e0       	ldi	r21, 0x00	; 0
     b2c:	89 ec       	ldi	r24, 0xC9	; 201
     b2e:	93 e0       	ldi	r25, 0x03	; 3
     b30:	0e 94 71 0f 	call	0x1ee2	; 0x1ee2 <_ZN5Print7printlnEii>
     b34:	65 e6       	ldi	r22, 0x65	; 101
     b36:	72 e0       	ldi	r23, 0x02	; 2
     b38:	89 ec       	ldi	r24, 0xC9	; 201
     b3a:	93 e0       	ldi	r25, 0x03	; 3
     b3c:	0e 94 a0 0e 	call	0x1d40	; 0x1d40 <_ZN5Print5printEPKc>
     b40:	8a e0       	ldi	r24, 0x0A	; 10
     b42:	e8 e1       	ldi	r30, 0x18	; 24
     b44:	f1 e0       	ldi	r31, 0x01	; 1
     b46:	a0 ed       	ldi	r26, 0xD0	; 208
     b48:	b2 e0       	ldi	r27, 0x02	; 2
     b4a:	01 90       	ld	r0, Z+
     b4c:	0d 92       	st	X+, r0
     b4e:	8a 95       	dec	r24
     b50:	e1 f7       	brne	.-8      	; 0xb4a <_Z13findTestStripv+0x84>
     b52:	c1 11       	cpse	r28, r1
     b54:	03 c0       	rjmp	.+6      	; 0xb5c <_Z13findTestStripv+0x96>
     b56:	0e 94 27 04 	call	0x84e	; 0x84e <_Z9SameColorv>
     b5a:	c8 2f       	mov	r28, r24
     b5c:	6c eb       	ldi	r22, 0xBC	; 188
     b5e:	71 e0       	ldi	r23, 0x01	; 1
     b60:	89 ec       	ldi	r24, 0xC9	; 201
     b62:	93 e0       	ldi	r25, 0x03	; 3
     b64:	0e 94 a0 0e 	call	0x1d40	; 0x1d40 <_ZN5Print5printEPKc>
     b68:	6c 2f       	mov	r22, r28
     b6a:	70 e0       	ldi	r23, 0x00	; 0
     b6c:	4a e0       	ldi	r20, 0x0A	; 10
     b6e:	50 e0       	ldi	r21, 0x00	; 0
     b70:	89 ec       	ldi	r24, 0xC9	; 201
     b72:	93 e0       	ldi	r25, 0x03	; 3
     b74:	0e 94 71 0f 	call	0x1ee2	; 0x1ee2 <_ZN5Print7printlnEii>
     b78:	65 e6       	ldi	r22, 0x65	; 101
     b7a:	72 e0       	ldi	r23, 0x02	; 2
     b7c:	89 ec       	ldi	r24, 0xC9	; 201
     b7e:	93 e0       	ldi	r25, 0x03	; 3
     b80:	0e 94 a0 0e 	call	0x1d40	; 0x1d40 <_ZN5Print5printEPKc>
     b84:	cc 23       	and	r28, r28
     b86:	51 f0       	breq	.+20     	; 0xb9c <_Z13findTestStripv+0xd6>
     b88:	0e 94 be 04 	call	0x97c	; 0x97c <_Z9FindMatchv>
     b8c:	c1 e0       	ldi	r28, 0x01	; 1
     b8e:	20 e0       	ldi	r18, 0x00	; 0
     b90:	30 e0       	ldi	r19, 0x00	; 0
     b92:	40 e8       	ldi	r20, 0x80	; 128
     b94:	5f eb       	ldi	r21, 0xBF	; 191
     b96:	0e 94 a2 0a 	call	0x1544	; 0x1544 <__cmpsf2>
     b9a:	81 11       	cpse	r24, r1
     b9c:	c0 e0       	ldi	r28, 0x00	; 0
     b9e:	8c 2f       	mov	r24, r28
     ba0:	cf 91       	pop	r28
     ba2:	08 95       	ret

00000ba4 <_Z6setLED8LEDColor>:
     ba4:	cf 93       	push	r28
     ba6:	df 93       	push	r29
     ba8:	00 d0       	rcall	.+0      	; 0xbaa <_Z6setLED8LEDColor+0x6>
     baa:	00 d0       	rcall	.+0      	; 0xbac <_Z6setLED8LEDColor+0x8>
     bac:	00 d0       	rcall	.+0      	; 0xbae <_Z6setLED8LEDColor+0xa>
     bae:	cd b7       	in	r28, 0x3d	; 61
     bb0:	de b7       	in	r29, 0x3e	; 62
     bb2:	49 83       	std	Y+1, r20	; 0x01
     bb4:	5a 83       	std	Y+2, r21	; 0x02
     bb6:	6b 83       	std	Y+3, r22	; 0x03
     bb8:	7c 83       	std	Y+4, r23	; 0x04
     bba:	8d 83       	std	Y+5, r24	; 0x05
     bbc:	9e 83       	std	Y+6, r25	; 0x06
     bbe:	69 81       	ldd	r22, Y+1	; 0x01
     bc0:	7a 81       	ldd	r23, Y+2	; 0x02
     bc2:	8f e0       	ldi	r24, 0x0F	; 15
     bc4:	0e 94 ed 11 	call	0x23da	; 0x23da <analogWrite>
     bc8:	6b 81       	ldd	r22, Y+3	; 0x03
     bca:	7c 81       	ldd	r23, Y+4	; 0x04
     bcc:	80 e1       	ldi	r24, 0x10	; 16
     bce:	0e 94 ed 11 	call	0x23da	; 0x23da <analogWrite>
     bd2:	6d 81       	ldd	r22, Y+5	; 0x05
     bd4:	7e 81       	ldd	r23, Y+6	; 0x06
     bd6:	81 e1       	ldi	r24, 0x11	; 17
     bd8:	26 96       	adiw	r28, 0x06	; 6
     bda:	0f b6       	in	r0, 0x3f	; 63
     bdc:	f8 94       	cli
     bde:	de bf       	out	0x3e, r29	; 62
     be0:	0f be       	out	0x3f, r0	; 63
     be2:	cd bf       	out	0x3d, r28	; 61
     be4:	df 91       	pop	r29
     be6:	cf 91       	pop	r28
     be8:	0c 94 ed 11 	jmp	0x23da	; 0x23da <analogWrite>

00000bec <_Z15TaskAmmoniaReadPv>:
     bec:	cf 93       	push	r28
     bee:	df 93       	push	r29
     bf0:	00 d0       	rcall	.+0      	; 0xbf2 <_Z15TaskAmmoniaReadPv+0x6>
     bf2:	cd b7       	in	r28, 0x3d	; 61
     bf4:	de b7       	in	r29, 0x3e	; 62
     bf6:	0e 94 9e 17 	call	0x2f3c	; 0x2f3c <xTaskGetTickCount>
     bfa:	9a 83       	std	Y+2, r25	; 0x02
     bfc:	89 83       	std	Y+1, r24	; 0x01
     bfe:	61 e0       	ldi	r22, 0x01	; 1
     c00:	8d e0       	ldi	r24, 0x0D	; 13
     c02:	0e 94 75 12 	call	0x24ea	; 0x24ea <pinMode>
     c06:	14 e6       	ldi	r17, 0x64	; 100
     c08:	40 91 06 01 	lds	r20, 0x0106	; 0x800106 <White>
     c0c:	50 91 07 01 	lds	r21, 0x0107	; 0x800107 <White+0x1>
     c10:	60 91 08 01 	lds	r22, 0x0108	; 0x800108 <White+0x2>
     c14:	70 91 09 01 	lds	r23, 0x0109	; 0x800109 <White+0x3>
     c18:	80 91 0a 01 	lds	r24, 0x010A	; 0x80010a <White+0x4>
     c1c:	90 91 0b 01 	lds	r25, 0x010B	; 0x80010b <White+0x5>
     c20:	0e 94 d2 05 	call	0xba4	; 0xba4 <_Z6setLED8LEDColor>
     c24:	0e 94 63 05 	call	0xac6	; 0xac6 <_Z13findTestStripv>
     c28:	81 11       	cpse	r24, r1
     c2a:	fc cf       	rjmp	.-8      	; 0xc24 <_Z15TaskAmmoniaReadPv+0x38>
     c2c:	6a ef       	ldi	r22, 0xFA	; 250
     c2e:	70 e0       	ldi	r23, 0x00	; 0
     c30:	80 e0       	ldi	r24, 0x00	; 0
     c32:	90 e0       	ldi	r25, 0x00	; 0
     c34:	0e 94 4e 11 	call	0x229c	; 0x229c <delay>
     c38:	10 92 9b 03 	sts	0x039B, r1	; 0x80039b <typeToRead>
     c3c:	0e 94 42 05 	call	0xa84	; 0xa84 <_Z9ScanColorv>
     c40:	16 9f       	mul	r17, r22
     c42:	90 01       	movw	r18, r0
     c44:	17 9f       	mul	r17, r23
     c46:	30 0d       	add	r19, r0
     c48:	11 24       	eor	r1, r1
     c4a:	30 93 93 02 	sts	0x0293, r19	; 0x800293 <ammoniaValue+0x1>
     c4e:	20 93 92 02 	sts	0x0292, r18	; 0x800292 <ammoniaValue>
     c52:	40 91 98 02 	lds	r20, 0x0298	; 0x800298 <Off>
     c56:	50 91 99 02 	lds	r21, 0x0299	; 0x800299 <Off+0x1>
     c5a:	60 91 9a 02 	lds	r22, 0x029A	; 0x80029a <Off+0x2>
     c5e:	70 91 9b 02 	lds	r23, 0x029B	; 0x80029b <Off+0x3>
     c62:	80 91 9c 02 	lds	r24, 0x029C	; 0x80029c <Off+0x4>
     c66:	90 91 9d 02 	lds	r25, 0x029D	; 0x80029d <Off+0x5>
     c6a:	0e 94 d2 05 	call	0xba4	; 0xba4 <_Z6setLED8LEDColor>
     c6e:	20 e0       	ldi	r18, 0x00	; 0
     c70:	40 e0       	ldi	r20, 0x00	; 0
     c72:	50 e0       	ldi	r21, 0x00	; 0
     c74:	60 e0       	ldi	r22, 0x00	; 0
     c76:	70 e0       	ldi	r23, 0x00	; 0
     c78:	80 91 8c 02 	lds	r24, 0x028C	; 0x80028c <xSerialSemaphoreColorSensor>
     c7c:	90 91 8d 02 	lds	r25, 0x028D	; 0x80028d <xSerialSemaphoreColorSensor+0x1>
     c80:	0e 94 fd 13 	call	0x27fa	; 0x27fa <xQueueGenericSend>
     c84:	80 e0       	ldi	r24, 0x00	; 0
     c86:	90 e0       	ldi	r25, 0x00	; 0
     c88:	0e 94 59 19 	call	0x32b2	; 0x32b2 <vTaskSuspend>
     c8c:	6e e3       	ldi	r22, 0x3E	; 62
     c8e:	70 e0       	ldi	r23, 0x00	; 0
     c90:	ce 01       	movw	r24, r28
     c92:	01 96       	adiw	r24, 0x01	; 1
     c94:	0e 94 c3 18 	call	0x3186	; 0x3186 <vTaskDelayUntil>
     c98:	b7 cf       	rjmp	.-146    	; 0xc08 <_Z15TaskAmmoniaReadPv+0x1c>

00000c9a <_Z10TaskPHReadPv>:
     c9a:	cf 93       	push	r28
     c9c:	df 93       	push	r29
     c9e:	00 d0       	rcall	.+0      	; 0xca0 <_Z10TaskPHReadPv+0x6>
     ca0:	cd b7       	in	r28, 0x3d	; 61
     ca2:	de b7       	in	r29, 0x3e	; 62
     ca4:	0e 94 9e 17 	call	0x2f3c	; 0x2f3c <xTaskGetTickCount>
     ca8:	9a 83       	std	Y+2, r25	; 0x02
     caa:	89 83       	std	Y+1, r24	; 0x01
     cac:	40 91 0c 01 	lds	r20, 0x010C	; 0x80010c <Green>
     cb0:	50 91 0d 01 	lds	r21, 0x010D	; 0x80010d <Green+0x1>
     cb4:	60 91 0e 01 	lds	r22, 0x010E	; 0x80010e <Green+0x2>
     cb8:	70 91 0f 01 	lds	r23, 0x010F	; 0x80010f <Green+0x3>
     cbc:	80 91 10 01 	lds	r24, 0x0110	; 0x800110 <Green+0x4>
     cc0:	90 91 11 01 	lds	r25, 0x0111	; 0x800111 <Green+0x5>
     cc4:	0e 94 d2 05 	call	0xba4	; 0xba4 <_Z6setLED8LEDColor>
     cc8:	67 ed       	ldi	r22, 0xD7	; 215
     cca:	71 e0       	ldi	r23, 0x01	; 1
     ccc:	89 ec       	ldi	r24, 0xC9	; 201
     cce:	93 e0       	ldi	r25, 0x03	; 3
     cd0:	0e 94 13 02 	call	0x426	; 0x426 <_ZN5Print5writeEPKc>
     cd4:	60 91 94 02 	lds	r22, 0x0294	; 0x800294 <tempValue>
     cd8:	70 91 95 02 	lds	r23, 0x0295	; 0x800295 <tempValue+0x1>
     cdc:	07 2e       	mov	r0, r23
     cde:	00 0c       	add	r0, r0
     ce0:	88 0b       	sbc	r24, r24
     ce2:	99 0b       	sbc	r25, r25
     ce4:	0e 94 f6 09 	call	0x13ec	; 0x13ec <_Z5getPHl>
     ce8:	20 e0       	ldi	r18, 0x00	; 0
     cea:	30 e0       	ldi	r19, 0x00	; 0
     cec:	48 ec       	ldi	r20, 0xC8	; 200
     cee:	52 e4       	ldi	r21, 0x42	; 66
     cf0:	0e 94 06 0c 	call	0x180c	; 0x180c <__mulsf3>
     cf4:	0e 94 19 0b 	call	0x1632	; 0x1632 <__fixsfsi>
     cf8:	70 93 97 02 	sts	0x0297, r23	; 0x800297 <phValue+0x1>
     cfc:	60 93 96 02 	sts	0x0296, r22	; 0x800296 <phValue>
     d00:	62 ee       	ldi	r22, 0xE2	; 226
     d02:	71 e0       	ldi	r23, 0x01	; 1
     d04:	89 ec       	ldi	r24, 0xC9	; 201
     d06:	93 e0       	ldi	r25, 0x03	; 3
     d08:	0e 94 13 02 	call	0x426	; 0x426 <_ZN5Print5writeEPKc>
     d0c:	60 91 96 02 	lds	r22, 0x0296	; 0x800296 <phValue>
     d10:	70 91 97 02 	lds	r23, 0x0297	; 0x800297 <phValue+0x1>
     d14:	4a e0       	ldi	r20, 0x0A	; 10
     d16:	50 e0       	ldi	r21, 0x00	; 0
     d18:	89 ec       	ldi	r24, 0xC9	; 201
     d1a:	93 e0       	ldi	r25, 0x03	; 3
     d1c:	0e 94 6a 0f 	call	0x1ed4	; 0x1ed4 <_ZN5Print5printEii>
     d20:	64 e6       	ldi	r22, 0x64	; 100
     d22:	70 e0       	ldi	r23, 0x00	; 0
     d24:	80 e0       	ldi	r24, 0x00	; 0
     d26:	90 e0       	ldi	r25, 0x00	; 0
     d28:	0e 94 4e 11 	call	0x229c	; 0x229c <delay>
     d2c:	40 91 98 02 	lds	r20, 0x0298	; 0x800298 <Off>
     d30:	50 91 99 02 	lds	r21, 0x0299	; 0x800299 <Off+0x1>
     d34:	60 91 9a 02 	lds	r22, 0x029A	; 0x80029a <Off+0x2>
     d38:	70 91 9b 02 	lds	r23, 0x029B	; 0x80029b <Off+0x3>
     d3c:	80 91 9c 02 	lds	r24, 0x029C	; 0x80029c <Off+0x4>
     d40:	90 91 9d 02 	lds	r25, 0x029D	; 0x80029d <Off+0x5>
     d44:	0e 94 d2 05 	call	0xba4	; 0xba4 <_Z6setLED8LEDColor>
     d48:	6f e1       	ldi	r22, 0x1F	; 31
     d4a:	70 e0       	ldi	r23, 0x00	; 0
     d4c:	ce 01       	movw	r24, r28
     d4e:	01 96       	adiw	r24, 0x01	; 1
     d50:	0e 94 c3 18 	call	0x3186	; 0x3186 <vTaskDelayUntil>
     d54:	ab cf       	rjmp	.-170    	; 0xcac <_Z10TaskPHReadPv+0x12>

00000d56 <_Z19TaskTemperatureReadPv>:
     d56:	cf 93       	push	r28
     d58:	df 93       	push	r29
     d5a:	00 d0       	rcall	.+0      	; 0xd5c <_Z19TaskTemperatureReadPv+0x6>
     d5c:	cd b7       	in	r28, 0x3d	; 61
     d5e:	de b7       	in	r29, 0x3e	; 62
     d60:	0e 94 9e 17 	call	0x2f3c	; 0x2f3c <xTaskGetTickCount>
     d64:	9a 83       	std	Y+2, r25	; 0x02
     d66:	89 83       	std	Y+1, r24	; 0x01
     d68:	40 91 12 01 	lds	r20, 0x0112	; 0x800112 <Red>
     d6c:	50 91 13 01 	lds	r21, 0x0113	; 0x800113 <Red+0x1>
     d70:	60 91 14 01 	lds	r22, 0x0114	; 0x800114 <Red+0x2>
     d74:	70 91 15 01 	lds	r23, 0x0115	; 0x800115 <Red+0x3>
     d78:	80 91 16 01 	lds	r24, 0x0116	; 0x800116 <Red+0x4>
     d7c:	90 91 17 01 	lds	r25, 0x0117	; 0x800117 <Red+0x5>
     d80:	0e 94 d2 05 	call	0xba4	; 0xba4 <_Z6setLED8LEDColor>
     d84:	0e 94 2f 02 	call	0x45e	; 0x45e <_Z11measureTempv>
     d88:	20 e0       	ldi	r18, 0x00	; 0
     d8a:	30 e0       	ldi	r19, 0x00	; 0
     d8c:	48 ec       	ldi	r20, 0xC8	; 200
     d8e:	52 e4       	ldi	r21, 0x42	; 66
     d90:	0e 94 06 0c 	call	0x180c	; 0x180c <__mulsf3>
     d94:	0e 94 19 0b 	call	0x1632	; 0x1632 <__fixsfsi>
     d98:	70 93 95 02 	sts	0x0295, r23	; 0x800295 <tempValue+0x1>
     d9c:	60 93 94 02 	sts	0x0294, r22	; 0x800294 <tempValue>
     da0:	6d ee       	ldi	r22, 0xED	; 237
     da2:	71 e0       	ldi	r23, 0x01	; 1
     da4:	89 ec       	ldi	r24, 0xC9	; 201
     da6:	93 e0       	ldi	r25, 0x03	; 3
     da8:	0e 94 13 02 	call	0x426	; 0x426 <_ZN5Print5writeEPKc>
     dac:	60 91 94 02 	lds	r22, 0x0294	; 0x800294 <tempValue>
     db0:	70 91 95 02 	lds	r23, 0x0295	; 0x800295 <tempValue+0x1>
     db4:	4a e0       	ldi	r20, 0x0A	; 10
     db6:	50 e0       	ldi	r21, 0x00	; 0
     db8:	89 ec       	ldi	r24, 0xC9	; 201
     dba:	93 e0       	ldi	r25, 0x03	; 3
     dbc:	0e 94 6a 0f 	call	0x1ed4	; 0x1ed4 <_ZN5Print5printEii>
     dc0:	64 e6       	ldi	r22, 0x64	; 100
     dc2:	70 e0       	ldi	r23, 0x00	; 0
     dc4:	80 e0       	ldi	r24, 0x00	; 0
     dc6:	90 e0       	ldi	r25, 0x00	; 0
     dc8:	0e 94 4e 11 	call	0x229c	; 0x229c <delay>
     dcc:	40 91 98 02 	lds	r20, 0x0298	; 0x800298 <Off>
     dd0:	50 91 99 02 	lds	r21, 0x0299	; 0x800299 <Off+0x1>
     dd4:	60 91 9a 02 	lds	r22, 0x029A	; 0x80029a <Off+0x2>
     dd8:	70 91 9b 02 	lds	r23, 0x029B	; 0x80029b <Off+0x3>
     ddc:	80 91 9c 02 	lds	r24, 0x029C	; 0x80029c <Off+0x4>
     de0:	90 91 9d 02 	lds	r25, 0x029D	; 0x80029d <Off+0x5>
     de4:	0e 94 d2 05 	call	0xba4	; 0xba4 <_Z6setLED8LEDColor>
     de8:	6d e7       	ldi	r22, 0x7D	; 125
     dea:	70 e0       	ldi	r23, 0x00	; 0
     dec:	ce 01       	movw	r24, r28
     dee:	01 96       	adiw	r24, 0x01	; 1
     df0:	0e 94 c3 18 	call	0x3186	; 0x3186 <vTaskDelayUntil>
     df4:	b9 cf       	rjmp	.-142    	; 0xd68 <_Z19TaskTemperatureReadPv+0x12>

00000df6 <_Z8setupLEDv>:
     df6:	61 e0       	ldi	r22, 0x01	; 1
     df8:	8f e0       	ldi	r24, 0x0F	; 15
     dfa:	0e 94 75 12 	call	0x24ea	; 0x24ea <pinMode>
     dfe:	61 e0       	ldi	r22, 0x01	; 1
     e00:	80 e1       	ldi	r24, 0x10	; 16
     e02:	0e 94 75 12 	call	0x24ea	; 0x24ea <pinMode>
     e06:	61 e0       	ldi	r22, 0x01	; 1
     e08:	81 e1       	ldi	r24, 0x11	; 17
     e0a:	0e 94 75 12 	call	0x24ea	; 0x24ea <pinMode>
     e0e:	40 91 98 02 	lds	r20, 0x0298	; 0x800298 <Off>
     e12:	50 91 99 02 	lds	r21, 0x0299	; 0x800299 <Off+0x1>
     e16:	60 91 9a 02 	lds	r22, 0x029A	; 0x80029a <Off+0x2>
     e1a:	70 91 9b 02 	lds	r23, 0x029B	; 0x80029b <Off+0x3>
     e1e:	80 91 9c 02 	lds	r24, 0x029C	; 0x80029c <Off+0x4>
     e22:	90 91 9d 02 	lds	r25, 0x029D	; 0x80029d <Off+0x5>
     e26:	0c 94 d2 05 	jmp	0xba4	; 0xba4 <_Z6setLED8LEDColor>

00000e2a <setup>:
     e2a:	ef 92       	push	r14
     e2c:	ff 92       	push	r15
     e2e:	0f 93       	push	r16
     e30:	26 e0       	ldi	r18, 0x06	; 6
     e32:	40 e0       	ldi	r20, 0x00	; 0
     e34:	52 ec       	ldi	r21, 0xC2	; 194
     e36:	61 e0       	ldi	r22, 0x01	; 1
     e38:	70 e0       	ldi	r23, 0x00	; 0
     e3a:	89 ec       	ldi	r24, 0xC9	; 201
     e3c:	93 e0       	ldi	r25, 0x03	; 3
     e3e:	0e 94 4f 0d 	call	0x1a9e	; 0x1a9e <_ZN14HardwareSerial5beginEmh>
     e42:	8e e9       	ldi	r24, 0x9E	; 158
     e44:	92 e0       	ldi	r25, 0x02	; 2
     e46:	0e 94 69 1d 	call	0x3ad2	; 0x3ad2 <_ZN9MD_TCS2305beginEv>
     e4a:	0e 94 e5 02 	call	0x5ca	; 0x5ca <_Z9addColorsv>
     e4e:	0e 94 fb 06 	call	0xdf6	; 0xdf6 <_Z8setupLEDv>
     e52:	6a ef       	ldi	r22, 0xFA	; 250
     e54:	71 e0       	ldi	r23, 0x01	; 1
     e56:	89 ec       	ldi	r24, 0xC9	; 201
     e58:	93 e0       	ldi	r25, 0x03	; 3
     e5a:	0e 94 a0 0e 	call	0x1d40	; 0x1d40 <_ZN5Print5printEPKc>
     e5e:	40 91 0c 01 	lds	r20, 0x010C	; 0x80010c <Green>
     e62:	50 91 0d 01 	lds	r21, 0x010D	; 0x80010d <Green+0x1>
     e66:	60 91 0e 01 	lds	r22, 0x010E	; 0x80010e <Green+0x2>
     e6a:	70 91 0f 01 	lds	r23, 0x010F	; 0x80010f <Green+0x3>
     e6e:	80 91 10 01 	lds	r24, 0x0110	; 0x800110 <Green+0x4>
     e72:	90 91 11 01 	lds	r25, 0x0111	; 0x800111 <Green+0x5>
     e76:	0e 94 d2 05 	call	0xba4	; 0xba4 <_Z6setLED8LEDColor>
     e7a:	0e 94 f2 09 	call	0x13e4	; 0x13e4 <_Z6phInitv>
     e7e:	43 e0       	ldi	r20, 0x03	; 3
     e80:	50 e0       	ldi	r21, 0x00	; 0
     e82:	61 ea       	ldi	r22, 0xA1	; 161
     e84:	77 e0       	ldi	r23, 0x07	; 7
     e86:	80 e0       	ldi	r24, 0x00	; 0
     e88:	0e 94 71 10 	call	0x20e2	; 0x20e2 <attachInterrupt>
     e8c:	8a e8       	ldi	r24, 0x8A	; 138
     e8e:	e8 2e       	mov	r14, r24
     e90:	82 e0       	ldi	r24, 0x02	; 2
     e92:	f8 2e       	mov	r15, r24
     e94:	02 e0       	ldi	r16, 0x02	; 2
     e96:	20 e0       	ldi	r18, 0x00	; 0
     e98:	30 e0       	ldi	r19, 0x00	; 0
     e9a:	40 e8       	ldi	r20, 0x80	; 128
     e9c:	50 e0       	ldi	r21, 0x00	; 0
     e9e:	69 e0       	ldi	r22, 0x09	; 9
     ea0:	72 e0       	ldi	r23, 0x02	; 2
     ea2:	86 ef       	ldi	r24, 0xF6	; 246
     ea4:	95 e0       	ldi	r25, 0x05	; 5
     ea6:	0e 94 15 16 	call	0x2c2a	; 0x2c2a <xTaskCreate>
     eaa:	96 e8       	ldi	r25, 0x86	; 134
     eac:	e9 2e       	mov	r14, r25
     eae:	92 e0       	ldi	r25, 0x02	; 2
     eb0:	f9 2e       	mov	r15, r25
     eb2:	20 e0       	ldi	r18, 0x00	; 0
     eb4:	30 e0       	ldi	r19, 0x00	; 0
     eb6:	40 e8       	ldi	r20, 0x80	; 128
     eb8:	50 e0       	ldi	r21, 0x00	; 0
     eba:	61 e1       	ldi	r22, 0x11	; 17
     ebc:	72 e0       	ldi	r23, 0x02	; 2
     ebe:	8d e4       	ldi	r24, 0x4D	; 77
     ec0:	96 e0       	ldi	r25, 0x06	; 6
     ec2:	0e 94 15 16 	call	0x2c2a	; 0x2c2a <xTaskCreate>
     ec6:	24 e8       	ldi	r18, 0x84	; 132
     ec8:	e2 2e       	mov	r14, r18
     eca:	22 e0       	ldi	r18, 0x02	; 2
     ecc:	f2 2e       	mov	r15, r18
     ece:	20 e0       	ldi	r18, 0x00	; 0
     ed0:	30 e0       	ldi	r19, 0x00	; 0
     ed2:	40 e8       	ldi	r20, 0x80	; 128
     ed4:	50 e0       	ldi	r21, 0x00	; 0
     ed6:	64 e1       	ldi	r22, 0x14	; 20
     ed8:	72 e0       	ldi	r23, 0x02	; 2
     eda:	8b ea       	ldi	r24, 0xAB	; 171
     edc:	96 e0       	ldi	r25, 0x06	; 6
     ede:	0e 94 15 16 	call	0x2c2a	; 0x2c2a <xTaskCreate>
     ee2:	68 ee       	ldi	r22, 0xE8	; 232
     ee4:	73 e0       	ldi	r23, 0x03	; 3
     ee6:	80 e0       	ldi	r24, 0x00	; 0
     ee8:	90 e0       	ldi	r25, 0x00	; 0
     eea:	0e 94 4e 11 	call	0x229c	; 0x229c <delay>
     eee:	40 91 98 02 	lds	r20, 0x0298	; 0x800298 <Off>
     ef2:	50 91 99 02 	lds	r21, 0x0299	; 0x800299 <Off+0x1>
     ef6:	60 91 9a 02 	lds	r22, 0x029A	; 0x80029a <Off+0x2>
     efa:	70 91 9b 02 	lds	r23, 0x029B	; 0x80029b <Off+0x3>
     efe:	80 91 9c 02 	lds	r24, 0x029C	; 0x80029c <Off+0x4>
     f02:	90 91 9d 02 	lds	r25, 0x029D	; 0x80029d <Off+0x5>
     f06:	0e 94 d2 05 	call	0xba4	; 0xba4 <_Z6setLED8LEDColor>
     f0a:	60 e2       	ldi	r22, 0x20	; 32
     f0c:	72 e0       	ldi	r23, 0x02	; 2
     f0e:	89 ec       	ldi	r24, 0xC9	; 201
     f10:	93 e0       	ldi	r25, 0x03	; 3
     f12:	0e 94 a0 0e 	call	0x1d40	; 0x1d40 <_ZN5Print5printEPKc>
     f16:	0f 91       	pop	r16
     f18:	ff 90       	pop	r15
     f1a:	ef 90       	pop	r14
     f1c:	0c 94 6a 17 	jmp	0x2ed4	; 0x2ed4 <vTaskStartScheduler>

00000f20 <loop>:
     f20:	08 95       	ret

00000f22 <_GLOBAL__sub_I_ds>:
    bool LastDeviceFlag;
#endif

  public:
    OneWire() { }
    OneWire(uint8_t pin) { begin(pin); }
     f22:	66 e0       	ldi	r22, 0x06	; 6
     f24:	8c e9       	ldi	r24, 0x9C	; 156
     f26:	93 e0       	ldi	r25, 0x03	; 3
     f28:	0e 94 30 09 	call	0x1260	; 0x1260 <_ZN7OneWire5beginEh>

uint8_t greenScanned;
uint8_t redScanned;
uint8_t blueScanned;

MD_TCS230  CS(S2, S3, OE);
     f2c:	28 e0       	ldi	r18, 0x08	; 8
     f2e:	4d e0       	ldi	r20, 0x0D	; 13
     f30:	6c e0       	ldi	r22, 0x0C	; 12
     f32:	8e e9       	ldi	r24, 0x9E	; 158
     f34:	92 e0       	ldi	r25, 0x02	; 2
     f36:	0c 94 f7 1c 	jmp	0x39ee	; 0x39ee <_ZN9MD_TCS230C1Ehhh>

00000f3a <_GLOBAL__sub_D_ds>:
     f3a:	8e e9       	ldi	r24, 0x9E	; 158
     f3c:	92 e0       	ldi	r25, 0x02	; 2
     f3e:	0c 94 0b 1d 	jmp	0x3a16	; 0x3a16 <_ZN9MD_TCS230D1Ev>

00000f42 <_Z8fromWifiv>:
		vTaskDelayUntil( &xLastWakeTime, 2000 / portTICK_PERIOD_MS );
	}
}

void fromWifi()
{
     f42:	cf 93       	push	r28
	int i = 0;
	char action = '\0';
	// check for data from Wifi
	if (Serial.available())
     f44:	89 ec       	ldi	r24, 0xC9	; 201
     f46:	93 e0       	ldi	r25, 0x03	; 3
     f48:	0e 94 73 0c 	call	0x18e6	; 0x18e6 <_ZN14HardwareSerial9availableEv>
     f4c:	89 2b       	or	r24, r25
     f4e:	09 f4       	brne	.+2      	; 0xf52 <_Z8fromWifiv+0x10>
     f50:	6d c0       	rjmp	.+218    	; 0x102c <_Z8fromWifiv+0xea>
	{
		delay(100); // allows all serial sent to be received together
     f52:	64 e6       	ldi	r22, 0x64	; 100
     f54:	70 e0       	ldi	r23, 0x00	; 0
     f56:	80 e0       	ldi	r24, 0x00	; 0
     f58:	90 e0       	ldi	r25, 0x00	; 0
     f5a:	0e 94 4e 11 	call	0x229c	; 0x229c <delay>
}

void fromWifi()
{
	int i = 0;
	char action = '\0';
     f5e:	c0 e0       	ldi	r28, 0x00	; 0
	// check for data from Wifi
	if (Serial.available())
	{
		delay(100); // allows all serial sent to be received together
		while (Serial.available())
     f60:	89 ec       	ldi	r24, 0xC9	; 201
     f62:	93 e0       	ldi	r25, 0x03	; 3
     f64:	0e 94 73 0c 	call	0x18e6	; 0x18e6 <_ZN14HardwareSerial9availableEv>
     f68:	89 2b       	or	r24, r25
     f6a:	31 f0       	breq	.+12     	; 0xf78 <_Z8fromWifiv+0x36>
		{
			action = Serial.read();
     f6c:	89 ec       	ldi	r24, 0xC9	; 201
     f6e:	93 e0       	ldi	r25, 0x03	; 3
     f70:	0e 94 8d 0c 	call	0x191a	; 0x191a <_ZN14HardwareSerial4readEv>
     f74:	c8 2f       	mov	r28, r24
	char action = '\0';
	// check for data from Wifi
	if (Serial.available())
	{
		delay(100); // allows all serial sent to be received together
		while (Serial.available())
     f76:	f4 cf       	rjmp	.-24     	; 0xf60 <_Z8fromWifiv+0x1e>
		{
			action = Serial.read();
		}
	}

	switch(action)
     f78:	ce 36       	cpi	r28, 0x6E	; 110
     f7a:	51 f0       	breq	.+20     	; 0xf90 <_Z8fromWifiv+0x4e>
     f7c:	c0 37       	cpi	r28, 0x70	; 112
     f7e:	79 f0       	breq	.+30     	; 0xf9e <_Z8fromWifiv+0x5c>
     f80:	c1 36       	cpi	r28, 0x61	; 97
     f82:	09 f0       	breq	.+2      	; 0xf86 <_Z8fromWifiv+0x44>
     f84:	53 c0       	rjmp	.+166    	; 0x102c <_Z8fromWifiv+0xea>
	{
	case 'a':
	{
		vTaskResume(xAmmonia);
     f86:	80 91 8a 02 	lds	r24, 0x028A	; 0x80028a <xAmmonia>
     f8a:	90 91 8b 02 	lds	r25, 0x028B	; 0x80028b <xAmmonia+0x1>
     f8e:	04 c0       	rjmp	.+8      	; 0xf98 <_Z8fromWifiv+0x56>
		break;
	}
	case 'n':
	{
		vTaskResume(xNitriteNitrate);
     f90:	80 91 88 02 	lds	r24, 0x0288	; 0x800288 <xNitriteNitrate>
     f94:	90 91 89 02 	lds	r25, 0x0289	; 0x800289 <xNitriteNitrate+0x1>
		Serial.write(nitrateValue);
	}
	default:
		break;
	}
}
     f98:	cf 91       	pop	r28
		vTaskResume(xAmmonia);
		break;
	}
	case 'n':
	{
		vTaskResume(xNitriteNitrate);
     f9a:	0c 94 21 17 	jmp	0x2e42	; 0x2e42 <vTaskResume>
		break;
	}
	case 'p':
	{
		Serial.write("ph:");
     f9e:	6d e2       	ldi	r22, 0x2D	; 45
     fa0:	72 e0       	ldi	r23, 0x02	; 2
     fa2:	89 ec       	ldi	r24, 0xC9	; 201
     fa4:	93 e0       	ldi	r25, 0x03	; 3
     fa6:	0e 94 13 02 	call	0x426	; 0x426 <_ZN5Print5writeEPKc>
		Serial.write(phValue);
     faa:	60 91 96 02 	lds	r22, 0x0296	; 0x800296 <phValue>
     fae:	70 91 97 02 	lds	r23, 0x0297	; 0x800297 <phValue+0x1>
     fb2:	89 ec       	ldi	r24, 0xC9	; 201
     fb4:	93 e0       	ldi	r25, 0x03	; 3
     fb6:	0e 94 28 02 	call	0x450	; 0x450 <_ZN14HardwareSerial5writeEi>
		Serial.write("temp:");
     fba:	61 e3       	ldi	r22, 0x31	; 49
     fbc:	72 e0       	ldi	r23, 0x02	; 2
     fbe:	89 ec       	ldi	r24, 0xC9	; 201
     fc0:	93 e0       	ldi	r25, 0x03	; 3
     fc2:	0e 94 13 02 	call	0x426	; 0x426 <_ZN5Print5writeEPKc>
		Serial.write(tempValue);
     fc6:	60 91 94 02 	lds	r22, 0x0294	; 0x800294 <tempValue>
     fca:	70 91 95 02 	lds	r23, 0x0295	; 0x800295 <tempValue+0x1>
     fce:	89 ec       	ldi	r24, 0xC9	; 201
     fd0:	93 e0       	ldi	r25, 0x03	; 3
     fd2:	0e 94 28 02 	call	0x450	; 0x450 <_ZN14HardwareSerial5writeEi>
		Serial.write("ammonia:");
     fd6:	67 e3       	ldi	r22, 0x37	; 55
     fd8:	72 e0       	ldi	r23, 0x02	; 2
     fda:	89 ec       	ldi	r24, 0xC9	; 201
     fdc:	93 e0       	ldi	r25, 0x03	; 3
     fde:	0e 94 13 02 	call	0x426	; 0x426 <_ZN5Print5writeEPKc>
		Serial.write(ammoniaValue);
     fe2:	60 91 92 02 	lds	r22, 0x0292	; 0x800292 <ammoniaValue>
     fe6:	70 91 93 02 	lds	r23, 0x0293	; 0x800293 <ammoniaValue+0x1>
     fea:	89 ec       	ldi	r24, 0xC9	; 201
     fec:	93 e0       	ldi	r25, 0x03	; 3
     fee:	0e 94 28 02 	call	0x450	; 0x450 <_ZN14HardwareSerial5writeEi>
		Serial.write("nitrite:");
     ff2:	60 e4       	ldi	r22, 0x40	; 64
     ff4:	72 e0       	ldi	r23, 0x02	; 2
     ff6:	89 ec       	ldi	r24, 0xC9	; 201
     ff8:	93 e0       	ldi	r25, 0x03	; 3
     ffa:	0e 94 13 02 	call	0x426	; 0x426 <_ZN5Print5writeEPKc>
		Serial.write(nitriteValue);
     ffe:	60 91 8e 02 	lds	r22, 0x028E	; 0x80028e <nitriteValue>
    1002:	70 91 8f 02 	lds	r23, 0x028F	; 0x80028f <nitriteValue+0x1>
    1006:	89 ec       	ldi	r24, 0xC9	; 201
    1008:	93 e0       	ldi	r25, 0x03	; 3
    100a:	0e 94 28 02 	call	0x450	; 0x450 <_ZN14HardwareSerial5writeEi>
		Serial.write("nitrate:");
    100e:	69 e4       	ldi	r22, 0x49	; 73
    1010:	72 e0       	ldi	r23, 0x02	; 2
    1012:	89 ec       	ldi	r24, 0xC9	; 201
    1014:	93 e0       	ldi	r25, 0x03	; 3
    1016:	0e 94 13 02 	call	0x426	; 0x426 <_ZN5Print5writeEPKc>
		Serial.write(nitrateValue);
    101a:	60 91 90 02 	lds	r22, 0x0290	; 0x800290 <nitrateValue>
    101e:	70 91 91 02 	lds	r23, 0x0291	; 0x800291 <nitrateValue+0x1>
    1022:	89 ec       	ldi	r24, 0xC9	; 201
    1024:	93 e0       	ldi	r25, 0x03	; 3
	}
	default:
		break;
	}
}
    1026:	cf 91       	pop	r28
		Serial.write("ammonia:");
		Serial.write(ammoniaValue);
		Serial.write("nitrite:");
		Serial.write(nitriteValue);
		Serial.write("nitrate:");
		Serial.write(nitrateValue);
    1028:	0c 94 28 02 	jmp	0x450	; 0x450 <_ZN14HardwareSerial5writeEi>
	}
	default:
		break;
	}
}
    102c:	cf 91       	pop	r28
    102e:	08 95       	ret

00001030 <_ZN7OneWire5resetEv>:
   ROM_NO[0] = family_code;
   for (uint8_t i = 1; i < 8; i++)
      ROM_NO[i] = 0;
   LastDiscrepancy = 64;
   LastFamilyDiscrepancy = 0;
   LastDeviceFlag = false;
    1030:	ff 92       	push	r15
    1032:	0f 93       	push	r16
    1034:	1f 93       	push	r17
    1036:	cf 93       	push	r28
    1038:	df 93       	push	r29
    103a:	fc 01       	movw	r30, r24
    103c:	f0 80       	ld	r15, Z
    103e:	c1 81       	ldd	r28, Z+1	; 0x01
    1040:	d2 81       	ldd	r29, Z+2	; 0x02
    1042:	f8 94       	cli
    1044:	89 81       	ldd	r24, Y+1	; 0x01
    1046:	0f 2d       	mov	r16, r15
    1048:	00 95       	com	r16
    104a:	80 23       	and	r24, r16
    104c:	89 83       	std	Y+1, r24	; 0x01
    104e:	78 94       	sei
    1050:	1d e7       	ldi	r17, 0x7D	; 125
    1052:	11 50       	subi	r17, 0x01	; 1
    1054:	29 f1       	breq	.+74     	; 0x10a0 <_ZN7OneWire5resetEv+0x70>
    1056:	82 e0       	ldi	r24, 0x02	; 2
    1058:	90 e0       	ldi	r25, 0x00	; 0
    105a:	0e 94 8a 11 	call	0x2314	; 0x2314 <delayMicroseconds>
    105e:	88 81       	ld	r24, Y
    1060:	8f 21       	and	r24, r15
    1062:	b9 f3       	breq	.-18     	; 0x1052 <_ZN7OneWire5resetEv+0x22>
    1064:	f8 94       	cli
    1066:	8a 81       	ldd	r24, Y+2	; 0x02
    1068:	80 23       	and	r24, r16
    106a:	8a 83       	std	Y+2, r24	; 0x02
    106c:	89 81       	ldd	r24, Y+1	; 0x01
    106e:	8f 29       	or	r24, r15
    1070:	89 83       	std	Y+1, r24	; 0x01
    1072:	78 94       	sei
    1074:	80 ee       	ldi	r24, 0xE0	; 224
    1076:	91 e0       	ldi	r25, 0x01	; 1
    1078:	0e 94 8a 11 	call	0x2314	; 0x2314 <delayMicroseconds>
    107c:	f8 94       	cli
    107e:	89 81       	ldd	r24, Y+1	; 0x01
    1080:	08 23       	and	r16, r24
    1082:	09 83       	std	Y+1, r16	; 0x01
    1084:	86 e4       	ldi	r24, 0x46	; 70
    1086:	90 e0       	ldi	r25, 0x00	; 0
    1088:	0e 94 8a 11 	call	0x2314	; 0x2314 <delayMicroseconds>
    108c:	88 81       	ld	r24, Y
    108e:	f8 22       	and	r15, r24
    1090:	11 e0       	ldi	r17, 0x01	; 1
    1092:	09 f0       	breq	.+2      	; 0x1096 <_ZN7OneWire5resetEv+0x66>
    1094:	10 e0       	ldi	r17, 0x00	; 0
    1096:	78 94       	sei
    1098:	8a e9       	ldi	r24, 0x9A	; 154
    109a:	91 e0       	ldi	r25, 0x01	; 1
    109c:	0e 94 8a 11 	call	0x2314	; 0x2314 <delayMicroseconds>
    10a0:	81 2f       	mov	r24, r17
    10a2:	df 91       	pop	r29
    10a4:	cf 91       	pop	r28
    10a6:	1f 91       	pop	r17
    10a8:	0f 91       	pop	r16
    10aa:	ff 90       	pop	r15
    10ac:	08 95       	ret

000010ae <_ZN7OneWire9write_bitEh>:
    10ae:	1f 93       	push	r17
    10b0:	cf 93       	push	r28
    10b2:	df 93       	push	r29
    10b4:	fc 01       	movw	r30, r24
    10b6:	10 81       	ld	r17, Z
    10b8:	c1 81       	ldd	r28, Z+1	; 0x01
    10ba:	d2 81       	ldd	r29, Z+2	; 0x02
    10bc:	81 2f       	mov	r24, r17
    10be:	80 95       	com	r24
    10c0:	60 ff       	sbrs	r22, 0
    10c2:	12 c0       	rjmp	.+36     	; 0x10e8 <_ZN7OneWire9write_bitEh+0x3a>
    10c4:	f8 94       	cli
    10c6:	9a 81       	ldd	r25, Y+2	; 0x02
    10c8:	89 23       	and	r24, r25
    10ca:	8a 83       	std	Y+2, r24	; 0x02
    10cc:	89 81       	ldd	r24, Y+1	; 0x01
    10ce:	81 2b       	or	r24, r17
    10d0:	89 83       	std	Y+1, r24	; 0x01
    10d2:	8a e0       	ldi	r24, 0x0A	; 10
    10d4:	90 e0       	ldi	r25, 0x00	; 0
    10d6:	0e 94 8a 11 	call	0x2314	; 0x2314 <delayMicroseconds>
    10da:	8a 81       	ldd	r24, Y+2	; 0x02
    10dc:	18 2b       	or	r17, r24
    10de:	1a 83       	std	Y+2, r17	; 0x02
    10e0:	78 94       	sei
    10e2:	87 e3       	ldi	r24, 0x37	; 55
    10e4:	90 e0       	ldi	r25, 0x00	; 0
    10e6:	11 c0       	rjmp	.+34     	; 0x110a <_ZN7OneWire9write_bitEh+0x5c>
    10e8:	f8 94       	cli
    10ea:	9a 81       	ldd	r25, Y+2	; 0x02
    10ec:	89 23       	and	r24, r25
    10ee:	8a 83       	std	Y+2, r24	; 0x02
    10f0:	89 81       	ldd	r24, Y+1	; 0x01
    10f2:	81 2b       	or	r24, r17
    10f4:	89 83       	std	Y+1, r24	; 0x01
    10f6:	81 e4       	ldi	r24, 0x41	; 65
    10f8:	90 e0       	ldi	r25, 0x00	; 0
    10fa:	0e 94 8a 11 	call	0x2314	; 0x2314 <delayMicroseconds>
    10fe:	8a 81       	ldd	r24, Y+2	; 0x02
    1100:	18 2b       	or	r17, r24
    1102:	1a 83       	std	Y+2, r17	; 0x02
    1104:	78 94       	sei
    1106:	85 e0       	ldi	r24, 0x05	; 5
    1108:	90 e0       	ldi	r25, 0x00	; 0
    110a:	df 91       	pop	r29
    110c:	cf 91       	pop	r28
    110e:	1f 91       	pop	r17
    1110:	0c 94 8a 11 	jmp	0x2314	; 0x2314 <delayMicroseconds>

00001114 <_ZN7OneWire8read_bitEv>:
    1114:	0f 93       	push	r16
    1116:	1f 93       	push	r17
    1118:	cf 93       	push	r28
    111a:	df 93       	push	r29
    111c:	fc 01       	movw	r30, r24
    111e:	00 81       	ld	r16, Z
    1120:	c1 81       	ldd	r28, Z+1	; 0x01
    1122:	d2 81       	ldd	r29, Z+2	; 0x02
    1124:	f8 94       	cli
    1126:	89 81       	ldd	r24, Y+1	; 0x01
    1128:	80 2b       	or	r24, r16
    112a:	89 83       	std	Y+1, r24	; 0x01
    112c:	8a 81       	ldd	r24, Y+2	; 0x02
    112e:	10 2f       	mov	r17, r16
    1130:	10 95       	com	r17
    1132:	81 23       	and	r24, r17
    1134:	8a 83       	std	Y+2, r24	; 0x02
    1136:	83 e0       	ldi	r24, 0x03	; 3
    1138:	90 e0       	ldi	r25, 0x00	; 0
    113a:	0e 94 8a 11 	call	0x2314	; 0x2314 <delayMicroseconds>
    113e:	89 81       	ldd	r24, Y+1	; 0x01
    1140:	18 23       	and	r17, r24
    1142:	19 83       	std	Y+1, r17	; 0x01
    1144:	8a e0       	ldi	r24, 0x0A	; 10
    1146:	90 e0       	ldi	r25, 0x00	; 0
    1148:	0e 94 8a 11 	call	0x2314	; 0x2314 <delayMicroseconds>
    114c:	c8 81       	ld	r28, Y
    114e:	78 94       	sei
    1150:	85 e3       	ldi	r24, 0x35	; 53
    1152:	90 e0       	ldi	r25, 0x00	; 0
    1154:	0e 94 8a 11 	call	0x2314	; 0x2314 <delayMicroseconds>
    1158:	c0 23       	and	r28, r16
    115a:	81 e0       	ldi	r24, 0x01	; 1
    115c:	09 f4       	brne	.+2      	; 0x1160 <_ZN7OneWire8read_bitEv+0x4c>
    115e:	80 e0       	ldi	r24, 0x00	; 0
    1160:	df 91       	pop	r29
    1162:	cf 91       	pop	r28
    1164:	1f 91       	pop	r17
    1166:	0f 91       	pop	r16
    1168:	08 95       	ret

0000116a <_ZN7OneWire5writeEhh>:
    116a:	df 92       	push	r13
    116c:	ef 92       	push	r14
    116e:	ff 92       	push	r15
    1170:	0f 93       	push	r16
    1172:	1f 93       	push	r17
    1174:	cf 93       	push	r28
    1176:	df 93       	push	r29
    1178:	ec 01       	movw	r28, r24
    117a:	d6 2e       	mov	r13, r22
    117c:	e4 2e       	mov	r14, r20
    117e:	08 e0       	ldi	r16, 0x08	; 8
    1180:	10 e0       	ldi	r17, 0x00	; 0
    1182:	ff 24       	eor	r15, r15
    1184:	f3 94       	inc	r15
    1186:	61 e0       	ldi	r22, 0x01	; 1
    1188:	8d 2d       	mov	r24, r13
    118a:	8f 21       	and	r24, r15
    118c:	09 f4       	brne	.+2      	; 0x1190 <_ZN7OneWire5writeEhh+0x26>
    118e:	60 e0       	ldi	r22, 0x00	; 0
    1190:	ce 01       	movw	r24, r28
    1192:	0e 94 57 08 	call	0x10ae	; 0x10ae <_ZN7OneWire9write_bitEh>
    1196:	ff 0c       	add	r15, r15
    1198:	01 50       	subi	r16, 0x01	; 1
    119a:	11 09       	sbc	r17, r1
    119c:	a1 f7       	brne	.-24     	; 0x1186 <_ZN7OneWire5writeEhh+0x1c>
    119e:	e1 10       	cpse	r14, r1
    11a0:	10 c0       	rjmp	.+32     	; 0x11c2 <_ZN7OneWire5writeEhh+0x58>
    11a2:	f8 94       	cli
    11a4:	e9 81       	ldd	r30, Y+1	; 0x01
    11a6:	fa 81       	ldd	r31, Y+2	; 0x02
    11a8:	91 81       	ldd	r25, Z+1	; 0x01
    11aa:	88 81       	ld	r24, Y
    11ac:	80 95       	com	r24
    11ae:	89 23       	and	r24, r25
    11b0:	81 83       	std	Z+1, r24	; 0x01
    11b2:	e9 81       	ldd	r30, Y+1	; 0x01
    11b4:	fa 81       	ldd	r31, Y+2	; 0x02
    11b6:	92 81       	ldd	r25, Z+2	; 0x02
    11b8:	88 81       	ld	r24, Y
    11ba:	80 95       	com	r24
    11bc:	89 23       	and	r24, r25
    11be:	82 83       	std	Z+2, r24	; 0x02
    11c0:	78 94       	sei
    11c2:	df 91       	pop	r29
    11c4:	cf 91       	pop	r28
    11c6:	1f 91       	pop	r17
    11c8:	0f 91       	pop	r16
    11ca:	ff 90       	pop	r15
    11cc:	ef 90       	pop	r14
    11ce:	df 90       	pop	r13
    11d0:	08 95       	ret

000011d2 <_ZN7OneWire4readEv>:
    11d2:	ef 92       	push	r14
    11d4:	ff 92       	push	r15
    11d6:	0f 93       	push	r16
    11d8:	1f 93       	push	r17
    11da:	cf 93       	push	r28
    11dc:	df 93       	push	r29
    11de:	7c 01       	movw	r14, r24
    11e0:	08 e0       	ldi	r16, 0x08	; 8
    11e2:	10 e0       	ldi	r17, 0x00	; 0
    11e4:	c0 e0       	ldi	r28, 0x00	; 0
    11e6:	d1 e0       	ldi	r29, 0x01	; 1
    11e8:	c7 01       	movw	r24, r14
    11ea:	0e 94 8a 08 	call	0x1114	; 0x1114 <_ZN7OneWire8read_bitEv>
    11ee:	81 11       	cpse	r24, r1
    11f0:	cd 2b       	or	r28, r29
    11f2:	dd 0f       	add	r29, r29
    11f4:	01 50       	subi	r16, 0x01	; 1
    11f6:	11 09       	sbc	r17, r1
    11f8:	b9 f7       	brne	.-18     	; 0x11e8 <_ZN7OneWire4readEv+0x16>
    11fa:	8c 2f       	mov	r24, r28
    11fc:	df 91       	pop	r29
    11fe:	cf 91       	pop	r28
    1200:	1f 91       	pop	r17
    1202:	0f 91       	pop	r16
    1204:	ff 90       	pop	r15
    1206:	ef 90       	pop	r14
    1208:	08 95       	ret

0000120a <_ZN7OneWire6selectEPKh>:
    120a:	ef 92       	push	r14
    120c:	ff 92       	push	r15
    120e:	0f 93       	push	r16
    1210:	1f 93       	push	r17
    1212:	cf 93       	push	r28
    1214:	df 93       	push	r29
    1216:	8c 01       	movw	r16, r24
    1218:	7b 01       	movw	r14, r22
    121a:	40 e0       	ldi	r20, 0x00	; 0
    121c:	65 e5       	ldi	r22, 0x55	; 85
    121e:	0e 94 b5 08 	call	0x116a	; 0x116a <_ZN7OneWire5writeEhh>
    1222:	e7 01       	movw	r28, r14
    1224:	88 e0       	ldi	r24, 0x08	; 8
    1226:	e8 0e       	add	r14, r24
    1228:	f1 1c       	adc	r15, r1
    122a:	69 91       	ld	r22, Y+
    122c:	40 e0       	ldi	r20, 0x00	; 0
    122e:	c8 01       	movw	r24, r16
    1230:	0e 94 b5 08 	call	0x116a	; 0x116a <_ZN7OneWire5writeEhh>
    1234:	ce 15       	cp	r28, r14
    1236:	df 05       	cpc	r29, r15
    1238:	c1 f7       	brne	.-16     	; 0x122a <_ZN7OneWire6selectEPKh+0x20>
    123a:	df 91       	pop	r29
    123c:	cf 91       	pop	r28
    123e:	1f 91       	pop	r17
    1240:	0f 91       	pop	r16
    1242:	ff 90       	pop	r15
    1244:	ef 90       	pop	r14
    1246:	08 95       	ret

00001248 <_ZN7OneWire12reset_searchEv>:
    1248:	fc 01       	movw	r30, r24
    124a:	13 86       	std	Z+11, r1	; 0x0b
    124c:	15 86       	std	Z+13, r1	; 0x0d
    124e:	14 86       	std	Z+12, r1	; 0x0c
    1250:	dc 01       	movw	r26, r24
    1252:	1b 96       	adiw	r26, 0x0b	; 11
    1254:	33 96       	adiw	r30, 0x03	; 3
    1256:	1e 92       	st	-X, r1
    1258:	ae 17       	cp	r26, r30
    125a:	bf 07       	cpc	r27, r31
    125c:	e1 f7       	brne	.-8      	; 0x1256 <_ZN7OneWire12reset_searchEv+0xe>
    125e:	08 95       	ret

00001260 <_ZN7OneWire5beginEh>:
    1260:	1f 93       	push	r17
    1262:	cf 93       	push	r28
    1264:	df 93       	push	r29
    1266:	ec 01       	movw	r28, r24
    1268:	16 2f       	mov	r17, r22
    126a:	60 e0       	ldi	r22, 0x00	; 0
    126c:	81 2f       	mov	r24, r17
    126e:	0e 94 75 12 	call	0x24ea	; 0x24ea <pinMode>
    1272:	61 2f       	mov	r22, r17
    1274:	70 e0       	ldi	r23, 0x00	; 0
    1276:	fb 01       	movw	r30, r22
    1278:	ea 53       	subi	r30, 0x3A	; 58
    127a:	ff 4f       	sbci	r31, 0xFF	; 255
    127c:	e4 91       	lpm	r30, Z
    127e:	e8 83       	st	Y, r30
    1280:	fb 01       	movw	r30, r22
    1282:	e6 52       	subi	r30, 0x26	; 38
    1284:	ff 4f       	sbci	r31, 0xFF	; 255
    1286:	e4 91       	lpm	r30, Z
    1288:	f0 e0       	ldi	r31, 0x00	; 0
    128a:	ee 0f       	add	r30, r30
    128c:	ff 1f       	adc	r31, r31
    128e:	e2 51       	subi	r30, 0x12	; 18
    1290:	ff 4f       	sbci	r31, 0xFF	; 255
    1292:	85 91       	lpm	r24, Z+
    1294:	94 91       	lpm	r25, Z
    1296:	9a 83       	std	Y+2, r25	; 0x02
    1298:	89 83       	std	Y+1, r24	; 0x01
    129a:	ce 01       	movw	r24, r28
    129c:	df 91       	pop	r29
    129e:	cf 91       	pop	r28
    12a0:	1f 91       	pop	r17
    12a2:	0c 94 24 09 	jmp	0x1248	; 0x1248 <_ZN7OneWire12reset_searchEv>

000012a6 <_ZN7OneWire6searchEPhb>:
// search state.
// Return TRUE  : device found, ROM number in ROM_NO buffer
//        FALSE : device not found, end of search
//
bool OneWire::search(uint8_t *newAddr, bool search_mode /* = true */)
{
    12a6:	bf 92       	push	r11
    12a8:	cf 92       	push	r12
    12aa:	df 92       	push	r13
    12ac:	ef 92       	push	r14
    12ae:	ff 92       	push	r15
    12b0:	0f 93       	push	r16
    12b2:	1f 93       	push	r17
    12b4:	cf 93       	push	r28
    12b6:	df 93       	push	r29
    12b8:	ec 01       	movw	r28, r24
    12ba:	6b 01       	movw	r12, r22
    12bc:	14 2f       	mov	r17, r20
   rom_byte_number = 0;
   rom_byte_mask = 1;
   search_result = false;

   // if the last call was not the last one
   if (!LastDeviceFlag) {
    12be:	8d 85       	ldd	r24, Y+13	; 0x0d
    12c0:	81 11       	cpse	r24, r1
    12c2:	05 c0       	rjmp	.+10     	; 0x12ce <_ZN7OneWire6searchEPhb+0x28>
      // 1-Wire reset
      if (!reset()) {
    12c4:	ce 01       	movw	r24, r28
    12c6:	0e 94 18 08 	call	0x1030	; 0x1030 <_ZN7OneWire5resetEv>
    12ca:	81 11       	cpse	r24, r1
    12cc:	05 c0       	rjmp	.+10     	; 0x12d8 <_ZN7OneWire6searchEPhb+0x32>
         // reset the search
         LastDiscrepancy = 0;
    12ce:	1b 86       	std	Y+11, r1	; 0x0b
         LastDeviceFlag = false;
    12d0:	1d 86       	std	Y+13, r1	; 0x0d
         LastFamilyDiscrepancy = 0;
    12d2:	1c 86       	std	Y+12, r1	; 0x0c
         return false;
    12d4:	80 e0       	ldi	r24, 0x00	; 0
    12d6:	64 c0       	rjmp	.+200    	; 0x13a0 <_ZN7OneWire6searchEPhb+0xfa>
      }

      // issue the search command
      if (search_mode == true) {
        write(0xF0);   // NORMAL SEARCH
    12d8:	40 e0       	ldi	r20, 0x00	; 0
         LastFamilyDiscrepancy = 0;
         return false;
      }

      // issue the search command
      if (search_mode == true) {
    12da:	11 23       	and	r17, r17
    12dc:	11 f0       	breq	.+4      	; 0x12e2 <_ZN7OneWire6searchEPhb+0x3c>
        write(0xF0);   // NORMAL SEARCH
    12de:	60 ef       	ldi	r22, 0xF0	; 240
    12e0:	01 c0       	rjmp	.+2      	; 0x12e4 <_ZN7OneWire6searchEPhb+0x3e>
      } else {
        write(0xEC);   // CONDITIONAL SEARCH
    12e2:	6c ee       	ldi	r22, 0xEC	; 236
    12e4:	ce 01       	movw	r24, r28
    12e6:	0e 94 b5 08 	call	0x116a	; 0x116a <_ZN7OneWire5writeEhh>
// search state.
// Return TRUE  : device found, ROM number in ROM_NO buffer
//        FALSE : device not found, end of search
//
bool OneWire::search(uint8_t *newAddr, bool search_mode /* = true */)
{
    12ea:	01 e0       	ldi	r16, 0x01	; 1
    12ec:	e1 2c       	mov	r14, r1
    12ee:	b1 2c       	mov	r11, r1
    12f0:	11 e0       	ldi	r17, 0x01	; 1

      // loop to do the search
      do
      {
         // read a bit and its complement
         id_bit = read_bit();
    12f2:	ce 01       	movw	r24, r28
    12f4:	0e 94 8a 08 	call	0x1114	; 0x1114 <_ZN7OneWire8read_bitEv>
    12f8:	f8 2e       	mov	r15, r24
         cmp_id_bit = read_bit();
    12fa:	ce 01       	movw	r24, r28
    12fc:	0e 94 8a 08 	call	0x1114	; 0x1114 <_ZN7OneWire8read_bitEv>

         // check for no devices on 1-wire
         if ((id_bit == 1) && (cmp_id_bit == 1)) {
    1300:	91 e0       	ldi	r25, 0x01	; 1
    1302:	f9 12       	cpse	r15, r25
    1304:	03 c0       	rjmp	.+6      	; 0x130c <_ZN7OneWire6searchEPhb+0x66>
    1306:	81 30       	cpi	r24, 0x01	; 1
    1308:	b1 f4       	brne	.+44     	; 0x1336 <_ZN7OneWire6searchEPhb+0x90>
    130a:	34 c0       	rjmp	.+104    	; 0x1374 <_ZN7OneWire6searchEPhb+0xce>
    130c:	2e 2d       	mov	r18, r14
    130e:	30 e0       	ldi	r19, 0x00	; 0
            break;
         } else {
            // all devices coupled have 0 or 1
            if (id_bit != cmp_id_bit) {
    1310:	f8 12       	cpse	r15, r24
    1312:	1b c0       	rjmp	.+54     	; 0x134a <_ZN7OneWire6searchEPhb+0xa4>
               search_direction = id_bit;  // bit write value for search
            } else {
               // if this discrepancy if before the Last Discrepancy
               // on a previous next then pick the same as last time
               if (id_bit_number < LastDiscrepancy) {
    1314:	8b 85       	ldd	r24, Y+11	; 0x0b
    1316:	18 17       	cp	r17, r24
    1318:	38 f4       	brcc	.+14     	; 0x1328 <_ZN7OneWire6searchEPhb+0x82>
                  search_direction = ((ROM_NO[rom_byte_number] & rom_byte_mask) > 0);
    131a:	fe 01       	movw	r30, r28
    131c:	e2 0f       	add	r30, r18
    131e:	f3 1f       	adc	r31, r19
    1320:	83 81       	ldd	r24, Z+3	; 0x03
    1322:	80 23       	and	r24, r16
    1324:	41 f4       	brne	.+16     	; 0x1336 <_ZN7OneWire6searchEPhb+0x90>
    1326:	02 c0       	rjmp	.+4      	; 0x132c <_ZN7OneWire6searchEPhb+0x86>
               } else {
                  // if equal to last pick 1, if not then pick 0
                  search_direction = (id_bit_number == LastDiscrepancy);
    1328:	18 17       	cp	r17, r24
    132a:	29 f0       	breq	.+10     	; 0x1336 <_ZN7OneWire6searchEPhb+0x90>
    132c:	f1 2c       	mov	r15, r1
               // if 0 was picked then record its position in LastZero
               if (search_direction == 0) {
                  last_zero = id_bit_number;

                  // check for Last discrepancy in family
                  if (last_zero < 9)
    132e:	19 30       	cpi	r17, 0x09	; 9
    1330:	58 f4       	brcc	.+22     	; 0x1348 <_ZN7OneWire6searchEPhb+0xa2>
                     LastFamilyDiscrepancy = last_zero;
    1332:	1c 87       	std	Y+12, r17	; 0x0c
    1334:	09 c0       	rjmp	.+18     	; 0x1348 <_ZN7OneWire6searchEPhb+0xa2>
            }

            // set or clear the bit in the ROM byte rom_byte_number
            // with mask rom_byte_mask
            if (search_direction == 1)
              ROM_NO[rom_byte_number] |= rom_byte_mask;
    1336:	fe 01       	movw	r30, r28
    1338:	ee 0d       	add	r30, r14
    133a:	f1 1d       	adc	r31, r1
    133c:	83 81       	ldd	r24, Z+3	; 0x03
    133e:	80 2b       	or	r24, r16
    1340:	83 83       	std	Z+3, r24	; 0x03
    1342:	ff 24       	eor	r15, r15
    1344:	f3 94       	inc	r15
    1346:	09 c0       	rjmp	.+18     	; 0x135a <_ZN7OneWire6searchEPhb+0xb4>
// search state.
// Return TRUE  : device found, ROM number in ROM_NO buffer
//        FALSE : device not found, end of search
//
bool OneWire::search(uint8_t *newAddr, bool search_mode /* = true */)
{
    1348:	b1 2e       	mov	r11, r17
            // set or clear the bit in the ROM byte rom_byte_number
            // with mask rom_byte_mask
            if (search_direction == 1)
              ROM_NO[rom_byte_number] |= rom_byte_mask;
            else
              ROM_NO[rom_byte_number] &= ~rom_byte_mask;
    134a:	fe 01       	movw	r30, r28
    134c:	e2 0f       	add	r30, r18
    134e:	f3 1f       	adc	r31, r19
    1350:	93 81       	ldd	r25, Z+3	; 0x03
    1352:	80 2f       	mov	r24, r16
    1354:	80 95       	com	r24
    1356:	89 23       	and	r24, r25
    1358:	83 83       	std	Z+3, r24	; 0x03

            // serial number search direction write bit
            write_bit(search_direction);
    135a:	6f 2d       	mov	r22, r15
    135c:	ce 01       	movw	r24, r28
    135e:	0e 94 57 08 	call	0x10ae	; 0x10ae <_ZN7OneWire9write_bitEh>

            // increment the byte counter id_bit_number
            // and shift the mask rom_byte_mask
            id_bit_number++;
    1362:	1f 5f       	subi	r17, 0xFF	; 255
            rom_byte_mask <<= 1;
    1364:	00 0f       	add	r16, r16

            // if the mask is 0 then go to new SerialNum byte rom_byte_number and reset mask
            if (rom_byte_mask == 0) {
    1366:	11 f4       	brne	.+4      	; 0x136c <_ZN7OneWire6searchEPhb+0xc6>
                rom_byte_number++;
    1368:	e3 94       	inc	r14
                rom_byte_mask = 1;
    136a:	01 e0       	ldi	r16, 0x01	; 1
            }
         }
      }
      while(rom_byte_number < 8);  // loop until through all ROM bytes 0-7
    136c:	87 e0       	ldi	r24, 0x07	; 7
    136e:	8e 15       	cp	r24, r14
    1370:	08 f0       	brcs	.+2      	; 0x1374 <_ZN7OneWire6searchEPhb+0xce>
    1372:	bf cf       	rjmp	.-130    	; 0x12f2 <_ZN7OneWire6searchEPhb+0x4c>

      // if the search was successful then
      if (!(id_bit_number < 65)) {
    1374:	11 34       	cpi	r17, 0x41	; 65
    1376:	08 f4       	brcc	.+2      	; 0x137a <_ZN7OneWire6searchEPhb+0xd4>
    1378:	aa cf       	rjmp	.-172    	; 0x12ce <_ZN7OneWire6searchEPhb+0x28>
         // search successful so set LastDiscrepancy,LastDeviceFlag,search_result
         LastDiscrepancy = last_zero;
    137a:	bb 86       	std	Y+11, r11	; 0x0b

         // check for last device
         if (LastDiscrepancy == 0) {
    137c:	b1 10       	cpse	r11, r1
    137e:	02 c0       	rjmp	.+4      	; 0x1384 <_ZN7OneWire6searchEPhb+0xde>
            LastDeviceFlag = true;
    1380:	81 e0       	ldi	r24, 0x01	; 1
    1382:	8d 87       	std	Y+13, r24	; 0x0d
         search_result = true;
      }
   }

   // if no device found then reset counters so next 'search' will be like a first
   if (!search_result || !ROM_NO[0]) {
    1384:	8b 81       	ldd	r24, Y+3	; 0x03
    1386:	88 23       	and	r24, r24
    1388:	09 f4       	brne	.+2      	; 0x138c <_ZN7OneWire6searchEPhb+0xe6>
    138a:	a1 cf       	rjmp	.-190    	; 0x12ce <_ZN7OneWire6searchEPhb+0x28>
    138c:	de 01       	movw	r26, r28
    138e:	13 96       	adiw	r26, 0x03	; 3
    1390:	f6 01       	movw	r30, r12
    1392:	2b 96       	adiw	r28, 0x0b	; 11
      LastDiscrepancy = 0;
      LastDeviceFlag = false;
      LastFamilyDiscrepancy = 0;
      search_result = false;
   } else {
      for (int i = 0; i < 8; i++) newAddr[i] = ROM_NO[i];
    1394:	8d 91       	ld	r24, X+
    1396:	81 93       	st	Z+, r24
    1398:	ca 17       	cp	r28, r26
    139a:	db 07       	cpc	r29, r27
    139c:	d9 f7       	brne	.-10     	; 0x1394 <_ZN7OneWire6searchEPhb+0xee>
    139e:	81 e0       	ldi	r24, 0x01	; 1
   }
   return search_result;
  }
    13a0:	df 91       	pop	r29
    13a2:	cf 91       	pop	r28
    13a4:	1f 91       	pop	r17
    13a6:	0f 91       	pop	r16
    13a8:	ff 90       	pop	r15
    13aa:	ef 90       	pop	r14
    13ac:	df 90       	pop	r13
    13ae:	cf 90       	pop	r12
    13b0:	bf 90       	pop	r11
    13b2:	08 95       	ret

000013b4 <_ZN7OneWire4crc8EPKhh>:
};

// Compute a Dallas Semiconductor 8 bit CRC. These show up in the ROM
// and the registers.  (Use tiny 2x16 entry CRC table)
uint8_t OneWire::crc8(const uint8_t *addr, uint8_t len)
{
    13b4:	dc 01       	movw	r26, r24
	uint8_t crc = 0;
    13b6:	80 e0       	ldi	r24, 0x00	; 0

	while (len--) {
    13b8:	61 50       	subi	r22, 0x01	; 1
    13ba:	98 f0       	brcs	.+38     	; 0x13e2 <_ZN7OneWire4crc8EPKhh+0x2e>
		crc = *addr++ ^ crc;  // just re-using crc as intermediate
    13bc:	2d 91       	ld	r18, X+
    13be:	98 2f       	mov	r25, r24
    13c0:	92 27       	eor	r25, r18
		crc = pgm_read_byte(dscrc2x16_table + (crc & 0x0f)) ^
    13c2:	e9 2f       	mov	r30, r25
    13c4:	ef 70       	andi	r30, 0x0F	; 15
    13c6:	f0 e0       	ldi	r31, 0x00	; 0
    13c8:	ee 56       	subi	r30, 0x6E	; 110
    13ca:	ff 4f       	sbci	r31, 0xFF	; 255
    13cc:	24 91       	lpm	r18, Z
		pgm_read_byte(dscrc2x16_table + 16 + ((crc >> 4) & 0x0f));
    13ce:	92 95       	swap	r25
    13d0:	9f 70       	andi	r25, 0x0F	; 15
    13d2:	e9 2f       	mov	r30, r25
    13d4:	f0 e0       	ldi	r31, 0x00	; 0
    13d6:	ee 55       	subi	r30, 0x5E	; 94
    13d8:	ff 4f       	sbci	r31, 0xFF	; 255
    13da:	e4 91       	lpm	r30, Z
    13dc:	82 2f       	mov	r24, r18
    13de:	8e 27       	eor	r24, r30
// and the registers.  (Use tiny 2x16 entry CRC table)
uint8_t OneWire::crc8(const uint8_t *addr, uint8_t len)
{
	uint8_t crc = 0;

	while (len--) {
    13e0:	eb cf       	rjmp	.-42     	; 0x13b8 <_ZN7OneWire4crc8EPKhh+0x4>
		crc = pgm_read_byte(dscrc2x16_table + (crc & 0x0f)) ^
		pgm_read_byte(dscrc2x16_table + 16 + ((crc >> 4) & 0x0f));
	}

	return crc;
}
    13e2:	08 95       	ret

000013e4 <_Z6phInitv>:
}

void calibratePH(long temperaturePH) {
	float voltage = analogRead(PH_PIN)/1024.0*5000;
	ph.calibration(voltage, temperaturePH);
    13e4:	8a ea       	ldi	r24, 0xAA	; 170
    13e6:	93 e0       	ldi	r25, 0x03	; 3
    13e8:	0c 94 de 00 	jmp	0x1bc	; 0x1bc <_ZN10DFRobot_PH5beginEv>

000013ec <_Z5getPHl>:
    13ec:	cf 92       	push	r12
    13ee:	df 92       	push	r13
    13f0:	ef 92       	push	r14
    13f2:	ff 92       	push	r15
    13f4:	0f 93       	push	r16
    13f6:	1f 93       	push	r17
    13f8:	cf 93       	push	r28
    13fa:	df 93       	push	r29
    13fc:	6b 01       	movw	r12, r22
    13fe:	7c 01       	movw	r14, r24
    1400:	8e e0       	ldi	r24, 0x0E	; 14
    1402:	0e 94 d0 11 	call	0x23a0	; 0x23a0 <analogRead>
    1406:	ec 01       	movw	r28, r24
    1408:	c7 01       	movw	r24, r14
    140a:	b6 01       	movw	r22, r12
    140c:	0e 94 51 0b 	call	0x16a2	; 0x16a2 <__floatsisf>
    1410:	6b 01       	movw	r12, r22
    1412:	7c 01       	movw	r14, r24
    1414:	be 01       	movw	r22, r28
    1416:	dd 0f       	add	r29, r29
    1418:	88 0b       	sbc	r24, r24
    141a:	99 0b       	sbc	r25, r25
    141c:	0e 94 51 0b 	call	0x16a2	; 0x16a2 <__floatsisf>
    1420:	20 e0       	ldi	r18, 0x00	; 0
    1422:	30 e0       	ldi	r19, 0x00	; 0
    1424:	40 e8       	ldi	r20, 0x80	; 128
    1426:	5a e3       	ldi	r21, 0x3A	; 58
    1428:	0e 94 06 0c 	call	0x180c	; 0x180c <__mulsf3>
    142c:	20 e0       	ldi	r18, 0x00	; 0
    142e:	30 e4       	ldi	r19, 0x40	; 64
    1430:	4c e9       	ldi	r20, 0x9C	; 156
    1432:	55 e4       	ldi	r21, 0x45	; 69
    1434:	0e 94 06 0c 	call	0x180c	; 0x180c <__mulsf3>
    1438:	ab 01       	movw	r20, r22
    143a:	bc 01       	movw	r22, r24
    143c:	97 01       	movw	r18, r14
    143e:	86 01       	movw	r16, r12
    1440:	8a ea       	ldi	r24, 0xAA	; 170
    1442:	93 e0       	ldi	r25, 0x03	; 3
    1444:	0e 94 8d 01 	call	0x31a	; 0x31a <_ZN10DFRobot_PH6readPHEff>
    1448:	df 91       	pop	r29
    144a:	cf 91       	pop	r28
    144c:	1f 91       	pop	r17
    144e:	0f 91       	pop	r16
    1450:	ff 90       	pop	r15
    1452:	ef 90       	pop	r14
    1454:	df 90       	pop	r13
    1456:	cf 90       	pop	r12
    1458:	08 95       	ret

0000145a <_GLOBAL__sub_I_ph>:
#include "phSensor.h"

DFRobot_PH ph;
    145a:	8a ea       	ldi	r24, 0xAA	; 170
    145c:	93 e0       	ldi	r25, 0x03	; 3
    145e:	0c 94 b7 00 	jmp	0x16e	; 0x16e <_ZN10DFRobot_PHC1Ev>

00001462 <_GLOBAL__sub_D_ph>:
    1462:	8a ea       	ldi	r24, 0xAA	; 170
    1464:	93 e0       	ldi	r25, 0x03	; 3
    1466:	0c 94 dd 00 	jmp	0x1ba	; 0x1ba <_ZN10DFRobot_PHD1Ev>

0000146a <__subsf3>:
    146a:	50 58       	subi	r21, 0x80	; 128

0000146c <__addsf3>:
    146c:	bb 27       	eor	r27, r27
    146e:	aa 27       	eor	r26, r26
    1470:	0e 94 4d 0a 	call	0x149a	; 0x149a <__addsf3x>
    1474:	0c 94 c7 0b 	jmp	0x178e	; 0x178e <__fp_round>
    1478:	0e 94 b9 0b 	call	0x1772	; 0x1772 <__fp_pscA>
    147c:	38 f0       	brcs	.+14     	; 0x148c <__addsf3+0x20>
    147e:	0e 94 c0 0b 	call	0x1780	; 0x1780 <__fp_pscB>
    1482:	20 f0       	brcs	.+8      	; 0x148c <__addsf3+0x20>
    1484:	39 f4       	brne	.+14     	; 0x1494 <__addsf3+0x28>
    1486:	9f 3f       	cpi	r25, 0xFF	; 255
    1488:	19 f4       	brne	.+6      	; 0x1490 <__addsf3+0x24>
    148a:	26 f4       	brtc	.+8      	; 0x1494 <__addsf3+0x28>
    148c:	0c 94 b6 0b 	jmp	0x176c	; 0x176c <__fp_nan>
    1490:	0e f4       	brtc	.+2      	; 0x1494 <__addsf3+0x28>
    1492:	e0 95       	com	r30
    1494:	e7 fb       	bst	r30, 7
    1496:	0c 94 b0 0b 	jmp	0x1760	; 0x1760 <__fp_inf>

0000149a <__addsf3x>:
    149a:	e9 2f       	mov	r30, r25
    149c:	0e 94 d8 0b 	call	0x17b0	; 0x17b0 <__fp_split3>
    14a0:	58 f3       	brcs	.-42     	; 0x1478 <__addsf3+0xc>
    14a2:	ba 17       	cp	r27, r26
    14a4:	62 07       	cpc	r22, r18
    14a6:	73 07       	cpc	r23, r19
    14a8:	84 07       	cpc	r24, r20
    14aa:	95 07       	cpc	r25, r21
    14ac:	20 f0       	brcs	.+8      	; 0x14b6 <__addsf3x+0x1c>
    14ae:	79 f4       	brne	.+30     	; 0x14ce <__addsf3x+0x34>
    14b0:	a6 f5       	brtc	.+104    	; 0x151a <__addsf3x+0x80>
    14b2:	0c 94 fa 0b 	jmp	0x17f4	; 0x17f4 <__fp_zero>
    14b6:	0e f4       	brtc	.+2      	; 0x14ba <__addsf3x+0x20>
    14b8:	e0 95       	com	r30
    14ba:	0b 2e       	mov	r0, r27
    14bc:	ba 2f       	mov	r27, r26
    14be:	a0 2d       	mov	r26, r0
    14c0:	0b 01       	movw	r0, r22
    14c2:	b9 01       	movw	r22, r18
    14c4:	90 01       	movw	r18, r0
    14c6:	0c 01       	movw	r0, r24
    14c8:	ca 01       	movw	r24, r20
    14ca:	a0 01       	movw	r20, r0
    14cc:	11 24       	eor	r1, r1
    14ce:	ff 27       	eor	r31, r31
    14d0:	59 1b       	sub	r21, r25
    14d2:	99 f0       	breq	.+38     	; 0x14fa <__addsf3x+0x60>
    14d4:	59 3f       	cpi	r21, 0xF9	; 249
    14d6:	50 f4       	brcc	.+20     	; 0x14ec <__addsf3x+0x52>
    14d8:	50 3e       	cpi	r21, 0xE0	; 224
    14da:	68 f1       	brcs	.+90     	; 0x1536 <__addsf3x+0x9c>
    14dc:	1a 16       	cp	r1, r26
    14de:	f0 40       	sbci	r31, 0x00	; 0
    14e0:	a2 2f       	mov	r26, r18
    14e2:	23 2f       	mov	r18, r19
    14e4:	34 2f       	mov	r19, r20
    14e6:	44 27       	eor	r20, r20
    14e8:	58 5f       	subi	r21, 0xF8	; 248
    14ea:	f3 cf       	rjmp	.-26     	; 0x14d2 <__addsf3x+0x38>
    14ec:	46 95       	lsr	r20
    14ee:	37 95       	ror	r19
    14f0:	27 95       	ror	r18
    14f2:	a7 95       	ror	r26
    14f4:	f0 40       	sbci	r31, 0x00	; 0
    14f6:	53 95       	inc	r21
    14f8:	c9 f7       	brne	.-14     	; 0x14ec <__addsf3x+0x52>
    14fa:	7e f4       	brtc	.+30     	; 0x151a <__addsf3x+0x80>
    14fc:	1f 16       	cp	r1, r31
    14fe:	ba 0b       	sbc	r27, r26
    1500:	62 0b       	sbc	r22, r18
    1502:	73 0b       	sbc	r23, r19
    1504:	84 0b       	sbc	r24, r20
    1506:	ba f0       	brmi	.+46     	; 0x1536 <__addsf3x+0x9c>
    1508:	91 50       	subi	r25, 0x01	; 1
    150a:	a1 f0       	breq	.+40     	; 0x1534 <__addsf3x+0x9a>
    150c:	ff 0f       	add	r31, r31
    150e:	bb 1f       	adc	r27, r27
    1510:	66 1f       	adc	r22, r22
    1512:	77 1f       	adc	r23, r23
    1514:	88 1f       	adc	r24, r24
    1516:	c2 f7       	brpl	.-16     	; 0x1508 <__addsf3x+0x6e>
    1518:	0e c0       	rjmp	.+28     	; 0x1536 <__addsf3x+0x9c>
    151a:	ba 0f       	add	r27, r26
    151c:	62 1f       	adc	r22, r18
    151e:	73 1f       	adc	r23, r19
    1520:	84 1f       	adc	r24, r20
    1522:	48 f4       	brcc	.+18     	; 0x1536 <__addsf3x+0x9c>
    1524:	87 95       	ror	r24
    1526:	77 95       	ror	r23
    1528:	67 95       	ror	r22
    152a:	b7 95       	ror	r27
    152c:	f7 95       	ror	r31
    152e:	9e 3f       	cpi	r25, 0xFE	; 254
    1530:	08 f0       	brcs	.+2      	; 0x1534 <__addsf3x+0x9a>
    1532:	b0 cf       	rjmp	.-160    	; 0x1494 <__addsf3+0x28>
    1534:	93 95       	inc	r25
    1536:	88 0f       	add	r24, r24
    1538:	08 f0       	brcs	.+2      	; 0x153c <__addsf3x+0xa2>
    153a:	99 27       	eor	r25, r25
    153c:	ee 0f       	add	r30, r30
    153e:	97 95       	ror	r25
    1540:	87 95       	ror	r24
    1542:	08 95       	ret

00001544 <__cmpsf2>:
    1544:	0e 94 8c 0b 	call	0x1718	; 0x1718 <__fp_cmp>
    1548:	08 f4       	brcc	.+2      	; 0x154c <__cmpsf2+0x8>
    154a:	81 e0       	ldi	r24, 0x01	; 1
    154c:	08 95       	ret

0000154e <__divsf3>:
    154e:	0e 94 bb 0a 	call	0x1576	; 0x1576 <__divsf3x>
    1552:	0c 94 c7 0b 	jmp	0x178e	; 0x178e <__fp_round>
    1556:	0e 94 c0 0b 	call	0x1780	; 0x1780 <__fp_pscB>
    155a:	58 f0       	brcs	.+22     	; 0x1572 <__divsf3+0x24>
    155c:	0e 94 b9 0b 	call	0x1772	; 0x1772 <__fp_pscA>
    1560:	40 f0       	brcs	.+16     	; 0x1572 <__divsf3+0x24>
    1562:	29 f4       	brne	.+10     	; 0x156e <__divsf3+0x20>
    1564:	5f 3f       	cpi	r21, 0xFF	; 255
    1566:	29 f0       	breq	.+10     	; 0x1572 <__divsf3+0x24>
    1568:	0c 94 b0 0b 	jmp	0x1760	; 0x1760 <__fp_inf>
    156c:	51 11       	cpse	r21, r1
    156e:	0c 94 fb 0b 	jmp	0x17f6	; 0x17f6 <__fp_szero>
    1572:	0c 94 b6 0b 	jmp	0x176c	; 0x176c <__fp_nan>

00001576 <__divsf3x>:
    1576:	0e 94 d8 0b 	call	0x17b0	; 0x17b0 <__fp_split3>
    157a:	68 f3       	brcs	.-38     	; 0x1556 <__divsf3+0x8>

0000157c <__divsf3_pse>:
    157c:	99 23       	and	r25, r25
    157e:	b1 f3       	breq	.-20     	; 0x156c <__divsf3+0x1e>
    1580:	55 23       	and	r21, r21
    1582:	91 f3       	breq	.-28     	; 0x1568 <__divsf3+0x1a>
    1584:	95 1b       	sub	r25, r21
    1586:	55 0b       	sbc	r21, r21
    1588:	bb 27       	eor	r27, r27
    158a:	aa 27       	eor	r26, r26
    158c:	62 17       	cp	r22, r18
    158e:	73 07       	cpc	r23, r19
    1590:	84 07       	cpc	r24, r20
    1592:	38 f0       	brcs	.+14     	; 0x15a2 <__divsf3_pse+0x26>
    1594:	9f 5f       	subi	r25, 0xFF	; 255
    1596:	5f 4f       	sbci	r21, 0xFF	; 255
    1598:	22 0f       	add	r18, r18
    159a:	33 1f       	adc	r19, r19
    159c:	44 1f       	adc	r20, r20
    159e:	aa 1f       	adc	r26, r26
    15a0:	a9 f3       	breq	.-22     	; 0x158c <__divsf3_pse+0x10>
    15a2:	35 d0       	rcall	.+106    	; 0x160e <__divsf3_pse+0x92>
    15a4:	0e 2e       	mov	r0, r30
    15a6:	3a f0       	brmi	.+14     	; 0x15b6 <__divsf3_pse+0x3a>
    15a8:	e0 e8       	ldi	r30, 0x80	; 128
    15aa:	32 d0       	rcall	.+100    	; 0x1610 <__divsf3_pse+0x94>
    15ac:	91 50       	subi	r25, 0x01	; 1
    15ae:	50 40       	sbci	r21, 0x00	; 0
    15b0:	e6 95       	lsr	r30
    15b2:	00 1c       	adc	r0, r0
    15b4:	ca f7       	brpl	.-14     	; 0x15a8 <__divsf3_pse+0x2c>
    15b6:	2b d0       	rcall	.+86     	; 0x160e <__divsf3_pse+0x92>
    15b8:	fe 2f       	mov	r31, r30
    15ba:	29 d0       	rcall	.+82     	; 0x160e <__divsf3_pse+0x92>
    15bc:	66 0f       	add	r22, r22
    15be:	77 1f       	adc	r23, r23
    15c0:	88 1f       	adc	r24, r24
    15c2:	bb 1f       	adc	r27, r27
    15c4:	26 17       	cp	r18, r22
    15c6:	37 07       	cpc	r19, r23
    15c8:	48 07       	cpc	r20, r24
    15ca:	ab 07       	cpc	r26, r27
    15cc:	b0 e8       	ldi	r27, 0x80	; 128
    15ce:	09 f0       	breq	.+2      	; 0x15d2 <__divsf3_pse+0x56>
    15d0:	bb 0b       	sbc	r27, r27
    15d2:	80 2d       	mov	r24, r0
    15d4:	bf 01       	movw	r22, r30
    15d6:	ff 27       	eor	r31, r31
    15d8:	93 58       	subi	r25, 0x83	; 131
    15da:	5f 4f       	sbci	r21, 0xFF	; 255
    15dc:	3a f0       	brmi	.+14     	; 0x15ec <__divsf3_pse+0x70>
    15de:	9e 3f       	cpi	r25, 0xFE	; 254
    15e0:	51 05       	cpc	r21, r1
    15e2:	78 f0       	brcs	.+30     	; 0x1602 <__divsf3_pse+0x86>
    15e4:	0c 94 b0 0b 	jmp	0x1760	; 0x1760 <__fp_inf>
    15e8:	0c 94 fb 0b 	jmp	0x17f6	; 0x17f6 <__fp_szero>
    15ec:	5f 3f       	cpi	r21, 0xFF	; 255
    15ee:	e4 f3       	brlt	.-8      	; 0x15e8 <__divsf3_pse+0x6c>
    15f0:	98 3e       	cpi	r25, 0xE8	; 232
    15f2:	d4 f3       	brlt	.-12     	; 0x15e8 <__divsf3_pse+0x6c>
    15f4:	86 95       	lsr	r24
    15f6:	77 95       	ror	r23
    15f8:	67 95       	ror	r22
    15fa:	b7 95       	ror	r27
    15fc:	f7 95       	ror	r31
    15fe:	9f 5f       	subi	r25, 0xFF	; 255
    1600:	c9 f7       	brne	.-14     	; 0x15f4 <__divsf3_pse+0x78>
    1602:	88 0f       	add	r24, r24
    1604:	91 1d       	adc	r25, r1
    1606:	96 95       	lsr	r25
    1608:	87 95       	ror	r24
    160a:	97 f9       	bld	r25, 7
    160c:	08 95       	ret
    160e:	e1 e0       	ldi	r30, 0x01	; 1
    1610:	66 0f       	add	r22, r22
    1612:	77 1f       	adc	r23, r23
    1614:	88 1f       	adc	r24, r24
    1616:	bb 1f       	adc	r27, r27
    1618:	62 17       	cp	r22, r18
    161a:	73 07       	cpc	r23, r19
    161c:	84 07       	cpc	r24, r20
    161e:	ba 07       	cpc	r27, r26
    1620:	20 f0       	brcs	.+8      	; 0x162a <__divsf3_pse+0xae>
    1622:	62 1b       	sub	r22, r18
    1624:	73 0b       	sbc	r23, r19
    1626:	84 0b       	sbc	r24, r20
    1628:	ba 0b       	sbc	r27, r26
    162a:	ee 1f       	adc	r30, r30
    162c:	88 f7       	brcc	.-30     	; 0x1610 <__divsf3_pse+0x94>
    162e:	e0 95       	com	r30
    1630:	08 95       	ret

00001632 <__fixsfsi>:
    1632:	0e 94 20 0b 	call	0x1640	; 0x1640 <__fixunssfsi>
    1636:	68 94       	set
    1638:	b1 11       	cpse	r27, r1
    163a:	0c 94 fb 0b 	jmp	0x17f6	; 0x17f6 <__fp_szero>
    163e:	08 95       	ret

00001640 <__fixunssfsi>:
    1640:	0e 94 e0 0b 	call	0x17c0	; 0x17c0 <__fp_splitA>
    1644:	88 f0       	brcs	.+34     	; 0x1668 <__fixunssfsi+0x28>
    1646:	9f 57       	subi	r25, 0x7F	; 127
    1648:	98 f0       	brcs	.+38     	; 0x1670 <__fixunssfsi+0x30>
    164a:	b9 2f       	mov	r27, r25
    164c:	99 27       	eor	r25, r25
    164e:	b7 51       	subi	r27, 0x17	; 23
    1650:	b0 f0       	brcs	.+44     	; 0x167e <__fixunssfsi+0x3e>
    1652:	e1 f0       	breq	.+56     	; 0x168c <__fixunssfsi+0x4c>
    1654:	66 0f       	add	r22, r22
    1656:	77 1f       	adc	r23, r23
    1658:	88 1f       	adc	r24, r24
    165a:	99 1f       	adc	r25, r25
    165c:	1a f0       	brmi	.+6      	; 0x1664 <__fixunssfsi+0x24>
    165e:	ba 95       	dec	r27
    1660:	c9 f7       	brne	.-14     	; 0x1654 <__fixunssfsi+0x14>
    1662:	14 c0       	rjmp	.+40     	; 0x168c <__fixunssfsi+0x4c>
    1664:	b1 30       	cpi	r27, 0x01	; 1
    1666:	91 f0       	breq	.+36     	; 0x168c <__fixunssfsi+0x4c>
    1668:	0e 94 fa 0b 	call	0x17f4	; 0x17f4 <__fp_zero>
    166c:	b1 e0       	ldi	r27, 0x01	; 1
    166e:	08 95       	ret
    1670:	0c 94 fa 0b 	jmp	0x17f4	; 0x17f4 <__fp_zero>
    1674:	67 2f       	mov	r22, r23
    1676:	78 2f       	mov	r23, r24
    1678:	88 27       	eor	r24, r24
    167a:	b8 5f       	subi	r27, 0xF8	; 248
    167c:	39 f0       	breq	.+14     	; 0x168c <__fixunssfsi+0x4c>
    167e:	b9 3f       	cpi	r27, 0xF9	; 249
    1680:	cc f3       	brlt	.-14     	; 0x1674 <__fixunssfsi+0x34>
    1682:	86 95       	lsr	r24
    1684:	77 95       	ror	r23
    1686:	67 95       	ror	r22
    1688:	b3 95       	inc	r27
    168a:	d9 f7       	brne	.-10     	; 0x1682 <__fixunssfsi+0x42>
    168c:	3e f4       	brtc	.+14     	; 0x169c <__fixunssfsi+0x5c>
    168e:	90 95       	com	r25
    1690:	80 95       	com	r24
    1692:	70 95       	com	r23
    1694:	61 95       	neg	r22
    1696:	7f 4f       	sbci	r23, 0xFF	; 255
    1698:	8f 4f       	sbci	r24, 0xFF	; 255
    169a:	9f 4f       	sbci	r25, 0xFF	; 255
    169c:	08 95       	ret

0000169e <__floatunsisf>:
    169e:	e8 94       	clt
    16a0:	09 c0       	rjmp	.+18     	; 0x16b4 <__floatsisf+0x12>

000016a2 <__floatsisf>:
    16a2:	97 fb       	bst	r25, 7
    16a4:	3e f4       	brtc	.+14     	; 0x16b4 <__floatsisf+0x12>
    16a6:	90 95       	com	r25
    16a8:	80 95       	com	r24
    16aa:	70 95       	com	r23
    16ac:	61 95       	neg	r22
    16ae:	7f 4f       	sbci	r23, 0xFF	; 255
    16b0:	8f 4f       	sbci	r24, 0xFF	; 255
    16b2:	9f 4f       	sbci	r25, 0xFF	; 255
    16b4:	99 23       	and	r25, r25
    16b6:	a9 f0       	breq	.+42     	; 0x16e2 <__floatsisf+0x40>
    16b8:	f9 2f       	mov	r31, r25
    16ba:	96 e9       	ldi	r25, 0x96	; 150
    16bc:	bb 27       	eor	r27, r27
    16be:	93 95       	inc	r25
    16c0:	f6 95       	lsr	r31
    16c2:	87 95       	ror	r24
    16c4:	77 95       	ror	r23
    16c6:	67 95       	ror	r22
    16c8:	b7 95       	ror	r27
    16ca:	f1 11       	cpse	r31, r1
    16cc:	f8 cf       	rjmp	.-16     	; 0x16be <__floatsisf+0x1c>
    16ce:	fa f4       	brpl	.+62     	; 0x170e <__floatsisf+0x6c>
    16d0:	bb 0f       	add	r27, r27
    16d2:	11 f4       	brne	.+4      	; 0x16d8 <__floatsisf+0x36>
    16d4:	60 ff       	sbrs	r22, 0
    16d6:	1b c0       	rjmp	.+54     	; 0x170e <__floatsisf+0x6c>
    16d8:	6f 5f       	subi	r22, 0xFF	; 255
    16da:	7f 4f       	sbci	r23, 0xFF	; 255
    16dc:	8f 4f       	sbci	r24, 0xFF	; 255
    16de:	9f 4f       	sbci	r25, 0xFF	; 255
    16e0:	16 c0       	rjmp	.+44     	; 0x170e <__floatsisf+0x6c>
    16e2:	88 23       	and	r24, r24
    16e4:	11 f0       	breq	.+4      	; 0x16ea <__floatsisf+0x48>
    16e6:	96 e9       	ldi	r25, 0x96	; 150
    16e8:	11 c0       	rjmp	.+34     	; 0x170c <__floatsisf+0x6a>
    16ea:	77 23       	and	r23, r23
    16ec:	21 f0       	breq	.+8      	; 0x16f6 <__floatsisf+0x54>
    16ee:	9e e8       	ldi	r25, 0x8E	; 142
    16f0:	87 2f       	mov	r24, r23
    16f2:	76 2f       	mov	r23, r22
    16f4:	05 c0       	rjmp	.+10     	; 0x1700 <__floatsisf+0x5e>
    16f6:	66 23       	and	r22, r22
    16f8:	71 f0       	breq	.+28     	; 0x1716 <__floatsisf+0x74>
    16fa:	96 e8       	ldi	r25, 0x86	; 134
    16fc:	86 2f       	mov	r24, r22
    16fe:	70 e0       	ldi	r23, 0x00	; 0
    1700:	60 e0       	ldi	r22, 0x00	; 0
    1702:	2a f0       	brmi	.+10     	; 0x170e <__floatsisf+0x6c>
    1704:	9a 95       	dec	r25
    1706:	66 0f       	add	r22, r22
    1708:	77 1f       	adc	r23, r23
    170a:	88 1f       	adc	r24, r24
    170c:	da f7       	brpl	.-10     	; 0x1704 <__floatsisf+0x62>
    170e:	88 0f       	add	r24, r24
    1710:	96 95       	lsr	r25
    1712:	87 95       	ror	r24
    1714:	97 f9       	bld	r25, 7
    1716:	08 95       	ret

00001718 <__fp_cmp>:
    1718:	99 0f       	add	r25, r25
    171a:	00 08       	sbc	r0, r0
    171c:	55 0f       	add	r21, r21
    171e:	aa 0b       	sbc	r26, r26
    1720:	e0 e8       	ldi	r30, 0x80	; 128
    1722:	fe ef       	ldi	r31, 0xFE	; 254
    1724:	16 16       	cp	r1, r22
    1726:	17 06       	cpc	r1, r23
    1728:	e8 07       	cpc	r30, r24
    172a:	f9 07       	cpc	r31, r25
    172c:	c0 f0       	brcs	.+48     	; 0x175e <__fp_cmp+0x46>
    172e:	12 16       	cp	r1, r18
    1730:	13 06       	cpc	r1, r19
    1732:	e4 07       	cpc	r30, r20
    1734:	f5 07       	cpc	r31, r21
    1736:	98 f0       	brcs	.+38     	; 0x175e <__fp_cmp+0x46>
    1738:	62 1b       	sub	r22, r18
    173a:	73 0b       	sbc	r23, r19
    173c:	84 0b       	sbc	r24, r20
    173e:	95 0b       	sbc	r25, r21
    1740:	39 f4       	brne	.+14     	; 0x1750 <__fp_cmp+0x38>
    1742:	0a 26       	eor	r0, r26
    1744:	61 f0       	breq	.+24     	; 0x175e <__fp_cmp+0x46>
    1746:	23 2b       	or	r18, r19
    1748:	24 2b       	or	r18, r20
    174a:	25 2b       	or	r18, r21
    174c:	21 f4       	brne	.+8      	; 0x1756 <__fp_cmp+0x3e>
    174e:	08 95       	ret
    1750:	0a 26       	eor	r0, r26
    1752:	09 f4       	brne	.+2      	; 0x1756 <__fp_cmp+0x3e>
    1754:	a1 40       	sbci	r26, 0x01	; 1
    1756:	a6 95       	lsr	r26
    1758:	8f ef       	ldi	r24, 0xFF	; 255
    175a:	81 1d       	adc	r24, r1
    175c:	81 1d       	adc	r24, r1
    175e:	08 95       	ret

00001760 <__fp_inf>:
    1760:	97 f9       	bld	r25, 7
    1762:	9f 67       	ori	r25, 0x7F	; 127
    1764:	80 e8       	ldi	r24, 0x80	; 128
    1766:	70 e0       	ldi	r23, 0x00	; 0
    1768:	60 e0       	ldi	r22, 0x00	; 0
    176a:	08 95       	ret

0000176c <__fp_nan>:
    176c:	9f ef       	ldi	r25, 0xFF	; 255
    176e:	80 ec       	ldi	r24, 0xC0	; 192
    1770:	08 95       	ret

00001772 <__fp_pscA>:
    1772:	00 24       	eor	r0, r0
    1774:	0a 94       	dec	r0
    1776:	16 16       	cp	r1, r22
    1778:	17 06       	cpc	r1, r23
    177a:	18 06       	cpc	r1, r24
    177c:	09 06       	cpc	r0, r25
    177e:	08 95       	ret

00001780 <__fp_pscB>:
    1780:	00 24       	eor	r0, r0
    1782:	0a 94       	dec	r0
    1784:	12 16       	cp	r1, r18
    1786:	13 06       	cpc	r1, r19
    1788:	14 06       	cpc	r1, r20
    178a:	05 06       	cpc	r0, r21
    178c:	08 95       	ret

0000178e <__fp_round>:
    178e:	09 2e       	mov	r0, r25
    1790:	03 94       	inc	r0
    1792:	00 0c       	add	r0, r0
    1794:	11 f4       	brne	.+4      	; 0x179a <__fp_round+0xc>
    1796:	88 23       	and	r24, r24
    1798:	52 f0       	brmi	.+20     	; 0x17ae <__fp_round+0x20>
    179a:	bb 0f       	add	r27, r27
    179c:	40 f4       	brcc	.+16     	; 0x17ae <__fp_round+0x20>
    179e:	bf 2b       	or	r27, r31
    17a0:	11 f4       	brne	.+4      	; 0x17a6 <__fp_round+0x18>
    17a2:	60 ff       	sbrs	r22, 0
    17a4:	04 c0       	rjmp	.+8      	; 0x17ae <__fp_round+0x20>
    17a6:	6f 5f       	subi	r22, 0xFF	; 255
    17a8:	7f 4f       	sbci	r23, 0xFF	; 255
    17aa:	8f 4f       	sbci	r24, 0xFF	; 255
    17ac:	9f 4f       	sbci	r25, 0xFF	; 255
    17ae:	08 95       	ret

000017b0 <__fp_split3>:
    17b0:	57 fd       	sbrc	r21, 7
    17b2:	90 58       	subi	r25, 0x80	; 128
    17b4:	44 0f       	add	r20, r20
    17b6:	55 1f       	adc	r21, r21
    17b8:	59 f0       	breq	.+22     	; 0x17d0 <__fp_splitA+0x10>
    17ba:	5f 3f       	cpi	r21, 0xFF	; 255
    17bc:	71 f0       	breq	.+28     	; 0x17da <__fp_splitA+0x1a>
    17be:	47 95       	ror	r20

000017c0 <__fp_splitA>:
    17c0:	88 0f       	add	r24, r24
    17c2:	97 fb       	bst	r25, 7
    17c4:	99 1f       	adc	r25, r25
    17c6:	61 f0       	breq	.+24     	; 0x17e0 <__fp_splitA+0x20>
    17c8:	9f 3f       	cpi	r25, 0xFF	; 255
    17ca:	79 f0       	breq	.+30     	; 0x17ea <__fp_splitA+0x2a>
    17cc:	87 95       	ror	r24
    17ce:	08 95       	ret
    17d0:	12 16       	cp	r1, r18
    17d2:	13 06       	cpc	r1, r19
    17d4:	14 06       	cpc	r1, r20
    17d6:	55 1f       	adc	r21, r21
    17d8:	f2 cf       	rjmp	.-28     	; 0x17be <__fp_split3+0xe>
    17da:	46 95       	lsr	r20
    17dc:	f1 df       	rcall	.-30     	; 0x17c0 <__fp_splitA>
    17de:	08 c0       	rjmp	.+16     	; 0x17f0 <__fp_splitA+0x30>
    17e0:	16 16       	cp	r1, r22
    17e2:	17 06       	cpc	r1, r23
    17e4:	18 06       	cpc	r1, r24
    17e6:	99 1f       	adc	r25, r25
    17e8:	f1 cf       	rjmp	.-30     	; 0x17cc <__fp_splitA+0xc>
    17ea:	86 95       	lsr	r24
    17ec:	71 05       	cpc	r23, r1
    17ee:	61 05       	cpc	r22, r1
    17f0:	08 94       	sec
    17f2:	08 95       	ret

000017f4 <__fp_zero>:
    17f4:	e8 94       	clt

000017f6 <__fp_szero>:
    17f6:	bb 27       	eor	r27, r27
    17f8:	66 27       	eor	r22, r22
    17fa:	77 27       	eor	r23, r23
    17fc:	cb 01       	movw	r24, r22
    17fe:	97 f9       	bld	r25, 7
    1800:	08 95       	ret

00001802 <__gesf2>:
    1802:	0e 94 8c 0b 	call	0x1718	; 0x1718 <__fp_cmp>
    1806:	08 f4       	brcc	.+2      	; 0x180a <__gesf2+0x8>
    1808:	8f ef       	ldi	r24, 0xFF	; 255
    180a:	08 95       	ret

0000180c <__mulsf3>:
    180c:	0e 94 19 0c 	call	0x1832	; 0x1832 <__mulsf3x>
    1810:	0c 94 c7 0b 	jmp	0x178e	; 0x178e <__fp_round>
    1814:	0e 94 b9 0b 	call	0x1772	; 0x1772 <__fp_pscA>
    1818:	38 f0       	brcs	.+14     	; 0x1828 <__mulsf3+0x1c>
    181a:	0e 94 c0 0b 	call	0x1780	; 0x1780 <__fp_pscB>
    181e:	20 f0       	brcs	.+8      	; 0x1828 <__mulsf3+0x1c>
    1820:	95 23       	and	r25, r21
    1822:	11 f0       	breq	.+4      	; 0x1828 <__mulsf3+0x1c>
    1824:	0c 94 b0 0b 	jmp	0x1760	; 0x1760 <__fp_inf>
    1828:	0c 94 b6 0b 	jmp	0x176c	; 0x176c <__fp_nan>
    182c:	11 24       	eor	r1, r1
    182e:	0c 94 fb 0b 	jmp	0x17f6	; 0x17f6 <__fp_szero>

00001832 <__mulsf3x>:
    1832:	0e 94 d8 0b 	call	0x17b0	; 0x17b0 <__fp_split3>
    1836:	70 f3       	brcs	.-36     	; 0x1814 <__mulsf3+0x8>

00001838 <__mulsf3_pse>:
    1838:	95 9f       	mul	r25, r21
    183a:	c1 f3       	breq	.-16     	; 0x182c <__mulsf3+0x20>
    183c:	95 0f       	add	r25, r21
    183e:	50 e0       	ldi	r21, 0x00	; 0
    1840:	55 1f       	adc	r21, r21
    1842:	62 9f       	mul	r22, r18
    1844:	f0 01       	movw	r30, r0
    1846:	72 9f       	mul	r23, r18
    1848:	bb 27       	eor	r27, r27
    184a:	f0 0d       	add	r31, r0
    184c:	b1 1d       	adc	r27, r1
    184e:	63 9f       	mul	r22, r19
    1850:	aa 27       	eor	r26, r26
    1852:	f0 0d       	add	r31, r0
    1854:	b1 1d       	adc	r27, r1
    1856:	aa 1f       	adc	r26, r26
    1858:	64 9f       	mul	r22, r20
    185a:	66 27       	eor	r22, r22
    185c:	b0 0d       	add	r27, r0
    185e:	a1 1d       	adc	r26, r1
    1860:	66 1f       	adc	r22, r22
    1862:	82 9f       	mul	r24, r18
    1864:	22 27       	eor	r18, r18
    1866:	b0 0d       	add	r27, r0
    1868:	a1 1d       	adc	r26, r1
    186a:	62 1f       	adc	r22, r18
    186c:	73 9f       	mul	r23, r19
    186e:	b0 0d       	add	r27, r0
    1870:	a1 1d       	adc	r26, r1
    1872:	62 1f       	adc	r22, r18
    1874:	83 9f       	mul	r24, r19
    1876:	a0 0d       	add	r26, r0
    1878:	61 1d       	adc	r22, r1
    187a:	22 1f       	adc	r18, r18
    187c:	74 9f       	mul	r23, r20
    187e:	33 27       	eor	r19, r19
    1880:	a0 0d       	add	r26, r0
    1882:	61 1d       	adc	r22, r1
    1884:	23 1f       	adc	r18, r19
    1886:	84 9f       	mul	r24, r20
    1888:	60 0d       	add	r22, r0
    188a:	21 1d       	adc	r18, r1
    188c:	82 2f       	mov	r24, r18
    188e:	76 2f       	mov	r23, r22
    1890:	6a 2f       	mov	r22, r26
    1892:	11 24       	eor	r1, r1
    1894:	9f 57       	subi	r25, 0x7F	; 127
    1896:	50 40       	sbci	r21, 0x00	; 0
    1898:	9a f0       	brmi	.+38     	; 0x18c0 <__mulsf3_pse+0x88>
    189a:	f1 f0       	breq	.+60     	; 0x18d8 <__mulsf3_pse+0xa0>
    189c:	88 23       	and	r24, r24
    189e:	4a f0       	brmi	.+18     	; 0x18b2 <__mulsf3_pse+0x7a>
    18a0:	ee 0f       	add	r30, r30
    18a2:	ff 1f       	adc	r31, r31
    18a4:	bb 1f       	adc	r27, r27
    18a6:	66 1f       	adc	r22, r22
    18a8:	77 1f       	adc	r23, r23
    18aa:	88 1f       	adc	r24, r24
    18ac:	91 50       	subi	r25, 0x01	; 1
    18ae:	50 40       	sbci	r21, 0x00	; 0
    18b0:	a9 f7       	brne	.-22     	; 0x189c <__mulsf3_pse+0x64>
    18b2:	9e 3f       	cpi	r25, 0xFE	; 254
    18b4:	51 05       	cpc	r21, r1
    18b6:	80 f0       	brcs	.+32     	; 0x18d8 <__mulsf3_pse+0xa0>
    18b8:	0c 94 b0 0b 	jmp	0x1760	; 0x1760 <__fp_inf>
    18bc:	0c 94 fb 0b 	jmp	0x17f6	; 0x17f6 <__fp_szero>
    18c0:	5f 3f       	cpi	r21, 0xFF	; 255
    18c2:	e4 f3       	brlt	.-8      	; 0x18bc <__mulsf3_pse+0x84>
    18c4:	98 3e       	cpi	r25, 0xE8	; 232
    18c6:	d4 f3       	brlt	.-12     	; 0x18bc <__mulsf3_pse+0x84>
    18c8:	86 95       	lsr	r24
    18ca:	77 95       	ror	r23
    18cc:	67 95       	ror	r22
    18ce:	b7 95       	ror	r27
    18d0:	f7 95       	ror	r31
    18d2:	e7 95       	ror	r30
    18d4:	9f 5f       	subi	r25, 0xFF	; 255
    18d6:	c1 f7       	brne	.-16     	; 0x18c8 <__mulsf3_pse+0x90>
    18d8:	fe 2b       	or	r31, r30
    18da:	88 0f       	add	r24, r24
    18dc:	91 1d       	adc	r25, r1
    18de:	96 95       	lsr	r25
    18e0:	87 95       	ror	r24
    18e2:	97 f9       	bld	r25, 7
    18e4:	08 95       	ret

000018e6 <_ZN14HardwareSerial9availableEv>:
  // clear any received data
  _rx_buffer_head = _rx_buffer_tail;
}

int HardwareSerial::available(void)
{
    18e6:	fc 01       	movw	r30, r24
  return ((unsigned int)(SERIAL_RX_BUFFER_SIZE + _rx_buffer_head - _rx_buffer_tail)) % SERIAL_RX_BUFFER_SIZE;
    18e8:	91 8d       	ldd	r25, Z+25	; 0x19
    18ea:	22 8d       	ldd	r18, Z+26	; 0x1a
    18ec:	89 2f       	mov	r24, r25
    18ee:	90 e0       	ldi	r25, 0x00	; 0
    18f0:	80 5c       	subi	r24, 0xC0	; 192
    18f2:	9f 4f       	sbci	r25, 0xFF	; 255
    18f4:	82 1b       	sub	r24, r18
    18f6:	91 09       	sbc	r25, r1
}
    18f8:	8f 73       	andi	r24, 0x3F	; 63
    18fa:	99 27       	eor	r25, r25
    18fc:	08 95       	ret

000018fe <_ZN14HardwareSerial4peekEv>:

int HardwareSerial::peek(void)
{
    18fe:	fc 01       	movw	r30, r24
  if (_rx_buffer_head == _rx_buffer_tail) {
    1900:	91 8d       	ldd	r25, Z+25	; 0x19
    1902:	82 8d       	ldd	r24, Z+26	; 0x1a
    1904:	98 17       	cp	r25, r24
    1906:	31 f0       	breq	.+12     	; 0x1914 <_ZN14HardwareSerial4peekEv+0x16>
    return -1;
  } else {
    return _rx_buffer[_rx_buffer_tail];
    1908:	82 8d       	ldd	r24, Z+26	; 0x1a
    190a:	e8 0f       	add	r30, r24
    190c:	f1 1d       	adc	r31, r1
    190e:	85 8d       	ldd	r24, Z+29	; 0x1d
    1910:	90 e0       	ldi	r25, 0x00	; 0
    1912:	08 95       	ret
}

int HardwareSerial::peek(void)
{
  if (_rx_buffer_head == _rx_buffer_tail) {
    return -1;
    1914:	8f ef       	ldi	r24, 0xFF	; 255
    1916:	9f ef       	ldi	r25, 0xFF	; 255
  } else {
    return _rx_buffer[_rx_buffer_tail];
  }
}
    1918:	08 95       	ret

0000191a <_ZN14HardwareSerial4readEv>:

int HardwareSerial::read(void)
{
    191a:	fc 01       	movw	r30, r24
  // if the head isn't ahead of the tail, we don't have any characters
  if (_rx_buffer_head == _rx_buffer_tail) {
    191c:	91 8d       	ldd	r25, Z+25	; 0x19
    191e:	82 8d       	ldd	r24, Z+26	; 0x1a
    1920:	98 17       	cp	r25, r24
    1922:	61 f0       	breq	.+24     	; 0x193c <_ZN14HardwareSerial4readEv+0x22>
    return -1;
  } else {
    unsigned char c = _rx_buffer[_rx_buffer_tail];
    1924:	82 8d       	ldd	r24, Z+26	; 0x1a
    1926:	df 01       	movw	r26, r30
    1928:	a8 0f       	add	r26, r24
    192a:	b1 1d       	adc	r27, r1
    192c:	5d 96       	adiw	r26, 0x1d	; 29
    192e:	8c 91       	ld	r24, X
    _rx_buffer_tail = (rx_buffer_index_t)(_rx_buffer_tail + 1) % SERIAL_RX_BUFFER_SIZE;
    1930:	92 8d       	ldd	r25, Z+26	; 0x1a
    1932:	9f 5f       	subi	r25, 0xFF	; 255
    1934:	9f 73       	andi	r25, 0x3F	; 63
    1936:	92 8f       	std	Z+26, r25	; 0x1a
    return c;
    1938:	90 e0       	ldi	r25, 0x00	; 0
    193a:	08 95       	ret

int HardwareSerial::read(void)
{
  // if the head isn't ahead of the tail, we don't have any characters
  if (_rx_buffer_head == _rx_buffer_tail) {
    return -1;
    193c:	8f ef       	ldi	r24, 0xFF	; 255
    193e:	9f ef       	ldi	r25, 0xFF	; 255
  } else {
    unsigned char c = _rx_buffer[_rx_buffer_tail];
    _rx_buffer_tail = (rx_buffer_index_t)(_rx_buffer_tail + 1) % SERIAL_RX_BUFFER_SIZE;
    return c;
  }
}
    1940:	08 95       	ret

00001942 <_ZN14HardwareSerial17availableForWriteEv>:
{
  tx_buffer_index_t head;
  tx_buffer_index_t tail;

  TX_BUFFER_ATOMIC {
    head = _tx_buffer_head;
    1942:	fc 01       	movw	r30, r24
    1944:	53 8d       	ldd	r21, Z+27	; 0x1b
    tail = _tx_buffer_tail;
    1946:	44 8d       	ldd	r20, Z+28	; 0x1c
    1948:	25 2f       	mov	r18, r21
    194a:	30 e0       	ldi	r19, 0x00	; 0
    194c:	84 2f       	mov	r24, r20
    194e:	90 e0       	ldi	r25, 0x00	; 0
  }
  if (head >= tail) return SERIAL_TX_BUFFER_SIZE - 1 - head + tail;
    1950:	82 1b       	sub	r24, r18
    1952:	93 0b       	sbc	r25, r19
    1954:	54 17       	cp	r21, r20
    1956:	10 f0       	brcs	.+4      	; 0x195c <_ZN14HardwareSerial17availableForWriteEv+0x1a>
    1958:	cf 96       	adiw	r24, 0x3f	; 63
    195a:	08 95       	ret
  return tail - head - 1;
    195c:	01 97       	sbiw	r24, 0x01	; 1
}
    195e:	08 95       	ret

00001960 <_Z14serialEventRunv>:
#endif

void serialEventRun(void)
{
#if defined(HAVE_HWSERIAL0)
  if (Serial0_available && serialEvent && Serial0_available()) serialEvent();
    1960:	8c e0       	ldi	r24, 0x0C	; 12
    1962:	9e e0       	ldi	r25, 0x0E	; 14
    1964:	89 2b       	or	r24, r25
    1966:	49 f0       	breq	.+18     	; 0x197a <_Z14serialEventRunv+0x1a>
    1968:	80 e0       	ldi	r24, 0x00	; 0
    196a:	90 e0       	ldi	r25, 0x00	; 0
    196c:	89 2b       	or	r24, r25
    196e:	29 f0       	breq	.+10     	; 0x197a <_Z14serialEventRunv+0x1a>
    1970:	0e 94 0c 0e 	call	0x1c18	; 0x1c18 <_Z17Serial0_availablev>
    1974:	81 11       	cpse	r24, r1
    1976:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>
    197a:	08 95       	ret

0000197c <_ZN14HardwareSerial17_tx_udr_empty_irqEv>:
#endif

// Actual interrupt handlers //////////////////////////////////////////////////////////////

void HardwareSerial::_tx_udr_empty_irq(void)
{
    197c:	fc 01       	movw	r30, r24
  // If interrupts are enabled, there must be more data in the output
  // buffer. Send the next byte
  unsigned char c = _tx_buffer[_tx_buffer_tail];
    197e:	84 8d       	ldd	r24, Z+28	; 0x1c
    1980:	df 01       	movw	r26, r30
    1982:	a8 0f       	add	r26, r24
    1984:	b1 1d       	adc	r27, r1
    1986:	a3 5a       	subi	r26, 0xA3	; 163
    1988:	bf 4f       	sbci	r27, 0xFF	; 255
    198a:	2c 91       	ld	r18, X
  _tx_buffer_tail = (_tx_buffer_tail + 1) % SERIAL_TX_BUFFER_SIZE;
    198c:	84 8d       	ldd	r24, Z+28	; 0x1c
    198e:	90 e0       	ldi	r25, 0x00	; 0
    1990:	01 96       	adiw	r24, 0x01	; 1
    1992:	8f 73       	andi	r24, 0x3F	; 63
    1994:	99 27       	eor	r25, r25
    1996:	84 8f       	std	Z+28, r24	; 0x1c

  *_udr = c;
    1998:	a6 89       	ldd	r26, Z+22	; 0x16
    199a:	b7 89       	ldd	r27, Z+23	; 0x17
    199c:	2c 93       	st	X, r18
  // location". This makes sure flush() won't return until the bytes
  // actually got written. Other r/w bits are preserved, and zeroes
  // written to the rest.

#ifdef MPCM0
  *_ucsra = ((*_ucsra) & ((1 << U2X0) | (1 << MPCM0))) | (1 << TXC0);
    199e:	a0 89       	ldd	r26, Z+16	; 0x10
    19a0:	b1 89       	ldd	r27, Z+17	; 0x11
    19a2:	8c 91       	ld	r24, X
    19a4:	83 70       	andi	r24, 0x03	; 3
    19a6:	80 64       	ori	r24, 0x40	; 64
    19a8:	8c 93       	st	X, r24
#else
  *_ucsra = ((*_ucsra) & ((1 << U2X0) | (1 << TXC0)));
#endif

  if (_tx_buffer_head == _tx_buffer_tail) {
    19aa:	93 8d       	ldd	r25, Z+27	; 0x1b
    19ac:	84 8d       	ldd	r24, Z+28	; 0x1c
    19ae:	98 13       	cpse	r25, r24
    19b0:	06 c0       	rjmp	.+12     	; 0x19be <_ZN14HardwareSerial17_tx_udr_empty_irqEv+0x42>
    // Buffer empty, so disable interrupts
    cbi(*_ucsrb, UDRIE0);
    19b2:	02 88       	ldd	r0, Z+18	; 0x12
    19b4:	f3 89       	ldd	r31, Z+19	; 0x13
    19b6:	e0 2d       	mov	r30, r0
    19b8:	80 81       	ld	r24, Z
    19ba:	8f 7d       	andi	r24, 0xDF	; 223
    19bc:	80 83       	st	Z, r24
    19be:	08 95       	ret

000019c0 <_ZN14HardwareSerial5writeEh>:
  // If we get here, nothing is queued anymore (DRIE is disabled) and
  // the hardware finished tranmission (TXC is set).
}

size_t HardwareSerial::write(uint8_t c)
{
    19c0:	ef 92       	push	r14
    19c2:	ff 92       	push	r15
    19c4:	0f 93       	push	r16
    19c6:	1f 93       	push	r17
    19c8:	cf 93       	push	r28
    19ca:	df 93       	push	r29
    19cc:	ec 01       	movw	r28, r24
  _written = true;
    19ce:	81 e0       	ldi	r24, 0x01	; 1
    19d0:	88 8f       	std	Y+24, r24	; 0x18
  // If the buffer and the data register is empty, just write the byte
  // to the data register and be done. This shortcut helps
  // significantly improve the effective datarate at high (>
  // 500kbit/s) bitrates, where interrupt overhead becomes a slowdown.
  if (_tx_buffer_head == _tx_buffer_tail && bit_is_set(*_ucsra, UDRE0)) {
    19d2:	9b 8d       	ldd	r25, Y+27	; 0x1b
    19d4:	8c 8d       	ldd	r24, Y+28	; 0x1c
    19d6:	98 13       	cpse	r25, r24
    19d8:	05 c0       	rjmp	.+10     	; 0x19e4 <_ZN14HardwareSerial5writeEh+0x24>
    19da:	e8 89       	ldd	r30, Y+16	; 0x10
    19dc:	f9 89       	ldd	r31, Y+17	; 0x11
    19de:	80 81       	ld	r24, Z
    19e0:	85 fd       	sbrc	r24, 5
    19e2:	26 c0       	rjmp	.+76     	; 0x1a30 <_ZN14HardwareSerial5writeEh+0x70>
    19e4:	f6 2e       	mov	r15, r22
      *_ucsra = ((*_ucsra) & ((1 << U2X0) | (1 << TXC0)));
#endif
    }
    return 1;
  }
  tx_buffer_index_t i = (_tx_buffer_head + 1) % SERIAL_TX_BUFFER_SIZE;
    19e6:	0b 8d       	ldd	r16, Y+27	; 0x1b
    19e8:	10 e0       	ldi	r17, 0x00	; 0
    19ea:	0f 5f       	subi	r16, 0xFF	; 255
    19ec:	1f 4f       	sbci	r17, 0xFF	; 255
    19ee:	0f 73       	andi	r16, 0x3F	; 63
    19f0:	11 27       	eor	r17, r17
    19f2:	e0 2e       	mov	r14, r16
	
  // If the output buffer is full, there's nothing for it other than to 
  // wait for the interrupt handler to empty it a bit
  while (i == _tx_buffer_tail) {
    19f4:	8c 8d       	ldd	r24, Y+28	; 0x1c
    19f6:	e8 12       	cpse	r14, r24
    19f8:	0c c0       	rjmp	.+24     	; 0x1a12 <_ZN14HardwareSerial5writeEh+0x52>
    if (bit_is_clear(SREG, SREG_I)) {
    19fa:	0f b6       	in	r0, 0x3f	; 63
    19fc:	07 fc       	sbrc	r0, 7
    19fe:	fa cf       	rjmp	.-12     	; 0x19f4 <_ZN14HardwareSerial5writeEh+0x34>
      // Interrupts are disabled, so we'll have to poll the data
      // register empty flag ourselves. If it is set, pretend an
      // interrupt has happened and call the handler to free up
      // space for us.
      if(bit_is_set(*_ucsra, UDRE0))
    1a00:	e8 89       	ldd	r30, Y+16	; 0x10
    1a02:	f9 89       	ldd	r31, Y+17	; 0x11
    1a04:	80 81       	ld	r24, Z
    1a06:	85 ff       	sbrs	r24, 5
    1a08:	f5 cf       	rjmp	.-22     	; 0x19f4 <_ZN14HardwareSerial5writeEh+0x34>
	_tx_udr_empty_irq();
    1a0a:	ce 01       	movw	r24, r28
    1a0c:	0e 94 be 0c 	call	0x197c	; 0x197c <_ZN14HardwareSerial17_tx_udr_empty_irqEv>
    1a10:	f1 cf       	rjmp	.-30     	; 0x19f4 <_ZN14HardwareSerial5writeEh+0x34>
    } else {
      // nop, the interrupt handler will free up space for us
    }
  }

  _tx_buffer[_tx_buffer_head] = c;
    1a12:	8b 8d       	ldd	r24, Y+27	; 0x1b
    1a14:	fe 01       	movw	r30, r28
    1a16:	e8 0f       	add	r30, r24
    1a18:	f1 1d       	adc	r31, r1
    1a1a:	e3 5a       	subi	r30, 0xA3	; 163
    1a1c:	ff 4f       	sbci	r31, 0xFF	; 255
    1a1e:	f0 82       	st	Z, r15

  // make atomic to prevent execution of ISR between setting the
  // head pointer and setting the interrupt flag resulting in buffer
  // retransmission
  ATOMIC_BLOCK(ATOMIC_RESTORESTATE) {
    1a20:	9f b7       	in	r25, 0x3f	; 63
    return 1;
}

static __inline__ uint8_t __iCliRetVal(void)
{
    cli();
    1a22:	f8 94       	cli
    _tx_buffer_head = i;
    1a24:	0b 8f       	std	Y+27, r16	; 0x1b
    sbi(*_ucsrb, UDRIE0);
    1a26:	ea 89       	ldd	r30, Y+18	; 0x12
    1a28:	fb 89       	ldd	r31, Y+19	; 0x13
    1a2a:	80 81       	ld	r24, Z
    1a2c:	80 62       	ori	r24, 0x20	; 32
    1a2e:	0a c0       	rjmp	.+20     	; 0x1a44 <_ZN14HardwareSerial5writeEh+0x84>
    // So writing UDR must happen first.
    // Writing UDR and clearing TC must be done atomically, otherwise
    // interrupts might delay the TXC clear so the byte written to UDR
    // is transmitted (setting TXC) before clearing TXC. Then TXC will
    // be cleared when no bytes are left, causing flush() to hang
    ATOMIC_BLOCK(ATOMIC_RESTORESTATE) {
    1a30:	9f b7       	in	r25, 0x3f	; 63
    1a32:	f8 94       	cli
      *_udr = c;
    1a34:	ee 89       	ldd	r30, Y+22	; 0x16
    1a36:	ff 89       	ldd	r31, Y+23	; 0x17
    1a38:	60 83       	st	Z, r22
#ifdef MPCM0
      *_ucsra = ((*_ucsra) & ((1 << U2X0) | (1 << MPCM0))) | (1 << TXC0);
    1a3a:	e8 89       	ldd	r30, Y+16	; 0x10
    1a3c:	f9 89       	ldd	r31, Y+17	; 0x11
    1a3e:	80 81       	ld	r24, Z
    1a40:	83 70       	andi	r24, 0x03	; 3
    1a42:	80 64       	ori	r24, 0x40	; 64
    1a44:	80 83       	st	Z, r24
    (void)__s;
}

static __inline__ void __iRestore(const  uint8_t *__s)
{
    SREG = *__s;
    1a46:	9f bf       	out	0x3f, r25	; 63
    _tx_buffer_head = i;
    sbi(*_ucsrb, UDRIE0);
  }
  
  return 1;
}
    1a48:	81 e0       	ldi	r24, 0x01	; 1
    1a4a:	90 e0       	ldi	r25, 0x00	; 0
    1a4c:	df 91       	pop	r29
    1a4e:	cf 91       	pop	r28
    1a50:	1f 91       	pop	r17
    1a52:	0f 91       	pop	r16
    1a54:	ff 90       	pop	r15
    1a56:	ef 90       	pop	r14
    1a58:	08 95       	ret

00001a5a <_ZN14HardwareSerial5flushEv>:
  if (head >= tail) return SERIAL_TX_BUFFER_SIZE - 1 - head + tail;
  return tail - head - 1;
}

void HardwareSerial::flush()
{
    1a5a:	cf 93       	push	r28
    1a5c:	df 93       	push	r29
    1a5e:	ec 01       	movw	r28, r24
  // If we have never written a byte, no need to flush. This special
  // case is needed since there is no way to force the TXC (transmit
  // complete) bit to 1 during initialization
  if (!_written)
    1a60:	88 8d       	ldd	r24, Y+24	; 0x18
    1a62:	88 23       	and	r24, r24
    1a64:	c9 f0       	breq	.+50     	; 0x1a98 <_ZN14HardwareSerial5flushEv+0x3e>
    return;

  while (bit_is_set(*_ucsrb, UDRIE0) || bit_is_clear(*_ucsra, TXC0)) {
    1a66:	ea 89       	ldd	r30, Y+18	; 0x12
    1a68:	fb 89       	ldd	r31, Y+19	; 0x13
    1a6a:	80 81       	ld	r24, Z
    1a6c:	85 fd       	sbrc	r24, 5
    1a6e:	05 c0       	rjmp	.+10     	; 0x1a7a <_ZN14HardwareSerial5flushEv+0x20>
    1a70:	a8 89       	ldd	r26, Y+16	; 0x10
    1a72:	b9 89       	ldd	r27, Y+17	; 0x11
    1a74:	8c 91       	ld	r24, X
    1a76:	86 fd       	sbrc	r24, 6
    1a78:	0f c0       	rjmp	.+30     	; 0x1a98 <_ZN14HardwareSerial5flushEv+0x3e>
    if (bit_is_clear(SREG, SREG_I) && bit_is_set(*_ucsrb, UDRIE0))
    1a7a:	0f b6       	in	r0, 0x3f	; 63
    1a7c:	07 fc       	sbrc	r0, 7
    1a7e:	f5 cf       	rjmp	.-22     	; 0x1a6a <_ZN14HardwareSerial5flushEv+0x10>
    1a80:	80 81       	ld	r24, Z
    1a82:	85 ff       	sbrs	r24, 5
    1a84:	f2 cf       	rjmp	.-28     	; 0x1a6a <_ZN14HardwareSerial5flushEv+0x10>
	// Interrupts are globally disabled, but the DR empty
	// interrupt should be enabled, so poll the DR empty flag to
	// prevent deadlock
	if (bit_is_set(*_ucsra, UDRE0))
    1a86:	a8 89       	ldd	r26, Y+16	; 0x10
    1a88:	b9 89       	ldd	r27, Y+17	; 0x11
    1a8a:	8c 91       	ld	r24, X
    1a8c:	85 ff       	sbrs	r24, 5
    1a8e:	ed cf       	rjmp	.-38     	; 0x1a6a <_ZN14HardwareSerial5flushEv+0x10>
	  _tx_udr_empty_irq();
    1a90:	ce 01       	movw	r24, r28
    1a92:	0e 94 be 0c 	call	0x197c	; 0x197c <_ZN14HardwareSerial17_tx_udr_empty_irqEv>
    1a96:	e7 cf       	rjmp	.-50     	; 0x1a66 <_ZN14HardwareSerial5flushEv+0xc>
  }
  // If we get here, nothing is queued anymore (DRIE is disabled) and
  // the hardware finished tranmission (TXC is set).
}
    1a98:	df 91       	pop	r29
    1a9a:	cf 91       	pop	r28
    1a9c:	08 95       	ret

00001a9e <_ZN14HardwareSerial5beginEmh>:
}

// Public Methods //////////////////////////////////////////////////////////////

void HardwareSerial::begin(unsigned long baud, byte config)
{
    1a9e:	cf 92       	push	r12
    1aa0:	df 92       	push	r13
    1aa2:	ef 92       	push	r14
    1aa4:	ff 92       	push	r15
    1aa6:	1f 93       	push	r17
    1aa8:	cf 93       	push	r28
    1aaa:	df 93       	push	r29
    1aac:	ec 01       	movw	r28, r24
    1aae:	6a 01       	movw	r12, r20
    1ab0:	7b 01       	movw	r14, r22
    1ab2:	12 2f       	mov	r17, r18
  // Try u2x mode first
  uint16_t baud_setting = (F_CPU / 4 / baud - 1) / 2;
  *_ucsra = 1 << U2X0;
    1ab4:	e8 89       	ldd	r30, Y+16	; 0x10
    1ab6:	f9 89       	ldd	r31, Y+17	; 0x11
    1ab8:	82 e0       	ldi	r24, 0x02	; 2
    1aba:	80 83       	st	Z, r24
  // hardcoded exception for 57600 for compatibility with the bootloader
  // shipped with the Duemilanove and previous boards and the firmware
  // on the 8U2 on the Uno and Mega 2560. Also, The baud_setting cannot
  // be > 4095, so switch back to non-u2x mode if the baud rate is too
  // low.
  if (((F_CPU == 16000000UL) && (baud == 57600)) || (baud_setting >4095))
    1abc:	41 15       	cp	r20, r1
    1abe:	51 4e       	sbci	r21, 0xE1	; 225
    1ac0:	61 05       	cpc	r22, r1
    1ac2:	71 05       	cpc	r23, r1
    1ac4:	b1 f0       	breq	.+44     	; 0x1af2 <_ZN14HardwareSerial5beginEmh+0x54>
// Public Methods //////////////////////////////////////////////////////////////

void HardwareSerial::begin(unsigned long baud, byte config)
{
  // Try u2x mode first
  uint16_t baud_setting = (F_CPU / 4 / baud - 1) / 2;
    1ac6:	60 e0       	ldi	r22, 0x00	; 0
    1ac8:	79 e0       	ldi	r23, 0x09	; 9
    1aca:	8d e3       	ldi	r24, 0x3D	; 61
    1acc:	90 e0       	ldi	r25, 0x00	; 0
    1ace:	a7 01       	movw	r20, r14
    1ad0:	96 01       	movw	r18, r12
    1ad2:	0e 94 b6 21 	call	0x436c	; 0x436c <__udivmodsi4>
    1ad6:	da 01       	movw	r26, r20
    1ad8:	c9 01       	movw	r24, r18
    1ada:	01 97       	sbiw	r24, 0x01	; 1
    1adc:	a1 09       	sbc	r26, r1
    1ade:	b1 09       	sbc	r27, r1
    1ae0:	b6 95       	lsr	r27
    1ae2:	a7 95       	ror	r26
    1ae4:	97 95       	ror	r25
    1ae6:	87 95       	ror	r24
    1ae8:	9c 01       	movw	r18, r24
  // hardcoded exception for 57600 for compatibility with the bootloader
  // shipped with the Duemilanove and previous boards and the firmware
  // on the 8U2 on the Uno and Mega 2560. Also, The baud_setting cannot
  // be > 4095, so switch back to non-u2x mode if the baud rate is too
  // low.
  if (((F_CPU == 16000000UL) && (baud == 57600)) || (baud_setting >4095))
    1aea:	21 15       	cp	r18, r1
    1aec:	80 e1       	ldi	r24, 0x10	; 16
    1aee:	38 07       	cpc	r19, r24
    1af0:	a8 f0       	brcs	.+42     	; 0x1b1c <_ZN14HardwareSerial5beginEmh+0x7e>
  {
    *_ucsra = 0;
    1af2:	e8 89       	ldd	r30, Y+16	; 0x10
    1af4:	f9 89       	ldd	r31, Y+17	; 0x11
    1af6:	10 82       	st	Z, r1
    baud_setting = (F_CPU / 8 / baud - 1) / 2;
    1af8:	60 e8       	ldi	r22, 0x80	; 128
    1afa:	74 e8       	ldi	r23, 0x84	; 132
    1afc:	8e e1       	ldi	r24, 0x1E	; 30
    1afe:	90 e0       	ldi	r25, 0x00	; 0
    1b00:	a7 01       	movw	r20, r14
    1b02:	96 01       	movw	r18, r12
    1b04:	0e 94 b6 21 	call	0x436c	; 0x436c <__udivmodsi4>
    1b08:	da 01       	movw	r26, r20
    1b0a:	c9 01       	movw	r24, r18
    1b0c:	01 97       	sbiw	r24, 0x01	; 1
    1b0e:	a1 09       	sbc	r26, r1
    1b10:	b1 09       	sbc	r27, r1
    1b12:	b6 95       	lsr	r27
    1b14:	a7 95       	ror	r26
    1b16:	97 95       	ror	r25
    1b18:	87 95       	ror	r24
    1b1a:	9c 01       	movw	r18, r24
  }

  // assign the baud_setting, a.k.a. ubrr (USART Baud Rate Register)
  *_ubrrh = baud_setting >> 8;
    1b1c:	ec 85       	ldd	r30, Y+12	; 0x0c
    1b1e:	fd 85       	ldd	r31, Y+13	; 0x0d
    1b20:	30 83       	st	Z, r19
  *_ubrrl = baud_setting;
    1b22:	ee 85       	ldd	r30, Y+14	; 0x0e
    1b24:	ff 85       	ldd	r31, Y+15	; 0x0f
    1b26:	20 83       	st	Z, r18

  _written = false;
    1b28:	18 8e       	std	Y+24, r1	; 0x18

  //set the data bits, parity, and stop bits
#if defined(__AVR_ATmega8__)
  config |= 0x80; // select UCSRC register (shared with UBRRH)
#endif
  *_ucsrc = config;
    1b2a:	ec 89       	ldd	r30, Y+20	; 0x14
    1b2c:	fd 89       	ldd	r31, Y+21	; 0x15
    1b2e:	10 83       	st	Z, r17
  
  sbi(*_ucsrb, RXEN0);
    1b30:	ea 89       	ldd	r30, Y+18	; 0x12
    1b32:	fb 89       	ldd	r31, Y+19	; 0x13
    1b34:	80 81       	ld	r24, Z
    1b36:	80 61       	ori	r24, 0x10	; 16
    1b38:	80 83       	st	Z, r24
  sbi(*_ucsrb, TXEN0);
    1b3a:	ea 89       	ldd	r30, Y+18	; 0x12
    1b3c:	fb 89       	ldd	r31, Y+19	; 0x13
    1b3e:	80 81       	ld	r24, Z
    1b40:	88 60       	ori	r24, 0x08	; 8
    1b42:	80 83       	st	Z, r24
  sbi(*_ucsrb, RXCIE0);
    1b44:	ea 89       	ldd	r30, Y+18	; 0x12
    1b46:	fb 89       	ldd	r31, Y+19	; 0x13
    1b48:	80 81       	ld	r24, Z
    1b4a:	80 68       	ori	r24, 0x80	; 128
    1b4c:	80 83       	st	Z, r24
  cbi(*_ucsrb, UDRIE0);
    1b4e:	ea 89       	ldd	r30, Y+18	; 0x12
    1b50:	fb 89       	ldd	r31, Y+19	; 0x13
    1b52:	80 81       	ld	r24, Z
    1b54:	8f 7d       	andi	r24, 0xDF	; 223
    1b56:	80 83       	st	Z, r24
}
    1b58:	df 91       	pop	r29
    1b5a:	cf 91       	pop	r28
    1b5c:	1f 91       	pop	r17
    1b5e:	ff 90       	pop	r15
    1b60:	ef 90       	pop	r14
    1b62:	df 90       	pop	r13
    1b64:	cf 90       	pop	r12
    1b66:	08 95       	ret

00001b68 <__vector_18>:
#elif defined(USART_RXC_vect)
  ISR(USART_RXC_vect) // ATmega8
#else
  #error "Don't know what the Data Received vector is called for Serial"
#endif
  {
    1b68:	1f 92       	push	r1
    1b6a:	0f 92       	push	r0
    1b6c:	0f b6       	in	r0, 0x3f	; 63
    1b6e:	0f 92       	push	r0
    1b70:	11 24       	eor	r1, r1
    1b72:	2f 93       	push	r18
    1b74:	8f 93       	push	r24
    1b76:	9f 93       	push	r25
    1b78:	ef 93       	push	r30
    1b7a:	ff 93       	push	r31

// Actual interrupt handlers //////////////////////////////////////////////////////////////

void HardwareSerial::_rx_complete_irq(void)
{
  if (bit_is_clear(*_ucsra, UPE0)) {
    1b7c:	e0 91 d9 03 	lds	r30, 0x03D9	; 0x8003d9 <Serial+0x10>
    1b80:	f0 91 da 03 	lds	r31, 0x03DA	; 0x8003da <Serial+0x11>
    1b84:	80 81       	ld	r24, Z
    1b86:	e0 91 df 03 	lds	r30, 0x03DF	; 0x8003df <Serial+0x16>
    1b8a:	f0 91 e0 03 	lds	r31, 0x03E0	; 0x8003e0 <Serial+0x17>
    1b8e:	82 fd       	sbrc	r24, 2
    1b90:	12 c0       	rjmp	.+36     	; 0x1bb6 <__vector_18+0x4e>
    // No Parity error, read byte and store it in the buffer if there is
    // room
    unsigned char c = *_udr;
    1b92:	90 81       	ld	r25, Z
    rx_buffer_index_t i = (unsigned int)(_rx_buffer_head + 1) % SERIAL_RX_BUFFER_SIZE;
    1b94:	80 91 e2 03 	lds	r24, 0x03E2	; 0x8003e2 <Serial+0x19>
    1b98:	8f 5f       	subi	r24, 0xFF	; 255
    1b9a:	8f 73       	andi	r24, 0x3F	; 63

    // if we should be storing the received character into the location
    // just before the tail (meaning that the head would advance to the
    // current location of the tail), we're about to overflow the buffer
    // and so we don't write the character or advance the head.
    if (i != _rx_buffer_tail) {
    1b9c:	20 91 e3 03 	lds	r18, 0x03E3	; 0x8003e3 <Serial+0x1a>
    1ba0:	82 17       	cp	r24, r18
    1ba2:	51 f0       	breq	.+20     	; 0x1bb8 <__vector_18+0x50>
      _rx_buffer[_rx_buffer_head] = c;
    1ba4:	e0 91 e2 03 	lds	r30, 0x03E2	; 0x8003e2 <Serial+0x19>
    1ba8:	f0 e0       	ldi	r31, 0x00	; 0
    1baa:	e7 53       	subi	r30, 0x37	; 55
    1bac:	fc 4f       	sbci	r31, 0xFC	; 252
    1bae:	95 8f       	std	Z+29, r25	; 0x1d
      _rx_buffer_head = i;
    1bb0:	80 93 e2 03 	sts	0x03E2, r24	; 0x8003e2 <Serial+0x19>
    1bb4:	01 c0       	rjmp	.+2      	; 0x1bb8 <__vector_18+0x50>
    }
  } else {
    // Parity error, read byte but discard it
    *_udr;
    1bb6:	80 81       	ld	r24, Z
    Serial._rx_complete_irq();
  }
    1bb8:	ff 91       	pop	r31
    1bba:	ef 91       	pop	r30
    1bbc:	9f 91       	pop	r25
    1bbe:	8f 91       	pop	r24
    1bc0:	2f 91       	pop	r18
    1bc2:	0f 90       	pop	r0
    1bc4:	0f be       	out	0x3f, r0	; 63
    1bc6:	0f 90       	pop	r0
    1bc8:	1f 90       	pop	r1
    1bca:	18 95       	reti

00001bcc <__vector_19>:
#elif defined(USART_UDRE_vect)
ISR(USART_UDRE_vect)
#else
  #error "Don't know what the Data Register Empty vector is called for Serial"
#endif
{
    1bcc:	1f 92       	push	r1
    1bce:	0f 92       	push	r0
    1bd0:	0f b6       	in	r0, 0x3f	; 63
    1bd2:	0f 92       	push	r0
    1bd4:	11 24       	eor	r1, r1
    1bd6:	2f 93       	push	r18
    1bd8:	3f 93       	push	r19
    1bda:	4f 93       	push	r20
    1bdc:	5f 93       	push	r21
    1bde:	6f 93       	push	r22
    1be0:	7f 93       	push	r23
    1be2:	8f 93       	push	r24
    1be4:	9f 93       	push	r25
    1be6:	af 93       	push	r26
    1be8:	bf 93       	push	r27
    1bea:	ef 93       	push	r30
    1bec:	ff 93       	push	r31
  Serial._tx_udr_empty_irq();
    1bee:	89 ec       	ldi	r24, 0xC9	; 201
    1bf0:	93 e0       	ldi	r25, 0x03	; 3
    1bf2:	0e 94 be 0c 	call	0x197c	; 0x197c <_ZN14HardwareSerial17_tx_udr_empty_irqEv>
}
    1bf6:	ff 91       	pop	r31
    1bf8:	ef 91       	pop	r30
    1bfa:	bf 91       	pop	r27
    1bfc:	af 91       	pop	r26
    1bfe:	9f 91       	pop	r25
    1c00:	8f 91       	pop	r24
    1c02:	7f 91       	pop	r23
    1c04:	6f 91       	pop	r22
    1c06:	5f 91       	pop	r21
    1c08:	4f 91       	pop	r20
    1c0a:	3f 91       	pop	r19
    1c0c:	2f 91       	pop	r18
    1c0e:	0f 90       	pop	r0
    1c10:	0f be       	out	0x3f, r0	; 63
    1c12:	0f 90       	pop	r0
    1c14:	1f 90       	pop	r1
    1c16:	18 95       	reti

00001c18 <_Z17Serial0_availablev>:
#endif

// Function that can be weakly referenced by serialEventRun to prevent
// pulling in this file if it's not otherwise used.
bool Serial0_available() {
  return Serial.available();
    1c18:	89 ec       	ldi	r24, 0xC9	; 201
    1c1a:	93 e0       	ldi	r25, 0x03	; 3
    1c1c:	0e 94 73 0c 	call	0x18e6	; 0x18e6 <_ZN14HardwareSerial9availableEv>
    1c20:	21 e0       	ldi	r18, 0x01	; 1
    1c22:	89 2b       	or	r24, r25
    1c24:	09 f4       	brne	.+2      	; 0x1c28 <_Z17Serial0_availablev+0x10>
    1c26:	20 e0       	ldi	r18, 0x00	; 0
}
    1c28:	82 2f       	mov	r24, r18
    1c2a:	08 95       	ret

00001c2c <_GLOBAL__sub_I___vector_18>:
    size_t printNumber(unsigned long, uint8_t);
    size_t printFloat(double, uint8_t);
  protected:
    void setWriteError(int err = 1) { write_error = err; }
  public:
    Print() : write_error(0) {}
    1c2c:	e9 ec       	ldi	r30, 0xC9	; 201
    1c2e:	f3 e0       	ldi	r31, 0x03	; 3
    1c30:	13 82       	std	Z+3, r1	; 0x03
    1c32:	12 82       	std	Z+2, r1	; 0x02
  public:
    virtual int available() = 0;
    virtual int read() = 0;
    virtual int peek() = 0;

    Stream() {_timeout=1000;}
    1c34:	88 ee       	ldi	r24, 0xE8	; 232
    1c36:	93 e0       	ldi	r25, 0x03	; 3
    1c38:	a0 e0       	ldi	r26, 0x00	; 0
    1c3a:	b0 e0       	ldi	r27, 0x00	; 0
    1c3c:	84 83       	std	Z+4, r24	; 0x04
    1c3e:	95 83       	std	Z+5, r25	; 0x05
    1c40:	a6 83       	std	Z+6, r26	; 0x06
    1c42:	b7 83       	std	Z+7, r27	; 0x07
  volatile uint8_t *ucsrc, volatile uint8_t *udr) :
    _ubrrh(ubrrh), _ubrrl(ubrrl),
    _ucsra(ucsra), _ucsrb(ucsrb), _ucsrc(ucsrc),
    _udr(udr),
    _rx_buffer_head(0), _rx_buffer_tail(0),
    _tx_buffer_head(0), _tx_buffer_tail(0)
    1c44:	86 e5       	ldi	r24, 0x56	; 86
    1c46:	92 e0       	ldi	r25, 0x02	; 2
    1c48:	91 83       	std	Z+1, r25	; 0x01
    1c4a:	80 83       	st	Z, r24
    1c4c:	85 ec       	ldi	r24, 0xC5	; 197
    1c4e:	90 e0       	ldi	r25, 0x00	; 0
    1c50:	95 87       	std	Z+13, r25	; 0x0d
    1c52:	84 87       	std	Z+12, r24	; 0x0c
    1c54:	84 ec       	ldi	r24, 0xC4	; 196
    1c56:	90 e0       	ldi	r25, 0x00	; 0
    1c58:	97 87       	std	Z+15, r25	; 0x0f
    1c5a:	86 87       	std	Z+14, r24	; 0x0e
    1c5c:	80 ec       	ldi	r24, 0xC0	; 192
    1c5e:	90 e0       	ldi	r25, 0x00	; 0
    1c60:	91 8b       	std	Z+17, r25	; 0x11
    1c62:	80 8b       	std	Z+16, r24	; 0x10
    1c64:	81 ec       	ldi	r24, 0xC1	; 193
    1c66:	90 e0       	ldi	r25, 0x00	; 0
    1c68:	93 8b       	std	Z+19, r25	; 0x13
    1c6a:	82 8b       	std	Z+18, r24	; 0x12
    1c6c:	82 ec       	ldi	r24, 0xC2	; 194
    1c6e:	90 e0       	ldi	r25, 0x00	; 0
    1c70:	95 8b       	std	Z+21, r25	; 0x15
    1c72:	84 8b       	std	Z+20, r24	; 0x14
    1c74:	86 ec       	ldi	r24, 0xC6	; 198
    1c76:	90 e0       	ldi	r25, 0x00	; 0
    1c78:	97 8b       	std	Z+23, r25	; 0x17
    1c7a:	86 8b       	std	Z+22, r24	; 0x16
    1c7c:	11 8e       	std	Z+25, r1	; 0x19
    1c7e:	12 8e       	std	Z+26, r1	; 0x1a
    1c80:	13 8e       	std	Z+27, r1	; 0x1b
    1c82:	14 8e       	std	Z+28, r1	; 0x1c
    1c84:	08 95       	ret

00001c86 <main>:
void setupUSB() __attribute__((weak));
void setupUSB() { }

int main(void)
{
	init();
    1c86:	0e 94 95 11 	call	0x232a	; 0x232a <init>

	initVariant();
    1c8a:	0e 94 a8 1c 	call	0x3950	; 0x3950 <initVariant>

#if defined(USBCON)
	USBDevice.attach();
#endif
	
	setup();
    1c8e:	0e 94 15 07 	call	0xe2a	; 0xe2a <setup>
    
	for (;;) {
		loop();
		if (serialEventRun) serialEventRun();
    1c92:	c0 eb       	ldi	r28, 0xB0	; 176
    1c94:	dc e0       	ldi	r29, 0x0C	; 12
#endif
	
	setup();
    
	for (;;) {
		loop();
    1c96:	0e 94 90 07 	call	0xf20	; 0xf20 <loop>
		if (serialEventRun) serialEventRun();
    1c9a:	20 97       	sbiw	r28, 0x00	; 0
    1c9c:	e1 f3       	breq	.-8      	; 0x1c96 <main+0x10>
    1c9e:	0e 94 b0 0c 	call	0x1960	; 0x1960 <_Z14serialEventRunv>
    1ca2:	f9 cf       	rjmp	.-14     	; 0x1c96 <main+0x10>

00001ca4 <_ZN5Print5writeEPKhj>:
  else return printNumber(n, base);
}

size_t Print::print(double n, int digits)
{
  return printFloat(n, digits);
    1ca4:	cf 92       	push	r12
    1ca6:	df 92       	push	r13
    1ca8:	ef 92       	push	r14
    1caa:	ff 92       	push	r15
    1cac:	0f 93       	push	r16
    1cae:	1f 93       	push	r17
    1cb0:	cf 93       	push	r28
    1cb2:	df 93       	push	r29
    1cb4:	6c 01       	movw	r12, r24
    1cb6:	7a 01       	movw	r14, r20
    1cb8:	8b 01       	movw	r16, r22
    1cba:	c0 e0       	ldi	r28, 0x00	; 0
    1cbc:	d0 e0       	ldi	r29, 0x00	; 0
    1cbe:	ce 15       	cp	r28, r14
    1cc0:	df 05       	cpc	r29, r15
    1cc2:	81 f0       	breq	.+32     	; 0x1ce4 <_ZN5Print5writeEPKhj+0x40>
    1cc4:	d8 01       	movw	r26, r16
    1cc6:	6d 91       	ld	r22, X+
    1cc8:	8d 01       	movw	r16, r26
    1cca:	d6 01       	movw	r26, r12
    1ccc:	ed 91       	ld	r30, X+
    1cce:	fc 91       	ld	r31, X
    1cd0:	01 90       	ld	r0, Z+
    1cd2:	f0 81       	ld	r31, Z
    1cd4:	e0 2d       	mov	r30, r0
    1cd6:	c6 01       	movw	r24, r12
    1cd8:	09 95       	icall
    1cda:	89 2b       	or	r24, r25
    1cdc:	11 f0       	breq	.+4      	; 0x1ce2 <_ZN5Print5writeEPKhj+0x3e>
    1cde:	21 96       	adiw	r28, 0x01	; 1
    1ce0:	ee cf       	rjmp	.-36     	; 0x1cbe <_ZN5Print5writeEPKhj+0x1a>
    1ce2:	7e 01       	movw	r14, r28
    1ce4:	c7 01       	movw	r24, r14
    1ce6:	df 91       	pop	r29
    1ce8:	cf 91       	pop	r28
    1cea:	1f 91       	pop	r17
    1cec:	0f 91       	pop	r16
    1cee:	ff 90       	pop	r15
    1cf0:	ef 90       	pop	r14
    1cf2:	df 90       	pop	r13
    1cf4:	cf 90       	pop	r12
    1cf6:	08 95       	ret

00001cf8 <_ZN5Print5printEPK19__FlashStringHelper>:
    1cf8:	ef 92       	push	r14
    1cfa:	ff 92       	push	r15
    1cfc:	0f 93       	push	r16
    1cfe:	1f 93       	push	r17
    1d00:	cf 93       	push	r28
    1d02:	df 93       	push	r29
    1d04:	8c 01       	movw	r16, r24
    1d06:	7b 01       	movw	r14, r22
    1d08:	c0 e0       	ldi	r28, 0x00	; 0
    1d0a:	d0 e0       	ldi	r29, 0x00	; 0
    1d0c:	f7 01       	movw	r30, r14
    1d0e:	ec 0f       	add	r30, r28
    1d10:	fd 1f       	adc	r31, r29
    1d12:	64 91       	lpm	r22, Z
    1d14:	66 23       	and	r22, r22
    1d16:	61 f0       	breq	.+24     	; 0x1d30 <_ZN5Print5printEPK19__FlashStringHelper+0x38>
    1d18:	d8 01       	movw	r26, r16
    1d1a:	ed 91       	ld	r30, X+
    1d1c:	fc 91       	ld	r31, X
    1d1e:	01 90       	ld	r0, Z+
    1d20:	f0 81       	ld	r31, Z
    1d22:	e0 2d       	mov	r30, r0
    1d24:	c8 01       	movw	r24, r16
    1d26:	09 95       	icall
    1d28:	89 2b       	or	r24, r25
    1d2a:	11 f0       	breq	.+4      	; 0x1d30 <_ZN5Print5printEPK19__FlashStringHelper+0x38>
    1d2c:	21 96       	adiw	r28, 0x01	; 1
    1d2e:	ee cf       	rjmp	.-36     	; 0x1d0c <_ZN5Print5printEPK19__FlashStringHelper+0x14>
    1d30:	ce 01       	movw	r24, r28
    1d32:	df 91       	pop	r29
    1d34:	cf 91       	pop	r28
    1d36:	1f 91       	pop	r17
    1d38:	0f 91       	pop	r16
    1d3a:	ff 90       	pop	r15
    1d3c:	ef 90       	pop	r14
    1d3e:	08 95       	ret

00001d40 <_ZN5Print5printEPKc>:
    1d40:	0c 94 13 02 	jmp	0x426	; 0x426 <_ZN5Print5writeEPKc>

00001d44 <_ZN5Print5printEc>:
    1d44:	dc 01       	movw	r26, r24
    1d46:	ed 91       	ld	r30, X+
    1d48:	fc 91       	ld	r31, X
    1d4a:	01 90       	ld	r0, Z+
    1d4c:	f0 81       	ld	r31, Z
    1d4e:	e0 2d       	mov	r30, r0
    1d50:	09 94       	ijmp

00001d52 <_ZN5Print7printlnEv>:
    1d52:	64 e6       	ldi	r22, 0x64	; 100
    1d54:	72 e0       	ldi	r23, 0x02	; 2
    1d56:	0c 94 13 02 	jmp	0x426	; 0x426 <_ZN5Print5writeEPKc>

00001d5a <_ZN5Print7printlnEPKc>:
    1d5a:	0f 93       	push	r16
    1d5c:	1f 93       	push	r17
    1d5e:	cf 93       	push	r28
    1d60:	df 93       	push	r29
    1d62:	ec 01       	movw	r28, r24
    1d64:	0e 94 13 02 	call	0x426	; 0x426 <_ZN5Print5writeEPKc>
    1d68:	8c 01       	movw	r16, r24
    1d6a:	ce 01       	movw	r24, r28
    1d6c:	0e 94 a9 0e 	call	0x1d52	; 0x1d52 <_ZN5Print7printlnEv>
    1d70:	80 0f       	add	r24, r16
    1d72:	91 1f       	adc	r25, r17
    1d74:	df 91       	pop	r29
    1d76:	cf 91       	pop	r28
    1d78:	1f 91       	pop	r17
    1d7a:	0f 91       	pop	r16
    1d7c:	08 95       	ret

00001d7e <_ZN5Print11printNumberEmh>:
    1d7e:	8f 92       	push	r8
    1d80:	9f 92       	push	r9
    1d82:	af 92       	push	r10
    1d84:	bf 92       	push	r11
    1d86:	ef 92       	push	r14
    1d88:	ff 92       	push	r15
    1d8a:	0f 93       	push	r16
    1d8c:	1f 93       	push	r17
    1d8e:	cf 93       	push	r28
    1d90:	df 93       	push	r29
    1d92:	cd b7       	in	r28, 0x3d	; 61
    1d94:	de b7       	in	r29, 0x3e	; 62
    1d96:	a1 97       	sbiw	r28, 0x21	; 33
    1d98:	0f b6       	in	r0, 0x3f	; 63
    1d9a:	f8 94       	cli
    1d9c:	de bf       	out	0x3e, r29	; 62
    1d9e:	0f be       	out	0x3f, r0	; 63
    1da0:	cd bf       	out	0x3d, r28	; 61
    1da2:	7c 01       	movw	r14, r24
    1da4:	fa 01       	movw	r30, r20
    1da6:	cb 01       	movw	r24, r22
    1da8:	19 a2       	std	Y+33, r1	; 0x21
    1daa:	22 30       	cpi	r18, 0x02	; 2
    1dac:	08 f4       	brcc	.+2      	; 0x1db0 <_ZN5Print11printNumberEmh+0x32>
    1dae:	2a e0       	ldi	r18, 0x0A	; 10
    1db0:	8e 01       	movw	r16, r28
    1db2:	0f 5d       	subi	r16, 0xDF	; 223
    1db4:	1f 4f       	sbci	r17, 0xFF	; 255
    1db6:	82 2e       	mov	r8, r18
    1db8:	91 2c       	mov	r9, r1
    1dba:	a1 2c       	mov	r10, r1
    1dbc:	b1 2c       	mov	r11, r1
    1dbe:	bf 01       	movw	r22, r30
    1dc0:	a5 01       	movw	r20, r10
    1dc2:	94 01       	movw	r18, r8
    1dc4:	0e 94 b6 21 	call	0x436c	; 0x436c <__udivmodsi4>
    1dc8:	f9 01       	movw	r30, r18
    1dca:	ca 01       	movw	r24, r20
    1dcc:	01 50       	subi	r16, 0x01	; 1
    1dce:	11 09       	sbc	r17, r1
    1dd0:	6a 30       	cpi	r22, 0x0A	; 10
    1dd2:	10 f4       	brcc	.+4      	; 0x1dd8 <_ZN5Print11printNumberEmh+0x5a>
    1dd4:	60 5d       	subi	r22, 0xD0	; 208
    1dd6:	01 c0       	rjmp	.+2      	; 0x1dda <_ZN5Print11printNumberEmh+0x5c>
    1dd8:	69 5c       	subi	r22, 0xC9	; 201
    1dda:	d8 01       	movw	r26, r16
    1ddc:	6c 93       	st	X, r22
    1dde:	23 2b       	or	r18, r19
    1de0:	24 2b       	or	r18, r20
    1de2:	25 2b       	or	r18, r21
    1de4:	61 f7       	brne	.-40     	; 0x1dbe <_ZN5Print11printNumberEmh+0x40>
    1de6:	b8 01       	movw	r22, r16
    1de8:	c7 01       	movw	r24, r14
    1dea:	0e 94 13 02 	call	0x426	; 0x426 <_ZN5Print5writeEPKc>
    1dee:	a1 96       	adiw	r28, 0x21	; 33
    1df0:	0f b6       	in	r0, 0x3f	; 63
    1df2:	f8 94       	cli
    1df4:	de bf       	out	0x3e, r29	; 62
    1df6:	0f be       	out	0x3f, r0	; 63
    1df8:	cd bf       	out	0x3d, r28	; 61
    1dfa:	df 91       	pop	r29
    1dfc:	cf 91       	pop	r28
    1dfe:	1f 91       	pop	r17
    1e00:	0f 91       	pop	r16
    1e02:	ff 90       	pop	r15
    1e04:	ef 90       	pop	r14
    1e06:	bf 90       	pop	r11
    1e08:	af 90       	pop	r10
    1e0a:	9f 90       	pop	r9
    1e0c:	8f 90       	pop	r8
    1e0e:	08 95       	ret

00001e10 <_ZN5Print5printEmi>:
    1e10:	21 15       	cp	r18, r1
    1e12:	31 05       	cpc	r19, r1
    1e14:	41 f4       	brne	.+16     	; 0x1e26 <_ZN5Print5printEmi+0x16>
    1e16:	dc 01       	movw	r26, r24
    1e18:	ed 91       	ld	r30, X+
    1e1a:	fc 91       	ld	r31, X
    1e1c:	01 90       	ld	r0, Z+
    1e1e:	f0 81       	ld	r31, Z
    1e20:	e0 2d       	mov	r30, r0
    1e22:	64 2f       	mov	r22, r20
    1e24:	09 94       	ijmp
    1e26:	0c 94 bf 0e 	jmp	0x1d7e	; 0x1d7e <_ZN5Print11printNumberEmh>

00001e2a <_ZN5Print5printEhi>:
    1e2a:	9a 01       	movw	r18, r20
    1e2c:	46 2f       	mov	r20, r22
    1e2e:	50 e0       	ldi	r21, 0x00	; 0
    1e30:	60 e0       	ldi	r22, 0x00	; 0
    1e32:	70 e0       	ldi	r23, 0x00	; 0
    1e34:	0c 94 08 0f 	jmp	0x1e10	; 0x1e10 <_ZN5Print5printEmi>

00001e38 <_ZN5Print5printEji>:
    1e38:	9a 01       	movw	r18, r20
    1e3a:	ab 01       	movw	r20, r22
    1e3c:	60 e0       	ldi	r22, 0x00	; 0
    1e3e:	70 e0       	ldi	r23, 0x00	; 0
    1e40:	0c 94 08 0f 	jmp	0x1e10	; 0x1e10 <_ZN5Print5printEmi>

00001e44 <_ZN5Print5printEli>:
    1e44:	cf 92       	push	r12
    1e46:	df 92       	push	r13
    1e48:	ef 92       	push	r14
    1e4a:	ff 92       	push	r15
    1e4c:	0f 93       	push	r16
    1e4e:	1f 93       	push	r17
    1e50:	cf 93       	push	r28
    1e52:	df 93       	push	r29
    1e54:	21 15       	cp	r18, r1
    1e56:	31 05       	cpc	r19, r1
    1e58:	81 f4       	brne	.+32     	; 0x1e7a <_ZN5Print5printEli+0x36>
    1e5a:	dc 01       	movw	r26, r24
    1e5c:	ed 91       	ld	r30, X+
    1e5e:	fc 91       	ld	r31, X
    1e60:	01 90       	ld	r0, Z+
    1e62:	f0 81       	ld	r31, Z
    1e64:	e0 2d       	mov	r30, r0
    1e66:	64 2f       	mov	r22, r20
    1e68:	df 91       	pop	r29
    1e6a:	cf 91       	pop	r28
    1e6c:	1f 91       	pop	r17
    1e6e:	0f 91       	pop	r16
    1e70:	ff 90       	pop	r15
    1e72:	ef 90       	pop	r14
    1e74:	df 90       	pop	r13
    1e76:	cf 90       	pop	r12
    1e78:	09 94       	ijmp
    1e7a:	2a 30       	cpi	r18, 0x0A	; 10
    1e7c:	31 05       	cpc	r19, r1
    1e7e:	01 f5       	brne	.+64     	; 0x1ec0 <_ZN5Print5printEli+0x7c>
    1e80:	77 ff       	sbrs	r23, 7
    1e82:	1d c0       	rjmp	.+58     	; 0x1ebe <_ZN5Print5printEli+0x7a>
    1e84:	6a 01       	movw	r12, r20
    1e86:	7b 01       	movw	r14, r22
    1e88:	ec 01       	movw	r28, r24
    1e8a:	6d e2       	ldi	r22, 0x2D	; 45
    1e8c:	0e 94 a2 0e 	call	0x1d44	; 0x1d44 <_ZN5Print5printEc>
    1e90:	8c 01       	movw	r16, r24
    1e92:	44 27       	eor	r20, r20
    1e94:	55 27       	eor	r21, r21
    1e96:	ba 01       	movw	r22, r20
    1e98:	4c 19       	sub	r20, r12
    1e9a:	5d 09       	sbc	r21, r13
    1e9c:	6e 09       	sbc	r22, r14
    1e9e:	7f 09       	sbc	r23, r15
    1ea0:	2a e0       	ldi	r18, 0x0A	; 10
    1ea2:	ce 01       	movw	r24, r28
    1ea4:	0e 94 bf 0e 	call	0x1d7e	; 0x1d7e <_ZN5Print11printNumberEmh>
    1ea8:	80 0f       	add	r24, r16
    1eaa:	91 1f       	adc	r25, r17
    1eac:	df 91       	pop	r29
    1eae:	cf 91       	pop	r28
    1eb0:	1f 91       	pop	r17
    1eb2:	0f 91       	pop	r16
    1eb4:	ff 90       	pop	r15
    1eb6:	ef 90       	pop	r14
    1eb8:	df 90       	pop	r13
    1eba:	cf 90       	pop	r12
    1ebc:	08 95       	ret
    1ebe:	2a e0       	ldi	r18, 0x0A	; 10
    1ec0:	df 91       	pop	r29
    1ec2:	cf 91       	pop	r28
    1ec4:	1f 91       	pop	r17
    1ec6:	0f 91       	pop	r16
    1ec8:	ff 90       	pop	r15
    1eca:	ef 90       	pop	r14
    1ecc:	df 90       	pop	r13
    1ece:	cf 90       	pop	r12
    1ed0:	0c 94 bf 0e 	jmp	0x1d7e	; 0x1d7e <_ZN5Print11printNumberEmh>

00001ed4 <_ZN5Print5printEii>:
    1ed4:	9a 01       	movw	r18, r20
    1ed6:	ab 01       	movw	r20, r22
    1ed8:	77 0f       	add	r23, r23
    1eda:	66 0b       	sbc	r22, r22
    1edc:	77 0b       	sbc	r23, r23
    1ede:	0c 94 22 0f 	jmp	0x1e44	; 0x1e44 <_ZN5Print5printEli>

00001ee2 <_ZN5Print7printlnEii>:
    1ee2:	0f 93       	push	r16
    1ee4:	1f 93       	push	r17
    1ee6:	cf 93       	push	r28
    1ee8:	df 93       	push	r29
    1eea:	ec 01       	movw	r28, r24
    1eec:	0e 94 6a 0f 	call	0x1ed4	; 0x1ed4 <_ZN5Print5printEii>
    1ef0:	8c 01       	movw	r16, r24
    1ef2:	ce 01       	movw	r24, r28
    1ef4:	0e 94 a9 0e 	call	0x1d52	; 0x1d52 <_ZN5Print7printlnEv>
    1ef8:	80 0f       	add	r24, r16
    1efa:	91 1f       	adc	r25, r17
    1efc:	df 91       	pop	r29
    1efe:	cf 91       	pop	r28
    1f00:	1f 91       	pop	r17
    1f02:	0f 91       	pop	r16
    1f04:	08 95       	ret

00001f06 <_ZN5Print10printFloatEdh>:
    1f06:	7f 92       	push	r7
    1f08:	8f 92       	push	r8
    1f0a:	9f 92       	push	r9
    1f0c:	af 92       	push	r10
    1f0e:	bf 92       	push	r11
    1f10:	cf 92       	push	r12
    1f12:	df 92       	push	r13
    1f14:	ef 92       	push	r14
    1f16:	ff 92       	push	r15
    1f18:	0f 93       	push	r16
    1f1a:	1f 93       	push	r17
    1f1c:	cf 93       	push	r28
    1f1e:	df 93       	push	r29
    1f20:	8c 01       	movw	r16, r24
    1f22:	6a 01       	movw	r12, r20
    1f24:	7b 01       	movw	r14, r22
    1f26:	72 2e       	mov	r7, r18
    1f28:	9a 01       	movw	r18, r20
    1f2a:	ab 01       	movw	r20, r22
    1f2c:	c7 01       	movw	r24, r14
    1f2e:	b6 01       	movw	r22, r12
    1f30:	0e 94 9d 21 	call	0x433a	; 0x433a <__unordsf2>
    1f34:	88 23       	and	r24, r24
    1f36:	19 f0       	breq	.+6      	; 0x1f3e <_ZN5Print10printFloatEdh+0x38>
    1f38:	67 e6       	ldi	r22, 0x67	; 103
    1f3a:	72 e0       	ldi	r23, 0x02	; 2
    1f3c:	27 c0       	rjmp	.+78     	; 0x1f8c <_ZN5Print10printFloatEdh+0x86>
    1f3e:	46 01       	movw	r8, r12
    1f40:	57 01       	movw	r10, r14
    1f42:	e8 94       	clt
    1f44:	b7 f8       	bld	r11, 7
    1f46:	2f ef       	ldi	r18, 0xFF	; 255
    1f48:	3f ef       	ldi	r19, 0xFF	; 255
    1f4a:	4f e7       	ldi	r20, 0x7F	; 127
    1f4c:	5f e7       	ldi	r21, 0x7F	; 127
    1f4e:	c5 01       	movw	r24, r10
    1f50:	b4 01       	movw	r22, r8
    1f52:	0e 94 9d 21 	call	0x433a	; 0x433a <__unordsf2>
    1f56:	81 11       	cpse	r24, r1
    1f58:	0d c0       	rjmp	.+26     	; 0x1f74 <_ZN5Print10printFloatEdh+0x6e>
    1f5a:	2f ef       	ldi	r18, 0xFF	; 255
    1f5c:	3f ef       	ldi	r19, 0xFF	; 255
    1f5e:	4f e7       	ldi	r20, 0x7F	; 127
    1f60:	5f e7       	ldi	r21, 0x7F	; 127
    1f62:	c5 01       	movw	r24, r10
    1f64:	b4 01       	movw	r22, r8
    1f66:	0e 94 a2 0a 	call	0x1544	; 0x1544 <__cmpsf2>
    1f6a:	18 16       	cp	r1, r24
    1f6c:	1c f4       	brge	.+6      	; 0x1f74 <_ZN5Print10printFloatEdh+0x6e>
    1f6e:	6b e6       	ldi	r22, 0x6B	; 107
    1f70:	72 e0       	ldi	r23, 0x02	; 2
    1f72:	0c c0       	rjmp	.+24     	; 0x1f8c <_ZN5Print10printFloatEdh+0x86>
    1f74:	2f ef       	ldi	r18, 0xFF	; 255
    1f76:	3f ef       	ldi	r19, 0xFF	; 255
    1f78:	4f e7       	ldi	r20, 0x7F	; 127
    1f7a:	5f e4       	ldi	r21, 0x4F	; 79
    1f7c:	c7 01       	movw	r24, r14
    1f7e:	b6 01       	movw	r22, r12
    1f80:	0e 94 01 0c 	call	0x1802	; 0x1802 <__gesf2>
    1f84:	18 16       	cp	r1, r24
    1f86:	94 f4       	brge	.+36     	; 0x1fac <_ZN5Print10printFloatEdh+0xa6>
    1f88:	6f e6       	ldi	r22, 0x6F	; 111
    1f8a:	72 e0       	ldi	r23, 0x02	; 2
    1f8c:	c8 01       	movw	r24, r16
    1f8e:	df 91       	pop	r29
    1f90:	cf 91       	pop	r28
    1f92:	1f 91       	pop	r17
    1f94:	0f 91       	pop	r16
    1f96:	ff 90       	pop	r15
    1f98:	ef 90       	pop	r14
    1f9a:	df 90       	pop	r13
    1f9c:	cf 90       	pop	r12
    1f9e:	bf 90       	pop	r11
    1fa0:	af 90       	pop	r10
    1fa2:	9f 90       	pop	r9
    1fa4:	8f 90       	pop	r8
    1fa6:	7f 90       	pop	r7
    1fa8:	0c 94 13 02 	jmp	0x426	; 0x426 <_ZN5Print5writeEPKc>
    1fac:	2f ef       	ldi	r18, 0xFF	; 255
    1fae:	3f ef       	ldi	r19, 0xFF	; 255
    1fb0:	4f e7       	ldi	r20, 0x7F	; 127
    1fb2:	5f ec       	ldi	r21, 0xCF	; 207
    1fb4:	c7 01       	movw	r24, r14
    1fb6:	b6 01       	movw	r22, r12
    1fb8:	0e 94 a2 0a 	call	0x1544	; 0x1544 <__cmpsf2>
    1fbc:	87 fd       	sbrc	r24, 7
    1fbe:	e4 cf       	rjmp	.-56     	; 0x1f88 <_ZN5Print10printFloatEdh+0x82>
    1fc0:	20 e0       	ldi	r18, 0x00	; 0
    1fc2:	30 e0       	ldi	r19, 0x00	; 0
    1fc4:	a9 01       	movw	r20, r18
    1fc6:	c7 01       	movw	r24, r14
    1fc8:	b6 01       	movw	r22, r12
    1fca:	0e 94 a2 0a 	call	0x1544	; 0x1544 <__cmpsf2>
    1fce:	87 ff       	sbrs	r24, 7
    1fd0:	0a c0       	rjmp	.+20     	; 0x1fe6 <_ZN5Print10printFloatEdh+0xe0>
    1fd2:	6d e2       	ldi	r22, 0x2D	; 45
    1fd4:	c8 01       	movw	r24, r16
    1fd6:	0e 94 a2 0e 	call	0x1d44	; 0x1d44 <_ZN5Print5printEc>
    1fda:	ec 01       	movw	r28, r24
    1fdc:	f7 fa       	bst	r15, 7
    1fde:	f0 94       	com	r15
    1fe0:	f7 f8       	bld	r15, 7
    1fe2:	f0 94       	com	r15
    1fe4:	02 c0       	rjmp	.+4      	; 0x1fea <_ZN5Print10printFloatEdh+0xe4>
    1fe6:	c0 e0       	ldi	r28, 0x00	; 0
    1fe8:	d0 e0       	ldi	r29, 0x00	; 0
    1fea:	b1 2c       	mov	r11, r1
    1fec:	60 e0       	ldi	r22, 0x00	; 0
    1fee:	70 e0       	ldi	r23, 0x00	; 0
    1ff0:	80 e0       	ldi	r24, 0x00	; 0
    1ff2:	9f e3       	ldi	r25, 0x3F	; 63
    1ff4:	7b 14       	cp	r7, r11
    1ff6:	41 f0       	breq	.+16     	; 0x2008 <_ZN5Print10printFloatEdh+0x102>
    1ff8:	20 e0       	ldi	r18, 0x00	; 0
    1ffa:	30 e0       	ldi	r19, 0x00	; 0
    1ffc:	40 e2       	ldi	r20, 0x20	; 32
    1ffe:	51 e4       	ldi	r21, 0x41	; 65
    2000:	0e 94 a7 0a 	call	0x154e	; 0x154e <__divsf3>
    2004:	b3 94       	inc	r11
    2006:	f6 cf       	rjmp	.-20     	; 0x1ff4 <_ZN5Print10printFloatEdh+0xee>
    2008:	a7 01       	movw	r20, r14
    200a:	96 01       	movw	r18, r12
    200c:	0e 94 36 0a 	call	0x146c	; 0x146c <__addsf3>
    2010:	6b 01       	movw	r12, r22
    2012:	7c 01       	movw	r14, r24
    2014:	0e 94 20 0b 	call	0x1640	; 0x1640 <__fixunssfsi>
    2018:	4b 01       	movw	r8, r22
    201a:	5c 01       	movw	r10, r24
    201c:	2a e0       	ldi	r18, 0x0A	; 10
    201e:	ab 01       	movw	r20, r22
    2020:	bc 01       	movw	r22, r24
    2022:	c8 01       	movw	r24, r16
    2024:	0e 94 bf 0e 	call	0x1d7e	; 0x1d7e <_ZN5Print11printNumberEmh>
    2028:	c8 0f       	add	r28, r24
    202a:	d9 1f       	adc	r29, r25
    202c:	77 20       	and	r7, r7
    202e:	b9 f1       	breq	.+110    	; 0x209e <_ZN5Print10printFloatEdh+0x198>
    2030:	c5 01       	movw	r24, r10
    2032:	b4 01       	movw	r22, r8
    2034:	0e 94 4f 0b 	call	0x169e	; 0x169e <__floatunsisf>
    2038:	9b 01       	movw	r18, r22
    203a:	ac 01       	movw	r20, r24
    203c:	c7 01       	movw	r24, r14
    203e:	b6 01       	movw	r22, r12
    2040:	0e 94 35 0a 	call	0x146a	; 0x146a <__subsf3>
    2044:	6b 01       	movw	r12, r22
    2046:	7c 01       	movw	r14, r24
    2048:	6e e2       	ldi	r22, 0x2E	; 46
    204a:	c8 01       	movw	r24, r16
    204c:	0e 94 a2 0e 	call	0x1d44	; 0x1d44 <_ZN5Print5printEc>
    2050:	c8 0f       	add	r28, r24
    2052:	d9 1f       	adc	r29, r25
    2054:	20 e0       	ldi	r18, 0x00	; 0
    2056:	30 e0       	ldi	r19, 0x00	; 0
    2058:	40 e2       	ldi	r20, 0x20	; 32
    205a:	51 e4       	ldi	r21, 0x41	; 65
    205c:	c7 01       	movw	r24, r14
    205e:	b6 01       	movw	r22, r12
    2060:	0e 94 06 0c 	call	0x180c	; 0x180c <__mulsf3>
    2064:	4b 01       	movw	r8, r22
    2066:	5c 01       	movw	r10, r24
    2068:	0e 94 20 0b 	call	0x1640	; 0x1640 <__fixunssfsi>
    206c:	6b 01       	movw	r12, r22
    206e:	7c 01       	movw	r14, r24
    2070:	4a e0       	ldi	r20, 0x0A	; 10
    2072:	50 e0       	ldi	r21, 0x00	; 0
    2074:	c8 01       	movw	r24, r16
    2076:	0e 94 1c 0f 	call	0x1e38	; 0x1e38 <_ZN5Print5printEji>
    207a:	c8 0f       	add	r28, r24
    207c:	d9 1f       	adc	r29, r25
    207e:	b6 01       	movw	r22, r12
    2080:	80 e0       	ldi	r24, 0x00	; 0
    2082:	90 e0       	ldi	r25, 0x00	; 0
    2084:	0e 94 4f 0b 	call	0x169e	; 0x169e <__floatunsisf>
    2088:	9b 01       	movw	r18, r22
    208a:	ac 01       	movw	r20, r24
    208c:	c5 01       	movw	r24, r10
    208e:	b4 01       	movw	r22, r8
    2090:	0e 94 35 0a 	call	0x146a	; 0x146a <__subsf3>
    2094:	6b 01       	movw	r12, r22
    2096:	7c 01       	movw	r14, r24
    2098:	7a 94       	dec	r7
    209a:	71 10       	cpse	r7, r1
    209c:	db cf       	rjmp	.-74     	; 0x2054 <_ZN5Print10printFloatEdh+0x14e>
    209e:	ce 01       	movw	r24, r28
    20a0:	df 91       	pop	r29
    20a2:	cf 91       	pop	r28
    20a4:	1f 91       	pop	r17
    20a6:	0f 91       	pop	r16
    20a8:	ff 90       	pop	r15
    20aa:	ef 90       	pop	r14
    20ac:	df 90       	pop	r13
    20ae:	cf 90       	pop	r12
    20b0:	bf 90       	pop	r11
    20b2:	af 90       	pop	r10
    20b4:	9f 90       	pop	r9
    20b6:	8f 90       	pop	r8
    20b8:	7f 90       	pop	r7
    20ba:	08 95       	ret

000020bc <_ZN5Print7printlnEdi>:
  n += println();
  return n;
}

size_t Print::println(double num, int digits)
{
    20bc:	0f 93       	push	r16
    20be:	1f 93       	push	r17
    20c0:	cf 93       	push	r28
    20c2:	df 93       	push	r29
    20c4:	ec 01       	movw	r28, r24
  else return printNumber(n, base);
}

size_t Print::print(double n, int digits)
{
  return printFloat(n, digits);
    20c6:	0e 94 83 0f 	call	0x1f06	; 0x1f06 <_ZN5Print10printFloatEdh>
    20ca:	8c 01       	movw	r16, r24
}

size_t Print::println(double num, int digits)
{
  size_t n = print(num, digits);
  n += println();
    20cc:	ce 01       	movw	r24, r28
    20ce:	0e 94 a9 0e 	call	0x1d52	; 0x1d52 <_ZN5Print7printlnEv>
  return n;
}
    20d2:	80 0f       	add	r24, r16
    20d4:	91 1f       	adc	r25, r17
    20d6:	df 91       	pop	r29
    20d8:	cf 91       	pop	r28
    20da:	1f 91       	pop	r17
    20dc:	0f 91       	pop	r16
    20de:	08 95       	ret

000020e0 <nothing>:
    #endif
      break;       
#endif
    }
      
    intFunc[interruptNum] = nothing;
    20e0:	08 95       	ret

000020e2 <attachInterrupt>:
    20e2:	82 30       	cpi	r24, 0x02	; 2
    20e4:	e8 f4       	brcc	.+58     	; 0x2120 <attachInterrupt+0x3e>
    20e6:	e8 2f       	mov	r30, r24
    20e8:	f0 e0       	ldi	r31, 0x00	; 0
    20ea:	ee 0f       	add	r30, r30
    20ec:	ff 1f       	adc	r31, r31
    20ee:	e4 5d       	subi	r30, 0xD4	; 212
    20f0:	fe 4f       	sbci	r31, 0xFE	; 254
    20f2:	71 83       	std	Z+1, r23	; 0x01
    20f4:	60 83       	st	Z, r22
    20f6:	81 30       	cpi	r24, 0x01	; 1
    20f8:	41 f0       	breq	.+16     	; 0x210a <attachInterrupt+0x28>
    20fa:	80 91 69 00 	lds	r24, 0x0069	; 0x800069 <__DATA_REGION_ORIGIN__+0x9>
    20fe:	8c 7f       	andi	r24, 0xFC	; 252
    2100:	48 2b       	or	r20, r24
    2102:	40 93 69 00 	sts	0x0069, r20	; 0x800069 <__DATA_REGION_ORIGIN__+0x9>
    2106:	e8 9a       	sbi	0x1d, 0	; 29
    2108:	08 95       	ret
    210a:	80 91 69 00 	lds	r24, 0x0069	; 0x800069 <__DATA_REGION_ORIGIN__+0x9>
    210e:	83 7f       	andi	r24, 0xF3	; 243
    2110:	44 0f       	add	r20, r20
    2112:	55 1f       	adc	r21, r21
    2114:	44 0f       	add	r20, r20
    2116:	55 1f       	adc	r21, r21
    2118:	48 2b       	or	r20, r24
    211a:	40 93 69 00 	sts	0x0069, r20	; 0x800069 <__DATA_REGION_ORIGIN__+0x9>
    211e:	e9 9a       	sbi	0x1d, 1	; 29
    2120:	08 95       	ret

00002122 <__vector_1>:
IMPLEMENT_ISR(INT6_vect, EXTERNAL_INT_6)
IMPLEMENT_ISR(INT7_vect, EXTERNAL_INT_7)

#else

IMPLEMENT_ISR(INT0_vect, EXTERNAL_INT_0)
    2122:	1f 92       	push	r1
    2124:	0f 92       	push	r0
    2126:	0f b6       	in	r0, 0x3f	; 63
    2128:	0f 92       	push	r0
    212a:	11 24       	eor	r1, r1
    212c:	2f 93       	push	r18
    212e:	3f 93       	push	r19
    2130:	4f 93       	push	r20
    2132:	5f 93       	push	r21
    2134:	6f 93       	push	r22
    2136:	7f 93       	push	r23
    2138:	8f 93       	push	r24
    213a:	9f 93       	push	r25
    213c:	af 93       	push	r26
    213e:	bf 93       	push	r27
    2140:	ef 93       	push	r30
    2142:	ff 93       	push	r31
    2144:	e0 91 2c 01 	lds	r30, 0x012C	; 0x80012c <intFunc>
    2148:	f0 91 2d 01 	lds	r31, 0x012D	; 0x80012d <intFunc+0x1>
    214c:	09 95       	icall
    214e:	ff 91       	pop	r31
    2150:	ef 91       	pop	r30
    2152:	bf 91       	pop	r27
    2154:	af 91       	pop	r26
    2156:	9f 91       	pop	r25
    2158:	8f 91       	pop	r24
    215a:	7f 91       	pop	r23
    215c:	6f 91       	pop	r22
    215e:	5f 91       	pop	r21
    2160:	4f 91       	pop	r20
    2162:	3f 91       	pop	r19
    2164:	2f 91       	pop	r18
    2166:	0f 90       	pop	r0
    2168:	0f be       	out	0x3f, r0	; 63
    216a:	0f 90       	pop	r0
    216c:	1f 90       	pop	r1
    216e:	18 95       	reti

00002170 <__vector_2>:
IMPLEMENT_ISR(INT1_vect, EXTERNAL_INT_1)
    2170:	1f 92       	push	r1
    2172:	0f 92       	push	r0
    2174:	0f b6       	in	r0, 0x3f	; 63
    2176:	0f 92       	push	r0
    2178:	11 24       	eor	r1, r1
    217a:	2f 93       	push	r18
    217c:	3f 93       	push	r19
    217e:	4f 93       	push	r20
    2180:	5f 93       	push	r21
    2182:	6f 93       	push	r22
    2184:	7f 93       	push	r23
    2186:	8f 93       	push	r24
    2188:	9f 93       	push	r25
    218a:	af 93       	push	r26
    218c:	bf 93       	push	r27
    218e:	ef 93       	push	r30
    2190:	ff 93       	push	r31
    2192:	e0 91 2e 01 	lds	r30, 0x012E	; 0x80012e <intFunc+0x2>
    2196:	f0 91 2f 01 	lds	r31, 0x012F	; 0x80012f <intFunc+0x3>
    219a:	09 95       	icall
    219c:	ff 91       	pop	r31
    219e:	ef 91       	pop	r30
    21a0:	bf 91       	pop	r27
    21a2:	af 91       	pop	r26
    21a4:	9f 91       	pop	r25
    21a6:	8f 91       	pop	r24
    21a8:	7f 91       	pop	r23
    21aa:	6f 91       	pop	r22
    21ac:	5f 91       	pop	r21
    21ae:	4f 91       	pop	r20
    21b0:	3f 91       	pop	r19
    21b2:	2f 91       	pop	r18
    21b4:	0f 90       	pop	r0
    21b6:	0f be       	out	0x3f, r0	; 63
    21b8:	0f 90       	pop	r0
    21ba:	1f 90       	pop	r1
    21bc:	18 95       	reti

000021be <__vector_16>:
	cli();
	m = timer0_millis;
	SREG = oldSREG;

	return m;
}
    21be:	1f 92       	push	r1
    21c0:	0f 92       	push	r0
    21c2:	0f b6       	in	r0, 0x3f	; 63
    21c4:	0f 92       	push	r0
    21c6:	11 24       	eor	r1, r1
    21c8:	2f 93       	push	r18
    21ca:	3f 93       	push	r19
    21cc:	8f 93       	push	r24
    21ce:	9f 93       	push	r25
    21d0:	af 93       	push	r26
    21d2:	bf 93       	push	r27
    21d4:	80 91 67 04 	lds	r24, 0x0467	; 0x800467 <timer0_millis>
    21d8:	90 91 68 04 	lds	r25, 0x0468	; 0x800468 <timer0_millis+0x1>
    21dc:	a0 91 69 04 	lds	r26, 0x0469	; 0x800469 <timer0_millis+0x2>
    21e0:	b0 91 6a 04 	lds	r27, 0x046A	; 0x80046a <timer0_millis+0x3>
    21e4:	30 91 66 04 	lds	r19, 0x0466	; 0x800466 <timer0_fract>
    21e8:	23 e0       	ldi	r18, 0x03	; 3
    21ea:	23 0f       	add	r18, r19
    21ec:	2d 37       	cpi	r18, 0x7D	; 125
    21ee:	20 f4       	brcc	.+8      	; 0x21f8 <__vector_16+0x3a>
    21f0:	01 96       	adiw	r24, 0x01	; 1
    21f2:	a1 1d       	adc	r26, r1
    21f4:	b1 1d       	adc	r27, r1
    21f6:	05 c0       	rjmp	.+10     	; 0x2202 <__vector_16+0x44>
    21f8:	26 e8       	ldi	r18, 0x86	; 134
    21fa:	23 0f       	add	r18, r19
    21fc:	02 96       	adiw	r24, 0x02	; 2
    21fe:	a1 1d       	adc	r26, r1
    2200:	b1 1d       	adc	r27, r1
    2202:	20 93 66 04 	sts	0x0466, r18	; 0x800466 <timer0_fract>
    2206:	80 93 67 04 	sts	0x0467, r24	; 0x800467 <timer0_millis>
    220a:	90 93 68 04 	sts	0x0468, r25	; 0x800468 <timer0_millis+0x1>
    220e:	a0 93 69 04 	sts	0x0469, r26	; 0x800469 <timer0_millis+0x2>
    2212:	b0 93 6a 04 	sts	0x046A, r27	; 0x80046a <timer0_millis+0x3>
    2216:	80 91 6b 04 	lds	r24, 0x046B	; 0x80046b <timer0_overflow_count>
    221a:	90 91 6c 04 	lds	r25, 0x046C	; 0x80046c <timer0_overflow_count+0x1>
    221e:	a0 91 6d 04 	lds	r26, 0x046D	; 0x80046d <timer0_overflow_count+0x2>
    2222:	b0 91 6e 04 	lds	r27, 0x046E	; 0x80046e <timer0_overflow_count+0x3>
    2226:	01 96       	adiw	r24, 0x01	; 1
    2228:	a1 1d       	adc	r26, r1
    222a:	b1 1d       	adc	r27, r1
    222c:	80 93 6b 04 	sts	0x046B, r24	; 0x80046b <timer0_overflow_count>
    2230:	90 93 6c 04 	sts	0x046C, r25	; 0x80046c <timer0_overflow_count+0x1>
    2234:	a0 93 6d 04 	sts	0x046D, r26	; 0x80046d <timer0_overflow_count+0x2>
    2238:	b0 93 6e 04 	sts	0x046E, r27	; 0x80046e <timer0_overflow_count+0x3>
    223c:	bf 91       	pop	r27
    223e:	af 91       	pop	r26
    2240:	9f 91       	pop	r25
    2242:	8f 91       	pop	r24
    2244:	3f 91       	pop	r19
    2246:	2f 91       	pop	r18
    2248:	0f 90       	pop	r0
    224a:	0f be       	out	0x3f, r0	; 63
    224c:	0f 90       	pop	r0
    224e:	1f 90       	pop	r1
    2250:	18 95       	reti

00002252 <micros>:

unsigned long micros() {
	unsigned long m;
	uint8_t oldSREG = SREG, t;
    2252:	3f b7       	in	r19, 0x3f	; 63
	
	cli();
    2254:	f8 94       	cli
	m = timer0_overflow_count;
    2256:	80 91 6b 04 	lds	r24, 0x046B	; 0x80046b <timer0_overflow_count>
    225a:	90 91 6c 04 	lds	r25, 0x046C	; 0x80046c <timer0_overflow_count+0x1>
    225e:	a0 91 6d 04 	lds	r26, 0x046D	; 0x80046d <timer0_overflow_count+0x2>
    2262:	b0 91 6e 04 	lds	r27, 0x046E	; 0x80046e <timer0_overflow_count+0x3>
#if defined(TCNT0)
	t = TCNT0;
    2266:	26 b5       	in	r18, 0x26	; 38
#else
	#error TIMER 0 not defined
#endif

#ifdef TIFR0
	if ((TIFR0 & _BV(TOV0)) && (t < 255))
    2268:	a8 9b       	sbis	0x15, 0	; 21
    226a:	05 c0       	rjmp	.+10     	; 0x2276 <micros+0x24>
    226c:	2f 3f       	cpi	r18, 0xFF	; 255
    226e:	19 f0       	breq	.+6      	; 0x2276 <micros+0x24>
		m++;
    2270:	01 96       	adiw	r24, 0x01	; 1
    2272:	a1 1d       	adc	r26, r1
    2274:	b1 1d       	adc	r27, r1
#else
	if ((TIFR & _BV(TOV0)) && (t < 255))
		m++;
#endif

	SREG = oldSREG;
    2276:	3f bf       	out	0x3f, r19	; 63
	
	return ((m << 8) + t) * (64 / clockCyclesPerMicrosecond());
    2278:	ba 2f       	mov	r27, r26
    227a:	a9 2f       	mov	r26, r25
    227c:	98 2f       	mov	r25, r24
    227e:	88 27       	eor	r24, r24
    2280:	82 0f       	add	r24, r18
    2282:	91 1d       	adc	r25, r1
    2284:	a1 1d       	adc	r26, r1
    2286:	b1 1d       	adc	r27, r1
    2288:	bc 01       	movw	r22, r24
    228a:	cd 01       	movw	r24, r26
    228c:	42 e0       	ldi	r20, 0x02	; 2
    228e:	66 0f       	add	r22, r22
    2290:	77 1f       	adc	r23, r23
    2292:	88 1f       	adc	r24, r24
    2294:	99 1f       	adc	r25, r25
    2296:	4a 95       	dec	r20
    2298:	d1 f7       	brne	.-12     	; 0x228e <micros+0x3c>
}
    229a:	08 95       	ret

0000229c <delay>:

void delay(unsigned long ms)
{
    229c:	8f 92       	push	r8
    229e:	9f 92       	push	r9
    22a0:	af 92       	push	r10
    22a2:	bf 92       	push	r11
    22a4:	cf 92       	push	r12
    22a6:	df 92       	push	r13
    22a8:	ef 92       	push	r14
    22aa:	ff 92       	push	r15
    22ac:	6b 01       	movw	r12, r22
    22ae:	7c 01       	movw	r14, r24
	uint32_t start = micros();
    22b0:	0e 94 29 11 	call	0x2252	; 0x2252 <micros>
    22b4:	4b 01       	movw	r8, r22
    22b6:	5c 01       	movw	r10, r24

	while (ms > 0) {
    22b8:	c1 14       	cp	r12, r1
    22ba:	d1 04       	cpc	r13, r1
    22bc:	e1 04       	cpc	r14, r1
    22be:	f1 04       	cpc	r15, r1
    22c0:	01 f1       	breq	.+64     	; 0x2302 <delay+0x66>
		yield();
    22c2:	0e 94 76 1e 	call	0x3cec	; 0x3cec <yield>
		while ( ms > 0 && (micros() - start) >= 1000) {
    22c6:	0e 94 29 11 	call	0x2252	; 0x2252 <micros>
    22ca:	dc 01       	movw	r26, r24
    22cc:	cb 01       	movw	r24, r22
    22ce:	88 19       	sub	r24, r8
    22d0:	99 09       	sbc	r25, r9
    22d2:	aa 09       	sbc	r26, r10
    22d4:	bb 09       	sbc	r27, r11
    22d6:	88 3e       	cpi	r24, 0xE8	; 232
    22d8:	93 40       	sbci	r25, 0x03	; 3
    22da:	a1 05       	cpc	r26, r1
    22dc:	b1 05       	cpc	r27, r1
    22de:	60 f3       	brcs	.-40     	; 0x22b8 <delay+0x1c>
			ms--;
    22e0:	21 e0       	ldi	r18, 0x01	; 1
    22e2:	c2 1a       	sub	r12, r18
    22e4:	d1 08       	sbc	r13, r1
    22e6:	e1 08       	sbc	r14, r1
    22e8:	f1 08       	sbc	r15, r1
			start += 1000;
    22ea:	88 ee       	ldi	r24, 0xE8	; 232
    22ec:	88 0e       	add	r8, r24
    22ee:	83 e0       	ldi	r24, 0x03	; 3
    22f0:	98 1e       	adc	r9, r24
    22f2:	a1 1c       	adc	r10, r1
    22f4:	b1 1c       	adc	r11, r1
{
	uint32_t start = micros();

	while (ms > 0) {
		yield();
		while ( ms > 0 && (micros() - start) >= 1000) {
    22f6:	c1 14       	cp	r12, r1
    22f8:	d1 04       	cpc	r13, r1
    22fa:	e1 04       	cpc	r14, r1
    22fc:	f1 04       	cpc	r15, r1
    22fe:	19 f7       	brne	.-58     	; 0x22c6 <delay+0x2a>
    2300:	db cf       	rjmp	.-74     	; 0x22b8 <delay+0x1c>
			ms--;
			start += 1000;
		}
	}
}
    2302:	ff 90       	pop	r15
    2304:	ef 90       	pop	r14
    2306:	df 90       	pop	r13
    2308:	cf 90       	pop	r12
    230a:	bf 90       	pop	r11
    230c:	af 90       	pop	r10
    230e:	9f 90       	pop	r9
    2310:	8f 90       	pop	r8
    2312:	08 95       	ret

00002314 <delayMicroseconds>:
#elif F_CPU >= 16000000L
	// for the 16 MHz clock on most Arduino boards

	// for a one-microsecond delay, simply return.  the overhead
	// of the function call takes 14 (16) cycles, which is 1us
	if (us <= 1) return; //  = 3 cycles, (4 when true)
    2314:	82 30       	cpi	r24, 0x02	; 2
    2316:	91 05       	cpc	r25, r1
    2318:	38 f0       	brcs	.+14     	; 0x2328 <delayMicroseconds+0x14>

	// the following loop takes 1/4 of a microsecond (4 cycles)
	// per iteration, so execute it four times for each microsecond of
	// delay requested.
	us <<= 2; // x4 us, = 4 cycles
    231a:	88 0f       	add	r24, r24
    231c:	99 1f       	adc	r25, r25
    231e:	88 0f       	add	r24, r24
    2320:	99 1f       	adc	r25, r25

	// account for the time taken in the preceeding commands.
	// we just burned 19 (21) cycles above, remove 5, (5*4=20)
	// us is at least 8 so we can substract 5
	us -= 5; // = 2 cycles,
    2322:	05 97       	sbiw	r24, 0x05	; 5
	

#endif

	// busy wait
	__asm__ __volatile__ (
    2324:	01 97       	sbiw	r24, 0x01	; 1
    2326:	f1 f7       	brne	.-4      	; 0x2324 <delayMicroseconds+0x10>
    2328:	08 95       	ret

0000232a <init>:

void init()
{
	// this needs to be called before setup() or some functions won't
	// work there
	sei();
    232a:	78 94       	sei
	
	// on the ATmega168, timer 0 is also used for fast hardware pwm
	// (using phase-correct PWM would mean that timer 0 overflowed half as often
	// resulting in different millis() behavior on the ATmega8 and ATmega168)
#if defined(TCCR0A) && defined(WGM01)
	sbi(TCCR0A, WGM01);
    232c:	84 b5       	in	r24, 0x24	; 36
    232e:	82 60       	ori	r24, 0x02	; 2
    2330:	84 bd       	out	0x24, r24	; 36
	sbi(TCCR0A, WGM00);
    2332:	84 b5       	in	r24, 0x24	; 36
    2334:	81 60       	ori	r24, 0x01	; 1
    2336:	84 bd       	out	0x24, r24	; 36
	// this combination is for the standard atmega8
	sbi(TCCR0, CS01);
	sbi(TCCR0, CS00);
#elif defined(TCCR0B) && defined(CS01) && defined(CS00)
	// this combination is for the standard 168/328/1280/2560
	sbi(TCCR0B, CS01);
    2338:	85 b5       	in	r24, 0x25	; 37
    233a:	82 60       	ori	r24, 0x02	; 2
    233c:	85 bd       	out	0x25, r24	; 37
	sbi(TCCR0B, CS00);
    233e:	85 b5       	in	r24, 0x25	; 37
    2340:	81 60       	ori	r24, 0x01	; 1
    2342:	85 bd       	out	0x25, r24	; 37

	// enable timer 0 overflow interrupt
#if defined(TIMSK) && defined(TOIE0)
	sbi(TIMSK, TOIE0);
#elif defined(TIMSK0) && defined(TOIE0)
	sbi(TIMSK0, TOIE0);
    2344:	ee e6       	ldi	r30, 0x6E	; 110
    2346:	f0 e0       	ldi	r31, 0x00	; 0
    2348:	80 81       	ld	r24, Z
    234a:	81 60       	ori	r24, 0x01	; 1
    234c:	80 83       	st	Z, r24
	// this is better for motors as it ensures an even waveform
	// note, however, that fast pwm mode can achieve a frequency of up
	// 8 MHz (with a 16 MHz clock) at 50% duty cycle

#if defined(TCCR1B) && defined(CS11) && defined(CS10)
	TCCR1B = 0;
    234e:	e1 e8       	ldi	r30, 0x81	; 129
    2350:	f0 e0       	ldi	r31, 0x00	; 0
    2352:	10 82       	st	Z, r1

	// set timer 1 prescale factor to 64
	sbi(TCCR1B, CS11);
    2354:	80 81       	ld	r24, Z
    2356:	82 60       	ori	r24, 0x02	; 2
    2358:	80 83       	st	Z, r24
#if F_CPU >= 8000000L
	sbi(TCCR1B, CS10);
    235a:	80 81       	ld	r24, Z
    235c:	81 60       	ori	r24, 0x01	; 1
    235e:	80 83       	st	Z, r24
	sbi(TCCR1, CS10);
#endif
#endif
	// put timer 1 in 8-bit phase correct pwm mode
#if defined(TCCR1A) && defined(WGM10)
	sbi(TCCR1A, WGM10);
    2360:	e0 e8       	ldi	r30, 0x80	; 128
    2362:	f0 e0       	ldi	r31, 0x00	; 0
    2364:	80 81       	ld	r24, Z
    2366:	81 60       	ori	r24, 0x01	; 1
    2368:	80 83       	st	Z, r24

	// set timer 2 prescale factor to 64
#if defined(TCCR2) && defined(CS22)
	sbi(TCCR2, CS22);
#elif defined(TCCR2B) && defined(CS22)
	sbi(TCCR2B, CS22);
    236a:	e1 eb       	ldi	r30, 0xB1	; 177
    236c:	f0 e0       	ldi	r31, 0x00	; 0
    236e:	80 81       	ld	r24, Z
    2370:	84 60       	ori	r24, 0x04	; 4
    2372:	80 83       	st	Z, r24

	// configure timer 2 for phase correct pwm (8-bit)
#if defined(TCCR2) && defined(WGM20)
	sbi(TCCR2, WGM20);
#elif defined(TCCR2A) && defined(WGM20)
	sbi(TCCR2A, WGM20);
    2374:	e0 eb       	ldi	r30, 0xB0	; 176
    2376:	f0 e0       	ldi	r31, 0x00	; 0
    2378:	80 81       	ld	r24, Z
    237a:	81 60       	ori	r24, 0x01	; 1
    237c:	80 83       	st	Z, r24
#endif

#if defined(ADCSRA)
	// set a2d prescaler so we are inside the desired 50-200 KHz range.
	#if F_CPU >= 16000000 // 16 MHz / 128 = 125 KHz
		sbi(ADCSRA, ADPS2);
    237e:	ea e7       	ldi	r30, 0x7A	; 122
    2380:	f0 e0       	ldi	r31, 0x00	; 0
    2382:	80 81       	ld	r24, Z
    2384:	84 60       	ori	r24, 0x04	; 4
    2386:	80 83       	st	Z, r24
		sbi(ADCSRA, ADPS1);
    2388:	80 81       	ld	r24, Z
    238a:	82 60       	ori	r24, 0x02	; 2
    238c:	80 83       	st	Z, r24
		sbi(ADCSRA, ADPS0);
    238e:	80 81       	ld	r24, Z
    2390:	81 60       	ori	r24, 0x01	; 1
    2392:	80 83       	st	Z, r24
		cbi(ADCSRA, ADPS2);
		cbi(ADCSRA, ADPS1);
		sbi(ADCSRA, ADPS0);
	#endif
	// enable a2d conversions
	sbi(ADCSRA, ADEN);
    2394:	80 81       	ld	r24, Z
    2396:	80 68       	ori	r24, 0x80	; 128
    2398:	80 83       	st	Z, r24
	// here so they can be used as normal digital i/o; they will be
	// reconnected in Serial.begin()
#if defined(UCSRB)
	UCSRB = 0;
#elif defined(UCSR0B)
	UCSR0B = 0;
    239a:	10 92 c1 00 	sts	0x00C1, r1	; 0x8000c1 <__DATA_REGION_ORIGIN__+0x61>
    239e:	08 95       	ret

000023a0 <analogRead>:
#elif defined(__AVR_ATmega32U4__)
	if (pin >= 18) pin -= 18; // allow for channel or pin numbers
#elif defined(__AVR_ATmega1284__) || defined(__AVR_ATmega1284P__) || defined(__AVR_ATmega644__) || defined(__AVR_ATmega644A__) || defined(__AVR_ATmega644P__) || defined(__AVR_ATmega644PA__)
	if (pin >= 24) pin -= 24; // allow for channel or pin numbers
#else
	if (pin >= 14) pin -= 14; // allow for channel or pin numbers
    23a0:	8e 30       	cpi	r24, 0x0E	; 14
    23a2:	08 f0       	brcs	.+2      	; 0x23a6 <analogRead+0x6>
    23a4:	8e 50       	subi	r24, 0x0E	; 14
	// to 0 (the default).
#if defined(ADMUX)
#if defined(__AVR_ATtiny25__) || defined(__AVR_ATtiny45__) || defined(__AVR_ATtiny85__)
	ADMUX = (analog_reference << 4) | (pin & 0x07);
#else
	ADMUX = (analog_reference << 6) | (pin & 0x07);
    23a6:	20 91 30 01 	lds	r18, 0x0130	; 0x800130 <analog_reference>
    23aa:	90 e4       	ldi	r25, 0x40	; 64
    23ac:	29 9f       	mul	r18, r25
    23ae:	90 01       	movw	r18, r0
    23b0:	11 24       	eor	r1, r1
    23b2:	87 70       	andi	r24, 0x07	; 7
    23b4:	82 2b       	or	r24, r18
    23b6:	80 93 7c 00 	sts	0x007C, r24	; 0x80007c <__DATA_REGION_ORIGIN__+0x1c>
	// without a delay, we seem to read from the wrong channel
	//delay(1);

#if defined(ADCSRA) && defined(ADCL)
	// start the conversion
	sbi(ADCSRA, ADSC);
    23ba:	80 91 7a 00 	lds	r24, 0x007A	; 0x80007a <__DATA_REGION_ORIGIN__+0x1a>
    23be:	80 64       	ori	r24, 0x40	; 64
    23c0:	80 93 7a 00 	sts	0x007A, r24	; 0x80007a <__DATA_REGION_ORIGIN__+0x1a>

	// ADSC is cleared when the conversion finishes
	while (bit_is_set(ADCSRA, ADSC));
    23c4:	80 91 7a 00 	lds	r24, 0x007A	; 0x80007a <__DATA_REGION_ORIGIN__+0x1a>
    23c8:	86 fd       	sbrc	r24, 6
    23ca:	fc cf       	rjmp	.-8      	; 0x23c4 <analogRead+0x24>

	// we have to read ADCL first; doing so locks both ADCL
	// and ADCH until ADCH is read.  reading ADCL second would
	// cause the results of each conversion to be discarded,
	// as ADCL and ADCH would be locked when it completed.
	low  = ADCL;
    23cc:	80 91 78 00 	lds	r24, 0x0078	; 0x800078 <__DATA_REGION_ORIGIN__+0x18>
	high = ADCH;
    23d0:	20 91 79 00 	lds	r18, 0x0079	; 0x800079 <__DATA_REGION_ORIGIN__+0x19>
	low  = 0;
	high = 0;
#endif

	// combine the two bytes
	return (high << 8) | low;
    23d4:	90 e0       	ldi	r25, 0x00	; 0
}
    23d6:	92 2b       	or	r25, r18
    23d8:	08 95       	ret

000023da <analogWrite>:
// Right now, PWM output only works on the pins with
// hardware support.  These are defined in the appropriate
// pins_*.c file.  For the rest of the pins, we default
// to digital output.
void analogWrite(uint8_t pin, int val)
{
    23da:	1f 93       	push	r17
    23dc:	cf 93       	push	r28
    23de:	df 93       	push	r29
    23e0:	18 2f       	mov	r17, r24
    23e2:	eb 01       	movw	r28, r22
	// We need to make sure the PWM output is enabled for those pins
	// that support it, as we turn it off when digitally reading or
	// writing with them.  Also, make sure the pin is in output mode
	// for consistenty with Wiring, which doesn't require a pinMode
	// call for the analog output pins.
	pinMode(pin, OUTPUT);
    23e4:	61 e0       	ldi	r22, 0x01	; 1
    23e6:	0e 94 75 12 	call	0x24ea	; 0x24ea <pinMode>
	if (val == 0)
    23ea:	20 97       	sbiw	r28, 0x00	; 0
    23ec:	11 f4       	brne	.+4      	; 0x23f2 <analogWrite+0x18>
	{
		digitalWrite(pin, LOW);
    23ee:	60 e0       	ldi	r22, 0x00	; 0
    23f0:	04 c0       	rjmp	.+8      	; 0x23fa <analogWrite+0x20>
	}
	else if (val == 255)
    23f2:	cf 3f       	cpi	r28, 0xFF	; 255
    23f4:	d1 05       	cpc	r29, r1
    23f6:	39 f4       	brne	.+14     	; 0x2406 <analogWrite+0x2c>
	{
		digitalWrite(pin, HIGH);
    23f8:	61 e0       	ldi	r22, 0x01	; 1
    23fa:	81 2f       	mov	r24, r17
				} else {
					digitalWrite(pin, HIGH);
				}
		}
	}
}
    23fc:	df 91       	pop	r29
    23fe:	cf 91       	pop	r28
    2400:	1f 91       	pop	r17
	{
		digitalWrite(pin, LOW);
	}
	else if (val == 255)
	{
		digitalWrite(pin, HIGH);
    2402:	0c 94 b1 12 	jmp	0x2562	; 0x2562 <digitalWrite>
	}
	else
	{
		switch(digitalPinToTimer(pin))
    2406:	e1 2f       	mov	r30, r17
    2408:	f0 e0       	ldi	r31, 0x00	; 0
    240a:	ee 54       	subi	r30, 0x4E	; 78
    240c:	ff 4f       	sbci	r31, 0xFF	; 255
    240e:	e4 91       	lpm	r30, Z
    2410:	e3 30       	cpi	r30, 0x03	; 3
    2412:	f9 f0       	breq	.+62     	; 0x2452 <analogWrite+0x78>
    2414:	48 f4       	brcc	.+18     	; 0x2428 <analogWrite+0x4e>
    2416:	e1 30       	cpi	r30, 0x01	; 1
    2418:	b9 f0       	breq	.+46     	; 0x2448 <analogWrite+0x6e>
    241a:	e2 30       	cpi	r30, 0x02	; 2
    241c:	a1 f5       	brne	.+104    	; 0x2486 <analogWrite+0xac>
			#endif

			#if defined(TCCR0A) && defined(COM0B1)
			case TIMER0B:
				// connect pwm to pin on timer 0, channel B
				sbi(TCCR0A, COM0B1);
    241e:	84 b5       	in	r24, 0x24	; 36
    2420:	80 62       	ori	r24, 0x20	; 32
    2422:	84 bd       	out	0x24, r24	; 36
				OCR0B = val; // set pwm duty
    2424:	c8 bd       	out	0x28, r28	; 40
				break;
    2426:	34 c0       	rjmp	.+104    	; 0x2490 <analogWrite+0xb6>
	{
		digitalWrite(pin, HIGH);
	}
	else
	{
		switch(digitalPinToTimer(pin))
    2428:	e7 30       	cpi	r30, 0x07	; 7
    242a:	e9 f0       	breq	.+58     	; 0x2466 <analogWrite+0x8c>
    242c:	e8 30       	cpi	r30, 0x08	; 8
    242e:	19 f1       	breq	.+70     	; 0x2476 <analogWrite+0x9c>
    2430:	e4 30       	cpi	r30, 0x04	; 4
    2432:	49 f5       	brne	.+82     	; 0x2486 <analogWrite+0xac>
			#endif

			#if defined(TCCR1A) && defined(COM1B1)
			case TIMER1B:
				// connect pwm to pin on timer 1, channel B
				sbi(TCCR1A, COM1B1);
    2434:	80 91 80 00 	lds	r24, 0x0080	; 0x800080 <__DATA_REGION_ORIGIN__+0x20>
    2438:	80 62       	ori	r24, 0x20	; 32
    243a:	80 93 80 00 	sts	0x0080, r24	; 0x800080 <__DATA_REGION_ORIGIN__+0x20>
				OCR1B = val; // set pwm duty
    243e:	d0 93 8b 00 	sts	0x008B, r29	; 0x80008b <__DATA_REGION_ORIGIN__+0x2b>
    2442:	c0 93 8a 00 	sts	0x008A, r28	; 0x80008a <__DATA_REGION_ORIGIN__+0x2a>
				break;
    2446:	24 c0       	rjmp	.+72     	; 0x2490 <analogWrite+0xb6>
			#endif

			#if defined(TCCR0A) && defined(COM0A1)
			case TIMER0A:
				// connect pwm to pin on timer 0, channel A
				sbi(TCCR0A, COM0A1);
    2448:	84 b5       	in	r24, 0x24	; 36
    244a:	80 68       	ori	r24, 0x80	; 128
    244c:	84 bd       	out	0x24, r24	; 36
				OCR0A = val; // set pwm duty
    244e:	c7 bd       	out	0x27, r28	; 39
				break;
    2450:	1f c0       	rjmp	.+62     	; 0x2490 <analogWrite+0xb6>
			#endif

			#if defined(TCCR1A) && defined(COM1A1)
			case TIMER1A:
				// connect pwm to pin on timer 1, channel A
				sbi(TCCR1A, COM1A1);
    2452:	80 91 80 00 	lds	r24, 0x0080	; 0x800080 <__DATA_REGION_ORIGIN__+0x20>
    2456:	80 68       	ori	r24, 0x80	; 128
    2458:	80 93 80 00 	sts	0x0080, r24	; 0x800080 <__DATA_REGION_ORIGIN__+0x20>
				OCR1A = val; // set pwm duty
    245c:	d0 93 89 00 	sts	0x0089, r29	; 0x800089 <__DATA_REGION_ORIGIN__+0x29>
    2460:	c0 93 88 00 	sts	0x0088, r28	; 0x800088 <__DATA_REGION_ORIGIN__+0x28>
				break;
    2464:	15 c0       	rjmp	.+42     	; 0x2490 <analogWrite+0xb6>
			#endif

			#if defined(TCCR2A) && defined(COM2A1)
			case TIMER2A:
				// connect pwm to pin on timer 2, channel A
				sbi(TCCR2A, COM2A1);
    2466:	80 91 b0 00 	lds	r24, 0x00B0	; 0x8000b0 <__DATA_REGION_ORIGIN__+0x50>
    246a:	80 68       	ori	r24, 0x80	; 128
    246c:	80 93 b0 00 	sts	0x00B0, r24	; 0x8000b0 <__DATA_REGION_ORIGIN__+0x50>
				OCR2A = val; // set pwm duty
    2470:	c0 93 b3 00 	sts	0x00B3, r28	; 0x8000b3 <__DATA_REGION_ORIGIN__+0x53>
				break;
    2474:	0d c0       	rjmp	.+26     	; 0x2490 <analogWrite+0xb6>
			#endif

			#if defined(TCCR2A) && defined(COM2B1)
			case TIMER2B:
				// connect pwm to pin on timer 2, channel B
				sbi(TCCR2A, COM2B1);
    2476:	80 91 b0 00 	lds	r24, 0x00B0	; 0x8000b0 <__DATA_REGION_ORIGIN__+0x50>
    247a:	80 62       	ori	r24, 0x20	; 32
    247c:	80 93 b0 00 	sts	0x00B0, r24	; 0x8000b0 <__DATA_REGION_ORIGIN__+0x50>
				OCR2B = val; // set pwm duty
    2480:	c0 93 b4 00 	sts	0x00B4, r28	; 0x8000b4 <__DATA_REGION_ORIGIN__+0x54>
				break;
    2484:	05 c0       	rjmp	.+10     	; 0x2490 <analogWrite+0xb6>
				break;
			#endif

			case NOT_ON_TIMER:
			default:
				if (val < 128) {
    2486:	c0 38       	cpi	r28, 0x80	; 128
    2488:	d1 05       	cpc	r29, r1
    248a:	0c f0       	brlt	.+2      	; 0x248e <analogWrite+0xb4>
    248c:	b5 cf       	rjmp	.-150    	; 0x23f8 <analogWrite+0x1e>
    248e:	af cf       	rjmp	.-162    	; 0x23ee <analogWrite+0x14>
				} else {
					digitalWrite(pin, HIGH);
				}
		}
	}
}
    2490:	df 91       	pop	r29
    2492:	cf 91       	pop	r28
    2494:	1f 91       	pop	r17
    2496:	08 95       	ret

00002498 <turnOffPWM>:
//
//static inline void turnOffPWM(uint8_t timer) __attribute__ ((always_inline));
//static inline void turnOffPWM(uint8_t timer)
static void turnOffPWM(uint8_t timer)
{
	switch (timer)
    2498:	83 30       	cpi	r24, 0x03	; 3
    249a:	81 f0       	breq	.+32     	; 0x24bc <turnOffPWM+0x24>
    249c:	28 f4       	brcc	.+10     	; 0x24a8 <turnOffPWM+0x10>
    249e:	81 30       	cpi	r24, 0x01	; 1
    24a0:	99 f0       	breq	.+38     	; 0x24c8 <turnOffPWM+0x30>
    24a2:	82 30       	cpi	r24, 0x02	; 2
    24a4:	a1 f0       	breq	.+40     	; 0x24ce <turnOffPWM+0x36>
    24a6:	08 95       	ret
    24a8:	87 30       	cpi	r24, 0x07	; 7
    24aa:	a9 f0       	breq	.+42     	; 0x24d6 <turnOffPWM+0x3e>
    24ac:	88 30       	cpi	r24, 0x08	; 8
    24ae:	b9 f0       	breq	.+46     	; 0x24de <turnOffPWM+0x46>
    24b0:	84 30       	cpi	r24, 0x04	; 4
    24b2:	d1 f4       	brne	.+52     	; 0x24e8 <turnOffPWM+0x50>
	{
		#if defined(TCCR1A) && defined(COM1A1)
		case TIMER1A:   cbi(TCCR1A, COM1A1);    break;
		#endif
		#if defined(TCCR1A) && defined(COM1B1)
		case TIMER1B:   cbi(TCCR1A, COM1B1);    break;
    24b4:	80 91 80 00 	lds	r24, 0x0080	; 0x800080 <__DATA_REGION_ORIGIN__+0x20>
    24b8:	8f 7d       	andi	r24, 0xDF	; 223
    24ba:	03 c0       	rjmp	.+6      	; 0x24c2 <turnOffPWM+0x2a>
static void turnOffPWM(uint8_t timer)
{
	switch (timer)
	{
		#if defined(TCCR1A) && defined(COM1A1)
		case TIMER1A:   cbi(TCCR1A, COM1A1);    break;
    24bc:	80 91 80 00 	lds	r24, 0x0080	; 0x800080 <__DATA_REGION_ORIGIN__+0x20>
    24c0:	8f 77       	andi	r24, 0x7F	; 127
		#endif
		#if defined(TCCR1A) && defined(COM1B1)
		case TIMER1B:   cbi(TCCR1A, COM1B1);    break;
    24c2:	80 93 80 00 	sts	0x0080, r24	; 0x800080 <__DATA_REGION_ORIGIN__+0x20>
    24c6:	08 95       	ret
		#if defined(TCCR2) && defined(COM21)
		case  TIMER2:   cbi(TCCR2, COM21);      break;
		#endif
		
		#if defined(TCCR0A) && defined(COM0A1)
		case  TIMER0A:  cbi(TCCR0A, COM0A1);    break;
    24c8:	84 b5       	in	r24, 0x24	; 36
    24ca:	8f 77       	andi	r24, 0x7F	; 127
    24cc:	02 c0       	rjmp	.+4      	; 0x24d2 <turnOffPWM+0x3a>
		#endif
		
		#if defined(TCCR0A) && defined(COM0B1)
		case  TIMER0B:  cbi(TCCR0A, COM0B1);    break;
    24ce:	84 b5       	in	r24, 0x24	; 36
    24d0:	8f 7d       	andi	r24, 0xDF	; 223
    24d2:	84 bd       	out	0x24, r24	; 36
    24d4:	08 95       	ret
		#endif
		#if defined(TCCR2A) && defined(COM2A1)
		case  TIMER2A:  cbi(TCCR2A, COM2A1);    break;
    24d6:	80 91 b0 00 	lds	r24, 0x00B0	; 0x8000b0 <__DATA_REGION_ORIGIN__+0x50>
    24da:	8f 77       	andi	r24, 0x7F	; 127
    24dc:	03 c0       	rjmp	.+6      	; 0x24e4 <turnOffPWM+0x4c>
		#endif
		#if defined(TCCR2A) && defined(COM2B1)
		case  TIMER2B:  cbi(TCCR2A, COM2B1);    break;
    24de:	80 91 b0 00 	lds	r24, 0x00B0	; 0x8000b0 <__DATA_REGION_ORIGIN__+0x50>
    24e2:	8f 7d       	andi	r24, 0xDF	; 223
    24e4:	80 93 b0 00 	sts	0x00B0, r24	; 0x8000b0 <__DATA_REGION_ORIGIN__+0x50>
    24e8:	08 95       	ret

000024ea <pinMode>:
#define ARDUINO_MAIN
#include "wiring_private.h"
#include "pins_arduino.h"

void pinMode(uint8_t pin, uint8_t mode)
{
    24ea:	cf 93       	push	r28
    24ec:	df 93       	push	r29
	uint8_t bit = digitalPinToBitMask(pin);
    24ee:	90 e0       	ldi	r25, 0x00	; 0
    24f0:	fc 01       	movw	r30, r24
    24f2:	ea 53       	subi	r30, 0x3A	; 58
    24f4:	ff 4f       	sbci	r31, 0xFF	; 255
    24f6:	24 91       	lpm	r18, Z
	uint8_t port = digitalPinToPort(pin);
    24f8:	fc 01       	movw	r30, r24
    24fa:	e6 52       	subi	r30, 0x26	; 38
    24fc:	ff 4f       	sbci	r31, 0xFF	; 255
    24fe:	84 91       	lpm	r24, Z
	volatile uint8_t *reg, *out;

	if (port == NOT_A_PIN) return;
    2500:	88 23       	and	r24, r24
    2502:	61 f1       	breq	.+88     	; 0x255c <pinMode+0x72>

	// JWS: can I let the optimizer do this?
	reg = portModeRegister(port);
    2504:	90 e0       	ldi	r25, 0x00	; 0
    2506:	88 0f       	add	r24, r24
    2508:	99 1f       	adc	r25, r25
    250a:	fc 01       	movw	r30, r24
    250c:	ee 5f       	subi	r30, 0xFE	; 254
    250e:	fe 4f       	sbci	r31, 0xFE	; 254
    2510:	c5 91       	lpm	r28, Z+
    2512:	d4 91       	lpm	r29, Z
	out = portOutputRegister(port);
    2514:	fc 01       	movw	r30, r24
    2516:	e8 50       	subi	r30, 0x08	; 8
    2518:	ff 4f       	sbci	r31, 0xFF	; 255
    251a:	a5 91       	lpm	r26, Z+
    251c:	b4 91       	lpm	r27, Z

	if (mode == INPUT) { 
    251e:	61 11       	cpse	r22, r1
    2520:	09 c0       	rjmp	.+18     	; 0x2534 <pinMode+0x4a>
		uint8_t oldSREG = SREG;
    2522:	9f b7       	in	r25, 0x3f	; 63
                cli();
    2524:	f8 94       	cli
		*reg &= ~bit;
    2526:	88 81       	ld	r24, Y
    2528:	20 95       	com	r18
    252a:	82 23       	and	r24, r18
    252c:	88 83       	st	Y, r24
		*out &= ~bit;
    252e:	ec 91       	ld	r30, X
    2530:	2e 23       	and	r18, r30
    2532:	0b c0       	rjmp	.+22     	; 0x254a <pinMode+0x60>
		SREG = oldSREG;
	} else if (mode == INPUT_PULLUP) {
    2534:	62 30       	cpi	r22, 0x02	; 2
    2536:	61 f4       	brne	.+24     	; 0x2550 <pinMode+0x66>
		uint8_t oldSREG = SREG;
    2538:	9f b7       	in	r25, 0x3f	; 63
                cli();
    253a:	f8 94       	cli
		*reg &= ~bit;
    253c:	88 81       	ld	r24, Y
    253e:	32 2f       	mov	r19, r18
    2540:	30 95       	com	r19
    2542:	83 23       	and	r24, r19
    2544:	88 83       	st	Y, r24
		*out |= bit;
    2546:	ec 91       	ld	r30, X
    2548:	2e 2b       	or	r18, r30
    254a:	2c 93       	st	X, r18
		SREG = oldSREG;
    254c:	9f bf       	out	0x3f, r25	; 63
    254e:	06 c0       	rjmp	.+12     	; 0x255c <pinMode+0x72>
	} else {
		uint8_t oldSREG = SREG;
    2550:	8f b7       	in	r24, 0x3f	; 63
                cli();
    2552:	f8 94       	cli
		*reg |= bit;
    2554:	e8 81       	ld	r30, Y
    2556:	2e 2b       	or	r18, r30
    2558:	28 83       	st	Y, r18
		SREG = oldSREG;
    255a:	8f bf       	out	0x3f, r24	; 63
	}
}
    255c:	df 91       	pop	r29
    255e:	cf 91       	pop	r28
    2560:	08 95       	ret

00002562 <digitalWrite>:
		#endif
	}
}

void digitalWrite(uint8_t pin, uint8_t val)
{
    2562:	1f 93       	push	r17
    2564:	cf 93       	push	r28
    2566:	df 93       	push	r29
	uint8_t timer = digitalPinToTimer(pin);
    2568:	28 2f       	mov	r18, r24
    256a:	30 e0       	ldi	r19, 0x00	; 0
    256c:	f9 01       	movw	r30, r18
    256e:	ee 54       	subi	r30, 0x4E	; 78
    2570:	ff 4f       	sbci	r31, 0xFF	; 255
    2572:	84 91       	lpm	r24, Z
	uint8_t bit = digitalPinToBitMask(pin);
    2574:	f9 01       	movw	r30, r18
    2576:	ea 53       	subi	r30, 0x3A	; 58
    2578:	ff 4f       	sbci	r31, 0xFF	; 255
    257a:	d4 91       	lpm	r29, Z
	uint8_t port = digitalPinToPort(pin);
    257c:	f9 01       	movw	r30, r18
    257e:	e6 52       	subi	r30, 0x26	; 38
    2580:	ff 4f       	sbci	r31, 0xFF	; 255
    2582:	c4 91       	lpm	r28, Z
	volatile uint8_t *out;

	if (port == NOT_A_PIN) return;
    2584:	cc 23       	and	r28, r28
    2586:	c1 f0       	breq	.+48     	; 0x25b8 <digitalWrite+0x56>
    2588:	16 2f       	mov	r17, r22

	// If the pin that support PWM output, we need to turn it off
	// before doing a digital write.
	if (timer != NOT_ON_TIMER) turnOffPWM(timer);
    258a:	81 11       	cpse	r24, r1
    258c:	0e 94 4c 12 	call	0x2498	; 0x2498 <turnOffPWM>

	out = portOutputRegister(port);
    2590:	ec 2f       	mov	r30, r28
    2592:	f0 e0       	ldi	r31, 0x00	; 0
    2594:	ee 0f       	add	r30, r30
    2596:	ff 1f       	adc	r31, r31
    2598:	e8 50       	subi	r30, 0x08	; 8
    259a:	ff 4f       	sbci	r31, 0xFF	; 255
    259c:	a5 91       	lpm	r26, Z+
    259e:	b4 91       	lpm	r27, Z

	uint8_t oldSREG = SREG;
    25a0:	9f b7       	in	r25, 0x3f	; 63
	cli();
    25a2:	f8 94       	cli

	if (val == LOW) {
    25a4:	11 11       	cpse	r17, r1
    25a6:	04 c0       	rjmp	.+8      	; 0x25b0 <digitalWrite+0x4e>
		*out &= ~bit;
    25a8:	8c 91       	ld	r24, X
    25aa:	d0 95       	com	r29
    25ac:	d8 23       	and	r29, r24
    25ae:	02 c0       	rjmp	.+4      	; 0x25b4 <digitalWrite+0x52>
	} else {
		*out |= bit;
    25b0:	ec 91       	ld	r30, X
    25b2:	de 2b       	or	r29, r30
    25b4:	dc 93       	st	X, r29
	}

	SREG = oldSREG;
    25b6:	9f bf       	out	0x3f, r25	; 63
}
    25b8:	df 91       	pop	r29
    25ba:	cf 91       	pop	r28
    25bc:	1f 91       	pop	r17
    25be:	08 95       	ret

000025c0 <prvIsQueueEmpty>:
    {
        xReturn = pdFALSE;
    }

    return xReturn;
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
    25c0:	0f b6       	in	r0, 0x3f	; 63
    25c2:	f8 94       	cli
    25c4:	0f 92       	push	r0
    25c6:	fc 01       	movw	r30, r24
    25c8:	92 8d       	ldd	r25, Z+26	; 0x1a
    25ca:	0f 90       	pop	r0
    25cc:	0f be       	out	0x3f, r0	; 63
    25ce:	81 e0       	ldi	r24, 0x01	; 1
    25d0:	91 11       	cpse	r25, r1
    25d2:	80 e0       	ldi	r24, 0x00	; 0
    25d4:	08 95       	ret

000025d6 <prvCopyDataToQueue>:
    25d6:	0f 93       	push	r16
    25d8:	1f 93       	push	r17
    25da:	cf 93       	push	r28
    25dc:	df 93       	push	r29
    25de:	ec 01       	movw	r28, r24
    25e0:	04 2f       	mov	r16, r20
    25e2:	1a 8d       	ldd	r17, Y+26	; 0x1a
    25e4:	4c 8d       	ldd	r20, Y+28	; 0x1c
    25e6:	41 11       	cpse	r20, r1
    25e8:	0b c0       	rjmp	.+22     	; 0x2600 <prvCopyDataToQueue+0x2a>
    25ea:	88 81       	ld	r24, Y
    25ec:	99 81       	ldd	r25, Y+1	; 0x01
    25ee:	89 2b       	or	r24, r25
    25f0:	e9 f5       	brne	.+122    	; 0x266c <prvCopyDataToQueue+0x96>
    25f2:	8c 81       	ldd	r24, Y+4	; 0x04
    25f4:	9d 81       	ldd	r25, Y+5	; 0x05
    25f6:	0e 94 68 1a 	call	0x34d0	; 0x34d0 <xTaskPriorityDisinherit>
    25fa:	1d 82       	std	Y+5, r1	; 0x05
    25fc:	1c 82       	std	Y+4, r1	; 0x04
    25fe:	37 c0       	rjmp	.+110    	; 0x266e <prvCopyDataToQueue+0x98>
    2600:	50 e0       	ldi	r21, 0x00	; 0
    2602:	01 11       	cpse	r16, r1
    2604:	15 c0       	rjmp	.+42     	; 0x2630 <prvCopyDataToQueue+0x5a>
    2606:	8a 81       	ldd	r24, Y+2	; 0x02
    2608:	9b 81       	ldd	r25, Y+3	; 0x03
    260a:	0e 94 4c 23 	call	0x4698	; 0x4698 <memcpy>
    260e:	2c 8d       	ldd	r18, Y+28	; 0x1c
    2610:	8a 81       	ldd	r24, Y+2	; 0x02
    2612:	9b 81       	ldd	r25, Y+3	; 0x03
    2614:	82 0f       	add	r24, r18
    2616:	91 1d       	adc	r25, r1
    2618:	9b 83       	std	Y+3, r25	; 0x03
    261a:	8a 83       	std	Y+2, r24	; 0x02
    261c:	2c 81       	ldd	r18, Y+4	; 0x04
    261e:	3d 81       	ldd	r19, Y+5	; 0x05
    2620:	82 17       	cp	r24, r18
    2622:	93 07       	cpc	r25, r19
    2624:	18 f1       	brcs	.+70     	; 0x266c <prvCopyDataToQueue+0x96>
    2626:	88 81       	ld	r24, Y
    2628:	99 81       	ldd	r25, Y+1	; 0x01
    262a:	9b 83       	std	Y+3, r25	; 0x03
    262c:	8a 83       	std	Y+2, r24	; 0x02
    262e:	1e c0       	rjmp	.+60     	; 0x266c <prvCopyDataToQueue+0x96>
    2630:	8e 81       	ldd	r24, Y+6	; 0x06
    2632:	9f 81       	ldd	r25, Y+7	; 0x07
    2634:	0e 94 4c 23 	call	0x4698	; 0x4698 <memcpy>
    2638:	8c 8d       	ldd	r24, Y+28	; 0x1c
    263a:	90 e0       	ldi	r25, 0x00	; 0
    263c:	91 95       	neg	r25
    263e:	81 95       	neg	r24
    2640:	91 09       	sbc	r25, r1
    2642:	2e 81       	ldd	r18, Y+6	; 0x06
    2644:	3f 81       	ldd	r19, Y+7	; 0x07
    2646:	28 0f       	add	r18, r24
    2648:	39 1f       	adc	r19, r25
    264a:	3f 83       	std	Y+7, r19	; 0x07
    264c:	2e 83       	std	Y+6, r18	; 0x06
    264e:	48 81       	ld	r20, Y
    2650:	59 81       	ldd	r21, Y+1	; 0x01
    2652:	24 17       	cp	r18, r20
    2654:	35 07       	cpc	r19, r21
    2656:	30 f4       	brcc	.+12     	; 0x2664 <prvCopyDataToQueue+0x8e>
    2658:	2c 81       	ldd	r18, Y+4	; 0x04
    265a:	3d 81       	ldd	r19, Y+5	; 0x05
    265c:	82 0f       	add	r24, r18
    265e:	93 1f       	adc	r25, r19
    2660:	9f 83       	std	Y+7, r25	; 0x07
    2662:	8e 83       	std	Y+6, r24	; 0x06
    2664:	02 30       	cpi	r16, 0x02	; 2
    2666:	11 f4       	brne	.+4      	; 0x266c <prvCopyDataToQueue+0x96>
    2668:	11 11       	cpse	r17, r1
    266a:	11 50       	subi	r17, 0x01	; 1
    266c:	80 e0       	ldi	r24, 0x00	; 0
    266e:	1f 5f       	subi	r17, 0xFF	; 255
    2670:	1a 8f       	std	Y+26, r17	; 0x1a
    2672:	df 91       	pop	r29
    2674:	cf 91       	pop	r28
    2676:	1f 91       	pop	r17
    2678:	0f 91       	pop	r16
    267a:	08 95       	ret

0000267c <prvCopyDataFromQueue>:
    267c:	fc 01       	movw	r30, r24
    267e:	cb 01       	movw	r24, r22
    2680:	44 8d       	ldd	r20, Z+28	; 0x1c
    2682:	44 23       	and	r20, r20
    2684:	a1 f0       	breq	.+40     	; 0x26ae <prvCopyDataFromQueue+0x32>
    2686:	50 e0       	ldi	r21, 0x00	; 0
    2688:	26 81       	ldd	r18, Z+6	; 0x06
    268a:	37 81       	ldd	r19, Z+7	; 0x07
    268c:	24 0f       	add	r18, r20
    268e:	35 1f       	adc	r19, r21
    2690:	37 83       	std	Z+7, r19	; 0x07
    2692:	26 83       	std	Z+6, r18	; 0x06
    2694:	64 81       	ldd	r22, Z+4	; 0x04
    2696:	75 81       	ldd	r23, Z+5	; 0x05
    2698:	26 17       	cp	r18, r22
    269a:	37 07       	cpc	r19, r23
    269c:	20 f0       	brcs	.+8      	; 0x26a6 <prvCopyDataFromQueue+0x2a>
    269e:	20 81       	ld	r18, Z
    26a0:	31 81       	ldd	r19, Z+1	; 0x01
    26a2:	37 83       	std	Z+7, r19	; 0x07
    26a4:	26 83       	std	Z+6, r18	; 0x06
    26a6:	66 81       	ldd	r22, Z+6	; 0x06
    26a8:	77 81       	ldd	r23, Z+7	; 0x07
    26aa:	0c 94 4c 23 	jmp	0x4698	; 0x4698 <memcpy>
    26ae:	08 95       	ret

000026b0 <prvUnlockQueue>:
    26b0:	ef 92       	push	r14
    26b2:	ff 92       	push	r15
    26b4:	1f 93       	push	r17
    26b6:	cf 93       	push	r28
    26b8:	df 93       	push	r29
    26ba:	ec 01       	movw	r28, r24
    26bc:	0f b6       	in	r0, 0x3f	; 63
    26be:	f8 94       	cli
    26c0:	0f 92       	push	r0
    26c2:	1e 8d       	ldd	r17, Y+30	; 0x1e
    26c4:	7c 01       	movw	r14, r24
    26c6:	81 e1       	ldi	r24, 0x11	; 17
    26c8:	e8 0e       	add	r14, r24
    26ca:	f1 1c       	adc	r15, r1
    26cc:	11 16       	cp	r1, r17
    26ce:	5c f4       	brge	.+22     	; 0x26e6 <prvUnlockQueue+0x36>
    26d0:	89 89       	ldd	r24, Y+17	; 0x11
    26d2:	88 23       	and	r24, r24
    26d4:	41 f0       	breq	.+16     	; 0x26e6 <prvUnlockQueue+0x36>
    26d6:	c7 01       	movw	r24, r14
    26d8:	0e 94 d8 19 	call	0x33b0	; 0x33b0 <xTaskRemoveFromEventList>
    26dc:	81 11       	cpse	r24, r1
    26de:	0e 94 56 1a 	call	0x34ac	; 0x34ac <vTaskMissedYield>
    26e2:	11 50       	subi	r17, 0x01	; 1
    26e4:	f3 cf       	rjmp	.-26     	; 0x26cc <prvUnlockQueue+0x1c>
    26e6:	8f ef       	ldi	r24, 0xFF	; 255
    26e8:	8e 8f       	std	Y+30, r24	; 0x1e
    26ea:	0f 90       	pop	r0
    26ec:	0f be       	out	0x3f, r0	; 63
    26ee:	0f b6       	in	r0, 0x3f	; 63
    26f0:	f8 94       	cli
    26f2:	0f 92       	push	r0
    26f4:	1d 8d       	ldd	r17, Y+29	; 0x1d
    26f6:	7e 01       	movw	r14, r28
    26f8:	88 e0       	ldi	r24, 0x08	; 8
    26fa:	e8 0e       	add	r14, r24
    26fc:	f1 1c       	adc	r15, r1
    26fe:	11 16       	cp	r1, r17
    2700:	5c f4       	brge	.+22     	; 0x2718 <prvUnlockQueue+0x68>
    2702:	88 85       	ldd	r24, Y+8	; 0x08
    2704:	88 23       	and	r24, r24
    2706:	41 f0       	breq	.+16     	; 0x2718 <prvUnlockQueue+0x68>
    2708:	c7 01       	movw	r24, r14
    270a:	0e 94 d8 19 	call	0x33b0	; 0x33b0 <xTaskRemoveFromEventList>
    270e:	81 11       	cpse	r24, r1
    2710:	0e 94 56 1a 	call	0x34ac	; 0x34ac <vTaskMissedYield>
    2714:	11 50       	subi	r17, 0x01	; 1
    2716:	f3 cf       	rjmp	.-26     	; 0x26fe <prvUnlockQueue+0x4e>
    2718:	8f ef       	ldi	r24, 0xFF	; 255
    271a:	8d 8f       	std	Y+29, r24	; 0x1d
    271c:	0f 90       	pop	r0
    271e:	0f be       	out	0x3f, r0	; 63
    2720:	df 91       	pop	r29
    2722:	cf 91       	pop	r28
    2724:	1f 91       	pop	r17
    2726:	ff 90       	pop	r15
    2728:	ef 90       	pop	r14
    272a:	08 95       	ret

0000272c <xQueueGenericReset>:
    272c:	cf 93       	push	r28
    272e:	df 93       	push	r29
    2730:	ec 01       	movw	r28, r24
    2732:	0f b6       	in	r0, 0x3f	; 63
    2734:	f8 94       	cli
    2736:	0f 92       	push	r0
    2738:	48 81       	ld	r20, Y
    273a:	59 81       	ldd	r21, Y+1	; 0x01
    273c:	8b 8d       	ldd	r24, Y+27	; 0x1b
    273e:	7c 8d       	ldd	r23, Y+28	; 0x1c
    2740:	9a 01       	movw	r18, r20
    2742:	87 9f       	mul	r24, r23
    2744:	20 0d       	add	r18, r0
    2746:	31 1d       	adc	r19, r1
    2748:	11 24       	eor	r1, r1
    274a:	3d 83       	std	Y+5, r19	; 0x05
    274c:	2c 83       	std	Y+4, r18	; 0x04
    274e:	1a 8e       	std	Y+26, r1	; 0x1a
    2750:	5b 83       	std	Y+3, r21	; 0x03
    2752:	4a 83       	std	Y+2, r20	; 0x02
    2754:	90 e0       	ldi	r25, 0x00	; 0
    2756:	01 97       	sbiw	r24, 0x01	; 1
    2758:	78 9f       	mul	r23, r24
    275a:	90 01       	movw	r18, r0
    275c:	79 9f       	mul	r23, r25
    275e:	30 0d       	add	r19, r0
    2760:	11 24       	eor	r1, r1
    2762:	ca 01       	movw	r24, r20
    2764:	82 0f       	add	r24, r18
    2766:	93 1f       	adc	r25, r19
    2768:	9f 83       	std	Y+7, r25	; 0x07
    276a:	8e 83       	std	Y+6, r24	; 0x06
    276c:	8f ef       	ldi	r24, 0xFF	; 255
    276e:	8d 8f       	std	Y+29, r24	; 0x1d
    2770:	8e 8f       	std	Y+30, r24	; 0x1e
    2772:	61 11       	cpse	r22, r1
    2774:	0c c0       	rjmp	.+24     	; 0x278e <xQueueGenericReset+0x62>
    2776:	88 85       	ldd	r24, Y+8	; 0x08
    2778:	88 23       	and	r24, r24
    277a:	89 f0       	breq	.+34     	; 0x279e <xQueueGenericReset+0x72>
    277c:	ce 01       	movw	r24, r28
    277e:	08 96       	adiw	r24, 0x08	; 8
    2780:	0e 94 d8 19 	call	0x33b0	; 0x33b0 <xTaskRemoveFromEventList>
    2784:	88 23       	and	r24, r24
    2786:	59 f0       	breq	.+22     	; 0x279e <xQueueGenericReset+0x72>
    2788:	0e 94 ce 1f 	call	0x3f9c	; 0x3f9c <vPortYield>
    278c:	08 c0       	rjmp	.+16     	; 0x279e <xQueueGenericReset+0x72>
    278e:	ce 01       	movw	r24, r28
    2790:	08 96       	adiw	r24, 0x08	; 8
    2792:	0e 94 9b 1e 	call	0x3d36	; 0x3d36 <vListInitialise>
    2796:	ce 01       	movw	r24, r28
    2798:	41 96       	adiw	r24, 0x11	; 17
    279a:	0e 94 9b 1e 	call	0x3d36	; 0x3d36 <vListInitialise>
    279e:	0f 90       	pop	r0
    27a0:	0f be       	out	0x3f, r0	; 63
    27a2:	81 e0       	ldi	r24, 0x01	; 1
    27a4:	df 91       	pop	r29
    27a6:	cf 91       	pop	r28
    27a8:	08 95       	ret

000027aa <xQueueGenericCreate>:
    27aa:	0f 93       	push	r16
    27ac:	1f 93       	push	r17
    27ae:	cf 93       	push	r28
    27b0:	df 93       	push	r29
    27b2:	08 2f       	mov	r16, r24
    27b4:	16 2f       	mov	r17, r22
    27b6:	66 23       	and	r22, r22
    27b8:	21 f0       	breq	.+8      	; 0x27c2 <xQueueGenericCreate+0x18>
    27ba:	86 9f       	mul	r24, r22
    27bc:	c0 01       	movw	r24, r0
    27be:	11 24       	eor	r1, r1
    27c0:	02 c0       	rjmp	.+4      	; 0x27c6 <xQueueGenericCreate+0x1c>
    27c2:	80 e0       	ldi	r24, 0x00	; 0
    27c4:	90 e0       	ldi	r25, 0x00	; 0
    27c6:	4f 96       	adiw	r24, 0x1f	; 31
    27c8:	0e 94 77 1e 	call	0x3cee	; 0x3cee <pvPortMalloc>
    27cc:	ec 01       	movw	r28, r24
    27ce:	00 97       	sbiw	r24, 0x00	; 0
    27d0:	71 f0       	breq	.+28     	; 0x27ee <xQueueGenericCreate+0x44>
    27d2:	11 11       	cpse	r17, r1
    27d4:	03 c0       	rjmp	.+6      	; 0x27dc <xQueueGenericCreate+0x32>
    27d6:	99 83       	std	Y+1, r25	; 0x01
    27d8:	88 83       	st	Y, r24
    27da:	03 c0       	rjmp	.+6      	; 0x27e2 <xQueueGenericCreate+0x38>
    27dc:	4f 96       	adiw	r24, 0x1f	; 31
    27de:	99 83       	std	Y+1, r25	; 0x01
    27e0:	88 83       	st	Y, r24
    27e2:	0b 8f       	std	Y+27, r16	; 0x1b
    27e4:	1c 8f       	std	Y+28, r17	; 0x1c
    27e6:	61 e0       	ldi	r22, 0x01	; 1
    27e8:	ce 01       	movw	r24, r28
    27ea:	0e 94 96 13 	call	0x272c	; 0x272c <xQueueGenericReset>
    27ee:	ce 01       	movw	r24, r28
    27f0:	df 91       	pop	r29
    27f2:	cf 91       	pop	r28
    27f4:	1f 91       	pop	r17
    27f6:	0f 91       	pop	r16
    27f8:	08 95       	ret

000027fa <xQueueGenericSend>:
    27fa:	af 92       	push	r10
    27fc:	bf 92       	push	r11
    27fe:	cf 92       	push	r12
    2800:	df 92       	push	r13
    2802:	ff 92       	push	r15
    2804:	0f 93       	push	r16
    2806:	1f 93       	push	r17
    2808:	cf 93       	push	r28
    280a:	df 93       	push	r29
    280c:	00 d0       	rcall	.+0      	; 0x280e <xQueueGenericSend+0x14>
    280e:	00 d0       	rcall	.+0      	; 0x2810 <xQueueGenericSend+0x16>
    2810:	1f 92       	push	r1
    2812:	cd b7       	in	r28, 0x3d	; 61
    2814:	de b7       	in	r29, 0x3e	; 62
    2816:	8c 01       	movw	r16, r24
    2818:	6b 01       	movw	r12, r22
    281a:	5d 83       	std	Y+5, r21	; 0x05
    281c:	4c 83       	std	Y+4, r20	; 0x04
    281e:	f2 2e       	mov	r15, r18
    2820:	80 e0       	ldi	r24, 0x00	; 0
    2822:	58 01       	movw	r10, r16
    2824:	98 e0       	ldi	r25, 0x08	; 8
    2826:	a9 0e       	add	r10, r25
    2828:	b1 1c       	adc	r11, r1
    282a:	0f b6       	in	r0, 0x3f	; 63
    282c:	f8 94       	cli
    282e:	0f 92       	push	r0
    2830:	f8 01       	movw	r30, r16
    2832:	22 8d       	ldd	r18, Z+26	; 0x1a
    2834:	93 8d       	ldd	r25, Z+27	; 0x1b
    2836:	29 17       	cp	r18, r25
    2838:	18 f0       	brcs	.+6      	; 0x2840 <xQueueGenericSend+0x46>
    283a:	f2 e0       	ldi	r31, 0x02	; 2
    283c:	ff 12       	cpse	r15, r31
    283e:	14 c0       	rjmp	.+40     	; 0x2868 <xQueueGenericSend+0x6e>
    2840:	4f 2d       	mov	r20, r15
    2842:	b6 01       	movw	r22, r12
    2844:	c8 01       	movw	r24, r16
    2846:	0e 94 eb 12 	call	0x25d6	; 0x25d6 <prvCopyDataToQueue>
    284a:	f8 01       	movw	r30, r16
    284c:	91 89       	ldd	r25, Z+17	; 0x11
    284e:	99 23       	and	r25, r25
    2850:	21 f0       	breq	.+8      	; 0x285a <xQueueGenericSend+0x60>
    2852:	c8 01       	movw	r24, r16
    2854:	41 96       	adiw	r24, 0x11	; 17
    2856:	0e 94 d8 19 	call	0x33b0	; 0x33b0 <xTaskRemoveFromEventList>
    285a:	81 11       	cpse	r24, r1
    285c:	0e 94 ce 1f 	call	0x3f9c	; 0x3f9c <vPortYield>
    2860:	0f 90       	pop	r0
    2862:	0f be       	out	0x3f, r0	; 63
    2864:	81 e0       	ldi	r24, 0x01	; 1
    2866:	50 c0       	rjmp	.+160    	; 0x2908 <xQueueGenericSend+0x10e>
    2868:	2c 81       	ldd	r18, Y+4	; 0x04
    286a:	3d 81       	ldd	r19, Y+5	; 0x05
    286c:	23 2b       	or	r18, r19
    286e:	19 f4       	brne	.+6      	; 0x2876 <xQueueGenericSend+0x7c>
    2870:	0f 90       	pop	r0
    2872:	0f be       	out	0x3f, r0	; 63
    2874:	48 c0       	rjmp	.+144    	; 0x2906 <xQueueGenericSend+0x10c>
    2876:	81 11       	cpse	r24, r1
    2878:	04 c0       	rjmp	.+8      	; 0x2882 <xQueueGenericSend+0x88>
    287a:	ce 01       	movw	r24, r28
    287c:	01 96       	adiw	r24, 0x01	; 1
    287e:	0e 94 18 1a 	call	0x3430	; 0x3430 <vTaskInternalSetTimeOutState>
    2882:	0f 90       	pop	r0
    2884:	0f be       	out	0x3f, r0	; 63
    2886:	0e 94 98 17 	call	0x2f30	; 0x2f30 <vTaskSuspendAll>
    288a:	0f b6       	in	r0, 0x3f	; 63
    288c:	f8 94       	cli
    288e:	0f 92       	push	r0
    2890:	f8 01       	movw	r30, r16
    2892:	85 8d       	ldd	r24, Z+29	; 0x1d
    2894:	8f 3f       	cpi	r24, 0xFF	; 255
    2896:	09 f4       	brne	.+2      	; 0x289a <xQueueGenericSend+0xa0>
    2898:	15 8e       	std	Z+29, r1	; 0x1d
    289a:	f8 01       	movw	r30, r16
    289c:	86 8d       	ldd	r24, Z+30	; 0x1e
    289e:	8f 3f       	cpi	r24, 0xFF	; 255
    28a0:	09 f4       	brne	.+2      	; 0x28a4 <xQueueGenericSend+0xaa>
    28a2:	16 8e       	std	Z+30, r1	; 0x1e
    28a4:	0f 90       	pop	r0
    28a6:	0f be       	out	0x3f, r0	; 63
    28a8:	be 01       	movw	r22, r28
    28aa:	6c 5f       	subi	r22, 0xFC	; 252
    28ac:	7f 4f       	sbci	r23, 0xFF	; 255
    28ae:	ce 01       	movw	r24, r28
    28b0:	01 96       	adiw	r24, 0x01	; 1
    28b2:	0e 94 23 1a 	call	0x3446	; 0x3446 <xTaskCheckForTimeOut>
    28b6:	81 11       	cpse	r24, r1
    28b8:	21 c0       	rjmp	.+66     	; 0x28fc <xQueueGenericSend+0x102>
    28ba:	0f b6       	in	r0, 0x3f	; 63
    28bc:	f8 94       	cli
    28be:	0f 92       	push	r0
    28c0:	f8 01       	movw	r30, r16
    28c2:	92 8d       	ldd	r25, Z+26	; 0x1a
    28c4:	83 8d       	ldd	r24, Z+27	; 0x1b
    28c6:	0f 90       	pop	r0
    28c8:	0f be       	out	0x3f, r0	; 63
    28ca:	98 13       	cpse	r25, r24
    28cc:	11 c0       	rjmp	.+34     	; 0x28f0 <xQueueGenericSend+0xf6>
    28ce:	6c 81       	ldd	r22, Y+4	; 0x04
    28d0:	7d 81       	ldd	r23, Y+5	; 0x05
    28d2:	c5 01       	movw	r24, r10
    28d4:	0e 94 af 19 	call	0x335e	; 0x335e <vTaskPlaceOnEventList>
    28d8:	c8 01       	movw	r24, r16
    28da:	0e 94 58 13 	call	0x26b0	; 0x26b0 <prvUnlockQueue>
    28de:	0e 94 54 18 	call	0x30a8	; 0x30a8 <xTaskResumeAll>
    28e2:	88 23       	and	r24, r24
    28e4:	11 f0       	breq	.+4      	; 0x28ea <xQueueGenericSend+0xf0>
    28e6:	81 e0       	ldi	r24, 0x01	; 1
    28e8:	a0 cf       	rjmp	.-192    	; 0x282a <xQueueGenericSend+0x30>
    28ea:	0e 94 ce 1f 	call	0x3f9c	; 0x3f9c <vPortYield>
    28ee:	fb cf       	rjmp	.-10     	; 0x28e6 <xQueueGenericSend+0xec>
    28f0:	c8 01       	movw	r24, r16
    28f2:	0e 94 58 13 	call	0x26b0	; 0x26b0 <prvUnlockQueue>
    28f6:	0e 94 54 18 	call	0x30a8	; 0x30a8 <xTaskResumeAll>
    28fa:	f5 cf       	rjmp	.-22     	; 0x28e6 <xQueueGenericSend+0xec>
    28fc:	c8 01       	movw	r24, r16
    28fe:	0e 94 58 13 	call	0x26b0	; 0x26b0 <prvUnlockQueue>
    2902:	0e 94 54 18 	call	0x30a8	; 0x30a8 <xTaskResumeAll>
    2906:	80 e0       	ldi	r24, 0x00	; 0
    2908:	0f 90       	pop	r0
    290a:	0f 90       	pop	r0
    290c:	0f 90       	pop	r0
    290e:	0f 90       	pop	r0
    2910:	0f 90       	pop	r0
    2912:	df 91       	pop	r29
    2914:	cf 91       	pop	r28
    2916:	1f 91       	pop	r17
    2918:	0f 91       	pop	r16
    291a:	ff 90       	pop	r15
    291c:	df 90       	pop	r13
    291e:	cf 90       	pop	r12
    2920:	bf 90       	pop	r11
    2922:	af 90       	pop	r10
    2924:	08 95       	ret

00002926 <xQueueGenericSendFromISR>:
    2926:	ef 92       	push	r14
    2928:	ff 92       	push	r15
    292a:	1f 93       	push	r17
    292c:	cf 93       	push	r28
    292e:	df 93       	push	r29
    2930:	ec 01       	movw	r28, r24
    2932:	9a 8d       	ldd	r25, Y+26	; 0x1a
    2934:	8b 8d       	ldd	r24, Y+27	; 0x1b
    2936:	98 17       	cp	r25, r24
    2938:	10 f0       	brcs	.+4      	; 0x293e <xQueueGenericSendFromISR+0x18>
    293a:	22 30       	cpi	r18, 0x02	; 2
    293c:	e1 f4       	brne	.+56     	; 0x2976 <xQueueGenericSendFromISR+0x50>
    293e:	7a 01       	movw	r14, r20
    2940:	1e 8d       	ldd	r17, Y+30	; 0x1e
    2942:	42 2f       	mov	r20, r18
    2944:	ce 01       	movw	r24, r28
    2946:	0e 94 eb 12 	call	0x25d6	; 0x25d6 <prvCopyDataToQueue>
    294a:	1f 3f       	cpi	r17, 0xFF	; 255
    294c:	81 f4       	brne	.+32     	; 0x296e <xQueueGenericSendFromISR+0x48>
    294e:	89 89       	ldd	r24, Y+17	; 0x11
    2950:	88 23       	and	r24, r24
    2952:	79 f0       	breq	.+30     	; 0x2972 <xQueueGenericSendFromISR+0x4c>
    2954:	ce 01       	movw	r24, r28
    2956:	41 96       	adiw	r24, 0x11	; 17
    2958:	0e 94 d8 19 	call	0x33b0	; 0x33b0 <xTaskRemoveFromEventList>
    295c:	88 23       	and	r24, r24
    295e:	49 f0       	breq	.+18     	; 0x2972 <xQueueGenericSendFromISR+0x4c>
    2960:	e1 14       	cp	r14, r1
    2962:	f1 04       	cpc	r15, r1
    2964:	31 f0       	breq	.+12     	; 0x2972 <xQueueGenericSendFromISR+0x4c>
    2966:	81 e0       	ldi	r24, 0x01	; 1
    2968:	f7 01       	movw	r30, r14
    296a:	80 83       	st	Z, r24
    296c:	05 c0       	rjmp	.+10     	; 0x2978 <xQueueGenericSendFromISR+0x52>
    296e:	1f 5f       	subi	r17, 0xFF	; 255
    2970:	1e 8f       	std	Y+30, r17	; 0x1e
    2972:	81 e0       	ldi	r24, 0x01	; 1
    2974:	01 c0       	rjmp	.+2      	; 0x2978 <xQueueGenericSendFromISR+0x52>
    2976:	80 e0       	ldi	r24, 0x00	; 0
    2978:	df 91       	pop	r29
    297a:	cf 91       	pop	r28
    297c:	1f 91       	pop	r17
    297e:	ff 90       	pop	r15
    2980:	ef 90       	pop	r14
    2982:	08 95       	ret

00002984 <xQueueReceive>:
    2984:	af 92       	push	r10
    2986:	bf 92       	push	r11
    2988:	cf 92       	push	r12
    298a:	df 92       	push	r13
    298c:	ff 92       	push	r15
    298e:	0f 93       	push	r16
    2990:	1f 93       	push	r17
    2992:	cf 93       	push	r28
    2994:	df 93       	push	r29
    2996:	00 d0       	rcall	.+0      	; 0x2998 <xQueueReceive+0x14>
    2998:	00 d0       	rcall	.+0      	; 0x299a <xQueueReceive+0x16>
    299a:	1f 92       	push	r1
    299c:	cd b7       	in	r28, 0x3d	; 61
    299e:	de b7       	in	r29, 0x3e	; 62
    29a0:	8c 01       	movw	r16, r24
    29a2:	6b 01       	movw	r12, r22
    29a4:	5d 83       	std	Y+5, r21	; 0x05
    29a6:	4c 83       	std	Y+4, r20	; 0x04
    29a8:	80 e0       	ldi	r24, 0x00	; 0
    29aa:	58 01       	movw	r10, r16
    29ac:	91 e1       	ldi	r25, 0x11	; 17
    29ae:	a9 0e       	add	r10, r25
    29b0:	b1 1c       	adc	r11, r1
    29b2:	0f b6       	in	r0, 0x3f	; 63
    29b4:	f8 94       	cli
    29b6:	0f 92       	push	r0
    29b8:	f8 01       	movw	r30, r16
    29ba:	f2 8c       	ldd	r15, Z+26	; 0x1a
    29bc:	ff 20       	and	r15, r15
    29be:	a9 f0       	breq	.+42     	; 0x29ea <xQueueReceive+0x66>
    29c0:	b6 01       	movw	r22, r12
    29c2:	c8 01       	movw	r24, r16
    29c4:	0e 94 3e 13 	call	0x267c	; 0x267c <prvCopyDataFromQueue>
    29c8:	fa 94       	dec	r15
    29ca:	f8 01       	movw	r30, r16
    29cc:	f2 8e       	std	Z+26, r15	; 0x1a
    29ce:	80 85       	ldd	r24, Z+8	; 0x08
    29d0:	88 23       	and	r24, r24
    29d2:	39 f0       	breq	.+14     	; 0x29e2 <xQueueReceive+0x5e>
    29d4:	c8 01       	movw	r24, r16
    29d6:	08 96       	adiw	r24, 0x08	; 8
    29d8:	0e 94 d8 19 	call	0x33b0	; 0x33b0 <xTaskRemoveFromEventList>
    29dc:	81 11       	cpse	r24, r1
    29de:	0e 94 ce 1f 	call	0x3f9c	; 0x3f9c <vPortYield>
    29e2:	0f 90       	pop	r0
    29e4:	0f be       	out	0x3f, r0	; 63
    29e6:	81 e0       	ldi	r24, 0x01	; 1
    29e8:	50 c0       	rjmp	.+160    	; 0x2a8a <xQueueReceive+0x106>
    29ea:	2c 81       	ldd	r18, Y+4	; 0x04
    29ec:	3d 81       	ldd	r19, Y+5	; 0x05
    29ee:	23 2b       	or	r18, r19
    29f0:	19 f4       	brne	.+6      	; 0x29f8 <xQueueReceive+0x74>
    29f2:	0f 90       	pop	r0
    29f4:	0f be       	out	0x3f, r0	; 63
    29f6:	48 c0       	rjmp	.+144    	; 0x2a88 <xQueueReceive+0x104>
    29f8:	81 11       	cpse	r24, r1
    29fa:	04 c0       	rjmp	.+8      	; 0x2a04 <xQueueReceive+0x80>
    29fc:	ce 01       	movw	r24, r28
    29fe:	01 96       	adiw	r24, 0x01	; 1
    2a00:	0e 94 18 1a 	call	0x3430	; 0x3430 <vTaskInternalSetTimeOutState>
    2a04:	0f 90       	pop	r0
    2a06:	0f be       	out	0x3f, r0	; 63
    2a08:	0e 94 98 17 	call	0x2f30	; 0x2f30 <vTaskSuspendAll>
    2a0c:	0f b6       	in	r0, 0x3f	; 63
    2a0e:	f8 94       	cli
    2a10:	0f 92       	push	r0
    2a12:	f8 01       	movw	r30, r16
    2a14:	85 8d       	ldd	r24, Z+29	; 0x1d
    2a16:	8f 3f       	cpi	r24, 0xFF	; 255
    2a18:	09 f4       	brne	.+2      	; 0x2a1c <xQueueReceive+0x98>
    2a1a:	15 8e       	std	Z+29, r1	; 0x1d
    2a1c:	f8 01       	movw	r30, r16
    2a1e:	86 8d       	ldd	r24, Z+30	; 0x1e
    2a20:	8f 3f       	cpi	r24, 0xFF	; 255
    2a22:	09 f4       	brne	.+2      	; 0x2a26 <xQueueReceive+0xa2>
    2a24:	16 8e       	std	Z+30, r1	; 0x1e
    2a26:	0f 90       	pop	r0
    2a28:	0f be       	out	0x3f, r0	; 63
    2a2a:	be 01       	movw	r22, r28
    2a2c:	6c 5f       	subi	r22, 0xFC	; 252
    2a2e:	7f 4f       	sbci	r23, 0xFF	; 255
    2a30:	ce 01       	movw	r24, r28
    2a32:	01 96       	adiw	r24, 0x01	; 1
    2a34:	0e 94 23 1a 	call	0x3446	; 0x3446 <xTaskCheckForTimeOut>
    2a38:	81 11       	cpse	r24, r1
    2a3a:	1c c0       	rjmp	.+56     	; 0x2a74 <xQueueReceive+0xf0>
    2a3c:	c8 01       	movw	r24, r16
    2a3e:	0e 94 e0 12 	call	0x25c0	; 0x25c0 <prvIsQueueEmpty>
    2a42:	88 23       	and	r24, r24
    2a44:	89 f0       	breq	.+34     	; 0x2a68 <xQueueReceive+0xe4>
    2a46:	6c 81       	ldd	r22, Y+4	; 0x04
    2a48:	7d 81       	ldd	r23, Y+5	; 0x05
    2a4a:	c5 01       	movw	r24, r10
    2a4c:	0e 94 af 19 	call	0x335e	; 0x335e <vTaskPlaceOnEventList>
    2a50:	c8 01       	movw	r24, r16
    2a52:	0e 94 58 13 	call	0x26b0	; 0x26b0 <prvUnlockQueue>
    2a56:	0e 94 54 18 	call	0x30a8	; 0x30a8 <xTaskResumeAll>
    2a5a:	88 23       	and	r24, r24
    2a5c:	11 f0       	breq	.+4      	; 0x2a62 <xQueueReceive+0xde>
    2a5e:	81 e0       	ldi	r24, 0x01	; 1
    2a60:	a8 cf       	rjmp	.-176    	; 0x29b2 <xQueueReceive+0x2e>
    2a62:	0e 94 ce 1f 	call	0x3f9c	; 0x3f9c <vPortYield>
    2a66:	fb cf       	rjmp	.-10     	; 0x2a5e <xQueueReceive+0xda>
    2a68:	c8 01       	movw	r24, r16
    2a6a:	0e 94 58 13 	call	0x26b0	; 0x26b0 <prvUnlockQueue>
    2a6e:	0e 94 54 18 	call	0x30a8	; 0x30a8 <xTaskResumeAll>
    2a72:	f5 cf       	rjmp	.-22     	; 0x2a5e <xQueueReceive+0xda>
    2a74:	c8 01       	movw	r24, r16
    2a76:	0e 94 58 13 	call	0x26b0	; 0x26b0 <prvUnlockQueue>
    2a7a:	0e 94 54 18 	call	0x30a8	; 0x30a8 <xTaskResumeAll>
    2a7e:	c8 01       	movw	r24, r16
    2a80:	0e 94 e0 12 	call	0x25c0	; 0x25c0 <prvIsQueueEmpty>
    2a84:	88 23       	and	r24, r24
    2a86:	59 f3       	breq	.-42     	; 0x2a5e <xQueueReceive+0xda>
    2a88:	80 e0       	ldi	r24, 0x00	; 0
    2a8a:	0f 90       	pop	r0
    2a8c:	0f 90       	pop	r0
    2a8e:	0f 90       	pop	r0
    2a90:	0f 90       	pop	r0
    2a92:	0f 90       	pop	r0
    2a94:	df 91       	pop	r29
    2a96:	cf 91       	pop	r28
    2a98:	1f 91       	pop	r17
    2a9a:	0f 91       	pop	r16
    2a9c:	ff 90       	pop	r15
    2a9e:	df 90       	pop	r13
    2aa0:	cf 90       	pop	r12
    2aa2:	bf 90       	pop	r11
    2aa4:	af 90       	pop	r10
    2aa6:	08 95       	ret

00002aa8 <vQueueWaitForMessageRestricted>:
/*-----------------------------------------------------------*/

#if ( configUSE_TIMERS == 1 )

    void vQueueWaitForMessageRestricted( QueueHandle_t xQueue, TickType_t xTicksToWait, const BaseType_t xWaitIndefinitely )
    {
    2aa8:	cf 93       	push	r28
    2aaa:	df 93       	push	r29
    2aac:	ec 01       	movw	r28, r24
        will not actually cause the task to block, just place it on a blocked
        list.  It will not block until the scheduler is unlocked - at which
        time a yield will be performed.  If an item is added to the queue while
        the queue is locked, and the calling task blocks on the queue, then the
        calling task will be immediately unblocked when the queue is unlocked. */
        prvLockQueue( pxQueue );
    2aae:	0f b6       	in	r0, 0x3f	; 63
    2ab0:	f8 94       	cli
    2ab2:	0f 92       	push	r0
    2ab4:	8d 8d       	ldd	r24, Y+29	; 0x1d
    2ab6:	8f 3f       	cpi	r24, 0xFF	; 255
    2ab8:	09 f4       	brne	.+2      	; 0x2abc <vQueueWaitForMessageRestricted+0x14>
    2aba:	1d 8e       	std	Y+29, r1	; 0x1d
    2abc:	8e 8d       	ldd	r24, Y+30	; 0x1e
    2abe:	8f 3f       	cpi	r24, 0xFF	; 255
    2ac0:	09 f4       	brne	.+2      	; 0x2ac4 <vQueueWaitForMessageRestricted+0x1c>
    2ac2:	1e 8e       	std	Y+30, r1	; 0x1e
    2ac4:	0f 90       	pop	r0
    2ac6:	0f be       	out	0x3f, r0	; 63
        if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0U )
    2ac8:	8a 8d       	ldd	r24, Y+26	; 0x1a
    2aca:	81 11       	cpse	r24, r1
    2acc:	04 c0       	rjmp	.+8      	; 0x2ad6 <vQueueWaitForMessageRestricted+0x2e>
        {
            /* There is nothing in the queue, block for the specified period. */
            vTaskPlaceOnEventListRestricted( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait, xWaitIndefinitely );
    2ace:	ce 01       	movw	r24, r28
    2ad0:	41 96       	adiw	r24, 0x11	; 17
    2ad2:	0e 94 c0 19 	call	0x3380	; 0x3380 <vTaskPlaceOnEventListRestricted>
        }
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }
        prvUnlockQueue( pxQueue );
    2ad6:	ce 01       	movw	r24, r28
    }
    2ad8:	df 91       	pop	r29
    2ada:	cf 91       	pop	r28
        }
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }
        prvUnlockQueue( pxQueue );
    2adc:	0c 94 58 13 	jmp	0x26b0	; 0x26b0 <prvUnlockQueue>

00002ae0 <prvResetNextTaskUnblockTime>:
        {
            mtCOVERAGE_TEST_MARKER();
        }

        return xReturn;
    }
    2ae0:	e0 91 9b 04 	lds	r30, 0x049B	; 0x80049b <pxDelayedTaskList>
    2ae4:	f0 91 9c 04 	lds	r31, 0x049C	; 0x80049c <pxDelayedTaskList+0x1>
    2ae8:	80 81       	ld	r24, Z
    2aea:	81 11       	cpse	r24, r1
    2aec:	03 c0       	rjmp	.+6      	; 0x2af4 <prvResetNextTaskUnblockTime+0x14>
    2aee:	8f ef       	ldi	r24, 0xFF	; 255
    2af0:	9f ef       	ldi	r25, 0xFF	; 255
    2af2:	0c c0       	rjmp	.+24     	; 0x2b0c <prvResetNextTaskUnblockTime+0x2c>
    2af4:	e0 91 9b 04 	lds	r30, 0x049B	; 0x80049b <pxDelayedTaskList>
    2af8:	f0 91 9c 04 	lds	r31, 0x049C	; 0x80049c <pxDelayedTaskList+0x1>
    2afc:	05 80       	ldd	r0, Z+5	; 0x05
    2afe:	f6 81       	ldd	r31, Z+6	; 0x06
    2b00:	e0 2d       	mov	r30, r0
    2b02:	06 80       	ldd	r0, Z+6	; 0x06
    2b04:	f7 81       	ldd	r31, Z+7	; 0x07
    2b06:	e0 2d       	mov	r30, r0
    2b08:	82 81       	ldd	r24, Z+2	; 0x02
    2b0a:	93 81       	ldd	r25, Z+3	; 0x03
    2b0c:	90 93 73 04 	sts	0x0473, r25	; 0x800473 <xNextTaskUnblockTime+0x1>
    2b10:	80 93 72 04 	sts	0x0472, r24	; 0x800472 <xNextTaskUnblockTime>
    2b14:	08 95       	ret

00002b16 <prvAddCurrentTaskToDelayedList>:
    2b16:	ff 92       	push	r15
    2b18:	0f 93       	push	r16
    2b1a:	1f 93       	push	r17
    2b1c:	cf 93       	push	r28
    2b1e:	df 93       	push	r29
    2b20:	ec 01       	movw	r28, r24
    2b22:	f6 2e       	mov	r15, r22
    2b24:	00 91 7a 04 	lds	r16, 0x047A	; 0x80047a <xTickCount>
    2b28:	10 91 7b 04 	lds	r17, 0x047B	; 0x80047b <xTickCount+0x1>
    2b2c:	80 91 d3 04 	lds	r24, 0x04D3	; 0x8004d3 <pxCurrentTCB>
    2b30:	90 91 d4 04 	lds	r25, 0x04D4	; 0x8004d4 <pxCurrentTCB+0x1>
    2b34:	02 96       	adiw	r24, 0x02	; 2
    2b36:	0e 94 06 1f 	call	0x3e0c	; 0x3e0c <uxListRemove>
    2b3a:	cf 3f       	cpi	r28, 0xFF	; 255
    2b3c:	8f ef       	ldi	r24, 0xFF	; 255
    2b3e:	d8 07       	cpc	r29, r24
    2b40:	89 f4       	brne	.+34     	; 0x2b64 <prvAddCurrentTaskToDelayedList+0x4e>
    2b42:	ff 20       	and	r15, r15
    2b44:	79 f0       	breq	.+30     	; 0x2b64 <prvAddCurrentTaskToDelayedList+0x4e>
    2b46:	60 91 d3 04 	lds	r22, 0x04D3	; 0x8004d3 <pxCurrentTCB>
    2b4a:	70 91 d4 04 	lds	r23, 0x04D4	; 0x8004d4 <pxCurrentTCB+0x1>
    2b4e:	6e 5f       	subi	r22, 0xFE	; 254
    2b50:	7f 4f       	sbci	r23, 0xFF	; 255
    2b52:	8d e7       	ldi	r24, 0x7D	; 125
    2b54:	94 e0       	ldi	r25, 0x04	; 4
    2b56:	df 91       	pop	r29
    2b58:	cf 91       	pop	r28
    2b5a:	1f 91       	pop	r17
    2b5c:	0f 91       	pop	r16
    2b5e:	ff 90       	pop	r15
    2b60:	0c 94 ad 1e 	jmp	0x3d5a	; 0x3d5a <vListInsertEnd>
    2b64:	c0 0f       	add	r28, r16
    2b66:	d1 1f       	adc	r29, r17
    2b68:	e0 91 d3 04 	lds	r30, 0x04D3	; 0x8004d3 <pxCurrentTCB>
    2b6c:	f0 91 d4 04 	lds	r31, 0x04D4	; 0x8004d4 <pxCurrentTCB+0x1>
    2b70:	d3 83       	std	Z+3, r29	; 0x03
    2b72:	c2 83       	std	Z+2, r28	; 0x02
    2b74:	60 91 d3 04 	lds	r22, 0x04D3	; 0x8004d3 <pxCurrentTCB>
    2b78:	70 91 d4 04 	lds	r23, 0x04D4	; 0x8004d4 <pxCurrentTCB+0x1>
    2b7c:	c0 17       	cp	r28, r16
    2b7e:	d1 07       	cpc	r29, r17
    2b80:	68 f4       	brcc	.+26     	; 0x2b9c <prvAddCurrentTaskToDelayedList+0x86>
    2b82:	80 91 99 04 	lds	r24, 0x0499	; 0x800499 <pxOverflowDelayedTaskList>
    2b86:	90 91 9a 04 	lds	r25, 0x049A	; 0x80049a <pxOverflowDelayedTaskList+0x1>
    2b8a:	6e 5f       	subi	r22, 0xFE	; 254
    2b8c:	7f 4f       	sbci	r23, 0xFF	; 255
    2b8e:	df 91       	pop	r29
    2b90:	cf 91       	pop	r28
    2b92:	1f 91       	pop	r17
    2b94:	0f 91       	pop	r16
    2b96:	ff 90       	pop	r15
    2b98:	0c 94 ce 1e 	jmp	0x3d9c	; 0x3d9c <vListInsert>
    2b9c:	80 91 9b 04 	lds	r24, 0x049B	; 0x80049b <pxDelayedTaskList>
    2ba0:	90 91 9c 04 	lds	r25, 0x049C	; 0x80049c <pxDelayedTaskList+0x1>
    2ba4:	6e 5f       	subi	r22, 0xFE	; 254
    2ba6:	7f 4f       	sbci	r23, 0xFF	; 255
    2ba8:	0e 94 ce 1e 	call	0x3d9c	; 0x3d9c <vListInsert>
    2bac:	80 91 72 04 	lds	r24, 0x0472	; 0x800472 <xNextTaskUnblockTime>
    2bb0:	90 91 73 04 	lds	r25, 0x0473	; 0x800473 <xNextTaskUnblockTime+0x1>
    2bb4:	c8 17       	cp	r28, r24
    2bb6:	d9 07       	cpc	r29, r25
    2bb8:	20 f4       	brcc	.+8      	; 0x2bc2 <prvAddCurrentTaskToDelayedList+0xac>
    2bba:	d0 93 73 04 	sts	0x0473, r29	; 0x800473 <xNextTaskUnblockTime+0x1>
    2bbe:	c0 93 72 04 	sts	0x0472, r28	; 0x800472 <xNextTaskUnblockTime>
    2bc2:	df 91       	pop	r29
    2bc4:	cf 91       	pop	r28
    2bc6:	1f 91       	pop	r17
    2bc8:	0f 91       	pop	r16
    2bca:	ff 90       	pop	r15
    2bcc:	08 95       	ret

00002bce <prvIdleTask>:
    2bce:	80 91 86 04 	lds	r24, 0x0486	; 0x800486 <uxDeletedTasksWaitingCleanUp>
    2bd2:	88 23       	and	r24, r24
    2bd4:	09 f1       	breq	.+66     	; 0x2c18 <prvIdleTask+0x4a>
    2bd6:	0f b6       	in	r0, 0x3f	; 63
    2bd8:	f8 94       	cli
    2bda:	0f 92       	push	r0
    2bdc:	e0 91 8c 04 	lds	r30, 0x048C	; 0x80048c <xTasksWaitingTermination+0x5>
    2be0:	f0 91 8d 04 	lds	r31, 0x048D	; 0x80048d <xTasksWaitingTermination+0x6>
    2be4:	c6 81       	ldd	r28, Z+6	; 0x06
    2be6:	d7 81       	ldd	r29, Z+7	; 0x07
    2be8:	ce 01       	movw	r24, r28
    2bea:	02 96       	adiw	r24, 0x02	; 2
    2bec:	0e 94 06 1f 	call	0x3e0c	; 0x3e0c <uxListRemove>
    2bf0:	80 91 7c 04 	lds	r24, 0x047C	; 0x80047c <uxCurrentNumberOfTasks>
    2bf4:	81 50       	subi	r24, 0x01	; 1
    2bf6:	80 93 7c 04 	sts	0x047C, r24	; 0x80047c <uxCurrentNumberOfTasks>
    2bfa:	80 91 86 04 	lds	r24, 0x0486	; 0x800486 <uxDeletedTasksWaitingCleanUp>
    2bfe:	81 50       	subi	r24, 0x01	; 1
    2c00:	80 93 86 04 	sts	0x0486, r24	; 0x800486 <uxDeletedTasksWaitingCleanUp>
    2c04:	0f 90       	pop	r0
    2c06:	0f be       	out	0x3f, r0	; 63
    2c08:	8f 89       	ldd	r24, Y+23	; 0x17
    2c0a:	98 8d       	ldd	r25, Y+24	; 0x18
    2c0c:	0e 94 8a 1e 	call	0x3d14	; 0x3d14 <vPortFree>
    2c10:	ce 01       	movw	r24, r28
    2c12:	0e 94 8a 1e 	call	0x3d14	; 0x3d14 <vPortFree>
    2c16:	db cf       	rjmp	.-74     	; 0x2bce <prvIdleTask>
    2c18:	80 91 af 04 	lds	r24, 0x04AF	; 0x8004af <pxReadyTasksLists>
    2c1c:	82 30       	cpi	r24, 0x02	; 2
    2c1e:	10 f0       	brcs	.+4      	; 0x2c24 <prvIdleTask+0x56>
    2c20:	0e 94 ce 1f 	call	0x3f9c	; 0x3f9c <vPortYield>
    2c24:	0e 94 ad 1c 	call	0x395a	; 0x395a <vApplicationIdleHook>
    2c28:	d2 cf       	rjmp	.-92     	; 0x2bce <prvIdleTask>

00002c2a <xTaskCreate>:
    2c2a:	5f 92       	push	r5
    2c2c:	6f 92       	push	r6
    2c2e:	7f 92       	push	r7
    2c30:	8f 92       	push	r8
    2c32:	9f 92       	push	r9
    2c34:	af 92       	push	r10
    2c36:	bf 92       	push	r11
    2c38:	cf 92       	push	r12
    2c3a:	df 92       	push	r13
    2c3c:	ef 92       	push	r14
    2c3e:	ff 92       	push	r15
    2c40:	0f 93       	push	r16
    2c42:	1f 93       	push	r17
    2c44:	cf 93       	push	r28
    2c46:	df 93       	push	r29
    2c48:	3c 01       	movw	r6, r24
    2c4a:	6b 01       	movw	r12, r22
    2c4c:	5a 01       	movw	r10, r20
    2c4e:	49 01       	movw	r8, r18
    2c50:	50 2e       	mov	r5, r16
    2c52:	ca 01       	movw	r24, r20
    2c54:	0e 94 77 1e 	call	0x3cee	; 0x3cee <pvPortMalloc>
    2c58:	8c 01       	movw	r16, r24
    2c5a:	89 2b       	or	r24, r25
    2c5c:	09 f4       	brne	.+2      	; 0x2c60 <xTaskCreate+0x36>
    2c5e:	e0 c0       	rjmp	.+448    	; 0x2e20 <xTaskCreate+0x1f6>
    2c60:	88 e2       	ldi	r24, 0x28	; 40
    2c62:	90 e0       	ldi	r25, 0x00	; 0
    2c64:	0e 94 77 1e 	call	0x3cee	; 0x3cee <pvPortMalloc>
    2c68:	ec 01       	movw	r28, r24
    2c6a:	89 2b       	or	r24, r25
    2c6c:	c9 f0       	breq	.+50     	; 0x2ca0 <xTaskCreate+0x76>
    2c6e:	18 8f       	std	Y+24, r17	; 0x18
    2c70:	0f 8b       	std	Y+23, r16	; 0x17
    2c72:	a5 01       	movw	r20, r10
    2c74:	65 ea       	ldi	r22, 0xA5	; 165
    2c76:	70 e0       	ldi	r23, 0x00	; 0
    2c78:	c8 01       	movw	r24, r16
    2c7a:	0e 94 55 23 	call	0x46aa	; 0x46aa <memset>
    2c7e:	21 e0       	ldi	r18, 0x01	; 1
    2c80:	a2 1a       	sub	r10, r18
    2c82:	b1 08       	sbc	r11, r1
    2c84:	8f 89       	ldd	r24, Y+23	; 0x17
    2c86:	98 8d       	ldd	r25, Y+24	; 0x18
    2c88:	a8 0e       	add	r10, r24
    2c8a:	b9 1e       	adc	r11, r25
    2c8c:	c1 14       	cp	r12, r1
    2c8e:	d1 04       	cpc	r13, r1
    2c90:	c9 f0       	breq	.+50     	; 0x2cc4 <xTaskCreate+0x9a>
    2c92:	be 01       	movw	r22, r28
    2c94:	67 5e       	subi	r22, 0xE7	; 231
    2c96:	7f 4f       	sbci	r23, 0xFF	; 255
    2c98:	f6 01       	movw	r30, r12
    2c9a:	c6 01       	movw	r24, r12
    2c9c:	08 96       	adiw	r24, 0x08	; 8
    2c9e:	07 c0       	rjmp	.+14     	; 0x2cae <xTaskCreate+0x84>
    2ca0:	c8 01       	movw	r24, r16
    2ca2:	0e 94 8a 1e 	call	0x3d14	; 0x3d14 <vPortFree>
    2ca6:	bc c0       	rjmp	.+376    	; 0x2e20 <xTaskCreate+0x1f6>
    2ca8:	e8 17       	cp	r30, r24
    2caa:	f9 07       	cpc	r31, r25
    2cac:	49 f0       	breq	.+18     	; 0x2cc0 <xTaskCreate+0x96>
    2cae:	9f 01       	movw	r18, r30
    2cb0:	41 91       	ld	r20, Z+
    2cb2:	db 01       	movw	r26, r22
    2cb4:	4d 93       	st	X+, r20
    2cb6:	bd 01       	movw	r22, r26
    2cb8:	d9 01       	movw	r26, r18
    2cba:	2c 91       	ld	r18, X
    2cbc:	21 11       	cpse	r18, r1
    2cbe:	f4 cf       	rjmp	.-24     	; 0x2ca8 <xTaskCreate+0x7e>
    2cc0:	18 a2       	std	Y+32, r1	; 0x20
    2cc2:	01 c0       	rjmp	.+2      	; 0x2cc6 <xTaskCreate+0x9c>
    2cc4:	19 8e       	std	Y+25, r1	; 0x19
    2cc6:	05 2d       	mov	r16, r5
    2cc8:	04 30       	cpi	r16, 0x04	; 4
    2cca:	08 f0       	brcs	.+2      	; 0x2cce <xTaskCreate+0xa4>
    2ccc:	03 e0       	ldi	r16, 0x03	; 3
    2cce:	0e 8b       	std	Y+22, r16	; 0x16
    2cd0:	09 a3       	std	Y+33, r16	; 0x21
    2cd2:	1a a2       	std	Y+34, r1	; 0x22
    2cd4:	6e 01       	movw	r12, r28
    2cd6:	b2 e0       	ldi	r27, 0x02	; 2
    2cd8:	cb 0e       	add	r12, r27
    2cda:	d1 1c       	adc	r13, r1
    2cdc:	c6 01       	movw	r24, r12
    2cde:	0e 94 a9 1e 	call	0x3d52	; 0x3d52 <vListInitialiseItem>
    2ce2:	ce 01       	movw	r24, r28
    2ce4:	0c 96       	adiw	r24, 0x0c	; 12
    2ce6:	0e 94 a9 1e 	call	0x3d52	; 0x3d52 <vListInitialiseItem>
    2cea:	d9 87       	std	Y+9, r29	; 0x09
    2cec:	c8 87       	std	Y+8, r28	; 0x08
    2cee:	84 e0       	ldi	r24, 0x04	; 4
    2cf0:	90 e0       	ldi	r25, 0x00	; 0
    2cf2:	80 1b       	sub	r24, r16
    2cf4:	91 09       	sbc	r25, r1
    2cf6:	9d 87       	std	Y+13, r25	; 0x0d
    2cf8:	8c 87       	std	Y+12, r24	; 0x0c
    2cfa:	db 8b       	std	Y+19, r29	; 0x13
    2cfc:	ca 8b       	std	Y+18, r28	; 0x12
    2cfe:	1b a2       	std	Y+35, r1	; 0x23
    2d00:	1c a2       	std	Y+36, r1	; 0x24
    2d02:	1d a2       	std	Y+37, r1	; 0x25
    2d04:	1e a2       	std	Y+38, r1	; 0x26
    2d06:	1f a2       	std	Y+39, r1	; 0x27
    2d08:	a4 01       	movw	r20, r8
    2d0a:	b3 01       	movw	r22, r6
    2d0c:	c5 01       	movw	r24, r10
    2d0e:	0e 94 2a 1f 	call	0x3e54	; 0x3e54 <pxPortInitialiseStack>
    2d12:	99 83       	std	Y+1, r25	; 0x01
    2d14:	88 83       	st	Y, r24
    2d16:	e1 14       	cp	r14, r1
    2d18:	f1 04       	cpc	r15, r1
    2d1a:	19 f0       	breq	.+6      	; 0x2d22 <xTaskCreate+0xf8>
    2d1c:	f7 01       	movw	r30, r14
    2d1e:	d1 83       	std	Z+1, r29	; 0x01
    2d20:	c0 83       	st	Z, r28
    2d22:	0f b6       	in	r0, 0x3f	; 63
    2d24:	f8 94       	cli
    2d26:	0f 92       	push	r0
    2d28:	80 91 7c 04 	lds	r24, 0x047C	; 0x80047c <uxCurrentNumberOfTasks>
    2d2c:	8f 5f       	subi	r24, 0xFF	; 255
    2d2e:	80 93 7c 04 	sts	0x047C, r24	; 0x80047c <uxCurrentNumberOfTasks>
    2d32:	80 91 d3 04 	lds	r24, 0x04D3	; 0x8004d3 <pxCurrentTCB>
    2d36:	90 91 d4 04 	lds	r25, 0x04D4	; 0x8004d4 <pxCurrentTCB+0x1>
    2d3a:	89 2b       	or	r24, r25
    2d3c:	d1 f5       	brne	.+116    	; 0x2db2 <xTaskCreate+0x188>
    2d3e:	d0 93 d4 04 	sts	0x04D4, r29	; 0x8004d4 <pxCurrentTCB+0x1>
    2d42:	c0 93 d3 04 	sts	0x04D3, r28	; 0x8004d3 <pxCurrentTCB>
    2d46:	80 91 7c 04 	lds	r24, 0x047C	; 0x80047c <uxCurrentNumberOfTasks>
    2d4a:	81 30       	cpi	r24, 0x01	; 1
    2d4c:	09 f0       	breq	.+2      	; 0x2d50 <xTaskCreate+0x126>
    2d4e:	41 c0       	rjmp	.+130    	; 0x2dd2 <xTaskCreate+0x1a8>
    2d50:	8f ea       	ldi	r24, 0xAF	; 175
    2d52:	94 e0       	ldi	r25, 0x04	; 4
    2d54:	0e 94 9b 1e 	call	0x3d36	; 0x3d36 <vListInitialise>
    2d58:	88 eb       	ldi	r24, 0xB8	; 184
    2d5a:	94 e0       	ldi	r25, 0x04	; 4
    2d5c:	0e 94 9b 1e 	call	0x3d36	; 0x3d36 <vListInitialise>
    2d60:	81 ec       	ldi	r24, 0xC1	; 193
    2d62:	94 e0       	ldi	r25, 0x04	; 4
    2d64:	0e 94 9b 1e 	call	0x3d36	; 0x3d36 <vListInitialise>
    2d68:	8a ec       	ldi	r24, 0xCA	; 202
    2d6a:	94 e0       	ldi	r25, 0x04	; 4
    2d6c:	0e 94 9b 1e 	call	0x3d36	; 0x3d36 <vListInitialise>
    2d70:	86 ea       	ldi	r24, 0xA6	; 166
    2d72:	94 e0       	ldi	r25, 0x04	; 4
    2d74:	0e 94 9b 1e 	call	0x3d36	; 0x3d36 <vListInitialise>
    2d78:	8d e9       	ldi	r24, 0x9D	; 157
    2d7a:	94 e0       	ldi	r25, 0x04	; 4
    2d7c:	0e 94 9b 1e 	call	0x3d36	; 0x3d36 <vListInitialise>
    2d80:	80 e9       	ldi	r24, 0x90	; 144
    2d82:	94 e0       	ldi	r25, 0x04	; 4
    2d84:	0e 94 9b 1e 	call	0x3d36	; 0x3d36 <vListInitialise>
    2d88:	87 e8       	ldi	r24, 0x87	; 135
    2d8a:	94 e0       	ldi	r25, 0x04	; 4
    2d8c:	0e 94 9b 1e 	call	0x3d36	; 0x3d36 <vListInitialise>
    2d90:	8d e7       	ldi	r24, 0x7D	; 125
    2d92:	94 e0       	ldi	r25, 0x04	; 4
    2d94:	0e 94 9b 1e 	call	0x3d36	; 0x3d36 <vListInitialise>
    2d98:	86 ea       	ldi	r24, 0xA6	; 166
    2d9a:	94 e0       	ldi	r25, 0x04	; 4
    2d9c:	90 93 9c 04 	sts	0x049C, r25	; 0x80049c <pxDelayedTaskList+0x1>
    2da0:	80 93 9b 04 	sts	0x049B, r24	; 0x80049b <pxDelayedTaskList>
    2da4:	8d e9       	ldi	r24, 0x9D	; 157
    2da6:	94 e0       	ldi	r25, 0x04	; 4
    2da8:	90 93 9a 04 	sts	0x049A, r25	; 0x80049a <pxOverflowDelayedTaskList+0x1>
    2dac:	80 93 99 04 	sts	0x0499, r24	; 0x800499 <pxOverflowDelayedTaskList>
    2db0:	10 c0       	rjmp	.+32     	; 0x2dd2 <xTaskCreate+0x1a8>
    2db2:	80 91 78 04 	lds	r24, 0x0478	; 0x800478 <xSchedulerRunning>
    2db6:	81 11       	cpse	r24, r1
    2db8:	0c c0       	rjmp	.+24     	; 0x2dd2 <xTaskCreate+0x1a8>
    2dba:	e0 91 d3 04 	lds	r30, 0x04D3	; 0x8004d3 <pxCurrentTCB>
    2dbe:	f0 91 d4 04 	lds	r31, 0x04D4	; 0x8004d4 <pxCurrentTCB+0x1>
    2dc2:	96 89       	ldd	r25, Z+22	; 0x16
    2dc4:	8e 89       	ldd	r24, Y+22	; 0x16
    2dc6:	89 17       	cp	r24, r25
    2dc8:	20 f0       	brcs	.+8      	; 0x2dd2 <xTaskCreate+0x1a8>
    2dca:	d0 93 d4 04 	sts	0x04D4, r29	; 0x8004d4 <pxCurrentTCB+0x1>
    2dce:	c0 93 d3 04 	sts	0x04D3, r28	; 0x8004d3 <pxCurrentTCB>
    2dd2:	80 91 74 04 	lds	r24, 0x0474	; 0x800474 <uxTaskNumber>
    2dd6:	8f 5f       	subi	r24, 0xFF	; 255
    2dd8:	80 93 74 04 	sts	0x0474, r24	; 0x800474 <uxTaskNumber>
    2ddc:	8e 89       	ldd	r24, Y+22	; 0x16
    2dde:	90 91 79 04 	lds	r25, 0x0479	; 0x800479 <uxTopReadyPriority>
    2de2:	98 17       	cp	r25, r24
    2de4:	10 f4       	brcc	.+4      	; 0x2dea <xTaskCreate+0x1c0>
    2de6:	80 93 79 04 	sts	0x0479, r24	; 0x800479 <uxTopReadyPriority>
    2dea:	f9 e0       	ldi	r31, 0x09	; 9
    2dec:	8f 9f       	mul	r24, r31
    2dee:	c0 01       	movw	r24, r0
    2df0:	11 24       	eor	r1, r1
    2df2:	b6 01       	movw	r22, r12
    2df4:	81 55       	subi	r24, 0x51	; 81
    2df6:	9b 4f       	sbci	r25, 0xFB	; 251
    2df8:	0e 94 ad 1e 	call	0x3d5a	; 0x3d5a <vListInsertEnd>
    2dfc:	0f 90       	pop	r0
    2dfe:	0f be       	out	0x3f, r0	; 63
    2e00:	80 91 78 04 	lds	r24, 0x0478	; 0x800478 <xSchedulerRunning>
    2e04:	88 23       	and	r24, r24
    2e06:	51 f0       	breq	.+20     	; 0x2e1c <xTaskCreate+0x1f2>
    2e08:	e0 91 d3 04 	lds	r30, 0x04D3	; 0x8004d3 <pxCurrentTCB>
    2e0c:	f0 91 d4 04 	lds	r31, 0x04D4	; 0x8004d4 <pxCurrentTCB+0x1>
    2e10:	96 89       	ldd	r25, Z+22	; 0x16
    2e12:	8e 89       	ldd	r24, Y+22	; 0x16
    2e14:	98 17       	cp	r25, r24
    2e16:	10 f4       	brcc	.+4      	; 0x2e1c <xTaskCreate+0x1f2>
    2e18:	0e 94 ce 1f 	call	0x3f9c	; 0x3f9c <vPortYield>
    2e1c:	81 e0       	ldi	r24, 0x01	; 1
    2e1e:	01 c0       	rjmp	.+2      	; 0x2e22 <xTaskCreate+0x1f8>
    2e20:	8f ef       	ldi	r24, 0xFF	; 255
    2e22:	df 91       	pop	r29
    2e24:	cf 91       	pop	r28
    2e26:	1f 91       	pop	r17
    2e28:	0f 91       	pop	r16
    2e2a:	ff 90       	pop	r15
    2e2c:	ef 90       	pop	r14
    2e2e:	df 90       	pop	r13
    2e30:	cf 90       	pop	r12
    2e32:	bf 90       	pop	r11
    2e34:	af 90       	pop	r10
    2e36:	9f 90       	pop	r9
    2e38:	8f 90       	pop	r8
    2e3a:	7f 90       	pop	r7
    2e3c:	6f 90       	pop	r6
    2e3e:	5f 90       	pop	r5
    2e40:	08 95       	ret

00002e42 <vTaskResume>:
    2e42:	0f 93       	push	r16
    2e44:	1f 93       	push	r17
    2e46:	cf 93       	push	r28
    2e48:	df 93       	push	r29
    2e4a:	20 91 d3 04 	lds	r18, 0x04D3	; 0x8004d3 <pxCurrentTCB>
    2e4e:	30 91 d4 04 	lds	r19, 0x04D4	; 0x8004d4 <pxCurrentTCB+0x1>
    2e52:	82 17       	cp	r24, r18
    2e54:	93 07       	cpc	r25, r19
    2e56:	09 f4       	brne	.+2      	; 0x2e5a <vTaskResume+0x18>
    2e58:	38 c0       	rjmp	.+112    	; 0x2eca <vTaskResume+0x88>
    2e5a:	00 97       	sbiw	r24, 0x00	; 0
    2e5c:	09 f4       	brne	.+2      	; 0x2e60 <vTaskResume+0x1e>
    2e5e:	35 c0       	rjmp	.+106    	; 0x2eca <vTaskResume+0x88>
    2e60:	0f b6       	in	r0, 0x3f	; 63
    2e62:	f8 94       	cli
    2e64:	0f 92       	push	r0
    2e66:	fc 01       	movw	r30, r24
    2e68:	22 85       	ldd	r18, Z+10	; 0x0a
    2e6a:	33 85       	ldd	r19, Z+11	; 0x0b
    2e6c:	2d 57       	subi	r18, 0x7D	; 125
    2e6e:	34 40       	sbci	r19, 0x04	; 4
    2e70:	51 f5       	brne	.+84     	; 0x2ec6 <vTaskResume+0x84>
    2e72:	fc 01       	movw	r30, r24
    2e74:	24 89       	ldd	r18, Z+20	; 0x14
    2e76:	35 89       	ldd	r19, Z+21	; 0x15
    2e78:	f4 e0       	ldi	r31, 0x04	; 4
    2e7a:	20 39       	cpi	r18, 0x90	; 144
    2e7c:	3f 07       	cpc	r19, r31
    2e7e:	19 f1       	breq	.+70     	; 0x2ec6 <vTaskResume+0x84>
    2e80:	23 2b       	or	r18, r19
    2e82:	09 f5       	brne	.+66     	; 0x2ec6 <vTaskResume+0x84>
    2e84:	ec 01       	movw	r28, r24
    2e86:	8c 01       	movw	r16, r24
    2e88:	0e 5f       	subi	r16, 0xFE	; 254
    2e8a:	1f 4f       	sbci	r17, 0xFF	; 255
    2e8c:	c8 01       	movw	r24, r16
    2e8e:	0e 94 06 1f 	call	0x3e0c	; 0x3e0c <uxListRemove>
    2e92:	8e 89       	ldd	r24, Y+22	; 0x16
    2e94:	90 91 79 04 	lds	r25, 0x0479	; 0x800479 <uxTopReadyPriority>
    2e98:	98 17       	cp	r25, r24
    2e9a:	10 f4       	brcc	.+4      	; 0x2ea0 <vTaskResume+0x5e>
    2e9c:	80 93 79 04 	sts	0x0479, r24	; 0x800479 <uxTopReadyPriority>
    2ea0:	29 e0       	ldi	r18, 0x09	; 9
    2ea2:	82 9f       	mul	r24, r18
    2ea4:	c0 01       	movw	r24, r0
    2ea6:	11 24       	eor	r1, r1
    2ea8:	b8 01       	movw	r22, r16
    2eaa:	81 55       	subi	r24, 0x51	; 81
    2eac:	9b 4f       	sbci	r25, 0xFB	; 251
    2eae:	0e 94 ad 1e 	call	0x3d5a	; 0x3d5a <vListInsertEnd>
    2eb2:	e0 91 d3 04 	lds	r30, 0x04D3	; 0x8004d3 <pxCurrentTCB>
    2eb6:	f0 91 d4 04 	lds	r31, 0x04D4	; 0x8004d4 <pxCurrentTCB+0x1>
    2eba:	9e 89       	ldd	r25, Y+22	; 0x16
    2ebc:	86 89       	ldd	r24, Z+22	; 0x16
    2ebe:	98 17       	cp	r25, r24
    2ec0:	10 f0       	brcs	.+4      	; 0x2ec6 <vTaskResume+0x84>
    2ec2:	0e 94 ce 1f 	call	0x3f9c	; 0x3f9c <vPortYield>
    2ec6:	0f 90       	pop	r0
    2ec8:	0f be       	out	0x3f, r0	; 63
    2eca:	df 91       	pop	r29
    2ecc:	cf 91       	pop	r28
    2ece:	1f 91       	pop	r17
    2ed0:	0f 91       	pop	r16
    2ed2:	08 95       	ret

00002ed4 <vTaskStartScheduler>:
    2ed4:	ef 92       	push	r14
    2ed6:	ff 92       	push	r15
    2ed8:	0f 93       	push	r16
    2eda:	80 e7       	ldi	r24, 0x70	; 112
    2edc:	e8 2e       	mov	r14, r24
    2ede:	84 e0       	ldi	r24, 0x04	; 4
    2ee0:	f8 2e       	mov	r15, r24
    2ee2:	00 e0       	ldi	r16, 0x00	; 0
    2ee4:	20 e0       	ldi	r18, 0x00	; 0
    2ee6:	30 e0       	ldi	r19, 0x00	; 0
    2ee8:	40 ec       	ldi	r20, 0xC0	; 192
    2eea:	50 e0       	ldi	r21, 0x00	; 0
    2eec:	63 e7       	ldi	r22, 0x73	; 115
    2eee:	72 e0       	ldi	r23, 0x02	; 2
    2ef0:	87 ee       	ldi	r24, 0xE7	; 231
    2ef2:	95 e1       	ldi	r25, 0x15	; 21
    2ef4:	0e 94 15 16 	call	0x2c2a	; 0x2c2a <xTaskCreate>
    2ef8:	81 30       	cpi	r24, 0x01	; 1
    2efa:	b1 f4       	brne	.+44     	; 0x2f28 <vTaskStartScheduler+0x54>
    2efc:	0e 94 f5 1a 	call	0x35ea	; 0x35ea <xTimerCreateTimerTask>
    2f00:	81 30       	cpi	r24, 0x01	; 1
    2f02:	91 f4       	brne	.+36     	; 0x2f28 <vTaskStartScheduler+0x54>
    2f04:	f8 94       	cli
    2f06:	2f ef       	ldi	r18, 0xFF	; 255
    2f08:	3f ef       	ldi	r19, 0xFF	; 255
    2f0a:	30 93 73 04 	sts	0x0473, r19	; 0x800473 <xNextTaskUnblockTime+0x1>
    2f0e:	20 93 72 04 	sts	0x0472, r18	; 0x800472 <xNextTaskUnblockTime>
    2f12:	80 93 78 04 	sts	0x0478, r24	; 0x800478 <xSchedulerRunning>
    2f16:	10 92 7b 04 	sts	0x047B, r1	; 0x80047b <xTickCount+0x1>
    2f1a:	10 92 7a 04 	sts	0x047A, r1	; 0x80047a <xTickCount>
    2f1e:	0f 91       	pop	r16
    2f20:	ff 90       	pop	r15
    2f22:	ef 90       	pop	r14
    2f24:	0c 94 96 1f 	jmp	0x3f2c	; 0x3f2c <xPortStartScheduler>
    2f28:	0f 91       	pop	r16
    2f2a:	ff 90       	pop	r15
    2f2c:	ef 90       	pop	r14
    2f2e:	08 95       	ret

00002f30 <vTaskSuspendAll>:
    2f30:	80 91 6f 04 	lds	r24, 0x046F	; 0x80046f <uxSchedulerSuspended>
    2f34:	8f 5f       	subi	r24, 0xFF	; 255
    2f36:	80 93 6f 04 	sts	0x046F, r24	; 0x80046f <uxSchedulerSuspended>
    2f3a:	08 95       	ret

00002f3c <xTaskGetTickCount>:
    2f3c:	0f b6       	in	r0, 0x3f	; 63
    2f3e:	f8 94       	cli
    2f40:	0f 92       	push	r0
    2f42:	80 91 7a 04 	lds	r24, 0x047A	; 0x80047a <xTickCount>
    2f46:	90 91 7b 04 	lds	r25, 0x047B	; 0x80047b <xTickCount+0x1>
    2f4a:	0f 90       	pop	r0
    2f4c:	0f be       	out	0x3f, r0	; 63
    2f4e:	08 95       	ret

00002f50 <xTaskIncrementTick>:
    2f50:	cf 92       	push	r12
    2f52:	df 92       	push	r13
    2f54:	ef 92       	push	r14
    2f56:	ff 92       	push	r15
    2f58:	0f 93       	push	r16
    2f5a:	1f 93       	push	r17
    2f5c:	cf 93       	push	r28
    2f5e:	df 93       	push	r29
    2f60:	80 91 6f 04 	lds	r24, 0x046F	; 0x80046f <uxSchedulerSuspended>
    2f64:	81 11       	cpse	r24, r1
    2f66:	8c c0       	rjmp	.+280    	; 0x3080 <xTaskIncrementTick+0x130>
    2f68:	00 91 7a 04 	lds	r16, 0x047A	; 0x80047a <xTickCount>
    2f6c:	10 91 7b 04 	lds	r17, 0x047B	; 0x80047b <xTickCount+0x1>
    2f70:	0f 5f       	subi	r16, 0xFF	; 255
    2f72:	1f 4f       	sbci	r17, 0xFF	; 255
    2f74:	10 93 7b 04 	sts	0x047B, r17	; 0x80047b <xTickCount+0x1>
    2f78:	00 93 7a 04 	sts	0x047A, r16	; 0x80047a <xTickCount>
    2f7c:	01 15       	cp	r16, r1
    2f7e:	11 05       	cpc	r17, r1
    2f80:	b9 f4       	brne	.+46     	; 0x2fb0 <xTaskIncrementTick+0x60>
    2f82:	80 91 9b 04 	lds	r24, 0x049B	; 0x80049b <pxDelayedTaskList>
    2f86:	90 91 9c 04 	lds	r25, 0x049C	; 0x80049c <pxDelayedTaskList+0x1>
    2f8a:	20 91 99 04 	lds	r18, 0x0499	; 0x800499 <pxOverflowDelayedTaskList>
    2f8e:	30 91 9a 04 	lds	r19, 0x049A	; 0x80049a <pxOverflowDelayedTaskList+0x1>
    2f92:	30 93 9c 04 	sts	0x049C, r19	; 0x80049c <pxDelayedTaskList+0x1>
    2f96:	20 93 9b 04 	sts	0x049B, r18	; 0x80049b <pxDelayedTaskList>
    2f9a:	90 93 9a 04 	sts	0x049A, r25	; 0x80049a <pxOverflowDelayedTaskList+0x1>
    2f9e:	80 93 99 04 	sts	0x0499, r24	; 0x800499 <pxOverflowDelayedTaskList>
    2fa2:	80 91 75 04 	lds	r24, 0x0475	; 0x800475 <xNumOfOverflows>
    2fa6:	8f 5f       	subi	r24, 0xFF	; 255
    2fa8:	80 93 75 04 	sts	0x0475, r24	; 0x800475 <xNumOfOverflows>
    2fac:	0e 94 70 15 	call	0x2ae0	; 0x2ae0 <prvResetNextTaskUnblockTime>
    2fb0:	80 91 72 04 	lds	r24, 0x0472	; 0x800472 <xNextTaskUnblockTime>
    2fb4:	90 91 73 04 	lds	r25, 0x0473	; 0x800473 <xNextTaskUnblockTime+0x1>
    2fb8:	c0 e0       	ldi	r28, 0x00	; 0
    2fba:	08 17       	cp	r16, r24
    2fbc:	19 07       	cpc	r17, r25
    2fbe:	08 f4       	brcc	.+2      	; 0x2fc2 <xTaskIncrementTick+0x72>
    2fc0:	4f c0       	rjmp	.+158    	; 0x3060 <xTaskIncrementTick+0x110>
    2fc2:	d9 e0       	ldi	r29, 0x09	; 9
    2fc4:	e0 91 9b 04 	lds	r30, 0x049B	; 0x80049b <pxDelayedTaskList>
    2fc8:	f0 91 9c 04 	lds	r31, 0x049C	; 0x80049c <pxDelayedTaskList+0x1>
    2fcc:	80 81       	ld	r24, Z
    2fce:	81 11       	cpse	r24, r1
    2fd0:	03 c0       	rjmp	.+6      	; 0x2fd8 <xTaskIncrementTick+0x88>
    2fd2:	8f ef       	ldi	r24, 0xFF	; 255
    2fd4:	9f ef       	ldi	r25, 0xFF	; 255
    2fd6:	11 c0       	rjmp	.+34     	; 0x2ffa <xTaskIncrementTick+0xaa>
    2fd8:	e0 91 9b 04 	lds	r30, 0x049B	; 0x80049b <pxDelayedTaskList>
    2fdc:	f0 91 9c 04 	lds	r31, 0x049C	; 0x80049c <pxDelayedTaskList+0x1>
    2fe0:	05 80       	ldd	r0, Z+5	; 0x05
    2fe2:	f6 81       	ldd	r31, Z+6	; 0x06
    2fe4:	e0 2d       	mov	r30, r0
    2fe6:	e6 80       	ldd	r14, Z+6	; 0x06
    2fe8:	f7 80       	ldd	r15, Z+7	; 0x07
    2fea:	d7 01       	movw	r26, r14
    2fec:	12 96       	adiw	r26, 0x02	; 2
    2fee:	8d 91       	ld	r24, X+
    2ff0:	9c 91       	ld	r25, X
    2ff2:	13 97       	sbiw	r26, 0x03	; 3
    2ff4:	08 17       	cp	r16, r24
    2ff6:	19 07       	cpc	r17, r25
    2ff8:	28 f4       	brcc	.+10     	; 0x3004 <xTaskIncrementTick+0xb4>
    2ffa:	90 93 73 04 	sts	0x0473, r25	; 0x800473 <xNextTaskUnblockTime+0x1>
    2ffe:	80 93 72 04 	sts	0x0472, r24	; 0x800472 <xNextTaskUnblockTime>
    3002:	2e c0       	rjmp	.+92     	; 0x3060 <xTaskIncrementTick+0x110>
    3004:	67 01       	movw	r12, r14
    3006:	b2 e0       	ldi	r27, 0x02	; 2
    3008:	cb 0e       	add	r12, r27
    300a:	d1 1c       	adc	r13, r1
    300c:	c6 01       	movw	r24, r12
    300e:	0e 94 06 1f 	call	0x3e0c	; 0x3e0c <uxListRemove>
    3012:	f7 01       	movw	r30, r14
    3014:	84 89       	ldd	r24, Z+20	; 0x14
    3016:	95 89       	ldd	r25, Z+21	; 0x15
    3018:	89 2b       	or	r24, r25
    301a:	21 f0       	breq	.+8      	; 0x3024 <xTaskIncrementTick+0xd4>
    301c:	c7 01       	movw	r24, r14
    301e:	0c 96       	adiw	r24, 0x0c	; 12
    3020:	0e 94 06 1f 	call	0x3e0c	; 0x3e0c <uxListRemove>
    3024:	d7 01       	movw	r26, r14
    3026:	56 96       	adiw	r26, 0x16	; 22
    3028:	8c 91       	ld	r24, X
    302a:	90 91 79 04 	lds	r25, 0x0479	; 0x800479 <uxTopReadyPriority>
    302e:	98 17       	cp	r25, r24
    3030:	10 f4       	brcc	.+4      	; 0x3036 <xTaskIncrementTick+0xe6>
    3032:	80 93 79 04 	sts	0x0479, r24	; 0x800479 <uxTopReadyPriority>
    3036:	d8 9f       	mul	r29, r24
    3038:	c0 01       	movw	r24, r0
    303a:	11 24       	eor	r1, r1
    303c:	b6 01       	movw	r22, r12
    303e:	81 55       	subi	r24, 0x51	; 81
    3040:	9b 4f       	sbci	r25, 0xFB	; 251
    3042:	0e 94 ad 1e 	call	0x3d5a	; 0x3d5a <vListInsertEnd>
    3046:	e0 91 d3 04 	lds	r30, 0x04D3	; 0x8004d3 <pxCurrentTCB>
    304a:	f0 91 d4 04 	lds	r31, 0x04D4	; 0x8004d4 <pxCurrentTCB+0x1>
    304e:	d7 01       	movw	r26, r14
    3050:	56 96       	adiw	r26, 0x16	; 22
    3052:	9c 91       	ld	r25, X
    3054:	86 89       	ldd	r24, Z+22	; 0x16
    3056:	98 17       	cp	r25, r24
    3058:	08 f4       	brcc	.+2      	; 0x305c <xTaskIncrementTick+0x10c>
    305a:	b4 cf       	rjmp	.-152    	; 0x2fc4 <xTaskIncrementTick+0x74>
    305c:	c1 e0       	ldi	r28, 0x01	; 1
    305e:	b2 cf       	rjmp	.-156    	; 0x2fc4 <xTaskIncrementTick+0x74>
    3060:	e0 91 d3 04 	lds	r30, 0x04D3	; 0x8004d3 <pxCurrentTCB>
    3064:	f0 91 d4 04 	lds	r31, 0x04D4	; 0x8004d4 <pxCurrentTCB+0x1>
    3068:	e6 89       	ldd	r30, Z+22	; 0x16
    306a:	b9 e0       	ldi	r27, 0x09	; 9
    306c:	eb 9f       	mul	r30, r27
    306e:	f0 01       	movw	r30, r0
    3070:	11 24       	eor	r1, r1
    3072:	e1 55       	subi	r30, 0x51	; 81
    3074:	fb 4f       	sbci	r31, 0xFB	; 251
    3076:	80 81       	ld	r24, Z
    3078:	82 30       	cpi	r24, 0x02	; 2
    307a:	40 f0       	brcs	.+16     	; 0x308c <xTaskIncrementTick+0x13c>
    307c:	c1 e0       	ldi	r28, 0x01	; 1
    307e:	06 c0       	rjmp	.+12     	; 0x308c <xTaskIncrementTick+0x13c>
    3080:	80 91 77 04 	lds	r24, 0x0477	; 0x800477 <uxPendedTicks>
    3084:	8f 5f       	subi	r24, 0xFF	; 255
    3086:	80 93 77 04 	sts	0x0477, r24	; 0x800477 <uxPendedTicks>
    308a:	c0 e0       	ldi	r28, 0x00	; 0
    308c:	80 91 76 04 	lds	r24, 0x0476	; 0x800476 <xYieldPending>
    3090:	81 11       	cpse	r24, r1
    3092:	c1 e0       	ldi	r28, 0x01	; 1
    3094:	8c 2f       	mov	r24, r28
    3096:	df 91       	pop	r29
    3098:	cf 91       	pop	r28
    309a:	1f 91       	pop	r17
    309c:	0f 91       	pop	r16
    309e:	ff 90       	pop	r15
    30a0:	ef 90       	pop	r14
    30a2:	df 90       	pop	r13
    30a4:	cf 90       	pop	r12
    30a6:	08 95       	ret

000030a8 <xTaskResumeAll>:
    30a8:	ef 92       	push	r14
    30aa:	ff 92       	push	r15
    30ac:	0f 93       	push	r16
    30ae:	1f 93       	push	r17
    30b0:	cf 93       	push	r28
    30b2:	df 93       	push	r29
    30b4:	0f b6       	in	r0, 0x3f	; 63
    30b6:	f8 94       	cli
    30b8:	0f 92       	push	r0
    30ba:	80 91 6f 04 	lds	r24, 0x046F	; 0x80046f <uxSchedulerSuspended>
    30be:	81 50       	subi	r24, 0x01	; 1
    30c0:	80 93 6f 04 	sts	0x046F, r24	; 0x80046f <uxSchedulerSuspended>
    30c4:	80 91 6f 04 	lds	r24, 0x046F	; 0x80046f <uxSchedulerSuspended>
    30c8:	88 23       	and	r24, r24
    30ca:	11 f0       	breq	.+4      	; 0x30d0 <xTaskResumeAll+0x28>
    30cc:	80 e0       	ldi	r24, 0x00	; 0
    30ce:	52 c0       	rjmp	.+164    	; 0x3174 <xTaskResumeAll+0xcc>
    30d0:	80 91 7c 04 	lds	r24, 0x047C	; 0x80047c <uxCurrentNumberOfTasks>
    30d4:	88 23       	and	r24, r24
    30d6:	d1 f3       	breq	.-12     	; 0x30cc <xTaskResumeAll+0x24>
    30d8:	c0 e0       	ldi	r28, 0x00	; 0
    30da:	d0 e0       	ldi	r29, 0x00	; 0
    30dc:	89 e0       	ldi	r24, 0x09	; 9
    30de:	f8 2e       	mov	r15, r24
    30e0:	ee 24       	eor	r14, r14
    30e2:	e3 94       	inc	r14
    30e4:	80 91 90 04 	lds	r24, 0x0490	; 0x800490 <xPendingReadyList>
    30e8:	88 23       	and	r24, r24
    30ea:	51 f1       	breq	.+84     	; 0x3140 <xTaskResumeAll+0x98>
    30ec:	e0 91 95 04 	lds	r30, 0x0495	; 0x800495 <xPendingReadyList+0x5>
    30f0:	f0 91 96 04 	lds	r31, 0x0496	; 0x800496 <xPendingReadyList+0x6>
    30f4:	c6 81       	ldd	r28, Z+6	; 0x06
    30f6:	d7 81       	ldd	r29, Z+7	; 0x07
    30f8:	ce 01       	movw	r24, r28
    30fa:	0c 96       	adiw	r24, 0x0c	; 12
    30fc:	0e 94 06 1f 	call	0x3e0c	; 0x3e0c <uxListRemove>
    3100:	8e 01       	movw	r16, r28
    3102:	0e 5f       	subi	r16, 0xFE	; 254
    3104:	1f 4f       	sbci	r17, 0xFF	; 255
    3106:	c8 01       	movw	r24, r16
    3108:	0e 94 06 1f 	call	0x3e0c	; 0x3e0c <uxListRemove>
    310c:	8e 89       	ldd	r24, Y+22	; 0x16
    310e:	90 91 79 04 	lds	r25, 0x0479	; 0x800479 <uxTopReadyPriority>
    3112:	98 17       	cp	r25, r24
    3114:	10 f4       	brcc	.+4      	; 0x311a <xTaskResumeAll+0x72>
    3116:	80 93 79 04 	sts	0x0479, r24	; 0x800479 <uxTopReadyPriority>
    311a:	f8 9e       	mul	r15, r24
    311c:	c0 01       	movw	r24, r0
    311e:	11 24       	eor	r1, r1
    3120:	b8 01       	movw	r22, r16
    3122:	81 55       	subi	r24, 0x51	; 81
    3124:	9b 4f       	sbci	r25, 0xFB	; 251
    3126:	0e 94 ad 1e 	call	0x3d5a	; 0x3d5a <vListInsertEnd>
    312a:	e0 91 d3 04 	lds	r30, 0x04D3	; 0x8004d3 <pxCurrentTCB>
    312e:	f0 91 d4 04 	lds	r31, 0x04D4	; 0x8004d4 <pxCurrentTCB+0x1>
    3132:	9e 89       	ldd	r25, Y+22	; 0x16
    3134:	86 89       	ldd	r24, Z+22	; 0x16
    3136:	98 17       	cp	r25, r24
    3138:	a8 f2       	brcs	.-86     	; 0x30e4 <xTaskResumeAll+0x3c>
    313a:	e0 92 76 04 	sts	0x0476, r14	; 0x800476 <xYieldPending>
    313e:	d2 cf       	rjmp	.-92     	; 0x30e4 <xTaskResumeAll+0x3c>
    3140:	cd 2b       	or	r28, r29
    3142:	11 f0       	breq	.+4      	; 0x3148 <xTaskResumeAll+0xa0>
    3144:	0e 94 70 15 	call	0x2ae0	; 0x2ae0 <prvResetNextTaskUnblockTime>
    3148:	c0 91 77 04 	lds	r28, 0x0477	; 0x800477 <uxPendedTicks>
    314c:	cc 23       	and	r28, r28
    314e:	51 f0       	breq	.+20     	; 0x3164 <xTaskResumeAll+0xbc>
    3150:	d1 e0       	ldi	r29, 0x01	; 1
    3152:	0e 94 a8 17 	call	0x2f50	; 0x2f50 <xTaskIncrementTick>
    3156:	81 11       	cpse	r24, r1
    3158:	d0 93 76 04 	sts	0x0476, r29	; 0x800476 <xYieldPending>
    315c:	c1 50       	subi	r28, 0x01	; 1
    315e:	c9 f7       	brne	.-14     	; 0x3152 <xTaskResumeAll+0xaa>
    3160:	10 92 77 04 	sts	0x0477, r1	; 0x800477 <uxPendedTicks>
    3164:	80 91 76 04 	lds	r24, 0x0476	; 0x800476 <xYieldPending>
    3168:	88 23       	and	r24, r24
    316a:	09 f4       	brne	.+2      	; 0x316e <xTaskResumeAll+0xc6>
    316c:	af cf       	rjmp	.-162    	; 0x30cc <xTaskResumeAll+0x24>
    316e:	0e 94 ce 1f 	call	0x3f9c	; 0x3f9c <vPortYield>
    3172:	81 e0       	ldi	r24, 0x01	; 1
    3174:	0f 90       	pop	r0
    3176:	0f be       	out	0x3f, r0	; 63
    3178:	df 91       	pop	r29
    317a:	cf 91       	pop	r28
    317c:	1f 91       	pop	r17
    317e:	0f 91       	pop	r16
    3180:	ff 90       	pop	r15
    3182:	ef 90       	pop	r14
    3184:	08 95       	ret

00003186 <vTaskDelayUntil>:
    3186:	0f 93       	push	r16
    3188:	1f 93       	push	r17
    318a:	cf 93       	push	r28
    318c:	df 93       	push	r29
    318e:	8c 01       	movw	r16, r24
    3190:	eb 01       	movw	r28, r22
    3192:	0e 94 98 17 	call	0x2f30	; 0x2f30 <vTaskSuspendAll>
    3196:	40 91 7a 04 	lds	r20, 0x047A	; 0x80047a <xTickCount>
    319a:	50 91 7b 04 	lds	r21, 0x047B	; 0x80047b <xTickCount+0x1>
    319e:	f8 01       	movw	r30, r16
    31a0:	20 81       	ld	r18, Z
    31a2:	31 81       	ldd	r19, Z+1	; 0x01
    31a4:	c9 01       	movw	r24, r18
    31a6:	8c 0f       	add	r24, r28
    31a8:	9d 1f       	adc	r25, r29
    31aa:	42 17       	cp	r20, r18
    31ac:	53 07       	cpc	r21, r19
    31ae:	20 f4       	brcc	.+8      	; 0x31b8 <vTaskDelayUntil+0x32>
    31b0:	82 17       	cp	r24, r18
    31b2:	93 07       	cpc	r25, r19
    31b4:	40 f4       	brcc	.+16     	; 0x31c6 <vTaskDelayUntil+0x40>
    31b6:	03 c0       	rjmp	.+6      	; 0x31be <vTaskDelayUntil+0x38>
    31b8:	82 17       	cp	r24, r18
    31ba:	93 07       	cpc	r25, r19
    31bc:	30 f0       	brcs	.+12     	; 0x31ca <vTaskDelayUntil+0x44>
    31be:	21 e0       	ldi	r18, 0x01	; 1
    31c0:	48 17       	cp	r20, r24
    31c2:	59 07       	cpc	r21, r25
    31c4:	18 f0       	brcs	.+6      	; 0x31cc <vTaskDelayUntil+0x46>
    31c6:	20 e0       	ldi	r18, 0x00	; 0
    31c8:	01 c0       	rjmp	.+2      	; 0x31cc <vTaskDelayUntil+0x46>
    31ca:	21 e0       	ldi	r18, 0x01	; 1
    31cc:	f8 01       	movw	r30, r16
    31ce:	91 83       	std	Z+1, r25	; 0x01
    31d0:	80 83       	st	Z, r24
    31d2:	22 23       	and	r18, r18
    31d4:	29 f0       	breq	.+10     	; 0x31e0 <vTaskDelayUntil+0x5a>
    31d6:	60 e0       	ldi	r22, 0x00	; 0
    31d8:	84 1b       	sub	r24, r20
    31da:	95 0b       	sbc	r25, r21
    31dc:	0e 94 8b 15 	call	0x2b16	; 0x2b16 <prvAddCurrentTaskToDelayedList>
    31e0:	0e 94 54 18 	call	0x30a8	; 0x30a8 <xTaskResumeAll>
    31e4:	81 11       	cpse	r24, r1
    31e6:	02 c0       	rjmp	.+4      	; 0x31ec <vTaskDelayUntil+0x66>
    31e8:	0e 94 ce 1f 	call	0x3f9c	; 0x3f9c <vPortYield>
    31ec:	df 91       	pop	r29
    31ee:	cf 91       	pop	r28
    31f0:	1f 91       	pop	r17
    31f2:	0f 91       	pop	r16
    31f4:	08 95       	ret

000031f6 <vTaskSwitchContext>:
    31f6:	80 91 6f 04 	lds	r24, 0x046F	; 0x80046f <uxSchedulerSuspended>
    31fa:	88 23       	and	r24, r24
    31fc:	21 f0       	breq	.+8      	; 0x3206 <vTaskSwitchContext+0x10>
    31fe:	81 e0       	ldi	r24, 0x01	; 1
    3200:	80 93 76 04 	sts	0x0476, r24	; 0x800476 <xYieldPending>
    3204:	08 95       	ret
    3206:	10 92 76 04 	sts	0x0476, r1	; 0x800476 <xYieldPending>
    320a:	a0 91 d3 04 	lds	r26, 0x04D3	; 0x8004d3 <pxCurrentTCB>
    320e:	b0 91 d4 04 	lds	r27, 0x04D4	; 0x8004d4 <pxCurrentTCB+0x1>
    3212:	e0 91 d3 04 	lds	r30, 0x04D3	; 0x8004d3 <pxCurrentTCB>
    3216:	f0 91 d4 04 	lds	r31, 0x04D4	; 0x8004d4 <pxCurrentTCB+0x1>
    321a:	2d 91       	ld	r18, X+
    321c:	3c 91       	ld	r19, X
    321e:	87 89       	ldd	r24, Z+23	; 0x17
    3220:	90 8d       	ldd	r25, Z+24	; 0x18
    3222:	82 17       	cp	r24, r18
    3224:	93 07       	cpc	r25, r19
    3226:	60 f0       	brcs	.+24     	; 0x3240 <vTaskSwitchContext+0x4a>
    3228:	60 91 d3 04 	lds	r22, 0x04D3	; 0x8004d3 <pxCurrentTCB>
    322c:	70 91 d4 04 	lds	r23, 0x04D4	; 0x8004d4 <pxCurrentTCB+0x1>
    3230:	80 91 d3 04 	lds	r24, 0x04D3	; 0x8004d3 <pxCurrentTCB>
    3234:	90 91 d4 04 	lds	r25, 0x04D4	; 0x8004d4 <pxCurrentTCB+0x1>
    3238:	67 5e       	subi	r22, 0xE7	; 231
    323a:	7f 4f       	sbci	r23, 0xFF	; 255
    323c:	0e 94 c3 1c 	call	0x3986	; 0x3986 <vApplicationStackOverflowHook>
    3240:	80 91 79 04 	lds	r24, 0x0479	; 0x800479 <uxTopReadyPriority>
    3244:	69 e0       	ldi	r22, 0x09	; 9
    3246:	48 2f       	mov	r20, r24
    3248:	50 e0       	ldi	r21, 0x00	; 0
    324a:	64 9f       	mul	r22, r20
    324c:	90 01       	movw	r18, r0
    324e:	65 9f       	mul	r22, r21
    3250:	30 0d       	add	r19, r0
    3252:	11 24       	eor	r1, r1
    3254:	f9 01       	movw	r30, r18
    3256:	e1 55       	subi	r30, 0x51	; 81
    3258:	fb 4f       	sbci	r31, 0xFB	; 251
    325a:	90 81       	ld	r25, Z
    325c:	91 11       	cpse	r25, r1
    325e:	02 c0       	rjmp	.+4      	; 0x3264 <vTaskSwitchContext+0x6e>
    3260:	81 50       	subi	r24, 0x01	; 1
    3262:	f1 cf       	rjmp	.-30     	; 0x3246 <vTaskSwitchContext+0x50>
    3264:	a1 81       	ldd	r26, Z+1	; 0x01
    3266:	b2 81       	ldd	r27, Z+2	; 0x02
    3268:	12 96       	adiw	r26, 0x02	; 2
    326a:	0d 90       	ld	r0, X+
    326c:	bc 91       	ld	r27, X
    326e:	a0 2d       	mov	r26, r0
    3270:	b2 83       	std	Z+2, r27	; 0x02
    3272:	a1 83       	std	Z+1, r26	; 0x01
    3274:	2e 54       	subi	r18, 0x4E	; 78
    3276:	3b 4f       	sbci	r19, 0xFB	; 251
    3278:	a2 17       	cp	r26, r18
    327a:	b3 07       	cpc	r27, r19
    327c:	31 f4       	brne	.+12     	; 0x328a <vTaskSwitchContext+0x94>
    327e:	12 96       	adiw	r26, 0x02	; 2
    3280:	2d 91       	ld	r18, X+
    3282:	3c 91       	ld	r19, X
    3284:	13 97       	sbiw	r26, 0x03	; 3
    3286:	32 83       	std	Z+2, r19	; 0x02
    3288:	21 83       	std	Z+1, r18	; 0x01
    328a:	99 e0       	ldi	r25, 0x09	; 9
    328c:	94 9f       	mul	r25, r20
    328e:	f0 01       	movw	r30, r0
    3290:	95 9f       	mul	r25, r21
    3292:	f0 0d       	add	r31, r0
    3294:	11 24       	eor	r1, r1
    3296:	e1 55       	subi	r30, 0x51	; 81
    3298:	fb 4f       	sbci	r31, 0xFB	; 251
    329a:	01 80       	ldd	r0, Z+1	; 0x01
    329c:	f2 81       	ldd	r31, Z+2	; 0x02
    329e:	e0 2d       	mov	r30, r0
    32a0:	26 81       	ldd	r18, Z+6	; 0x06
    32a2:	37 81       	ldd	r19, Z+7	; 0x07
    32a4:	30 93 d4 04 	sts	0x04D4, r19	; 0x8004d4 <pxCurrentTCB+0x1>
    32a8:	20 93 d3 04 	sts	0x04D3, r18	; 0x8004d3 <pxCurrentTCB>
    32ac:	80 93 79 04 	sts	0x0479, r24	; 0x800479 <uxTopReadyPriority>
    32b0:	08 95       	ret

000032b2 <vTaskSuspend>:
    32b2:	0f 93       	push	r16
    32b4:	1f 93       	push	r17
    32b6:	cf 93       	push	r28
    32b8:	df 93       	push	r29
    32ba:	ec 01       	movw	r28, r24
    32bc:	0f b6       	in	r0, 0x3f	; 63
    32be:	f8 94       	cli
    32c0:	0f 92       	push	r0
    32c2:	89 2b       	or	r24, r25
    32c4:	21 f4       	brne	.+8      	; 0x32ce <vTaskSuspend+0x1c>
    32c6:	c0 91 d3 04 	lds	r28, 0x04D3	; 0x8004d3 <pxCurrentTCB>
    32ca:	d0 91 d4 04 	lds	r29, 0x04D4	; 0x8004d4 <pxCurrentTCB+0x1>
    32ce:	8e 01       	movw	r16, r28
    32d0:	0e 5f       	subi	r16, 0xFE	; 254
    32d2:	1f 4f       	sbci	r17, 0xFF	; 255
    32d4:	c8 01       	movw	r24, r16
    32d6:	0e 94 06 1f 	call	0x3e0c	; 0x3e0c <uxListRemove>
    32da:	8c 89       	ldd	r24, Y+20	; 0x14
    32dc:	9d 89       	ldd	r25, Y+21	; 0x15
    32de:	89 2b       	or	r24, r25
    32e0:	21 f0       	breq	.+8      	; 0x32ea <vTaskSuspend+0x38>
    32e2:	ce 01       	movw	r24, r28
    32e4:	0c 96       	adiw	r24, 0x0c	; 12
    32e6:	0e 94 06 1f 	call	0x3e0c	; 0x3e0c <uxListRemove>
    32ea:	b8 01       	movw	r22, r16
    32ec:	8d e7       	ldi	r24, 0x7D	; 125
    32ee:	94 e0       	ldi	r25, 0x04	; 4
    32f0:	0e 94 ad 1e 	call	0x3d5a	; 0x3d5a <vListInsertEnd>
    32f4:	8f a1       	ldd	r24, Y+39	; 0x27
    32f6:	81 30       	cpi	r24, 0x01	; 1
    32f8:	09 f4       	brne	.+2      	; 0x32fc <vTaskSuspend+0x4a>
    32fa:	1f a2       	std	Y+39, r1	; 0x27
    32fc:	0f 90       	pop	r0
    32fe:	0f be       	out	0x3f, r0	; 63
    3300:	80 91 78 04 	lds	r24, 0x0478	; 0x800478 <xSchedulerRunning>
    3304:	88 23       	and	r24, r24
    3306:	39 f0       	breq	.+14     	; 0x3316 <vTaskSuspend+0x64>
    3308:	0f b6       	in	r0, 0x3f	; 63
    330a:	f8 94       	cli
    330c:	0f 92       	push	r0
    330e:	0e 94 70 15 	call	0x2ae0	; 0x2ae0 <prvResetNextTaskUnblockTime>
    3312:	0f 90       	pop	r0
    3314:	0f be       	out	0x3f, r0	; 63
    3316:	80 91 d3 04 	lds	r24, 0x04D3	; 0x8004d3 <pxCurrentTCB>
    331a:	90 91 d4 04 	lds	r25, 0x04D4	; 0x8004d4 <pxCurrentTCB+0x1>
    331e:	c8 17       	cp	r28, r24
    3320:	d9 07       	cpc	r29, r25
    3322:	c1 f4       	brne	.+48     	; 0x3354 <vTaskSuspend+0xa2>
    3324:	80 91 78 04 	lds	r24, 0x0478	; 0x800478 <xSchedulerRunning>
    3328:	88 23       	and	r24, r24
    332a:	19 f0       	breq	.+6      	; 0x3332 <vTaskSuspend+0x80>
    332c:	0e 94 ce 1f 	call	0x3f9c	; 0x3f9c <vPortYield>
    3330:	11 c0       	rjmp	.+34     	; 0x3354 <vTaskSuspend+0xa2>
    3332:	90 91 7d 04 	lds	r25, 0x047D	; 0x80047d <xSuspendedTaskList>
    3336:	80 91 7c 04 	lds	r24, 0x047C	; 0x80047c <uxCurrentNumberOfTasks>
    333a:	98 13       	cpse	r25, r24
    333c:	05 c0       	rjmp	.+10     	; 0x3348 <vTaskSuspend+0x96>
    333e:	10 92 d4 04 	sts	0x04D4, r1	; 0x8004d4 <pxCurrentTCB+0x1>
    3342:	10 92 d3 04 	sts	0x04D3, r1	; 0x8004d3 <pxCurrentTCB>
    3346:	06 c0       	rjmp	.+12     	; 0x3354 <vTaskSuspend+0xa2>
    3348:	df 91       	pop	r29
    334a:	cf 91       	pop	r28
    334c:	1f 91       	pop	r17
    334e:	0f 91       	pop	r16
    3350:	0c 94 fb 18 	jmp	0x31f6	; 0x31f6 <vTaskSwitchContext>
    3354:	df 91       	pop	r29
    3356:	cf 91       	pop	r28
    3358:	1f 91       	pop	r17
    335a:	0f 91       	pop	r16
    335c:	08 95       	ret

0000335e <vTaskPlaceOnEventList>:
    335e:	cf 93       	push	r28
    3360:	df 93       	push	r29
    3362:	eb 01       	movw	r28, r22
    3364:	60 91 d3 04 	lds	r22, 0x04D3	; 0x8004d3 <pxCurrentTCB>
    3368:	70 91 d4 04 	lds	r23, 0x04D4	; 0x8004d4 <pxCurrentTCB+0x1>
    336c:	64 5f       	subi	r22, 0xF4	; 244
    336e:	7f 4f       	sbci	r23, 0xFF	; 255
    3370:	0e 94 ce 1e 	call	0x3d9c	; 0x3d9c <vListInsert>
    3374:	61 e0       	ldi	r22, 0x01	; 1
    3376:	ce 01       	movw	r24, r28
    3378:	df 91       	pop	r29
    337a:	cf 91       	pop	r28
    337c:	0c 94 8b 15 	jmp	0x2b16	; 0x2b16 <prvAddCurrentTaskToDelayedList>

00003380 <vTaskPlaceOnEventListRestricted>:
    3380:	1f 93       	push	r17
    3382:	cf 93       	push	r28
    3384:	df 93       	push	r29
    3386:	eb 01       	movw	r28, r22
    3388:	14 2f       	mov	r17, r20
    338a:	60 91 d3 04 	lds	r22, 0x04D3	; 0x8004d3 <pxCurrentTCB>
    338e:	70 91 d4 04 	lds	r23, 0x04D4	; 0x8004d4 <pxCurrentTCB+0x1>
    3392:	64 5f       	subi	r22, 0xF4	; 244
    3394:	7f 4f       	sbci	r23, 0xFF	; 255
    3396:	0e 94 ad 1e 	call	0x3d5a	; 0x3d5a <vListInsertEnd>
    339a:	11 23       	and	r17, r17
    339c:	11 f0       	breq	.+4      	; 0x33a2 <vTaskPlaceOnEventListRestricted+0x22>
    339e:	cf ef       	ldi	r28, 0xFF	; 255
    33a0:	df ef       	ldi	r29, 0xFF	; 255
    33a2:	61 2f       	mov	r22, r17
    33a4:	ce 01       	movw	r24, r28
    33a6:	df 91       	pop	r29
    33a8:	cf 91       	pop	r28
    33aa:	1f 91       	pop	r17
    33ac:	0c 94 8b 15 	jmp	0x2b16	; 0x2b16 <prvAddCurrentTaskToDelayedList>

000033b0 <xTaskRemoveFromEventList>:
    33b0:	0f 93       	push	r16
    33b2:	1f 93       	push	r17
    33b4:	cf 93       	push	r28
    33b6:	df 93       	push	r29
    33b8:	dc 01       	movw	r26, r24
    33ba:	15 96       	adiw	r26, 0x05	; 5
    33bc:	ed 91       	ld	r30, X+
    33be:	fc 91       	ld	r31, X
    33c0:	16 97       	sbiw	r26, 0x06	; 6
    33c2:	c6 81       	ldd	r28, Z+6	; 0x06
    33c4:	d7 81       	ldd	r29, Z+7	; 0x07
    33c6:	8e 01       	movw	r16, r28
    33c8:	04 5f       	subi	r16, 0xF4	; 244
    33ca:	1f 4f       	sbci	r17, 0xFF	; 255
    33cc:	c8 01       	movw	r24, r16
    33ce:	0e 94 06 1f 	call	0x3e0c	; 0x3e0c <uxListRemove>
    33d2:	80 91 6f 04 	lds	r24, 0x046F	; 0x80046f <uxSchedulerSuspended>
    33d6:	81 11       	cpse	r24, r1
    33d8:	14 c0       	rjmp	.+40     	; 0x3402 <xTaskRemoveFromEventList+0x52>
    33da:	0a 50       	subi	r16, 0x0A	; 10
    33dc:	11 09       	sbc	r17, r1
    33de:	c8 01       	movw	r24, r16
    33e0:	0e 94 06 1f 	call	0x3e0c	; 0x3e0c <uxListRemove>
    33e4:	8e 89       	ldd	r24, Y+22	; 0x16
    33e6:	90 91 79 04 	lds	r25, 0x0479	; 0x800479 <uxTopReadyPriority>
    33ea:	98 17       	cp	r25, r24
    33ec:	10 f4       	brcc	.+4      	; 0x33f2 <xTaskRemoveFromEventList+0x42>
    33ee:	80 93 79 04 	sts	0x0479, r24	; 0x800479 <uxTopReadyPriority>
    33f2:	b9 e0       	ldi	r27, 0x09	; 9
    33f4:	8b 9f       	mul	r24, r27
    33f6:	c0 01       	movw	r24, r0
    33f8:	11 24       	eor	r1, r1
    33fa:	b8 01       	movw	r22, r16
    33fc:	81 55       	subi	r24, 0x51	; 81
    33fe:	9b 4f       	sbci	r25, 0xFB	; 251
    3400:	03 c0       	rjmp	.+6      	; 0x3408 <xTaskRemoveFromEventList+0x58>
    3402:	b8 01       	movw	r22, r16
    3404:	80 e9       	ldi	r24, 0x90	; 144
    3406:	94 e0       	ldi	r25, 0x04	; 4
    3408:	0e 94 ad 1e 	call	0x3d5a	; 0x3d5a <vListInsertEnd>
    340c:	e0 91 d3 04 	lds	r30, 0x04D3	; 0x8004d3 <pxCurrentTCB>
    3410:	f0 91 d4 04 	lds	r31, 0x04D4	; 0x8004d4 <pxCurrentTCB+0x1>
    3414:	9e 89       	ldd	r25, Y+22	; 0x16
    3416:	86 89       	ldd	r24, Z+22	; 0x16
    3418:	89 17       	cp	r24, r25
    341a:	20 f4       	brcc	.+8      	; 0x3424 <xTaskRemoveFromEventList+0x74>
    341c:	81 e0       	ldi	r24, 0x01	; 1
    341e:	80 93 76 04 	sts	0x0476, r24	; 0x800476 <xYieldPending>
    3422:	01 c0       	rjmp	.+2      	; 0x3426 <xTaskRemoveFromEventList+0x76>
    3424:	80 e0       	ldi	r24, 0x00	; 0
    3426:	df 91       	pop	r29
    3428:	cf 91       	pop	r28
    342a:	1f 91       	pop	r17
    342c:	0f 91       	pop	r16
    342e:	08 95       	ret

00003430 <vTaskInternalSetTimeOutState>:
    3430:	20 91 75 04 	lds	r18, 0x0475	; 0x800475 <xNumOfOverflows>
    3434:	fc 01       	movw	r30, r24
    3436:	20 83       	st	Z, r18
    3438:	20 91 7a 04 	lds	r18, 0x047A	; 0x80047a <xTickCount>
    343c:	30 91 7b 04 	lds	r19, 0x047B	; 0x80047b <xTickCount+0x1>
    3440:	32 83       	std	Z+2, r19	; 0x02
    3442:	21 83       	std	Z+1, r18	; 0x01
    3444:	08 95       	ret

00003446 <xTaskCheckForTimeOut>:
    3446:	cf 93       	push	r28
    3448:	df 93       	push	r29
    344a:	0f b6       	in	r0, 0x3f	; 63
    344c:	f8 94       	cli
    344e:	0f 92       	push	r0
    3450:	40 91 7a 04 	lds	r20, 0x047A	; 0x80047a <xTickCount>
    3454:	50 91 7b 04 	lds	r21, 0x047B	; 0x80047b <xTickCount+0x1>
    3458:	db 01       	movw	r26, r22
    345a:	2d 91       	ld	r18, X+
    345c:	3c 91       	ld	r19, X
    345e:	2f 3f       	cpi	r18, 0xFF	; 255
    3460:	bf ef       	ldi	r27, 0xFF	; 255
    3462:	3b 07       	cpc	r19, r27
    3464:	d9 f0       	breq	.+54     	; 0x349c <xTaskCheckForTimeOut+0x56>
    3466:	ec 01       	movw	r28, r24
    3468:	e9 81       	ldd	r30, Y+1	; 0x01
    346a:	fa 81       	ldd	r31, Y+2	; 0x02
    346c:	a0 91 75 04 	lds	r26, 0x0475	; 0x800475 <xNumOfOverflows>
    3470:	b8 81       	ld	r27, Y
    3472:	ba 17       	cp	r27, r26
    3474:	19 f0       	breq	.+6      	; 0x347c <xTaskCheckForTimeOut+0x36>
    3476:	4e 17       	cp	r20, r30
    3478:	5f 07       	cpc	r21, r31
    347a:	90 f4       	brcc	.+36     	; 0x34a0 <xTaskCheckForTimeOut+0x5a>
    347c:	4e 1b       	sub	r20, r30
    347e:	5f 0b       	sbc	r21, r31
    3480:	fb 01       	movw	r30, r22
    3482:	42 17       	cp	r20, r18
    3484:	53 07       	cpc	r21, r19
    3486:	38 f4       	brcc	.+14     	; 0x3496 <xTaskCheckForTimeOut+0x50>
    3488:	24 1b       	sub	r18, r20
    348a:	35 0b       	sbc	r19, r21
    348c:	31 83       	std	Z+1, r19	; 0x01
    348e:	20 83       	st	Z, r18
    3490:	0e 94 18 1a 	call	0x3430	; 0x3430 <vTaskInternalSetTimeOutState>
    3494:	03 c0       	rjmp	.+6      	; 0x349c <xTaskCheckForTimeOut+0x56>
    3496:	11 82       	std	Z+1, r1	; 0x01
    3498:	10 82       	st	Z, r1
    349a:	02 c0       	rjmp	.+4      	; 0x34a0 <xTaskCheckForTimeOut+0x5a>
    349c:	80 e0       	ldi	r24, 0x00	; 0
    349e:	01 c0       	rjmp	.+2      	; 0x34a2 <xTaskCheckForTimeOut+0x5c>
    34a0:	81 e0       	ldi	r24, 0x01	; 1
    34a2:	0f 90       	pop	r0
    34a4:	0f be       	out	0x3f, r0	; 63
    34a6:	df 91       	pop	r29
    34a8:	cf 91       	pop	r28
    34aa:	08 95       	ret

000034ac <vTaskMissedYield>:
    34ac:	81 e0       	ldi	r24, 0x01	; 1
    34ae:	80 93 76 04 	sts	0x0476, r24	; 0x800476 <xYieldPending>
    34b2:	08 95       	ret

000034b4 <xTaskGetSchedulerState>:
    34b4:	80 91 78 04 	lds	r24, 0x0478	; 0x800478 <xSchedulerRunning>
    34b8:	88 23       	and	r24, r24
    34ba:	31 f0       	breq	.+12     	; 0x34c8 <xTaskGetSchedulerState+0x14>
    34bc:	80 91 6f 04 	lds	r24, 0x046F	; 0x80046f <uxSchedulerSuspended>
    34c0:	88 23       	and	r24, r24
    34c2:	21 f0       	breq	.+8      	; 0x34cc <xTaskGetSchedulerState+0x18>
    34c4:	80 e0       	ldi	r24, 0x00	; 0
    34c6:	08 95       	ret
    34c8:	81 e0       	ldi	r24, 0x01	; 1
    34ca:	08 95       	ret
    34cc:	82 e0       	ldi	r24, 0x02	; 2
    34ce:	08 95       	ret

000034d0 <xTaskPriorityDisinherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

    BaseType_t xTaskPriorityDisinherit( TaskHandle_t const pxMutexHolder )
    {
    34d0:	0f 93       	push	r16
    34d2:	1f 93       	push	r17
    34d4:	cf 93       	push	r28
    34d6:	df 93       	push	r29
    34d8:	fc 01       	movw	r30, r24
    TCB_t * const pxTCB = pxMutexHolder;
    BaseType_t xReturn = pdFALSE;

        if( pxMutexHolder != NULL )
    34da:	89 2b       	or	r24, r25
    34dc:	11 f4       	brne	.+4      	; 0x34e2 <xTaskPriorityDisinherit+0x12>
#if ( configUSE_MUTEXES == 1 )

    BaseType_t xTaskPriorityDisinherit( TaskHandle_t const pxMutexHolder )
    {
    TCB_t * const pxTCB = pxMutexHolder;
    BaseType_t xReturn = pdFALSE;
    34de:	80 e0       	ldi	r24, 0x00	; 0
    34e0:	2c c0       	rjmp	.+88     	; 0x353a <xTaskPriorityDisinherit+0x6a>
            If the mutex is held by a task then it cannot be given from an
            interrupt, and if a mutex is given by the holding task then it must
            be the running state task. */
            configASSERT( pxTCB == pxCurrentTCB );
            configASSERT( pxTCB->uxMutexesHeld );
            ( pxTCB->uxMutexesHeld )--;
    34e2:	82 a1       	ldd	r24, Z+34	; 0x22
    34e4:	81 50       	subi	r24, 0x01	; 1
    34e6:	82 a3       	std	Z+34, r24	; 0x22

            /* Has the holder of the mutex inherited the priority of another
            task? */
            if( pxTCB->uxPriority != pxTCB->uxBasePriority )
    34e8:	26 89       	ldd	r18, Z+22	; 0x16
    34ea:	91 a1       	ldd	r25, Z+33	; 0x21
    34ec:	29 17       	cp	r18, r25
    34ee:	b9 f3       	breq	.-18     	; 0x34de <xTaskPriorityDisinherit+0xe>
            {
                /* Only disinherit if no other mutexes are held. */
                if( pxTCB->uxMutexesHeld == ( UBaseType_t ) 0 )
    34f0:	81 11       	cpse	r24, r1
    34f2:	f5 cf       	rjmp	.-22     	; 0x34de <xTaskPriorityDisinherit+0xe>
    34f4:	ef 01       	movw	r28, r30
                    /* A task can only have an inherited priority if it holds
                    the mutex.  If the mutex is held by a task then it cannot be
                    given from an interrupt, and if a mutex is given by the
                    holding task then it must be the running state task.  Remove
                    the holding task from the ready list. */
                    if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    34f6:	8f 01       	movw	r16, r30
    34f8:	0e 5f       	subi	r16, 0xFE	; 254
    34fa:	1f 4f       	sbci	r17, 0xFF	; 255
    34fc:	c8 01       	movw	r24, r16
    34fe:	0e 94 06 1f 	call	0x3e0c	; 0x3e0c <uxListRemove>
                    }

                    /* Disinherit the priority before adding the task into the
                    new    ready list. */
                    traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
                    pxTCB->uxPriority = pxTCB->uxBasePriority;
    3502:	89 a1       	ldd	r24, Y+33	; 0x21
    3504:	8e 8b       	std	Y+22, r24	; 0x16

                    /* Reset the event list item value.  It cannot be in use for
                    any other purpose if this task is running, and it must be
                    running to give back the mutex. */
                    listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    3506:	48 2f       	mov	r20, r24
    3508:	50 e0       	ldi	r21, 0x00	; 0
    350a:	24 e0       	ldi	r18, 0x04	; 4
    350c:	30 e0       	ldi	r19, 0x00	; 0
    350e:	24 1b       	sub	r18, r20
    3510:	35 0b       	sbc	r19, r21
    3512:	3d 87       	std	Y+13, r19	; 0x0d
    3514:	2c 87       	std	Y+12, r18	; 0x0c
                    prvAddTaskToReadyList( pxTCB );
    3516:	90 91 79 04 	lds	r25, 0x0479	; 0x800479 <uxTopReadyPriority>
    351a:	98 17       	cp	r25, r24
    351c:	10 f4       	brcc	.+4      	; 0x3522 <xTaskPriorityDisinherit+0x52>
    351e:	80 93 79 04 	sts	0x0479, r24	; 0x800479 <uxTopReadyPriority>
    3522:	29 e0       	ldi	r18, 0x09	; 9
    3524:	24 9f       	mul	r18, r20
    3526:	c0 01       	movw	r24, r0
    3528:	25 9f       	mul	r18, r21
    352a:	90 0d       	add	r25, r0
    352c:	11 24       	eor	r1, r1
    352e:	b8 01       	movw	r22, r16
    3530:	81 55       	subi	r24, 0x51	; 81
    3532:	9b 4f       	sbci	r25, 0xFB	; 251
    3534:	0e 94 ad 1e 	call	0x3d5a	; 0x3d5a <vListInsertEnd>
                    in an order different to that in which they were taken.
                    If a context switch did not occur when the first mutex was
                    returned, even if a task was waiting on it, then a context
                    switch should occur when the last mutex is returned whether
                    a task is waiting on it or not. */
                    xReturn = pdTRUE;
    3538:	81 e0       	ldi	r24, 0x01	; 1
        {
            mtCOVERAGE_TEST_MARKER();
        }

        return xReturn;
    }
    353a:	df 91       	pop	r29
    353c:	cf 91       	pop	r28
    353e:	1f 91       	pop	r17
    3540:	0f 91       	pop	r16
    3542:	08 95       	ret

00003544 <prvCheckForValidListAndQueue>:
            pxNewTimer->ucStatus = 0x00;
            prvInitialiseNewTimer( pcTimerName, xTimerPeriodInTicks, uxAutoReload, pvTimerID, pxCallbackFunction, pxNewTimer );
        }

        return pxNewTimer;
    }
    3544:	0f b6       	in	r0, 0x3f	; 63
    3546:	f8 94       	cli
    3548:	0f 92       	push	r0
    354a:	80 91 d9 04 	lds	r24, 0x04D9	; 0x8004d9 <xTimerQueue>
    354e:	90 91 da 04 	lds	r25, 0x04DA	; 0x8004da <xTimerQueue+0x1>
    3552:	89 2b       	or	r24, r25
    3554:	e9 f4       	brne	.+58     	; 0x3590 <prvCheckForValidListAndQueue+0x4c>
    3556:	88 ee       	ldi	r24, 0xE8	; 232
    3558:	94 e0       	ldi	r25, 0x04	; 4
    355a:	0e 94 9b 1e 	call	0x3d36	; 0x3d36 <vListInitialise>
    355e:	8f ed       	ldi	r24, 0xDF	; 223
    3560:	94 e0       	ldi	r25, 0x04	; 4
    3562:	0e 94 9b 1e 	call	0x3d36	; 0x3d36 <vListInitialise>
    3566:	88 ee       	ldi	r24, 0xE8	; 232
    3568:	94 e0       	ldi	r25, 0x04	; 4
    356a:	90 93 de 04 	sts	0x04DE, r25	; 0x8004de <pxCurrentTimerList+0x1>
    356e:	80 93 dd 04 	sts	0x04DD, r24	; 0x8004dd <pxCurrentTimerList>
    3572:	8f ed       	ldi	r24, 0xDF	; 223
    3574:	94 e0       	ldi	r25, 0x04	; 4
    3576:	90 93 dc 04 	sts	0x04DC, r25	; 0x8004dc <pxOverflowTimerList+0x1>
    357a:	80 93 db 04 	sts	0x04DB, r24	; 0x8004db <pxOverflowTimerList>
    357e:	40 e0       	ldi	r20, 0x00	; 0
    3580:	65 e0       	ldi	r22, 0x05	; 5
    3582:	8a e0       	ldi	r24, 0x0A	; 10
    3584:	0e 94 d5 13 	call	0x27aa	; 0x27aa <xQueueGenericCreate>
    3588:	90 93 da 04 	sts	0x04DA, r25	; 0x8004da <xTimerQueue+0x1>
    358c:	80 93 d9 04 	sts	0x04D9, r24	; 0x8004d9 <xTimerQueue>
    3590:	0f 90       	pop	r0
    3592:	0f be       	out	0x3f, r0	; 63
    3594:	08 95       	ret

00003596 <prvInsertTimerInActiveList>:
    3596:	fc 01       	movw	r30, r24
    3598:	73 83       	std	Z+3, r23	; 0x03
    359a:	62 83       	std	Z+2, r22	; 0x02
    359c:	91 87       	std	Z+9, r25	; 0x09
    359e:	80 87       	std	Z+8, r24	; 0x08
    35a0:	46 17       	cp	r20, r22
    35a2:	57 07       	cpc	r21, r23
    35a4:	78 f0       	brcs	.+30     	; 0x35c4 <prvInsertTimerInActiveList+0x2e>
    35a6:	42 1b       	sub	r20, r18
    35a8:	53 0b       	sbc	r21, r19
    35aa:	84 85       	ldd	r24, Z+12	; 0x0c
    35ac:	95 85       	ldd	r25, Z+13	; 0x0d
    35ae:	48 17       	cp	r20, r24
    35b0:	59 07       	cpc	r21, r25
    35b2:	c8 f4       	brcc	.+50     	; 0x35e6 <prvInsertTimerInActiveList+0x50>
    35b4:	bf 01       	movw	r22, r30
    35b6:	6e 5f       	subi	r22, 0xFE	; 254
    35b8:	7f 4f       	sbci	r23, 0xFF	; 255
    35ba:	80 91 db 04 	lds	r24, 0x04DB	; 0x8004db <pxOverflowTimerList>
    35be:	90 91 dc 04 	lds	r25, 0x04DC	; 0x8004dc <pxOverflowTimerList+0x1>
    35c2:	0d c0       	rjmp	.+26     	; 0x35de <prvInsertTimerInActiveList+0x48>
    35c4:	42 17       	cp	r20, r18
    35c6:	53 07       	cpc	r21, r19
    35c8:	18 f4       	brcc	.+6      	; 0x35d0 <prvInsertTimerInActiveList+0x3a>
    35ca:	62 17       	cp	r22, r18
    35cc:	73 07       	cpc	r23, r19
    35ce:	58 f4       	brcc	.+22     	; 0x35e6 <prvInsertTimerInActiveList+0x50>
    35d0:	bf 01       	movw	r22, r30
    35d2:	6e 5f       	subi	r22, 0xFE	; 254
    35d4:	7f 4f       	sbci	r23, 0xFF	; 255
    35d6:	80 91 dd 04 	lds	r24, 0x04DD	; 0x8004dd <pxCurrentTimerList>
    35da:	90 91 de 04 	lds	r25, 0x04DE	; 0x8004de <pxCurrentTimerList+0x1>
    35de:	0e 94 ce 1e 	call	0x3d9c	; 0x3d9c <vListInsert>
    35e2:	80 e0       	ldi	r24, 0x00	; 0
    35e4:	08 95       	ret
    35e6:	81 e0       	ldi	r24, 0x01	; 1
    35e8:	08 95       	ret

000035ea <xTimerCreateTimerTask>:
    35ea:	ef 92       	push	r14
    35ec:	ff 92       	push	r15
    35ee:	0f 93       	push	r16
    35f0:	0e 94 a2 1a 	call	0x3544	; 0x3544 <prvCheckForValidListAndQueue>
    35f4:	80 91 d9 04 	lds	r24, 0x04D9	; 0x8004d9 <xTimerQueue>
    35f8:	90 91 da 04 	lds	r25, 0x04DA	; 0x8004da <xTimerQueue+0x1>
    35fc:	89 2b       	or	r24, r25
    35fe:	81 f0       	breq	.+32     	; 0x3620 <xTimerCreateTimerTask+0x36>
    3600:	87 ed       	ldi	r24, 0xD7	; 215
    3602:	e8 2e       	mov	r14, r24
    3604:	84 e0       	ldi	r24, 0x04	; 4
    3606:	f8 2e       	mov	r15, r24
    3608:	03 e0       	ldi	r16, 0x03	; 3
    360a:	20 e0       	ldi	r18, 0x00	; 0
    360c:	30 e0       	ldi	r19, 0x00	; 0
    360e:	45 e5       	ldi	r20, 0x55	; 85
    3610:	50 e0       	ldi	r21, 0x00	; 0
    3612:	68 e7       	ldi	r22, 0x78	; 120
    3614:	72 e0       	ldi	r23, 0x02	; 2
    3616:	85 ea       	ldi	r24, 0xA5	; 165
    3618:	9b e1       	ldi	r25, 0x1B	; 27
    361a:	0e 94 15 16 	call	0x2c2a	; 0x2c2a <xTaskCreate>
    361e:	01 c0       	rjmp	.+2      	; 0x3622 <xTimerCreateTimerTask+0x38>
    3620:	80 e0       	ldi	r24, 0x00	; 0
    3622:	0f 91       	pop	r16
    3624:	ff 90       	pop	r15
    3626:	ef 90       	pop	r14
    3628:	08 95       	ret

0000362a <xTimerGenericCommand>:
    }
}
/*-----------------------------------------------------------*/

BaseType_t xTimerGenericCommand( TimerHandle_t xTimer, const BaseType_t xCommandID, const TickType_t xOptionalValue, BaseType_t * const pxHigherPriorityTaskWoken, const TickType_t xTicksToWait )
{
    362a:	0f 93       	push	r16
    362c:	1f 93       	push	r17
    362e:	cf 93       	push	r28
    3630:	df 93       	push	r29
    3632:	00 d0       	rcall	.+0      	; 0x3634 <xTimerGenericCommand+0xa>
    3634:	00 d0       	rcall	.+0      	; 0x3636 <xTimerGenericCommand+0xc>
    3636:	1f 92       	push	r1
    3638:	cd b7       	in	r28, 0x3d	; 61
    363a:	de b7       	in	r29, 0x3e	; 62

    configASSERT( xTimer );

    /* Send a message to the timer service task to perform a particular action
    on a particular timer definition. */
    if( xTimerQueue != NULL )
    363c:	a0 91 d9 04 	lds	r26, 0x04D9	; 0x8004d9 <xTimerQueue>
    3640:	b0 91 da 04 	lds	r27, 0x04DA	; 0x8004da <xTimerQueue+0x1>
    3644:	10 97       	sbiw	r26, 0x00	; 0
    3646:	29 f1       	breq	.+74     	; 0x3692 <xTimerGenericCommand+0x68>
    3648:	f9 01       	movw	r30, r18
    {
        /* Send a command to the timer service task to start the xTimer timer. */
        xMessage.xMessageID = xCommandID;
    364a:	69 83       	std	Y+1, r22	; 0x01
        xMessage.u.xTimerParameters.xMessageValue = xOptionalValue;
    364c:	5b 83       	std	Y+3, r21	; 0x03
    364e:	4a 83       	std	Y+2, r20	; 0x02
        xMessage.u.xTimerParameters.pxTimer = xTimer;
    3650:	9d 83       	std	Y+5, r25	; 0x05
    3652:	8c 83       	std	Y+4, r24	; 0x04

        if( xCommandID < tmrFIRST_FROM_ISR_COMMAND )
    3654:	66 30       	cpi	r22, 0x06	; 6
    3656:	a4 f4       	brge	.+40     	; 0x3680 <xTimerGenericCommand+0x56>
        {
            if( xTaskGetSchedulerState() == taskSCHEDULER_RUNNING )
    3658:	0e 94 5a 1a 	call	0x34b4	; 0x34b4 <xTaskGetSchedulerState>
    365c:	e0 91 d9 04 	lds	r30, 0x04D9	; 0x8004d9 <xTimerQueue>
    3660:	f0 91 da 04 	lds	r31, 0x04DA	; 0x8004da <xTimerQueue+0x1>
            {
                xReturn = xQueueSendToBack( xTimerQueue, &xMessage, xTicksToWait );
    3664:	20 e0       	ldi	r18, 0x00	; 0
        xMessage.u.xTimerParameters.xMessageValue = xOptionalValue;
        xMessage.u.xTimerParameters.pxTimer = xTimer;

        if( xCommandID < tmrFIRST_FROM_ISR_COMMAND )
        {
            if( xTaskGetSchedulerState() == taskSCHEDULER_RUNNING )
    3666:	82 30       	cpi	r24, 0x02	; 2
    3668:	11 f4       	brne	.+4      	; 0x366e <xTimerGenericCommand+0x44>
            {
                xReturn = xQueueSendToBack( xTimerQueue, &xMessage, xTicksToWait );
    366a:	a8 01       	movw	r20, r16
    366c:	02 c0       	rjmp	.+4      	; 0x3672 <xTimerGenericCommand+0x48>
            }
            else
            {
                xReturn = xQueueSendToBack( xTimerQueue, &xMessage, tmrNO_DELAY );
    366e:	40 e0       	ldi	r20, 0x00	; 0
    3670:	50 e0       	ldi	r21, 0x00	; 0
    3672:	be 01       	movw	r22, r28
    3674:	6f 5f       	subi	r22, 0xFF	; 255
    3676:	7f 4f       	sbci	r23, 0xFF	; 255
    3678:	cf 01       	movw	r24, r30
    367a:	0e 94 fd 13 	call	0x27fa	; 0x27fa <xQueueGenericSend>
    367e:	0a c0       	rjmp	.+20     	; 0x3694 <xTimerGenericCommand+0x6a>
            }
        }
        else
        {
            xReturn = xQueueSendToBackFromISR( xTimerQueue, &xMessage, pxHigherPriorityTaskWoken );
    3680:	20 e0       	ldi	r18, 0x00	; 0
    3682:	af 01       	movw	r20, r30
    3684:	be 01       	movw	r22, r28
    3686:	6f 5f       	subi	r22, 0xFF	; 255
    3688:	7f 4f       	sbci	r23, 0xFF	; 255
    368a:	cd 01       	movw	r24, r26
    368c:	0e 94 93 14 	call	0x2926	; 0x2926 <xQueueGenericSendFromISR>
    3690:	01 c0       	rjmp	.+2      	; 0x3694 <xTimerGenericCommand+0x6a>
}
/*-----------------------------------------------------------*/

BaseType_t xTimerGenericCommand( TimerHandle_t xTimer, const BaseType_t xCommandID, const TickType_t xOptionalValue, BaseType_t * const pxHigherPriorityTaskWoken, const TickType_t xTicksToWait )
{
BaseType_t xReturn = pdFAIL;
    3692:	80 e0       	ldi	r24, 0x00	; 0
    {
        mtCOVERAGE_TEST_MARKER();
    }

    return xReturn;
}
    3694:	0f 90       	pop	r0
    3696:	0f 90       	pop	r0
    3698:	0f 90       	pop	r0
    369a:	0f 90       	pop	r0
    369c:	0f 90       	pop	r0
    369e:	df 91       	pop	r29
    36a0:	cf 91       	pop	r28
    36a2:	1f 91       	pop	r17
    36a4:	0f 91       	pop	r16
    36a6:	08 95       	ret

000036a8 <prvSwitchTimerLists>:
    }
}
/*-----------------------------------------------------------*/

static void prvSwitchTimerLists( void )
{
    36a8:	ef 92       	push	r14
    36aa:	ff 92       	push	r15
    36ac:	0f 93       	push	r16
    36ae:	1f 93       	push	r17
    36b0:	cf 93       	push	r28
    36b2:	df 93       	push	r29

    /* The tick count has overflowed.  The timer lists must be switched.
    If there are any timers still referenced from the current timer list
    then they must have expired and should be processed before the lists
    are switched. */
    while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
    36b4:	e0 91 dd 04 	lds	r30, 0x04DD	; 0x8004dd <pxCurrentTimerList>
    36b8:	f0 91 de 04 	lds	r31, 0x04DE	; 0x8004de <pxCurrentTimerList+0x1>
    36bc:	80 81       	ld	r24, Z
    36be:	88 23       	and	r24, r24
    36c0:	89 f1       	breq	.+98     	; 0x3724 <prvSwitchTimerLists+0x7c>
    {
        xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
    36c2:	05 80       	ldd	r0, Z+5	; 0x05
    36c4:	f6 81       	ldd	r31, Z+6	; 0x06
    36c6:	e0 2d       	mov	r30, r0
    36c8:	e0 80       	ld	r14, Z
    36ca:	f1 80       	ldd	r15, Z+1	; 0x01

        /* Remove the timer from the list. */
        pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList ); /*lint !e9087 !e9079 void * is used as this macro is used with tasks and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    36cc:	c6 81       	ldd	r28, Z+6	; 0x06
    36ce:	d7 81       	ldd	r29, Z+7	; 0x07
        ( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
    36d0:	8e 01       	movw	r16, r28
    36d2:	0e 5f       	subi	r16, 0xFE	; 254
    36d4:	1f 4f       	sbci	r17, 0xFF	; 255
    36d6:	c8 01       	movw	r24, r16
    36d8:	0e 94 06 1f 	call	0x3e0c	; 0x3e0c <uxListRemove>
        traceTIMER_EXPIRED( pxTimer );

        /* Execute its callback, then send a command to restart the timer if
        it is an auto-reload timer.  It cannot be restarted here as the lists
        have not yet been switched. */
        pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
    36dc:	e8 89       	ldd	r30, Y+16	; 0x10
    36de:	f9 89       	ldd	r31, Y+17	; 0x11
    36e0:	ce 01       	movw	r24, r28
    36e2:	09 95       	icall

        if( ( pxTimer->ucStatus & tmrSTATUS_IS_AUTORELOAD ) != 0 )
    36e4:	8a 89       	ldd	r24, Y+18	; 0x12
    36e6:	82 ff       	sbrs	r24, 2
    36e8:	e5 cf       	rjmp	.-54     	; 0x36b4 <prvSwitchTimerLists+0xc>
            the timer going into the same timer list then it has already expired
            and the timer should be re-inserted into the current list so it is
            processed again within this loop.  Otherwise a command should be sent
            to restart the timer to ensure it is only inserted into a list after
            the lists have been swapped. */
            xReloadTime = ( xNextExpireTime + pxTimer->xTimerPeriodInTicks );
    36ea:	8c 85       	ldd	r24, Y+12	; 0x0c
    36ec:	9d 85       	ldd	r25, Y+13	; 0x0d
    36ee:	8e 0d       	add	r24, r14
    36f0:	9f 1d       	adc	r25, r15
            if( xReloadTime > xNextExpireTime )
    36f2:	e8 16       	cp	r14, r24
    36f4:	f9 06       	cpc	r15, r25
    36f6:	60 f4       	brcc	.+24     	; 0x3710 <prvSwitchTimerLists+0x68>
            {
                listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xReloadTime );
    36f8:	9b 83       	std	Y+3, r25	; 0x03
    36fa:	8a 83       	std	Y+2, r24	; 0x02
                listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
    36fc:	d9 87       	std	Y+9, r29	; 0x09
    36fe:	c8 87       	std	Y+8, r28	; 0x08
                vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
    3700:	b8 01       	movw	r22, r16
    3702:	80 91 dd 04 	lds	r24, 0x04DD	; 0x8004dd <pxCurrentTimerList>
    3706:	90 91 de 04 	lds	r25, 0x04DE	; 0x8004de <pxCurrentTimerList+0x1>
    370a:	0e 94 ce 1e 	call	0x3d9c	; 0x3d9c <vListInsert>
    370e:	d2 cf       	rjmp	.-92     	; 0x36b4 <prvSwitchTimerLists+0xc>
            }
            else
            {
                xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY );
    3710:	00 e0       	ldi	r16, 0x00	; 0
    3712:	10 e0       	ldi	r17, 0x00	; 0
    3714:	20 e0       	ldi	r18, 0x00	; 0
    3716:	30 e0       	ldi	r19, 0x00	; 0
    3718:	a7 01       	movw	r20, r14
    371a:	60 e0       	ldi	r22, 0x00	; 0
    371c:	ce 01       	movw	r24, r28
    371e:	0e 94 15 1b 	call	0x362a	; 0x362a <xTimerGenericCommand>
    3722:	c8 cf       	rjmp	.-112    	; 0x36b4 <prvSwitchTimerLists+0xc>
            mtCOVERAGE_TEST_MARKER();
        }
    }

    pxTemp = pxCurrentTimerList;
    pxCurrentTimerList = pxOverflowTimerList;
    3724:	80 91 db 04 	lds	r24, 0x04DB	; 0x8004db <pxOverflowTimerList>
    3728:	90 91 dc 04 	lds	r25, 0x04DC	; 0x8004dc <pxOverflowTimerList+0x1>
    372c:	90 93 de 04 	sts	0x04DE, r25	; 0x8004de <pxCurrentTimerList+0x1>
    3730:	80 93 dd 04 	sts	0x04DD, r24	; 0x8004dd <pxCurrentTimerList>
    pxOverflowTimerList = pxTemp;
    3734:	f0 93 dc 04 	sts	0x04DC, r31	; 0x8004dc <pxOverflowTimerList+0x1>
    3738:	e0 93 db 04 	sts	0x04DB, r30	; 0x8004db <pxOverflowTimerList>
}
    373c:	df 91       	pop	r29
    373e:	cf 91       	pop	r28
    3740:	1f 91       	pop	r17
    3742:	0f 91       	pop	r16
    3744:	ff 90       	pop	r15
    3746:	ef 90       	pop	r14
    3748:	08 95       	ret

0000374a <prvTimerTask>:
    pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
}
/*-----------------------------------------------------------*/

static portTASK_FUNCTION( prvTimerTask, pvParameters )
{
    374a:	cf 93       	push	r28
    374c:	df 93       	push	r29
    374e:	00 d0       	rcall	.+0      	; 0x3750 <prvTimerTask+0x6>
    3750:	00 d0       	rcall	.+0      	; 0x3752 <prvTimerTask+0x8>
    3752:	1f 92       	push	r1
    3754:	cd b7       	in	r28, 0x3d	; 61
    3756:	de b7       	in	r29, 0x3e	; 62
    the timer with the nearest expiry time will expire.  If there are no
    active timers then just set the next expire time to 0.  That will cause
    this task to unblock when the tick count overflows, at which point the
    timer lists will be switched and the next expiry time can be
    re-assessed.  */
    *pxListWasEmpty = listLIST_IS_EMPTY( pxCurrentTimerList );
    3758:	e0 91 dd 04 	lds	r30, 0x04DD	; 0x8004dd <pxCurrentTimerList>
    375c:	f0 91 de 04 	lds	r31, 0x04DE	; 0x8004de <pxCurrentTimerList+0x1>
    3760:	d0 80       	ld	r13, Z
    if( *pxListWasEmpty == pdFALSE )
    3762:	dd 20       	and	r13, r13
    3764:	31 f0       	breq	.+12     	; 0x3772 <prvTimerTask+0x28>
    {
        xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
    3766:	05 80       	ldd	r0, Z+5	; 0x05
    3768:	f6 81       	ldd	r31, Z+6	; 0x06
    376a:	e0 2d       	mov	r30, r0
    376c:	e0 80       	ld	r14, Z
    376e:	f1 80       	ldd	r15, Z+1	; 0x01
    3770:	02 c0       	rjmp	.+4      	; 0x3776 <prvTimerTask+0x2c>
    }
    else
    {
        /* Ensure the task unblocks when the tick count rolls over. */
        xNextExpireTime = ( TickType_t ) 0U;
    3772:	e1 2c       	mov	r14, r1
    3774:	f1 2c       	mov	r15, r1
static void prvProcessTimerOrBlockTask( const TickType_t xNextExpireTime, BaseType_t xListWasEmpty )
{
TickType_t xTimeNow;
BaseType_t xTimerListsWereSwitched;

    vTaskSuspendAll();
    3776:	0e 94 98 17 	call	0x2f30	; 0x2f30 <vTaskSuspendAll>
static TickType_t prvSampleTimeNow( BaseType_t * const pxTimerListsWereSwitched )
{
TickType_t xTimeNow;
PRIVILEGED_DATA static TickType_t xLastTime = ( TickType_t ) 0U; /*lint !e956 Variable is only accessible to one task. */

    xTimeNow = xTaskGetTickCount();
    377a:	0e 94 9e 17 	call	0x2f3c	; 0x2f3c <xTaskGetTickCount>
    377e:	8c 01       	movw	r16, r24

    if( xTimeNow < xLastTime )
    3780:	80 91 d5 04 	lds	r24, 0x04D5	; 0x8004d5 <xLastTime.2412>
    3784:	90 91 d6 04 	lds	r25, 0x04D6	; 0x8004d6 <xLastTime.2412+0x1>
    3788:	08 17       	cp	r16, r24
    378a:	19 07       	cpc	r17, r25
    378c:	20 f4       	brcc	.+8      	; 0x3796 <prvTimerTask+0x4c>
    {
        prvSwitchTimerLists();
    378e:	0e 94 54 1b 	call	0x36a8	; 0x36a8 <prvSwitchTimerLists>
        *pxTimerListsWereSwitched = pdTRUE;
    3792:	81 e0       	ldi	r24, 0x01	; 1
    3794:	01 c0       	rjmp	.+2      	; 0x3798 <prvTimerTask+0x4e>
    }
    else
    {
        *pxTimerListsWereSwitched = pdFALSE;
    3796:	80 e0       	ldi	r24, 0x00	; 0
    }

    xLastTime = xTimeNow;
    3798:	10 93 d6 04 	sts	0x04D6, r17	; 0x8004d6 <xLastTime.2412+0x1>
    379c:	00 93 d5 04 	sts	0x04D5, r16	; 0x8004d5 <xLastTime.2412>
        has expired or not.  If obtaining the time causes the lists to switch
        then don't process this timer as any timers that remained in the list
        when the lists were switched will have been processed within the
        prvSampleTimeNow() function. */
        xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
        if( xTimerListsWereSwitched == pdFALSE )
    37a0:	81 11       	cpse	r24, r1
    37a2:	55 c0       	rjmp	.+170    	; 0x384e <prvTimerTask+0x104>
        {
            /* The tick count has not overflowed, has the timer expired? */
            if( ( xListWasEmpty == pdFALSE ) && ( xNextExpireTime <= xTimeNow ) )
    37a4:	dd 20       	and	r13, r13
    37a6:	d9 f1       	breq	.+118    	; 0x381e <prvTimerTask+0xd4>
    37a8:	0e 15       	cp	r16, r14
    37aa:	1f 05       	cpc	r17, r15
    37ac:	08 f4       	brcc	.+2      	; 0x37b0 <prvTimerTask+0x66>
    37ae:	3e c0       	rjmp	.+124    	; 0x382c <prvTimerTask+0xe2>
            {
                ( void ) xTaskResumeAll();
    37b0:	0e 94 54 18 	call	0x30a8	; 0x30a8 <xTaskResumeAll>
/*-----------------------------------------------------------*/

static void prvProcessExpiredTimer( const TickType_t xNextExpireTime, const TickType_t xTimeNow )
{
BaseType_t xResult;
Timer_t * const pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList ); /*lint !e9087 !e9079 void * is used as this macro is used with tasks and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    37b4:	e0 91 dd 04 	lds	r30, 0x04DD	; 0x8004dd <pxCurrentTimerList>
    37b8:	f0 91 de 04 	lds	r31, 0x04DE	; 0x8004de <pxCurrentTimerList+0x1>
    37bc:	05 80       	ldd	r0, Z+5	; 0x05
    37be:	f6 81       	ldd	r31, Z+6	; 0x06
    37c0:	e0 2d       	mov	r30, r0
    37c2:	c6 80       	ldd	r12, Z+6	; 0x06
    37c4:	d7 80       	ldd	r13, Z+7	; 0x07

    /* Remove the timer from the list of active timers.  A check has already
    been performed to ensure the list is not empty. */
    ( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
    37c6:	c6 01       	movw	r24, r12
    37c8:	02 96       	adiw	r24, 0x02	; 2
    37ca:	0e 94 06 1f 	call	0x3e0c	; 0x3e0c <uxListRemove>
    traceTIMER_EXPIRED( pxTimer );

    /* If the timer is an auto reload timer then calculate the next
    expiry time and re-insert the timer in the list of active timers. */
    if( ( pxTimer->ucStatus & tmrSTATUS_IS_AUTORELOAD ) != 0 )
    37ce:	d6 01       	movw	r26, r12
    37d0:	52 96       	adiw	r26, 0x12	; 18
    37d2:	8c 91       	ld	r24, X
    37d4:	52 97       	sbiw	r26, 0x12	; 18
    37d6:	82 ff       	sbrs	r24, 2
    37d8:	17 c0       	rjmp	.+46     	; 0x3808 <prvTimerTask+0xbe>
    {
        /* The timer is inserted into a list using a time relative to anything
        other than the current time.  It will therefore be inserted into the
        correct list relative to the time this task thinks it is now. */
        if( prvInsertTimerInActiveList( pxTimer, ( xNextExpireTime + pxTimer->xTimerPeriodInTicks ), xTimeNow, xNextExpireTime ) != pdFALSE )
    37da:	1c 96       	adiw	r26, 0x0c	; 12
    37dc:	6d 91       	ld	r22, X+
    37de:	7c 91       	ld	r23, X
    37e0:	1d 97       	sbiw	r26, 0x0d	; 13
    37e2:	6e 0d       	add	r22, r14
    37e4:	7f 1d       	adc	r23, r15
    37e6:	97 01       	movw	r18, r14
    37e8:	a8 01       	movw	r20, r16
    37ea:	c6 01       	movw	r24, r12
    37ec:	0e 94 cb 1a 	call	0x3596	; 0x3596 <prvInsertTimerInActiveList>
    37f0:	88 23       	and	r24, r24
    37f2:	69 f0       	breq	.+26     	; 0x380e <prvTimerTask+0xc4>
        {
            /* The timer expired before it was added to the active timer
            list.  Reload it now.  */
            xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY );
    37f4:	00 e0       	ldi	r16, 0x00	; 0
    37f6:	10 e0       	ldi	r17, 0x00	; 0
    37f8:	20 e0       	ldi	r18, 0x00	; 0
    37fa:	30 e0       	ldi	r19, 0x00	; 0
    37fc:	a7 01       	movw	r20, r14
    37fe:	60 e0       	ldi	r22, 0x00	; 0
    3800:	c6 01       	movw	r24, r12
    3802:	0e 94 15 1b 	call	0x362a	; 0x362a <xTimerGenericCommand>
    3806:	03 c0       	rjmp	.+6      	; 0x380e <prvTimerTask+0xc4>
            mtCOVERAGE_TEST_MARKER();
        }
    }
    else
    {
        pxTimer->ucStatus &= ~tmrSTATUS_IS_ACTIVE;
    3808:	8e 7f       	andi	r24, 0xFE	; 254
    380a:	f6 01       	movw	r30, r12
    380c:	82 8b       	std	Z+18, r24	; 0x12
        mtCOVERAGE_TEST_MARKER();
    }

    /* Call the timer callback. */
    pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
    380e:	d6 01       	movw	r26, r12
    3810:	50 96       	adiw	r26, 0x10	; 16
    3812:	ed 91       	ld	r30, X+
    3814:	fc 91       	ld	r31, X
    3816:	51 97       	sbiw	r26, 0x11	; 17
    3818:	c6 01       	movw	r24, r12
    381a:	09 95       	icall
    381c:	1e c0       	rjmp	.+60     	; 0x385a <prvTimerTask+0x110>
                case when the current timer list is empty. */
                if( xListWasEmpty != pdFALSE )
                {
                    /* The current timer list is empty - is the overflow list
                    also empty? */
                    xListWasEmpty = listLIST_IS_EMPTY( pxOverflowTimerList );
    381e:	e0 91 db 04 	lds	r30, 0x04DB	; 0x8004db <pxOverflowTimerList>
    3822:	f0 91 dc 04 	lds	r31, 0x04DC	; 0x8004dc <pxOverflowTimerList+0x1>
    3826:	80 81       	ld	r24, Z
    3828:	41 e0       	ldi	r20, 0x01	; 1
    382a:	81 11       	cpse	r24, r1
        prvSampleTimeNow() function. */
        xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
        if( xTimerListsWereSwitched == pdFALSE )
        {
            /* The tick count has not overflowed, has the timer expired? */
            if( ( xListWasEmpty == pdFALSE ) && ( xNextExpireTime <= xTimeNow ) )
    382c:	40 e0       	ldi	r20, 0x00	; 0
                    /* The current timer list is empty - is the overflow list
                    also empty? */
                    xListWasEmpty = listLIST_IS_EMPTY( pxOverflowTimerList );
                }

                vQueueWaitForMessageRestricted( xTimerQueue, ( xNextExpireTime - xTimeNow ), xListWasEmpty );
    382e:	b7 01       	movw	r22, r14
    3830:	60 1b       	sub	r22, r16
    3832:	71 0b       	sbc	r23, r17
    3834:	80 91 d9 04 	lds	r24, 0x04D9	; 0x8004d9 <xTimerQueue>
    3838:	90 91 da 04 	lds	r25, 0x04DA	; 0x8004da <xTimerQueue+0x1>
    383c:	0e 94 54 15 	call	0x2aa8	; 0x2aa8 <vQueueWaitForMessageRestricted>

                if( xTaskResumeAll() == pdFALSE )
    3840:	0e 94 54 18 	call	0x30a8	; 0x30a8 <xTaskResumeAll>
    3844:	81 11       	cpse	r24, r1
    3846:	09 c0       	rjmp	.+18     	; 0x385a <prvTimerTask+0x110>
                {
                    /* Yield to wait for either a command to arrive, or the
                    block time to expire.  If a command arrived between the
                    critical section being exited and this yield then the yield
                    will not cause the task to block. */
                    portYIELD_WITHIN_API();
    3848:	0e 94 ce 1f 	call	0x3f9c	; 0x3f9c <vPortYield>
    384c:	06 c0       	rjmp	.+12     	; 0x385a <prvTimerTask+0x110>
                }
            }
        }
        else
        {
            ( void ) xTaskResumeAll();
    384e:	0e 94 54 18 	call	0x30a8	; 0x30a8 <xTaskResumeAll>
    3852:	03 c0       	rjmp	.+6      	; 0x385a <prvTimerTask+0x110>
        }
        #endif /* INCLUDE_xTimerPendFunctionCall */

        /* Commands that are positive are timer commands rather than pended
        function calls. */
        if( xMessage.xMessageID >= ( BaseType_t ) 0 )
    3854:	89 81       	ldd	r24, Y+1	; 0x01
    3856:	87 ff       	sbrs	r24, 7
    3858:	0e c0       	rjmp	.+28     	; 0x3876 <prvTimerTask+0x12c>
DaemonTaskMessage_t xMessage;
Timer_t *pxTimer;
BaseType_t xTimerListsWereSwitched, xResult;
TickType_t xTimeNow;

    while( xQueueReceive( xTimerQueue, &xMessage, tmrNO_DELAY ) != pdFAIL ) /*lint !e603 xMessage does not have to be initialised as it is passed out, not in, and it is not used unless xQueueReceive() returns pdTRUE. */
    385a:	40 e0       	ldi	r20, 0x00	; 0
    385c:	50 e0       	ldi	r21, 0x00	; 0
    385e:	be 01       	movw	r22, r28
    3860:	6f 5f       	subi	r22, 0xFF	; 255
    3862:	7f 4f       	sbci	r23, 0xFF	; 255
    3864:	80 91 d9 04 	lds	r24, 0x04D9	; 0x8004d9 <xTimerQueue>
    3868:	90 91 da 04 	lds	r25, 0x04DA	; 0x8004da <xTimerQueue+0x1>
    386c:	0e 94 c2 14 	call	0x2984	; 0x2984 <xQueueReceive>
    3870:	81 11       	cpse	r24, r1
    3872:	f0 cf       	rjmp	.-32     	; 0x3854 <prvTimerTask+0x10a>
    3874:	71 cf       	rjmp	.-286    	; 0x3758 <prvTimerTask+0xe>
        function calls. */
        if( xMessage.xMessageID >= ( BaseType_t ) 0 )
        {
            /* The messages uses the xTimerParameters member to work on a
            software timer. */
            pxTimer = xMessage.u.xTimerParameters.pxTimer;
    3876:	ec 80       	ldd	r14, Y+4	; 0x04
    3878:	fd 80       	ldd	r15, Y+5	; 0x05

        if( listIS_CONTAINED_WITHIN( NULL, &( pxTimer->xTimerListItem ) ) == pdFALSE ) /*lint !e961. The cast is only redundant when NULL is passed into the macro. */
    387a:	f7 01       	movw	r30, r14
    387c:	82 85       	ldd	r24, Z+10	; 0x0a
    387e:	93 85       	ldd	r25, Z+11	; 0x0b
    3880:	89 2b       	or	r24, r25
    3882:	21 f0       	breq	.+8      	; 0x388c <prvTimerTask+0x142>
            {
                /* The timer is in a list, remove it. */
                ( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
    3884:	c7 01       	movw	r24, r14
    3886:	02 96       	adiw	r24, 0x02	; 2
    3888:	0e 94 06 1f 	call	0x3e0c	; 0x3e0c <uxListRemove>
static TickType_t prvSampleTimeNow( BaseType_t * const pxTimerListsWereSwitched )
{
TickType_t xTimeNow;
PRIVILEGED_DATA static TickType_t xLastTime = ( TickType_t ) 0U; /*lint !e956 Variable is only accessible to one task. */

    xTimeNow = xTaskGetTickCount();
    388c:	0e 94 9e 17 	call	0x2f3c	; 0x2f3c <xTaskGetTickCount>
    3890:	6c 01       	movw	r12, r24

    if( xTimeNow < xLastTime )
    3892:	80 91 d5 04 	lds	r24, 0x04D5	; 0x8004d5 <xLastTime.2412>
    3896:	90 91 d6 04 	lds	r25, 0x04D6	; 0x8004d6 <xLastTime.2412+0x1>
    389a:	c8 16       	cp	r12, r24
    389c:	d9 06       	cpc	r13, r25
    389e:	10 f4       	brcc	.+4      	; 0x38a4 <prvTimerTask+0x15a>
    {
        prvSwitchTimerLists();
    38a0:	0e 94 54 1b 	call	0x36a8	; 0x36a8 <prvSwitchTimerLists>
    else
    {
        *pxTimerListsWereSwitched = pdFALSE;
    }

    xLastTime = xTimeNow;
    38a4:	d0 92 d6 04 	sts	0x04D6, r13	; 0x8004d6 <xLastTime.2412+0x1>
    38a8:	c0 92 d5 04 	sts	0x04D5, r12	; 0x8004d5 <xLastTime.2412>
            possibility of a higher priority task adding a message to the message
            queue with a time that is ahead of the timer daemon task (because it
            pre-empted the timer daemon task after the xTimeNow value was set). */
            xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );

            switch( xMessage.xMessageID )
    38ac:	e9 81       	ldd	r30, Y+1	; 0x01
    38ae:	0e 2e       	mov	r0, r30
    38b0:	00 0c       	add	r0, r0
    38b2:	ff 0b       	sbc	r31, r31
    38b4:	ea 30       	cpi	r30, 0x0A	; 10
    38b6:	f1 05       	cpc	r31, r1
    38b8:	80 f6       	brcc	.-96     	; 0x385a <prvTimerTask+0x110>
    38ba:	ec 5c       	subi	r30, 0xCC	; 204
    38bc:	ff 4f       	sbci	r31, 0xFF	; 255
    38be:	d7 01       	movw	r26, r14
    38c0:	52 96       	adiw	r26, 0x12	; 18
    38c2:	8c 91       	ld	r24, X
    38c4:	0c 94 f7 21 	jmp	0x43ee	; 0x43ee <__tablejump2__>
                case tmrCOMMAND_START_FROM_ISR :
                case tmrCOMMAND_RESET :
                case tmrCOMMAND_RESET_FROM_ISR :
                case tmrCOMMAND_START_DONT_TRACE :
                    /* Start or restart a timer. */
                    pxTimer->ucStatus |= tmrSTATUS_IS_ACTIVE;
    38c8:	81 60       	ori	r24, 0x01	; 1
    38ca:	f7 01       	movw	r30, r14
    38cc:	82 8b       	std	Z+18, r24	; 0x12
                    if( prvInsertTimerInActiveList( pxTimer,  xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, xTimeNow, xMessage.u.xTimerParameters.xMessageValue ) != pdFALSE )
    38ce:	2a 81       	ldd	r18, Y+2	; 0x02
    38d0:	3b 81       	ldd	r19, Y+3	; 0x03
    38d2:	64 85       	ldd	r22, Z+12	; 0x0c
    38d4:	75 85       	ldd	r23, Z+13	; 0x0d
    38d6:	62 0f       	add	r22, r18
    38d8:	73 1f       	adc	r23, r19
    38da:	a6 01       	movw	r20, r12
    38dc:	c7 01       	movw	r24, r14
    38de:	0e 94 cb 1a 	call	0x3596	; 0x3596 <prvInsertTimerInActiveList>
    38e2:	88 23       	and	r24, r24
    38e4:	09 f4       	brne	.+2      	; 0x38e8 <prvTimerTask+0x19e>
    38e6:	b9 cf       	rjmp	.-142    	; 0x385a <prvTimerTask+0x110>
                    {
                        /* The timer expired before it was added to the active
                        timer list.  Process it now. */
                        pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
    38e8:	d7 01       	movw	r26, r14
    38ea:	50 96       	adiw	r26, 0x10	; 16
    38ec:	ed 91       	ld	r30, X+
    38ee:	fc 91       	ld	r31, X
    38f0:	51 97       	sbiw	r26, 0x11	; 17
    38f2:	c7 01       	movw	r24, r14
    38f4:	09 95       	icall
                        traceTIMER_EXPIRED( pxTimer );

                        if( ( pxTimer->ucStatus & tmrSTATUS_IS_AUTORELOAD ) != 0 )
    38f6:	f7 01       	movw	r30, r14
    38f8:	82 89       	ldd	r24, Z+18	; 0x12
    38fa:	82 ff       	sbrs	r24, 2
    38fc:	ae cf       	rjmp	.-164    	; 0x385a <prvTimerTask+0x110>
                        {
                            xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, NULL, tmrNO_DELAY );
    38fe:	4a 81       	ldd	r20, Y+2	; 0x02
    3900:	5b 81       	ldd	r21, Y+3	; 0x03
    3902:	84 85       	ldd	r24, Z+12	; 0x0c
    3904:	95 85       	ldd	r25, Z+13	; 0x0d
    3906:	48 0f       	add	r20, r24
    3908:	59 1f       	adc	r21, r25
    390a:	00 e0       	ldi	r16, 0x00	; 0
    390c:	10 e0       	ldi	r17, 0x00	; 0
    390e:	20 e0       	ldi	r18, 0x00	; 0
    3910:	30 e0       	ldi	r19, 0x00	; 0
    3912:	60 e0       	ldi	r22, 0x00	; 0
    3914:	c7 01       	movw	r24, r14
    3916:	0e 94 15 1b 	call	0x362a	; 0x362a <xTimerGenericCommand>
    391a:	9f cf       	rjmp	.-194    	; 0x385a <prvTimerTask+0x110>
                    pxTimer->ucStatus &= ~tmrSTATUS_IS_ACTIVE;
                    break;

                case tmrCOMMAND_CHANGE_PERIOD :
                case tmrCOMMAND_CHANGE_PERIOD_FROM_ISR :
                    pxTimer->ucStatus |= tmrSTATUS_IS_ACTIVE;
    391c:	81 60       	ori	r24, 0x01	; 1
    391e:	f7 01       	movw	r30, r14
    3920:	82 8b       	std	Z+18, r24	; 0x12
                    pxTimer->xTimerPeriodInTicks = xMessage.u.xTimerParameters.xMessageValue;
    3922:	6a 81       	ldd	r22, Y+2	; 0x02
    3924:	7b 81       	ldd	r23, Y+3	; 0x03
    3926:	75 87       	std	Z+13, r23	; 0x0d
    3928:	64 87       	std	Z+12, r22	; 0x0c
                    be longer or shorter than the old one.  The command time is
                    therefore set to the current time, and as the period cannot
                    be zero the next expiry time can only be in the future,
                    meaning (unlike for the xTimerStart() case above) there is
                    no fail case that needs to be handled here. */
                    ( void ) prvInsertTimerInActiveList( pxTimer, ( xTimeNow + pxTimer->xTimerPeriodInTicks ), xTimeNow, xTimeNow );
    392a:	6c 0d       	add	r22, r12
    392c:	7d 1d       	adc	r23, r13
    392e:	96 01       	movw	r18, r12
    3930:	a6 01       	movw	r20, r12
    3932:	c7 01       	movw	r24, r14
    3934:	0e 94 cb 1a 	call	0x3596	; 0x3596 <prvInsertTimerInActiveList>
    3938:	90 cf       	rjmp	.-224    	; 0x385a <prvTimerTask+0x110>
                    #if ( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
                    {
                    /* The timer has already been removed from the active list,
                    just free up the memory if the memory was dynamically
                    allocated. */
                        if( ( pxTimer->ucStatus & tmrSTATUS_IS_STATICALLY_ALLOCATED ) == ( uint8_t ) 0 )
    393a:	81 fd       	sbrc	r24, 1
    393c:	04 c0       	rjmp	.+8      	; 0x3946 <prvTimerTask+0x1fc>
                        {
                            vPortFree( pxTimer );
    393e:	c7 01       	movw	r24, r14
    3940:	0e 94 8a 1e 	call	0x3d14	; 0x3d14 <vPortFree>
    3944:	8a cf       	rjmp	.-236    	; 0x385a <prvTimerTask+0x110>
                        }
                        else
                        {
                            pxTimer->ucStatus &= ~tmrSTATUS_IS_ACTIVE;
    3946:	8e 7f       	andi	r24, 0xFE	; 254
    3948:	d7 01       	movw	r26, r14
    394a:	52 96       	adiw	r26, 0x12	; 18
    394c:	8c 93       	st	X, r24
    394e:	85 cf       	rjmp	.-246    	; 0x385a <prvTimerTask+0x110>

00003950 <initVariant>:
{
#if defined(USBCON)
    USBDevice.attach();
#endif

    setup();        // the normal Arduino setup() function is run here.
    3950:	0e 94 15 07 	call	0xe2a	; 0xe2a <setup>
    vTaskStartScheduler(); // initialise and run the freeRTOS scheduler. Execution should never return here.
    3954:	0e 94 6a 17 	call	0x2ed4	; 0x2ed4 <vTaskStartScheduler>
    3958:	08 95       	ret

0000395a <vApplicationIdleHook>:
 */
void vApplicationIdleHook( void ) __attribute__((weak));

void vApplicationIdleHook( void )
{
    loop();        // the normal Arduino loop() function is run here.
    395a:	0e 94 90 07 	call	0xf20	; 0xf20 <loop>
    if (serialEventRun) serialEventRun();
    395e:	80 eb       	ldi	r24, 0xB0	; 176
    3960:	9c e0       	ldi	r25, 0x0C	; 12
    3962:	89 2b       	or	r24, r25
    3964:	11 f0       	breq	.+4      	; 0x396a <vApplicationIdleHook+0x10>
    3966:	0c 94 b0 0c 	jmp	0x1960	; 0x1960 <_Z14serialEventRunv>
    396a:	08 95       	ret

0000396c <vApplicationMallocFailedHook>:
#elif defined(__AVR_ATmega644P__) || defined(__AVR_ATmega644PA__) || defined(__AVR_ATmega1284P__) || defined(__AVR_ATmega1284PA__) // Seeed Goldilocks with 1284p
    DDRB  |= _BV(DDB7);
    PORTB |= _BV(PORTB7);       // Main (red PB7) LED on. Main LED on.

#elif defined(__AVR_ATmega328P__) || defined(__AVR_ATmega168__) || defined(__AVR_ATmega8__) // assume we're using an Arduino Uno with 328p
    DDRB  |= _BV(DDB5);
    396c:	25 9a       	sbi	0x04, 5	; 4
    PORTB |= _BV(PORTB5);       // Main (red PB5) LED on. Main LED on.
    396e:	2d 9a       	sbi	0x05, 5	; 5
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    3970:	2f ef       	ldi	r18, 0xFF	; 255
    3972:	80 e7       	ldi	r24, 0x70	; 112
    3974:	92 e0       	ldi	r25, 0x02	; 2
    3976:	21 50       	subi	r18, 0x01	; 1
    3978:	80 40       	sbci	r24, 0x00	; 0
    397a:	90 40       	sbci	r25, 0x00	; 0
    397c:	e1 f7       	brne	.-8      	; 0x3976 <vApplicationMallocFailedHook+0xa>
    397e:	00 c0       	rjmp	.+0      	; 0x3980 <vApplicationMallocFailedHook+0x14>
    3980:	00 00       	nop

#elif defined(__AVR_ATmega644P__) || defined(__AVR_ATmega644PA__) || defined(__AVR_ATmega1284P__) || defined(__AVR_ATmega1284PA__) // Seeed Goldilocks with 1284p
        PINB  |= _BV(PINB7);       // Main (red PB7) LED toggle. Main LED fast blink.

#elif defined(__AVR_ATmega328P__) || defined(__AVR_ATmega168__) || defined(__AVR_ATmega8__) // assume we're using an Arduino Uno with 328p
        PINB  |= _BV(PINB5);       // Main (red PB5) LED toggle. Main LED fast blink.
    3982:	1d 9a       	sbi	0x03, 5	; 3
    3984:	f5 cf       	rjmp	.-22     	; 0x3970 <vApplicationMallocFailedHook+0x4>

00003986 <vApplicationStackOverflowHook>:
#elif defined(__AVR_ATmega644P__) || defined(__AVR_ATmega644PA__) || defined(__AVR_ATmega1284P__) || defined(__AVR_ATmega1284PA__) // Seeed Goldilocks with 1284p
    DDRB  |= _BV(DDB7);
    PORTB |= _BV(PORTB7);       // Main (red PB7) LED on. Main LED on.

#elif defined(__AVR_ATmega328P__) || defined(__AVR_ATmega168__) || defined(__AVR_ATmega8__) // assume we're using an Arduino Uno with 328p
    DDRB  |= _BV(DDB5);
    3986:	25 9a       	sbi	0x04, 5	; 4
    PORTB |= _BV(PORTB5);       // Main (red PB5) LED on. Main LED on.
    3988:	2d 9a       	sbi	0x05, 5	; 5
    398a:	2f ef       	ldi	r18, 0xFF	; 255
    398c:	87 ea       	ldi	r24, 0xA7	; 167
    398e:	91 e6       	ldi	r25, 0x61	; 97
    3990:	21 50       	subi	r18, 0x01	; 1
    3992:	80 40       	sbci	r24, 0x00	; 0
    3994:	90 40       	sbci	r25, 0x00	; 0
    3996:	e1 f7       	brne	.-8      	; 0x3990 <vApplicationStackOverflowHook+0xa>
    3998:	00 c0       	rjmp	.+0      	; 0x399a <vApplicationStackOverflowHook+0x14>
    399a:	00 00       	nop

#elif defined(__AVR_ATmega644P__) || defined(__AVR_ATmega644PA__) || defined(__AVR_ATmega1284P__) || defined(__AVR_ATmega1284PA__) // Seeed Goldilocks with 1284p
        PINB  |= _BV(PINB7);       // Main (red PB7) LED toggle. Main LED slow blink.

#elif defined(__AVR_ATmega328P__) || defined(__AVR_ATmega168__) || defined(__AVR_ATmega8__) // assume we're using an Arduino Uno with 328p
        PINB  |= _BV(PINB5);       // Main (red PB5) LED toggle. Main LED slow blink.
    399c:	1d 9a       	sbi	0x03, 5	; 3
    399e:	f5 cf       	rjmp	.-22     	; 0x398a <vApplicationStackOverflowHook+0x4>

000039a0 <_ZN9MD_TCS23010initialiseEv>:
  }
  FreqCount.end();      // stop
  DUMP("VALUE ", FreqCount.read());

  return(FreqCount.read() * _readDiv);
}
    39a0:	0f 93       	push	r16
    39a2:	1f 93       	push	r17
    39a4:	fc 01       	movw	r30, r24
    39a6:	8f ef       	ldi	r24, 0xFF	; 255
    39a8:	80 83       	st	Z, r24
    39aa:	81 83       	std	Z+1, r24	; 0x01
    39ac:	82 83       	std	Z+2, r24	; 0x02
    39ae:	83 83       	std	Z+3, r24	; 0x03
    39b0:	84 83       	std	Z+4, r24	; 0x04
    39b2:	8a e0       	ldi	r24, 0x0A	; 10
    39b4:	85 83       	std	Z+5, r24	; 0x05
    39b6:	16 82       	std	Z+6, r1	; 0x06
    39b8:	df 01       	movw	r26, r30
    39ba:	17 96       	adiw	r26, 0x07	; 7
    39bc:	73 96       	adiw	r30, 0x13	; 19
    39be:	00 e7       	ldi	r16, 0x70	; 112
    39c0:	17 e1       	ldi	r17, 0x17	; 23
    39c2:	20 e0       	ldi	r18, 0x00	; 0
    39c4:	30 e0       	ldi	r19, 0x00	; 0
    39c6:	48 ed       	ldi	r20, 0xD8	; 216
    39c8:	56 ed       	ldi	r21, 0xD6	; 214
    39ca:	60 e0       	ldi	r22, 0x00	; 0
    39cc:	70 e0       	ldi	r23, 0x00	; 0
    39ce:	0d 93       	st	X+, r16
    39d0:	1d 93       	st	X+, r17
    39d2:	2d 93       	st	X+, r18
    39d4:	3d 93       	st	X+, r19
    39d6:	18 96       	adiw	r26, 0x08	; 8
    39d8:	4d 93       	st	X+, r20
    39da:	5d 93       	st	X+, r21
    39dc:	6d 93       	st	X+, r22
    39de:	7c 93       	st	X, r23
    39e0:	1b 97       	sbiw	r26, 0x0b	; 11
    39e2:	ae 17       	cp	r26, r30
    39e4:	bf 07       	cpc	r27, r31
    39e6:	99 f7       	brne	.-26     	; 0x39ce <_ZN9MD_TCS23010initialiseEv+0x2e>
    39e8:	1f 91       	pop	r17
    39ea:	0f 91       	pop	r16
    39ec:	08 95       	ret

000039ee <_ZN9MD_TCS230C1Ehhh>:
    39ee:	ff 92       	push	r15
    39f0:	0f 93       	push	r16
    39f2:	1f 93       	push	r17
    39f4:	cf 93       	push	r28
    39f6:	df 93       	push	r29
    39f8:	ec 01       	movw	r28, r24
    39fa:	f6 2e       	mov	r15, r22
    39fc:	04 2f       	mov	r16, r20
    39fe:	12 2f       	mov	r17, r18
    3a00:	0e 94 d0 1c 	call	0x39a0	; 0x39a0 <_ZN9MD_TCS23010initialiseEv>
    3a04:	fb 82       	std	Y+3, r15	; 0x03
    3a06:	0c 83       	std	Y+4, r16	; 0x04
    3a08:	18 83       	st	Y, r17
    3a0a:	df 91       	pop	r29
    3a0c:	cf 91       	pop	r28
    3a0e:	1f 91       	pop	r17
    3a10:	0f 91       	pop	r16
    3a12:	ff 90       	pop	r15
    3a14:	08 95       	ret

00003a16 <_ZN9MD_TCS230D1Ev>:
    3a16:	08 95       	ret

00003a18 <_ZN9MD_TCS2309setFilterEh>:
    3a18:	cf 93       	push	r28
    3a1a:	df 93       	push	r29
    3a1c:	ec 01       	movw	r28, r24
    3a1e:	8b 81       	ldd	r24, Y+3	; 0x03
    3a20:	8f 3f       	cpi	r24, 0xFF	; 255
    3a22:	e9 f0       	breq	.+58     	; 0x3a5e <_ZN9MD_TCS2309setFilterEh+0x46>
    3a24:	9c 81       	ldd	r25, Y+4	; 0x04
    3a26:	9f 3f       	cpi	r25, 0xFF	; 255
    3a28:	d1 f0       	breq	.+52     	; 0x3a5e <_ZN9MD_TCS2309setFilterEh+0x46>
    3a2a:	61 30       	cpi	r22, 0x01	; 1
    3a2c:	49 f0       	breq	.+18     	; 0x3a40 <_ZN9MD_TCS2309setFilterEh+0x28>
    3a2e:	30 f0       	brcs	.+12     	; 0x3a3c <_ZN9MD_TCS2309setFilterEh+0x24>
    3a30:	62 30       	cpi	r22, 0x02	; 2
    3a32:	41 f0       	breq	.+16     	; 0x3a44 <_ZN9MD_TCS2309setFilterEh+0x2c>
    3a34:	63 30       	cpi	r22, 0x03	; 3
    3a36:	99 f4       	brne	.+38     	; 0x3a5e <_ZN9MD_TCS2309setFilterEh+0x46>
    3a38:	61 e0       	ldi	r22, 0x01	; 1
    3a3a:	09 c0       	rjmp	.+18     	; 0x3a4e <_ZN9MD_TCS2309setFilterEh+0x36>
    3a3c:	60 e0       	ldi	r22, 0x00	; 0
    3a3e:	07 c0       	rjmp	.+14     	; 0x3a4e <_ZN9MD_TCS2309setFilterEh+0x36>
    3a40:	61 e0       	ldi	r22, 0x01	; 1
    3a42:	01 c0       	rjmp	.+2      	; 0x3a46 <_ZN9MD_TCS2309setFilterEh+0x2e>
    3a44:	60 e0       	ldi	r22, 0x00	; 0
    3a46:	0e 94 b1 12 	call	0x2562	; 0x2562 <digitalWrite>
    3a4a:	61 e0       	ldi	r22, 0x01	; 1
    3a4c:	03 c0       	rjmp	.+6      	; 0x3a54 <_ZN9MD_TCS2309setFilterEh+0x3c>
    3a4e:	0e 94 b1 12 	call	0x2562	; 0x2562 <digitalWrite>
    3a52:	60 e0       	ldi	r22, 0x00	; 0
    3a54:	8c 81       	ldd	r24, Y+4	; 0x04
    3a56:	df 91       	pop	r29
    3a58:	cf 91       	pop	r28
    3a5a:	0c 94 b1 12 	jmp	0x2562	; 0x2562 <digitalWrite>
    3a5e:	df 91       	pop	r29
    3a60:	cf 91       	pop	r28
    3a62:	08 95       	ret

00003a64 <_ZN9MD_TCS23013setFrequency2Eh>:
    3a64:	cf 93       	push	r28
    3a66:	df 93       	push	r29
    3a68:	ec 01       	movw	r28, r24
    3a6a:	89 81       	ldd	r24, Y+1	; 0x01
    3a6c:	8f 3f       	cpi	r24, 0xFF	; 255
    3a6e:	e9 f0       	breq	.+58     	; 0x3aaa <_ZN9MD_TCS23013setFrequency2Eh+0x46>
    3a70:	9a 81       	ldd	r25, Y+2	; 0x02
    3a72:	9f 3f       	cpi	r25, 0xFF	; 255
    3a74:	d1 f0       	breq	.+52     	; 0x3aaa <_ZN9MD_TCS23013setFrequency2Eh+0x46>
    3a76:	61 30       	cpi	r22, 0x01	; 1
    3a78:	49 f0       	breq	.+18     	; 0x3a8c <_ZN9MD_TCS23013setFrequency2Eh+0x28>
    3a7a:	30 f0       	brcs	.+12     	; 0x3a88 <_ZN9MD_TCS23013setFrequency2Eh+0x24>
    3a7c:	62 30       	cpi	r22, 0x02	; 2
    3a7e:	41 f0       	breq	.+16     	; 0x3a90 <_ZN9MD_TCS23013setFrequency2Eh+0x2c>
    3a80:	63 30       	cpi	r22, 0x03	; 3
    3a82:	99 f4       	brne	.+38     	; 0x3aaa <_ZN9MD_TCS23013setFrequency2Eh+0x46>
    3a84:	60 e0       	ldi	r22, 0x00	; 0
    3a86:	09 c0       	rjmp	.+18     	; 0x3a9a <_ZN9MD_TCS23013setFrequency2Eh+0x36>
    3a88:	61 e0       	ldi	r22, 0x01	; 1
    3a8a:	03 c0       	rjmp	.+6      	; 0x3a92 <_ZN9MD_TCS23013setFrequency2Eh+0x2e>
    3a8c:	61 e0       	ldi	r22, 0x01	; 1
    3a8e:	05 c0       	rjmp	.+10     	; 0x3a9a <_ZN9MD_TCS23013setFrequency2Eh+0x36>
    3a90:	60 e0       	ldi	r22, 0x00	; 0
    3a92:	0e 94 b1 12 	call	0x2562	; 0x2562 <digitalWrite>
    3a96:	61 e0       	ldi	r22, 0x01	; 1
    3a98:	03 c0       	rjmp	.+6      	; 0x3aa0 <_ZN9MD_TCS23013setFrequency2Eh+0x3c>
    3a9a:	0e 94 b1 12 	call	0x2562	; 0x2562 <digitalWrite>
    3a9e:	60 e0       	ldi	r22, 0x00	; 0
    3aa0:	8a 81       	ldd	r24, Y+2	; 0x02
    3aa2:	df 91       	pop	r29
    3aa4:	cf 91       	pop	r28
    3aa6:	0c 94 b1 12 	jmp	0x2562	; 0x2562 <digitalWrite>
    3aaa:	df 91       	pop	r29
    3aac:	cf 91       	pop	r28
    3aae:	08 95       	ret

00003ab0 <_ZN9MD_TCS2309setEnableEb>:
    3ab0:	fc 01       	movw	r30, r24
    3ab2:	20 81       	ld	r18, Z
    3ab4:	2f 3f       	cpi	r18, 0xFF	; 255
    3ab6:	29 f0       	breq	.+10     	; 0x3ac2 <_ZN9MD_TCS2309setEnableEb+0x12>
    3ab8:	91 e0       	ldi	r25, 0x01	; 1
    3aba:	69 27       	eor	r22, r25
    3abc:	82 2f       	mov	r24, r18
    3abe:	0c 94 b1 12 	jmp	0x2562	; 0x2562 <digitalWrite>
    3ac2:	66 23       	and	r22, r22
    3ac4:	19 f0       	breq	.+6      	; 0x3acc <_ZN9MD_TCS2309setEnableEb+0x1c>
    3ac6:	fc 01       	movw	r30, r24
    3ac8:	66 81       	ldd	r22, Z+6	; 0x06
    3aca:	01 c0       	rjmp	.+2      	; 0x3ace <_ZN9MD_TCS2309setEnableEb+0x1e>
    3acc:	63 e0       	ldi	r22, 0x03	; 3
    3ace:	0c 94 32 1d 	jmp	0x3a64	; 0x3a64 <_ZN9MD_TCS23013setFrequency2Eh>

00003ad2 <_ZN9MD_TCS2305beginEv>:
    3ad2:	cf 93       	push	r28
    3ad4:	df 93       	push	r29
    3ad6:	ec 01       	movw	r28, r24
    3ad8:	89 81       	ldd	r24, Y+1	; 0x01
    3ada:	8f 3f       	cpi	r24, 0xFF	; 255
    3adc:	19 f0       	breq	.+6      	; 0x3ae4 <_ZN9MD_TCS2305beginEv+0x12>
    3ade:	61 e0       	ldi	r22, 0x01	; 1
    3ae0:	0e 94 75 12 	call	0x24ea	; 0x24ea <pinMode>
    3ae4:	8a 81       	ldd	r24, Y+2	; 0x02
    3ae6:	8f 3f       	cpi	r24, 0xFF	; 255
    3ae8:	19 f0       	breq	.+6      	; 0x3af0 <_ZN9MD_TCS2305beginEv+0x1e>
    3aea:	61 e0       	ldi	r22, 0x01	; 1
    3aec:	0e 94 75 12 	call	0x24ea	; 0x24ea <pinMode>
    3af0:	8b 81       	ldd	r24, Y+3	; 0x03
    3af2:	8f 3f       	cpi	r24, 0xFF	; 255
    3af4:	19 f0       	breq	.+6      	; 0x3afc <_ZN9MD_TCS2305beginEv+0x2a>
    3af6:	61 e0       	ldi	r22, 0x01	; 1
    3af8:	0e 94 75 12 	call	0x24ea	; 0x24ea <pinMode>
    3afc:	8c 81       	ldd	r24, Y+4	; 0x04
    3afe:	8f 3f       	cpi	r24, 0xFF	; 255
    3b00:	19 f0       	breq	.+6      	; 0x3b08 <_ZN9MD_TCS2305beginEv+0x36>
    3b02:	61 e0       	ldi	r22, 0x01	; 1
    3b04:	0e 94 75 12 	call	0x24ea	; 0x24ea <pinMode>
    3b08:	88 81       	ld	r24, Y
    3b0a:	8f 3f       	cpi	r24, 0xFF	; 255
    3b0c:	19 f0       	breq	.+6      	; 0x3b14 <_ZN9MD_TCS2305beginEv+0x42>
    3b0e:	61 e0       	ldi	r22, 0x01	; 1
    3b10:	0e 94 75 12 	call	0x24ea	; 0x24ea <pinMode>
    3b14:	60 e0       	ldi	r22, 0x00	; 0
    3b16:	ce 01       	movw	r24, r28
    3b18:	0e 94 58 1d 	call	0x3ab0	; 0x3ab0 <_ZN9MD_TCS2309setEnableEb>
    3b1c:	6e 81       	ldd	r22, Y+6	; 0x06
    3b1e:	ce 01       	movw	r24, r28
    3b20:	df 91       	pop	r29
    3b22:	cf 91       	pop	r28
    3b24:	0c 94 32 1d 	jmp	0x3a64	; 0x3a64 <_ZN9MD_TCS23013setFrequency2Eh>

00003b28 <_ZN9MD_TCS2306getRGBEP9colorData>:
    3b28:	dc 01       	movw	r26, r24
    3b2a:	fb 01       	movw	r30, r22
    3b2c:	30 97       	sbiw	r30, 0x00	; 0
    3b2e:	59 f0       	breq	.+22     	; 0x3b46 <_ZN9MD_TCS2306getRGBEP9colorData+0x1e>
    3b30:	9b 96       	adiw	r26, 0x2b	; 43
    3b32:	8c 91       	ld	r24, X
    3b34:	9b 97       	sbiw	r26, 0x2b	; 43
    3b36:	80 83       	st	Z, r24
    3b38:	9c 96       	adiw	r26, 0x2c	; 44
    3b3a:	8c 91       	ld	r24, X
    3b3c:	9c 97       	sbiw	r26, 0x2c	; 44
    3b3e:	81 83       	std	Z+1, r24	; 0x01
    3b40:	9d 96       	adiw	r26, 0x2d	; 45
    3b42:	8c 91       	ld	r24, X
    3b44:	82 83       	std	Z+2, r24	; 0x02
    3b46:	08 95       	ret

00003b48 <_ZN9MD_TCS23017RGBTransformationEv>:
  return(s);
}

void MD_TCS230::RGBTransformation(void)
// Exploiting linear relationship to remap the range 
{
    3b48:	4f 92       	push	r4
    3b4a:	5f 92       	push	r5
    3b4c:	6f 92       	push	r6
    3b4e:	7f 92       	push	r7
    3b50:	8f 92       	push	r8
    3b52:	9f 92       	push	r9
    3b54:	af 92       	push	r10
    3b56:	bf 92       	push	r11
    3b58:	df 92       	push	r13
    3b5a:	ef 92       	push	r14
    3b5c:	ff 92       	push	r15
    3b5e:	0f 93       	push	r16
    3b60:	1f 93       	push	r17
    3b62:	cf 93       	push	r28
    3b64:	df 93       	push	r29
    3b66:	8c 01       	movw	r16, r24
    3b68:	09 5f       	subi	r16, 0xF9	; 249
    3b6a:	1f 4f       	sbci	r17, 0xFF	; 255
    3b6c:	ec 01       	movw	r28, r24
    3b6e:	7c 01       	movw	r14, r24
    3b70:	83 e1       	ldi	r24, 0x13	; 19
    3b72:	e8 0e       	add	r14, r24
    3b74:	f1 1c       	adc	r15, r1
    x = (_Fo.value[i] - _Fd.value[i]) * 255;
    x /= (_Fw.value[i] - _Fd.value[i]);

    // copy results back into the global structures
    if (x < 0) _rgb.value[i] = 0; 
    else if (x > 255) _rgb.value[i] = 255;
    3b76:	dd 24       	eor	r13, r13
    3b78:	da 94       	dec	r13
    3b7a:	f8 01       	movw	r30, r16
{
  int32_t x;

  for (uint8_t i=0; i<RGB_SIZE; i++)
  {
    x = (_Fo.value[i] - _Fd.value[i]) * 255;
    3b7c:	d8 01       	movw	r26, r16
    3b7e:	8d 90       	ld	r8, X+
    3b80:	9d 90       	ld	r9, X+
    3b82:	ad 90       	ld	r10, X+
    3b84:	bd 90       	ld	r11, X+
    3b86:	8d 01       	movw	r16, r26
    3b88:	80 8d       	ldd	r24, Z+24	; 0x18
    3b8a:	91 8d       	ldd	r25, Z+25	; 0x19
    3b8c:	a2 8d       	ldd	r26, Z+26	; 0x1a
    3b8e:	b3 8d       	ldd	r27, Z+27	; 0x1b
    3b90:	9c 01       	movw	r18, r24
    3b92:	ad 01       	movw	r20, r26
    3b94:	28 19       	sub	r18, r8
    3b96:	39 09       	sbc	r19, r9
    3b98:	4a 09       	sbc	r20, r10
    3b9a:	5b 09       	sbc	r21, r11
    3b9c:	af ef       	ldi	r26, 0xFF	; 255
    3b9e:	b0 e0       	ldi	r27, 0x00	; 0
    3ba0:	0e 94 fd 21 	call	0x43fa	; 0x43fa <__muluhisi3>
    x /= (_Fw.value[i] - _Fd.value[i]);
    3ba4:	f8 01       	movw	r30, r16
    3ba6:	40 84       	ldd	r4, Z+8	; 0x08
    3ba8:	51 84       	ldd	r5, Z+9	; 0x09
    3baa:	62 84       	ldd	r6, Z+10	; 0x0a
    3bac:	73 84       	ldd	r7, Z+11	; 0x0b
    3bae:	a3 01       	movw	r20, r6
    3bb0:	92 01       	movw	r18, r4
    3bb2:	28 19       	sub	r18, r8
    3bb4:	39 09       	sbc	r19, r9
    3bb6:	4a 09       	sbc	r20, r10
    3bb8:	5b 09       	sbc	r21, r11
    3bba:	0e 94 d8 21 	call	0x43b0	; 0x43b0 <__divmodsi4>

    // copy results back into the global structures
    if (x < 0) _rgb.value[i] = 0; 
    3bbe:	57 ff       	sbrs	r21, 7
    3bc0:	02 c0       	rjmp	.+4      	; 0x3bc6 <_ZN9MD_TCS23017RGBTransformationEv+0x7e>
    3bc2:	1b a6       	std	Y+43, r1	; 0x2b
    3bc4:	09 c0       	rjmp	.+18     	; 0x3bd8 <_ZN9MD_TCS23017RGBTransformationEv+0x90>
    else if (x > 255) _rgb.value[i] = 255;
    3bc6:	2f 3f       	cpi	r18, 0xFF	; 255
    3bc8:	31 05       	cpc	r19, r1
    3bca:	41 05       	cpc	r20, r1
    3bcc:	51 05       	cpc	r21, r1
    3bce:	19 f0       	breq	.+6      	; 0x3bd6 <_ZN9MD_TCS23017RGBTransformationEv+0x8e>
    3bd0:	14 f0       	brlt	.+4      	; 0x3bd6 <_ZN9MD_TCS23017RGBTransformationEv+0x8e>
    3bd2:	db a6       	std	Y+43, r13	; 0x2b
    3bd4:	01 c0       	rjmp	.+2      	; 0x3bd8 <_ZN9MD_TCS23017RGBTransformationEv+0x90>
    else _rgb.value[i] = x;
    3bd6:	2b a7       	std	Y+43, r18	; 0x2b
    3bd8:	21 96       	adiw	r28, 0x01	; 1
void MD_TCS230::RGBTransformation(void)
// Exploiting linear relationship to remap the range 
{
  int32_t x;

  for (uint8_t i=0; i<RGB_SIZE; i++)
    3bda:	0e 15       	cp	r16, r14
    3bdc:	1f 05       	cpc	r17, r15
    3bde:	69 f6       	brne	.-102    	; 0x3b7a <_ZN9MD_TCS23017RGBTransformationEv+0x32>
    // copy results back into the global structures
    if (x < 0) _rgb.value[i] = 0; 
    else if (x > 255) _rgb.value[i] = 255;
    else _rgb.value[i] = x;
  }
}
    3be0:	df 91       	pop	r29
    3be2:	cf 91       	pop	r28
    3be4:	1f 91       	pop	r17
    3be6:	0f 91       	pop	r16
    3be8:	ff 90       	pop	r15
    3bea:	ef 90       	pop	r14
    3bec:	df 90       	pop	r13
    3bee:	bf 90       	pop	r11
    3bf0:	af 90       	pop	r10
    3bf2:	9f 90       	pop	r9
    3bf4:	8f 90       	pop	r8
    3bf6:	7f 90       	pop	r7
    3bf8:	6f 90       	pop	r6
    3bfa:	5f 90       	pop	r5
    3bfc:	4f 90       	pop	r4
    3bfe:	08 95       	ret

00003c00 <_ZN9MD_TCS2307readFSMEh>:
  return(_readState == 0);
}

uint8_t MD_TCS230::readFSM(uint8_t s)
// Finite State Machine to read a value (internal function)
{
    3c00:	0f 93       	push	r16
    3c02:	1f 93       	push	r17
    3c04:	cf 93       	push	r28
    3c06:	df 93       	push	r29
    3c08:	8c 01       	movw	r16, r24
    3c0a:	c6 2f       	mov	r28, r22
  static const uint8_t seq[] = { TCS230_RGB_R, TCS230_RGB_G, TCS230_RGB_B };
  static uint8_t       currCol;  // index for seq above

  switch(s)
    3c0c:	61 30       	cpi	r22, 0x01	; 1
    3c0e:	49 f0       	breq	.+18     	; 0x3c22 <_ZN9MD_TCS2307readFSMEh+0x22>
    3c10:	18 f0       	brcs	.+6      	; 0x3c18 <_ZN9MD_TCS2307readFSMEh+0x18>
    3c12:	62 30       	cpi	r22, 0x02	; 2
    3c14:	d9 f0       	breq	.+54     	; 0x3c4c <_ZN9MD_TCS2307readFSMEh+0x4c>
    3c16:	4c c0       	rjmp	.+152    	; 0x3cb0 <_ZN9MD_TCS2307readFSMEh+0xb0>
  {
  case 0: // enable the hardware for reading
    DUMPS("\n0");
    currCol = 0;  // RGB_R but we don't care
    3c18:	10 92 f1 04 	sts	0x04F1, r1	; 0x8004f1 <_ZZN9MD_TCS2307readFSMEhE7currCol>
    setEnable(true);
    3c1c:	61 e0       	ldi	r22, 0x01	; 1
    3c1e:	0e 94 58 1d 	call	0x3ab0	; 0x3ab0 <_ZN9MD_TCS2309setEnableEb>
    s++;
    // fall through to the next state

  case 1: // select a filter and start a reading
    DUMPS("\n1");
    setFilter(seq[currCol]);
    3c22:	e0 91 f1 04 	lds	r30, 0x04F1	; 0x8004f1 <_ZZN9MD_TCS2307readFSMEhE7currCol>
    3c26:	f0 e0       	ldi	r31, 0x00	; 0
    3c28:	e0 58       	subi	r30, 0x80	; 128
    3c2a:	fd 4f       	sbci	r31, 0xFD	; 253
    3c2c:	60 81       	ld	r22, Z
    3c2e:	c8 01       	movw	r24, r16
    3c30:	0e 94 0c 1d 	call	0x3a18	; 0x3a18 <_ZN9MD_TCS2309setFilterEh>
    FreqCount.begin(1000/_readDiv);
    3c34:	f8 01       	movw	r30, r16
    3c36:	65 81       	ldd	r22, Z+5	; 0x05
    3c38:	70 e0       	ldi	r23, 0x00	; 0
    3c3a:	88 ee       	ldi	r24, 0xE8	; 232
    3c3c:	93 e0       	ldi	r25, 0x03	; 3
    3c3e:	0e 94 a2 21 	call	0x4344	; 0x4344 <__divmodhi4>
    3c42:	cb 01       	movw	r24, r22
    3c44:	0e 94 87 20 	call	0x410e	; 0x410e <_ZN14FreqCountClass5beginEj>
    s++;
    3c48:	c2 e0       	ldi	r28, 0x02	; 2
    break;
    3c4a:	32 c0       	rjmp	.+100    	; 0x3cb0 <_ZN9MD_TCS2307readFSMEh+0xb0>

  case 2: // see if a value is available
    DUMPS("2");
    if (FreqCount.available())
    3c4c:	0e 94 ff 20 	call	0x41fe	; 0x41fe <_ZN14FreqCountClass9availableEv>
    3c50:	88 23       	and	r24, r24
    3c52:	71 f1       	breq	.+92     	; 0x3cb0 <_ZN9MD_TCS2307readFSMEh+0xb0>
    {
      DUMP(" VALUE ", FreqCount.read());
      // read the value and save it 
      _Fo.value[seq[currCol++]] = FreqCount.read() * _readDiv;
    3c54:	e0 91 f1 04 	lds	r30, 0x04F1	; 0x8004f1 <_ZZN9MD_TCS2307readFSMEhE7currCol>
    3c58:	81 e0       	ldi	r24, 0x01	; 1
    3c5a:	8e 0f       	add	r24, r30
    3c5c:	80 93 f1 04 	sts	0x04F1, r24	; 0x8004f1 <_ZZN9MD_TCS2307readFSMEhE7currCol>
    3c60:	f0 e0       	ldi	r31, 0x00	; 0
    3c62:	e0 58       	subi	r30, 0x80	; 128
    3c64:	fd 4f       	sbci	r31, 0xFD	; 253
    3c66:	c0 81       	ld	r28, Z
    3c68:	d0 e0       	ldi	r29, 0x00	; 0
    3c6a:	0e 94 02 21 	call	0x4204	; 0x4204 <_ZN14FreqCountClass4readEv>
    3c6e:	9b 01       	movw	r18, r22
    3c70:	ac 01       	movw	r20, r24
    3c72:	cc 0f       	add	r28, r28
    3c74:	dd 1f       	adc	r29, r29
    3c76:	cc 0f       	add	r28, r28
    3c78:	dd 1f       	adc	r29, r29
    3c7a:	c0 0f       	add	r28, r16
    3c7c:	d1 1f       	adc	r29, r17
    3c7e:	f8 01       	movw	r30, r16
    3c80:	a5 81       	ldd	r26, Z+5	; 0x05
    3c82:	b0 e0       	ldi	r27, 0x00	; 0
    3c84:	0e 94 fd 21 	call	0x43fa	; 0x43fa <__muluhisi3>
    3c88:	6f 8f       	std	Y+31, r22	; 0x1f
    3c8a:	78 a3       	std	Y+32, r23	; 0x20
    3c8c:	89 a3       	std	Y+33, r24	; 0x21
    3c8e:	9a a3       	std	Y+34, r25	; 0x22

      if (currCol < RGB_SIZE)
    3c90:	80 91 f1 04 	lds	r24, 0x04F1	; 0x8004f1 <_ZZN9MD_TCS2307readFSMEhE7currCol>
    3c94:	83 30       	cpi	r24, 0x03	; 3
    3c96:	58 f0       	brcs	.+22     	; 0x3cae <_ZN9MD_TCS2307readFSMEh+0xae>
        s--;
      }
      else
      {
        // end this reading session
        FreqCount.end();
    3c98:	0e 94 10 21 	call	0x4220	; 0x4220 <_ZN14FreqCountClass3endEv>
        setEnable(false);
    3c9c:	60 e0       	ldi	r22, 0x00	; 0
    3c9e:	c8 01       	movw	r24, r16
    3ca0:	0e 94 58 1d 	call	0x3ab0	; 0x3ab0 <_ZN9MD_TCS2309setEnableEb>
        RGBTransformation();
    3ca4:	c8 01       	movw	r24, r16
    3ca6:	0e 94 a4 1d 	call	0x3b48	; 0x3b48 <_ZN9MD_TCS23017RGBTransformationEv>
        s = 0;
    3caa:	c0 e0       	ldi	r28, 0x00	; 0
    3cac:	01 c0       	rjmp	.+2      	; 0x3cb0 <_ZN9MD_TCS2307readFSMEh+0xb0>
      _Fo.value[seq[currCol++]] = FreqCount.read() * _readDiv;

      if (currCol < RGB_SIZE)
      {
        // loop around again on next call to available()
        s--;
    3cae:	c1 e0       	ldi	r28, 0x01	; 1
    }
    break;
  }

  return(s);
}
    3cb0:	8c 2f       	mov	r24, r28
    3cb2:	df 91       	pop	r29
    3cb4:	cf 91       	pop	r28
    3cb6:	1f 91       	pop	r17
    3cb8:	0f 91       	pop	r16
    3cba:	08 95       	ret

00003cbc <_ZN9MD_TCS2304readEv>:
  return(FreqCount.read() * _readDiv);
}

void MD_TCS230::read(void)
// initiate the finite state machine for reading a value
{
    3cbc:	cf 93       	push	r28
    3cbe:	df 93       	push	r29
    3cc0:	ec 01       	movw	r28, r24
  _readState = readFSM(0);
    3cc2:	60 e0       	ldi	r22, 0x00	; 0
    3cc4:	0e 94 00 1e 	call	0x3c00	; 0x3c00 <_ZN9MD_TCS2307readFSMEh>
    3cc8:	8e a7       	std	Y+46, r24	; 0x2e
}
    3cca:	df 91       	pop	r29
    3ccc:	cf 91       	pop	r28
    3cce:	08 95       	ret

00003cd0 <_ZN9MD_TCS2309availableEv>:

bool MD_TCS230::available(void)
// check if a value is ready. Called repeatedly until it is!
{
    3cd0:	cf 93       	push	r28
    3cd2:	df 93       	push	r29
    3cd4:	ec 01       	movw	r28, r24
  _readState = readFSM(_readState);
    3cd6:	6e a5       	ldd	r22, Y+46	; 0x2e
    3cd8:	0e 94 00 1e 	call	0x3c00	; 0x3c00 <_ZN9MD_TCS2307readFSMEh>
    3cdc:	98 2f       	mov	r25, r24
    3cde:	8e a7       	std	Y+46, r24	; 0x2e

  return(_readState == 0);
    3ce0:	81 e0       	ldi	r24, 0x01	; 1
    3ce2:	91 11       	cpse	r25, r1
    3ce4:	80 e0       	ldi	r24, 0x00	; 0
}
    3ce6:	df 91       	pop	r29
    3ce8:	cf 91       	pop	r28
    3cea:	08 95       	ret

00003cec <yield>:
 * libraries or sketches that supports cooperative threads.
 *
 * Its defined as a weak symbol and it can be redefined to implement a
 * real cooperative scheduler.
 */
static void __empty() {
    3cec:	08 95       	ret

00003cee <pvPortMalloc>:
#if( configSUPPORT_DYNAMIC_ALLOCATION > 0 )

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
    3cee:	cf 93       	push	r28
    3cf0:	df 93       	push	r29
    3cf2:	ec 01       	movw	r28, r24
void *pvReturn;

    vTaskSuspendAll();
    3cf4:	0e 94 98 17 	call	0x2f30	; 0x2f30 <vTaskSuspendAll>
    {
        pvReturn = malloc( xWantedSize );
    3cf8:	ce 01       	movw	r24, r28
    3cfa:	0e 94 2b 22 	call	0x4456	; 0x4456 <malloc>
    3cfe:	ec 01       	movw	r28, r24
        traceMALLOC( pvReturn, xWantedSize );
    }
    ( void ) xTaskResumeAll();
    3d00:	0e 94 54 18 	call	0x30a8	; 0x30a8 <xTaskResumeAll>

    #if( configUSE_MALLOC_FAILED_HOOK == 1 )
    {
        if( pvReturn == NULL )
    3d04:	20 97       	sbiw	r28, 0x00	; 0
    3d06:	11 f4       	brne	.+4      	; 0x3d0c <pvPortMalloc+0x1e>
        {
            extern void vApplicationMallocFailedHook( void );
            vApplicationMallocFailedHook();
    3d08:	0e 94 b6 1c 	call	0x396c	; 0x396c <vApplicationMallocFailedHook>
        }
    }
    #endif

    return pvReturn;
}
    3d0c:	ce 01       	movw	r24, r28
    3d0e:	df 91       	pop	r29
    3d10:	cf 91       	pop	r28
    3d12:	08 95       	ret

00003d14 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
    3d14:	cf 93       	push	r28
    3d16:	df 93       	push	r29
    if( pv )
    3d18:	00 97       	sbiw	r24, 0x00	; 0
    3d1a:	51 f0       	breq	.+20     	; 0x3d30 <vPortFree+0x1c>
    3d1c:	ec 01       	movw	r28, r24
    {
        vTaskSuspendAll();
    3d1e:	0e 94 98 17 	call	0x2f30	; 0x2f30 <vTaskSuspendAll>
        {
            free( pv );
    3d22:	ce 01       	movw	r24, r28
    3d24:	0e 94 c3 22 	call	0x4586	; 0x4586 <free>
            traceFREE( pv, 0 );
        }
        ( void ) xTaskResumeAll();
    }
}
    3d28:	df 91       	pop	r29
    3d2a:	cf 91       	pop	r28
        vTaskSuspendAll();
        {
            free( pv );
            traceFREE( pv, 0 );
        }
        ( void ) xTaskResumeAll();
    3d2c:	0c 94 54 18 	jmp	0x30a8	; 0x30a8 <xTaskResumeAll>
    }
}
    3d30:	df 91       	pop	r29
    3d32:	cf 91       	pop	r28
    3d34:	08 95       	ret

00003d36 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
    3d36:	fc 01       	movw	r30, r24
    /* The list structure contains a list item which is used to mark the
    end of the list.  To initialise the list the list end is inserted
    as the only list entry. */
    pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );            /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    3d38:	03 96       	adiw	r24, 0x03	; 3
    3d3a:	92 83       	std	Z+2, r25	; 0x02
    3d3c:	81 83       	std	Z+1, r24	; 0x01

    /* The list end value is the highest possible value in the list to
    ensure it remains at the end of the list. */
    pxList->xListEnd.xItemValue = portMAX_DELAY;
    3d3e:	2f ef       	ldi	r18, 0xFF	; 255
    3d40:	3f ef       	ldi	r19, 0xFF	; 255
    3d42:	34 83       	std	Z+4, r19	; 0x04
    3d44:	23 83       	std	Z+3, r18	; 0x03

    /* The list end next and previous pointers point to itself so we know
    when the list is empty. */
    pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );    /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    3d46:	96 83       	std	Z+6, r25	; 0x06
    3d48:	85 83       	std	Z+5, r24	; 0x05
    pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    3d4a:	90 87       	std	Z+8, r25	; 0x08
    3d4c:	87 83       	std	Z+7, r24	; 0x07

    pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
    3d4e:	10 82       	st	Z, r1
    3d50:	08 95       	ret

00003d52 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
    /* Make sure the list item is not recorded as being on a list. */
    pxItem->pxContainer = NULL;
    3d52:	fc 01       	movw	r30, r24
    3d54:	11 86       	std	Z+9, r1	; 0x09
    3d56:	10 86       	std	Z+8, r1	; 0x08
    3d58:	08 95       	ret

00003d5a <vListInsertEnd>:
    listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    3d5a:	cf 93       	push	r28
    3d5c:	df 93       	push	r29
    3d5e:	9c 01       	movw	r18, r24
    3d60:	fb 01       	movw	r30, r22
ListItem_t * const pxIndex = pxList->pxIndex;
    3d62:	dc 01       	movw	r26, r24
    3d64:	11 96       	adiw	r26, 0x01	; 1
    3d66:	cd 91       	ld	r28, X+
    3d68:	dc 91       	ld	r29, X
    3d6a:	12 97       	sbiw	r26, 0x02	; 2
    listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

    /* Insert a new list item into pxList, but rather than sort the list,
    makes the new list item the last item to be removed by a call to
    listGET_OWNER_OF_NEXT_ENTRY(). */
    pxNewListItem->pxNext = pxIndex;
    3d6c:	d3 83       	std	Z+3, r29	; 0x03
    3d6e:	c2 83       	std	Z+2, r28	; 0x02
    pxNewListItem->pxPrevious = pxIndex->pxPrevious;
    3d70:	8c 81       	ldd	r24, Y+4	; 0x04
    3d72:	9d 81       	ldd	r25, Y+5	; 0x05
    3d74:	95 83       	std	Z+5, r25	; 0x05
    3d76:	84 83       	std	Z+4, r24	; 0x04

    /* Only used during decision coverage testing. */
    mtCOVERAGE_TEST_DELAY();

    pxIndex->pxPrevious->pxNext = pxNewListItem;
    3d78:	8c 81       	ldd	r24, Y+4	; 0x04
    3d7a:	9d 81       	ldd	r25, Y+5	; 0x05
    3d7c:	dc 01       	movw	r26, r24
    3d7e:	13 96       	adiw	r26, 0x03	; 3
    3d80:	7c 93       	st	X, r23
    3d82:	6e 93       	st	-X, r22
    3d84:	12 97       	sbiw	r26, 0x02	; 2
    pxIndex->pxPrevious = pxNewListItem;
    3d86:	7d 83       	std	Y+5, r23	; 0x05
    3d88:	6c 83       	std	Y+4, r22	; 0x04

    /* Remember which list the item is in. */
    pxNewListItem->pxContainer = pxList;
    3d8a:	31 87       	std	Z+9, r19	; 0x09
    3d8c:	20 87       	std	Z+8, r18	; 0x08

    ( pxList->uxNumberOfItems )++;
    3d8e:	f9 01       	movw	r30, r18
    3d90:	80 81       	ld	r24, Z
    3d92:	8f 5f       	subi	r24, 0xFF	; 255
    3d94:	80 83       	st	Z, r24
}
    3d96:	df 91       	pop	r29
    3d98:	cf 91       	pop	r28
    3d9a:	08 95       	ret

00003d9c <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    3d9c:	0f 93       	push	r16
    3d9e:	1f 93       	push	r17
    3da0:	cf 93       	push	r28
    3da2:	df 93       	push	r29
    3da4:	8c 01       	movw	r16, r24
    3da6:	fb 01       	movw	r30, r22
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
    3da8:	80 81       	ld	r24, Z
    3daa:	91 81       	ldd	r25, Z+1	; 0x01
    new list item should be placed after it.  This ensures that TCBs which are
    stored in ready lists (all of which have the same xItemValue value) get a
    share of the CPU.  However, if the xItemValue is the same as the back marker
    the iteration loop below will not end.  Therefore the value is checked
    first, and the algorithm slightly modified if necessary. */
    if( xValueOfInsertion == portMAX_DELAY )
    3dac:	8f 3f       	cpi	r24, 0xFF	; 255
    3dae:	2f ef       	ldi	r18, 0xFF	; 255
    3db0:	92 07       	cpc	r25, r18
    3db2:	21 f4       	brne	.+8      	; 0x3dbc <vListInsert+0x20>
    {
        pxIterator = pxList->xListEnd.pxPrevious;
    3db4:	e8 01       	movw	r28, r16
    3db6:	af 81       	ldd	r26, Y+7	; 0x07
    3db8:	b8 85       	ldd	r27, Y+8	; 0x08
    3dba:	0e c0       	rjmp	.+28     	; 0x3dd8 <vListInsert+0x3c>
            4) Using a queue or semaphore before it has been initialised or
               before the scheduler has been started (are interrupts firing
               before vTaskStartScheduler() has been called?).
        **********************************************************************/

        for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. *//*lint !e440 The iterator moves to a different value, not xValueOfInsertion. */
    3dbc:	d8 01       	movw	r26, r16
    3dbe:	13 96       	adiw	r26, 0x03	; 3
    3dc0:	12 96       	adiw	r26, 0x02	; 2
    3dc2:	2d 91       	ld	r18, X+
    3dc4:	3c 91       	ld	r19, X
    3dc6:	13 97       	sbiw	r26, 0x03	; 3
    3dc8:	e9 01       	movw	r28, r18
    3dca:	48 81       	ld	r20, Y
    3dcc:	59 81       	ldd	r21, Y+1	; 0x01
    3dce:	84 17       	cp	r24, r20
    3dd0:	95 07       	cpc	r25, r21
    3dd2:	10 f0       	brcs	.+4      	; 0x3dd8 <vListInsert+0x3c>
    3dd4:	d9 01       	movw	r26, r18
    3dd6:	f4 cf       	rjmp	.-24     	; 0x3dc0 <vListInsert+0x24>
            /* There is nothing to do here, just iterating to the wanted
            insertion position. */
        }
    }

    pxNewListItem->pxNext = pxIterator->pxNext;
    3dd8:	12 96       	adiw	r26, 0x02	; 2
    3dda:	8d 91       	ld	r24, X+
    3ddc:	9c 91       	ld	r25, X
    3dde:	13 97       	sbiw	r26, 0x03	; 3
    3de0:	93 83       	std	Z+3, r25	; 0x03
    3de2:	82 83       	std	Z+2, r24	; 0x02
    pxNewListItem->pxNext->pxPrevious = pxNewListItem;
    3de4:	ec 01       	movw	r28, r24
    3de6:	fd 83       	std	Y+5, r31	; 0x05
    3de8:	ec 83       	std	Y+4, r30	; 0x04
    pxNewListItem->pxPrevious = pxIterator;
    3dea:	b5 83       	std	Z+5, r27	; 0x05
    3dec:	a4 83       	std	Z+4, r26	; 0x04
    pxIterator->pxNext = pxNewListItem;
    3dee:	13 96       	adiw	r26, 0x03	; 3
    3df0:	fc 93       	st	X, r31
    3df2:	ee 93       	st	-X, r30
    3df4:	12 97       	sbiw	r26, 0x02	; 2

    /* Remember which list the item is in.  This allows fast removal of the
    item later. */
    pxNewListItem->pxContainer = pxList;
    3df6:	11 87       	std	Z+9, r17	; 0x09
    3df8:	00 87       	std	Z+8, r16	; 0x08

    ( pxList->uxNumberOfItems )++;
    3dfa:	f8 01       	movw	r30, r16
    3dfc:	80 81       	ld	r24, Z
    3dfe:	8f 5f       	subi	r24, 0xFF	; 255
    3e00:	80 83       	st	Z, r24
}
    3e02:	df 91       	pop	r29
    3e04:	cf 91       	pop	r28
    3e06:	1f 91       	pop	r17
    3e08:	0f 91       	pop	r16
    3e0a:	08 95       	ret

00003e0c <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
    3e0c:	cf 93       	push	r28
    3e0e:	df 93       	push	r29
    3e10:	fc 01       	movw	r30, r24
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = pxItemToRemove->pxContainer;
    3e12:	a0 85       	ldd	r26, Z+8	; 0x08
    3e14:	b1 85       	ldd	r27, Z+9	; 0x09

    pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    3e16:	82 81       	ldd	r24, Z+2	; 0x02
    3e18:	93 81       	ldd	r25, Z+3	; 0x03
    3e1a:	24 81       	ldd	r18, Z+4	; 0x04
    3e1c:	35 81       	ldd	r19, Z+5	; 0x05
    3e1e:	ec 01       	movw	r28, r24
    3e20:	3d 83       	std	Y+5, r19	; 0x05
    3e22:	2c 83       	std	Y+4, r18	; 0x04
    pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    3e24:	c4 81       	ldd	r28, Z+4	; 0x04
    3e26:	d5 81       	ldd	r29, Z+5	; 0x05
    3e28:	9b 83       	std	Y+3, r25	; 0x03
    3e2a:	8a 83       	std	Y+2, r24	; 0x02

    /* Only used during decision coverage testing. */
    mtCOVERAGE_TEST_DELAY();

    /* Make sure the index is left pointing to a valid item. */
    if( pxList->pxIndex == pxItemToRemove )
    3e2c:	11 96       	adiw	r26, 0x01	; 1
    3e2e:	8d 91       	ld	r24, X+
    3e30:	9c 91       	ld	r25, X
    3e32:	12 97       	sbiw	r26, 0x02	; 2
    3e34:	e8 17       	cp	r30, r24
    3e36:	f9 07       	cpc	r31, r25
    3e38:	21 f4       	brne	.+8      	; 0x3e42 <uxListRemove+0x36>
    {
        pxList->pxIndex = pxItemToRemove->pxPrevious;
    3e3a:	12 96       	adiw	r26, 0x02	; 2
    3e3c:	dc 93       	st	X, r29
    3e3e:	ce 93       	st	-X, r28
    3e40:	11 97       	sbiw	r26, 0x01	; 1
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }

    pxItemToRemove->pxContainer = NULL;
    3e42:	11 86       	std	Z+9, r1	; 0x09
    3e44:	10 86       	std	Z+8, r1	; 0x08
    ( pxList->uxNumberOfItems )--;
    3e46:	8c 91       	ld	r24, X
    3e48:	81 50       	subi	r24, 0x01	; 1
    3e4a:	8c 93       	st	X, r24

    return pxList->uxNumberOfItems;
    3e4c:	8c 91       	ld	r24, X
}
    3e4e:	df 91       	pop	r29
    3e50:	cf 91       	pop	r28
    3e52:	08 95       	ret

00003e54 <pxPortInitialiseStack>:
		);
	}
	else
	{
        uint8_t register temp_reg;
		__asm__ __volatile__ (
    3e54:	31 e1       	ldi	r19, 0x11	; 17
    3e56:	fc 01       	movw	r30, r24
    3e58:	30 83       	st	Z, r19
    3e5a:	31 97       	sbiw	r30, 0x01	; 1
    3e5c:	22 e2       	ldi	r18, 0x22	; 34
    3e5e:	20 83       	st	Z, r18
    3e60:	31 97       	sbiw	r30, 0x01	; 1
    3e62:	a3 e3       	ldi	r26, 0x33	; 51
    3e64:	a0 83       	st	Z, r26
    3e66:	31 97       	sbiw	r30, 0x01	; 1
    3e68:	60 83       	st	Z, r22
    3e6a:	31 97       	sbiw	r30, 0x01	; 1
    3e6c:	70 83       	st	Z, r23
    3e6e:	31 97       	sbiw	r30, 0x01	; 1
    3e70:	10 82       	st	Z, r1
    3e72:	31 97       	sbiw	r30, 0x01	; 1
    3e74:	60 e8       	ldi	r22, 0x80	; 128
    3e76:	60 83       	st	Z, r22
    3e78:	31 97       	sbiw	r30, 0x01	; 1
    3e7a:	10 82       	st	Z, r1
    3e7c:	31 97       	sbiw	r30, 0x01	; 1
    3e7e:	62 e0       	ldi	r22, 0x02	; 2
    3e80:	60 83       	st	Z, r22
    3e82:	31 97       	sbiw	r30, 0x01	; 1
    3e84:	63 e0       	ldi	r22, 0x03	; 3
    3e86:	60 83       	st	Z, r22
    3e88:	31 97       	sbiw	r30, 0x01	; 1
    3e8a:	64 e0       	ldi	r22, 0x04	; 4
    3e8c:	60 83       	st	Z, r22
    3e8e:	31 97       	sbiw	r30, 0x01	; 1
    3e90:	65 e0       	ldi	r22, 0x05	; 5
    3e92:	60 83       	st	Z, r22
    3e94:	31 97       	sbiw	r30, 0x01	; 1
    3e96:	66 e0       	ldi	r22, 0x06	; 6
    3e98:	60 83       	st	Z, r22
    3e9a:	31 97       	sbiw	r30, 0x01	; 1
    3e9c:	67 e0       	ldi	r22, 0x07	; 7
    3e9e:	60 83       	st	Z, r22
    3ea0:	31 97       	sbiw	r30, 0x01	; 1
    3ea2:	68 e0       	ldi	r22, 0x08	; 8
    3ea4:	60 83       	st	Z, r22
    3ea6:	31 97       	sbiw	r30, 0x01	; 1
    3ea8:	69 e0       	ldi	r22, 0x09	; 9
    3eaa:	60 83       	st	Z, r22
    3eac:	31 97       	sbiw	r30, 0x01	; 1
    3eae:	60 e1       	ldi	r22, 0x10	; 16
    3eb0:	60 83       	st	Z, r22
    3eb2:	31 97       	sbiw	r30, 0x01	; 1
    3eb4:	30 83       	st	Z, r19
    3eb6:	31 97       	sbiw	r30, 0x01	; 1
    3eb8:	32 e1       	ldi	r19, 0x12	; 18
    3eba:	30 83       	st	Z, r19
    3ebc:	31 97       	sbiw	r30, 0x01	; 1
    3ebe:	33 e1       	ldi	r19, 0x13	; 19
    3ec0:	30 83       	st	Z, r19
    3ec2:	31 97       	sbiw	r30, 0x01	; 1
    3ec4:	34 e1       	ldi	r19, 0x14	; 20
    3ec6:	30 83       	st	Z, r19
    3ec8:	31 97       	sbiw	r30, 0x01	; 1
    3eca:	35 e1       	ldi	r19, 0x15	; 21
    3ecc:	30 83       	st	Z, r19
    3ece:	31 97       	sbiw	r30, 0x01	; 1
    3ed0:	36 e1       	ldi	r19, 0x16	; 22
    3ed2:	30 83       	st	Z, r19
    3ed4:	31 97       	sbiw	r30, 0x01	; 1
    3ed6:	37 e1       	ldi	r19, 0x17	; 23
    3ed8:	30 83       	st	Z, r19
    3eda:	31 97       	sbiw	r30, 0x01	; 1
    3edc:	38 e1       	ldi	r19, 0x18	; 24
    3ede:	30 83       	st	Z, r19
    3ee0:	31 97       	sbiw	r30, 0x01	; 1
    3ee2:	39 e1       	ldi	r19, 0x19	; 25
    3ee4:	30 83       	st	Z, r19
    3ee6:	31 97       	sbiw	r30, 0x01	; 1
    3ee8:	30 e2       	ldi	r19, 0x20	; 32
    3eea:	30 83       	st	Z, r19
    3eec:	31 97       	sbiw	r30, 0x01	; 1
    3eee:	31 e2       	ldi	r19, 0x21	; 33
    3ef0:	30 83       	st	Z, r19
    3ef2:	31 97       	sbiw	r30, 0x01	; 1
    3ef4:	20 83       	st	Z, r18
    3ef6:	31 97       	sbiw	r30, 0x01	; 1
    3ef8:	23 e2       	ldi	r18, 0x23	; 35
    3efa:	20 83       	st	Z, r18
    3efc:	31 97       	sbiw	r30, 0x01	; 1
    3efe:	40 83       	st	Z, r20
    3f00:	31 97       	sbiw	r30, 0x01	; 1
    3f02:	50 83       	st	Z, r21
    3f04:	31 97       	sbiw	r30, 0x01	; 1
    3f06:	26 e2       	ldi	r18, 0x26	; 38
    3f08:	20 83       	st	Z, r18
    3f0a:	31 97       	sbiw	r30, 0x01	; 1
    3f0c:	27 e2       	ldi	r18, 0x27	; 39
    3f0e:	20 83       	st	Z, r18
    3f10:	31 97       	sbiw	r30, 0x01	; 1
    3f12:	28 e2       	ldi	r18, 0x28	; 40
    3f14:	20 83       	st	Z, r18
    3f16:	31 97       	sbiw	r30, 0x01	; 1
    3f18:	29 e2       	ldi	r18, 0x29	; 41
    3f1a:	20 83       	st	Z, r18
    3f1c:	31 97       	sbiw	r30, 0x01	; 1
    3f1e:	20 e3       	ldi	r18, 0x30	; 48
    3f20:	20 83       	st	Z, r18
    3f22:	31 97       	sbiw	r30, 0x01	; 1
    3f24:	21 e3       	ldi	r18, 0x31	; 49
    3f26:	20 83       	st	Z, r18
    3f28:	86 97       	sbiw	r24, 0x26	; 38
    3f2a:	08 95       	ret

00003f2c <xPortStartScheduler>:
    3f2c:	a8 95       	wdr
    3f2e:	90 ec       	ldi	r25, 0xC0	; 192
    3f30:	88 e1       	ldi	r24, 0x18	; 24
    3f32:	0f b6       	in	r0, 0x3f	; 63
    3f34:	f8 94       	cli
    3f36:	a8 95       	wdr
    3f38:	80 93 60 00 	sts	0x0060, r24	; 0x800060 <__DATA_REGION_ORIGIN__>
    3f3c:	0f be       	out	0x3f, r0	; 63
    3f3e:	90 93 60 00 	sts	0x0060, r25	; 0x800060 <__DATA_REGION_ORIGIN__>
    3f42:	a0 91 d3 04 	lds	r26, 0x04D3	; 0x8004d3 <pxCurrentTCB>
    3f46:	b0 91 d4 04 	lds	r27, 0x04D4	; 0x8004d4 <pxCurrentTCB+0x1>
    3f4a:	cd 91       	ld	r28, X+
    3f4c:	cd bf       	out	0x3d, r28	; 61
    3f4e:	dd 91       	ld	r29, X+
    3f50:	de bf       	out	0x3e, r29	; 62
    3f52:	ff 91       	pop	r31
    3f54:	ef 91       	pop	r30
    3f56:	df 91       	pop	r29
    3f58:	cf 91       	pop	r28
    3f5a:	bf 91       	pop	r27
    3f5c:	af 91       	pop	r26
    3f5e:	9f 91       	pop	r25
    3f60:	8f 91       	pop	r24
    3f62:	7f 91       	pop	r23
    3f64:	6f 91       	pop	r22
    3f66:	5f 91       	pop	r21
    3f68:	4f 91       	pop	r20
    3f6a:	3f 91       	pop	r19
    3f6c:	2f 91       	pop	r18
    3f6e:	1f 91       	pop	r17
    3f70:	0f 91       	pop	r16
    3f72:	ff 90       	pop	r15
    3f74:	ef 90       	pop	r14
    3f76:	df 90       	pop	r13
    3f78:	cf 90       	pop	r12
    3f7a:	bf 90       	pop	r11
    3f7c:	af 90       	pop	r10
    3f7e:	9f 90       	pop	r9
    3f80:	8f 90       	pop	r8
    3f82:	7f 90       	pop	r7
    3f84:	6f 90       	pop	r6
    3f86:	5f 90       	pop	r5
    3f88:	4f 90       	pop	r4
    3f8a:	3f 90       	pop	r3
    3f8c:	2f 90       	pop	r2
    3f8e:	1f 90       	pop	r1
    3f90:	0f 90       	pop	r0
    3f92:	0f be       	out	0x3f, r0	; 63
    3f94:	0f 90       	pop	r0
    3f96:	08 95       	ret
    3f98:	81 e0       	ldi	r24, 0x01	; 1
    3f9a:	08 95       	ret

00003f9c <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( hot, flatten, naked ) );
void vPortYield( void )
{
    portSAVE_CONTEXT();
    3f9c:	0f 92       	push	r0
    3f9e:	0f b6       	in	r0, 0x3f	; 63
    3fa0:	f8 94       	cli
    3fa2:	0f 92       	push	r0
    3fa4:	1f 92       	push	r1
    3fa6:	11 24       	eor	r1, r1
    3fa8:	2f 92       	push	r2
    3faa:	3f 92       	push	r3
    3fac:	4f 92       	push	r4
    3fae:	5f 92       	push	r5
    3fb0:	6f 92       	push	r6
    3fb2:	7f 92       	push	r7
    3fb4:	8f 92       	push	r8
    3fb6:	9f 92       	push	r9
    3fb8:	af 92       	push	r10
    3fba:	bf 92       	push	r11
    3fbc:	cf 92       	push	r12
    3fbe:	df 92       	push	r13
    3fc0:	ef 92       	push	r14
    3fc2:	ff 92       	push	r15
    3fc4:	0f 93       	push	r16
    3fc6:	1f 93       	push	r17
    3fc8:	2f 93       	push	r18
    3fca:	3f 93       	push	r19
    3fcc:	4f 93       	push	r20
    3fce:	5f 93       	push	r21
    3fd0:	6f 93       	push	r22
    3fd2:	7f 93       	push	r23
    3fd4:	8f 93       	push	r24
    3fd6:	9f 93       	push	r25
    3fd8:	af 93       	push	r26
    3fda:	bf 93       	push	r27
    3fdc:	cf 93       	push	r28
    3fde:	df 93       	push	r29
    3fe0:	ef 93       	push	r30
    3fe2:	ff 93       	push	r31
    3fe4:	a0 91 d3 04 	lds	r26, 0x04D3	; 0x8004d3 <pxCurrentTCB>
    3fe8:	b0 91 d4 04 	lds	r27, 0x04D4	; 0x8004d4 <pxCurrentTCB+0x1>
    3fec:	0d b6       	in	r0, 0x3d	; 61
    3fee:	0d 92       	st	X+, r0
    3ff0:	0e b6       	in	r0, 0x3e	; 62
    3ff2:	0d 92       	st	X+, r0
    vTaskSwitchContext();
    3ff4:	0e 94 fb 18 	call	0x31f6	; 0x31f6 <vTaskSwitchContext>
    portRESTORE_CONTEXT();
    3ff8:	a0 91 d3 04 	lds	r26, 0x04D3	; 0x8004d3 <pxCurrentTCB>
    3ffc:	b0 91 d4 04 	lds	r27, 0x04D4	; 0x8004d4 <pxCurrentTCB+0x1>
    4000:	cd 91       	ld	r28, X+
    4002:	cd bf       	out	0x3d, r28	; 61
    4004:	dd 91       	ld	r29, X+
    4006:	de bf       	out	0x3e, r29	; 62
    4008:	ff 91       	pop	r31
    400a:	ef 91       	pop	r30
    400c:	df 91       	pop	r29
    400e:	cf 91       	pop	r28
    4010:	bf 91       	pop	r27
    4012:	af 91       	pop	r26
    4014:	9f 91       	pop	r25
    4016:	8f 91       	pop	r24
    4018:	7f 91       	pop	r23
    401a:	6f 91       	pop	r22
    401c:	5f 91       	pop	r21
    401e:	4f 91       	pop	r20
    4020:	3f 91       	pop	r19
    4022:	2f 91       	pop	r18
    4024:	1f 91       	pop	r17
    4026:	0f 91       	pop	r16
    4028:	ff 90       	pop	r15
    402a:	ef 90       	pop	r14
    402c:	df 90       	pop	r13
    402e:	cf 90       	pop	r12
    4030:	bf 90       	pop	r11
    4032:	af 90       	pop	r10
    4034:	9f 90       	pop	r9
    4036:	8f 90       	pop	r8
    4038:	7f 90       	pop	r7
    403a:	6f 90       	pop	r6
    403c:	5f 90       	pop	r5
    403e:	4f 90       	pop	r4
    4040:	3f 90       	pop	r3
    4042:	2f 90       	pop	r2
    4044:	1f 90       	pop	r1
    4046:	0f 90       	pop	r0
    4048:	0f be       	out	0x3f, r0	; 63
    404a:	0f 90       	pop	r0

    __asm__ __volatile__ ( "ret" );
    404c:	08 95       	ret

0000404e <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( hot, flatten, naked ) );
void vPortYieldFromTick( void )
{
    portSAVE_CONTEXT();
    404e:	0f 92       	push	r0
    4050:	0f b6       	in	r0, 0x3f	; 63
    4052:	f8 94       	cli
    4054:	0f 92       	push	r0
    4056:	1f 92       	push	r1
    4058:	11 24       	eor	r1, r1
    405a:	2f 92       	push	r2
    405c:	3f 92       	push	r3
    405e:	4f 92       	push	r4
    4060:	5f 92       	push	r5
    4062:	6f 92       	push	r6
    4064:	7f 92       	push	r7
    4066:	8f 92       	push	r8
    4068:	9f 92       	push	r9
    406a:	af 92       	push	r10
    406c:	bf 92       	push	r11
    406e:	cf 92       	push	r12
    4070:	df 92       	push	r13
    4072:	ef 92       	push	r14
    4074:	ff 92       	push	r15
    4076:	0f 93       	push	r16
    4078:	1f 93       	push	r17
    407a:	2f 93       	push	r18
    407c:	3f 93       	push	r19
    407e:	4f 93       	push	r20
    4080:	5f 93       	push	r21
    4082:	6f 93       	push	r22
    4084:	7f 93       	push	r23
    4086:	8f 93       	push	r24
    4088:	9f 93       	push	r25
    408a:	af 93       	push	r26
    408c:	bf 93       	push	r27
    408e:	cf 93       	push	r28
    4090:	df 93       	push	r29
    4092:	ef 93       	push	r30
    4094:	ff 93       	push	r31
    4096:	a0 91 d3 04 	lds	r26, 0x04D3	; 0x8004d3 <pxCurrentTCB>
    409a:	b0 91 d4 04 	lds	r27, 0x04D4	; 0x8004d4 <pxCurrentTCB+0x1>
    409e:	0d b6       	in	r0, 0x3d	; 61
    40a0:	0d 92       	st	X+, r0
    40a2:	0e b6       	in	r0, 0x3e	; 62
    40a4:	0d 92       	st	X+, r0

    sleep_reset();        //     reset the sleep_mode() faster than sleep_disable();
    40a6:	13 be       	out	0x33, r1	; 51

    if( xTaskIncrementTick() != pdFALSE )
    40a8:	0e 94 a8 17 	call	0x2f50	; 0x2f50 <xTaskIncrementTick>
    40ac:	81 11       	cpse	r24, r1
    {
        vTaskSwitchContext();
    40ae:	0e 94 fb 18 	call	0x31f6	; 0x31f6 <vTaskSwitchContext>
    }

    portRESTORE_CONTEXT();
    40b2:	a0 91 d3 04 	lds	r26, 0x04D3	; 0x8004d3 <pxCurrentTCB>
    40b6:	b0 91 d4 04 	lds	r27, 0x04D4	; 0x8004d4 <pxCurrentTCB+0x1>
    40ba:	cd 91       	ld	r28, X+
    40bc:	cd bf       	out	0x3d, r28	; 61
    40be:	dd 91       	ld	r29, X+
    40c0:	de bf       	out	0x3e, r29	; 62
    40c2:	ff 91       	pop	r31
    40c4:	ef 91       	pop	r30
    40c6:	df 91       	pop	r29
    40c8:	cf 91       	pop	r28
    40ca:	bf 91       	pop	r27
    40cc:	af 91       	pop	r26
    40ce:	9f 91       	pop	r25
    40d0:	8f 91       	pop	r24
    40d2:	7f 91       	pop	r23
    40d4:	6f 91       	pop	r22
    40d6:	5f 91       	pop	r21
    40d8:	4f 91       	pop	r20
    40da:	3f 91       	pop	r19
    40dc:	2f 91       	pop	r18
    40de:	1f 91       	pop	r17
    40e0:	0f 91       	pop	r16
    40e2:	ff 90       	pop	r15
    40e4:	ef 90       	pop	r14
    40e6:	df 90       	pop	r13
    40e8:	cf 90       	pop	r12
    40ea:	bf 90       	pop	r11
    40ec:	af 90       	pop	r10
    40ee:	9f 90       	pop	r9
    40f0:	8f 90       	pop	r8
    40f2:	7f 90       	pop	r7
    40f4:	6f 90       	pop	r6
    40f6:	5f 90       	pop	r5
    40f8:	4f 90       	pop	r4
    40fa:	3f 90       	pop	r3
    40fc:	2f 90       	pop	r2
    40fe:	1f 90       	pop	r1
    4100:	0f 90       	pop	r0
    4102:	0f be       	out	0x3f, r0	; 63
    4104:	0f 90       	pop	r0

    __asm__ __volatile__ ( "ret" );
    4106:	08 95       	ret

00004108 <__vector_6>:
     */
    ISR(portSCHEDULER_ISR, ISR_NAKED) __attribute__ ((hot, flatten));
//  ISR(portSCHEDULER_ISR, ISR_NAKED ISR_NOBLOCK) __attribute__ ((hot, flatten));
    ISR(portSCHEDULER_ISR)
    {
        vPortYieldFromTick();
    4108:	0e 94 27 20 	call	0x404e	; 0x404e <vPortYieldFromTick>
        __asm__ __volatile__ ( "reti" );
    410c:	18 95       	reti

0000410e <_ZN14FreqCountClass5beginEj>:
static uint16_t gate_index;


void FreqCountClass::begin(uint16_t msec)
{
	if (msec < 1) return;
    410e:	00 97       	sbiw	r24, 0x00	; 0
    4110:	09 f4       	brne	.+2      	; 0x4114 <_ZN14FreqCountClass5beginEj+0x6>
    4112:	74 c0       	rjmp	.+232    	; 0x41fc <L_130_loop+0xc>
	gate_index = 0;
    4114:	10 92 f3 04 	sts	0x04F3, r1	; 0x8004f3 <_ZL10gate_index+0x1>
    4118:	10 92 f2 04 	sts	0x04F2, r1	; 0x8004f2 <_ZL10gate_index>
	count_msw = 0;
    411c:	10 92 00 05 	sts	0x0500, r1	; 0x800500 <_ZL9count_msw+0x1>
    4120:	10 92 ff 04 	sts	0x04FF, r1	; 0x8004ff <_ZL9count_msw>
	count_prev = 0;
    4124:	10 92 fb 04 	sts	0x04FB, r1	; 0x8004fb <_ZL10count_prev>
    4128:	10 92 fc 04 	sts	0x04FC, r1	; 0x8004fc <_ZL10count_prev+0x1>
    412c:	10 92 fd 04 	sts	0x04FD, r1	; 0x8004fd <_ZL10count_prev+0x2>
    4130:	10 92 fe 04 	sts	0x04FE, r1	; 0x8004fe <_ZL10count_prev+0x3>
	count_ready = 0;
    4134:	10 92 f6 04 	sts	0x04F6, r1	; 0x8004f6 <_ZL11count_ready>

static uint8_t saveTCCR1A, saveTCCR1B;

static inline void counter_init(void)
{
	saveTCCR1A = TCCR1A;
    4138:	20 91 80 00 	lds	r18, 0x0080	; 0x800080 <__DATA_REGION_ORIGIN__+0x20>
    413c:	20 93 05 05 	sts	0x0505, r18	; 0x800505 <_ZL10saveTCCR1A>
	saveTCCR1B = TCCR1B;
    4140:	20 91 81 00 	lds	r18, 0x0081	; 0x800081 <__DATA_REGION_ORIGIN__+0x21>
    4144:	20 93 04 05 	sts	0x0504, r18	; 0x800504 <_ZL10saveTCCR1B>
	TCCR1B = 0;
    4148:	10 92 81 00 	sts	0x0081, r1	; 0x800081 <__DATA_REGION_ORIGIN__+0x21>
	TCCR1A = 0;
    414c:	10 92 80 00 	sts	0x0080, r1	; 0x800080 <__DATA_REGION_ORIGIN__+0x20>
	TCNT1 = 0;
    4150:	10 92 85 00 	sts	0x0085, r1	; 0x800085 <__DATA_REGION_ORIGIN__+0x25>
    4154:	10 92 84 00 	sts	0x0084, r1	; 0x800084 <__DATA_REGION_ORIGIN__+0x24>
	TIFR1 = (1<<TOV1);
    4158:	21 e0       	ldi	r18, 0x01	; 1
    415a:	26 bb       	out	0x16, r18	; 22
	TIMSK1 = 0;
    415c:	10 92 6f 00 	sts	0x006F, r1	; 0x80006f <__DATA_REGION_ORIGIN__+0xf>

static inline uint16_t timer_init(uint16_t msec)
{
	uint16_t gate_len;

	saveTCCR2A = TCCR2A;
    4160:	20 91 b0 00 	lds	r18, 0x00B0	; 0x8000b0 <__DATA_REGION_ORIGIN__+0x50>
    4164:	20 93 03 05 	sts	0x0503, r18	; 0x800503 <_ZL10saveTCCR2A>
	saveTCCR2B = TCCR2B;
    4168:	20 91 b1 00 	lds	r18, 0x00B1	; 0x8000b1 <__DATA_REGION_ORIGIN__+0x51>
    416c:	20 93 02 05 	sts	0x0502, r18	; 0x800502 <_ZL10saveTCCR2B>
	TCCR2B = 0;
    4170:	10 92 b1 00 	sts	0x00B1, r1	; 0x8000b1 <__DATA_REGION_ORIGIN__+0x51>
	TCCR2A = (1<<WGM21);
    4174:	22 e0       	ldi	r18, 0x02	; 2
    4176:	20 93 b0 00 	sts	0x00B0, r18	; 0x8000b0 <__DATA_REGION_ORIGIN__+0x50>
	if ((msec & 7) == 0) {
    417a:	9c 01       	movw	r18, r24
    417c:	27 70       	andi	r18, 0x07	; 7
    417e:	33 27       	eor	r19, r19
    4180:	23 2b       	or	r18, r19
    4182:	51 f4       	brne	.+20     	; 0x4198 <_ZN14FreqCountClass5beginEj+0x8a>
		gate_len = msec >> 3;
    4184:	43 e0       	ldi	r20, 0x03	; 3
    4186:	96 95       	lsr	r25
    4188:	87 95       	ror	r24
    418a:	4a 95       	dec	r20
    418c:	e1 f7       	brne	.-8      	; 0x4186 <_ZN14FreqCountClass5beginEj+0x78>
		OCR2A = TIMER2_OCR2A_8MS_VAL;
    418e:	2c e7       	ldi	r18, 0x7C	; 124
    4190:	20 93 b3 00 	sts	0x00B3, r18	; 0x8000b3 <__DATA_REGION_ORIGIN__+0x53>
		startTCCR2B = TIMER2_TCCR2B_8MS_VAL;
    4194:	27 e0       	ldi	r18, 0x07	; 7
    4196:	18 c0       	rjmp	.+48     	; 0x41c8 <_ZN14FreqCountClass5beginEj+0xba>
	} else if ((msec & 3) == 0) {
    4198:	9c 01       	movw	r18, r24
    419a:	23 70       	andi	r18, 0x03	; 3
    419c:	33 27       	eor	r19, r19
    419e:	23 2b       	or	r18, r19
    41a0:	31 f4       	brne	.+12     	; 0x41ae <_ZN14FreqCountClass5beginEj+0xa0>
		gate_len = msec >> 2;
    41a2:	96 95       	lsr	r25
    41a4:	87 95       	ror	r24
    41a6:	96 95       	lsr	r25
    41a8:	87 95       	ror	r24
		OCR2A = TIMER2_OCR2A_4MS_VAL;
    41aa:	29 ef       	ldi	r18, 0xF9	; 249
    41ac:	05 c0       	rjmp	.+10     	; 0x41b8 <_ZN14FreqCountClass5beginEj+0xaa>
		startTCCR2B = TIMER2_TCCR2B_4MS_VAL;
	} else if ((msec & 1) == 0) {
    41ae:	80 fd       	sbrc	r24, 0
    41b0:	07 c0       	rjmp	.+14     	; 0x41c0 <_ZN14FreqCountClass5beginEj+0xb2>
		gate_len = msec >> 1;
    41b2:	96 95       	lsr	r25
    41b4:	87 95       	ror	r24
		OCR2A = TIMER2_OCR2A_2MS_VAL;
    41b6:	2c e7       	ldi	r18, 0x7C	; 124
    41b8:	20 93 b3 00 	sts	0x00B3, r18	; 0x8000b3 <__DATA_REGION_ORIGIN__+0x53>
		startTCCR2B = TIMER2_TCCR2B_2MS_VAL;
    41bc:	26 e0       	ldi	r18, 0x06	; 6
    41be:	04 c0       	rjmp	.+8      	; 0x41c8 <_ZN14FreqCountClass5beginEj+0xba>
	} else {
		gate_len = msec;
		OCR2A = TIMER2_OCR2A_1MS_VAL;
    41c0:	2c e7       	ldi	r18, 0x7C	; 124
    41c2:	20 93 b3 00 	sts	0x00B3, r18	; 0x8000b3 <__DATA_REGION_ORIGIN__+0x53>
		startTCCR2B = TIMER2_TCCR2B_1MS_VAL;
    41c6:	25 e0       	ldi	r18, 0x05	; 5
    41c8:	20 93 01 05 	sts	0x0501, r18	; 0x800501 <_ZL11startTCCR2B>
	}
	TIFR2 = (1<<OCF2A);
    41cc:	22 e0       	ldi	r18, 0x02	; 2
    41ce:	27 bb       	out	0x17, r18	; 23
	TCNT2 = 0;
    41d0:	10 92 b2 00 	sts	0x00B2, r1	; 0x8000b2 <__DATA_REGION_ORIGIN__+0x52>
	counter_init();
	gate_length = timer_init(msec);
    41d4:	90 93 f5 04 	sts	0x04F5, r25	; 0x8004f5 <_ZL11gate_length+0x1>
    41d8:	80 93 f4 04 	sts	0x04F4, r24	; 0x8004f4 <_ZL11gate_length>
	uint8_t status = SREG;
    41dc:	9f b7       	in	r25, 0x3f	; 63
	cli();
    41de:	f8 94       	cli
	return gate_len;
}

static inline void timer_start(void)
{
	GTCCR = (1<<PSRASY);
    41e0:	23 bd       	out	0x23, r18	; 35
	TCCR2B = startTCCR2B;
    41e2:	80 91 01 05 	lds	r24, 0x0501	; 0x800501 <_ZL11startTCCR2B>
    41e6:	80 93 b1 00 	sts	0x00B1, r24	; 0x8000b1 <__DATA_REGION_ORIGIN__+0x51>
	TIMSK2 = (1<<OCIE2A);
    41ea:	20 93 70 00 	sts	0x0070, r18	; 0x800070 <__DATA_REGION_ORIGIN__+0x10>
		"L_%=_loop:"
		"subi   %0, 1"		"\n\t"
		"brne   L_%=_loop"	"\n\t"
		: "+d" (cycles_times_3)
		: "0" (cycles_times_3)
	);
    41ee:	8b e0       	ldi	r24, 0x0B	; 11

000041f0 <L_130_loop>:
    41f0:	81 50       	subi	r24, 0x01	; 1
    41f2:	f1 f7       	brne	.-4      	; 0x41f0 <L_130_loop>
	TIMSK1 = 0;
}

static inline void counter_start(void)
{
	TCCR1B = (1<<CS12) | (1<<CS11) | (1<<CS10);
    41f4:	87 e0       	ldi	r24, 0x07	; 7
    41f6:	80 93 81 00 	sts	0x0081, r24	; 0x800081 <__DATA_REGION_ORIGIN__+0x21>
	timer_start();
	timer_isr_latency_delay();
	counter_start();
	SREG = status;
    41fa:	9f bf       	out	0x3f, r25	; 63
    41fc:	08 95       	ret

000041fe <_ZN14FreqCountClass9availableEv>:
}

uint8_t FreqCountClass::available(void)
{
	return count_ready;
    41fe:	80 91 f6 04 	lds	r24, 0x04F6	; 0x8004f6 <_ZL11count_ready>
}
    4202:	08 95       	ret

00004204 <_ZN14FreqCountClass4readEv>:
uint32_t FreqCountClass::read(void)
{
	uint32_t count;
	uint8_t status;

	status = SREG;
    4204:	2f b7       	in	r18, 0x3f	; 63
	cli();
    4206:	f8 94       	cli
	count = count_output;
    4208:	60 91 f7 04 	lds	r22, 0x04F7	; 0x8004f7 <_ZL12count_output>
    420c:	70 91 f8 04 	lds	r23, 0x04F8	; 0x8004f8 <_ZL12count_output+0x1>
    4210:	80 91 f9 04 	lds	r24, 0x04F9	; 0x8004f9 <_ZL12count_output+0x2>
    4214:	90 91 fa 04 	lds	r25, 0x04FA	; 0x8004fa <_ZL12count_output+0x3>
	count_ready = 0;
    4218:	10 92 f6 04 	sts	0x04F6, r1	; 0x8004f6 <_ZL11count_ready>
	SREG = status;
    421c:	2f bf       	out	0x3f, r18	; 63
	return count;
}
    421e:	08 95       	ret

00004220 <_ZN14FreqCountClass3endEv>:
	TIMSK2 = (1<<OCIE2A);
}

static inline void timer_shutdown(void)
{
	TCCR2B = 0;
    4220:	e1 eb       	ldi	r30, 0xB1	; 177
    4222:	f0 e0       	ldi	r31, 0x00	; 0
    4224:	10 82       	st	Z, r1
	TIMSK2 = 0;
    4226:	10 92 70 00 	sts	0x0070, r1	; 0x800070 <__DATA_REGION_ORIGIN__+0x10>
	TCCR2A = saveTCCR2A;
    422a:	80 91 03 05 	lds	r24, 0x0503	; 0x800503 <_ZL10saveTCCR2A>
    422e:	80 93 b0 00 	sts	0x00B0, r24	; 0x8000b0 <__DATA_REGION_ORIGIN__+0x50>
	TCCR2B = saveTCCR2B;
    4232:	80 91 02 05 	lds	r24, 0x0502	; 0x800502 <_ZL10saveTCCR2B>
    4236:	80 83       	st	Z, r24
	TCCR1B = (1<<CS12) | (1<<CS11) | (1<<CS10);
}

static inline void counter_shutdown(void)
{
	TCCR1B = 0;
    4238:	e1 e8       	ldi	r30, 0x81	; 129
    423a:	f0 e0       	ldi	r31, 0x00	; 0
    423c:	10 82       	st	Z, r1
	TCCR1A = saveTCCR1A;
    423e:	80 91 05 05 	lds	r24, 0x0505	; 0x800505 <_ZL10saveTCCR1A>
    4242:	80 93 80 00 	sts	0x0080, r24	; 0x800080 <__DATA_REGION_ORIGIN__+0x20>
	TCCR1B = saveTCCR1B;
    4246:	80 91 04 05 	lds	r24, 0x0504	; 0x800504 <_ZL10saveTCCR1B>
    424a:	80 83       	st	Z, r24
    424c:	08 95       	ret

0000424e <__vector_7>:
	counter_shutdown();
}


ISR(TIMER_ISR_VECTOR)
{
    424e:	1f 92       	push	r1
    4250:	0f 92       	push	r0
    4252:	0f b6       	in	r0, 0x3f	; 63
    4254:	0f 92       	push	r0
    4256:	11 24       	eor	r1, r1
    4258:	0f 93       	push	r16
    425a:	1f 93       	push	r17
    425c:	2f 93       	push	r18
    425e:	3f 93       	push	r19
    4260:	4f 93       	push	r20
    4262:	5f 93       	push	r21
    4264:	6f 93       	push	r22
    4266:	7f 93       	push	r23
    4268:	8f 93       	push	r24
    426a:	9f 93       	push	r25
    426c:	af 93       	push	r26
    426e:	bf 93       	push	r27
}

static inline uint16_t counter_read(void)
{
	return TCNT1;
    4270:	20 91 84 00 	lds	r18, 0x0084	; 0x800084 <__DATA_REGION_ORIGIN__+0x24>
    4274:	30 91 85 00 	lds	r19, 0x0085	; 0x800085 <__DATA_REGION_ORIGIN__+0x25>
	uint16_t count_lsw;
	uint32_t count;
	uint16_t index, length;

	count_lsw = counter_read();
	if (counter_overflow()) {
    4278:	b0 9b       	sbis	0x16, 0	; 22
    427a:	0b c0       	rjmp	.+22     	; 0x4292 <__vector_7+0x44>
	return TIFR1 & (1<<TOV1);
}

static inline void counter_overflow_reset(void)
{
	TIFR1 = (1<<TOV1);
    427c:	81 e0       	ldi	r24, 0x01	; 1
    427e:	86 bb       	out	0x16, r24	; 22
		counter_overflow_reset();
		count_msw++;
    4280:	80 91 ff 04 	lds	r24, 0x04FF	; 0x8004ff <_ZL9count_msw>
    4284:	90 91 00 05 	lds	r25, 0x0500	; 0x800500 <_ZL9count_msw+0x1>
    4288:	01 96       	adiw	r24, 0x01	; 1
    428a:	90 93 00 05 	sts	0x0500, r25	; 0x800500 <_ZL9count_msw+0x1>
    428e:	80 93 ff 04 	sts	0x04FF, r24	; 0x8004ff <_ZL9count_msw>
	}
	index = gate_index + 1;
    4292:	80 91 f2 04 	lds	r24, 0x04F2	; 0x8004f2 <_ZL10gate_index>
    4296:	90 91 f3 04 	lds	r25, 0x04F3	; 0x8004f3 <_ZL10gate_index+0x1>
    429a:	01 96       	adiw	r24, 0x01	; 1
	length = gate_length;
	if (index >= length) {
    429c:	40 91 f4 04 	lds	r20, 0x04F4	; 0x8004f4 <_ZL11gate_length>
    42a0:	50 91 f5 04 	lds	r21, 0x04F5	; 0x8004f5 <_ZL11gate_length+0x1>
    42a4:	84 17       	cp	r24, r20
    42a6:	95 07       	cpc	r25, r21
    42a8:	98 f1       	brcs	.+102    	; 0x4310 <__vector_7+0xc2>
		gate_index = 0;
    42aa:	10 92 f3 04 	sts	0x04F3, r1	; 0x8004f3 <_ZL10gate_index+0x1>
    42ae:	10 92 f2 04 	sts	0x04F2, r1	; 0x8004f2 <_ZL10gate_index>
		count = ((uint32_t)count_msw << 16) + count_lsw;
    42b2:	80 91 ff 04 	lds	r24, 0x04FF	; 0x8004ff <_ZL9count_msw>
    42b6:	90 91 00 05 	lds	r25, 0x0500	; 0x800500 <_ZL9count_msw+0x1>
    42ba:	a0 e0       	ldi	r26, 0x00	; 0
    42bc:	b0 e0       	ldi	r27, 0x00	; 0
    42be:	dc 01       	movw	r26, r24
    42c0:	99 27       	eor	r25, r25
    42c2:	88 27       	eor	r24, r24
    42c4:	82 0f       	add	r24, r18
    42c6:	93 1f       	adc	r25, r19
    42c8:	a1 1d       	adc	r26, r1
    42ca:	b1 1d       	adc	r27, r1
		count_output = count - count_prev;
    42cc:	40 91 fb 04 	lds	r20, 0x04FB	; 0x8004fb <_ZL10count_prev>
    42d0:	50 91 fc 04 	lds	r21, 0x04FC	; 0x8004fc <_ZL10count_prev+0x1>
    42d4:	60 91 fd 04 	lds	r22, 0x04FD	; 0x8004fd <_ZL10count_prev+0x2>
    42d8:	70 91 fe 04 	lds	r23, 0x04FE	; 0x8004fe <_ZL10count_prev+0x3>
    42dc:	8c 01       	movw	r16, r24
    42de:	9d 01       	movw	r18, r26
    42e0:	04 1b       	sub	r16, r20
    42e2:	15 0b       	sbc	r17, r21
    42e4:	26 0b       	sbc	r18, r22
    42e6:	37 0b       	sbc	r19, r23
    42e8:	00 93 f7 04 	sts	0x04F7, r16	; 0x8004f7 <_ZL12count_output>
    42ec:	10 93 f8 04 	sts	0x04F8, r17	; 0x8004f8 <_ZL12count_output+0x1>
    42f0:	20 93 f9 04 	sts	0x04F9, r18	; 0x8004f9 <_ZL12count_output+0x2>
    42f4:	30 93 fa 04 	sts	0x04FA, r19	; 0x8004fa <_ZL12count_output+0x3>
		count_prev = count;
    42f8:	80 93 fb 04 	sts	0x04FB, r24	; 0x8004fb <_ZL10count_prev>
    42fc:	90 93 fc 04 	sts	0x04FC, r25	; 0x8004fc <_ZL10count_prev+0x1>
    4300:	a0 93 fd 04 	sts	0x04FD, r26	; 0x8004fd <_ZL10count_prev+0x2>
    4304:	b0 93 fe 04 	sts	0x04FE, r27	; 0x8004fe <_ZL10count_prev+0x3>
		count_ready = 1;
    4308:	81 e0       	ldi	r24, 0x01	; 1
    430a:	80 93 f6 04 	sts	0x04F6, r24	; 0x8004f6 <_ZL11count_ready>
    430e:	04 c0       	rjmp	.+8      	; 0x4318 <__vector_7+0xca>
		restore_other_interrupts();
	} else {
		if (index == length - 1) disable_other_interrupts();
		gate_index = index;
    4310:	90 93 f3 04 	sts	0x04F3, r25	; 0x8004f3 <_ZL10gate_index+0x1>
    4314:	80 93 f2 04 	sts	0x04F2, r24	; 0x8004f2 <_ZL10gate_index>
	}
}
    4318:	bf 91       	pop	r27
    431a:	af 91       	pop	r26
    431c:	9f 91       	pop	r25
    431e:	8f 91       	pop	r24
    4320:	7f 91       	pop	r23
    4322:	6f 91       	pop	r22
    4324:	5f 91       	pop	r21
    4326:	4f 91       	pop	r20
    4328:	3f 91       	pop	r19
    432a:	2f 91       	pop	r18
    432c:	1f 91       	pop	r17
    432e:	0f 91       	pop	r16
    4330:	0f 90       	pop	r0
    4332:	0f be       	out	0x3f, r0	; 63
    4334:	0f 90       	pop	r0
    4336:	1f 90       	pop	r1
    4338:	18 95       	reti

0000433a <__unordsf2>:
    433a:	0e 94 8c 0b 	call	0x1718	; 0x1718 <__fp_cmp>
    433e:	88 0b       	sbc	r24, r24
    4340:	99 0b       	sbc	r25, r25
    4342:	08 95       	ret

00004344 <__divmodhi4>:
    4344:	97 fb       	bst	r25, 7
    4346:	07 2e       	mov	r0, r23
    4348:	16 f4       	brtc	.+4      	; 0x434e <__divmodhi4+0xa>
    434a:	00 94       	com	r0
    434c:	07 d0       	rcall	.+14     	; 0x435c <__divmodhi4_neg1>
    434e:	77 fd       	sbrc	r23, 7
    4350:	09 d0       	rcall	.+18     	; 0x4364 <__divmodhi4_neg2>
    4352:	0e 94 08 22 	call	0x4410	; 0x4410 <__udivmodhi4>
    4356:	07 fc       	sbrc	r0, 7
    4358:	05 d0       	rcall	.+10     	; 0x4364 <__divmodhi4_neg2>
    435a:	3e f4       	brtc	.+14     	; 0x436a <__divmodhi4_exit>

0000435c <__divmodhi4_neg1>:
    435c:	90 95       	com	r25
    435e:	81 95       	neg	r24
    4360:	9f 4f       	sbci	r25, 0xFF	; 255
    4362:	08 95       	ret

00004364 <__divmodhi4_neg2>:
    4364:	70 95       	com	r23
    4366:	61 95       	neg	r22
    4368:	7f 4f       	sbci	r23, 0xFF	; 255

0000436a <__divmodhi4_exit>:
    436a:	08 95       	ret

0000436c <__udivmodsi4>:
    436c:	a1 e2       	ldi	r26, 0x21	; 33
    436e:	1a 2e       	mov	r1, r26
    4370:	aa 1b       	sub	r26, r26
    4372:	bb 1b       	sub	r27, r27
    4374:	fd 01       	movw	r30, r26
    4376:	0d c0       	rjmp	.+26     	; 0x4392 <__udivmodsi4_ep>

00004378 <__udivmodsi4_loop>:
    4378:	aa 1f       	adc	r26, r26
    437a:	bb 1f       	adc	r27, r27
    437c:	ee 1f       	adc	r30, r30
    437e:	ff 1f       	adc	r31, r31
    4380:	a2 17       	cp	r26, r18
    4382:	b3 07       	cpc	r27, r19
    4384:	e4 07       	cpc	r30, r20
    4386:	f5 07       	cpc	r31, r21
    4388:	20 f0       	brcs	.+8      	; 0x4392 <__udivmodsi4_ep>
    438a:	a2 1b       	sub	r26, r18
    438c:	b3 0b       	sbc	r27, r19
    438e:	e4 0b       	sbc	r30, r20
    4390:	f5 0b       	sbc	r31, r21

00004392 <__udivmodsi4_ep>:
    4392:	66 1f       	adc	r22, r22
    4394:	77 1f       	adc	r23, r23
    4396:	88 1f       	adc	r24, r24
    4398:	99 1f       	adc	r25, r25
    439a:	1a 94       	dec	r1
    439c:	69 f7       	brne	.-38     	; 0x4378 <__udivmodsi4_loop>
    439e:	60 95       	com	r22
    43a0:	70 95       	com	r23
    43a2:	80 95       	com	r24
    43a4:	90 95       	com	r25
    43a6:	9b 01       	movw	r18, r22
    43a8:	ac 01       	movw	r20, r24
    43aa:	bd 01       	movw	r22, r26
    43ac:	cf 01       	movw	r24, r30
    43ae:	08 95       	ret

000043b0 <__divmodsi4>:
    43b0:	05 2e       	mov	r0, r21
    43b2:	97 fb       	bst	r25, 7
    43b4:	1e f4       	brtc	.+6      	; 0x43bc <__divmodsi4+0xc>
    43b6:	00 94       	com	r0
    43b8:	0e 94 ef 21 	call	0x43de	; 0x43de <__negsi2>
    43bc:	57 fd       	sbrc	r21, 7
    43be:	07 d0       	rcall	.+14     	; 0x43ce <__divmodsi4_neg2>
    43c0:	0e 94 b6 21 	call	0x436c	; 0x436c <__udivmodsi4>
    43c4:	07 fc       	sbrc	r0, 7
    43c6:	03 d0       	rcall	.+6      	; 0x43ce <__divmodsi4_neg2>
    43c8:	4e f4       	brtc	.+18     	; 0x43dc <__divmodsi4_exit>
    43ca:	0c 94 ef 21 	jmp	0x43de	; 0x43de <__negsi2>

000043ce <__divmodsi4_neg2>:
    43ce:	50 95       	com	r21
    43d0:	40 95       	com	r20
    43d2:	30 95       	com	r19
    43d4:	21 95       	neg	r18
    43d6:	3f 4f       	sbci	r19, 0xFF	; 255
    43d8:	4f 4f       	sbci	r20, 0xFF	; 255
    43da:	5f 4f       	sbci	r21, 0xFF	; 255

000043dc <__divmodsi4_exit>:
    43dc:	08 95       	ret

000043de <__negsi2>:
    43de:	90 95       	com	r25
    43e0:	80 95       	com	r24
    43e2:	70 95       	com	r23
    43e4:	61 95       	neg	r22
    43e6:	7f 4f       	sbci	r23, 0xFF	; 255
    43e8:	8f 4f       	sbci	r24, 0xFF	; 255
    43ea:	9f 4f       	sbci	r25, 0xFF	; 255
    43ec:	08 95       	ret

000043ee <__tablejump2__>:
    43ee:	ee 0f       	add	r30, r30
    43f0:	ff 1f       	adc	r31, r31
    43f2:	05 90       	lpm	r0, Z+
    43f4:	f4 91       	lpm	r31, Z
    43f6:	e0 2d       	mov	r30, r0
    43f8:	09 94       	ijmp

000043fa <__muluhisi3>:
    43fa:	0e 94 1c 22 	call	0x4438	; 0x4438 <__umulhisi3>
    43fe:	a5 9f       	mul	r26, r21
    4400:	90 0d       	add	r25, r0
    4402:	b4 9f       	mul	r27, r20
    4404:	90 0d       	add	r25, r0
    4406:	a4 9f       	mul	r26, r20
    4408:	80 0d       	add	r24, r0
    440a:	91 1d       	adc	r25, r1
    440c:	11 24       	eor	r1, r1
    440e:	08 95       	ret

00004410 <__udivmodhi4>:
    4410:	aa 1b       	sub	r26, r26
    4412:	bb 1b       	sub	r27, r27
    4414:	51 e1       	ldi	r21, 0x11	; 17
    4416:	07 c0       	rjmp	.+14     	; 0x4426 <__udivmodhi4_ep>

00004418 <__udivmodhi4_loop>:
    4418:	aa 1f       	adc	r26, r26
    441a:	bb 1f       	adc	r27, r27
    441c:	a6 17       	cp	r26, r22
    441e:	b7 07       	cpc	r27, r23
    4420:	10 f0       	brcs	.+4      	; 0x4426 <__udivmodhi4_ep>
    4422:	a6 1b       	sub	r26, r22
    4424:	b7 0b       	sbc	r27, r23

00004426 <__udivmodhi4_ep>:
    4426:	88 1f       	adc	r24, r24
    4428:	99 1f       	adc	r25, r25
    442a:	5a 95       	dec	r21
    442c:	a9 f7       	brne	.-22     	; 0x4418 <__udivmodhi4_loop>
    442e:	80 95       	com	r24
    4430:	90 95       	com	r25
    4432:	bc 01       	movw	r22, r24
    4434:	cd 01       	movw	r24, r26
    4436:	08 95       	ret

00004438 <__umulhisi3>:
    4438:	a2 9f       	mul	r26, r18
    443a:	b0 01       	movw	r22, r0
    443c:	b3 9f       	mul	r27, r19
    443e:	c0 01       	movw	r24, r0
    4440:	a3 9f       	mul	r26, r19
    4442:	70 0d       	add	r23, r0
    4444:	81 1d       	adc	r24, r1
    4446:	11 24       	eor	r1, r1
    4448:	91 1d       	adc	r25, r1
    444a:	b2 9f       	mul	r27, r18
    444c:	70 0d       	add	r23, r0
    444e:	81 1d       	adc	r24, r1
    4450:	11 24       	eor	r1, r1
    4452:	91 1d       	adc	r25, r1
    4454:	08 95       	ret

00004456 <malloc>:
    4456:	0f 93       	push	r16
    4458:	1f 93       	push	r17
    445a:	cf 93       	push	r28
    445c:	df 93       	push	r29
    445e:	82 30       	cpi	r24, 0x02	; 2
    4460:	91 05       	cpc	r25, r1
    4462:	10 f4       	brcc	.+4      	; 0x4468 <malloc+0x12>
    4464:	82 e0       	ldi	r24, 0x02	; 2
    4466:	90 e0       	ldi	r25, 0x00	; 0
    4468:	e0 91 08 05 	lds	r30, 0x0508	; 0x800508 <__flp>
    446c:	f0 91 09 05 	lds	r31, 0x0509	; 0x800509 <__flp+0x1>
    4470:	20 e0       	ldi	r18, 0x00	; 0
    4472:	30 e0       	ldi	r19, 0x00	; 0
    4474:	a0 e0       	ldi	r26, 0x00	; 0
    4476:	b0 e0       	ldi	r27, 0x00	; 0
    4478:	30 97       	sbiw	r30, 0x00	; 0
    447a:	19 f1       	breq	.+70     	; 0x44c2 <malloc+0x6c>
    447c:	40 81       	ld	r20, Z
    447e:	51 81       	ldd	r21, Z+1	; 0x01
    4480:	02 81       	ldd	r16, Z+2	; 0x02
    4482:	13 81       	ldd	r17, Z+3	; 0x03
    4484:	48 17       	cp	r20, r24
    4486:	59 07       	cpc	r21, r25
    4488:	c8 f0       	brcs	.+50     	; 0x44bc <malloc+0x66>
    448a:	84 17       	cp	r24, r20
    448c:	95 07       	cpc	r25, r21
    448e:	69 f4       	brne	.+26     	; 0x44aa <malloc+0x54>
    4490:	10 97       	sbiw	r26, 0x00	; 0
    4492:	31 f0       	breq	.+12     	; 0x44a0 <malloc+0x4a>
    4494:	12 96       	adiw	r26, 0x02	; 2
    4496:	0c 93       	st	X, r16
    4498:	12 97       	sbiw	r26, 0x02	; 2
    449a:	13 96       	adiw	r26, 0x03	; 3
    449c:	1c 93       	st	X, r17
    449e:	27 c0       	rjmp	.+78     	; 0x44ee <malloc+0x98>
    44a0:	00 93 08 05 	sts	0x0508, r16	; 0x800508 <__flp>
    44a4:	10 93 09 05 	sts	0x0509, r17	; 0x800509 <__flp+0x1>
    44a8:	22 c0       	rjmp	.+68     	; 0x44ee <malloc+0x98>
    44aa:	21 15       	cp	r18, r1
    44ac:	31 05       	cpc	r19, r1
    44ae:	19 f0       	breq	.+6      	; 0x44b6 <malloc+0x60>
    44b0:	42 17       	cp	r20, r18
    44b2:	53 07       	cpc	r21, r19
    44b4:	18 f4       	brcc	.+6      	; 0x44bc <malloc+0x66>
    44b6:	9a 01       	movw	r18, r20
    44b8:	bd 01       	movw	r22, r26
    44ba:	ef 01       	movw	r28, r30
    44bc:	df 01       	movw	r26, r30
    44be:	f8 01       	movw	r30, r16
    44c0:	db cf       	rjmp	.-74     	; 0x4478 <malloc+0x22>
    44c2:	21 15       	cp	r18, r1
    44c4:	31 05       	cpc	r19, r1
    44c6:	f9 f0       	breq	.+62     	; 0x4506 <malloc+0xb0>
    44c8:	28 1b       	sub	r18, r24
    44ca:	39 0b       	sbc	r19, r25
    44cc:	24 30       	cpi	r18, 0x04	; 4
    44ce:	31 05       	cpc	r19, r1
    44d0:	80 f4       	brcc	.+32     	; 0x44f2 <malloc+0x9c>
    44d2:	8a 81       	ldd	r24, Y+2	; 0x02
    44d4:	9b 81       	ldd	r25, Y+3	; 0x03
    44d6:	61 15       	cp	r22, r1
    44d8:	71 05       	cpc	r23, r1
    44da:	21 f0       	breq	.+8      	; 0x44e4 <malloc+0x8e>
    44dc:	fb 01       	movw	r30, r22
    44de:	93 83       	std	Z+3, r25	; 0x03
    44e0:	82 83       	std	Z+2, r24	; 0x02
    44e2:	04 c0       	rjmp	.+8      	; 0x44ec <malloc+0x96>
    44e4:	90 93 09 05 	sts	0x0509, r25	; 0x800509 <__flp+0x1>
    44e8:	80 93 08 05 	sts	0x0508, r24	; 0x800508 <__flp>
    44ec:	fe 01       	movw	r30, r28
    44ee:	32 96       	adiw	r30, 0x02	; 2
    44f0:	44 c0       	rjmp	.+136    	; 0x457a <malloc+0x124>
    44f2:	fe 01       	movw	r30, r28
    44f4:	e2 0f       	add	r30, r18
    44f6:	f3 1f       	adc	r31, r19
    44f8:	81 93       	st	Z+, r24
    44fa:	91 93       	st	Z+, r25
    44fc:	22 50       	subi	r18, 0x02	; 2
    44fe:	31 09       	sbc	r19, r1
    4500:	39 83       	std	Y+1, r19	; 0x01
    4502:	28 83       	st	Y, r18
    4504:	3a c0       	rjmp	.+116    	; 0x457a <malloc+0x124>
    4506:	20 91 06 05 	lds	r18, 0x0506	; 0x800506 <__brkval>
    450a:	30 91 07 05 	lds	r19, 0x0507	; 0x800507 <__brkval+0x1>
    450e:	23 2b       	or	r18, r19
    4510:	41 f4       	brne	.+16     	; 0x4522 <malloc+0xcc>
    4512:	20 91 02 01 	lds	r18, 0x0102	; 0x800102 <__malloc_heap_start>
    4516:	30 91 03 01 	lds	r19, 0x0103	; 0x800103 <__malloc_heap_start+0x1>
    451a:	30 93 07 05 	sts	0x0507, r19	; 0x800507 <__brkval+0x1>
    451e:	20 93 06 05 	sts	0x0506, r18	; 0x800506 <__brkval>
    4522:	20 91 00 01 	lds	r18, 0x0100	; 0x800100 <__data_start>
    4526:	30 91 01 01 	lds	r19, 0x0101	; 0x800101 <__data_start+0x1>
    452a:	21 15       	cp	r18, r1
    452c:	31 05       	cpc	r19, r1
    452e:	41 f4       	brne	.+16     	; 0x4540 <malloc+0xea>
    4530:	2d b7       	in	r18, 0x3d	; 61
    4532:	3e b7       	in	r19, 0x3e	; 62
    4534:	40 91 04 01 	lds	r20, 0x0104	; 0x800104 <__malloc_margin>
    4538:	50 91 05 01 	lds	r21, 0x0105	; 0x800105 <__malloc_margin+0x1>
    453c:	24 1b       	sub	r18, r20
    453e:	35 0b       	sbc	r19, r21
    4540:	e0 91 06 05 	lds	r30, 0x0506	; 0x800506 <__brkval>
    4544:	f0 91 07 05 	lds	r31, 0x0507	; 0x800507 <__brkval+0x1>
    4548:	e2 17       	cp	r30, r18
    454a:	f3 07       	cpc	r31, r19
    454c:	a0 f4       	brcc	.+40     	; 0x4576 <malloc+0x120>
    454e:	2e 1b       	sub	r18, r30
    4550:	3f 0b       	sbc	r19, r31
    4552:	28 17       	cp	r18, r24
    4554:	39 07       	cpc	r19, r25
    4556:	78 f0       	brcs	.+30     	; 0x4576 <malloc+0x120>
    4558:	ac 01       	movw	r20, r24
    455a:	4e 5f       	subi	r20, 0xFE	; 254
    455c:	5f 4f       	sbci	r21, 0xFF	; 255
    455e:	24 17       	cp	r18, r20
    4560:	35 07       	cpc	r19, r21
    4562:	48 f0       	brcs	.+18     	; 0x4576 <malloc+0x120>
    4564:	4e 0f       	add	r20, r30
    4566:	5f 1f       	adc	r21, r31
    4568:	50 93 07 05 	sts	0x0507, r21	; 0x800507 <__brkval+0x1>
    456c:	40 93 06 05 	sts	0x0506, r20	; 0x800506 <__brkval>
    4570:	81 93       	st	Z+, r24
    4572:	91 93       	st	Z+, r25
    4574:	02 c0       	rjmp	.+4      	; 0x457a <malloc+0x124>
    4576:	e0 e0       	ldi	r30, 0x00	; 0
    4578:	f0 e0       	ldi	r31, 0x00	; 0
    457a:	cf 01       	movw	r24, r30
    457c:	df 91       	pop	r29
    457e:	cf 91       	pop	r28
    4580:	1f 91       	pop	r17
    4582:	0f 91       	pop	r16
    4584:	08 95       	ret

00004586 <free>:
    4586:	cf 93       	push	r28
    4588:	df 93       	push	r29
    458a:	00 97       	sbiw	r24, 0x00	; 0
    458c:	09 f4       	brne	.+2      	; 0x4590 <free+0xa>
    458e:	81 c0       	rjmp	.+258    	; 0x4692 <free+0x10c>
    4590:	fc 01       	movw	r30, r24
    4592:	32 97       	sbiw	r30, 0x02	; 2
    4594:	13 82       	std	Z+3, r1	; 0x03
    4596:	12 82       	std	Z+2, r1	; 0x02
    4598:	a0 91 08 05 	lds	r26, 0x0508	; 0x800508 <__flp>
    459c:	b0 91 09 05 	lds	r27, 0x0509	; 0x800509 <__flp+0x1>
    45a0:	10 97       	sbiw	r26, 0x00	; 0
    45a2:	81 f4       	brne	.+32     	; 0x45c4 <free+0x3e>
    45a4:	20 81       	ld	r18, Z
    45a6:	31 81       	ldd	r19, Z+1	; 0x01
    45a8:	82 0f       	add	r24, r18
    45aa:	93 1f       	adc	r25, r19
    45ac:	20 91 06 05 	lds	r18, 0x0506	; 0x800506 <__brkval>
    45b0:	30 91 07 05 	lds	r19, 0x0507	; 0x800507 <__brkval+0x1>
    45b4:	28 17       	cp	r18, r24
    45b6:	39 07       	cpc	r19, r25
    45b8:	51 f5       	brne	.+84     	; 0x460e <free+0x88>
    45ba:	f0 93 07 05 	sts	0x0507, r31	; 0x800507 <__brkval+0x1>
    45be:	e0 93 06 05 	sts	0x0506, r30	; 0x800506 <__brkval>
    45c2:	67 c0       	rjmp	.+206    	; 0x4692 <free+0x10c>
    45c4:	ed 01       	movw	r28, r26
    45c6:	20 e0       	ldi	r18, 0x00	; 0
    45c8:	30 e0       	ldi	r19, 0x00	; 0
    45ca:	ce 17       	cp	r28, r30
    45cc:	df 07       	cpc	r29, r31
    45ce:	40 f4       	brcc	.+16     	; 0x45e0 <free+0x5a>
    45d0:	4a 81       	ldd	r20, Y+2	; 0x02
    45d2:	5b 81       	ldd	r21, Y+3	; 0x03
    45d4:	9e 01       	movw	r18, r28
    45d6:	41 15       	cp	r20, r1
    45d8:	51 05       	cpc	r21, r1
    45da:	f1 f0       	breq	.+60     	; 0x4618 <free+0x92>
    45dc:	ea 01       	movw	r28, r20
    45de:	f5 cf       	rjmp	.-22     	; 0x45ca <free+0x44>
    45e0:	d3 83       	std	Z+3, r29	; 0x03
    45e2:	c2 83       	std	Z+2, r28	; 0x02
    45e4:	40 81       	ld	r20, Z
    45e6:	51 81       	ldd	r21, Z+1	; 0x01
    45e8:	84 0f       	add	r24, r20
    45ea:	95 1f       	adc	r25, r21
    45ec:	c8 17       	cp	r28, r24
    45ee:	d9 07       	cpc	r29, r25
    45f0:	59 f4       	brne	.+22     	; 0x4608 <free+0x82>
    45f2:	88 81       	ld	r24, Y
    45f4:	99 81       	ldd	r25, Y+1	; 0x01
    45f6:	84 0f       	add	r24, r20
    45f8:	95 1f       	adc	r25, r21
    45fa:	02 96       	adiw	r24, 0x02	; 2
    45fc:	91 83       	std	Z+1, r25	; 0x01
    45fe:	80 83       	st	Z, r24
    4600:	8a 81       	ldd	r24, Y+2	; 0x02
    4602:	9b 81       	ldd	r25, Y+3	; 0x03
    4604:	93 83       	std	Z+3, r25	; 0x03
    4606:	82 83       	std	Z+2, r24	; 0x02
    4608:	21 15       	cp	r18, r1
    460a:	31 05       	cpc	r19, r1
    460c:	29 f4       	brne	.+10     	; 0x4618 <free+0x92>
    460e:	f0 93 09 05 	sts	0x0509, r31	; 0x800509 <__flp+0x1>
    4612:	e0 93 08 05 	sts	0x0508, r30	; 0x800508 <__flp>
    4616:	3d c0       	rjmp	.+122    	; 0x4692 <free+0x10c>
    4618:	e9 01       	movw	r28, r18
    461a:	fb 83       	std	Y+3, r31	; 0x03
    461c:	ea 83       	std	Y+2, r30	; 0x02
    461e:	49 91       	ld	r20, Y+
    4620:	59 91       	ld	r21, Y+
    4622:	c4 0f       	add	r28, r20
    4624:	d5 1f       	adc	r29, r21
    4626:	ec 17       	cp	r30, r28
    4628:	fd 07       	cpc	r31, r29
    462a:	61 f4       	brne	.+24     	; 0x4644 <free+0xbe>
    462c:	80 81       	ld	r24, Z
    462e:	91 81       	ldd	r25, Z+1	; 0x01
    4630:	84 0f       	add	r24, r20
    4632:	95 1f       	adc	r25, r21
    4634:	02 96       	adiw	r24, 0x02	; 2
    4636:	e9 01       	movw	r28, r18
    4638:	99 83       	std	Y+1, r25	; 0x01
    463a:	88 83       	st	Y, r24
    463c:	82 81       	ldd	r24, Z+2	; 0x02
    463e:	93 81       	ldd	r25, Z+3	; 0x03
    4640:	9b 83       	std	Y+3, r25	; 0x03
    4642:	8a 83       	std	Y+2, r24	; 0x02
    4644:	e0 e0       	ldi	r30, 0x00	; 0
    4646:	f0 e0       	ldi	r31, 0x00	; 0
    4648:	12 96       	adiw	r26, 0x02	; 2
    464a:	8d 91       	ld	r24, X+
    464c:	9c 91       	ld	r25, X
    464e:	13 97       	sbiw	r26, 0x03	; 3
    4650:	00 97       	sbiw	r24, 0x00	; 0
    4652:	19 f0       	breq	.+6      	; 0x465a <free+0xd4>
    4654:	fd 01       	movw	r30, r26
    4656:	dc 01       	movw	r26, r24
    4658:	f7 cf       	rjmp	.-18     	; 0x4648 <free+0xc2>
    465a:	8d 91       	ld	r24, X+
    465c:	9c 91       	ld	r25, X
    465e:	11 97       	sbiw	r26, 0x01	; 1
    4660:	9d 01       	movw	r18, r26
    4662:	2e 5f       	subi	r18, 0xFE	; 254
    4664:	3f 4f       	sbci	r19, 0xFF	; 255
    4666:	82 0f       	add	r24, r18
    4668:	93 1f       	adc	r25, r19
    466a:	20 91 06 05 	lds	r18, 0x0506	; 0x800506 <__brkval>
    466e:	30 91 07 05 	lds	r19, 0x0507	; 0x800507 <__brkval+0x1>
    4672:	28 17       	cp	r18, r24
    4674:	39 07       	cpc	r19, r25
    4676:	69 f4       	brne	.+26     	; 0x4692 <free+0x10c>
    4678:	30 97       	sbiw	r30, 0x00	; 0
    467a:	29 f4       	brne	.+10     	; 0x4686 <free+0x100>
    467c:	10 92 09 05 	sts	0x0509, r1	; 0x800509 <__flp+0x1>
    4680:	10 92 08 05 	sts	0x0508, r1	; 0x800508 <__flp>
    4684:	02 c0       	rjmp	.+4      	; 0x468a <free+0x104>
    4686:	13 82       	std	Z+3, r1	; 0x03
    4688:	12 82       	std	Z+2, r1	; 0x02
    468a:	b0 93 07 05 	sts	0x0507, r27	; 0x800507 <__brkval+0x1>
    468e:	a0 93 06 05 	sts	0x0506, r26	; 0x800506 <__brkval>
    4692:	df 91       	pop	r29
    4694:	cf 91       	pop	r28
    4696:	08 95       	ret

00004698 <memcpy>:
    4698:	fb 01       	movw	r30, r22
    469a:	dc 01       	movw	r26, r24
    469c:	02 c0       	rjmp	.+4      	; 0x46a2 <memcpy+0xa>
    469e:	01 90       	ld	r0, Z+
    46a0:	0d 92       	st	X+, r0
    46a2:	41 50       	subi	r20, 0x01	; 1
    46a4:	50 40       	sbci	r21, 0x00	; 0
    46a6:	d8 f7       	brcc	.-10     	; 0x469e <memcpy+0x6>
    46a8:	08 95       	ret

000046aa <memset>:
    46aa:	dc 01       	movw	r26, r24
    46ac:	01 c0       	rjmp	.+2      	; 0x46b0 <memset+0x6>
    46ae:	6d 93       	st	X+, r22
    46b0:	41 50       	subi	r20, 0x01	; 1
    46b2:	50 40       	sbci	r21, 0x00	; 0
    46b4:	e0 f7       	brcc	.-8      	; 0x46ae <memset+0x4>
    46b6:	08 95       	ret

000046b8 <eeprom_read_byte>:
    46b8:	f9 99       	sbic	0x1f, 1	; 31
    46ba:	fe cf       	rjmp	.-4      	; 0x46b8 <eeprom_read_byte>
    46bc:	92 bd       	out	0x22, r25	; 34
    46be:	81 bd       	out	0x21, r24	; 33
    46c0:	f8 9a       	sbi	0x1f, 0	; 31
    46c2:	99 27       	eor	r25, r25
    46c4:	80 b5       	in	r24, 0x20	; 32
    46c6:	08 95       	ret

000046c8 <eeprom_write_byte>:
    46c8:	26 2f       	mov	r18, r22

000046ca <eeprom_write_r18>:
    46ca:	f9 99       	sbic	0x1f, 1	; 31
    46cc:	fe cf       	rjmp	.-4      	; 0x46ca <eeprom_write_r18>
    46ce:	1f ba       	out	0x1f, r1	; 31
    46d0:	92 bd       	out	0x22, r25	; 34
    46d2:	81 bd       	out	0x21, r24	; 33
    46d4:	20 bd       	out	0x20, r18	; 32
    46d6:	0f b6       	in	r0, 0x3f	; 63
    46d8:	f8 94       	cli
    46da:	fa 9a       	sbi	0x1f, 2	; 31
    46dc:	f9 9a       	sbi	0x1f, 1	; 31
    46de:	0f be       	out	0x3f, r0	; 63
    46e0:	01 96       	adiw	r24, 0x01	; 1
    46e2:	08 95       	ret

000046e4 <__do_global_dtors>:
    46e4:	10 e0       	ldi	r17, 0x00	; 0
    46e6:	c9 e8       	ldi	r28, 0x89	; 137
    46e8:	d0 e0       	ldi	r29, 0x00	; 0
    46ea:	04 c0       	rjmp	.+8      	; 0x46f4 <__do_global_dtors+0x10>
    46ec:	fe 01       	movw	r30, r28
    46ee:	0e 94 f7 21 	call	0x43ee	; 0x43ee <__tablejump2__>
    46f2:	21 96       	adiw	r28, 0x01	; 1
    46f4:	cb 38       	cpi	r28, 0x8B	; 139
    46f6:	d1 07       	cpc	r29, r17
    46f8:	c9 f7       	brne	.-14     	; 0x46ec <__do_global_dtors+0x8>
    46fa:	f8 94       	cli

000046fc <__stop_program>:
    46fc:	ff cf       	rjmp	.-2      	; 0x46fc <__stop_program>
