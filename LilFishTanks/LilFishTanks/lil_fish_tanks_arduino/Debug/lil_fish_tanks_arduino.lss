
lil_fish_tanks_arduino.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000178  00800100  0000470c  000047a0  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         0000470c  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000280  00800278  00800278  00004918  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00004918  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00004948  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000a00  00000000  00000000  00004988  2**3
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   000137a7  00000000  00000000  00005388  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00003d03  00000000  00000000  00018b2f  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00006941  00000000  00000000  0001c832  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00001ea0  00000000  00000000  00023174  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00004b0c  00000000  00000000  00025014  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    0000b72d  00000000  00000000  00029b20  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000920  00000000  00000000  0003524d  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 8b 00 	jmp	0x116	; 0x116 <__dtors_end>
       4:	0c 94 94 12 	jmp	0x2528	; 0x2528 <__vector_1>
       8:	0c 94 bb 12 	jmp	0x2576	; 0x2576 <__vector_2>
       c:	0c 94 b3 00 	jmp	0x166	; 0x166 <__bad_interrupt>
      10:	0c 94 b3 00 	jmp	0x166	; 0x166 <__bad_interrupt>
      14:	0c 94 b3 00 	jmp	0x166	; 0x166 <__bad_interrupt>
      18:	0c 94 11 1f 	jmp	0x3e22	; 0x3e22 <__vector_6>
      1c:	0c 94 8d 1c 	jmp	0x391a	; 0x391a <__vector_7>
      20:	0c 94 b3 00 	jmp	0x166	; 0x166 <__bad_interrupt>
      24:	0c 94 b3 00 	jmp	0x166	; 0x166 <__bad_interrupt>
      28:	0c 94 b3 00 	jmp	0x166	; 0x166 <__bad_interrupt>
      2c:	0c 94 b3 00 	jmp	0x166	; 0x166 <__bad_interrupt>
      30:	0c 94 b3 00 	jmp	0x166	; 0x166 <__bad_interrupt>
      34:	0c 94 b3 00 	jmp	0x166	; 0x166 <__bad_interrupt>
      38:	0c 94 b3 00 	jmp	0x166	; 0x166 <__bad_interrupt>
      3c:	0c 94 b3 00 	jmp	0x166	; 0x166 <__bad_interrupt>
      40:	0c 94 e2 12 	jmp	0x25c4	; 0x25c4 <__vector_16>
      44:	0c 94 b3 00 	jmp	0x166	; 0x166 <__bad_interrupt>
      48:	0c 94 a5 0f 	jmp	0x1f4a	; 0x1f4a <__vector_18>
      4c:	0c 94 d7 0f 	jmp	0x1fae	; 0x1fae <__vector_19>
      50:	0c 94 b3 00 	jmp	0x166	; 0x166 <__bad_interrupt>
      54:	0c 94 b3 00 	jmp	0x166	; 0x166 <__bad_interrupt>
      58:	0c 94 b3 00 	jmp	0x166	; 0x166 <__bad_interrupt>
      5c:	0c 94 b3 00 	jmp	0x166	; 0x166 <__bad_interrupt>
      60:	0c 94 b3 00 	jmp	0x166	; 0x166 <__bad_interrupt>
      64:	0c 94 b3 00 	jmp	0x166	; 0x166 <__bad_interrupt>
      68:	81 1b       	sub	r24, r17
      6a:	81 1b       	sub	r24, r17
      6c:	81 1b       	sub	r24, r17
      6e:	c0 1b       	sub	r28, r16
      70:	ab 1b       	sub	r26, r27
      72:	ba 1b       	sub	r27, r26
      74:	81 1b       	sub	r24, r17
      76:	81 1b       	sub	r24, r17
      78:	c0 1b       	sub	r28, r16
      7a:	ab 1b       	sub	r26, r27

0000007c <__trampolines_end>:
      7c:	0a 46       	sbci	r16, 0x6A	; 106
      7e:	6f 75       	andi	r22, 0x5F	; 95
      80:	6e 64       	ori	r22, 0x4E	; 78
      82:	20 4d       	sbci	r18, 0xD0	; 208
      84:	61 74       	andi	r22, 0x41	; 65
      86:	63 68       	ori	r22, 0x83	; 131
      88:	69 6e       	ori	r22, 0xE9	; 233
      8a:	67 20       	and	r6, r7
      8c:	43 6f       	ori	r20, 0xF3	; 243
      8e:	6c 6f       	ori	r22, 0xFC	; 252
      90:	72 00       	.word	0x0072	; ????

00000092 <_ZL15dscrc2x16_table>:
      92:	00 5e bc e2 61 3f dd 83 c2 9c 7e 20 a3 fd 1f 41     .^..a?....~ ...A
      a2:	00 9d 23 be 46 db 65 f8 8c 11 af 32 ca 57 e9 74     ..#.F.e....2.W.t

000000b2 <digital_pin_to_timer_PGM>:
      b2:	00 00 00 08 00 02 01 00 00 03 04 07 00 00 00 00     ................
      c2:	00 00 00 00                                         ....

000000c6 <digital_pin_to_bit_mask_PGM>:
      c6:	01 02 04 08 10 20 40 80 01 02 04 08 10 20 01 02     ..... @...... ..
      d6:	04 08 10 20                                         ... 

000000da <digital_pin_to_port_PGM>:
      da:	04 04 04 04 04 04 04 04 02 02 02 02 02 02 03 03     ................
      ea:	03 03 03 03                                         ....

000000ee <port_to_input_PGM>:
      ee:	00 00 00 00 23 00 26 00 29 00                       ....#.&.).

000000f8 <port_to_output_PGM>:
      f8:	00 00 00 00 25 00 28 00 2b 00                       ....%.(.+.

00000102 <port_to_mode_PGM>:
     102:	00 00 00 00 24 00 27 00 2a 00                       ....$.'.*.

0000010c <__ctors_start>:
     10c:	df 07       	cpc	r29, r31
     10e:	78 0a       	sbc	r7, r24
     110:	07 10       	cpse	r0, r7

00000112 <__ctors_end>:
     112:	eb 07       	cpc	r30, r27
     114:	7c 0a       	sbc	r7, r28

00000116 <__dtors_end>:
     116:	11 24       	eor	r1, r1
     118:	1f be       	out	0x3f, r1	; 63
     11a:	cf ef       	ldi	r28, 0xFF	; 255
     11c:	d8 e0       	ldi	r29, 0x08	; 8
     11e:	de bf       	out	0x3e, r29	; 62
     120:	cd bf       	out	0x3d, r28	; 61

00000122 <__do_copy_data>:
     122:	12 e0       	ldi	r17, 0x02	; 2
     124:	a0 e0       	ldi	r26, 0x00	; 0
     126:	b1 e0       	ldi	r27, 0x01	; 1
     128:	ec e0       	ldi	r30, 0x0C	; 12
     12a:	f7 e4       	ldi	r31, 0x47	; 71
     12c:	02 c0       	rjmp	.+4      	; 0x132 <__do_copy_data+0x10>
     12e:	05 90       	lpm	r0, Z+
     130:	0d 92       	st	X+, r0
     132:	a8 37       	cpi	r26, 0x78	; 120
     134:	b1 07       	cpc	r27, r17
     136:	d9 f7       	brne	.-10     	; 0x12e <__do_copy_data+0xc>

00000138 <__do_clear_bss>:
     138:	24 e0       	ldi	r18, 0x04	; 4
     13a:	a8 e7       	ldi	r26, 0x78	; 120
     13c:	b2 e0       	ldi	r27, 0x02	; 2
     13e:	01 c0       	rjmp	.+2      	; 0x142 <.do_clear_bss_start>

00000140 <.do_clear_bss_loop>:
     140:	1d 92       	st	X+, r1

00000142 <.do_clear_bss_start>:
     142:	a8 3f       	cpi	r26, 0xF8	; 248
     144:	b2 07       	cpc	r27, r18
     146:	e1 f7       	brne	.-8      	; 0x140 <.do_clear_bss_loop>

00000148 <__do_global_ctors>:
     148:	10 e0       	ldi	r17, 0x00	; 0
     14a:	c9 e8       	ldi	r28, 0x89	; 137
     14c:	d0 e0       	ldi	r29, 0x00	; 0
     14e:	04 c0       	rjmp	.+8      	; 0x158 <__do_global_ctors+0x10>
     150:	21 97       	sbiw	r28, 0x01	; 1
     152:	fe 01       	movw	r30, r28
     154:	0e 94 fe 21 	call	0x43fc	; 0x43fc <__tablejump2__>
     158:	c6 38       	cpi	r28, 0x86	; 134
     15a:	d1 07       	cpc	r29, r17
     15c:	c9 f7       	brne	.-14     	; 0x150 <__do_global_ctors+0x8>
     15e:	0e 94 34 10 	call	0x2068	; 0x2068 <main>
     162:	0c 94 79 23 	jmp	0x46f2	; 0x46f2 <__do_global_dtors>

00000166 <__bad_interrupt>:
     166:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

0000016a <_ZN11EEPROMClass4readEi.isra.0>:

    EERef( const int index )
        : index( index )                 {}
    
    //Access/read members.
    uint8_t operator*() const            { return eeprom_read_byte( (uint8_t*) index ); }
     16a:	0c 94 63 23 	jmp	0x46c6	; 0x46c6 <eeprom_read_byte>

0000016e <_ZN10DFRobot_PHC1Ev>:
#define EEPROM_read(address, p)  {int i = 0; byte *pp = (byte*)&(p);for(; i < sizeof(p); i++) pp[i]=EEPROM.read(address+i);}

#define PHVALUEADDR 0x00    //the start address of the pH calibration parameters stored in the EEPROM


DFRobot_PH::DFRobot_PH()
     16e:	fc 01       	movw	r30, r24
{
    this->_temperature    = 25.0;
     170:	80 e0       	ldi	r24, 0x00	; 0
     172:	90 e0       	ldi	r25, 0x00	; 0
     174:	a8 ec       	ldi	r26, 0xC8	; 200
     176:	b1 e4       	ldi	r27, 0x41	; 65
     178:	80 8b       	std	Z+16, r24	; 0x10
     17a:	91 8b       	std	Z+17, r25	; 0x11
     17c:	a2 8b       	std	Z+18, r26	; 0x12
     17e:	b3 8b       	std	Z+19, r27	; 0x13
    this->_phValue        = 7.0;
     180:	80 e0       	ldi	r24, 0x00	; 0
     182:	90 e0       	ldi	r25, 0x00	; 0
     184:	a0 ee       	ldi	r26, 0xE0	; 224
     186:	b0 e4       	ldi	r27, 0x40	; 64
     188:	80 83       	st	Z, r24
     18a:	91 83       	std	Z+1, r25	; 0x01
     18c:	a2 83       	std	Z+2, r26	; 0x02
     18e:	b3 83       	std	Z+3, r27	; 0x03
    this->_acidVoltage    = 2032.44;    //buffer solution 4.0 at 25C
     190:	84 e1       	ldi	r24, 0x14	; 20
     192:	9e e0       	ldi	r25, 0x0E	; 14
     194:	ae ef       	ldi	r26, 0xFE	; 254
     196:	b4 e4       	ldi	r27, 0x44	; 68
     198:	84 83       	std	Z+4, r24	; 0x04
     19a:	95 83       	std	Z+5, r25	; 0x05
     19c:	a6 83       	std	Z+6, r26	; 0x06
     19e:	b7 83       	std	Z+7, r27	; 0x07
    this->_neutralVoltage = 1500.0;     //buffer solution 7.0 at 25C
     1a0:	80 e0       	ldi	r24, 0x00	; 0
     1a2:	90 e8       	ldi	r25, 0x80	; 128
     1a4:	ab eb       	ldi	r26, 0xBB	; 187
     1a6:	b4 e4       	ldi	r27, 0x44	; 68
     1a8:	80 87       	std	Z+8, r24	; 0x08
     1aa:	91 87       	std	Z+9, r25	; 0x09
     1ac:	a2 87       	std	Z+10, r26	; 0x0a
     1ae:	b3 87       	std	Z+11, r27	; 0x0b
    this->_voltage        = 1500.0;
     1b0:	84 87       	std	Z+12, r24	; 0x0c
     1b2:	95 87       	std	Z+13, r25	; 0x0d
     1b4:	a6 87       	std	Z+14, r26	; 0x0e
     1b6:	b7 87       	std	Z+15, r27	; 0x0f
     1b8:	08 95       	ret

000001ba <_ZN10DFRobot_PHD1Ev>:
}

DFRobot_PH::~DFRobot_PH()
     1ba:	08 95       	ret

000001bc <_ZN10DFRobot_PH5beginEv>:
{

}

void DFRobot_PH::begin()
{
     1bc:	cf 92       	push	r12
     1be:	df 92       	push	r13
     1c0:	ef 92       	push	r14
     1c2:	ff 92       	push	r15
     1c4:	0f 93       	push	r16
     1c6:	1f 93       	push	r17
     1c8:	cf 93       	push	r28
     1ca:	df 93       	push	r29
     1cc:	ec 01       	movw	r28, r24
    EEPROM_read(PHVALUEADDR, this->_neutralVoltage);  //load the neutral (pH = 7.0)voltage of the pH board from the EEPROM
     1ce:	7c 01       	movw	r14, r24
     1d0:	88 e0       	ldi	r24, 0x08	; 8
     1d2:	e8 0e       	add	r14, r24
     1d4:	f1 1c       	adc	r15, r1
     1d6:	67 01       	movw	r12, r14
     1d8:	00 e0       	ldi	r16, 0x00	; 0
     1da:	10 e0       	ldi	r17, 0x00	; 0
     1dc:	c8 01       	movw	r24, r16
     1de:	0e 94 b5 00 	call	0x16a	; 0x16a <_ZN11EEPROMClass4readEi.isra.0>
     1e2:	f6 01       	movw	r30, r12
     1e4:	81 93       	st	Z+, r24
     1e6:	6f 01       	movw	r12, r30
     1e8:	0f 5f       	subi	r16, 0xFF	; 255
     1ea:	1f 4f       	sbci	r17, 0xFF	; 255
     1ec:	04 30       	cpi	r16, 0x04	; 4
     1ee:	11 05       	cpc	r17, r1
     1f0:	a9 f7       	brne	.-22     	; 0x1dc <_ZN10DFRobot_PH5beginEv+0x20>
    Serial.print("_neutralVoltage:");
     1f2:	68 e3       	ldi	r22, 0x38	; 56
     1f4:	71 e0       	ldi	r23, 0x01	; 1
     1f6:	88 eb       	ldi	r24, 0xB8	; 184
     1f8:	93 e0       	ldi	r25, 0x03	; 3
     1fa:	0e 94 91 10 	call	0x2122	; 0x2122 <_ZN5Print5printEPKc>
    Serial.println(this->_neutralVoltage);
     1fe:	48 85       	ldd	r20, Y+8	; 0x08
     200:	59 85       	ldd	r21, Y+9	; 0x09
     202:	6a 85       	ldd	r22, Y+10	; 0x0a
     204:	7b 85       	ldd	r23, Y+11	; 0x0b
     206:	22 e0       	ldi	r18, 0x02	; 2
     208:	30 e0       	ldi	r19, 0x00	; 0
     20a:	88 eb       	ldi	r24, 0xB8	; 184
     20c:	93 e0       	ldi	r25, 0x03	; 3
     20e:	0e 94 61 12 	call	0x24c2	; 0x24c2 <_ZN5Print7printlnEdi>
    if(EEPROM.read(PHVALUEADDR)==0xFF && EEPROM.read(PHVALUEADDR+1)==0xFF && EEPROM.read(PHVALUEADDR+2)==0xFF && EEPROM.read(PHVALUEADDR+3)==0xFF){
     212:	80 e0       	ldi	r24, 0x00	; 0
     214:	90 e0       	ldi	r25, 0x00	; 0
     216:	0e 94 b5 00 	call	0x16a	; 0x16a <_ZN11EEPROMClass4readEi.isra.0>
     21a:	8f 3f       	cpi	r24, 0xFF	; 255
     21c:	39 f5       	brne	.+78     	; 0x26c <_ZN10DFRobot_PH5beginEv+0xb0>
     21e:	81 e0       	ldi	r24, 0x01	; 1
     220:	90 e0       	ldi	r25, 0x00	; 0
     222:	0e 94 b5 00 	call	0x16a	; 0x16a <_ZN11EEPROMClass4readEi.isra.0>
     226:	8f 3f       	cpi	r24, 0xFF	; 255
     228:	09 f5       	brne	.+66     	; 0x26c <_ZN10DFRobot_PH5beginEv+0xb0>
     22a:	82 e0       	ldi	r24, 0x02	; 2
     22c:	90 e0       	ldi	r25, 0x00	; 0
     22e:	0e 94 b5 00 	call	0x16a	; 0x16a <_ZN11EEPROMClass4readEi.isra.0>
     232:	8f 3f       	cpi	r24, 0xFF	; 255
     234:	d9 f4       	brne	.+54     	; 0x26c <_ZN10DFRobot_PH5beginEv+0xb0>
     236:	83 e0       	ldi	r24, 0x03	; 3
     238:	90 e0       	ldi	r25, 0x00	; 0
     23a:	0e 94 b5 00 	call	0x16a	; 0x16a <_ZN11EEPROMClass4readEi.isra.0>
     23e:	8f 3f       	cpi	r24, 0xFF	; 255
     240:	a9 f4       	brne	.+42     	; 0x26c <_ZN10DFRobot_PH5beginEv+0xb0>
        this->_neutralVoltage = 1500.0;  // new EEPROM, write typical voltage
     242:	80 e0       	ldi	r24, 0x00	; 0
     244:	90 e8       	ldi	r25, 0x80	; 128
     246:	ab eb       	ldi	r26, 0xBB	; 187
     248:	b4 e4       	ldi	r27, 0x44	; 68
     24a:	88 87       	std	Y+8, r24	; 0x08
     24c:	99 87       	std	Y+9, r25	; 0x09
     24e:	aa 87       	std	Y+10, r26	; 0x0a
     250:	bb 87       	std	Y+11, r27	; 0x0b
        EEPROM_write(PHVALUEADDR, this->_neutralVoltage);
     252:	00 e0       	ldi	r16, 0x00	; 0
     254:	10 e0       	ldi	r17, 0x00	; 0
     256:	f7 01       	movw	r30, r14
     258:	61 91       	ld	r22, Z+
     25a:	7f 01       	movw	r14, r30
    operator uint8_t() const             { return **this; }
    
    //Assignment/write members.
    EERef &operator=( const EERef &ref ) { return *this = *ref; }
    EERef &operator=( uint8_t in )       { return eeprom_write_byte( (uint8_t*) index, in ), *this;  }
     25c:	c8 01       	movw	r24, r16
     25e:	0e 94 6b 23 	call	0x46d6	; 0x46d6 <eeprom_write_byte>
     262:	0f 5f       	subi	r16, 0xFF	; 255
     264:	1f 4f       	sbci	r17, 0xFF	; 255
     266:	04 30       	cpi	r16, 0x04	; 4
     268:	11 05       	cpc	r17, r1
     26a:	a9 f7       	brne	.-22     	; 0x256 <_ZN10DFRobot_PH5beginEv+0x9a>
    }
    EEPROM_read(PHVALUEADDR+4, this->_acidVoltage);//load the acid (pH = 4.0) voltage of the pH board from the EEPROM
     26c:	7e 01       	movw	r14, r28
     26e:	f4 e0       	ldi	r31, 0x04	; 4
     270:	ef 0e       	add	r14, r31
     272:	f1 1c       	adc	r15, r1
     274:	67 01       	movw	r12, r14
     276:	04 e0       	ldi	r16, 0x04	; 4
     278:	10 e0       	ldi	r17, 0x00	; 0
     27a:	c8 01       	movw	r24, r16
     27c:	0e 94 b5 00 	call	0x16a	; 0x16a <_ZN11EEPROMClass4readEi.isra.0>
     280:	f6 01       	movw	r30, r12
     282:	81 93       	st	Z+, r24
     284:	6f 01       	movw	r12, r30
     286:	0f 5f       	subi	r16, 0xFF	; 255
     288:	1f 4f       	sbci	r17, 0xFF	; 255
     28a:	08 30       	cpi	r16, 0x08	; 8
     28c:	11 05       	cpc	r17, r1
     28e:	a9 f7       	brne	.-22     	; 0x27a <_ZN10DFRobot_PH5beginEv+0xbe>
    Serial.print("_acidVoltage:");
     290:	69 e4       	ldi	r22, 0x49	; 73
     292:	71 e0       	ldi	r23, 0x01	; 1
     294:	88 eb       	ldi	r24, 0xB8	; 184
     296:	93 e0       	ldi	r25, 0x03	; 3
     298:	0e 94 91 10 	call	0x2122	; 0x2122 <_ZN5Print5printEPKc>
    Serial.println(this->_acidVoltage);
     29c:	4c 81       	ldd	r20, Y+4	; 0x04
     29e:	5d 81       	ldd	r21, Y+5	; 0x05
     2a0:	6e 81       	ldd	r22, Y+6	; 0x06
     2a2:	7f 81       	ldd	r23, Y+7	; 0x07
     2a4:	22 e0       	ldi	r18, 0x02	; 2
     2a6:	30 e0       	ldi	r19, 0x00	; 0
     2a8:	88 eb       	ldi	r24, 0xB8	; 184
     2aa:	93 e0       	ldi	r25, 0x03	; 3
     2ac:	0e 94 61 12 	call	0x24c2	; 0x24c2 <_ZN5Print7printlnEdi>
    if(EEPROM.read(PHVALUEADDR+4)==0xFF && EEPROM.read(PHVALUEADDR+5)==0xFF && EEPROM.read(PHVALUEADDR+6)==0xFF && EEPROM.read(PHVALUEADDR+7)==0xFF){
     2b0:	84 e0       	ldi	r24, 0x04	; 4
     2b2:	90 e0       	ldi	r25, 0x00	; 0
     2b4:	0e 94 b5 00 	call	0x16a	; 0x16a <_ZN11EEPROMClass4readEi.isra.0>
     2b8:	8f 3f       	cpi	r24, 0xFF	; 255
     2ba:	31 f5       	brne	.+76     	; 0x308 <_ZN10DFRobot_PH5beginEv+0x14c>
     2bc:	85 e0       	ldi	r24, 0x05	; 5
     2be:	90 e0       	ldi	r25, 0x00	; 0
     2c0:	0e 94 b5 00 	call	0x16a	; 0x16a <_ZN11EEPROMClass4readEi.isra.0>
     2c4:	8f 3f       	cpi	r24, 0xFF	; 255
     2c6:	01 f5       	brne	.+64     	; 0x308 <_ZN10DFRobot_PH5beginEv+0x14c>
     2c8:	86 e0       	ldi	r24, 0x06	; 6
     2ca:	90 e0       	ldi	r25, 0x00	; 0
     2cc:	0e 94 b5 00 	call	0x16a	; 0x16a <_ZN11EEPROMClass4readEi.isra.0>
     2d0:	8f 3f       	cpi	r24, 0xFF	; 255
     2d2:	d1 f4       	brne	.+52     	; 0x308 <_ZN10DFRobot_PH5beginEv+0x14c>
     2d4:	87 e0       	ldi	r24, 0x07	; 7
     2d6:	90 e0       	ldi	r25, 0x00	; 0
     2d8:	0e 94 b5 00 	call	0x16a	; 0x16a <_ZN11EEPROMClass4readEi.isra.0>
     2dc:	8f 3f       	cpi	r24, 0xFF	; 255
     2de:	a1 f4       	brne	.+40     	; 0x308 <_ZN10DFRobot_PH5beginEv+0x14c>
        this->_acidVoltage = 2032.44;  // new EEPROM, write typical voltage
     2e0:	84 e1       	ldi	r24, 0x14	; 20
     2e2:	9e e0       	ldi	r25, 0x0E	; 14
     2e4:	ae ef       	ldi	r26, 0xFE	; 254
     2e6:	b4 e4       	ldi	r27, 0x44	; 68
     2e8:	8c 83       	std	Y+4, r24	; 0x04
     2ea:	9d 83       	std	Y+5, r25	; 0x05
     2ec:	ae 83       	std	Y+6, r26	; 0x06
     2ee:	bf 83       	std	Y+7, r27	; 0x07
     2f0:	c4 e0       	ldi	r28, 0x04	; 4
     2f2:	d0 e0       	ldi	r29, 0x00	; 0
        EEPROM_write(PHVALUEADDR+4, this->_acidVoltage);
     2f4:	f7 01       	movw	r30, r14
     2f6:	61 91       	ld	r22, Z+
     2f8:	7f 01       	movw	r14, r30
     2fa:	ce 01       	movw	r24, r28
     2fc:	0e 94 6b 23 	call	0x46d6	; 0x46d6 <eeprom_write_byte>
     300:	21 96       	adiw	r28, 0x01	; 1
     302:	c8 30       	cpi	r28, 0x08	; 8
     304:	d1 05       	cpc	r29, r1
     306:	b1 f7       	brne	.-20     	; 0x2f4 <_ZN10DFRobot_PH5beginEv+0x138>
    }
}
     308:	df 91       	pop	r29
     30a:	cf 91       	pop	r28
     30c:	1f 91       	pop	r17
     30e:	0f 91       	pop	r16
     310:	ff 90       	pop	r15
     312:	ef 90       	pop	r14
     314:	df 90       	pop	r13
     316:	cf 90       	pop	r12
     318:	08 95       	ret

0000031a <_ZN10DFRobot_PH6readPHEff>:

float DFRobot_PH::readPH(float voltage, float temperature)
{
     31a:	4f 92       	push	r4
     31c:	5f 92       	push	r5
     31e:	6f 92       	push	r6
     320:	7f 92       	push	r7
     322:	8f 92       	push	r8
     324:	9f 92       	push	r9
     326:	af 92       	push	r10
     328:	bf 92       	push	r11
     32a:	cf 92       	push	r12
     32c:	df 92       	push	r13
     32e:	ef 92       	push	r14
     330:	ff 92       	push	r15
     332:	cf 93       	push	r28
     334:	df 93       	push	r29
     336:	ec 01       	movw	r28, r24
     338:	2a 01       	movw	r4, r20
     33a:	3b 01       	movw	r6, r22
    float slope = (7.0-4.0)/((this->_neutralVoltage-1500.0)/3.0 - (this->_acidVoltage-1500.0)/3.0);  // two point: (_neutralVoltage,7.0),(_acidVoltage,4.0)
     33c:	20 e0       	ldi	r18, 0x00	; 0
     33e:	30 e8       	ldi	r19, 0x80	; 128
     340:	4b eb       	ldi	r20, 0xBB	; 187
     342:	54 e4       	ldi	r21, 0x44	; 68
     344:	68 85       	ldd	r22, Y+8	; 0x08
     346:	79 85       	ldd	r23, Y+9	; 0x09
     348:	8a 85       	ldd	r24, Y+10	; 0x0a
     34a:	9b 85       	ldd	r25, Y+11	; 0x0b
     34c:	0e 94 26 0c 	call	0x184c	; 0x184c <__subsf3>
     350:	4b 01       	movw	r8, r22
     352:	5c 01       	movw	r10, r24
     354:	20 e0       	ldi	r18, 0x00	; 0
     356:	30 e0       	ldi	r19, 0x00	; 0
     358:	40 e4       	ldi	r20, 0x40	; 64
     35a:	50 e4       	ldi	r21, 0x40	; 64
     35c:	0e 94 98 0c 	call	0x1930	; 0x1930 <__divsf3>
     360:	6b 01       	movw	r12, r22
     362:	7c 01       	movw	r14, r24
     364:	20 e0       	ldi	r18, 0x00	; 0
     366:	30 e8       	ldi	r19, 0x80	; 128
     368:	4b eb       	ldi	r20, 0xBB	; 187
     36a:	54 e4       	ldi	r21, 0x44	; 68
     36c:	6c 81       	ldd	r22, Y+4	; 0x04
     36e:	7d 81       	ldd	r23, Y+5	; 0x05
     370:	8e 81       	ldd	r24, Y+6	; 0x06
     372:	9f 81       	ldd	r25, Y+7	; 0x07
     374:	0e 94 26 0c 	call	0x184c	; 0x184c <__subsf3>
     378:	20 e0       	ldi	r18, 0x00	; 0
     37a:	30 e0       	ldi	r19, 0x00	; 0
     37c:	40 e4       	ldi	r20, 0x40	; 64
     37e:	50 e4       	ldi	r21, 0x40	; 64
     380:	0e 94 98 0c 	call	0x1930	; 0x1930 <__divsf3>
     384:	9b 01       	movw	r18, r22
     386:	ac 01       	movw	r20, r24
     388:	c7 01       	movw	r24, r14
     38a:	b6 01       	movw	r22, r12
     38c:	0e 94 26 0c 	call	0x184c	; 0x184c <__subsf3>
     390:	9b 01       	movw	r18, r22
     392:	ac 01       	movw	r20, r24
     394:	60 e0       	ldi	r22, 0x00	; 0
     396:	70 e0       	ldi	r23, 0x00	; 0
     398:	80 e4       	ldi	r24, 0x40	; 64
     39a:	90 e4       	ldi	r25, 0x40	; 64
     39c:	0e 94 98 0c 	call	0x1930	; 0x1930 <__divsf3>
     3a0:	6b 01       	movw	r12, r22
     3a2:	7c 01       	movw	r14, r24
    float intercept =  7.0 - slope*(this->_neutralVoltage-1500.0)/3.0;
    //Serial.print("slope:");
    //Serial.print(slope);
    //Serial.print(",intercept:");
    //Serial.println(intercept);
    this->_phValue = slope*(voltage-1500.0)/3.0+intercept;  //y = k*x + b
     3a4:	9b 01       	movw	r18, r22
     3a6:	ac 01       	movw	r20, r24
     3a8:	c5 01       	movw	r24, r10
     3aa:	b4 01       	movw	r22, r8
     3ac:	0e 94 f7 0d 	call	0x1bee	; 0x1bee <__mulsf3>
     3b0:	20 e0       	ldi	r18, 0x00	; 0
     3b2:	30 e0       	ldi	r19, 0x00	; 0
     3b4:	40 e4       	ldi	r20, 0x40	; 64
     3b6:	50 e4       	ldi	r21, 0x40	; 64
     3b8:	0e 94 98 0c 	call	0x1930	; 0x1930 <__divsf3>
     3bc:	9b 01       	movw	r18, r22
     3be:	ac 01       	movw	r20, r24
     3c0:	60 e0       	ldi	r22, 0x00	; 0
     3c2:	70 e0       	ldi	r23, 0x00	; 0
     3c4:	80 ee       	ldi	r24, 0xE0	; 224
     3c6:	90 e4       	ldi	r25, 0x40	; 64
     3c8:	0e 94 26 0c 	call	0x184c	; 0x184c <__subsf3>
     3cc:	4b 01       	movw	r8, r22
     3ce:	5c 01       	movw	r10, r24
     3d0:	20 e0       	ldi	r18, 0x00	; 0
     3d2:	30 e8       	ldi	r19, 0x80	; 128
     3d4:	4b eb       	ldi	r20, 0xBB	; 187
     3d6:	54 e4       	ldi	r21, 0x44	; 68
     3d8:	c3 01       	movw	r24, r6
     3da:	b2 01       	movw	r22, r4
     3dc:	0e 94 26 0c 	call	0x184c	; 0x184c <__subsf3>
     3e0:	a7 01       	movw	r20, r14
     3e2:	96 01       	movw	r18, r12
     3e4:	0e 94 f7 0d 	call	0x1bee	; 0x1bee <__mulsf3>
     3e8:	20 e0       	ldi	r18, 0x00	; 0
     3ea:	30 e0       	ldi	r19, 0x00	; 0
     3ec:	40 e4       	ldi	r20, 0x40	; 64
     3ee:	50 e4       	ldi	r21, 0x40	; 64
     3f0:	0e 94 98 0c 	call	0x1930	; 0x1930 <__divsf3>
     3f4:	9b 01       	movw	r18, r22
     3f6:	ac 01       	movw	r20, r24
     3f8:	c5 01       	movw	r24, r10
     3fa:	b4 01       	movw	r22, r8
     3fc:	0e 94 27 0c 	call	0x184e	; 0x184e <__addsf3>
     400:	68 83       	st	Y, r22
     402:	79 83       	std	Y+1, r23	; 0x01
     404:	8a 83       	std	Y+2, r24	; 0x02
     406:	9b 83       	std	Y+3, r25	; 0x03
    return _phValue;
}
     408:	df 91       	pop	r29
     40a:	cf 91       	pop	r28
     40c:	ff 90       	pop	r15
     40e:	ef 90       	pop	r14
     410:	df 90       	pop	r13
     412:	cf 90       	pop	r12
     414:	bf 90       	pop	r11
     416:	af 90       	pop	r10
     418:	9f 90       	pop	r9
     41a:	8f 90       	pop	r8
     41c:	7f 90       	pop	r7
     41e:	6f 90       	pop	r6
     420:	5f 90       	pop	r5
     422:	4f 90       	pop	r4
     424:	08 95       	ret

00000426 <_ZN5Print5writeEPKc>:
    int getWriteError() { return write_error; }
    void clearWriteError() { setWriteError(0); }
  
    virtual size_t write(uint8_t) = 0;
    size_t write(const char *str) {
      if (str == NULL) return 0;
     426:	61 15       	cp	r22, r1
     428:	71 05       	cpc	r23, r1
     42a:	79 f0       	breq	.+30     	; 0x44a <_ZN5Print5writeEPKc+0x24>
      return write((const uint8_t *)str, strlen(str));
     42c:	fb 01       	movw	r30, r22
     42e:	01 90       	ld	r0, Z+
     430:	00 20       	and	r0, r0
     432:	e9 f7       	brne	.-6      	; 0x42e <_ZN5Print5writeEPKc+0x8>
     434:	31 97       	sbiw	r30, 0x01	; 1
     436:	af 01       	movw	r20, r30
     438:	46 1b       	sub	r20, r22
     43a:	57 0b       	sbc	r21, r23
     43c:	dc 01       	movw	r26, r24
     43e:	ed 91       	ld	r30, X+
     440:	fc 91       	ld	r31, X
     442:	02 80       	ldd	r0, Z+2	; 0x02
     444:	f3 81       	ldd	r31, Z+3	; 0x03
     446:	e0 2d       	mov	r30, r0
     448:	09 94       	ijmp
    }
     44a:	80 e0       	ldi	r24, 0x00	; 0
     44c:	90 e0       	ldi	r25, 0x00	; 0
     44e:	08 95       	ret

00000450 <_ZN14HardwareSerial5writeEi>:
    virtual void flush(void);
    virtual size_t write(uint8_t);
    inline size_t write(unsigned long n) { return write((uint8_t)n); }
    inline size_t write(long n) { return write((uint8_t)n); }
    inline size_t write(unsigned int n) { return write((uint8_t)n); }
    inline size_t write(int n) { return write((uint8_t)n); }
     450:	dc 01       	movw	r26, r24
     452:	ed 91       	ld	r30, X+
     454:	fc 91       	ld	r31, X
     456:	01 90       	ld	r0, Z+
     458:	f0 81       	ld	r31, Z
     45a:	e0 2d       	mov	r30, r0
     45c:	09 94       	ijmp

0000045e <_Z11measureTempv>:

OneWire ds(TEMP_PIN); // Temp sensor on pin 7


/* measureTemp() returns the measured temperature in degrees Celsius */
float measureTemp() {
     45e:	cf 92       	push	r12
     460:	df 92       	push	r13
     462:	ff 92       	push	r15
     464:	0f 93       	push	r16
     466:	1f 93       	push	r17
     468:	cf 93       	push	r28
     46a:	df 93       	push	r29
     46c:	cd b7       	in	r28, 0x3d	; 61
     46e:	de b7       	in	r29, 0x3e	; 62
     470:	64 97       	sbiw	r28, 0x14	; 20
     472:	0f b6       	in	r0, 0x3f	; 63
     474:	f8 94       	cli
     476:	de bf       	out	0x3e, r29	; 62
     478:	0f be       	out	0x3f, r0	; 63
     47a:	cd bf       	out	0x3d, r28	; 61
	byte type_s;
	byte data[12];
	byte addr[8];
	float celsius, fahrenheit;
	
	ds.reset_search();
     47c:	8a e8       	ldi	r24, 0x8A	; 138
     47e:	93 e0       	ldi	r25, 0x03	; 3
     480:	0e 94 6f 09 	call	0x12de	; 0x12de <_ZN7OneWire12reset_searchEv>
	delay(250);
     484:	6a ef       	ldi	r22, 0xFA	; 250
     486:	70 e0       	ldi	r23, 0x00	; 0
     488:	80 e0       	ldi	r24, 0x00	; 0
     48a:	90 e0       	ldi	r25, 0x00	; 0
     48c:	0e 94 51 13 	call	0x26a2	; 0x26a2 <delay>
	ds.search(addr);
     490:	41 e0       	ldi	r20, 0x01	; 1
     492:	be 01       	movw	r22, r28
     494:	63 5f       	subi	r22, 0xF3	; 243
     496:	7f 4f       	sbci	r23, 0xFF	; 255
     498:	8a e8       	ldi	r24, 0x8A	; 138
     49a:	93 e0       	ldi	r25, 0x03	; 3
     49c:	0e 94 9e 09 	call	0x133c	; 0x133c <_ZN7OneWire6searchEPhb>

	if (OneWire::crc8(addr, 7) != addr[7]) {
     4a0:	67 e0       	ldi	r22, 0x07	; 7
     4a2:	ce 01       	movw	r24, r28
     4a4:	0d 96       	adiw	r24, 0x0d	; 13
     4a6:	0e 94 25 0a 	call	0x144a	; 0x144a <_ZN7OneWire4crc8EPKhh>
     4aa:	9c 89       	ldd	r25, Y+20	; 0x14
     4ac:	89 17       	cp	r24, r25
     4ae:	19 f0       	breq	.+6      	; 0x4b6 <_Z11measureTempv+0x58>
		Serial.println("CRC is not valid!");
     4b0:	6c e6       	ldi	r22, 0x6C	; 108
     4b2:	71 e0       	ldi	r23, 0x01	; 1
     4b4:	09 c0       	rjmp	.+18     	; 0x4c8 <_Z11measureTempv+0x6a>
		return -1;
	}
//	Serial.println();
	
	// the first ROM byte indicates which chip
	switch (addr[0]) {
     4b6:	8d 85       	ldd	r24, Y+13	; 0x0d
     4b8:	82 32       	cpi	r24, 0x22	; 34
     4ba:	91 f0       	breq	.+36     	; 0x4e0 <_Z11measureTempv+0x82>
     4bc:	88 32       	cpi	r24, 0x28	; 40
     4be:	81 f0       	breq	.+32     	; 0x4e0 <_Z11measureTempv+0x82>
     4c0:	80 31       	cpi	r24, 0x10	; 16
     4c2:	59 f0       	breq	.+22     	; 0x4da <_Z11measureTempv+0x7c>
		case 0x22:
		//Serial.println("  Chip = DS1822");
		type_s = 0;
		break;
		default:
		Serial.println("Device is not a DS18x20 family device.");
     4c4:	6e e7       	ldi	r22, 0x7E	; 126
     4c6:	71 e0       	ldi	r23, 0x01	; 1
     4c8:	88 eb       	ldi	r24, 0xB8	; 184
     4ca:	93 e0       	ldi	r25, 0x03	; 3
     4cc:	0e 94 9e 10 	call	0x213c	; 0x213c <_ZN5Print7printlnEPKc>
		return -1;
     4d0:	60 e0       	ldi	r22, 0x00	; 0
     4d2:	70 e0       	ldi	r23, 0x00	; 0
     4d4:	80 e8       	ldi	r24, 0x80	; 128
     4d6:	9f eb       	ldi	r25, 0xBF	; 191
     4d8:	6a c0       	rjmp	.+212    	; 0x5ae <_Z11measureTempv+0x150>
	
	// the first ROM byte indicates which chip
	switch (addr[0]) {
		case 0x10:
		//Serial.println("  Chip = DS18S20");  // or old DS1820
		type_s = 1;
     4da:	ff 24       	eor	r15, r15
     4dc:	f3 94       	inc	r15
     4de:	01 c0       	rjmp	.+2      	; 0x4e2 <_Z11measureTempv+0x84>
		break;
		case 0x28:
		//Serial.println("  Chip = DS18B20");
		type_s = 0;
     4e0:	f1 2c       	mov	r15, r1
		default:
		Serial.println("Device is not a DS18x20 family device.");
		return -1;
	}

	ds.reset();
     4e2:	8a e8       	ldi	r24, 0x8A	; 138
     4e4:	93 e0       	ldi	r25, 0x03	; 3
     4e6:	0e 94 63 08 	call	0x10c6	; 0x10c6 <_ZN7OneWire5resetEv>
	ds.select(addr);
     4ea:	be 01       	movw	r22, r28
     4ec:	63 5f       	subi	r22, 0xF3	; 243
     4ee:	7f 4f       	sbci	r23, 0xFF	; 255
     4f0:	8a e8       	ldi	r24, 0x8A	; 138
     4f2:	93 e0       	ldi	r25, 0x03	; 3
     4f4:	0e 94 50 09 	call	0x12a0	; 0x12a0 <_ZN7OneWire6selectEPKh>
	ds.write(0x44, 1);        // start conversion, with parasite power on at the end
     4f8:	41 e0       	ldi	r20, 0x01	; 1
     4fa:	64 e4       	ldi	r22, 0x44	; 68
     4fc:	8a e8       	ldi	r24, 0x8A	; 138
     4fe:	93 e0       	ldi	r25, 0x03	; 3
     500:	0e 94 00 09 	call	0x1200	; 0x1200 <_ZN7OneWire5writeEhh>
	
	delay(1000);     // maybe 750ms is enough, maybe not
     504:	68 ee       	ldi	r22, 0xE8	; 232
     506:	73 e0       	ldi	r23, 0x03	; 3
     508:	80 e0       	ldi	r24, 0x00	; 0
     50a:	90 e0       	ldi	r25, 0x00	; 0
     50c:	0e 94 51 13 	call	0x26a2	; 0x26a2 <delay>
	// we might do a ds.depower() here, but the reset will take care of it.
	
	present = ds.reset();
     510:	8a e8       	ldi	r24, 0x8A	; 138
     512:	93 e0       	ldi	r25, 0x03	; 3
     514:	0e 94 63 08 	call	0x10c6	; 0x10c6 <_ZN7OneWire5resetEv>
	ds.select(addr);
     518:	be 01       	movw	r22, r28
     51a:	63 5f       	subi	r22, 0xF3	; 243
     51c:	7f 4f       	sbci	r23, 0xFF	; 255
     51e:	8a e8       	ldi	r24, 0x8A	; 138
     520:	93 e0       	ldi	r25, 0x03	; 3
     522:	0e 94 50 09 	call	0x12a0	; 0x12a0 <_ZN7OneWire6selectEPKh>
	ds.write(0xBE);         // Read Scratchpad
     526:	40 e0       	ldi	r20, 0x00	; 0
     528:	6e eb       	ldi	r22, 0xBE	; 190
     52a:	8a e8       	ldi	r24, 0x8A	; 138
     52c:	93 e0       	ldi	r25, 0x03	; 3
     52e:	0e 94 00 09 	call	0x1200	; 0x1200 <_ZN7OneWire5writeEhh>
     532:	8e 01       	movw	r16, r28
     534:	0f 5f       	subi	r16, 0xFF	; 255
     536:	1f 4f       	sbci	r17, 0xFF	; 255
     538:	6e 01       	movw	r12, r28
     53a:	8a e0       	ldi	r24, 0x0A	; 10
     53c:	c8 0e       	add	r12, r24
     53e:	d1 1c       	adc	r13, r1

	//Serial.print("  Data = ");
	//Serial.print(present, HEX);
	//Serial.print(" ");
	for ( i = 0; i < 9; i++) {           // we need 9 bytes
		data[i] = ds.read();
     540:	8a e8       	ldi	r24, 0x8A	; 138
     542:	93 e0       	ldi	r25, 0x03	; 3
     544:	0e 94 34 09 	call	0x1268	; 0x1268 <_ZN7OneWire4readEv>
     548:	f8 01       	movw	r30, r16
     54a:	81 93       	st	Z+, r24
     54c:	8f 01       	movw	r16, r30
	ds.write(0xBE);         // Read Scratchpad

	//Serial.print("  Data = ");
	//Serial.print(present, HEX);
	//Serial.print(" ");
	for ( i = 0; i < 9; i++) {           // we need 9 bytes
     54e:	ec 15       	cp	r30, r12
     550:	fd 05       	cpc	r31, r13
     552:	b1 f7       	brne	.-20     	; 0x540 <_Z11measureTempv+0xe2>

	// Convert the data to actual temperature
	// because the result is a 16 bit signed integer, it should
	// be stored to an "int16_t" type, which is always 16 bits
	// even when compiled on a 32 bit processor.
	int16_t raw = (data[1] << 8) | data[0];
     554:	69 81       	ldd	r22, Y+1	; 0x01
     556:	7a 81       	ldd	r23, Y+2	; 0x02
	if (type_s) {
     558:	ff 20       	and	r15, r15
     55a:	89 f0       	breq	.+34     	; 0x57e <_Z11measureTempv+0x120>
		raw = raw << 3; // 9 bit resolution default
     55c:	83 e0       	ldi	r24, 0x03	; 3
     55e:	66 0f       	add	r22, r22
     560:	77 1f       	adc	r23, r23
     562:	8a 95       	dec	r24
     564:	e1 f7       	brne	.-8      	; 0x55e <_Z11measureTempv+0x100>
		if (data[7] == 0x10) {
     566:	88 85       	ldd	r24, Y+8	; 0x08
     568:	80 31       	cpi	r24, 0x10	; 16
     56a:	a9 f4       	brne	.+42     	; 0x596 <_Z11measureTempv+0x138>
			// "count remain" gives full 12 bit resolution
			raw = (raw & 0xFFF0) + 12 - data[6];
     56c:	2f 81       	ldd	r18, Y+7	; 0x07
     56e:	8c e0       	ldi	r24, 0x0C	; 12
     570:	90 e0       	ldi	r25, 0x00	; 0
     572:	82 1b       	sub	r24, r18
     574:	91 09       	sbc	r25, r1
     576:	60 7f       	andi	r22, 0xF0	; 240
     578:	68 0f       	add	r22, r24
     57a:	79 1f       	adc	r23, r25
     57c:	0c c0       	rjmp	.+24     	; 0x596 <_Z11measureTempv+0x138>
		}
		} else {
		byte cfg = (data[4] & 0x60);
     57e:	8d 81       	ldd	r24, Y+5	; 0x05
     580:	80 76       	andi	r24, 0x60	; 96
		// at lower res, the low bits are undefined, so let's zero them
		if (cfg == 0x00) raw = raw & ~7;  // 9 bit resolution, 93.75 ms
     582:	11 f4       	brne	.+4      	; 0x588 <_Z11measureTempv+0x12a>
     584:	68 7f       	andi	r22, 0xF8	; 248
     586:	07 c0       	rjmp	.+14     	; 0x596 <_Z11measureTempv+0x138>
		else if (cfg == 0x20) raw = raw & ~3; // 10 bit res, 187.5 ms
     588:	80 32       	cpi	r24, 0x20	; 32
     58a:	11 f4       	brne	.+4      	; 0x590 <_Z11measureTempv+0x132>
     58c:	6c 7f       	andi	r22, 0xFC	; 252
     58e:	03 c0       	rjmp	.+6      	; 0x596 <_Z11measureTempv+0x138>
		else if (cfg == 0x40) raw = raw & ~1; // 11 bit res, 375 ms
     590:	80 34       	cpi	r24, 0x40	; 64
     592:	09 f4       	brne	.+2      	; 0x596 <_Z11measureTempv+0x138>
     594:	6e 7f       	andi	r22, 0xFE	; 254
		//// default is 12 bit resolution, 750 ms conversion time
	}
	celsius = (float)raw / 16.0;
     596:	07 2e       	mov	r0, r23
     598:	00 0c       	add	r0, r0
     59a:	88 0b       	sbc	r24, r24
     59c:	99 0b       	sbc	r25, r25
     59e:	0e 94 42 0d 	call	0x1a84	; 0x1a84 <__floatsisf>
     5a2:	20 e0       	ldi	r18, 0x00	; 0
     5a4:	30 e0       	ldi	r19, 0x00	; 0
     5a6:	40 e8       	ldi	r20, 0x80	; 128
     5a8:	5d e3       	ldi	r21, 0x3D	; 61
     5aa:	0e 94 f7 0d 	call	0x1bee	; 0x1bee <__mulsf3>
	//Serial.print(celsius);
	//Serial.print(" Celsius, ");
	//Serial.print(fahrenheit);
	//Serial.println(" Fahrenheit");
	return celsius;
     5ae:	64 96       	adiw	r28, 0x14	; 20
     5b0:	0f b6       	in	r0, 0x3f	; 63
     5b2:	f8 94       	cli
     5b4:	de bf       	out	0x3e, r29	; 62
     5b6:	0f be       	out	0x3f, r0	; 63
     5b8:	cd bf       	out	0x3d, r28	; 61
     5ba:	df 91       	pop	r29
     5bc:	cf 91       	pop	r28
     5be:	1f 91       	pop	r17
     5c0:	0f 91       	pop	r16
     5c2:	ff 90       	pop	r15
     5c4:	df 90       	pop	r13
     5c6:	cf 90       	pop	r12
     5c8:	08 95       	ret

000005ca <_Z9addColorsv>:
MD_TCS230  CS(S2, S3, OE);


// add possible color strip values to specific arrays
void addColors()
{
     5ca:	0f 93       	push	r16
     5cc:	1f 93       	push	r17
     5ce:	cf 93       	push	r28
     5d0:	df 93       	push	r29
	int index = 0;
	Color c;
	c.ppm = 0.0;
	c.p = {0, 0, 0};
	Ammonia[index] = c;
     5d2:	c7 e5       	ldi	r28, 0x57	; 87
     5d4:	d3 e0       	ldi	r29, 0x03	; 3
     5d6:	18 82       	st	Y, r1
     5d8:	19 82       	std	Y+1, r1	; 0x01
     5da:	1a 82       	std	Y+2, r1	; 0x02
     5dc:	1b 82       	std	Y+3, r1	; 0x03
     5de:	1d 82       	std	Y+5, r1	; 0x05
     5e0:	1c 82       	std	Y+4, r1	; 0x04
     5e2:	1f 82       	std	Y+7, r1	; 0x07
     5e4:	1e 82       	std	Y+6, r1	; 0x06
     5e6:	19 86       	std	Y+9, r1	; 0x09
     5e8:	18 86       	std	Y+8, r1	; 0x08

	c.ppm = 0.0;
	c.p = {255, 95, 95};
	Nitrite[index] = c;
     5ea:	a1 e1       	ldi	r26, 0x11	; 17
     5ec:	b3 e0       	ldi	r27, 0x03	; 3
     5ee:	1d 92       	st	X+, r1
     5f0:	1d 92       	st	X+, r1
     5f2:	1d 92       	st	X+, r1
     5f4:	1c 92       	st	X, r1
     5f6:	13 97       	sbiw	r26, 0x03	; 3
     5f8:	2f ef       	ldi	r18, 0xFF	; 255
     5fa:	30 e0       	ldi	r19, 0x00	; 0
     5fc:	15 96       	adiw	r26, 0x05	; 5
     5fe:	3c 93       	st	X, r19
     600:	2e 93       	st	-X, r18
     602:	14 97       	sbiw	r26, 0x04	; 4
     604:	8f e5       	ldi	r24, 0x5F	; 95
     606:	90 e0       	ldi	r25, 0x00	; 0
     608:	17 96       	adiw	r26, 0x07	; 7
     60a:	9c 93       	st	X, r25
     60c:	8e 93       	st	-X, r24
     60e:	16 97       	sbiw	r26, 0x06	; 6
     610:	19 96       	adiw	r26, 0x09	; 9
     612:	9c 93       	st	X, r25
     614:	8e 93       	st	-X, r24
     616:	18 97       	sbiw	r26, 0x08	; 8

	c.ppm = 0.0;
	c.p = {255, 95, 95};
	Nitrate[index] = c;
     618:	eb ec       	ldi	r30, 0xCB	; 203
     61a:	f2 e0       	ldi	r31, 0x02	; 2
     61c:	10 82       	st	Z, r1
     61e:	11 82       	std	Z+1, r1	; 0x01
     620:	12 82       	std	Z+2, r1	; 0x02
     622:	13 82       	std	Z+3, r1	; 0x03
     624:	35 83       	std	Z+5, r19	; 0x05
     626:	24 83       	std	Z+4, r18	; 0x04
     628:	97 83       	std	Z+7, r25	; 0x07
     62a:	86 83       	std	Z+6, r24	; 0x06
     62c:	91 87       	std	Z+9, r25	; 0x09
     62e:	80 87       	std	Z+8, r24	; 0x08

	++index;

	c.ppm = 0.25;
	c.p = {0, 0, 0};
	Ammonia[index] = c;
     630:	40 e0       	ldi	r20, 0x00	; 0
     632:	50 e0       	ldi	r21, 0x00	; 0
     634:	60 e8       	ldi	r22, 0x80	; 128
     636:	7e e3       	ldi	r23, 0x3E	; 62
     638:	4a 87       	std	Y+10, r20	; 0x0a
     63a:	5b 87       	std	Y+11, r21	; 0x0b
     63c:	6c 87       	std	Y+12, r22	; 0x0c
     63e:	7d 87       	std	Y+13, r23	; 0x0d
     640:	1f 86       	std	Y+15, r1	; 0x0f
     642:	1e 86       	std	Y+14, r1	; 0x0e
     644:	19 8a       	std	Y+17, r1	; 0x11
     646:	18 8a       	std	Y+16, r1	; 0x10
     648:	1b 8a       	std	Y+19, r1	; 0x13
     64a:	1a 8a       	std	Y+18, r1	; 0x12

	c.ppm = 0.15;
	c.p = {0, 0, 0};
	Nitrite[index] = c;
     64c:	4a e9       	ldi	r20, 0x9A	; 154
     64e:	59 e9       	ldi	r21, 0x99	; 153
     650:	69 e1       	ldi	r22, 0x19	; 25
     652:	7e e3       	ldi	r23, 0x3E	; 62
     654:	1a 96       	adiw	r26, 0x0a	; 10
     656:	4d 93       	st	X+, r20
     658:	5d 93       	st	X+, r21
     65a:	6d 93       	st	X+, r22
     65c:	7c 93       	st	X, r23
     65e:	1d 97       	sbiw	r26, 0x0d	; 13
     660:	1f 96       	adiw	r26, 0x0f	; 15
     662:	1c 92       	st	X, r1
     664:	1e 92       	st	-X, r1
     666:	1e 97       	sbiw	r26, 0x0e	; 14
     668:	51 96       	adiw	r26, 0x11	; 17
     66a:	1c 92       	st	X, r1
     66c:	1e 92       	st	-X, r1
     66e:	50 97       	sbiw	r26, 0x10	; 16
     670:	53 96       	adiw	r26, 0x13	; 19
     672:	1c 92       	st	X, r1
     674:	1e 92       	st	-X, r1
     676:	52 97       	sbiw	r26, 0x12	; 18

	c.ppm = 0.5;
	c.p = {0, 0, 0};
	Nitrate[index] = c;
     678:	40 e0       	ldi	r20, 0x00	; 0
     67a:	50 e0       	ldi	r21, 0x00	; 0
     67c:	60 e0       	ldi	r22, 0x00	; 0
     67e:	7f e3       	ldi	r23, 0x3F	; 63
     680:	42 87       	std	Z+10, r20	; 0x0a
     682:	53 87       	std	Z+11, r21	; 0x0b
     684:	64 87       	std	Z+12, r22	; 0x0c
     686:	75 87       	std	Z+13, r23	; 0x0d
     688:	17 86       	std	Z+15, r1	; 0x0f
     68a:	16 86       	std	Z+14, r1	; 0x0e
     68c:	11 8a       	std	Z+17, r1	; 0x11
     68e:	10 8a       	std	Z+16, r1	; 0x10
     690:	13 8a       	std	Z+19, r1	; 0x13
     692:	12 8a       	std	Z+18, r1	; 0x12

	++index;

	c.ppm = 0.5;
	c.p = {0, 0, 0};
	Ammonia[index] = c;
     694:	4c 8b       	std	Y+20, r20	; 0x14
     696:	5d 8b       	std	Y+21, r21	; 0x15
     698:	6e 8b       	std	Y+22, r22	; 0x16
     69a:	7f 8b       	std	Y+23, r23	; 0x17
     69c:	19 8e       	std	Y+25, r1	; 0x19
     69e:	18 8e       	std	Y+24, r1	; 0x18
     6a0:	1b 8e       	std	Y+27, r1	; 0x1b
     6a2:	1a 8e       	std	Y+26, r1	; 0x1a
     6a4:	1d 8e       	std	Y+29, r1	; 0x1d
     6a6:	1c 8e       	std	Y+28, r1	; 0x1c

	c.ppm = 0.3;
	c.p = {0, 0, 0};
	Nitrite[index] = c;
     6a8:	4a e9       	ldi	r20, 0x9A	; 154
     6aa:	59 e9       	ldi	r21, 0x99	; 153
     6ac:	69 e9       	ldi	r22, 0x99	; 153
     6ae:	7e e3       	ldi	r23, 0x3E	; 62
     6b0:	54 96       	adiw	r26, 0x14	; 20
     6b2:	4d 93       	st	X+, r20
     6b4:	5d 93       	st	X+, r21
     6b6:	6d 93       	st	X+, r22
     6b8:	7c 93       	st	X, r23
     6ba:	57 97       	sbiw	r26, 0x17	; 23
     6bc:	59 96       	adiw	r26, 0x19	; 25
     6be:	1c 92       	st	X, r1
     6c0:	1e 92       	st	-X, r1
     6c2:	58 97       	sbiw	r26, 0x18	; 24
     6c4:	5b 96       	adiw	r26, 0x1b	; 27
     6c6:	1c 92       	st	X, r1
     6c8:	1e 92       	st	-X, r1
     6ca:	5a 97       	sbiw	r26, 0x1a	; 26
     6cc:	5d 96       	adiw	r26, 0x1d	; 29
     6ce:	1c 92       	st	X, r1
     6d0:	1e 92       	st	-X, r1
     6d2:	5c 97       	sbiw	r26, 0x1c	; 28

	c.ppm = 2.0;
	c.p = {0, 0, 0};
	Nitrate[index] = c;
     6d4:	40 e0       	ldi	r20, 0x00	; 0
     6d6:	50 e0       	ldi	r21, 0x00	; 0
     6d8:	60 e0       	ldi	r22, 0x00	; 0
     6da:	70 e4       	ldi	r23, 0x40	; 64
     6dc:	44 8b       	std	Z+20, r20	; 0x14
     6de:	55 8b       	std	Z+21, r21	; 0x15
     6e0:	66 8b       	std	Z+22, r22	; 0x16
     6e2:	77 8b       	std	Z+23, r23	; 0x17
     6e4:	11 8e       	std	Z+25, r1	; 0x19
     6e6:	10 8e       	std	Z+24, r1	; 0x18
     6e8:	13 8e       	std	Z+27, r1	; 0x1b
     6ea:	12 8e       	std	Z+26, r1	; 0x1a
     6ec:	15 8e       	std	Z+29, r1	; 0x1d
     6ee:	14 8e       	std	Z+28, r1	; 0x1c

	++index;

	c.ppm = 3.0;
	c.p = {0, 0, 0};
	Ammonia[index] = c;
     6f0:	00 e0       	ldi	r16, 0x00	; 0
     6f2:	10 e0       	ldi	r17, 0x00	; 0
     6f4:	20 e4       	ldi	r18, 0x40	; 64
     6f6:	30 e4       	ldi	r19, 0x40	; 64
     6f8:	0e 8f       	std	Y+30, r16	; 0x1e
     6fa:	1f 8f       	std	Y+31, r17	; 0x1f
     6fc:	28 a3       	std	Y+32, r18	; 0x20
     6fe:	39 a3       	std	Y+33, r19	; 0x21
     700:	1b a2       	std	Y+35, r1	; 0x23
     702:	1a a2       	std	Y+34, r1	; 0x22
     704:	1d a2       	std	Y+37, r1	; 0x25
     706:	1c a2       	std	Y+36, r1	; 0x24
     708:	1f a2       	std	Y+39, r1	; 0x27
     70a:	1e a2       	std	Y+38, r1	; 0x26

	c.ppm = 1.0;
	c.p = {0, 0, 0};
	Nitrite[index] = c;
     70c:	40 e0       	ldi	r20, 0x00	; 0
     70e:	50 e0       	ldi	r21, 0x00	; 0
     710:	60 e8       	ldi	r22, 0x80	; 128
     712:	7f e3       	ldi	r23, 0x3F	; 63
     714:	5e 96       	adiw	r26, 0x1e	; 30
     716:	4d 93       	st	X+, r20
     718:	5d 93       	st	X+, r21
     71a:	6d 93       	st	X+, r22
     71c:	7c 93       	st	X, r23
     71e:	91 97       	sbiw	r26, 0x21	; 33
     720:	93 96       	adiw	r26, 0x23	; 35
     722:	1c 92       	st	X, r1
     724:	1e 92       	st	-X, r1
     726:	92 97       	sbiw	r26, 0x22	; 34
     728:	95 96       	adiw	r26, 0x25	; 37
     72a:	1c 92       	st	X, r1
     72c:	1e 92       	st	-X, r1
     72e:	94 97       	sbiw	r26, 0x24	; 36
     730:	97 96       	adiw	r26, 0x27	; 39
     732:	1c 92       	st	X, r1
     734:	1e 92       	st	-X, r1
     736:	96 97       	sbiw	r26, 0x26	; 38

	c.ppm = 5.0;
	c.p = {0, 0, 0};
	Nitrate[index] = c;
     738:	40 e0       	ldi	r20, 0x00	; 0
     73a:	50 e0       	ldi	r21, 0x00	; 0
     73c:	60 ea       	ldi	r22, 0xA0	; 160
     73e:	70 e4       	ldi	r23, 0x40	; 64
     740:	46 8f       	std	Z+30, r20	; 0x1e
     742:	57 8f       	std	Z+31, r21	; 0x1f
     744:	60 a3       	std	Z+32, r22	; 0x20
     746:	71 a3       	std	Z+33, r23	; 0x21
     748:	13 a2       	std	Z+35, r1	; 0x23
     74a:	12 a2       	std	Z+34, r1	; 0x22
     74c:	15 a2       	std	Z+37, r1	; 0x25
     74e:	14 a2       	std	Z+36, r1	; 0x24
     750:	17 a2       	std	Z+39, r1	; 0x27
     752:	16 a2       	std	Z+38, r1	; 0x26

	++index;

	c.ppm = 6.0;
	c.p = {0, 0, 0};
	Ammonia[index] = c;
     754:	40 e0       	ldi	r20, 0x00	; 0
     756:	50 e0       	ldi	r21, 0x00	; 0
     758:	60 ec       	ldi	r22, 0xC0	; 192
     75a:	70 e4       	ldi	r23, 0x40	; 64
     75c:	48 a7       	std	Y+40, r20	; 0x28
     75e:	59 a7       	std	Y+41, r21	; 0x29
     760:	6a a7       	std	Y+42, r22	; 0x2a
     762:	7b a7       	std	Y+43, r23	; 0x2b
     764:	1d a6       	std	Y+45, r1	; 0x2d
     766:	1c a6       	std	Y+44, r1	; 0x2c
     768:	1f a6       	std	Y+47, r1	; 0x2f
     76a:	1e a6       	std	Y+46, r1	; 0x2e
     76c:	19 aa       	std	Y+49, r1	; 0x31
     76e:	18 aa       	std	Y+48, r1	; 0x30

	c.ppm = 1.5;
	c.p = {0, 0, 0};
	Nitrite[index] = c;
     770:	40 e0       	ldi	r20, 0x00	; 0
     772:	50 e0       	ldi	r21, 0x00	; 0
     774:	60 ec       	ldi	r22, 0xC0	; 192
     776:	7f e3       	ldi	r23, 0x3F	; 63
     778:	98 96       	adiw	r26, 0x28	; 40
     77a:	4d 93       	st	X+, r20
     77c:	5d 93       	st	X+, r21
     77e:	6d 93       	st	X+, r22
     780:	7c 93       	st	X, r23
     782:	9b 97       	sbiw	r26, 0x2b	; 43
     784:	9d 96       	adiw	r26, 0x2d	; 45
     786:	1c 92       	st	X, r1
     788:	1e 92       	st	-X, r1
     78a:	9c 97       	sbiw	r26, 0x2c	; 44
     78c:	9f 96       	adiw	r26, 0x2f	; 47
     78e:	1c 92       	st	X, r1
     790:	1e 92       	st	-X, r1
     792:	9e 97       	sbiw	r26, 0x2e	; 46
     794:	d1 96       	adiw	r26, 0x31	; 49
     796:	1c 92       	st	X, r1
     798:	1e 92       	st	-X, r1
     79a:	d0 97       	sbiw	r26, 0x30	; 48

	c.ppm = 10.0;
	c.p = {0, 0, 0};
	Nitrate[index] = c;
     79c:	40 e0       	ldi	r20, 0x00	; 0
     79e:	50 e0       	ldi	r21, 0x00	; 0
     7a0:	60 e2       	ldi	r22, 0x20	; 32
     7a2:	71 e4       	ldi	r23, 0x41	; 65
     7a4:	40 a7       	std	Z+40, r20	; 0x28
     7a6:	51 a7       	std	Z+41, r21	; 0x29
     7a8:	62 a7       	std	Z+42, r22	; 0x2a
     7aa:	73 a7       	std	Z+43, r23	; 0x2b
     7ac:	15 a6       	std	Z+45, r1	; 0x2d
     7ae:	14 a6       	std	Z+44, r1	; 0x2c
     7b0:	17 a6       	std	Z+47, r1	; 0x2f
     7b2:	16 a6       	std	Z+46, r1	; 0x2e
     7b4:	11 aa       	std	Z+49, r1	; 0x31
     7b6:	10 aa       	std	Z+48, r1	; 0x30

	++index;

	c.ppm = 3.0;
	c.p = {0, 0, 0};
	Nitrite[index] = c;
     7b8:	d2 96       	adiw	r26, 0x32	; 50
     7ba:	0d 93       	st	X+, r16
     7bc:	1d 93       	st	X+, r17
     7be:	2d 93       	st	X+, r18
     7c0:	3c 93       	st	X, r19
     7c2:	d5 97       	sbiw	r26, 0x35	; 53
     7c4:	d7 96       	adiw	r26, 0x37	; 55
     7c6:	1c 92       	st	X, r1
     7c8:	1e 92       	st	-X, r1
     7ca:	d6 97       	sbiw	r26, 0x36	; 54
     7cc:	d9 96       	adiw	r26, 0x39	; 57
     7ce:	1c 92       	st	X, r1
     7d0:	1e 92       	st	-X, r1
     7d2:	d8 97       	sbiw	r26, 0x38	; 56
     7d4:	db 96       	adiw	r26, 0x3b	; 59
     7d6:	1c 92       	st	X, r1
     7d8:	1e 92       	st	-X, r1
     7da:	da 97       	sbiw	r26, 0x3a	; 58

	c.ppm = 20.0;
	c.p = {0, 0, 0};
	Nitrate[index] = c;
     7dc:	00 e0       	ldi	r16, 0x00	; 0
     7de:	10 e0       	ldi	r17, 0x00	; 0
     7e0:	20 ea       	ldi	r18, 0xA0	; 160
     7e2:	31 e4       	ldi	r19, 0x41	; 65
     7e4:	02 ab       	std	Z+50, r16	; 0x32
     7e6:	13 ab       	std	Z+51, r17	; 0x33
     7e8:	24 ab       	std	Z+52, r18	; 0x34
     7ea:	35 ab       	std	Z+53, r19	; 0x35
     7ec:	17 aa       	std	Z+55, r1	; 0x37
     7ee:	16 aa       	std	Z+54, r1	; 0x36
     7f0:	11 ae       	std	Z+57, r1	; 0x39
     7f2:	10 ae       	std	Z+56, r1	; 0x38
     7f4:	13 ae       	std	Z+59, r1	; 0x3b
     7f6:	12 ae       	std	Z+58, r1	; 0x3a

	++index;

	c.ppm = 10.0;
	c.p = {0, 0, 0};
	Nitrite[index] = c;
     7f8:	dc 96       	adiw	r26, 0x3c	; 60
     7fa:	4d 93       	st	X+, r20
     7fc:	5d 93       	st	X+, r21
     7fe:	6d 93       	st	X+, r22
     800:	7c 93       	st	X, r23
     802:	df 97       	sbiw	r26, 0x3f	; 63
     804:	10 92 52 03 	sts	0x0352, r1	; 0x800352 <Nitrite+0x41>
     808:	10 92 51 03 	sts	0x0351, r1	; 0x800351 <Nitrite+0x40>
     80c:	10 92 54 03 	sts	0x0354, r1	; 0x800354 <Nitrite+0x43>
     810:	10 92 53 03 	sts	0x0353, r1	; 0x800353 <Nitrite+0x42>
     814:	10 92 56 03 	sts	0x0356, r1	; 0x800356 <Nitrite+0x45>
     818:	10 92 55 03 	sts	0x0355, r1	; 0x800355 <Nitrite+0x44>

	c.ppm = 50.0;
	c.p = {0, 0, 0};
	Nitrate[index] = c;
     81c:	80 e0       	ldi	r24, 0x00	; 0
     81e:	90 e0       	ldi	r25, 0x00	; 0
     820:	a8 e4       	ldi	r26, 0x48	; 72
     822:	b2 e4       	ldi	r27, 0x42	; 66
     824:	84 af       	std	Z+60, r24	; 0x3c
     826:	95 af       	std	Z+61, r25	; 0x3d
     828:	a6 af       	std	Z+62, r26	; 0x3e
     82a:	b7 af       	std	Z+63, r27	; 0x3f
     82c:	10 92 0c 03 	sts	0x030C, r1	; 0x80030c <Nitrate+0x41>
     830:	10 92 0b 03 	sts	0x030B, r1	; 0x80030b <Nitrate+0x40>
     834:	10 92 0e 03 	sts	0x030E, r1	; 0x80030e <Nitrate+0x43>
     838:	10 92 0d 03 	sts	0x030D, r1	; 0x80030d <Nitrate+0x42>
     83c:	10 92 10 03 	sts	0x0310, r1	; 0x800310 <Nitrate+0x45>
     840:	10 92 0f 03 	sts	0x030F, r1	; 0x80030f <Nitrate+0x44>
}
     844:	df 91       	pop	r29
     846:	cf 91       	pop	r28
     848:	1f 91       	pop	r17
     84a:	0f 91       	pop	r16
     84c:	08 95       	ret

0000084e <_Z9SameColorv>:


bool SameColor()
{
	Serial.print("c: ");
     84e:	65 ea       	ldi	r22, 0xA5	; 165
     850:	71 e0       	ldi	r23, 0x01	; 1
     852:	88 eb       	ldi	r24, 0xB8	; 184
     854:	93 e0       	ldi	r25, 0x03	; 3
     856:	0e 94 91 10 	call	0x2122	; 0x2122 <_ZN5Print5printEPKc>
	Serial.print(c.p.R);
     85a:	60 91 c2 02 	lds	r22, 0x02C2	; 0x8002c2 <c+0x4>
     85e:	70 91 c3 02 	lds	r23, 0x02C3	; 0x8002c3 <c+0x5>
     862:	4a e0       	ldi	r20, 0x0A	; 10
     864:	50 e0       	ldi	r21, 0x00	; 0
     866:	88 eb       	ldi	r24, 0xB8	; 184
     868:	93 e0       	ldi	r25, 0x03	; 3
     86a:	0e 94 6d 11 	call	0x22da	; 0x22da <_ZN5Print5printEii>
	Serial.print(" ");
     86e:	67 ea       	ldi	r22, 0xA7	; 167
     870:	71 e0       	ldi	r23, 0x01	; 1
     872:	88 eb       	ldi	r24, 0xB8	; 184
     874:	93 e0       	ldi	r25, 0x03	; 3
     876:	0e 94 91 10 	call	0x2122	; 0x2122 <_ZN5Print5printEPKc>
	Serial.print(c.p.G);
     87a:	60 91 c4 02 	lds	r22, 0x02C4	; 0x8002c4 <c+0x6>
     87e:	70 91 c5 02 	lds	r23, 0x02C5	; 0x8002c5 <c+0x7>
     882:	4a e0       	ldi	r20, 0x0A	; 10
     884:	50 e0       	ldi	r21, 0x00	; 0
     886:	88 eb       	ldi	r24, 0xB8	; 184
     888:	93 e0       	ldi	r25, 0x03	; 3
     88a:	0e 94 6d 11 	call	0x22da	; 0x22da <_ZN5Print5printEii>
	Serial.print(" ");
     88e:	67 ea       	ldi	r22, 0xA7	; 167
     890:	71 e0       	ldi	r23, 0x01	; 1
     892:	88 eb       	ldi	r24, 0xB8	; 184
     894:	93 e0       	ldi	r25, 0x03	; 3
     896:	0e 94 91 10 	call	0x2122	; 0x2122 <_ZN5Print5printEPKc>
	Serial.print(c.p.B);
     89a:	60 91 c6 02 	lds	r22, 0x02C6	; 0x8002c6 <c+0x8>
     89e:	70 91 c7 02 	lds	r23, 0x02C7	; 0x8002c7 <c+0x9>
     8a2:	4a e0       	ldi	r20, 0x0A	; 10
     8a4:	50 e0       	ldi	r21, 0x00	; 0
     8a6:	88 eb       	ldi	r24, 0xB8	; 184
     8a8:	93 e0       	ldi	r25, 0x03	; 3
     8aa:	0e 94 6d 11 	call	0x22da	; 0x22da <_ZN5Print5printEii>
	Serial.print("read_in: ");
     8ae:	69 ea       	ldi	r22, 0xA9	; 169
     8b0:	71 e0       	ldi	r23, 0x01	; 1
     8b2:	88 eb       	ldi	r24, 0xB8	; 184
     8b4:	93 e0       	ldi	r25, 0x03	; 3
     8b6:	0e 94 91 10 	call	0x2122	; 0x2122 <_ZN5Print5printEPKc>
	Serial.print(redScanned);
     8ba:	4a e0       	ldi	r20, 0x0A	; 10
     8bc:	50 e0       	ldi	r21, 0x00	; 0
     8be:	60 91 bc 02 	lds	r22, 0x02BC	; 0x8002bc <redScanned>
     8c2:	88 eb       	ldi	r24, 0xB8	; 184
     8c4:	93 e0       	ldi	r25, 0x03	; 3
     8c6:	0e 94 06 11 	call	0x220c	; 0x220c <_ZN5Print5printEhi>
	Serial.print(" ");
     8ca:	67 ea       	ldi	r22, 0xA7	; 167
     8cc:	71 e0       	ldi	r23, 0x01	; 1
     8ce:	88 eb       	ldi	r24, 0xB8	; 184
     8d0:	93 e0       	ldi	r25, 0x03	; 3
     8d2:	0e 94 91 10 	call	0x2122	; 0x2122 <_ZN5Print5printEPKc>
	Serial.print(greenScanned);
     8d6:	4a e0       	ldi	r20, 0x0A	; 10
     8d8:	50 e0       	ldi	r21, 0x00	; 0
     8da:	60 91 bd 02 	lds	r22, 0x02BD	; 0x8002bd <greenScanned>
     8de:	88 eb       	ldi	r24, 0xB8	; 184
     8e0:	93 e0       	ldi	r25, 0x03	; 3
     8e2:	0e 94 06 11 	call	0x220c	; 0x220c <_ZN5Print5printEhi>
	Serial.print(" ");
     8e6:	67 ea       	ldi	r22, 0xA7	; 167
     8e8:	71 e0       	ldi	r23, 0x01	; 1
     8ea:	88 eb       	ldi	r24, 0xB8	; 184
     8ec:	93 e0       	ldi	r25, 0x03	; 3
     8ee:	0e 94 91 10 	call	0x2122	; 0x2122 <_ZN5Print5printEPKc>
	Serial.print(blueScanned);
     8f2:	4a e0       	ldi	r20, 0x0A	; 10
     8f4:	50 e0       	ldi	r21, 0x00	; 0
     8f6:	60 91 bb 02 	lds	r22, 0x02BB	; 0x8002bb <blueScanned>
     8fa:	88 eb       	ldi	r24, 0xB8	; 184
     8fc:	93 e0       	ldi	r25, 0x03	; 3
     8fe:	0e 94 06 11 	call	0x220c	; 0x220c <_ZN5Print5printEhi>
	// check if RGB values are within range specified by tolerance
	if (redScanned < (c.p.R - TOLERANCE) || redScanned > (c.p.R + TOLERANCE))
     902:	20 91 bc 02 	lds	r18, 0x02BC	; 0x8002bc <redScanned>
     906:	30 e0       	ldi	r19, 0x00	; 0
     908:	80 91 c2 02 	lds	r24, 0x02C2	; 0x8002c2 <c+0x4>
     90c:	90 91 c3 02 	lds	r25, 0x02C3	; 0x8002c3 <c+0x5>
     910:	ac 01       	movw	r20, r24
     912:	45 50       	subi	r20, 0x05	; 5
     914:	51 09       	sbc	r21, r1
     916:	24 17       	cp	r18, r20
     918:	35 07       	cpc	r19, r21
     91a:	74 f1       	brlt	.+92     	; 0x978 <__stack+0x79>
     91c:	05 96       	adiw	r24, 0x05	; 5
     91e:	82 17       	cp	r24, r18
     920:	93 07       	cpc	r25, r19
     922:	54 f1       	brlt	.+84     	; 0x978 <__stack+0x79>
		return false;
	if (greenScanned < (c.p.G - TOLERANCE) || greenScanned > (c.p.G + TOLERANCE))
     924:	20 91 bd 02 	lds	r18, 0x02BD	; 0x8002bd <greenScanned>
     928:	30 e0       	ldi	r19, 0x00	; 0
     92a:	80 91 c4 02 	lds	r24, 0x02C4	; 0x8002c4 <c+0x6>
     92e:	90 91 c5 02 	lds	r25, 0x02C5	; 0x8002c5 <c+0x7>
     932:	ac 01       	movw	r20, r24
     934:	45 50       	subi	r20, 0x05	; 5
     936:	51 09       	sbc	r21, r1
     938:	24 17       	cp	r18, r20
     93a:	35 07       	cpc	r19, r21
     93c:	ec f0       	brlt	.+58     	; 0x978 <__stack+0x79>
     93e:	05 96       	adiw	r24, 0x05	; 5
     940:	82 17       	cp	r24, r18
     942:	93 07       	cpc	r25, r19
     944:	cc f0       	brlt	.+50     	; 0x978 <__stack+0x79>
		return false;
	if (blueScanned < (c.p.B - TOLERANCE) || blueScanned > (c.p.B + TOLERANCE))
     946:	20 91 bb 02 	lds	r18, 0x02BB	; 0x8002bb <blueScanned>
     94a:	30 e0       	ldi	r19, 0x00	; 0
     94c:	80 91 c6 02 	lds	r24, 0x02C6	; 0x8002c6 <c+0x8>
     950:	90 91 c7 02 	lds	r25, 0x02C7	; 0x8002c7 <c+0x9>
     954:	ac 01       	movw	r20, r24
     956:	45 50       	subi	r20, 0x05	; 5
     958:	51 09       	sbc	r21, r1
     95a:	24 17       	cp	r18, r20
     95c:	35 07       	cpc	r19, r21
     95e:	64 f0       	brlt	.+24     	; 0x978 <__stack+0x79>
     960:	05 96       	adiw	r24, 0x05	; 5
     962:	82 17       	cp	r24, r18
     964:	93 07       	cpc	r25, r19
     966:	44 f0       	brlt	.+16     	; 0x978 <__stack+0x79>
		return false;
	
	Serial.print(F("\nFound Matching Color"));
     968:	6c e7       	ldi	r22, 0x7C	; 124
     96a:	70 e0       	ldi	r23, 0x00	; 0
     96c:	88 eb       	ldi	r24, 0xB8	; 184
     96e:	93 e0       	ldi	r25, 0x03	; 3
     970:	0e 94 6d 10 	call	0x20da	; 0x20da <_ZN5Print5printEPK19__FlashStringHelper>
	return true;
     974:	81 e0       	ldi	r24, 0x01	; 1
     976:	08 95       	ret
	Serial.print(greenScanned);
	Serial.print(" ");
	Serial.print(blueScanned);
	// check if RGB values are within range specified by tolerance
	if (redScanned < (c.p.R - TOLERANCE) || redScanned > (c.p.R + TOLERANCE))
		return false;
     978:	80 e0       	ldi	r24, 0x00	; 0
	if (blueScanned < (c.p.B - TOLERANCE) || blueScanned > (c.p.B + TOLERANCE))
		return false;
	
	Serial.print(F("\nFound Matching Color"));
	return true;
}
     97a:	08 95       	ret

0000097c <_Z9FindMatchv>:

double FindMatch()
{
     97c:	0f 93       	push	r16
     97e:	1f 93       	push	r17
     980:	cf 93       	push	r28
     982:	df 93       	push	r29
	switch(typeToRead)
     984:	80 91 89 03 	lds	r24, 0x0389	; 0x800389 <typeToRead>
     988:	81 30       	cpi	r24, 0x01	; 1
     98a:	09 f4       	brne	.+2      	; 0x98e <_Z9FindMatchv+0x12>
     98c:	48 c0       	rjmp	.+144    	; 0xa1e <_Z9FindMatchv+0xa2>
     98e:	40 f0       	brcs	.+16     	; 0x9a0 <_Z9FindMatchv+0x24>
     990:	82 30       	cpi	r24, 0x02	; 2
     992:	09 f0       	breq	.+2      	; 0x996 <_Z9FindMatchv+0x1a>
     994:	6e c0       	rjmp	.+220    	; 0xa72 <_Z9FindMatchv+0xf6>
     996:	01 e1       	ldi	r16, 0x11	; 17
     998:	13 e0       	ldi	r17, 0x03	; 3
     99a:	c6 e0       	ldi	r28, 0x06	; 6
     99c:	d0 e0       	ldi	r29, 0x00	; 0
     99e:	29 c0       	rjmp	.+82     	; 0x9f2 <_Z9FindMatchv+0x76>
     9a0:	07 e5       	ldi	r16, 0x57	; 87
     9a2:	13 e0       	ldi	r17, 0x03	; 3
     9a4:	c4 e0       	ldi	r28, 0x04	; 4
     9a6:	d0 e0       	ldi	r29, 0x00	; 0
		case AMMONIA:
		{
			// start at highest ammonia level - false positive better than false negative
			for(int i = MAX_AMMONIA_COLORS - 1; i >= 0; --i)
			{
				c = Ammonia[i];
     9a8:	8a e0       	ldi	r24, 0x0A	; 10
     9aa:	f8 01       	movw	r30, r16
     9ac:	b8 96       	adiw	r30, 0x28	; 40
     9ae:	ae eb       	ldi	r26, 0xBE	; 190
     9b0:	b2 e0       	ldi	r27, 0x02	; 2
     9b2:	01 90       	ld	r0, Z+
     9b4:	0d 92       	st	X+, r0
     9b6:	8a 95       	dec	r24
     9b8:	e1 f7       	brne	.-8      	; 0x9b2 <_Z9FindMatchv+0x36>
				if(SameColor())
     9ba:	0e 94 27 04 	call	0x84e	; 0x84e <_Z9SameColorv>
     9be:	88 23       	and	r24, r24
     9c0:	49 f0       	breq	.+18     	; 0x9d4 <_Z9FindMatchv+0x58>
				return Ammonia[i].ppm;
     9c2:	8a e0       	ldi	r24, 0x0A	; 10
     9c4:	8c 9f       	mul	r24, r28
     9c6:	f0 01       	movw	r30, r0
     9c8:	8d 9f       	mul	r24, r29
     9ca:	f0 0d       	add	r31, r0
     9cc:	11 24       	eor	r1, r1
     9ce:	e9 5a       	subi	r30, 0xA9	; 169
     9d0:	fc 4f       	sbci	r31, 0xFC	; 252
     9d2:	3e c0       	rjmp	.+124    	; 0xa50 <_Z9FindMatchv+0xd4>
	switch(typeToRead)
	{
		case AMMONIA:
		{
			// start at highest ammonia level - false positive better than false negative
			for(int i = MAX_AMMONIA_COLORS - 1; i >= 0; --i)
     9d4:	21 97       	sbiw	r28, 0x01	; 1
     9d6:	0a 50       	subi	r16, 0x0A	; 10
     9d8:	11 09       	sbc	r17, r1
     9da:	cf 3f       	cpi	r28, 0xFF	; 255
     9dc:	8f ef       	ldi	r24, 0xFF	; 255
     9de:	d8 07       	cpc	r29, r24
     9e0:	19 f7       	brne	.-58     	; 0x9a8 <_Z9FindMatchv+0x2c>
     9e2:	42 c0       	rjmp	.+132    	; 0xa68 <_Z9FindMatchv+0xec>
			break;
		}
		case NITRITE:
		{
			// start at highest nitrite level - false positive better than false negative
			for(int i = MAX_NITRITE_NITRATE_COLORS - 1; i >= 0; --i)
     9e4:	21 97       	sbiw	r28, 0x01	; 1
     9e6:	0a 50       	subi	r16, 0x0A	; 10
     9e8:	11 09       	sbc	r17, r1
     9ea:	cf 3f       	cpi	r28, 0xFF	; 255
     9ec:	8f ef       	ldi	r24, 0xFF	; 255
     9ee:	d8 07       	cpc	r29, r24
     9f0:	d9 f1       	breq	.+118    	; 0xa68 <_Z9FindMatchv+0xec>
			{
				c = Nitrite[i];
     9f2:	8a e0       	ldi	r24, 0x0A	; 10
     9f4:	f8 01       	movw	r30, r16
     9f6:	fc 96       	adiw	r30, 0x3c	; 60
     9f8:	ae eb       	ldi	r26, 0xBE	; 190
     9fa:	b2 e0       	ldi	r27, 0x02	; 2
     9fc:	01 90       	ld	r0, Z+
     9fe:	0d 92       	st	X+, r0
     a00:	8a 95       	dec	r24
     a02:	e1 f7       	brne	.-8      	; 0x9fc <_Z9FindMatchv+0x80>
				if(SameColor())
     a04:	0e 94 27 04 	call	0x84e	; 0x84e <_Z9SameColorv>
     a08:	88 23       	and	r24, r24
     a0a:	61 f3       	breq	.-40     	; 0x9e4 <_Z9FindMatchv+0x68>
				return Nitrite[i].ppm;
     a0c:	8a e0       	ldi	r24, 0x0A	; 10
     a0e:	8c 9f       	mul	r24, r28
     a10:	f0 01       	movw	r30, r0
     a12:	8d 9f       	mul	r24, r29
     a14:	f0 0d       	add	r31, r0
     a16:	11 24       	eor	r1, r1
     a18:	ef 5e       	subi	r30, 0xEF	; 239
     a1a:	fc 4f       	sbci	r31, 0xFC	; 252
     a1c:	19 c0       	rjmp	.+50     	; 0xa50 <_Z9FindMatchv+0xd4>
     a1e:	0b ec       	ldi	r16, 0xCB	; 203
     a20:	12 e0       	ldi	r17, 0x02	; 2
	return true;
}

double FindMatch()
{
	switch(typeToRead)
     a22:	c6 e0       	ldi	r28, 0x06	; 6
     a24:	d0 e0       	ldi	r29, 0x00	; 0
		case NITRATE:
		{
			// start at highest nitrate level - false positive better than false negative
			for(int i = MAX_NITRITE_NITRATE_COLORS - 1; i >= 0; --i)
			{
				c = Nitrate[i];
     a26:	8a e0       	ldi	r24, 0x0A	; 10
     a28:	f8 01       	movw	r30, r16
     a2a:	fc 96       	adiw	r30, 0x3c	; 60
     a2c:	ae eb       	ldi	r26, 0xBE	; 190
     a2e:	b2 e0       	ldi	r27, 0x02	; 2
     a30:	01 90       	ld	r0, Z+
     a32:	0d 92       	st	X+, r0
     a34:	8a 95       	dec	r24
     a36:	e1 f7       	brne	.-8      	; 0xa30 <_Z9FindMatchv+0xb4>
				if(SameColor())
     a38:	0e 94 27 04 	call	0x84e	; 0x84e <_Z9SameColorv>
     a3c:	88 23       	and	r24, r24
     a3e:	69 f0       	breq	.+26     	; 0xa5a <_Z9FindMatchv+0xde>
				return Nitrate[i].ppm;
     a40:	8a e0       	ldi	r24, 0x0A	; 10
     a42:	8c 9f       	mul	r24, r28
     a44:	f0 01       	movw	r30, r0
     a46:	8d 9f       	mul	r24, r29
     a48:	f0 0d       	add	r31, r0
     a4a:	11 24       	eor	r1, r1
     a4c:	e5 53       	subi	r30, 0x35	; 53
     a4e:	fd 4f       	sbci	r31, 0xFD	; 253
     a50:	30 81       	ld	r19, Z
     a52:	21 81       	ldd	r18, Z+1	; 0x01
     a54:	92 81       	ldd	r25, Z+2	; 0x02
     a56:	83 81       	ldd	r24, Z+3	; 0x03
     a58:	0b c0       	rjmp	.+22     	; 0xa70 <_Z9FindMatchv+0xf4>
			break;
		}
		case NITRATE:
		{
			// start at highest nitrate level - false positive better than false negative
			for(int i = MAX_NITRITE_NITRATE_COLORS - 1; i >= 0; --i)
     a5a:	21 97       	sbiw	r28, 0x01	; 1
     a5c:	0a 50       	subi	r16, 0x0A	; 10
     a5e:	11 09       	sbc	r17, r1
     a60:	cf 3f       	cpi	r28, 0xFF	; 255
     a62:	8f ef       	ldi	r24, 0xFF	; 255
     a64:	d8 07       	cpc	r29, r24
     a66:	f9 f6       	brne	.-66     	; 0xa26 <_Z9FindMatchv+0xaa>
			{
				c = Ammonia[i];
				if(SameColor())
				return Ammonia[i].ppm;
			}
			return -1;
     a68:	30 e0       	ldi	r19, 0x00	; 0
     a6a:	20 e0       	ldi	r18, 0x00	; 0
     a6c:	90 e8       	ldi	r25, 0x80	; 128
     a6e:	8f eb       	ldi	r24, 0xBF	; 191
     a70:	ac 01       	movw	r20, r24
			}
			return -1;
			break;
		}
	}
}
     a72:	63 2f       	mov	r22, r19
     a74:	72 2f       	mov	r23, r18
     a76:	85 2f       	mov	r24, r21
     a78:	94 2f       	mov	r25, r20
     a7a:	df 91       	pop	r29
     a7c:	cf 91       	pop	r28
     a7e:	1f 91       	pop	r17
     a80:	0f 91       	pop	r16
     a82:	08 95       	ret

00000a84 <_Z9ScanColorv>:

long ScanColor()
{
	CS.read();
     a84:	8c e8       	ldi	r24, 0x8C	; 140
     a86:	92 e0       	ldi	r25, 0x02	; 2
     a88:	0e 94 0e 0c 	call	0x181c	; 0x181c <_ZN9MD_TCS2304readEv>
	while(CS.available() == 0);  // wait for read to complete
     a8c:	8c e8       	ldi	r24, 0x8C	; 140
     a8e:	92 e0       	ldi	r25, 0x02	; 2
     a90:	0e 94 18 0c 	call	0x1830	; 0x1830 <_ZN9MD_TCS2309availableEv>
     a94:	88 23       	and	r24, r24
     a96:	d1 f3       	breq	.-12     	; 0xa8c <_Z9ScanColorv+0x8>
	CS.getRGB(&rgb);
     a98:	68 ec       	ldi	r22, 0xC8	; 200
     a9a:	72 e0       	ldi	r23, 0x02	; 2
     a9c:	8c e8       	ldi	r24, 0x8C	; 140
     a9e:	92 e0       	ldi	r25, 0x02	; 2
     aa0:	0e 94 44 0b 	call	0x1688	; 0x1688 <_ZN9MD_TCS2306getRGBEP9colorData>
	greenScanned = rgb.value[TCS230_RGB_G];
     aa4:	80 91 c9 02 	lds	r24, 0x02C9	; 0x8002c9 <rgb+0x1>
     aa8:	80 93 bd 02 	sts	0x02BD, r24	; 0x8002bd <greenScanned>
	redScanned = rgb.value[TCS230_RGB_R];
     aac:	80 91 c8 02 	lds	r24, 0x02C8	; 0x8002c8 <rgb>
     ab0:	80 93 bc 02 	sts	0x02BC, r24	; 0x8002bc <redScanned>
	blueScanned = rgb.value[TCS230_RGB_B];
     ab4:	80 91 ca 02 	lds	r24, 0x02CA	; 0x8002ca <rgb+0x2>
     ab8:	80 93 bb 02 	sts	0x02BB, r24	; 0x8002bb <blueScanned>
	// look for match
	Serial.println("RGB");
     abc:	63 eb       	ldi	r22, 0xB3	; 179
     abe:	71 e0       	ldi	r23, 0x01	; 1
     ac0:	88 eb       	ldi	r24, 0xB8	; 184
     ac2:	93 e0       	ldi	r25, 0x03	; 3
     ac4:	0e 94 9e 10 	call	0x213c	; 0x213c <_ZN5Print7printlnEPKc>
	Serial.println(redScanned);
     ac8:	4a e0       	ldi	r20, 0x0A	; 10
     aca:	50 e0       	ldi	r21, 0x00	; 0
     acc:	60 91 bc 02 	lds	r22, 0x02BC	; 0x8002bc <redScanned>
     ad0:	88 eb       	ldi	r24, 0xB8	; 184
     ad2:	93 e0       	ldi	r25, 0x03	; 3
     ad4:	0e 94 0d 11 	call	0x221a	; 0x221a <_ZN5Print7printlnEhi>
	Serial.println(greenScanned);
     ad8:	4a e0       	ldi	r20, 0x0A	; 10
     ada:	50 e0       	ldi	r21, 0x00	; 0
     adc:	60 91 bd 02 	lds	r22, 0x02BD	; 0x8002bd <greenScanned>
     ae0:	88 eb       	ldi	r24, 0xB8	; 184
     ae2:	93 e0       	ldi	r25, 0x03	; 3
     ae4:	0e 94 0d 11 	call	0x221a	; 0x221a <_ZN5Print7printlnEhi>
	Serial.println(blueScanned);
     ae8:	4a e0       	ldi	r20, 0x0A	; 10
     aea:	50 e0       	ldi	r21, 0x00	; 0
     aec:	60 91 bb 02 	lds	r22, 0x02BB	; 0x8002bb <blueScanned>
     af0:	88 eb       	ldi	r24, 0xB8	; 184
     af2:	93 e0       	ldi	r25, 0x03	; 3
     af4:	0e 94 0d 11 	call	0x221a	; 0x221a <_ZN5Print7printlnEhi>
	//return FindMatch();
}
     af8:	08 95       	ret

00000afa <_Z13findTestStripv>:

bool findTestStrip()
{
     afa:	cf 93       	push	r28
	// Scan for color
	CS.read();
     afc:	8c e8       	ldi	r24, 0x8C	; 140
     afe:	92 e0       	ldi	r25, 0x02	; 2
     b00:	0e 94 0e 0c 	call	0x181c	; 0x181c <_ZN9MD_TCS2304readEv>
	while (CS.available() == 0);
     b04:	8c e8       	ldi	r24, 0x8C	; 140
     b06:	92 e0       	ldi	r25, 0x02	; 2
     b08:	0e 94 18 0c 	call	0x1830	; 0x1830 <_ZN9MD_TCS2309availableEv>
     b0c:	88 23       	and	r24, r24
     b0e:	d1 f3       	breq	.-12     	; 0xb04 <_Z13findTestStripv+0xa>
	CS.getRGB(&rgb);
     b10:	68 ec       	ldi	r22, 0xC8	; 200
     b12:	72 e0       	ldi	r23, 0x02	; 2
     b14:	8c e8       	ldi	r24, 0x8C	; 140
     b16:	92 e0       	ldi	r25, 0x02	; 2
     b18:	0e 94 44 0b 	call	0x1688	; 0x1688 <_ZN9MD_TCS2306getRGBEP9colorData>
	greenScanned = rgb.value[TCS230_RGB_G];
     b1c:	80 91 c9 02 	lds	r24, 0x02C9	; 0x8002c9 <rgb+0x1>
     b20:	80 93 bd 02 	sts	0x02BD, r24	; 0x8002bd <greenScanned>
	redScanned = rgb.value[TCS230_RGB_R];
     b24:	80 91 c8 02 	lds	r24, 0x02C8	; 0x8002c8 <rgb>
     b28:	80 93 bc 02 	sts	0x02BC, r24	; 0x8002bc <redScanned>
	blueScanned = rgb.value[TCS230_RGB_B];
     b2c:	80 91 ca 02 	lds	r24, 0x02CA	; 0x8002ca <rgb+0x2>
     b30:	80 93 bb 02 	sts	0x02BB, r24	; 0x8002bb <blueScanned>
	// look for match against black
	c = EmptyTestBox;
     b34:	8a e0       	ldi	r24, 0x0A	; 10
     b36:	e9 e2       	ldi	r30, 0x29	; 41
     b38:	f1 e0       	ldi	r31, 0x01	; 1
     b3a:	ae eb       	ldi	r26, 0xBE	; 190
     b3c:	b2 e0       	ldi	r27, 0x02	; 2
     b3e:	01 90       	ld	r0, Z+
     b40:	0d 92       	st	X+, r0
     b42:	8a 95       	dec	r24
     b44:	e1 f7       	brne	.-8      	; 0xb3e <_Z13findTestStripv+0x44>
	bool foundEmptyBox = SameColor();
     b46:	0e 94 27 04 	call	0x84e	; 0x84e <_Z9SameColorv>
     b4a:	c8 2f       	mov	r28, r24
	Serial.print(" foundEmptyBox ");
     b4c:	67 eb       	ldi	r22, 0xB7	; 183
     b4e:	71 e0       	ldi	r23, 0x01	; 1
     b50:	88 eb       	ldi	r24, 0xB8	; 184
     b52:	93 e0       	ldi	r25, 0x03	; 3
     b54:	0e 94 91 10 	call	0x2122	; 0x2122 <_ZN5Print5printEPKc>
	Serial.println(foundEmptyBox);
     b58:	6c 2f       	mov	r22, r28
     b5a:	70 e0       	ldi	r23, 0x00	; 0
     b5c:	4a e0       	ldi	r20, 0x0A	; 10
     b5e:	50 e0       	ldi	r21, 0x00	; 0
     b60:	88 eb       	ldi	r24, 0xB8	; 184
     b62:	93 e0       	ldi	r25, 0x03	; 3
     b64:	0e 94 74 11 	call	0x22e8	; 0x22e8 <_ZN5Print7printlnEii>
	Serial.print("\n");
     b68:	6c e5       	ldi	r22, 0x5C	; 92
     b6a:	72 e0       	ldi	r23, 0x02	; 2
     b6c:	88 eb       	ldi	r24, 0xB8	; 184
     b6e:	93 e0       	ldi	r25, 0x03	; 3
     b70:	0e 94 91 10 	call	0x2122	; 0x2122 <_ZN5Print5printEPKc>
	c = WhiteTestStrip;
     b74:	8a e0       	ldi	r24, 0x0A	; 10
     b76:	ef e1       	ldi	r30, 0x1F	; 31
     b78:	f1 e0       	ldi	r31, 0x01	; 1
     b7a:	ae eb       	ldi	r26, 0xBE	; 190
     b7c:	b2 e0       	ldi	r27, 0x02	; 2
     b7e:	01 90       	ld	r0, Z+
     b80:	0d 92       	st	X+, r0
     b82:	8a 95       	dec	r24
     b84:	e1 f7       	brne	.-8      	; 0xb7e <_Z13findTestStripv+0x84>
	foundEmptyBox =  foundEmptyBox || SameColor();
     b86:	c1 11       	cpse	r28, r1
     b88:	03 c0       	rjmp	.+6      	; 0xb90 <_Z13findTestStripv+0x96>
     b8a:	0e 94 27 04 	call	0x84e	; 0x84e <_Z9SameColorv>
     b8e:	c8 2f       	mov	r28, r24
	Serial.print(" foundEmptyBoxOrTestStrip ");
     b90:	67 ec       	ldi	r22, 0xC7	; 199
     b92:	71 e0       	ldi	r23, 0x01	; 1
     b94:	88 eb       	ldi	r24, 0xB8	; 184
     b96:	93 e0       	ldi	r25, 0x03	; 3
     b98:	0e 94 91 10 	call	0x2122	; 0x2122 <_ZN5Print5printEPKc>
	Serial.println(foundEmptyBox);
     b9c:	6c 2f       	mov	r22, r28
     b9e:	70 e0       	ldi	r23, 0x00	; 0
     ba0:	4a e0       	ldi	r20, 0x0A	; 10
     ba2:	50 e0       	ldi	r21, 0x00	; 0
     ba4:	88 eb       	ldi	r24, 0xB8	; 184
     ba6:	93 e0       	ldi	r25, 0x03	; 3
     ba8:	0e 94 74 11 	call	0x22e8	; 0x22e8 <_ZN5Print7printlnEii>
	Serial.print("\n");
     bac:	6c e5       	ldi	r22, 0x5C	; 92
     bae:	72 e0       	ldi	r23, 0x02	; 2
     bb0:	88 eb       	ldi	r24, 0xB8	; 184
     bb2:	93 e0       	ldi	r25, 0x03	; 3
     bb4:	0e 94 91 10 	call	0x2122	; 0x2122 <_ZN5Print5printEPKc>
	return foundEmptyBox && (FindMatch() == -1);
     bb8:	cc 23       	and	r28, r28
     bba:	51 f0       	breq	.+20     	; 0xbd0 <_Z13findTestStripv+0xd6>
     bbc:	0e 94 be 04 	call	0x97c	; 0x97c <_Z9FindMatchv>
     bc0:	c1 e0       	ldi	r28, 0x01	; 1
     bc2:	20 e0       	ldi	r18, 0x00	; 0
     bc4:	30 e0       	ldi	r19, 0x00	; 0
     bc6:	40 e8       	ldi	r20, 0x80	; 128
     bc8:	5f eb       	ldi	r21, 0xBF	; 191
     bca:	0e 94 93 0c 	call	0x1926	; 0x1926 <__cmpsf2>
     bce:	81 11       	cpse	r24, r1
     bd0:	c0 e0       	ldi	r28, 0x00	; 0
     bd2:	8c 2f       	mov	r24, r28
     bd4:	cf 91       	pop	r28
     bd6:	08 95       	ret

00000bd8 <_Z6setLED8LEDColor>:
LEDColor White = {255, 255, 255};
LEDColor Off = {0, 0, 0};


void setLED(LEDColor c)
{
     bd8:	cf 93       	push	r28
     bda:	df 93       	push	r29
     bdc:	00 d0       	rcall	.+0      	; 0xbde <_Z6setLED8LEDColor+0x6>
     bde:	00 d0       	rcall	.+0      	; 0xbe0 <_Z6setLED8LEDColor+0x8>
     be0:	00 d0       	rcall	.+0      	; 0xbe2 <_Z6setLED8LEDColor+0xa>
     be2:	cd b7       	in	r28, 0x3d	; 61
     be4:	de b7       	in	r29, 0x3e	; 62
     be6:	49 83       	std	Y+1, r20	; 0x01
     be8:	5a 83       	std	Y+2, r21	; 0x02
     bea:	6b 83       	std	Y+3, r22	; 0x03
     bec:	7c 83       	std	Y+4, r23	; 0x04
     bee:	8d 83       	std	Y+5, r24	; 0x05
     bf0:	9e 83       	std	Y+6, r25	; 0x06
	analogWrite(R_LED, c.r);
     bf2:	69 81       	ldd	r22, Y+1	; 0x01
     bf4:	7a 81       	ldd	r23, Y+2	; 0x02
     bf6:	8f e0       	ldi	r24, 0x0F	; 15
     bf8:	0e 94 f0 13 	call	0x27e0	; 0x27e0 <analogWrite>
	analogWrite(G_LED, c.g);
     bfc:	6b 81       	ldd	r22, Y+3	; 0x03
     bfe:	7c 81       	ldd	r23, Y+4	; 0x04
     c00:	80 e1       	ldi	r24, 0x10	; 16
     c02:	0e 94 f0 13 	call	0x27e0	; 0x27e0 <analogWrite>
	analogWrite(B_LED, c.b);
     c06:	6d 81       	ldd	r22, Y+5	; 0x05
     c08:	7e 81       	ldd	r23, Y+6	; 0x06
     c0a:	81 e1       	ldi	r24, 0x11	; 17
}
     c0c:	26 96       	adiw	r28, 0x06	; 6
     c0e:	0f b6       	in	r0, 0x3f	; 63
     c10:	f8 94       	cli
     c12:	de bf       	out	0x3e, r29	; 62
     c14:	0f be       	out	0x3f, r0	; 63
     c16:	cd bf       	out	0x3d, r28	; 61
     c18:	df 91       	pop	r29
     c1a:	cf 91       	pop	r28

void setLED(LEDColor c)
{
	analogWrite(R_LED, c.r);
	analogWrite(G_LED, c.g);
	analogWrite(B_LED, c.b);
     c1c:	0c 94 f0 13 	jmp	0x27e0	; 0x27e0 <analogWrite>

00000c20 <_Z15TaskColorSensorPv>:
/*---------------------- Tasks ---------------------*/
/*--------------------------------------------------*/

// get Ammonia, Nitrite, and Nitrate reading from color sensor
void TaskColorSensor(void *pvParameters)
{
     c20:	cf 93       	push	r28
     c22:	df 93       	push	r29
     c24:	00 d0       	rcall	.+0      	; 0xc26 <_Z15TaskColorSensorPv+0x6>
     c26:	cd b7       	in	r28, 0x3d	; 61
     c28:	de b7       	in	r29, 0x3e	; 62
	(void) pvParameters;
  
	TickType_t xLastWakeTime = xTaskGetTickCount();
     c2a:	0e 94 11 17 	call	0x2e22	; 0x2e22 <xTaskGetTickCount>
     c2e:	9a 83       	std	Y+2, r25	; 0x02
     c30:	89 83       	std	Y+1, r24	; 0x01
				ammoniaValue = ScanColor() * 100;
			}
			else
			{
				setLED(Red);
				typeToRead = NITRATE;
     c32:	01 e0       	ldi	r16, 0x01	; 1
				while (findTestStrip());
				setLED(Green);
				delay(250); // allow user to see LED and stop moving test strip

				nitrateValue = ScanColor() * 100;
     c34:	14 e6       	ldi	r17, 0x64	; 100
				
				setLED(Off);
				
				typeToRead = NITRITE;
     c36:	82 e0       	ldi	r24, 0x02	; 2
     c38:	f8 2e       	mov	r15, r24
	TickType_t xLastWakeTime = xTaskGetTickCount();
	for (;;) // A Task shall never return or exit.
	{
		//if ( xSemaphoreTake( xSerialSemaphoreColorSensor, ( TickType_t ) 1 ) == pdTRUE )
		//{
			if (colorToRead == 'a')
     c3a:	80 91 06 01 	lds	r24, 0x0106	; 0x800106 <colorToRead>
     c3e:	81 36       	cpi	r24, 0x61	; 97
     c40:	41 f5       	brne	.+80     	; 0xc92 <_Z15TaskColorSensorPv+0x72>
			{
				Serial.println("c");
     c42:	65 e7       	ldi	r22, 0x75	; 117
     c44:	72 e0       	ldi	r23, 0x02	; 2
     c46:	88 eb       	ldi	r24, 0xB8	; 184
     c48:	93 e0       	ldi	r25, 0x03	; 3
     c4a:	0e 94 9e 10 	call	0x213c	; 0x213c <_ZN5Print7printlnEPKc>
				setLED(White);
     c4e:	40 91 07 01 	lds	r20, 0x0107	; 0x800107 <White>
     c52:	50 91 08 01 	lds	r21, 0x0108	; 0x800108 <White+0x1>
     c56:	60 91 09 01 	lds	r22, 0x0109	; 0x800109 <White+0x2>
     c5a:	70 91 0a 01 	lds	r23, 0x010A	; 0x80010a <White+0x3>
     c5e:	80 91 0b 01 	lds	r24, 0x010B	; 0x80010b <White+0x4>
     c62:	90 91 0c 01 	lds	r25, 0x010C	; 0x80010c <White+0x5>
     c66:	0e 94 ec 05 	call	0xbd8	; 0xbd8 <_Z6setLED8LEDColor>
				//while (findTestStrip());
				//setLED(Green);
				delay(250); // let user see LED and stop moving before measuring
     c6a:	6a ef       	ldi	r22, 0xFA	; 250
     c6c:	70 e0       	ldi	r23, 0x00	; 0
     c6e:	80 e0       	ldi	r24, 0x00	; 0
     c70:	90 e0       	ldi	r25, 0x00	; 0
     c72:	0e 94 51 13 	call	0x26a2	; 0x26a2 <delay>
				
				typeToRead = AMMONIA;
     c76:	10 92 89 03 	sts	0x0389, r1	; 0x800389 <typeToRead>
				ammoniaValue = ScanColor() * 100;
     c7a:	0e 94 42 05 	call	0xa84	; 0xa84 <_Z9ScanColorv>
     c7e:	16 9f       	mul	r17, r22
     c80:	90 01       	movw	r18, r0
     c82:	17 9f       	mul	r17, r23
     c84:	30 0d       	add	r19, r0
     c86:	11 24       	eor	r1, r1
     c88:	30 93 81 02 	sts	0x0281, r19	; 0x800281 <ammoniaValue+0x1>
     c8c:	20 93 80 02 	sts	0x0280, r18	; 0x800280 <ammoniaValue>
     c90:	66 c0       	rjmp	.+204    	; 0xd5e <_Z15TaskColorSensorPv+0x13e>
			}
			else
			{
				setLED(Red);
     c92:	40 91 19 01 	lds	r20, 0x0119	; 0x800119 <Red>
     c96:	50 91 1a 01 	lds	r21, 0x011A	; 0x80011a <Red+0x1>
     c9a:	60 91 1b 01 	lds	r22, 0x011B	; 0x80011b <Red+0x2>
     c9e:	70 91 1c 01 	lds	r23, 0x011C	; 0x80011c <Red+0x3>
     ca2:	80 91 1d 01 	lds	r24, 0x011D	; 0x80011d <Red+0x4>
     ca6:	90 91 1e 01 	lds	r25, 0x011E	; 0x80011e <Red+0x5>
     caa:	0e 94 ec 05 	call	0xbd8	; 0xbd8 <_Z6setLED8LEDColor>
				typeToRead = NITRATE;
     cae:	00 93 89 03 	sts	0x0389, r16	; 0x800389 <typeToRead>
				while (findTestStrip());
     cb2:	0e 94 7d 05 	call	0xafa	; 0xafa <_Z13findTestStripv>
     cb6:	81 11       	cpse	r24, r1
     cb8:	fc cf       	rjmp	.-8      	; 0xcb2 <_Z15TaskColorSensorPv+0x92>
				setLED(Green);
     cba:	40 91 13 01 	lds	r20, 0x0113	; 0x800113 <Green>
     cbe:	50 91 14 01 	lds	r21, 0x0114	; 0x800114 <Green+0x1>
     cc2:	60 91 15 01 	lds	r22, 0x0115	; 0x800115 <Green+0x2>
     cc6:	70 91 16 01 	lds	r23, 0x0116	; 0x800116 <Green+0x3>
     cca:	80 91 17 01 	lds	r24, 0x0117	; 0x800117 <Green+0x4>
     cce:	90 91 18 01 	lds	r25, 0x0118	; 0x800118 <Green+0x5>
     cd2:	0e 94 ec 05 	call	0xbd8	; 0xbd8 <_Z6setLED8LEDColor>
				delay(250); // allow user to see LED and stop moving test strip
     cd6:	6a ef       	ldi	r22, 0xFA	; 250
     cd8:	70 e0       	ldi	r23, 0x00	; 0
     cda:	80 e0       	ldi	r24, 0x00	; 0
     cdc:	90 e0       	ldi	r25, 0x00	; 0
     cde:	0e 94 51 13 	call	0x26a2	; 0x26a2 <delay>

				nitrateValue = ScanColor() * 100;
     ce2:	0e 94 42 05 	call	0xa84	; 0xa84 <_Z9ScanColorv>
     ce6:	16 9f       	mul	r17, r22
     ce8:	90 01       	movw	r18, r0
     cea:	17 9f       	mul	r17, r23
     cec:	30 0d       	add	r19, r0
     cee:	11 24       	eor	r1, r1
     cf0:	30 93 7f 02 	sts	0x027F, r19	; 0x80027f <nitrateValue+0x1>
     cf4:	20 93 7e 02 	sts	0x027E, r18	; 0x80027e <nitrateValue>
				
				setLED(Off);
     cf8:	40 91 86 02 	lds	r20, 0x0286	; 0x800286 <Off>
     cfc:	50 91 87 02 	lds	r21, 0x0287	; 0x800287 <Off+0x1>
     d00:	60 91 88 02 	lds	r22, 0x0288	; 0x800288 <Off+0x2>
     d04:	70 91 89 02 	lds	r23, 0x0289	; 0x800289 <Off+0x3>
     d08:	80 91 8a 02 	lds	r24, 0x028A	; 0x80028a <Off+0x4>
     d0c:	90 91 8b 02 	lds	r25, 0x028B	; 0x80028b <Off+0x5>
     d10:	0e 94 ec 05 	call	0xbd8	; 0xbd8 <_Z6setLED8LEDColor>
				
				typeToRead = NITRITE;
     d14:	f0 92 89 03 	sts	0x0389, r15	; 0x800389 <typeToRead>
				while (findTestStrip());
     d18:	0e 94 7d 05 	call	0xafa	; 0xafa <_Z13findTestStripv>
     d1c:	81 11       	cpse	r24, r1
     d1e:	fc cf       	rjmp	.-8      	; 0xd18 <_Z15TaskColorSensorPv+0xf8>
				setLED(Blue);
     d20:	40 91 0d 01 	lds	r20, 0x010D	; 0x80010d <Blue>
     d24:	50 91 0e 01 	lds	r21, 0x010E	; 0x80010e <Blue+0x1>
     d28:	60 91 0f 01 	lds	r22, 0x010F	; 0x80010f <Blue+0x2>
     d2c:	70 91 10 01 	lds	r23, 0x0110	; 0x800110 <Blue+0x3>
     d30:	80 91 11 01 	lds	r24, 0x0111	; 0x800111 <Blue+0x4>
     d34:	90 91 12 01 	lds	r25, 0x0112	; 0x800112 <Blue+0x5>
     d38:	0e 94 ec 05 	call	0xbd8	; 0xbd8 <_Z6setLED8LEDColor>
				delay(250);
     d3c:	6a ef       	ldi	r22, 0xFA	; 250
     d3e:	70 e0       	ldi	r23, 0x00	; 0
     d40:	80 e0       	ldi	r24, 0x00	; 0
     d42:	90 e0       	ldi	r25, 0x00	; 0
     d44:	0e 94 51 13 	call	0x26a2	; 0x26a2 <delay>
				
				nitriteValue = ScanColor() * 100;
     d48:	0e 94 42 05 	call	0xa84	; 0xa84 <_Z9ScanColorv>
     d4c:	16 9f       	mul	r17, r22
     d4e:	90 01       	movw	r18, r0
     d50:	17 9f       	mul	r17, r23
     d52:	30 0d       	add	r19, r0
     d54:	11 24       	eor	r1, r1
     d56:	30 93 7d 02 	sts	0x027D, r19	; 0x80027d <nitriteValue+0x1>
     d5a:	20 93 7c 02 	sts	0x027C, r18	; 0x80027c <nitriteValue>
			}
			setLED(Off);	  
     d5e:	40 91 86 02 	lds	r20, 0x0286	; 0x800286 <Off>
     d62:	50 91 87 02 	lds	r21, 0x0287	; 0x800287 <Off+0x1>
     d66:	60 91 88 02 	lds	r22, 0x0288	; 0x800288 <Off+0x2>
     d6a:	70 91 89 02 	lds	r23, 0x0289	; 0x800289 <Off+0x3>
     d6e:	80 91 8a 02 	lds	r24, 0x028A	; 0x80028a <Off+0x4>
     d72:	90 91 8b 02 	lds	r25, 0x028B	; 0x80028b <Off+0x5>
     d76:	0e 94 ec 05 	call	0xbd8	; 0xbd8 <_Z6setLED8LEDColor>
			//xSemaphoreGive( xSerialSemaphoreColorSensor );
			// suspend until triggered by next interrupt from Wifi module
			//vTaskSuspend(NULL);
		//}
		vTaskDelayUntil( &xLastWakeTime, 1000 / portTICK_PERIOD_MS );
     d7a:	6e e3       	ldi	r22, 0x3E	; 62
     d7c:	70 e0       	ldi	r23, 0x00	; 0
     d7e:	ce 01       	movw	r24, r28
     d80:	01 96       	adiw	r24, 0x01	; 1
     d82:	0e 94 36 18 	call	0x306c	; 0x306c <vTaskDelayUntil>
void TaskColorSensor(void *pvParameters)
{
	(void) pvParameters;
  
	TickType_t xLastWakeTime = xTaskGetTickCount();
	for (;;) // A Task shall never return or exit.
     d86:	59 cf       	rjmp	.-334    	; 0xc3a <_Z15TaskColorSensorPv+0x1a>

00000d88 <_Z20TaskPHandTemperaturePv>:
}


// get pH and temp reading from sensors
void TaskPHandTemperature(void *pvParameters)
{
     d88:	cf 93       	push	r28
     d8a:	df 93       	push	r29
     d8c:	00 d0       	rcall	.+0      	; 0xd8e <_Z20TaskPHandTemperaturePv+0x6>
     d8e:	cd b7       	in	r28, 0x3d	; 61
     d90:	de b7       	in	r29, 0x3e	; 62
  (void) pvParameters;
  
  TickType_t xLastWakeTime = xTaskGetTickCount();
     d92:	0e 94 11 17 	call	0x2e22	; 0x2e22 <xTaskGetTickCount>
     d96:	9a 83       	std	Y+2, r25	; 0x02
     d98:	89 83       	std	Y+1, r24	; 0x01
  for (;;) // A Task shall never return or exit.
  {
	// Gets pH value
	//delay(500);
	setLED(Green);
     d9a:	40 91 13 01 	lds	r20, 0x0113	; 0x800113 <Green>
     d9e:	50 91 14 01 	lds	r21, 0x0114	; 0x800114 <Green+0x1>
     da2:	60 91 15 01 	lds	r22, 0x0115	; 0x800115 <Green+0x2>
     da6:	70 91 16 01 	lds	r23, 0x0116	; 0x800116 <Green+0x3>
     daa:	80 91 17 01 	lds	r24, 0x0117	; 0x800117 <Green+0x4>
     dae:	90 91 18 01 	lds	r25, 0x0118	; 0x800118 <Green+0x5>
     db2:	0e 94 ec 05 	call	0xbd8	; 0xbd8 <_Z6setLED8LEDColor>
	Serial.write("p\n");
     db6:	62 ee       	ldi	r22, 0xE2	; 226
     db8:	71 e0       	ldi	r23, 0x01	; 1
     dba:	88 eb       	ldi	r24, 0xB8	; 184
     dbc:	93 e0       	ldi	r25, 0x03	; 3
     dbe:	0e 94 13 02 	call	0x426	; 0x426 <_ZN5Print5writeEPKc>
	//long temp = measureTemp();
	phValue = getPH(tempValue) * 100;
     dc2:	60 91 82 02 	lds	r22, 0x0282	; 0x800282 <tempValue>
     dc6:	70 91 83 02 	lds	r23, 0x0283	; 0x800283 <tempValue+0x1>
     dca:	07 2e       	mov	r0, r23
     dcc:	00 0c       	add	r0, r0
     dce:	88 0b       	sbc	r24, r24
     dd0:	99 0b       	sbc	r25, r25
     dd2:	0e 94 41 0a 	call	0x1482	; 0x1482 <_Z5getPHl>
     dd6:	20 e0       	ldi	r18, 0x00	; 0
     dd8:	30 e0       	ldi	r19, 0x00	; 0
     dda:	48 ec       	ldi	r20, 0xC8	; 200
     ddc:	52 e4       	ldi	r21, 0x42	; 66
     dde:	0e 94 f7 0d 	call	0x1bee	; 0x1bee <__mulsf3>
     de2:	0e 94 0a 0d 	call	0x1a14	; 0x1a14 <__fixsfsi>
     de6:	70 93 85 02 	sts	0x0285, r23	; 0x800285 <phValue+0x1>
     dea:	60 93 84 02 	sts	0x0284, r22	; 0x800284 <phValue>
	//Serial.write(phValue);
	Serial.print(phValue);
     dee:	4a e0       	ldi	r20, 0x0A	; 10
     df0:	50 e0       	ldi	r21, 0x00	; 0
     df2:	88 eb       	ldi	r24, 0xB8	; 184
     df4:	93 e0       	ldi	r25, 0x03	; 3
     df6:	0e 94 6d 11 	call	0x22da	; 0x22da <_ZN5Print5printEii>
	delay(100);
     dfa:	64 e6       	ldi	r22, 0x64	; 100
     dfc:	70 e0       	ldi	r23, 0x00	; 0
     dfe:	80 e0       	ldi	r24, 0x00	; 0
     e00:	90 e0       	ldi	r25, 0x00	; 0
     e02:	0e 94 51 13 	call	0x26a2	; 0x26a2 <delay>
	setLED(Off);
     e06:	40 91 86 02 	lds	r20, 0x0286	; 0x800286 <Off>
     e0a:	50 91 87 02 	lds	r21, 0x0287	; 0x800287 <Off+0x1>
     e0e:	60 91 88 02 	lds	r22, 0x0288	; 0x800288 <Off+0x2>
     e12:	70 91 89 02 	lds	r23, 0x0289	; 0x800289 <Off+0x3>
     e16:	80 91 8a 02 	lds	r24, 0x028A	; 0x80028a <Off+0x4>
     e1a:	90 91 8b 02 	lds	r25, 0x028B	; 0x80028b <Off+0x5>
     e1e:	0e 94 ec 05 	call	0xbd8	; 0xbd8 <_Z6setLED8LEDColor>
	
	setLED(Red);
     e22:	40 91 19 01 	lds	r20, 0x0119	; 0x800119 <Red>
     e26:	50 91 1a 01 	lds	r21, 0x011A	; 0x80011a <Red+0x1>
     e2a:	60 91 1b 01 	lds	r22, 0x011B	; 0x80011b <Red+0x2>
     e2e:	70 91 1c 01 	lds	r23, 0x011C	; 0x80011c <Red+0x3>
     e32:	80 91 1d 01 	lds	r24, 0x011D	; 0x80011d <Red+0x4>
     e36:	90 91 1e 01 	lds	r25, 0x011E	; 0x80011e <Red+0x5>
     e3a:	0e 94 ec 05 	call	0xbd8	; 0xbd8 <_Z6setLED8LEDColor>
	// Gets temperature value in Celsius
	tempValue = measureTemp() * 100;
     e3e:	0e 94 2f 02 	call	0x45e	; 0x45e <_Z11measureTempv>
     e42:	20 e0       	ldi	r18, 0x00	; 0
     e44:	30 e0       	ldi	r19, 0x00	; 0
     e46:	48 ec       	ldi	r20, 0xC8	; 200
     e48:	52 e4       	ldi	r21, 0x42	; 66
     e4a:	0e 94 f7 0d 	call	0x1bee	; 0x1bee <__mulsf3>
     e4e:	0e 94 0a 0d 	call	0x1a14	; 0x1a14 <__fixsfsi>
     e52:	70 93 83 02 	sts	0x0283, r23	; 0x800283 <tempValue+0x1>
     e56:	60 93 82 02 	sts	0x0282, r22	; 0x800282 <tempValue>
	Serial.write("t\n");
     e5a:	65 ee       	ldi	r22, 0xE5	; 229
     e5c:	71 e0       	ldi	r23, 0x01	; 1
     e5e:	88 eb       	ldi	r24, 0xB8	; 184
     e60:	93 e0       	ldi	r25, 0x03	; 3
     e62:	0e 94 13 02 	call	0x426	; 0x426 <_ZN5Print5writeEPKc>
	Serial.print(tempValue);
     e66:	60 91 82 02 	lds	r22, 0x0282	; 0x800282 <tempValue>
     e6a:	70 91 83 02 	lds	r23, 0x0283	; 0x800283 <tempValue+0x1>
     e6e:	4a e0       	ldi	r20, 0x0A	; 10
     e70:	50 e0       	ldi	r21, 0x00	; 0
     e72:	88 eb       	ldi	r24, 0xB8	; 184
     e74:	93 e0       	ldi	r25, 0x03	; 3
     e76:	0e 94 6d 11 	call	0x22da	; 0x22da <_ZN5Print5printEii>
	
	delay(100);
     e7a:	64 e6       	ldi	r22, 0x64	; 100
     e7c:	70 e0       	ldi	r23, 0x00	; 0
     e7e:	80 e0       	ldi	r24, 0x00	; 0
     e80:	90 e0       	ldi	r25, 0x00	; 0
     e82:	0e 94 51 13 	call	0x26a2	; 0x26a2 <delay>
	setLED(Off);
     e86:	40 91 86 02 	lds	r20, 0x0286	; 0x800286 <Off>
     e8a:	50 91 87 02 	lds	r21, 0x0287	; 0x800287 <Off+0x1>
     e8e:	60 91 88 02 	lds	r22, 0x0288	; 0x800288 <Off+0x2>
     e92:	70 91 89 02 	lds	r23, 0x0289	; 0x800289 <Off+0x3>
     e96:	80 91 8a 02 	lds	r24, 0x028A	; 0x80028a <Off+0x4>
     e9a:	90 91 8b 02 	lds	r25, 0x028B	; 0x80028b <Off+0x5>
     e9e:	0e 94 ec 05 	call	0xbd8	; 0xbd8 <_Z6setLED8LEDColor>
    // check pH and temp every 15 min
    vTaskDelayUntil( &xLastWakeTime, 5000 / portTICK_PERIOD_MS );
     ea2:	68 e3       	ldi	r22, 0x38	; 56
     ea4:	71 e0       	ldi	r23, 0x01	; 1
     ea6:	ce 01       	movw	r24, r28
     ea8:	01 96       	adiw	r24, 0x01	; 1
     eaa:	0e 94 36 18 	call	0x306c	; 0x306c <vTaskDelayUntil>
     eae:	75 cf       	rjmp	.-278    	; 0xd9a <_Z20TaskPHandTemperaturePv+0x12>

00000eb0 <_Z8setupLEDv>:
}

void setupLED()
{
	pinMode(R_LED, OUTPUT);
     eb0:	61 e0       	ldi	r22, 0x01	; 1
     eb2:	8f e0       	ldi	r24, 0x0F	; 15
     eb4:	0e 94 78 14 	call	0x28f0	; 0x28f0 <pinMode>
	pinMode(G_LED, OUTPUT);
     eb8:	61 e0       	ldi	r22, 0x01	; 1
     eba:	80 e1       	ldi	r24, 0x10	; 16
     ebc:	0e 94 78 14 	call	0x28f0	; 0x28f0 <pinMode>
	pinMode(B_LED, OUTPUT);
     ec0:	61 e0       	ldi	r22, 0x01	; 1
     ec2:	81 e1       	ldi	r24, 0x11	; 17
     ec4:	0e 94 78 14 	call	0x28f0	; 0x28f0 <pinMode>
	setLED(Off);
     ec8:	40 91 86 02 	lds	r20, 0x0286	; 0x800286 <Off>
     ecc:	50 91 87 02 	lds	r21, 0x0287	; 0x800287 <Off+0x1>
     ed0:	60 91 88 02 	lds	r22, 0x0288	; 0x800288 <Off+0x2>
     ed4:	70 91 89 02 	lds	r23, 0x0289	; 0x800289 <Off+0x3>
     ed8:	80 91 8a 02 	lds	r24, 0x028A	; 0x80028a <Off+0x4>
     edc:	90 91 8b 02 	lds	r25, 0x028B	; 0x80028b <Off+0x5>
     ee0:	0c 94 ec 05 	jmp	0xbd8	; 0xbd8 <_Z6setLED8LEDColor>

00000ee4 <setup>:
TaskHandle_t xColorSensor;
TaskHandle_t xPHandTemperature;


// the setup function runs once when you press reset or power the board
void setup() {  
     ee4:	ef 92       	push	r14
     ee6:	ff 92       	push	r15
     ee8:	0f 93       	push	r16
  public:
    inline HardwareSerial(
      volatile uint8_t *ubrrh, volatile uint8_t *ubrrl,
      volatile uint8_t *ucsra, volatile uint8_t *ucsrb,
      volatile uint8_t *ucsrc, volatile uint8_t *udr);
    void begin(unsigned long baud) { begin(baud, SERIAL_8N1); }
     eea:	26 e0       	ldi	r18, 0x06	; 6
     eec:	40 e0       	ldi	r20, 0x00	; 0
     eee:	52 ec       	ldi	r21, 0xC2	; 194
     ef0:	61 e0       	ldi	r22, 0x01	; 1
     ef2:	70 e0       	ldi	r23, 0x00	; 0
     ef4:	88 eb       	ldi	r24, 0xB8	; 184
     ef6:	93 e0       	ldi	r25, 0x03	; 3
     ef8:	0e 94 40 0f 	call	0x1e80	; 0x1e80 <_ZN14HardwareSerial5beginEmh>
	}
  
	// initialize Wifi module (Maybe?)

	// load test strip color data and initialize indicator LED
	CS.begin();
     efc:	8c e8       	ldi	r24, 0x8C	; 140
     efe:	92 e0       	ldi	r25, 0x02	; 2
     f00:	0e 94 19 0b 	call	0x1632	; 0x1632 <_ZN9MD_TCS2305beginEv>
	addColors();
     f04:	0e 94 e5 02 	call	0x5ca	; 0x5ca <_Z9addColorsv>
	setupLED();
     f08:	0e 94 58 07 	call	0xeb0	; 0xeb0 <_Z8setupLEDv>
	Serial.print("Starting setup");
     f0c:	68 ee       	ldi	r22, 0xE8	; 232
     f0e:	71 e0       	ldi	r23, 0x01	; 1
     f10:	88 eb       	ldi	r24, 0xB8	; 184
     f12:	93 e0       	ldi	r25, 0x03	; 3
     f14:	0e 94 91 10 	call	0x2122	; 0x2122 <_ZN5Print5printEPKc>
	
	setLED(Green);
     f18:	40 91 13 01 	lds	r20, 0x0113	; 0x800113 <Green>
     f1c:	50 91 14 01 	lds	r21, 0x0114	; 0x800114 <Green+0x1>
     f20:	60 91 15 01 	lds	r22, 0x0115	; 0x800115 <Green+0x2>
     f24:	70 91 16 01 	lds	r23, 0x0116	; 0x800116 <Green+0x3>
     f28:	80 91 17 01 	lds	r24, 0x0117	; 0x800117 <Green+0x4>
     f2c:	90 91 18 01 	lds	r25, 0x0118	; 0x800118 <Green+0x5>
     f30:	0e 94 ec 05 	call	0xbd8	; 0xbd8 <_Z6setLED8LEDColor>
  
	// initialize pH sensor
	phInit();
     f34:	0e 94 3d 0a 	call	0x147a	; 0x147a <_Z6phInitv>

	// TODO: Not sure how Wifi module indicates that it is getting data - replace that with the interrupt from pin2 
	attachInterrupt(digitalPinToInterrupt(2), fromWifi, RISING);
     f38:	43 e0       	ldi	r20, 0x03	; 3
     f3a:	50 e0       	ldi	r21, 0x00	; 0
     f3c:	6f ee       	ldi	r22, 0xEF	; 239
     f3e:	77 e0       	ldi	r23, 0x07	; 7
     f40:	80 e0       	ldi	r24, 0x00	; 0
     f42:	0e 94 74 12 	call	0x24e8	; 0x24e8 <attachInterrupt>
	TaskColorSensor
	,  (const portCHAR *)"ColorSensor"
	,  128
	,  NULL
	,  1
	,  &xColorSensor );
     f46:	8a e7       	ldi	r24, 0x7A	; 122
     f48:	e8 2e       	mov	r14, r24
     f4a:	82 e0       	ldi	r24, 0x02	; 2
     f4c:	f8 2e       	mov	r15, r24
     f4e:	01 e0       	ldi	r16, 0x01	; 1
     f50:	20 e0       	ldi	r18, 0x00	; 0
     f52:	30 e0       	ldi	r19, 0x00	; 0
     f54:	40 e8       	ldi	r20, 0x80	; 128
     f56:	50 e0       	ldi	r21, 0x00	; 0
     f58:	67 ef       	ldi	r22, 0xF7	; 247
     f5a:	71 e0       	ldi	r23, 0x01	; 1
     f5c:	80 e1       	ldi	r24, 0x10	; 16
     f5e:	96 e0       	ldi	r25, 0x06	; 6
     f60:	0e 94 88 15 	call	0x2b10	; 0x2b10 <xTaskCreate>
	TaskPHandTemperature
	,  (const portCHAR *) "PHandTemperature"
	,  128
	,  NULL
	,  2
	,  &xPHandTemperature );
     f64:	98 e7       	ldi	r25, 0x78	; 120
     f66:	e9 2e       	mov	r14, r25
     f68:	92 e0       	ldi	r25, 0x02	; 2
     f6a:	f9 2e       	mov	r15, r25
     f6c:	02 e0       	ldi	r16, 0x02	; 2
     f6e:	20 e0       	ldi	r18, 0x00	; 0
     f70:	30 e0       	ldi	r19, 0x00	; 0
     f72:	40 e8       	ldi	r20, 0x80	; 128
     f74:	50 e0       	ldi	r21, 0x00	; 0
     f76:	63 e0       	ldi	r22, 0x03	; 3
     f78:	72 e0       	ldi	r23, 0x02	; 2
     f7a:	84 ec       	ldi	r24, 0xC4	; 196
     f7c:	96 e0       	ldi	r25, 0x06	; 6
     f7e:	0e 94 88 15 	call	0x2b10	; 0x2b10 <xTaskCreate>
	
	//vTaskSuspend(xColorSensor);
	
	delay(1000);
     f82:	68 ee       	ldi	r22, 0xE8	; 232
     f84:	73 e0       	ldi	r23, 0x03	; 3
     f86:	80 e0       	ldi	r24, 0x00	; 0
     f88:	90 e0       	ldi	r25, 0x00	; 0
     f8a:	0e 94 51 13 	call	0x26a2	; 0x26a2 <delay>
	setLED(Off);
     f8e:	40 91 86 02 	lds	r20, 0x0286	; 0x800286 <Off>
     f92:	50 91 87 02 	lds	r21, 0x0287	; 0x800287 <Off+0x1>
     f96:	60 91 88 02 	lds	r22, 0x0288	; 0x800288 <Off+0x2>
     f9a:	70 91 89 02 	lds	r23, 0x0289	; 0x800289 <Off+0x3>
     f9e:	80 91 8a 02 	lds	r24, 0x028A	; 0x80028a <Off+0x4>
     fa2:	90 91 8b 02 	lds	r25, 0x028B	; 0x80028b <Off+0x5>
     fa6:	0e 94 ec 05 	call	0xbd8	; 0xbd8 <_Z6setLED8LEDColor>
	//calibratePH(25);
	Serial.print("Inside setup");
     faa:	64 e1       	ldi	r22, 0x14	; 20
     fac:	72 e0       	ldi	r23, 0x02	; 2
     fae:	88 eb       	ldi	r24, 0xB8	; 184
     fb0:	93 e0       	ldi	r25, 0x03	; 3

	// Now the task scheduler, which takes over control of scheduling individual tasks, is automatically started.
}
     fb2:	0f 91       	pop	r16
     fb4:	ff 90       	pop	r15
     fb6:	ef 90       	pop	r14
	//vTaskSuspend(xColorSensor);
	
	delay(1000);
	setLED(Off);
	//calibratePH(25);
	Serial.print("Inside setup");
     fb8:	0c 94 91 10 	jmp	0x2122	; 0x2122 <_ZN5Print5printEPKc>

00000fbc <loop>:

	// Now the task scheduler, which takes over control of scheduling individual tasks, is automatically started.
}

void loop()
{
     fbc:	08 95       	ret

00000fbe <_GLOBAL__sub_I_ds>:
    bool LastDeviceFlag;
#endif

  public:
    OneWire() { }
    OneWire(uint8_t pin) { begin(pin); }
     fbe:	66 e0       	ldi	r22, 0x06	; 6
     fc0:	8a e8       	ldi	r24, 0x8A	; 138
     fc2:	93 e0       	ldi	r25, 0x03	; 3
     fc4:	0e 94 7b 09 	call	0x12f6	; 0x12f6 <_ZN7OneWire5beginEh>

uint8_t greenScanned;
uint8_t redScanned;
uint8_t blueScanned;

MD_TCS230  CS(S2, S3, OE);
     fc8:	28 e0       	ldi	r18, 0x08	; 8
     fca:	4d e0       	ldi	r20, 0x0D	; 13
     fcc:	6c e0       	ldi	r22, 0x0C	; 12
     fce:	8c e8       	ldi	r24, 0x8C	; 140
     fd0:	92 e0       	ldi	r25, 0x02	; 2
     fd2:	0c 94 a7 0a 	jmp	0x154e	; 0x154e <_ZN9MD_TCS230C1Ehhh>

00000fd6 <_GLOBAL__sub_D_ds>:
     fd6:	8c e8       	ldi	r24, 0x8C	; 140
     fd8:	92 e0       	ldi	r25, 0x02	; 2
     fda:	0c 94 bb 0a 	jmp	0x1576	; 0x1576 <_ZN9MD_TCS230D1Ev>

00000fde <_Z8fromWifiv>:
  }
}


void fromWifi()
{
     fde:	cf 93       	push	r28
	int i = 0;
	char action = '\0';
	// check for data from Wifi
	if (Serial.available())
     fe0:	88 eb       	ldi	r24, 0xB8	; 184
     fe2:	93 e0       	ldi	r25, 0x03	; 3
     fe4:	0e 94 64 0e 	call	0x1cc8	; 0x1cc8 <_ZN14HardwareSerial9availableEv>
     fe8:	89 2b       	or	r24, r25
     fea:	09 f4       	brne	.+2      	; 0xfee <_Z8fromWifiv+0x10>
     fec:	6a c0       	rjmp	.+212    	; 0x10c2 <_Z8fromWifiv+0xe4>
	{
		delay(100); // allows all serial sent to be received together
     fee:	64 e6       	ldi	r22, 0x64	; 100
     ff0:	70 e0       	ldi	r23, 0x00	; 0
     ff2:	80 e0       	ldi	r24, 0x00	; 0
     ff4:	90 e0       	ldi	r25, 0x00	; 0
     ff6:	0e 94 51 13 	call	0x26a2	; 0x26a2 <delay>


void fromWifi()
{
	int i = 0;
	char action = '\0';
     ffa:	c0 e0       	ldi	r28, 0x00	; 0
	// check for data from Wifi
	if (Serial.available())
	{
		delay(100); // allows all serial sent to be received together
		while (Serial.available())
     ffc:	88 eb       	ldi	r24, 0xB8	; 184
     ffe:	93 e0       	ldi	r25, 0x03	; 3
    1000:	0e 94 64 0e 	call	0x1cc8	; 0x1cc8 <_ZN14HardwareSerial9availableEv>
    1004:	89 2b       	or	r24, r25
    1006:	31 f0       	breq	.+12     	; 0x1014 <_Z8fromWifiv+0x36>
		{
			action = Serial.read();
    1008:	88 eb       	ldi	r24, 0xB8	; 184
    100a:	93 e0       	ldi	r25, 0x03	; 3
    100c:	0e 94 7e 0e 	call	0x1cfc	; 0x1cfc <_ZN14HardwareSerial4readEv>
    1010:	c8 2f       	mov	r28, r24
	char action = '\0';
	// check for data from Wifi
	if (Serial.available())
	{
		delay(100); // allows all serial sent to be received together
		while (Serial.available())
    1012:	f4 cf       	rjmp	.-24     	; 0xffc <_Z8fromWifiv+0x1e>
		{
			action = Serial.read();
		}
	}

	switch(action)
    1014:	ce 36       	cpi	r28, 0x6E	; 110
    1016:	29 f0       	breq	.+10     	; 0x1022 <_Z8fromWifiv+0x44>
    1018:	c0 37       	cpi	r28, 0x70	; 112
    101a:	61 f0       	breq	.+24     	; 0x1034 <_Z8fromWifiv+0x56>
    101c:	c1 36       	cpi	r28, 0x61	; 97
    101e:	09 f0       	breq	.+2      	; 0x1022 <_Z8fromWifiv+0x44>
    1020:	50 c0       	rjmp	.+160    	; 0x10c2 <_Z8fromWifiv+0xe4>
		vTaskResume(xColorSensor);
		break;
	}
	case 'n':
	{
		colorToRead = 'n';
    1022:	c0 93 06 01 	sts	0x0106, r28	; 0x800106 <colorToRead>
		vTaskResume(xColorSensor);
    1026:	80 91 7a 02 	lds	r24, 0x027A	; 0x80027a <xColorSensor>
    102a:	90 91 7b 02 	lds	r25, 0x027B	; 0x80027b <xColorSensor+0x1>
		Serial.write(nitrateValue);
	}
	default:
		break;
	}
}
    102e:	cf 91       	pop	r28
		break;
	}
	case 'n':
	{
		colorToRead = 'n';
		vTaskResume(xColorSensor);
    1030:	0c 94 94 16 	jmp	0x2d28	; 0x2d28 <vTaskResume>
		break;
	}
	case 'p':
	{
		Serial.write("ph:");
    1034:	61 e2       	ldi	r22, 0x21	; 33
    1036:	72 e0       	ldi	r23, 0x02	; 2
    1038:	88 eb       	ldi	r24, 0xB8	; 184
    103a:	93 e0       	ldi	r25, 0x03	; 3
    103c:	0e 94 13 02 	call	0x426	; 0x426 <_ZN5Print5writeEPKc>
		Serial.write(phValue);
    1040:	60 91 84 02 	lds	r22, 0x0284	; 0x800284 <phValue>
    1044:	70 91 85 02 	lds	r23, 0x0285	; 0x800285 <phValue+0x1>
    1048:	88 eb       	ldi	r24, 0xB8	; 184
    104a:	93 e0       	ldi	r25, 0x03	; 3
    104c:	0e 94 28 02 	call	0x450	; 0x450 <_ZN14HardwareSerial5writeEi>
		Serial.write("temp:");
    1050:	65 e2       	ldi	r22, 0x25	; 37
    1052:	72 e0       	ldi	r23, 0x02	; 2
    1054:	88 eb       	ldi	r24, 0xB8	; 184
    1056:	93 e0       	ldi	r25, 0x03	; 3
    1058:	0e 94 13 02 	call	0x426	; 0x426 <_ZN5Print5writeEPKc>
		Serial.write(tempValue);
    105c:	60 91 82 02 	lds	r22, 0x0282	; 0x800282 <tempValue>
    1060:	70 91 83 02 	lds	r23, 0x0283	; 0x800283 <tempValue+0x1>
    1064:	88 eb       	ldi	r24, 0xB8	; 184
    1066:	93 e0       	ldi	r25, 0x03	; 3
    1068:	0e 94 28 02 	call	0x450	; 0x450 <_ZN14HardwareSerial5writeEi>
		Serial.write("ammonia:");
    106c:	6b e2       	ldi	r22, 0x2B	; 43
    106e:	72 e0       	ldi	r23, 0x02	; 2
    1070:	88 eb       	ldi	r24, 0xB8	; 184
    1072:	93 e0       	ldi	r25, 0x03	; 3
    1074:	0e 94 13 02 	call	0x426	; 0x426 <_ZN5Print5writeEPKc>
		Serial.write(ammoniaValue);
    1078:	60 91 80 02 	lds	r22, 0x0280	; 0x800280 <ammoniaValue>
    107c:	70 91 81 02 	lds	r23, 0x0281	; 0x800281 <ammoniaValue+0x1>
    1080:	88 eb       	ldi	r24, 0xB8	; 184
    1082:	93 e0       	ldi	r25, 0x03	; 3
    1084:	0e 94 28 02 	call	0x450	; 0x450 <_ZN14HardwareSerial5writeEi>
		Serial.write("nitrite:");
    1088:	64 e3       	ldi	r22, 0x34	; 52
    108a:	72 e0       	ldi	r23, 0x02	; 2
    108c:	88 eb       	ldi	r24, 0xB8	; 184
    108e:	93 e0       	ldi	r25, 0x03	; 3
    1090:	0e 94 13 02 	call	0x426	; 0x426 <_ZN5Print5writeEPKc>
		Serial.write(nitriteValue);
    1094:	60 91 7c 02 	lds	r22, 0x027C	; 0x80027c <nitriteValue>
    1098:	70 91 7d 02 	lds	r23, 0x027D	; 0x80027d <nitriteValue+0x1>
    109c:	88 eb       	ldi	r24, 0xB8	; 184
    109e:	93 e0       	ldi	r25, 0x03	; 3
    10a0:	0e 94 28 02 	call	0x450	; 0x450 <_ZN14HardwareSerial5writeEi>
		Serial.write("nitrate:");
    10a4:	6d e3       	ldi	r22, 0x3D	; 61
    10a6:	72 e0       	ldi	r23, 0x02	; 2
    10a8:	88 eb       	ldi	r24, 0xB8	; 184
    10aa:	93 e0       	ldi	r25, 0x03	; 3
    10ac:	0e 94 13 02 	call	0x426	; 0x426 <_ZN5Print5writeEPKc>
		Serial.write(nitrateValue);
    10b0:	60 91 7e 02 	lds	r22, 0x027E	; 0x80027e <nitrateValue>
    10b4:	70 91 7f 02 	lds	r23, 0x027F	; 0x80027f <nitrateValue+0x1>
    10b8:	88 eb       	ldi	r24, 0xB8	; 184
    10ba:	93 e0       	ldi	r25, 0x03	; 3
	}
	default:
		break;
	}
}
    10bc:	cf 91       	pop	r28
		Serial.write("ammonia:");
		Serial.write(ammoniaValue);
		Serial.write("nitrite:");
		Serial.write(nitriteValue);
		Serial.write("nitrate:");
		Serial.write(nitrateValue);
    10be:	0c 94 28 02 	jmp	0x450	; 0x450 <_ZN14HardwareSerial5writeEi>
	}
	default:
		break;
	}
}
    10c2:	cf 91       	pop	r28
    10c4:	08 95       	ret

000010c6 <_ZN7OneWire5resetEv>:
   ROM_NO[0] = family_code;
   for (uint8_t i = 1; i < 8; i++)
      ROM_NO[i] = 0;
   LastDiscrepancy = 64;
   LastFamilyDiscrepancy = 0;
   LastDeviceFlag = false;
    10c6:	ff 92       	push	r15
    10c8:	0f 93       	push	r16
    10ca:	1f 93       	push	r17
    10cc:	cf 93       	push	r28
    10ce:	df 93       	push	r29
    10d0:	fc 01       	movw	r30, r24
    10d2:	f0 80       	ld	r15, Z
    10d4:	c1 81       	ldd	r28, Z+1	; 0x01
    10d6:	d2 81       	ldd	r29, Z+2	; 0x02
    10d8:	f8 94       	cli
    10da:	89 81       	ldd	r24, Y+1	; 0x01
    10dc:	0f 2d       	mov	r16, r15
    10de:	00 95       	com	r16
    10e0:	80 23       	and	r24, r16
    10e2:	89 83       	std	Y+1, r24	; 0x01
    10e4:	78 94       	sei
    10e6:	1d e7       	ldi	r17, 0x7D	; 125
    10e8:	11 50       	subi	r17, 0x01	; 1
    10ea:	29 f1       	breq	.+74     	; 0x1136 <_ZN7OneWire5resetEv+0x70>
    10ec:	82 e0       	ldi	r24, 0x02	; 2
    10ee:	90 e0       	ldi	r25, 0x00	; 0
    10f0:	0e 94 8d 13 	call	0x271a	; 0x271a <delayMicroseconds>
    10f4:	88 81       	ld	r24, Y
    10f6:	8f 21       	and	r24, r15
    10f8:	b9 f3       	breq	.-18     	; 0x10e8 <_ZN7OneWire5resetEv+0x22>
    10fa:	f8 94       	cli
    10fc:	8a 81       	ldd	r24, Y+2	; 0x02
    10fe:	80 23       	and	r24, r16
    1100:	8a 83       	std	Y+2, r24	; 0x02
    1102:	89 81       	ldd	r24, Y+1	; 0x01
    1104:	8f 29       	or	r24, r15
    1106:	89 83       	std	Y+1, r24	; 0x01
    1108:	78 94       	sei
    110a:	80 ee       	ldi	r24, 0xE0	; 224
    110c:	91 e0       	ldi	r25, 0x01	; 1
    110e:	0e 94 8d 13 	call	0x271a	; 0x271a <delayMicroseconds>
    1112:	f8 94       	cli
    1114:	89 81       	ldd	r24, Y+1	; 0x01
    1116:	08 23       	and	r16, r24
    1118:	09 83       	std	Y+1, r16	; 0x01
    111a:	86 e4       	ldi	r24, 0x46	; 70
    111c:	90 e0       	ldi	r25, 0x00	; 0
    111e:	0e 94 8d 13 	call	0x271a	; 0x271a <delayMicroseconds>
    1122:	88 81       	ld	r24, Y
    1124:	f8 22       	and	r15, r24
    1126:	11 e0       	ldi	r17, 0x01	; 1
    1128:	09 f0       	breq	.+2      	; 0x112c <_ZN7OneWire5resetEv+0x66>
    112a:	10 e0       	ldi	r17, 0x00	; 0
    112c:	78 94       	sei
    112e:	8a e9       	ldi	r24, 0x9A	; 154
    1130:	91 e0       	ldi	r25, 0x01	; 1
    1132:	0e 94 8d 13 	call	0x271a	; 0x271a <delayMicroseconds>
    1136:	81 2f       	mov	r24, r17
    1138:	df 91       	pop	r29
    113a:	cf 91       	pop	r28
    113c:	1f 91       	pop	r17
    113e:	0f 91       	pop	r16
    1140:	ff 90       	pop	r15
    1142:	08 95       	ret

00001144 <_ZN7OneWire9write_bitEh>:
    1144:	1f 93       	push	r17
    1146:	cf 93       	push	r28
    1148:	df 93       	push	r29
    114a:	fc 01       	movw	r30, r24
    114c:	10 81       	ld	r17, Z
    114e:	c1 81       	ldd	r28, Z+1	; 0x01
    1150:	d2 81       	ldd	r29, Z+2	; 0x02
    1152:	81 2f       	mov	r24, r17
    1154:	80 95       	com	r24
    1156:	60 ff       	sbrs	r22, 0
    1158:	12 c0       	rjmp	.+36     	; 0x117e <_ZN7OneWire9write_bitEh+0x3a>
    115a:	f8 94       	cli
    115c:	9a 81       	ldd	r25, Y+2	; 0x02
    115e:	89 23       	and	r24, r25
    1160:	8a 83       	std	Y+2, r24	; 0x02
    1162:	89 81       	ldd	r24, Y+1	; 0x01
    1164:	81 2b       	or	r24, r17
    1166:	89 83       	std	Y+1, r24	; 0x01
    1168:	8a e0       	ldi	r24, 0x0A	; 10
    116a:	90 e0       	ldi	r25, 0x00	; 0
    116c:	0e 94 8d 13 	call	0x271a	; 0x271a <delayMicroseconds>
    1170:	8a 81       	ldd	r24, Y+2	; 0x02
    1172:	18 2b       	or	r17, r24
    1174:	1a 83       	std	Y+2, r17	; 0x02
    1176:	78 94       	sei
    1178:	87 e3       	ldi	r24, 0x37	; 55
    117a:	90 e0       	ldi	r25, 0x00	; 0
    117c:	11 c0       	rjmp	.+34     	; 0x11a0 <_ZN7OneWire9write_bitEh+0x5c>
    117e:	f8 94       	cli
    1180:	9a 81       	ldd	r25, Y+2	; 0x02
    1182:	89 23       	and	r24, r25
    1184:	8a 83       	std	Y+2, r24	; 0x02
    1186:	89 81       	ldd	r24, Y+1	; 0x01
    1188:	81 2b       	or	r24, r17
    118a:	89 83       	std	Y+1, r24	; 0x01
    118c:	81 e4       	ldi	r24, 0x41	; 65
    118e:	90 e0       	ldi	r25, 0x00	; 0
    1190:	0e 94 8d 13 	call	0x271a	; 0x271a <delayMicroseconds>
    1194:	8a 81       	ldd	r24, Y+2	; 0x02
    1196:	18 2b       	or	r17, r24
    1198:	1a 83       	std	Y+2, r17	; 0x02
    119a:	78 94       	sei
    119c:	85 e0       	ldi	r24, 0x05	; 5
    119e:	90 e0       	ldi	r25, 0x00	; 0
    11a0:	df 91       	pop	r29
    11a2:	cf 91       	pop	r28
    11a4:	1f 91       	pop	r17
    11a6:	0c 94 8d 13 	jmp	0x271a	; 0x271a <delayMicroseconds>

000011aa <_ZN7OneWire8read_bitEv>:
    11aa:	0f 93       	push	r16
    11ac:	1f 93       	push	r17
    11ae:	cf 93       	push	r28
    11b0:	df 93       	push	r29
    11b2:	fc 01       	movw	r30, r24
    11b4:	00 81       	ld	r16, Z
    11b6:	c1 81       	ldd	r28, Z+1	; 0x01
    11b8:	d2 81       	ldd	r29, Z+2	; 0x02
    11ba:	f8 94       	cli
    11bc:	89 81       	ldd	r24, Y+1	; 0x01
    11be:	80 2b       	or	r24, r16
    11c0:	89 83       	std	Y+1, r24	; 0x01
    11c2:	8a 81       	ldd	r24, Y+2	; 0x02
    11c4:	10 2f       	mov	r17, r16
    11c6:	10 95       	com	r17
    11c8:	81 23       	and	r24, r17
    11ca:	8a 83       	std	Y+2, r24	; 0x02
    11cc:	83 e0       	ldi	r24, 0x03	; 3
    11ce:	90 e0       	ldi	r25, 0x00	; 0
    11d0:	0e 94 8d 13 	call	0x271a	; 0x271a <delayMicroseconds>
    11d4:	89 81       	ldd	r24, Y+1	; 0x01
    11d6:	18 23       	and	r17, r24
    11d8:	19 83       	std	Y+1, r17	; 0x01
    11da:	8a e0       	ldi	r24, 0x0A	; 10
    11dc:	90 e0       	ldi	r25, 0x00	; 0
    11de:	0e 94 8d 13 	call	0x271a	; 0x271a <delayMicroseconds>
    11e2:	c8 81       	ld	r28, Y
    11e4:	78 94       	sei
    11e6:	85 e3       	ldi	r24, 0x35	; 53
    11e8:	90 e0       	ldi	r25, 0x00	; 0
    11ea:	0e 94 8d 13 	call	0x271a	; 0x271a <delayMicroseconds>
    11ee:	c0 23       	and	r28, r16
    11f0:	81 e0       	ldi	r24, 0x01	; 1
    11f2:	09 f4       	brne	.+2      	; 0x11f6 <_ZN7OneWire8read_bitEv+0x4c>
    11f4:	80 e0       	ldi	r24, 0x00	; 0
    11f6:	df 91       	pop	r29
    11f8:	cf 91       	pop	r28
    11fa:	1f 91       	pop	r17
    11fc:	0f 91       	pop	r16
    11fe:	08 95       	ret

00001200 <_ZN7OneWire5writeEhh>:
    1200:	df 92       	push	r13
    1202:	ef 92       	push	r14
    1204:	ff 92       	push	r15
    1206:	0f 93       	push	r16
    1208:	1f 93       	push	r17
    120a:	cf 93       	push	r28
    120c:	df 93       	push	r29
    120e:	ec 01       	movw	r28, r24
    1210:	d6 2e       	mov	r13, r22
    1212:	e4 2e       	mov	r14, r20
    1214:	08 e0       	ldi	r16, 0x08	; 8
    1216:	10 e0       	ldi	r17, 0x00	; 0
    1218:	ff 24       	eor	r15, r15
    121a:	f3 94       	inc	r15
    121c:	61 e0       	ldi	r22, 0x01	; 1
    121e:	8d 2d       	mov	r24, r13
    1220:	8f 21       	and	r24, r15
    1222:	09 f4       	brne	.+2      	; 0x1226 <_ZN7OneWire5writeEhh+0x26>
    1224:	60 e0       	ldi	r22, 0x00	; 0
    1226:	ce 01       	movw	r24, r28
    1228:	0e 94 a2 08 	call	0x1144	; 0x1144 <_ZN7OneWire9write_bitEh>
    122c:	ff 0c       	add	r15, r15
    122e:	01 50       	subi	r16, 0x01	; 1
    1230:	11 09       	sbc	r17, r1
    1232:	a1 f7       	brne	.-24     	; 0x121c <_ZN7OneWire5writeEhh+0x1c>
    1234:	e1 10       	cpse	r14, r1
    1236:	10 c0       	rjmp	.+32     	; 0x1258 <_ZN7OneWire5writeEhh+0x58>
    1238:	f8 94       	cli
    123a:	e9 81       	ldd	r30, Y+1	; 0x01
    123c:	fa 81       	ldd	r31, Y+2	; 0x02
    123e:	91 81       	ldd	r25, Z+1	; 0x01
    1240:	88 81       	ld	r24, Y
    1242:	80 95       	com	r24
    1244:	89 23       	and	r24, r25
    1246:	81 83       	std	Z+1, r24	; 0x01
    1248:	e9 81       	ldd	r30, Y+1	; 0x01
    124a:	fa 81       	ldd	r31, Y+2	; 0x02
    124c:	92 81       	ldd	r25, Z+2	; 0x02
    124e:	88 81       	ld	r24, Y
    1250:	80 95       	com	r24
    1252:	89 23       	and	r24, r25
    1254:	82 83       	std	Z+2, r24	; 0x02
    1256:	78 94       	sei
    1258:	df 91       	pop	r29
    125a:	cf 91       	pop	r28
    125c:	1f 91       	pop	r17
    125e:	0f 91       	pop	r16
    1260:	ff 90       	pop	r15
    1262:	ef 90       	pop	r14
    1264:	df 90       	pop	r13
    1266:	08 95       	ret

00001268 <_ZN7OneWire4readEv>:
    1268:	ef 92       	push	r14
    126a:	ff 92       	push	r15
    126c:	0f 93       	push	r16
    126e:	1f 93       	push	r17
    1270:	cf 93       	push	r28
    1272:	df 93       	push	r29
    1274:	7c 01       	movw	r14, r24
    1276:	08 e0       	ldi	r16, 0x08	; 8
    1278:	10 e0       	ldi	r17, 0x00	; 0
    127a:	c0 e0       	ldi	r28, 0x00	; 0
    127c:	d1 e0       	ldi	r29, 0x01	; 1
    127e:	c7 01       	movw	r24, r14
    1280:	0e 94 d5 08 	call	0x11aa	; 0x11aa <_ZN7OneWire8read_bitEv>
    1284:	81 11       	cpse	r24, r1
    1286:	cd 2b       	or	r28, r29
    1288:	dd 0f       	add	r29, r29
    128a:	01 50       	subi	r16, 0x01	; 1
    128c:	11 09       	sbc	r17, r1
    128e:	b9 f7       	brne	.-18     	; 0x127e <_ZN7OneWire4readEv+0x16>
    1290:	8c 2f       	mov	r24, r28
    1292:	df 91       	pop	r29
    1294:	cf 91       	pop	r28
    1296:	1f 91       	pop	r17
    1298:	0f 91       	pop	r16
    129a:	ff 90       	pop	r15
    129c:	ef 90       	pop	r14
    129e:	08 95       	ret

000012a0 <_ZN7OneWire6selectEPKh>:
    12a0:	ef 92       	push	r14
    12a2:	ff 92       	push	r15
    12a4:	0f 93       	push	r16
    12a6:	1f 93       	push	r17
    12a8:	cf 93       	push	r28
    12aa:	df 93       	push	r29
    12ac:	8c 01       	movw	r16, r24
    12ae:	7b 01       	movw	r14, r22
    12b0:	40 e0       	ldi	r20, 0x00	; 0
    12b2:	65 e5       	ldi	r22, 0x55	; 85
    12b4:	0e 94 00 09 	call	0x1200	; 0x1200 <_ZN7OneWire5writeEhh>
    12b8:	e7 01       	movw	r28, r14
    12ba:	88 e0       	ldi	r24, 0x08	; 8
    12bc:	e8 0e       	add	r14, r24
    12be:	f1 1c       	adc	r15, r1
    12c0:	69 91       	ld	r22, Y+
    12c2:	40 e0       	ldi	r20, 0x00	; 0
    12c4:	c8 01       	movw	r24, r16
    12c6:	0e 94 00 09 	call	0x1200	; 0x1200 <_ZN7OneWire5writeEhh>
    12ca:	ce 15       	cp	r28, r14
    12cc:	df 05       	cpc	r29, r15
    12ce:	c1 f7       	brne	.-16     	; 0x12c0 <_ZN7OneWire6selectEPKh+0x20>
    12d0:	df 91       	pop	r29
    12d2:	cf 91       	pop	r28
    12d4:	1f 91       	pop	r17
    12d6:	0f 91       	pop	r16
    12d8:	ff 90       	pop	r15
    12da:	ef 90       	pop	r14
    12dc:	08 95       	ret

000012de <_ZN7OneWire12reset_searchEv>:
    12de:	fc 01       	movw	r30, r24
    12e0:	13 86       	std	Z+11, r1	; 0x0b
    12e2:	15 86       	std	Z+13, r1	; 0x0d
    12e4:	14 86       	std	Z+12, r1	; 0x0c
    12e6:	dc 01       	movw	r26, r24
    12e8:	1b 96       	adiw	r26, 0x0b	; 11
    12ea:	33 96       	adiw	r30, 0x03	; 3
    12ec:	1e 92       	st	-X, r1
    12ee:	ae 17       	cp	r26, r30
    12f0:	bf 07       	cpc	r27, r31
    12f2:	e1 f7       	brne	.-8      	; 0x12ec <_ZN7OneWire12reset_searchEv+0xe>
    12f4:	08 95       	ret

000012f6 <_ZN7OneWire5beginEh>:
    12f6:	1f 93       	push	r17
    12f8:	cf 93       	push	r28
    12fa:	df 93       	push	r29
    12fc:	ec 01       	movw	r28, r24
    12fe:	16 2f       	mov	r17, r22
    1300:	60 e0       	ldi	r22, 0x00	; 0
    1302:	81 2f       	mov	r24, r17
    1304:	0e 94 78 14 	call	0x28f0	; 0x28f0 <pinMode>
    1308:	61 2f       	mov	r22, r17
    130a:	70 e0       	ldi	r23, 0x00	; 0
    130c:	fb 01       	movw	r30, r22
    130e:	ea 53       	subi	r30, 0x3A	; 58
    1310:	ff 4f       	sbci	r31, 0xFF	; 255
    1312:	e4 91       	lpm	r30, Z
    1314:	e8 83       	st	Y, r30
    1316:	fb 01       	movw	r30, r22
    1318:	e6 52       	subi	r30, 0x26	; 38
    131a:	ff 4f       	sbci	r31, 0xFF	; 255
    131c:	e4 91       	lpm	r30, Z
    131e:	f0 e0       	ldi	r31, 0x00	; 0
    1320:	ee 0f       	add	r30, r30
    1322:	ff 1f       	adc	r31, r31
    1324:	e2 51       	subi	r30, 0x12	; 18
    1326:	ff 4f       	sbci	r31, 0xFF	; 255
    1328:	85 91       	lpm	r24, Z+
    132a:	94 91       	lpm	r25, Z
    132c:	9a 83       	std	Y+2, r25	; 0x02
    132e:	89 83       	std	Y+1, r24	; 0x01
    1330:	ce 01       	movw	r24, r28
    1332:	df 91       	pop	r29
    1334:	cf 91       	pop	r28
    1336:	1f 91       	pop	r17
    1338:	0c 94 6f 09 	jmp	0x12de	; 0x12de <_ZN7OneWire12reset_searchEv>

0000133c <_ZN7OneWire6searchEPhb>:
// search state.
// Return TRUE  : device found, ROM number in ROM_NO buffer
//        FALSE : device not found, end of search
//
bool OneWire::search(uint8_t *newAddr, bool search_mode /* = true */)
{
    133c:	bf 92       	push	r11
    133e:	cf 92       	push	r12
    1340:	df 92       	push	r13
    1342:	ef 92       	push	r14
    1344:	ff 92       	push	r15
    1346:	0f 93       	push	r16
    1348:	1f 93       	push	r17
    134a:	cf 93       	push	r28
    134c:	df 93       	push	r29
    134e:	ec 01       	movw	r28, r24
    1350:	6b 01       	movw	r12, r22
    1352:	14 2f       	mov	r17, r20
   rom_byte_number = 0;
   rom_byte_mask = 1;
   search_result = false;

   // if the last call was not the last one
   if (!LastDeviceFlag) {
    1354:	8d 85       	ldd	r24, Y+13	; 0x0d
    1356:	81 11       	cpse	r24, r1
    1358:	05 c0       	rjmp	.+10     	; 0x1364 <_ZN7OneWire6searchEPhb+0x28>
      // 1-Wire reset
      if (!reset()) {
    135a:	ce 01       	movw	r24, r28
    135c:	0e 94 63 08 	call	0x10c6	; 0x10c6 <_ZN7OneWire5resetEv>
    1360:	81 11       	cpse	r24, r1
    1362:	05 c0       	rjmp	.+10     	; 0x136e <_ZN7OneWire6searchEPhb+0x32>
         // reset the search
         LastDiscrepancy = 0;
    1364:	1b 86       	std	Y+11, r1	; 0x0b
         LastDeviceFlag = false;
    1366:	1d 86       	std	Y+13, r1	; 0x0d
         LastFamilyDiscrepancy = 0;
    1368:	1c 86       	std	Y+12, r1	; 0x0c
         return false;
    136a:	80 e0       	ldi	r24, 0x00	; 0
    136c:	64 c0       	rjmp	.+200    	; 0x1436 <_ZN7OneWire6searchEPhb+0xfa>
      }

      // issue the search command
      if (search_mode == true) {
        write(0xF0);   // NORMAL SEARCH
    136e:	40 e0       	ldi	r20, 0x00	; 0
         LastFamilyDiscrepancy = 0;
         return false;
      }

      // issue the search command
      if (search_mode == true) {
    1370:	11 23       	and	r17, r17
    1372:	11 f0       	breq	.+4      	; 0x1378 <_ZN7OneWire6searchEPhb+0x3c>
        write(0xF0);   // NORMAL SEARCH
    1374:	60 ef       	ldi	r22, 0xF0	; 240
    1376:	01 c0       	rjmp	.+2      	; 0x137a <_ZN7OneWire6searchEPhb+0x3e>
      } else {
        write(0xEC);   // CONDITIONAL SEARCH
    1378:	6c ee       	ldi	r22, 0xEC	; 236
    137a:	ce 01       	movw	r24, r28
    137c:	0e 94 00 09 	call	0x1200	; 0x1200 <_ZN7OneWire5writeEhh>
// search state.
// Return TRUE  : device found, ROM number in ROM_NO buffer
//        FALSE : device not found, end of search
//
bool OneWire::search(uint8_t *newAddr, bool search_mode /* = true */)
{
    1380:	01 e0       	ldi	r16, 0x01	; 1
    1382:	e1 2c       	mov	r14, r1
    1384:	b1 2c       	mov	r11, r1
    1386:	11 e0       	ldi	r17, 0x01	; 1

      // loop to do the search
      do
      {
         // read a bit and its complement
         id_bit = read_bit();
    1388:	ce 01       	movw	r24, r28
    138a:	0e 94 d5 08 	call	0x11aa	; 0x11aa <_ZN7OneWire8read_bitEv>
    138e:	f8 2e       	mov	r15, r24
         cmp_id_bit = read_bit();
    1390:	ce 01       	movw	r24, r28
    1392:	0e 94 d5 08 	call	0x11aa	; 0x11aa <_ZN7OneWire8read_bitEv>

         // check for no devices on 1-wire
         if ((id_bit == 1) && (cmp_id_bit == 1)) {
    1396:	91 e0       	ldi	r25, 0x01	; 1
    1398:	f9 12       	cpse	r15, r25
    139a:	03 c0       	rjmp	.+6      	; 0x13a2 <_ZN7OneWire6searchEPhb+0x66>
    139c:	81 30       	cpi	r24, 0x01	; 1
    139e:	b1 f4       	brne	.+44     	; 0x13cc <_ZN7OneWire6searchEPhb+0x90>
    13a0:	34 c0       	rjmp	.+104    	; 0x140a <_ZN7OneWire6searchEPhb+0xce>
    13a2:	2e 2d       	mov	r18, r14
    13a4:	30 e0       	ldi	r19, 0x00	; 0
            break;
         } else {
            // all devices coupled have 0 or 1
            if (id_bit != cmp_id_bit) {
    13a6:	f8 12       	cpse	r15, r24
    13a8:	1b c0       	rjmp	.+54     	; 0x13e0 <_ZN7OneWire6searchEPhb+0xa4>
               search_direction = id_bit;  // bit write value for search
            } else {
               // if this discrepancy if before the Last Discrepancy
               // on a previous next then pick the same as last time
               if (id_bit_number < LastDiscrepancy) {
    13aa:	8b 85       	ldd	r24, Y+11	; 0x0b
    13ac:	18 17       	cp	r17, r24
    13ae:	38 f4       	brcc	.+14     	; 0x13be <_ZN7OneWire6searchEPhb+0x82>
                  search_direction = ((ROM_NO[rom_byte_number] & rom_byte_mask) > 0);
    13b0:	fe 01       	movw	r30, r28
    13b2:	e2 0f       	add	r30, r18
    13b4:	f3 1f       	adc	r31, r19
    13b6:	83 81       	ldd	r24, Z+3	; 0x03
    13b8:	80 23       	and	r24, r16
    13ba:	41 f4       	brne	.+16     	; 0x13cc <_ZN7OneWire6searchEPhb+0x90>
    13bc:	02 c0       	rjmp	.+4      	; 0x13c2 <_ZN7OneWire6searchEPhb+0x86>
               } else {
                  // if equal to last pick 1, if not then pick 0
                  search_direction = (id_bit_number == LastDiscrepancy);
    13be:	18 17       	cp	r17, r24
    13c0:	29 f0       	breq	.+10     	; 0x13cc <_ZN7OneWire6searchEPhb+0x90>
    13c2:	f1 2c       	mov	r15, r1
               // if 0 was picked then record its position in LastZero
               if (search_direction == 0) {
                  last_zero = id_bit_number;

                  // check for Last discrepancy in family
                  if (last_zero < 9)
    13c4:	19 30       	cpi	r17, 0x09	; 9
    13c6:	58 f4       	brcc	.+22     	; 0x13de <_ZN7OneWire6searchEPhb+0xa2>
                     LastFamilyDiscrepancy = last_zero;
    13c8:	1c 87       	std	Y+12, r17	; 0x0c
    13ca:	09 c0       	rjmp	.+18     	; 0x13de <_ZN7OneWire6searchEPhb+0xa2>
            }

            // set or clear the bit in the ROM byte rom_byte_number
            // with mask rom_byte_mask
            if (search_direction == 1)
              ROM_NO[rom_byte_number] |= rom_byte_mask;
    13cc:	fe 01       	movw	r30, r28
    13ce:	ee 0d       	add	r30, r14
    13d0:	f1 1d       	adc	r31, r1
    13d2:	83 81       	ldd	r24, Z+3	; 0x03
    13d4:	80 2b       	or	r24, r16
    13d6:	83 83       	std	Z+3, r24	; 0x03
    13d8:	ff 24       	eor	r15, r15
    13da:	f3 94       	inc	r15
    13dc:	09 c0       	rjmp	.+18     	; 0x13f0 <_ZN7OneWire6searchEPhb+0xb4>
// search state.
// Return TRUE  : device found, ROM number in ROM_NO buffer
//        FALSE : device not found, end of search
//
bool OneWire::search(uint8_t *newAddr, bool search_mode /* = true */)
{
    13de:	b1 2e       	mov	r11, r17
            // set or clear the bit in the ROM byte rom_byte_number
            // with mask rom_byte_mask
            if (search_direction == 1)
              ROM_NO[rom_byte_number] |= rom_byte_mask;
            else
              ROM_NO[rom_byte_number] &= ~rom_byte_mask;
    13e0:	fe 01       	movw	r30, r28
    13e2:	e2 0f       	add	r30, r18
    13e4:	f3 1f       	adc	r31, r19
    13e6:	93 81       	ldd	r25, Z+3	; 0x03
    13e8:	80 2f       	mov	r24, r16
    13ea:	80 95       	com	r24
    13ec:	89 23       	and	r24, r25
    13ee:	83 83       	std	Z+3, r24	; 0x03

            // serial number search direction write bit
            write_bit(search_direction);
    13f0:	6f 2d       	mov	r22, r15
    13f2:	ce 01       	movw	r24, r28
    13f4:	0e 94 a2 08 	call	0x1144	; 0x1144 <_ZN7OneWire9write_bitEh>

            // increment the byte counter id_bit_number
            // and shift the mask rom_byte_mask
            id_bit_number++;
    13f8:	1f 5f       	subi	r17, 0xFF	; 255
            rom_byte_mask <<= 1;
    13fa:	00 0f       	add	r16, r16

            // if the mask is 0 then go to new SerialNum byte rom_byte_number and reset mask
            if (rom_byte_mask == 0) {
    13fc:	11 f4       	brne	.+4      	; 0x1402 <_ZN7OneWire6searchEPhb+0xc6>
                rom_byte_number++;
    13fe:	e3 94       	inc	r14
                rom_byte_mask = 1;
    1400:	01 e0       	ldi	r16, 0x01	; 1
            }
         }
      }
      while(rom_byte_number < 8);  // loop until through all ROM bytes 0-7
    1402:	87 e0       	ldi	r24, 0x07	; 7
    1404:	8e 15       	cp	r24, r14
    1406:	08 f0       	brcs	.+2      	; 0x140a <_ZN7OneWire6searchEPhb+0xce>
    1408:	bf cf       	rjmp	.-130    	; 0x1388 <_ZN7OneWire6searchEPhb+0x4c>

      // if the search was successful then
      if (!(id_bit_number < 65)) {
    140a:	11 34       	cpi	r17, 0x41	; 65
    140c:	08 f4       	brcc	.+2      	; 0x1410 <_ZN7OneWire6searchEPhb+0xd4>
    140e:	aa cf       	rjmp	.-172    	; 0x1364 <_ZN7OneWire6searchEPhb+0x28>
         // search successful so set LastDiscrepancy,LastDeviceFlag,search_result
         LastDiscrepancy = last_zero;
    1410:	bb 86       	std	Y+11, r11	; 0x0b

         // check for last device
         if (LastDiscrepancy == 0) {
    1412:	b1 10       	cpse	r11, r1
    1414:	02 c0       	rjmp	.+4      	; 0x141a <_ZN7OneWire6searchEPhb+0xde>
            LastDeviceFlag = true;
    1416:	81 e0       	ldi	r24, 0x01	; 1
    1418:	8d 87       	std	Y+13, r24	; 0x0d
         search_result = true;
      }
   }

   // if no device found then reset counters so next 'search' will be like a first
   if (!search_result || !ROM_NO[0]) {
    141a:	8b 81       	ldd	r24, Y+3	; 0x03
    141c:	88 23       	and	r24, r24
    141e:	09 f4       	brne	.+2      	; 0x1422 <_ZN7OneWire6searchEPhb+0xe6>
    1420:	a1 cf       	rjmp	.-190    	; 0x1364 <_ZN7OneWire6searchEPhb+0x28>
    1422:	de 01       	movw	r26, r28
    1424:	13 96       	adiw	r26, 0x03	; 3
    1426:	f6 01       	movw	r30, r12
    1428:	2b 96       	adiw	r28, 0x0b	; 11
      LastDiscrepancy = 0;
      LastDeviceFlag = false;
      LastFamilyDiscrepancy = 0;
      search_result = false;
   } else {
      for (int i = 0; i < 8; i++) newAddr[i] = ROM_NO[i];
    142a:	8d 91       	ld	r24, X+
    142c:	81 93       	st	Z+, r24
    142e:	ca 17       	cp	r28, r26
    1430:	db 07       	cpc	r29, r27
    1432:	d9 f7       	brne	.-10     	; 0x142a <_ZN7OneWire6searchEPhb+0xee>
    1434:	81 e0       	ldi	r24, 0x01	; 1
   }
   return search_result;
  }
    1436:	df 91       	pop	r29
    1438:	cf 91       	pop	r28
    143a:	1f 91       	pop	r17
    143c:	0f 91       	pop	r16
    143e:	ff 90       	pop	r15
    1440:	ef 90       	pop	r14
    1442:	df 90       	pop	r13
    1444:	cf 90       	pop	r12
    1446:	bf 90       	pop	r11
    1448:	08 95       	ret

0000144a <_ZN7OneWire4crc8EPKhh>:
};

// Compute a Dallas Semiconductor 8 bit CRC. These show up in the ROM
// and the registers.  (Use tiny 2x16 entry CRC table)
uint8_t OneWire::crc8(const uint8_t *addr, uint8_t len)
{
    144a:	dc 01       	movw	r26, r24
	uint8_t crc = 0;
    144c:	80 e0       	ldi	r24, 0x00	; 0

	while (len--) {
    144e:	61 50       	subi	r22, 0x01	; 1
    1450:	98 f0       	brcs	.+38     	; 0x1478 <_ZN7OneWire4crc8EPKhh+0x2e>
		crc = *addr++ ^ crc;  // just re-using crc as intermediate
    1452:	2d 91       	ld	r18, X+
    1454:	98 2f       	mov	r25, r24
    1456:	92 27       	eor	r25, r18
		crc = pgm_read_byte(dscrc2x16_table + (crc & 0x0f)) ^
    1458:	e9 2f       	mov	r30, r25
    145a:	ef 70       	andi	r30, 0x0F	; 15
    145c:	f0 e0       	ldi	r31, 0x00	; 0
    145e:	ee 56       	subi	r30, 0x6E	; 110
    1460:	ff 4f       	sbci	r31, 0xFF	; 255
    1462:	24 91       	lpm	r18, Z
		pgm_read_byte(dscrc2x16_table + 16 + ((crc >> 4) & 0x0f));
    1464:	92 95       	swap	r25
    1466:	9f 70       	andi	r25, 0x0F	; 15
    1468:	e9 2f       	mov	r30, r25
    146a:	f0 e0       	ldi	r31, 0x00	; 0
    146c:	ee 55       	subi	r30, 0x5E	; 94
    146e:	ff 4f       	sbci	r31, 0xFF	; 255
    1470:	e4 91       	lpm	r30, Z
    1472:	82 2f       	mov	r24, r18
    1474:	8e 27       	eor	r24, r30
// and the registers.  (Use tiny 2x16 entry CRC table)
uint8_t OneWire::crc8(const uint8_t *addr, uint8_t len)
{
	uint8_t crc = 0;

	while (len--) {
    1476:	eb cf       	rjmp	.-42     	; 0x144e <_ZN7OneWire4crc8EPKhh+0x4>
		crc = pgm_read_byte(dscrc2x16_table + (crc & 0x0f)) ^
		pgm_read_byte(dscrc2x16_table + 16 + ((crc >> 4) & 0x0f));
	}

	return crc;
}
    1478:	08 95       	ret

0000147a <_Z6phInitv>:
}

void calibratePH(long temperaturePH) {
	float voltage = analogRead(PH_PIN)/1024.0*5000;
	ph.calibration(voltage, temperaturePH);
    147a:	88 e9       	ldi	r24, 0x98	; 152
    147c:	93 e0       	ldi	r25, 0x03	; 3
    147e:	0c 94 de 00 	jmp	0x1bc	; 0x1bc <_ZN10DFRobot_PH5beginEv>

00001482 <_Z5getPHl>:
    1482:	cf 92       	push	r12
    1484:	df 92       	push	r13
    1486:	ef 92       	push	r14
    1488:	ff 92       	push	r15
    148a:	0f 93       	push	r16
    148c:	1f 93       	push	r17
    148e:	cf 93       	push	r28
    1490:	df 93       	push	r29
    1492:	6b 01       	movw	r12, r22
    1494:	7c 01       	movw	r14, r24
    1496:	8e e0       	ldi	r24, 0x0E	; 14
    1498:	0e 94 d3 13 	call	0x27a6	; 0x27a6 <analogRead>
    149c:	ec 01       	movw	r28, r24
    149e:	c7 01       	movw	r24, r14
    14a0:	b6 01       	movw	r22, r12
    14a2:	0e 94 42 0d 	call	0x1a84	; 0x1a84 <__floatsisf>
    14a6:	6b 01       	movw	r12, r22
    14a8:	7c 01       	movw	r14, r24
    14aa:	be 01       	movw	r22, r28
    14ac:	dd 0f       	add	r29, r29
    14ae:	88 0b       	sbc	r24, r24
    14b0:	99 0b       	sbc	r25, r25
    14b2:	0e 94 42 0d 	call	0x1a84	; 0x1a84 <__floatsisf>
    14b6:	20 e0       	ldi	r18, 0x00	; 0
    14b8:	30 e0       	ldi	r19, 0x00	; 0
    14ba:	40 e8       	ldi	r20, 0x80	; 128
    14bc:	5a e3       	ldi	r21, 0x3A	; 58
    14be:	0e 94 f7 0d 	call	0x1bee	; 0x1bee <__mulsf3>
    14c2:	20 e0       	ldi	r18, 0x00	; 0
    14c4:	30 e4       	ldi	r19, 0x40	; 64
    14c6:	4c e9       	ldi	r20, 0x9C	; 156
    14c8:	55 e4       	ldi	r21, 0x45	; 69
    14ca:	0e 94 f7 0d 	call	0x1bee	; 0x1bee <__mulsf3>
    14ce:	ab 01       	movw	r20, r22
    14d0:	bc 01       	movw	r22, r24
    14d2:	97 01       	movw	r18, r14
    14d4:	86 01       	movw	r16, r12
    14d6:	88 e9       	ldi	r24, 0x98	; 152
    14d8:	93 e0       	ldi	r25, 0x03	; 3
    14da:	0e 94 8d 01 	call	0x31a	; 0x31a <_ZN10DFRobot_PH6readPHEff>
    14de:	df 91       	pop	r29
    14e0:	cf 91       	pop	r28
    14e2:	1f 91       	pop	r17
    14e4:	0f 91       	pop	r16
    14e6:	ff 90       	pop	r15
    14e8:	ef 90       	pop	r14
    14ea:	df 90       	pop	r13
    14ec:	cf 90       	pop	r12
    14ee:	08 95       	ret

000014f0 <_GLOBAL__sub_I_ph>:
#include "phSensor.h"

DFRobot_PH ph;
    14f0:	88 e9       	ldi	r24, 0x98	; 152
    14f2:	93 e0       	ldi	r25, 0x03	; 3
    14f4:	0c 94 b7 00 	jmp	0x16e	; 0x16e <_ZN10DFRobot_PHC1Ev>

000014f8 <_GLOBAL__sub_D_ph>:
    14f8:	88 e9       	ldi	r24, 0x98	; 152
    14fa:	93 e0       	ldi	r25, 0x03	; 3
    14fc:	0c 94 dd 00 	jmp	0x1ba	; 0x1ba <_ZN10DFRobot_PHD1Ev>

00001500 <_ZN9MD_TCS23010initialiseEv>:
  }
  FreqCount.end();      // stop
  DUMP("VALUE ", FreqCount.read());

  return(FreqCount.read() * _readDiv);
}
    1500:	0f 93       	push	r16
    1502:	1f 93       	push	r17
    1504:	fc 01       	movw	r30, r24
    1506:	8f ef       	ldi	r24, 0xFF	; 255
    1508:	80 83       	st	Z, r24
    150a:	81 83       	std	Z+1, r24	; 0x01
    150c:	82 83       	std	Z+2, r24	; 0x02
    150e:	83 83       	std	Z+3, r24	; 0x03
    1510:	84 83       	std	Z+4, r24	; 0x04
    1512:	8a e0       	ldi	r24, 0x0A	; 10
    1514:	85 83       	std	Z+5, r24	; 0x05
    1516:	16 82       	std	Z+6, r1	; 0x06
    1518:	df 01       	movw	r26, r30
    151a:	17 96       	adiw	r26, 0x07	; 7
    151c:	73 96       	adiw	r30, 0x13	; 19
    151e:	00 e7       	ldi	r16, 0x70	; 112
    1520:	17 e1       	ldi	r17, 0x17	; 23
    1522:	20 e0       	ldi	r18, 0x00	; 0
    1524:	30 e0       	ldi	r19, 0x00	; 0
    1526:	48 ed       	ldi	r20, 0xD8	; 216
    1528:	56 ed       	ldi	r21, 0xD6	; 214
    152a:	60 e0       	ldi	r22, 0x00	; 0
    152c:	70 e0       	ldi	r23, 0x00	; 0
    152e:	0d 93       	st	X+, r16
    1530:	1d 93       	st	X+, r17
    1532:	2d 93       	st	X+, r18
    1534:	3d 93       	st	X+, r19
    1536:	18 96       	adiw	r26, 0x08	; 8
    1538:	4d 93       	st	X+, r20
    153a:	5d 93       	st	X+, r21
    153c:	6d 93       	st	X+, r22
    153e:	7c 93       	st	X, r23
    1540:	1b 97       	sbiw	r26, 0x0b	; 11
    1542:	ae 17       	cp	r26, r30
    1544:	bf 07       	cpc	r27, r31
    1546:	99 f7       	brne	.-26     	; 0x152e <_ZN9MD_TCS23010initialiseEv+0x2e>
    1548:	1f 91       	pop	r17
    154a:	0f 91       	pop	r16
    154c:	08 95       	ret

0000154e <_ZN9MD_TCS230C1Ehhh>:
    154e:	ff 92       	push	r15
    1550:	0f 93       	push	r16
    1552:	1f 93       	push	r17
    1554:	cf 93       	push	r28
    1556:	df 93       	push	r29
    1558:	ec 01       	movw	r28, r24
    155a:	f6 2e       	mov	r15, r22
    155c:	04 2f       	mov	r16, r20
    155e:	12 2f       	mov	r17, r18
    1560:	0e 94 80 0a 	call	0x1500	; 0x1500 <_ZN9MD_TCS23010initialiseEv>
    1564:	fb 82       	std	Y+3, r15	; 0x03
    1566:	0c 83       	std	Y+4, r16	; 0x04
    1568:	18 83       	st	Y, r17
    156a:	df 91       	pop	r29
    156c:	cf 91       	pop	r28
    156e:	1f 91       	pop	r17
    1570:	0f 91       	pop	r16
    1572:	ff 90       	pop	r15
    1574:	08 95       	ret

00001576 <_ZN9MD_TCS230D1Ev>:
    1576:	08 95       	ret

00001578 <_ZN9MD_TCS2309setFilterEh>:
    1578:	cf 93       	push	r28
    157a:	df 93       	push	r29
    157c:	ec 01       	movw	r28, r24
    157e:	8b 81       	ldd	r24, Y+3	; 0x03
    1580:	8f 3f       	cpi	r24, 0xFF	; 255
    1582:	e9 f0       	breq	.+58     	; 0x15be <_ZN9MD_TCS2309setFilterEh+0x46>
    1584:	9c 81       	ldd	r25, Y+4	; 0x04
    1586:	9f 3f       	cpi	r25, 0xFF	; 255
    1588:	d1 f0       	breq	.+52     	; 0x15be <_ZN9MD_TCS2309setFilterEh+0x46>
    158a:	61 30       	cpi	r22, 0x01	; 1
    158c:	49 f0       	breq	.+18     	; 0x15a0 <_ZN9MD_TCS2309setFilterEh+0x28>
    158e:	30 f0       	brcs	.+12     	; 0x159c <_ZN9MD_TCS2309setFilterEh+0x24>
    1590:	62 30       	cpi	r22, 0x02	; 2
    1592:	41 f0       	breq	.+16     	; 0x15a4 <_ZN9MD_TCS2309setFilterEh+0x2c>
    1594:	63 30       	cpi	r22, 0x03	; 3
    1596:	99 f4       	brne	.+38     	; 0x15be <_ZN9MD_TCS2309setFilterEh+0x46>
    1598:	61 e0       	ldi	r22, 0x01	; 1
    159a:	09 c0       	rjmp	.+18     	; 0x15ae <_ZN9MD_TCS2309setFilterEh+0x36>
    159c:	60 e0       	ldi	r22, 0x00	; 0
    159e:	07 c0       	rjmp	.+14     	; 0x15ae <_ZN9MD_TCS2309setFilterEh+0x36>
    15a0:	61 e0       	ldi	r22, 0x01	; 1
    15a2:	01 c0       	rjmp	.+2      	; 0x15a6 <_ZN9MD_TCS2309setFilterEh+0x2e>
    15a4:	60 e0       	ldi	r22, 0x00	; 0
    15a6:	0e 94 b4 14 	call	0x2968	; 0x2968 <digitalWrite>
    15aa:	61 e0       	ldi	r22, 0x01	; 1
    15ac:	03 c0       	rjmp	.+6      	; 0x15b4 <_ZN9MD_TCS2309setFilterEh+0x3c>
    15ae:	0e 94 b4 14 	call	0x2968	; 0x2968 <digitalWrite>
    15b2:	60 e0       	ldi	r22, 0x00	; 0
    15b4:	8c 81       	ldd	r24, Y+4	; 0x04
    15b6:	df 91       	pop	r29
    15b8:	cf 91       	pop	r28
    15ba:	0c 94 b4 14 	jmp	0x2968	; 0x2968 <digitalWrite>
    15be:	df 91       	pop	r29
    15c0:	cf 91       	pop	r28
    15c2:	08 95       	ret

000015c4 <_ZN9MD_TCS23013setFrequency2Eh>:
    15c4:	cf 93       	push	r28
    15c6:	df 93       	push	r29
    15c8:	ec 01       	movw	r28, r24
    15ca:	89 81       	ldd	r24, Y+1	; 0x01
    15cc:	8f 3f       	cpi	r24, 0xFF	; 255
    15ce:	e9 f0       	breq	.+58     	; 0x160a <_ZN9MD_TCS23013setFrequency2Eh+0x46>
    15d0:	9a 81       	ldd	r25, Y+2	; 0x02
    15d2:	9f 3f       	cpi	r25, 0xFF	; 255
    15d4:	d1 f0       	breq	.+52     	; 0x160a <_ZN9MD_TCS23013setFrequency2Eh+0x46>
    15d6:	61 30       	cpi	r22, 0x01	; 1
    15d8:	49 f0       	breq	.+18     	; 0x15ec <_ZN9MD_TCS23013setFrequency2Eh+0x28>
    15da:	30 f0       	brcs	.+12     	; 0x15e8 <_ZN9MD_TCS23013setFrequency2Eh+0x24>
    15dc:	62 30       	cpi	r22, 0x02	; 2
    15de:	41 f0       	breq	.+16     	; 0x15f0 <_ZN9MD_TCS23013setFrequency2Eh+0x2c>
    15e0:	63 30       	cpi	r22, 0x03	; 3
    15e2:	99 f4       	brne	.+38     	; 0x160a <_ZN9MD_TCS23013setFrequency2Eh+0x46>
    15e4:	60 e0       	ldi	r22, 0x00	; 0
    15e6:	09 c0       	rjmp	.+18     	; 0x15fa <_ZN9MD_TCS23013setFrequency2Eh+0x36>
    15e8:	61 e0       	ldi	r22, 0x01	; 1
    15ea:	03 c0       	rjmp	.+6      	; 0x15f2 <_ZN9MD_TCS23013setFrequency2Eh+0x2e>
    15ec:	61 e0       	ldi	r22, 0x01	; 1
    15ee:	05 c0       	rjmp	.+10     	; 0x15fa <_ZN9MD_TCS23013setFrequency2Eh+0x36>
    15f0:	60 e0       	ldi	r22, 0x00	; 0
    15f2:	0e 94 b4 14 	call	0x2968	; 0x2968 <digitalWrite>
    15f6:	61 e0       	ldi	r22, 0x01	; 1
    15f8:	03 c0       	rjmp	.+6      	; 0x1600 <_ZN9MD_TCS23013setFrequency2Eh+0x3c>
    15fa:	0e 94 b4 14 	call	0x2968	; 0x2968 <digitalWrite>
    15fe:	60 e0       	ldi	r22, 0x00	; 0
    1600:	8a 81       	ldd	r24, Y+2	; 0x02
    1602:	df 91       	pop	r29
    1604:	cf 91       	pop	r28
    1606:	0c 94 b4 14 	jmp	0x2968	; 0x2968 <digitalWrite>
    160a:	df 91       	pop	r29
    160c:	cf 91       	pop	r28
    160e:	08 95       	ret

00001610 <_ZN9MD_TCS2309setEnableEb>:
    1610:	fc 01       	movw	r30, r24
    1612:	20 81       	ld	r18, Z
    1614:	2f 3f       	cpi	r18, 0xFF	; 255
    1616:	29 f0       	breq	.+10     	; 0x1622 <_ZN9MD_TCS2309setEnableEb+0x12>
    1618:	91 e0       	ldi	r25, 0x01	; 1
    161a:	69 27       	eor	r22, r25
    161c:	82 2f       	mov	r24, r18
    161e:	0c 94 b4 14 	jmp	0x2968	; 0x2968 <digitalWrite>
    1622:	66 23       	and	r22, r22
    1624:	19 f0       	breq	.+6      	; 0x162c <_ZN9MD_TCS2309setEnableEb+0x1c>
    1626:	fc 01       	movw	r30, r24
    1628:	66 81       	ldd	r22, Z+6	; 0x06
    162a:	01 c0       	rjmp	.+2      	; 0x162e <_ZN9MD_TCS2309setEnableEb+0x1e>
    162c:	63 e0       	ldi	r22, 0x03	; 3
    162e:	0c 94 e2 0a 	jmp	0x15c4	; 0x15c4 <_ZN9MD_TCS23013setFrequency2Eh>

00001632 <_ZN9MD_TCS2305beginEv>:
    1632:	cf 93       	push	r28
    1634:	df 93       	push	r29
    1636:	ec 01       	movw	r28, r24
    1638:	89 81       	ldd	r24, Y+1	; 0x01
    163a:	8f 3f       	cpi	r24, 0xFF	; 255
    163c:	19 f0       	breq	.+6      	; 0x1644 <_ZN9MD_TCS2305beginEv+0x12>
    163e:	61 e0       	ldi	r22, 0x01	; 1
    1640:	0e 94 78 14 	call	0x28f0	; 0x28f0 <pinMode>
    1644:	8a 81       	ldd	r24, Y+2	; 0x02
    1646:	8f 3f       	cpi	r24, 0xFF	; 255
    1648:	19 f0       	breq	.+6      	; 0x1650 <_ZN9MD_TCS2305beginEv+0x1e>
    164a:	61 e0       	ldi	r22, 0x01	; 1
    164c:	0e 94 78 14 	call	0x28f0	; 0x28f0 <pinMode>
    1650:	8b 81       	ldd	r24, Y+3	; 0x03
    1652:	8f 3f       	cpi	r24, 0xFF	; 255
    1654:	19 f0       	breq	.+6      	; 0x165c <_ZN9MD_TCS2305beginEv+0x2a>
    1656:	61 e0       	ldi	r22, 0x01	; 1
    1658:	0e 94 78 14 	call	0x28f0	; 0x28f0 <pinMode>
    165c:	8c 81       	ldd	r24, Y+4	; 0x04
    165e:	8f 3f       	cpi	r24, 0xFF	; 255
    1660:	19 f0       	breq	.+6      	; 0x1668 <_ZN9MD_TCS2305beginEv+0x36>
    1662:	61 e0       	ldi	r22, 0x01	; 1
    1664:	0e 94 78 14 	call	0x28f0	; 0x28f0 <pinMode>
    1668:	88 81       	ld	r24, Y
    166a:	8f 3f       	cpi	r24, 0xFF	; 255
    166c:	19 f0       	breq	.+6      	; 0x1674 <_ZN9MD_TCS2305beginEv+0x42>
    166e:	61 e0       	ldi	r22, 0x01	; 1
    1670:	0e 94 78 14 	call	0x28f0	; 0x28f0 <pinMode>
    1674:	60 e0       	ldi	r22, 0x00	; 0
    1676:	ce 01       	movw	r24, r28
    1678:	0e 94 08 0b 	call	0x1610	; 0x1610 <_ZN9MD_TCS2309setEnableEb>
    167c:	6e 81       	ldd	r22, Y+6	; 0x06
    167e:	ce 01       	movw	r24, r28
    1680:	df 91       	pop	r29
    1682:	cf 91       	pop	r28
    1684:	0c 94 e2 0a 	jmp	0x15c4	; 0x15c4 <_ZN9MD_TCS23013setFrequency2Eh>

00001688 <_ZN9MD_TCS2306getRGBEP9colorData>:
    1688:	dc 01       	movw	r26, r24
    168a:	fb 01       	movw	r30, r22
    168c:	30 97       	sbiw	r30, 0x00	; 0
    168e:	59 f0       	breq	.+22     	; 0x16a6 <_ZN9MD_TCS2306getRGBEP9colorData+0x1e>
    1690:	9b 96       	adiw	r26, 0x2b	; 43
    1692:	8c 91       	ld	r24, X
    1694:	9b 97       	sbiw	r26, 0x2b	; 43
    1696:	80 83       	st	Z, r24
    1698:	9c 96       	adiw	r26, 0x2c	; 44
    169a:	8c 91       	ld	r24, X
    169c:	9c 97       	sbiw	r26, 0x2c	; 44
    169e:	81 83       	std	Z+1, r24	; 0x01
    16a0:	9d 96       	adiw	r26, 0x2d	; 45
    16a2:	8c 91       	ld	r24, X
    16a4:	82 83       	std	Z+2, r24	; 0x02
    16a6:	08 95       	ret

000016a8 <_ZN9MD_TCS23017RGBTransformationEv>:
  return(s);
}

void MD_TCS230::RGBTransformation(void)
// Exploiting linear relationship to remap the range 
{
    16a8:	4f 92       	push	r4
    16aa:	5f 92       	push	r5
    16ac:	6f 92       	push	r6
    16ae:	7f 92       	push	r7
    16b0:	8f 92       	push	r8
    16b2:	9f 92       	push	r9
    16b4:	af 92       	push	r10
    16b6:	bf 92       	push	r11
    16b8:	df 92       	push	r13
    16ba:	ef 92       	push	r14
    16bc:	ff 92       	push	r15
    16be:	0f 93       	push	r16
    16c0:	1f 93       	push	r17
    16c2:	cf 93       	push	r28
    16c4:	df 93       	push	r29
    16c6:	8c 01       	movw	r16, r24
    16c8:	09 5f       	subi	r16, 0xF9	; 249
    16ca:	1f 4f       	sbci	r17, 0xFF	; 255
    16cc:	ec 01       	movw	r28, r24
    16ce:	7c 01       	movw	r14, r24
    16d0:	83 e1       	ldi	r24, 0x13	; 19
    16d2:	e8 0e       	add	r14, r24
    16d4:	f1 1c       	adc	r15, r1
    x = (_Fo.value[i] - _Fd.value[i]) * 255;
    x /= (_Fw.value[i] - _Fd.value[i]);

    // copy results back into the global structures
    if (x < 0) _rgb.value[i] = 0; 
    else if (x > 255) _rgb.value[i] = 255;
    16d6:	dd 24       	eor	r13, r13
    16d8:	da 94       	dec	r13
    16da:	f8 01       	movw	r30, r16
{
  int32_t x;

  for (uint8_t i=0; i<RGB_SIZE; i++)
  {
    x = (_Fo.value[i] - _Fd.value[i]) * 255;
    16dc:	d8 01       	movw	r26, r16
    16de:	8d 90       	ld	r8, X+
    16e0:	9d 90       	ld	r9, X+
    16e2:	ad 90       	ld	r10, X+
    16e4:	bd 90       	ld	r11, X+
    16e6:	8d 01       	movw	r16, r26
    16e8:	80 8d       	ldd	r24, Z+24	; 0x18
    16ea:	91 8d       	ldd	r25, Z+25	; 0x19
    16ec:	a2 8d       	ldd	r26, Z+26	; 0x1a
    16ee:	b3 8d       	ldd	r27, Z+27	; 0x1b
    16f0:	9c 01       	movw	r18, r24
    16f2:	ad 01       	movw	r20, r26
    16f4:	28 19       	sub	r18, r8
    16f6:	39 09       	sbc	r19, r9
    16f8:	4a 09       	sbc	r20, r10
    16fa:	5b 09       	sbc	r21, r11
    16fc:	af ef       	ldi	r26, 0xFF	; 255
    16fe:	b0 e0       	ldi	r27, 0x00	; 0
    1700:	0e 94 04 22 	call	0x4408	; 0x4408 <__muluhisi3>
    x /= (_Fw.value[i] - _Fd.value[i]);
    1704:	f8 01       	movw	r30, r16
    1706:	40 84       	ldd	r4, Z+8	; 0x08
    1708:	51 84       	ldd	r5, Z+9	; 0x09
    170a:	62 84       	ldd	r6, Z+10	; 0x0a
    170c:	73 84       	ldd	r7, Z+11	; 0x0b
    170e:	a3 01       	movw	r20, r6
    1710:	92 01       	movw	r18, r4
    1712:	28 19       	sub	r18, r8
    1714:	39 09       	sbc	r19, r9
    1716:	4a 09       	sbc	r20, r10
    1718:	5b 09       	sbc	r21, r11
    171a:	0e 94 df 21 	call	0x43be	; 0x43be <__divmodsi4>

    // copy results back into the global structures
    if (x < 0) _rgb.value[i] = 0; 
    171e:	57 ff       	sbrs	r21, 7
    1720:	02 c0       	rjmp	.+4      	; 0x1726 <_ZN9MD_TCS23017RGBTransformationEv+0x7e>
    1722:	1b a6       	std	Y+43, r1	; 0x2b
    1724:	09 c0       	rjmp	.+18     	; 0x1738 <_ZN9MD_TCS23017RGBTransformationEv+0x90>
    else if (x > 255) _rgb.value[i] = 255;
    1726:	2f 3f       	cpi	r18, 0xFF	; 255
    1728:	31 05       	cpc	r19, r1
    172a:	41 05       	cpc	r20, r1
    172c:	51 05       	cpc	r21, r1
    172e:	19 f0       	breq	.+6      	; 0x1736 <_ZN9MD_TCS23017RGBTransformationEv+0x8e>
    1730:	14 f0       	brlt	.+4      	; 0x1736 <_ZN9MD_TCS23017RGBTransformationEv+0x8e>
    1732:	db a6       	std	Y+43, r13	; 0x2b
    1734:	01 c0       	rjmp	.+2      	; 0x1738 <_ZN9MD_TCS23017RGBTransformationEv+0x90>
    else _rgb.value[i] = x;
    1736:	2b a7       	std	Y+43, r18	; 0x2b
    1738:	21 96       	adiw	r28, 0x01	; 1
void MD_TCS230::RGBTransformation(void)
// Exploiting linear relationship to remap the range 
{
  int32_t x;

  for (uint8_t i=0; i<RGB_SIZE; i++)
    173a:	0e 15       	cp	r16, r14
    173c:	1f 05       	cpc	r17, r15
    173e:	69 f6       	brne	.-102    	; 0x16da <_ZN9MD_TCS23017RGBTransformationEv+0x32>
    // copy results back into the global structures
    if (x < 0) _rgb.value[i] = 0; 
    else if (x > 255) _rgb.value[i] = 255;
    else _rgb.value[i] = x;
  }
}
    1740:	df 91       	pop	r29
    1742:	cf 91       	pop	r28
    1744:	1f 91       	pop	r17
    1746:	0f 91       	pop	r16
    1748:	ff 90       	pop	r15
    174a:	ef 90       	pop	r14
    174c:	df 90       	pop	r13
    174e:	bf 90       	pop	r11
    1750:	af 90       	pop	r10
    1752:	9f 90       	pop	r9
    1754:	8f 90       	pop	r8
    1756:	7f 90       	pop	r7
    1758:	6f 90       	pop	r6
    175a:	5f 90       	pop	r5
    175c:	4f 90       	pop	r4
    175e:	08 95       	ret

00001760 <_ZN9MD_TCS2307readFSMEh>:
  return(_readState == 0);
}

uint8_t MD_TCS230::readFSM(uint8_t s)
// Finite State Machine to read a value (internal function)
{
    1760:	0f 93       	push	r16
    1762:	1f 93       	push	r17
    1764:	cf 93       	push	r28
    1766:	df 93       	push	r29
    1768:	8c 01       	movw	r16, r24
    176a:	c6 2f       	mov	r28, r22
  static const uint8_t seq[] = { TCS230_RGB_R, TCS230_RGB_G, TCS230_RGB_B };
  static uint8_t       currCol;  // index for seq above

  switch(s)
    176c:	61 30       	cpi	r22, 0x01	; 1
    176e:	49 f0       	breq	.+18     	; 0x1782 <_ZN9MD_TCS2307readFSMEh+0x22>
    1770:	18 f0       	brcs	.+6      	; 0x1778 <_ZN9MD_TCS2307readFSMEh+0x18>
    1772:	62 30       	cpi	r22, 0x02	; 2
    1774:	d9 f0       	breq	.+54     	; 0x17ac <_ZN9MD_TCS2307readFSMEh+0x4c>
    1776:	4c c0       	rjmp	.+152    	; 0x1810 <_ZN9MD_TCS2307readFSMEh+0xb0>
  {
  case 0: // enable the hardware for reading
    DUMPS("\n0");
    currCol = 0;  // RGB_R but we don't care
    1778:	10 92 b7 03 	sts	0x03B7, r1	; 0x8003b7 <_ZZN9MD_TCS2307readFSMEhE7currCol>
    setEnable(true);
    177c:	61 e0       	ldi	r22, 0x01	; 1
    177e:	0e 94 08 0b 	call	0x1610	; 0x1610 <_ZN9MD_TCS2309setEnableEb>
    s++;
    // fall through to the next state

  case 1: // select a filter and start a reading
    DUMPS("\n1");
    setFilter(seq[currCol]);
    1782:	e0 91 b7 03 	lds	r30, 0x03B7	; 0x8003b7 <_ZZN9MD_TCS2307readFSMEhE7currCol>
    1786:	f0 e0       	ldi	r31, 0x00	; 0
    1788:	ea 5b       	subi	r30, 0xBA	; 186
    178a:	fd 4f       	sbci	r31, 0xFD	; 253
    178c:	60 81       	ld	r22, Z
    178e:	c8 01       	movw	r24, r16
    1790:	0e 94 bc 0a 	call	0x1578	; 0x1578 <_ZN9MD_TCS2309setFilterEh>
    FreqCount.begin(1000/_readDiv);
    1794:	f8 01       	movw	r30, r16
    1796:	65 81       	ldd	r22, Z+5	; 0x05
    1798:	70 e0       	ldi	r23, 0x00	; 0
    179a:	88 ee       	ldi	r24, 0xE8	; 232
    179c:	93 e0       	ldi	r25, 0x03	; 3
    179e:	0e 94 a9 21 	call	0x4352	; 0x4352 <__divmodhi4>
    17a2:	cb 01       	movw	r24, r22
    17a4:	0e 94 ed 1b 	call	0x37da	; 0x37da <_ZN14FreqCountClass5beginEj>
    s++;
    17a8:	c2 e0       	ldi	r28, 0x02	; 2
    break;
    17aa:	32 c0       	rjmp	.+100    	; 0x1810 <_ZN9MD_TCS2307readFSMEh+0xb0>

  case 2: // see if a value is available
    DUMPS("2");
    if (FreqCount.available())
    17ac:	0e 94 65 1c 	call	0x38ca	; 0x38ca <_ZN14FreqCountClass9availableEv>
    17b0:	88 23       	and	r24, r24
    17b2:	71 f1       	breq	.+92     	; 0x1810 <_ZN9MD_TCS2307readFSMEh+0xb0>
    {
      DUMP(" VALUE ", FreqCount.read());
      // read the value and save it 
      _Fo.value[seq[currCol++]] = FreqCount.read() * _readDiv;
    17b4:	e0 91 b7 03 	lds	r30, 0x03B7	; 0x8003b7 <_ZZN9MD_TCS2307readFSMEhE7currCol>
    17b8:	81 e0       	ldi	r24, 0x01	; 1
    17ba:	8e 0f       	add	r24, r30
    17bc:	80 93 b7 03 	sts	0x03B7, r24	; 0x8003b7 <_ZZN9MD_TCS2307readFSMEhE7currCol>
    17c0:	f0 e0       	ldi	r31, 0x00	; 0
    17c2:	ea 5b       	subi	r30, 0xBA	; 186
    17c4:	fd 4f       	sbci	r31, 0xFD	; 253
    17c6:	c0 81       	ld	r28, Z
    17c8:	d0 e0       	ldi	r29, 0x00	; 0
    17ca:	0e 94 68 1c 	call	0x38d0	; 0x38d0 <_ZN14FreqCountClass4readEv>
    17ce:	9b 01       	movw	r18, r22
    17d0:	ac 01       	movw	r20, r24
    17d2:	cc 0f       	add	r28, r28
    17d4:	dd 1f       	adc	r29, r29
    17d6:	cc 0f       	add	r28, r28
    17d8:	dd 1f       	adc	r29, r29
    17da:	c0 0f       	add	r28, r16
    17dc:	d1 1f       	adc	r29, r17
    17de:	f8 01       	movw	r30, r16
    17e0:	a5 81       	ldd	r26, Z+5	; 0x05
    17e2:	b0 e0       	ldi	r27, 0x00	; 0
    17e4:	0e 94 04 22 	call	0x4408	; 0x4408 <__muluhisi3>
    17e8:	6f 8f       	std	Y+31, r22	; 0x1f
    17ea:	78 a3       	std	Y+32, r23	; 0x20
    17ec:	89 a3       	std	Y+33, r24	; 0x21
    17ee:	9a a3       	std	Y+34, r25	; 0x22

      if (currCol < RGB_SIZE)
    17f0:	80 91 b7 03 	lds	r24, 0x03B7	; 0x8003b7 <_ZZN9MD_TCS2307readFSMEhE7currCol>
    17f4:	83 30       	cpi	r24, 0x03	; 3
    17f6:	58 f0       	brcs	.+22     	; 0x180e <_ZN9MD_TCS2307readFSMEh+0xae>
        s--;
      }
      else
      {
        // end this reading session
        FreqCount.end();
    17f8:	0e 94 76 1c 	call	0x38ec	; 0x38ec <_ZN14FreqCountClass3endEv>
        setEnable(false);
    17fc:	60 e0       	ldi	r22, 0x00	; 0
    17fe:	c8 01       	movw	r24, r16
    1800:	0e 94 08 0b 	call	0x1610	; 0x1610 <_ZN9MD_TCS2309setEnableEb>
        RGBTransformation();
    1804:	c8 01       	movw	r24, r16
    1806:	0e 94 54 0b 	call	0x16a8	; 0x16a8 <_ZN9MD_TCS23017RGBTransformationEv>
        s = 0;
    180a:	c0 e0       	ldi	r28, 0x00	; 0
    180c:	01 c0       	rjmp	.+2      	; 0x1810 <_ZN9MD_TCS2307readFSMEh+0xb0>
      _Fo.value[seq[currCol++]] = FreqCount.read() * _readDiv;

      if (currCol < RGB_SIZE)
      {
        // loop around again on next call to available()
        s--;
    180e:	c1 e0       	ldi	r28, 0x01	; 1
    }
    break;
  }

  return(s);
}
    1810:	8c 2f       	mov	r24, r28
    1812:	df 91       	pop	r29
    1814:	cf 91       	pop	r28
    1816:	1f 91       	pop	r17
    1818:	0f 91       	pop	r16
    181a:	08 95       	ret

0000181c <_ZN9MD_TCS2304readEv>:
  return(FreqCount.read() * _readDiv);
}

void MD_TCS230::read(void)
// initiate the finite state machine for reading a value
{
    181c:	cf 93       	push	r28
    181e:	df 93       	push	r29
    1820:	ec 01       	movw	r28, r24
  _readState = readFSM(0);
    1822:	60 e0       	ldi	r22, 0x00	; 0
    1824:	0e 94 b0 0b 	call	0x1760	; 0x1760 <_ZN9MD_TCS2307readFSMEh>
    1828:	8e a7       	std	Y+46, r24	; 0x2e
}
    182a:	df 91       	pop	r29
    182c:	cf 91       	pop	r28
    182e:	08 95       	ret

00001830 <_ZN9MD_TCS2309availableEv>:

bool MD_TCS230::available(void)
// check if a value is ready. Called repeatedly until it is!
{
    1830:	cf 93       	push	r28
    1832:	df 93       	push	r29
    1834:	ec 01       	movw	r28, r24
  _readState = readFSM(_readState);
    1836:	6e a5       	ldd	r22, Y+46	; 0x2e
    1838:	0e 94 b0 0b 	call	0x1760	; 0x1760 <_ZN9MD_TCS2307readFSMEh>
    183c:	98 2f       	mov	r25, r24
    183e:	8e a7       	std	Y+46, r24	; 0x2e

  return(_readState == 0);
    1840:	81 e0       	ldi	r24, 0x01	; 1
    1842:	91 11       	cpse	r25, r1
    1844:	80 e0       	ldi	r24, 0x00	; 0
}
    1846:	df 91       	pop	r29
    1848:	cf 91       	pop	r28
    184a:	08 95       	ret

0000184c <__subsf3>:
    184c:	50 58       	subi	r21, 0x80	; 128

0000184e <__addsf3>:
    184e:	bb 27       	eor	r27, r27
    1850:	aa 27       	eor	r26, r26
    1852:	0e 94 3e 0c 	call	0x187c	; 0x187c <__addsf3x>
    1856:	0c 94 b8 0d 	jmp	0x1b70	; 0x1b70 <__fp_round>
    185a:	0e 94 aa 0d 	call	0x1b54	; 0x1b54 <__fp_pscA>
    185e:	38 f0       	brcs	.+14     	; 0x186e <__addsf3+0x20>
    1860:	0e 94 b1 0d 	call	0x1b62	; 0x1b62 <__fp_pscB>
    1864:	20 f0       	brcs	.+8      	; 0x186e <__addsf3+0x20>
    1866:	39 f4       	brne	.+14     	; 0x1876 <__addsf3+0x28>
    1868:	9f 3f       	cpi	r25, 0xFF	; 255
    186a:	19 f4       	brne	.+6      	; 0x1872 <__addsf3+0x24>
    186c:	26 f4       	brtc	.+8      	; 0x1876 <__addsf3+0x28>
    186e:	0c 94 a7 0d 	jmp	0x1b4e	; 0x1b4e <__fp_nan>
    1872:	0e f4       	brtc	.+2      	; 0x1876 <__addsf3+0x28>
    1874:	e0 95       	com	r30
    1876:	e7 fb       	bst	r30, 7
    1878:	0c 94 a1 0d 	jmp	0x1b42	; 0x1b42 <__fp_inf>

0000187c <__addsf3x>:
    187c:	e9 2f       	mov	r30, r25
    187e:	0e 94 c9 0d 	call	0x1b92	; 0x1b92 <__fp_split3>
    1882:	58 f3       	brcs	.-42     	; 0x185a <__addsf3+0xc>
    1884:	ba 17       	cp	r27, r26
    1886:	62 07       	cpc	r22, r18
    1888:	73 07       	cpc	r23, r19
    188a:	84 07       	cpc	r24, r20
    188c:	95 07       	cpc	r25, r21
    188e:	20 f0       	brcs	.+8      	; 0x1898 <__addsf3x+0x1c>
    1890:	79 f4       	brne	.+30     	; 0x18b0 <__addsf3x+0x34>
    1892:	a6 f5       	brtc	.+104    	; 0x18fc <__addsf3x+0x80>
    1894:	0c 94 eb 0d 	jmp	0x1bd6	; 0x1bd6 <__fp_zero>
    1898:	0e f4       	brtc	.+2      	; 0x189c <__addsf3x+0x20>
    189a:	e0 95       	com	r30
    189c:	0b 2e       	mov	r0, r27
    189e:	ba 2f       	mov	r27, r26
    18a0:	a0 2d       	mov	r26, r0
    18a2:	0b 01       	movw	r0, r22
    18a4:	b9 01       	movw	r22, r18
    18a6:	90 01       	movw	r18, r0
    18a8:	0c 01       	movw	r0, r24
    18aa:	ca 01       	movw	r24, r20
    18ac:	a0 01       	movw	r20, r0
    18ae:	11 24       	eor	r1, r1
    18b0:	ff 27       	eor	r31, r31
    18b2:	59 1b       	sub	r21, r25
    18b4:	99 f0       	breq	.+38     	; 0x18dc <__addsf3x+0x60>
    18b6:	59 3f       	cpi	r21, 0xF9	; 249
    18b8:	50 f4       	brcc	.+20     	; 0x18ce <__addsf3x+0x52>
    18ba:	50 3e       	cpi	r21, 0xE0	; 224
    18bc:	68 f1       	brcs	.+90     	; 0x1918 <__addsf3x+0x9c>
    18be:	1a 16       	cp	r1, r26
    18c0:	f0 40       	sbci	r31, 0x00	; 0
    18c2:	a2 2f       	mov	r26, r18
    18c4:	23 2f       	mov	r18, r19
    18c6:	34 2f       	mov	r19, r20
    18c8:	44 27       	eor	r20, r20
    18ca:	58 5f       	subi	r21, 0xF8	; 248
    18cc:	f3 cf       	rjmp	.-26     	; 0x18b4 <__addsf3x+0x38>
    18ce:	46 95       	lsr	r20
    18d0:	37 95       	ror	r19
    18d2:	27 95       	ror	r18
    18d4:	a7 95       	ror	r26
    18d6:	f0 40       	sbci	r31, 0x00	; 0
    18d8:	53 95       	inc	r21
    18da:	c9 f7       	brne	.-14     	; 0x18ce <__addsf3x+0x52>
    18dc:	7e f4       	brtc	.+30     	; 0x18fc <__addsf3x+0x80>
    18de:	1f 16       	cp	r1, r31
    18e0:	ba 0b       	sbc	r27, r26
    18e2:	62 0b       	sbc	r22, r18
    18e4:	73 0b       	sbc	r23, r19
    18e6:	84 0b       	sbc	r24, r20
    18e8:	ba f0       	brmi	.+46     	; 0x1918 <__addsf3x+0x9c>
    18ea:	91 50       	subi	r25, 0x01	; 1
    18ec:	a1 f0       	breq	.+40     	; 0x1916 <__addsf3x+0x9a>
    18ee:	ff 0f       	add	r31, r31
    18f0:	bb 1f       	adc	r27, r27
    18f2:	66 1f       	adc	r22, r22
    18f4:	77 1f       	adc	r23, r23
    18f6:	88 1f       	adc	r24, r24
    18f8:	c2 f7       	brpl	.-16     	; 0x18ea <__addsf3x+0x6e>
    18fa:	0e c0       	rjmp	.+28     	; 0x1918 <__addsf3x+0x9c>
    18fc:	ba 0f       	add	r27, r26
    18fe:	62 1f       	adc	r22, r18
    1900:	73 1f       	adc	r23, r19
    1902:	84 1f       	adc	r24, r20
    1904:	48 f4       	brcc	.+18     	; 0x1918 <__addsf3x+0x9c>
    1906:	87 95       	ror	r24
    1908:	77 95       	ror	r23
    190a:	67 95       	ror	r22
    190c:	b7 95       	ror	r27
    190e:	f7 95       	ror	r31
    1910:	9e 3f       	cpi	r25, 0xFE	; 254
    1912:	08 f0       	brcs	.+2      	; 0x1916 <__addsf3x+0x9a>
    1914:	b0 cf       	rjmp	.-160    	; 0x1876 <__addsf3+0x28>
    1916:	93 95       	inc	r25
    1918:	88 0f       	add	r24, r24
    191a:	08 f0       	brcs	.+2      	; 0x191e <__addsf3x+0xa2>
    191c:	99 27       	eor	r25, r25
    191e:	ee 0f       	add	r30, r30
    1920:	97 95       	ror	r25
    1922:	87 95       	ror	r24
    1924:	08 95       	ret

00001926 <__cmpsf2>:
    1926:	0e 94 7d 0d 	call	0x1afa	; 0x1afa <__fp_cmp>
    192a:	08 f4       	brcc	.+2      	; 0x192e <__cmpsf2+0x8>
    192c:	81 e0       	ldi	r24, 0x01	; 1
    192e:	08 95       	ret

00001930 <__divsf3>:
    1930:	0e 94 ac 0c 	call	0x1958	; 0x1958 <__divsf3x>
    1934:	0c 94 b8 0d 	jmp	0x1b70	; 0x1b70 <__fp_round>
    1938:	0e 94 b1 0d 	call	0x1b62	; 0x1b62 <__fp_pscB>
    193c:	58 f0       	brcs	.+22     	; 0x1954 <__divsf3+0x24>
    193e:	0e 94 aa 0d 	call	0x1b54	; 0x1b54 <__fp_pscA>
    1942:	40 f0       	brcs	.+16     	; 0x1954 <__divsf3+0x24>
    1944:	29 f4       	brne	.+10     	; 0x1950 <__divsf3+0x20>
    1946:	5f 3f       	cpi	r21, 0xFF	; 255
    1948:	29 f0       	breq	.+10     	; 0x1954 <__divsf3+0x24>
    194a:	0c 94 a1 0d 	jmp	0x1b42	; 0x1b42 <__fp_inf>
    194e:	51 11       	cpse	r21, r1
    1950:	0c 94 ec 0d 	jmp	0x1bd8	; 0x1bd8 <__fp_szero>
    1954:	0c 94 a7 0d 	jmp	0x1b4e	; 0x1b4e <__fp_nan>

00001958 <__divsf3x>:
    1958:	0e 94 c9 0d 	call	0x1b92	; 0x1b92 <__fp_split3>
    195c:	68 f3       	brcs	.-38     	; 0x1938 <__divsf3+0x8>

0000195e <__divsf3_pse>:
    195e:	99 23       	and	r25, r25
    1960:	b1 f3       	breq	.-20     	; 0x194e <__divsf3+0x1e>
    1962:	55 23       	and	r21, r21
    1964:	91 f3       	breq	.-28     	; 0x194a <__divsf3+0x1a>
    1966:	95 1b       	sub	r25, r21
    1968:	55 0b       	sbc	r21, r21
    196a:	bb 27       	eor	r27, r27
    196c:	aa 27       	eor	r26, r26
    196e:	62 17       	cp	r22, r18
    1970:	73 07       	cpc	r23, r19
    1972:	84 07       	cpc	r24, r20
    1974:	38 f0       	brcs	.+14     	; 0x1984 <__divsf3_pse+0x26>
    1976:	9f 5f       	subi	r25, 0xFF	; 255
    1978:	5f 4f       	sbci	r21, 0xFF	; 255
    197a:	22 0f       	add	r18, r18
    197c:	33 1f       	adc	r19, r19
    197e:	44 1f       	adc	r20, r20
    1980:	aa 1f       	adc	r26, r26
    1982:	a9 f3       	breq	.-22     	; 0x196e <__divsf3_pse+0x10>
    1984:	35 d0       	rcall	.+106    	; 0x19f0 <__divsf3_pse+0x92>
    1986:	0e 2e       	mov	r0, r30
    1988:	3a f0       	brmi	.+14     	; 0x1998 <__divsf3_pse+0x3a>
    198a:	e0 e8       	ldi	r30, 0x80	; 128
    198c:	32 d0       	rcall	.+100    	; 0x19f2 <__divsf3_pse+0x94>
    198e:	91 50       	subi	r25, 0x01	; 1
    1990:	50 40       	sbci	r21, 0x00	; 0
    1992:	e6 95       	lsr	r30
    1994:	00 1c       	adc	r0, r0
    1996:	ca f7       	brpl	.-14     	; 0x198a <__divsf3_pse+0x2c>
    1998:	2b d0       	rcall	.+86     	; 0x19f0 <__divsf3_pse+0x92>
    199a:	fe 2f       	mov	r31, r30
    199c:	29 d0       	rcall	.+82     	; 0x19f0 <__divsf3_pse+0x92>
    199e:	66 0f       	add	r22, r22
    19a0:	77 1f       	adc	r23, r23
    19a2:	88 1f       	adc	r24, r24
    19a4:	bb 1f       	adc	r27, r27
    19a6:	26 17       	cp	r18, r22
    19a8:	37 07       	cpc	r19, r23
    19aa:	48 07       	cpc	r20, r24
    19ac:	ab 07       	cpc	r26, r27
    19ae:	b0 e8       	ldi	r27, 0x80	; 128
    19b0:	09 f0       	breq	.+2      	; 0x19b4 <__divsf3_pse+0x56>
    19b2:	bb 0b       	sbc	r27, r27
    19b4:	80 2d       	mov	r24, r0
    19b6:	bf 01       	movw	r22, r30
    19b8:	ff 27       	eor	r31, r31
    19ba:	93 58       	subi	r25, 0x83	; 131
    19bc:	5f 4f       	sbci	r21, 0xFF	; 255
    19be:	3a f0       	brmi	.+14     	; 0x19ce <__divsf3_pse+0x70>
    19c0:	9e 3f       	cpi	r25, 0xFE	; 254
    19c2:	51 05       	cpc	r21, r1
    19c4:	78 f0       	brcs	.+30     	; 0x19e4 <__divsf3_pse+0x86>
    19c6:	0c 94 a1 0d 	jmp	0x1b42	; 0x1b42 <__fp_inf>
    19ca:	0c 94 ec 0d 	jmp	0x1bd8	; 0x1bd8 <__fp_szero>
    19ce:	5f 3f       	cpi	r21, 0xFF	; 255
    19d0:	e4 f3       	brlt	.-8      	; 0x19ca <__divsf3_pse+0x6c>
    19d2:	98 3e       	cpi	r25, 0xE8	; 232
    19d4:	d4 f3       	brlt	.-12     	; 0x19ca <__divsf3_pse+0x6c>
    19d6:	86 95       	lsr	r24
    19d8:	77 95       	ror	r23
    19da:	67 95       	ror	r22
    19dc:	b7 95       	ror	r27
    19de:	f7 95       	ror	r31
    19e0:	9f 5f       	subi	r25, 0xFF	; 255
    19e2:	c9 f7       	brne	.-14     	; 0x19d6 <__divsf3_pse+0x78>
    19e4:	88 0f       	add	r24, r24
    19e6:	91 1d       	adc	r25, r1
    19e8:	96 95       	lsr	r25
    19ea:	87 95       	ror	r24
    19ec:	97 f9       	bld	r25, 7
    19ee:	08 95       	ret
    19f0:	e1 e0       	ldi	r30, 0x01	; 1
    19f2:	66 0f       	add	r22, r22
    19f4:	77 1f       	adc	r23, r23
    19f6:	88 1f       	adc	r24, r24
    19f8:	bb 1f       	adc	r27, r27
    19fa:	62 17       	cp	r22, r18
    19fc:	73 07       	cpc	r23, r19
    19fe:	84 07       	cpc	r24, r20
    1a00:	ba 07       	cpc	r27, r26
    1a02:	20 f0       	brcs	.+8      	; 0x1a0c <__divsf3_pse+0xae>
    1a04:	62 1b       	sub	r22, r18
    1a06:	73 0b       	sbc	r23, r19
    1a08:	84 0b       	sbc	r24, r20
    1a0a:	ba 0b       	sbc	r27, r26
    1a0c:	ee 1f       	adc	r30, r30
    1a0e:	88 f7       	brcc	.-30     	; 0x19f2 <__divsf3_pse+0x94>
    1a10:	e0 95       	com	r30
    1a12:	08 95       	ret

00001a14 <__fixsfsi>:
    1a14:	0e 94 11 0d 	call	0x1a22	; 0x1a22 <__fixunssfsi>
    1a18:	68 94       	set
    1a1a:	b1 11       	cpse	r27, r1
    1a1c:	0c 94 ec 0d 	jmp	0x1bd8	; 0x1bd8 <__fp_szero>
    1a20:	08 95       	ret

00001a22 <__fixunssfsi>:
    1a22:	0e 94 d1 0d 	call	0x1ba2	; 0x1ba2 <__fp_splitA>
    1a26:	88 f0       	brcs	.+34     	; 0x1a4a <__fixunssfsi+0x28>
    1a28:	9f 57       	subi	r25, 0x7F	; 127
    1a2a:	98 f0       	brcs	.+38     	; 0x1a52 <__fixunssfsi+0x30>
    1a2c:	b9 2f       	mov	r27, r25
    1a2e:	99 27       	eor	r25, r25
    1a30:	b7 51       	subi	r27, 0x17	; 23
    1a32:	b0 f0       	brcs	.+44     	; 0x1a60 <__fixunssfsi+0x3e>
    1a34:	e1 f0       	breq	.+56     	; 0x1a6e <__fixunssfsi+0x4c>
    1a36:	66 0f       	add	r22, r22
    1a38:	77 1f       	adc	r23, r23
    1a3a:	88 1f       	adc	r24, r24
    1a3c:	99 1f       	adc	r25, r25
    1a3e:	1a f0       	brmi	.+6      	; 0x1a46 <__fixunssfsi+0x24>
    1a40:	ba 95       	dec	r27
    1a42:	c9 f7       	brne	.-14     	; 0x1a36 <__fixunssfsi+0x14>
    1a44:	14 c0       	rjmp	.+40     	; 0x1a6e <__fixunssfsi+0x4c>
    1a46:	b1 30       	cpi	r27, 0x01	; 1
    1a48:	91 f0       	breq	.+36     	; 0x1a6e <__fixunssfsi+0x4c>
    1a4a:	0e 94 eb 0d 	call	0x1bd6	; 0x1bd6 <__fp_zero>
    1a4e:	b1 e0       	ldi	r27, 0x01	; 1
    1a50:	08 95       	ret
    1a52:	0c 94 eb 0d 	jmp	0x1bd6	; 0x1bd6 <__fp_zero>
    1a56:	67 2f       	mov	r22, r23
    1a58:	78 2f       	mov	r23, r24
    1a5a:	88 27       	eor	r24, r24
    1a5c:	b8 5f       	subi	r27, 0xF8	; 248
    1a5e:	39 f0       	breq	.+14     	; 0x1a6e <__fixunssfsi+0x4c>
    1a60:	b9 3f       	cpi	r27, 0xF9	; 249
    1a62:	cc f3       	brlt	.-14     	; 0x1a56 <__fixunssfsi+0x34>
    1a64:	86 95       	lsr	r24
    1a66:	77 95       	ror	r23
    1a68:	67 95       	ror	r22
    1a6a:	b3 95       	inc	r27
    1a6c:	d9 f7       	brne	.-10     	; 0x1a64 <__fixunssfsi+0x42>
    1a6e:	3e f4       	brtc	.+14     	; 0x1a7e <__fixunssfsi+0x5c>
    1a70:	90 95       	com	r25
    1a72:	80 95       	com	r24
    1a74:	70 95       	com	r23
    1a76:	61 95       	neg	r22
    1a78:	7f 4f       	sbci	r23, 0xFF	; 255
    1a7a:	8f 4f       	sbci	r24, 0xFF	; 255
    1a7c:	9f 4f       	sbci	r25, 0xFF	; 255
    1a7e:	08 95       	ret

00001a80 <__floatunsisf>:
    1a80:	e8 94       	clt
    1a82:	09 c0       	rjmp	.+18     	; 0x1a96 <__floatsisf+0x12>

00001a84 <__floatsisf>:
    1a84:	97 fb       	bst	r25, 7
    1a86:	3e f4       	brtc	.+14     	; 0x1a96 <__floatsisf+0x12>
    1a88:	90 95       	com	r25
    1a8a:	80 95       	com	r24
    1a8c:	70 95       	com	r23
    1a8e:	61 95       	neg	r22
    1a90:	7f 4f       	sbci	r23, 0xFF	; 255
    1a92:	8f 4f       	sbci	r24, 0xFF	; 255
    1a94:	9f 4f       	sbci	r25, 0xFF	; 255
    1a96:	99 23       	and	r25, r25
    1a98:	a9 f0       	breq	.+42     	; 0x1ac4 <__floatsisf+0x40>
    1a9a:	f9 2f       	mov	r31, r25
    1a9c:	96 e9       	ldi	r25, 0x96	; 150
    1a9e:	bb 27       	eor	r27, r27
    1aa0:	93 95       	inc	r25
    1aa2:	f6 95       	lsr	r31
    1aa4:	87 95       	ror	r24
    1aa6:	77 95       	ror	r23
    1aa8:	67 95       	ror	r22
    1aaa:	b7 95       	ror	r27
    1aac:	f1 11       	cpse	r31, r1
    1aae:	f8 cf       	rjmp	.-16     	; 0x1aa0 <__floatsisf+0x1c>
    1ab0:	fa f4       	brpl	.+62     	; 0x1af0 <__floatsisf+0x6c>
    1ab2:	bb 0f       	add	r27, r27
    1ab4:	11 f4       	brne	.+4      	; 0x1aba <__floatsisf+0x36>
    1ab6:	60 ff       	sbrs	r22, 0
    1ab8:	1b c0       	rjmp	.+54     	; 0x1af0 <__floatsisf+0x6c>
    1aba:	6f 5f       	subi	r22, 0xFF	; 255
    1abc:	7f 4f       	sbci	r23, 0xFF	; 255
    1abe:	8f 4f       	sbci	r24, 0xFF	; 255
    1ac0:	9f 4f       	sbci	r25, 0xFF	; 255
    1ac2:	16 c0       	rjmp	.+44     	; 0x1af0 <__floatsisf+0x6c>
    1ac4:	88 23       	and	r24, r24
    1ac6:	11 f0       	breq	.+4      	; 0x1acc <__floatsisf+0x48>
    1ac8:	96 e9       	ldi	r25, 0x96	; 150
    1aca:	11 c0       	rjmp	.+34     	; 0x1aee <__floatsisf+0x6a>
    1acc:	77 23       	and	r23, r23
    1ace:	21 f0       	breq	.+8      	; 0x1ad8 <__floatsisf+0x54>
    1ad0:	9e e8       	ldi	r25, 0x8E	; 142
    1ad2:	87 2f       	mov	r24, r23
    1ad4:	76 2f       	mov	r23, r22
    1ad6:	05 c0       	rjmp	.+10     	; 0x1ae2 <__floatsisf+0x5e>
    1ad8:	66 23       	and	r22, r22
    1ada:	71 f0       	breq	.+28     	; 0x1af8 <__floatsisf+0x74>
    1adc:	96 e8       	ldi	r25, 0x86	; 134
    1ade:	86 2f       	mov	r24, r22
    1ae0:	70 e0       	ldi	r23, 0x00	; 0
    1ae2:	60 e0       	ldi	r22, 0x00	; 0
    1ae4:	2a f0       	brmi	.+10     	; 0x1af0 <__floatsisf+0x6c>
    1ae6:	9a 95       	dec	r25
    1ae8:	66 0f       	add	r22, r22
    1aea:	77 1f       	adc	r23, r23
    1aec:	88 1f       	adc	r24, r24
    1aee:	da f7       	brpl	.-10     	; 0x1ae6 <__floatsisf+0x62>
    1af0:	88 0f       	add	r24, r24
    1af2:	96 95       	lsr	r25
    1af4:	87 95       	ror	r24
    1af6:	97 f9       	bld	r25, 7
    1af8:	08 95       	ret

00001afa <__fp_cmp>:
    1afa:	99 0f       	add	r25, r25
    1afc:	00 08       	sbc	r0, r0
    1afe:	55 0f       	add	r21, r21
    1b00:	aa 0b       	sbc	r26, r26
    1b02:	e0 e8       	ldi	r30, 0x80	; 128
    1b04:	fe ef       	ldi	r31, 0xFE	; 254
    1b06:	16 16       	cp	r1, r22
    1b08:	17 06       	cpc	r1, r23
    1b0a:	e8 07       	cpc	r30, r24
    1b0c:	f9 07       	cpc	r31, r25
    1b0e:	c0 f0       	brcs	.+48     	; 0x1b40 <__fp_cmp+0x46>
    1b10:	12 16       	cp	r1, r18
    1b12:	13 06       	cpc	r1, r19
    1b14:	e4 07       	cpc	r30, r20
    1b16:	f5 07       	cpc	r31, r21
    1b18:	98 f0       	brcs	.+38     	; 0x1b40 <__fp_cmp+0x46>
    1b1a:	62 1b       	sub	r22, r18
    1b1c:	73 0b       	sbc	r23, r19
    1b1e:	84 0b       	sbc	r24, r20
    1b20:	95 0b       	sbc	r25, r21
    1b22:	39 f4       	brne	.+14     	; 0x1b32 <__fp_cmp+0x38>
    1b24:	0a 26       	eor	r0, r26
    1b26:	61 f0       	breq	.+24     	; 0x1b40 <__fp_cmp+0x46>
    1b28:	23 2b       	or	r18, r19
    1b2a:	24 2b       	or	r18, r20
    1b2c:	25 2b       	or	r18, r21
    1b2e:	21 f4       	brne	.+8      	; 0x1b38 <__fp_cmp+0x3e>
    1b30:	08 95       	ret
    1b32:	0a 26       	eor	r0, r26
    1b34:	09 f4       	brne	.+2      	; 0x1b38 <__fp_cmp+0x3e>
    1b36:	a1 40       	sbci	r26, 0x01	; 1
    1b38:	a6 95       	lsr	r26
    1b3a:	8f ef       	ldi	r24, 0xFF	; 255
    1b3c:	81 1d       	adc	r24, r1
    1b3e:	81 1d       	adc	r24, r1
    1b40:	08 95       	ret

00001b42 <__fp_inf>:
    1b42:	97 f9       	bld	r25, 7
    1b44:	9f 67       	ori	r25, 0x7F	; 127
    1b46:	80 e8       	ldi	r24, 0x80	; 128
    1b48:	70 e0       	ldi	r23, 0x00	; 0
    1b4a:	60 e0       	ldi	r22, 0x00	; 0
    1b4c:	08 95       	ret

00001b4e <__fp_nan>:
    1b4e:	9f ef       	ldi	r25, 0xFF	; 255
    1b50:	80 ec       	ldi	r24, 0xC0	; 192
    1b52:	08 95       	ret

00001b54 <__fp_pscA>:
    1b54:	00 24       	eor	r0, r0
    1b56:	0a 94       	dec	r0
    1b58:	16 16       	cp	r1, r22
    1b5a:	17 06       	cpc	r1, r23
    1b5c:	18 06       	cpc	r1, r24
    1b5e:	09 06       	cpc	r0, r25
    1b60:	08 95       	ret

00001b62 <__fp_pscB>:
    1b62:	00 24       	eor	r0, r0
    1b64:	0a 94       	dec	r0
    1b66:	12 16       	cp	r1, r18
    1b68:	13 06       	cpc	r1, r19
    1b6a:	14 06       	cpc	r1, r20
    1b6c:	05 06       	cpc	r0, r21
    1b6e:	08 95       	ret

00001b70 <__fp_round>:
    1b70:	09 2e       	mov	r0, r25
    1b72:	03 94       	inc	r0
    1b74:	00 0c       	add	r0, r0
    1b76:	11 f4       	brne	.+4      	; 0x1b7c <__fp_round+0xc>
    1b78:	88 23       	and	r24, r24
    1b7a:	52 f0       	brmi	.+20     	; 0x1b90 <__fp_round+0x20>
    1b7c:	bb 0f       	add	r27, r27
    1b7e:	40 f4       	brcc	.+16     	; 0x1b90 <__fp_round+0x20>
    1b80:	bf 2b       	or	r27, r31
    1b82:	11 f4       	brne	.+4      	; 0x1b88 <__fp_round+0x18>
    1b84:	60 ff       	sbrs	r22, 0
    1b86:	04 c0       	rjmp	.+8      	; 0x1b90 <__fp_round+0x20>
    1b88:	6f 5f       	subi	r22, 0xFF	; 255
    1b8a:	7f 4f       	sbci	r23, 0xFF	; 255
    1b8c:	8f 4f       	sbci	r24, 0xFF	; 255
    1b8e:	9f 4f       	sbci	r25, 0xFF	; 255
    1b90:	08 95       	ret

00001b92 <__fp_split3>:
    1b92:	57 fd       	sbrc	r21, 7
    1b94:	90 58       	subi	r25, 0x80	; 128
    1b96:	44 0f       	add	r20, r20
    1b98:	55 1f       	adc	r21, r21
    1b9a:	59 f0       	breq	.+22     	; 0x1bb2 <__fp_splitA+0x10>
    1b9c:	5f 3f       	cpi	r21, 0xFF	; 255
    1b9e:	71 f0       	breq	.+28     	; 0x1bbc <__fp_splitA+0x1a>
    1ba0:	47 95       	ror	r20

00001ba2 <__fp_splitA>:
    1ba2:	88 0f       	add	r24, r24
    1ba4:	97 fb       	bst	r25, 7
    1ba6:	99 1f       	adc	r25, r25
    1ba8:	61 f0       	breq	.+24     	; 0x1bc2 <__fp_splitA+0x20>
    1baa:	9f 3f       	cpi	r25, 0xFF	; 255
    1bac:	79 f0       	breq	.+30     	; 0x1bcc <__fp_splitA+0x2a>
    1bae:	87 95       	ror	r24
    1bb0:	08 95       	ret
    1bb2:	12 16       	cp	r1, r18
    1bb4:	13 06       	cpc	r1, r19
    1bb6:	14 06       	cpc	r1, r20
    1bb8:	55 1f       	adc	r21, r21
    1bba:	f2 cf       	rjmp	.-28     	; 0x1ba0 <__fp_split3+0xe>
    1bbc:	46 95       	lsr	r20
    1bbe:	f1 df       	rcall	.-30     	; 0x1ba2 <__fp_splitA>
    1bc0:	08 c0       	rjmp	.+16     	; 0x1bd2 <__fp_splitA+0x30>
    1bc2:	16 16       	cp	r1, r22
    1bc4:	17 06       	cpc	r1, r23
    1bc6:	18 06       	cpc	r1, r24
    1bc8:	99 1f       	adc	r25, r25
    1bca:	f1 cf       	rjmp	.-30     	; 0x1bae <__fp_splitA+0xc>
    1bcc:	86 95       	lsr	r24
    1bce:	71 05       	cpc	r23, r1
    1bd0:	61 05       	cpc	r22, r1
    1bd2:	08 94       	sec
    1bd4:	08 95       	ret

00001bd6 <__fp_zero>:
    1bd6:	e8 94       	clt

00001bd8 <__fp_szero>:
    1bd8:	bb 27       	eor	r27, r27
    1bda:	66 27       	eor	r22, r22
    1bdc:	77 27       	eor	r23, r23
    1bde:	cb 01       	movw	r24, r22
    1be0:	97 f9       	bld	r25, 7
    1be2:	08 95       	ret

00001be4 <__gesf2>:
    1be4:	0e 94 7d 0d 	call	0x1afa	; 0x1afa <__fp_cmp>
    1be8:	08 f4       	brcc	.+2      	; 0x1bec <__gesf2+0x8>
    1bea:	8f ef       	ldi	r24, 0xFF	; 255
    1bec:	08 95       	ret

00001bee <__mulsf3>:
    1bee:	0e 94 0a 0e 	call	0x1c14	; 0x1c14 <__mulsf3x>
    1bf2:	0c 94 b8 0d 	jmp	0x1b70	; 0x1b70 <__fp_round>
    1bf6:	0e 94 aa 0d 	call	0x1b54	; 0x1b54 <__fp_pscA>
    1bfa:	38 f0       	brcs	.+14     	; 0x1c0a <__mulsf3+0x1c>
    1bfc:	0e 94 b1 0d 	call	0x1b62	; 0x1b62 <__fp_pscB>
    1c00:	20 f0       	brcs	.+8      	; 0x1c0a <__mulsf3+0x1c>
    1c02:	95 23       	and	r25, r21
    1c04:	11 f0       	breq	.+4      	; 0x1c0a <__mulsf3+0x1c>
    1c06:	0c 94 a1 0d 	jmp	0x1b42	; 0x1b42 <__fp_inf>
    1c0a:	0c 94 a7 0d 	jmp	0x1b4e	; 0x1b4e <__fp_nan>
    1c0e:	11 24       	eor	r1, r1
    1c10:	0c 94 ec 0d 	jmp	0x1bd8	; 0x1bd8 <__fp_szero>

00001c14 <__mulsf3x>:
    1c14:	0e 94 c9 0d 	call	0x1b92	; 0x1b92 <__fp_split3>
    1c18:	70 f3       	brcs	.-36     	; 0x1bf6 <__mulsf3+0x8>

00001c1a <__mulsf3_pse>:
    1c1a:	95 9f       	mul	r25, r21
    1c1c:	c1 f3       	breq	.-16     	; 0x1c0e <__mulsf3+0x20>
    1c1e:	95 0f       	add	r25, r21
    1c20:	50 e0       	ldi	r21, 0x00	; 0
    1c22:	55 1f       	adc	r21, r21
    1c24:	62 9f       	mul	r22, r18
    1c26:	f0 01       	movw	r30, r0
    1c28:	72 9f       	mul	r23, r18
    1c2a:	bb 27       	eor	r27, r27
    1c2c:	f0 0d       	add	r31, r0
    1c2e:	b1 1d       	adc	r27, r1
    1c30:	63 9f       	mul	r22, r19
    1c32:	aa 27       	eor	r26, r26
    1c34:	f0 0d       	add	r31, r0
    1c36:	b1 1d       	adc	r27, r1
    1c38:	aa 1f       	adc	r26, r26
    1c3a:	64 9f       	mul	r22, r20
    1c3c:	66 27       	eor	r22, r22
    1c3e:	b0 0d       	add	r27, r0
    1c40:	a1 1d       	adc	r26, r1
    1c42:	66 1f       	adc	r22, r22
    1c44:	82 9f       	mul	r24, r18
    1c46:	22 27       	eor	r18, r18
    1c48:	b0 0d       	add	r27, r0
    1c4a:	a1 1d       	adc	r26, r1
    1c4c:	62 1f       	adc	r22, r18
    1c4e:	73 9f       	mul	r23, r19
    1c50:	b0 0d       	add	r27, r0
    1c52:	a1 1d       	adc	r26, r1
    1c54:	62 1f       	adc	r22, r18
    1c56:	83 9f       	mul	r24, r19
    1c58:	a0 0d       	add	r26, r0
    1c5a:	61 1d       	adc	r22, r1
    1c5c:	22 1f       	adc	r18, r18
    1c5e:	74 9f       	mul	r23, r20
    1c60:	33 27       	eor	r19, r19
    1c62:	a0 0d       	add	r26, r0
    1c64:	61 1d       	adc	r22, r1
    1c66:	23 1f       	adc	r18, r19
    1c68:	84 9f       	mul	r24, r20
    1c6a:	60 0d       	add	r22, r0
    1c6c:	21 1d       	adc	r18, r1
    1c6e:	82 2f       	mov	r24, r18
    1c70:	76 2f       	mov	r23, r22
    1c72:	6a 2f       	mov	r22, r26
    1c74:	11 24       	eor	r1, r1
    1c76:	9f 57       	subi	r25, 0x7F	; 127
    1c78:	50 40       	sbci	r21, 0x00	; 0
    1c7a:	9a f0       	brmi	.+38     	; 0x1ca2 <__mulsf3_pse+0x88>
    1c7c:	f1 f0       	breq	.+60     	; 0x1cba <__mulsf3_pse+0xa0>
    1c7e:	88 23       	and	r24, r24
    1c80:	4a f0       	brmi	.+18     	; 0x1c94 <__mulsf3_pse+0x7a>
    1c82:	ee 0f       	add	r30, r30
    1c84:	ff 1f       	adc	r31, r31
    1c86:	bb 1f       	adc	r27, r27
    1c88:	66 1f       	adc	r22, r22
    1c8a:	77 1f       	adc	r23, r23
    1c8c:	88 1f       	adc	r24, r24
    1c8e:	91 50       	subi	r25, 0x01	; 1
    1c90:	50 40       	sbci	r21, 0x00	; 0
    1c92:	a9 f7       	brne	.-22     	; 0x1c7e <__mulsf3_pse+0x64>
    1c94:	9e 3f       	cpi	r25, 0xFE	; 254
    1c96:	51 05       	cpc	r21, r1
    1c98:	80 f0       	brcs	.+32     	; 0x1cba <__mulsf3_pse+0xa0>
    1c9a:	0c 94 a1 0d 	jmp	0x1b42	; 0x1b42 <__fp_inf>
    1c9e:	0c 94 ec 0d 	jmp	0x1bd8	; 0x1bd8 <__fp_szero>
    1ca2:	5f 3f       	cpi	r21, 0xFF	; 255
    1ca4:	e4 f3       	brlt	.-8      	; 0x1c9e <__mulsf3_pse+0x84>
    1ca6:	98 3e       	cpi	r25, 0xE8	; 232
    1ca8:	d4 f3       	brlt	.-12     	; 0x1c9e <__mulsf3_pse+0x84>
    1caa:	86 95       	lsr	r24
    1cac:	77 95       	ror	r23
    1cae:	67 95       	ror	r22
    1cb0:	b7 95       	ror	r27
    1cb2:	f7 95       	ror	r31
    1cb4:	e7 95       	ror	r30
    1cb6:	9f 5f       	subi	r25, 0xFF	; 255
    1cb8:	c1 f7       	brne	.-16     	; 0x1caa <__mulsf3_pse+0x90>
    1cba:	fe 2b       	or	r31, r30
    1cbc:	88 0f       	add	r24, r24
    1cbe:	91 1d       	adc	r25, r1
    1cc0:	96 95       	lsr	r25
    1cc2:	87 95       	ror	r24
    1cc4:	97 f9       	bld	r25, 7
    1cc6:	08 95       	ret

00001cc8 <_ZN14HardwareSerial9availableEv>:
  // clear any received data
  _rx_buffer_head = _rx_buffer_tail;
}

int HardwareSerial::available(void)
{
    1cc8:	fc 01       	movw	r30, r24
  return ((unsigned int)(SERIAL_RX_BUFFER_SIZE + _rx_buffer_head - _rx_buffer_tail)) % SERIAL_RX_BUFFER_SIZE;
    1cca:	91 8d       	ldd	r25, Z+25	; 0x19
    1ccc:	22 8d       	ldd	r18, Z+26	; 0x1a
    1cce:	89 2f       	mov	r24, r25
    1cd0:	90 e0       	ldi	r25, 0x00	; 0
    1cd2:	80 5c       	subi	r24, 0xC0	; 192
    1cd4:	9f 4f       	sbci	r25, 0xFF	; 255
    1cd6:	82 1b       	sub	r24, r18
    1cd8:	91 09       	sbc	r25, r1
}
    1cda:	8f 73       	andi	r24, 0x3F	; 63
    1cdc:	99 27       	eor	r25, r25
    1cde:	08 95       	ret

00001ce0 <_ZN14HardwareSerial4peekEv>:

int HardwareSerial::peek(void)
{
    1ce0:	fc 01       	movw	r30, r24
  if (_rx_buffer_head == _rx_buffer_tail) {
    1ce2:	91 8d       	ldd	r25, Z+25	; 0x19
    1ce4:	82 8d       	ldd	r24, Z+26	; 0x1a
    1ce6:	98 17       	cp	r25, r24
    1ce8:	31 f0       	breq	.+12     	; 0x1cf6 <_ZN14HardwareSerial4peekEv+0x16>
    return -1;
  } else {
    return _rx_buffer[_rx_buffer_tail];
    1cea:	82 8d       	ldd	r24, Z+26	; 0x1a
    1cec:	e8 0f       	add	r30, r24
    1cee:	f1 1d       	adc	r31, r1
    1cf0:	85 8d       	ldd	r24, Z+29	; 0x1d
    1cf2:	90 e0       	ldi	r25, 0x00	; 0
    1cf4:	08 95       	ret
}

int HardwareSerial::peek(void)
{
  if (_rx_buffer_head == _rx_buffer_tail) {
    return -1;
    1cf6:	8f ef       	ldi	r24, 0xFF	; 255
    1cf8:	9f ef       	ldi	r25, 0xFF	; 255
  } else {
    return _rx_buffer[_rx_buffer_tail];
  }
}
    1cfa:	08 95       	ret

00001cfc <_ZN14HardwareSerial4readEv>:

int HardwareSerial::read(void)
{
    1cfc:	fc 01       	movw	r30, r24
  // if the head isn't ahead of the tail, we don't have any characters
  if (_rx_buffer_head == _rx_buffer_tail) {
    1cfe:	91 8d       	ldd	r25, Z+25	; 0x19
    1d00:	82 8d       	ldd	r24, Z+26	; 0x1a
    1d02:	98 17       	cp	r25, r24
    1d04:	61 f0       	breq	.+24     	; 0x1d1e <_ZN14HardwareSerial4readEv+0x22>
    return -1;
  } else {
    unsigned char c = _rx_buffer[_rx_buffer_tail];
    1d06:	82 8d       	ldd	r24, Z+26	; 0x1a
    1d08:	df 01       	movw	r26, r30
    1d0a:	a8 0f       	add	r26, r24
    1d0c:	b1 1d       	adc	r27, r1
    1d0e:	5d 96       	adiw	r26, 0x1d	; 29
    1d10:	8c 91       	ld	r24, X
    _rx_buffer_tail = (rx_buffer_index_t)(_rx_buffer_tail + 1) % SERIAL_RX_BUFFER_SIZE;
    1d12:	92 8d       	ldd	r25, Z+26	; 0x1a
    1d14:	9f 5f       	subi	r25, 0xFF	; 255
    1d16:	9f 73       	andi	r25, 0x3F	; 63
    1d18:	92 8f       	std	Z+26, r25	; 0x1a
    return c;
    1d1a:	90 e0       	ldi	r25, 0x00	; 0
    1d1c:	08 95       	ret

int HardwareSerial::read(void)
{
  // if the head isn't ahead of the tail, we don't have any characters
  if (_rx_buffer_head == _rx_buffer_tail) {
    return -1;
    1d1e:	8f ef       	ldi	r24, 0xFF	; 255
    1d20:	9f ef       	ldi	r25, 0xFF	; 255
  } else {
    unsigned char c = _rx_buffer[_rx_buffer_tail];
    _rx_buffer_tail = (rx_buffer_index_t)(_rx_buffer_tail + 1) % SERIAL_RX_BUFFER_SIZE;
    return c;
  }
}
    1d22:	08 95       	ret

00001d24 <_ZN14HardwareSerial17availableForWriteEv>:
{
  tx_buffer_index_t head;
  tx_buffer_index_t tail;

  TX_BUFFER_ATOMIC {
    head = _tx_buffer_head;
    1d24:	fc 01       	movw	r30, r24
    1d26:	53 8d       	ldd	r21, Z+27	; 0x1b
    tail = _tx_buffer_tail;
    1d28:	44 8d       	ldd	r20, Z+28	; 0x1c
    1d2a:	25 2f       	mov	r18, r21
    1d2c:	30 e0       	ldi	r19, 0x00	; 0
    1d2e:	84 2f       	mov	r24, r20
    1d30:	90 e0       	ldi	r25, 0x00	; 0
  }
  if (head >= tail) return SERIAL_TX_BUFFER_SIZE - 1 - head + tail;
    1d32:	82 1b       	sub	r24, r18
    1d34:	93 0b       	sbc	r25, r19
    1d36:	54 17       	cp	r21, r20
    1d38:	10 f0       	brcs	.+4      	; 0x1d3e <_ZN14HardwareSerial17availableForWriteEv+0x1a>
    1d3a:	cf 96       	adiw	r24, 0x3f	; 63
    1d3c:	08 95       	ret
  return tail - head - 1;
    1d3e:	01 97       	sbiw	r24, 0x01	; 1
}
    1d40:	08 95       	ret

00001d42 <_Z14serialEventRunv>:
#endif

void serialEventRun(void)
{
#if defined(HAVE_HWSERIAL0)
  if (Serial0_available && serialEvent && Serial0_available()) serialEvent();
    1d42:	8d ef       	ldi	r24, 0xFD	; 253
    1d44:	9f e0       	ldi	r25, 0x0F	; 15
    1d46:	89 2b       	or	r24, r25
    1d48:	49 f0       	breq	.+18     	; 0x1d5c <_Z14serialEventRunv+0x1a>
    1d4a:	80 e0       	ldi	r24, 0x00	; 0
    1d4c:	90 e0       	ldi	r25, 0x00	; 0
    1d4e:	89 2b       	or	r24, r25
    1d50:	29 f0       	breq	.+10     	; 0x1d5c <_Z14serialEventRunv+0x1a>
    1d52:	0e 94 fd 0f 	call	0x1ffa	; 0x1ffa <_Z17Serial0_availablev>
    1d56:	81 11       	cpse	r24, r1
    1d58:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>
    1d5c:	08 95       	ret

00001d5e <_ZN14HardwareSerial17_tx_udr_empty_irqEv>:
#endif

// Actual interrupt handlers //////////////////////////////////////////////////////////////

void HardwareSerial::_tx_udr_empty_irq(void)
{
    1d5e:	fc 01       	movw	r30, r24
  // If interrupts are enabled, there must be more data in the output
  // buffer. Send the next byte
  unsigned char c = _tx_buffer[_tx_buffer_tail];
    1d60:	84 8d       	ldd	r24, Z+28	; 0x1c
    1d62:	df 01       	movw	r26, r30
    1d64:	a8 0f       	add	r26, r24
    1d66:	b1 1d       	adc	r27, r1
    1d68:	a3 5a       	subi	r26, 0xA3	; 163
    1d6a:	bf 4f       	sbci	r27, 0xFF	; 255
    1d6c:	2c 91       	ld	r18, X
  _tx_buffer_tail = (_tx_buffer_tail + 1) % SERIAL_TX_BUFFER_SIZE;
    1d6e:	84 8d       	ldd	r24, Z+28	; 0x1c
    1d70:	90 e0       	ldi	r25, 0x00	; 0
    1d72:	01 96       	adiw	r24, 0x01	; 1
    1d74:	8f 73       	andi	r24, 0x3F	; 63
    1d76:	99 27       	eor	r25, r25
    1d78:	84 8f       	std	Z+28, r24	; 0x1c

  *_udr = c;
    1d7a:	a6 89       	ldd	r26, Z+22	; 0x16
    1d7c:	b7 89       	ldd	r27, Z+23	; 0x17
    1d7e:	2c 93       	st	X, r18
  // location". This makes sure flush() won't return until the bytes
  // actually got written. Other r/w bits are preserved, and zeroes
  // written to the rest.

#ifdef MPCM0
  *_ucsra = ((*_ucsra) & ((1 << U2X0) | (1 << MPCM0))) | (1 << TXC0);
    1d80:	a0 89       	ldd	r26, Z+16	; 0x10
    1d82:	b1 89       	ldd	r27, Z+17	; 0x11
    1d84:	8c 91       	ld	r24, X
    1d86:	83 70       	andi	r24, 0x03	; 3
    1d88:	80 64       	ori	r24, 0x40	; 64
    1d8a:	8c 93       	st	X, r24
#else
  *_ucsra = ((*_ucsra) & ((1 << U2X0) | (1 << TXC0)));
#endif

  if (_tx_buffer_head == _tx_buffer_tail) {
    1d8c:	93 8d       	ldd	r25, Z+27	; 0x1b
    1d8e:	84 8d       	ldd	r24, Z+28	; 0x1c
    1d90:	98 13       	cpse	r25, r24
    1d92:	06 c0       	rjmp	.+12     	; 0x1da0 <_ZN14HardwareSerial17_tx_udr_empty_irqEv+0x42>
    // Buffer empty, so disable interrupts
    cbi(*_ucsrb, UDRIE0);
    1d94:	02 88       	ldd	r0, Z+18	; 0x12
    1d96:	f3 89       	ldd	r31, Z+19	; 0x13
    1d98:	e0 2d       	mov	r30, r0
    1d9a:	80 81       	ld	r24, Z
    1d9c:	8f 7d       	andi	r24, 0xDF	; 223
    1d9e:	80 83       	st	Z, r24
    1da0:	08 95       	ret

00001da2 <_ZN14HardwareSerial5writeEh>:
  // If we get here, nothing is queued anymore (DRIE is disabled) and
  // the hardware finished tranmission (TXC is set).
}

size_t HardwareSerial::write(uint8_t c)
{
    1da2:	ef 92       	push	r14
    1da4:	ff 92       	push	r15
    1da6:	0f 93       	push	r16
    1da8:	1f 93       	push	r17
    1daa:	cf 93       	push	r28
    1dac:	df 93       	push	r29
    1dae:	ec 01       	movw	r28, r24
  _written = true;
    1db0:	81 e0       	ldi	r24, 0x01	; 1
    1db2:	88 8f       	std	Y+24, r24	; 0x18
  // If the buffer and the data register is empty, just write the byte
  // to the data register and be done. This shortcut helps
  // significantly improve the effective datarate at high (>
  // 500kbit/s) bitrates, where interrupt overhead becomes a slowdown.
  if (_tx_buffer_head == _tx_buffer_tail && bit_is_set(*_ucsra, UDRE0)) {
    1db4:	9b 8d       	ldd	r25, Y+27	; 0x1b
    1db6:	8c 8d       	ldd	r24, Y+28	; 0x1c
    1db8:	98 13       	cpse	r25, r24
    1dba:	05 c0       	rjmp	.+10     	; 0x1dc6 <_ZN14HardwareSerial5writeEh+0x24>
    1dbc:	e8 89       	ldd	r30, Y+16	; 0x10
    1dbe:	f9 89       	ldd	r31, Y+17	; 0x11
    1dc0:	80 81       	ld	r24, Z
    1dc2:	85 fd       	sbrc	r24, 5
    1dc4:	26 c0       	rjmp	.+76     	; 0x1e12 <_ZN14HardwareSerial5writeEh+0x70>
    1dc6:	f6 2e       	mov	r15, r22
      *_ucsra = ((*_ucsra) & ((1 << U2X0) | (1 << TXC0)));
#endif
    }
    return 1;
  }
  tx_buffer_index_t i = (_tx_buffer_head + 1) % SERIAL_TX_BUFFER_SIZE;
    1dc8:	0b 8d       	ldd	r16, Y+27	; 0x1b
    1dca:	10 e0       	ldi	r17, 0x00	; 0
    1dcc:	0f 5f       	subi	r16, 0xFF	; 255
    1dce:	1f 4f       	sbci	r17, 0xFF	; 255
    1dd0:	0f 73       	andi	r16, 0x3F	; 63
    1dd2:	11 27       	eor	r17, r17
    1dd4:	e0 2e       	mov	r14, r16
	
  // If the output buffer is full, there's nothing for it other than to 
  // wait for the interrupt handler to empty it a bit
  while (i == _tx_buffer_tail) {
    1dd6:	8c 8d       	ldd	r24, Y+28	; 0x1c
    1dd8:	e8 12       	cpse	r14, r24
    1dda:	0c c0       	rjmp	.+24     	; 0x1df4 <_ZN14HardwareSerial5writeEh+0x52>
    if (bit_is_clear(SREG, SREG_I)) {
    1ddc:	0f b6       	in	r0, 0x3f	; 63
    1dde:	07 fc       	sbrc	r0, 7
    1de0:	fa cf       	rjmp	.-12     	; 0x1dd6 <_ZN14HardwareSerial5writeEh+0x34>
      // Interrupts are disabled, so we'll have to poll the data
      // register empty flag ourselves. If it is set, pretend an
      // interrupt has happened and call the handler to free up
      // space for us.
      if(bit_is_set(*_ucsra, UDRE0))
    1de2:	e8 89       	ldd	r30, Y+16	; 0x10
    1de4:	f9 89       	ldd	r31, Y+17	; 0x11
    1de6:	80 81       	ld	r24, Z
    1de8:	85 ff       	sbrs	r24, 5
    1dea:	f5 cf       	rjmp	.-22     	; 0x1dd6 <_ZN14HardwareSerial5writeEh+0x34>
	_tx_udr_empty_irq();
    1dec:	ce 01       	movw	r24, r28
    1dee:	0e 94 af 0e 	call	0x1d5e	; 0x1d5e <_ZN14HardwareSerial17_tx_udr_empty_irqEv>
    1df2:	f1 cf       	rjmp	.-30     	; 0x1dd6 <_ZN14HardwareSerial5writeEh+0x34>
    } else {
      // nop, the interrupt handler will free up space for us
    }
  }

  _tx_buffer[_tx_buffer_head] = c;
    1df4:	8b 8d       	ldd	r24, Y+27	; 0x1b
    1df6:	fe 01       	movw	r30, r28
    1df8:	e8 0f       	add	r30, r24
    1dfa:	f1 1d       	adc	r31, r1
    1dfc:	e3 5a       	subi	r30, 0xA3	; 163
    1dfe:	ff 4f       	sbci	r31, 0xFF	; 255
    1e00:	f0 82       	st	Z, r15

  // make atomic to prevent execution of ISR between setting the
  // head pointer and setting the interrupt flag resulting in buffer
  // retransmission
  ATOMIC_BLOCK(ATOMIC_RESTORESTATE) {
    1e02:	9f b7       	in	r25, 0x3f	; 63
    return 1;
}

static __inline__ uint8_t __iCliRetVal(void)
{
    cli();
    1e04:	f8 94       	cli
    _tx_buffer_head = i;
    1e06:	0b 8f       	std	Y+27, r16	; 0x1b
    sbi(*_ucsrb, UDRIE0);
    1e08:	ea 89       	ldd	r30, Y+18	; 0x12
    1e0a:	fb 89       	ldd	r31, Y+19	; 0x13
    1e0c:	80 81       	ld	r24, Z
    1e0e:	80 62       	ori	r24, 0x20	; 32
    1e10:	0a c0       	rjmp	.+20     	; 0x1e26 <_ZN14HardwareSerial5writeEh+0x84>
    // So writing UDR must happen first.
    // Writing UDR and clearing TC must be done atomically, otherwise
    // interrupts might delay the TXC clear so the byte written to UDR
    // is transmitted (setting TXC) before clearing TXC. Then TXC will
    // be cleared when no bytes are left, causing flush() to hang
    ATOMIC_BLOCK(ATOMIC_RESTORESTATE) {
    1e12:	9f b7       	in	r25, 0x3f	; 63
    1e14:	f8 94       	cli
      *_udr = c;
    1e16:	ee 89       	ldd	r30, Y+22	; 0x16
    1e18:	ff 89       	ldd	r31, Y+23	; 0x17
    1e1a:	60 83       	st	Z, r22
#ifdef MPCM0
      *_ucsra = ((*_ucsra) & ((1 << U2X0) | (1 << MPCM0))) | (1 << TXC0);
    1e1c:	e8 89       	ldd	r30, Y+16	; 0x10
    1e1e:	f9 89       	ldd	r31, Y+17	; 0x11
    1e20:	80 81       	ld	r24, Z
    1e22:	83 70       	andi	r24, 0x03	; 3
    1e24:	80 64       	ori	r24, 0x40	; 64
    1e26:	80 83       	st	Z, r24
    (void)__s;
}

static __inline__ void __iRestore(const  uint8_t *__s)
{
    SREG = *__s;
    1e28:	9f bf       	out	0x3f, r25	; 63
    _tx_buffer_head = i;
    sbi(*_ucsrb, UDRIE0);
  }
  
  return 1;
}
    1e2a:	81 e0       	ldi	r24, 0x01	; 1
    1e2c:	90 e0       	ldi	r25, 0x00	; 0
    1e2e:	df 91       	pop	r29
    1e30:	cf 91       	pop	r28
    1e32:	1f 91       	pop	r17
    1e34:	0f 91       	pop	r16
    1e36:	ff 90       	pop	r15
    1e38:	ef 90       	pop	r14
    1e3a:	08 95       	ret

00001e3c <_ZN14HardwareSerial5flushEv>:
  if (head >= tail) return SERIAL_TX_BUFFER_SIZE - 1 - head + tail;
  return tail - head - 1;
}

void HardwareSerial::flush()
{
    1e3c:	cf 93       	push	r28
    1e3e:	df 93       	push	r29
    1e40:	ec 01       	movw	r28, r24
  // If we have never written a byte, no need to flush. This special
  // case is needed since there is no way to force the TXC (transmit
  // complete) bit to 1 during initialization
  if (!_written)
    1e42:	88 8d       	ldd	r24, Y+24	; 0x18
    1e44:	88 23       	and	r24, r24
    1e46:	c9 f0       	breq	.+50     	; 0x1e7a <_ZN14HardwareSerial5flushEv+0x3e>
    return;

  while (bit_is_set(*_ucsrb, UDRIE0) || bit_is_clear(*_ucsra, TXC0)) {
    1e48:	ea 89       	ldd	r30, Y+18	; 0x12
    1e4a:	fb 89       	ldd	r31, Y+19	; 0x13
    1e4c:	80 81       	ld	r24, Z
    1e4e:	85 fd       	sbrc	r24, 5
    1e50:	05 c0       	rjmp	.+10     	; 0x1e5c <_ZN14HardwareSerial5flushEv+0x20>
    1e52:	a8 89       	ldd	r26, Y+16	; 0x10
    1e54:	b9 89       	ldd	r27, Y+17	; 0x11
    1e56:	8c 91       	ld	r24, X
    1e58:	86 fd       	sbrc	r24, 6
    1e5a:	0f c0       	rjmp	.+30     	; 0x1e7a <_ZN14HardwareSerial5flushEv+0x3e>
    if (bit_is_clear(SREG, SREG_I) && bit_is_set(*_ucsrb, UDRIE0))
    1e5c:	0f b6       	in	r0, 0x3f	; 63
    1e5e:	07 fc       	sbrc	r0, 7
    1e60:	f5 cf       	rjmp	.-22     	; 0x1e4c <_ZN14HardwareSerial5flushEv+0x10>
    1e62:	80 81       	ld	r24, Z
    1e64:	85 ff       	sbrs	r24, 5
    1e66:	f2 cf       	rjmp	.-28     	; 0x1e4c <_ZN14HardwareSerial5flushEv+0x10>
	// Interrupts are globally disabled, but the DR empty
	// interrupt should be enabled, so poll the DR empty flag to
	// prevent deadlock
	if (bit_is_set(*_ucsra, UDRE0))
    1e68:	a8 89       	ldd	r26, Y+16	; 0x10
    1e6a:	b9 89       	ldd	r27, Y+17	; 0x11
    1e6c:	8c 91       	ld	r24, X
    1e6e:	85 ff       	sbrs	r24, 5
    1e70:	ed cf       	rjmp	.-38     	; 0x1e4c <_ZN14HardwareSerial5flushEv+0x10>
	  _tx_udr_empty_irq();
    1e72:	ce 01       	movw	r24, r28
    1e74:	0e 94 af 0e 	call	0x1d5e	; 0x1d5e <_ZN14HardwareSerial17_tx_udr_empty_irqEv>
    1e78:	e7 cf       	rjmp	.-50     	; 0x1e48 <_ZN14HardwareSerial5flushEv+0xc>
  }
  // If we get here, nothing is queued anymore (DRIE is disabled) and
  // the hardware finished tranmission (TXC is set).
}
    1e7a:	df 91       	pop	r29
    1e7c:	cf 91       	pop	r28
    1e7e:	08 95       	ret

00001e80 <_ZN14HardwareSerial5beginEmh>:
}

// Public Methods //////////////////////////////////////////////////////////////

void HardwareSerial::begin(unsigned long baud, byte config)
{
    1e80:	cf 92       	push	r12
    1e82:	df 92       	push	r13
    1e84:	ef 92       	push	r14
    1e86:	ff 92       	push	r15
    1e88:	1f 93       	push	r17
    1e8a:	cf 93       	push	r28
    1e8c:	df 93       	push	r29
    1e8e:	ec 01       	movw	r28, r24
    1e90:	6a 01       	movw	r12, r20
    1e92:	7b 01       	movw	r14, r22
    1e94:	12 2f       	mov	r17, r18
  // Try u2x mode first
  uint16_t baud_setting = (F_CPU / 4 / baud - 1) / 2;
  *_ucsra = 1 << U2X0;
    1e96:	e8 89       	ldd	r30, Y+16	; 0x10
    1e98:	f9 89       	ldd	r31, Y+17	; 0x11
    1e9a:	82 e0       	ldi	r24, 0x02	; 2
    1e9c:	80 83       	st	Z, r24
  // hardcoded exception for 57600 for compatibility with the bootloader
  // shipped with the Duemilanove and previous boards and the firmware
  // on the 8U2 on the Uno and Mega 2560. Also, The baud_setting cannot
  // be > 4095, so switch back to non-u2x mode if the baud rate is too
  // low.
  if (((F_CPU == 16000000UL) && (baud == 57600)) || (baud_setting >4095))
    1e9e:	41 15       	cp	r20, r1
    1ea0:	51 4e       	sbci	r21, 0xE1	; 225
    1ea2:	61 05       	cpc	r22, r1
    1ea4:	71 05       	cpc	r23, r1
    1ea6:	b1 f0       	breq	.+44     	; 0x1ed4 <_ZN14HardwareSerial5beginEmh+0x54>
// Public Methods //////////////////////////////////////////////////////////////

void HardwareSerial::begin(unsigned long baud, byte config)
{
  // Try u2x mode first
  uint16_t baud_setting = (F_CPU / 4 / baud - 1) / 2;
    1ea8:	60 e0       	ldi	r22, 0x00	; 0
    1eaa:	79 e0       	ldi	r23, 0x09	; 9
    1eac:	8d e3       	ldi	r24, 0x3D	; 61
    1eae:	90 e0       	ldi	r25, 0x00	; 0
    1eb0:	a7 01       	movw	r20, r14
    1eb2:	96 01       	movw	r18, r12
    1eb4:	0e 94 bd 21 	call	0x437a	; 0x437a <__udivmodsi4>
    1eb8:	da 01       	movw	r26, r20
    1eba:	c9 01       	movw	r24, r18
    1ebc:	01 97       	sbiw	r24, 0x01	; 1
    1ebe:	a1 09       	sbc	r26, r1
    1ec0:	b1 09       	sbc	r27, r1
    1ec2:	b6 95       	lsr	r27
    1ec4:	a7 95       	ror	r26
    1ec6:	97 95       	ror	r25
    1ec8:	87 95       	ror	r24
    1eca:	9c 01       	movw	r18, r24
  // hardcoded exception for 57600 for compatibility with the bootloader
  // shipped with the Duemilanove and previous boards and the firmware
  // on the 8U2 on the Uno and Mega 2560. Also, The baud_setting cannot
  // be > 4095, so switch back to non-u2x mode if the baud rate is too
  // low.
  if (((F_CPU == 16000000UL) && (baud == 57600)) || (baud_setting >4095))
    1ecc:	21 15       	cp	r18, r1
    1ece:	80 e1       	ldi	r24, 0x10	; 16
    1ed0:	38 07       	cpc	r19, r24
    1ed2:	a8 f0       	brcs	.+42     	; 0x1efe <_ZN14HardwareSerial5beginEmh+0x7e>
  {
    *_ucsra = 0;
    1ed4:	e8 89       	ldd	r30, Y+16	; 0x10
    1ed6:	f9 89       	ldd	r31, Y+17	; 0x11
    1ed8:	10 82       	st	Z, r1
    baud_setting = (F_CPU / 8 / baud - 1) / 2;
    1eda:	60 e8       	ldi	r22, 0x80	; 128
    1edc:	74 e8       	ldi	r23, 0x84	; 132
    1ede:	8e e1       	ldi	r24, 0x1E	; 30
    1ee0:	90 e0       	ldi	r25, 0x00	; 0
    1ee2:	a7 01       	movw	r20, r14
    1ee4:	96 01       	movw	r18, r12
    1ee6:	0e 94 bd 21 	call	0x437a	; 0x437a <__udivmodsi4>
    1eea:	da 01       	movw	r26, r20
    1eec:	c9 01       	movw	r24, r18
    1eee:	01 97       	sbiw	r24, 0x01	; 1
    1ef0:	a1 09       	sbc	r26, r1
    1ef2:	b1 09       	sbc	r27, r1
    1ef4:	b6 95       	lsr	r27
    1ef6:	a7 95       	ror	r26
    1ef8:	97 95       	ror	r25
    1efa:	87 95       	ror	r24
    1efc:	9c 01       	movw	r18, r24
  }

  // assign the baud_setting, a.k.a. ubrr (USART Baud Rate Register)
  *_ubrrh = baud_setting >> 8;
    1efe:	ec 85       	ldd	r30, Y+12	; 0x0c
    1f00:	fd 85       	ldd	r31, Y+13	; 0x0d
    1f02:	30 83       	st	Z, r19
  *_ubrrl = baud_setting;
    1f04:	ee 85       	ldd	r30, Y+14	; 0x0e
    1f06:	ff 85       	ldd	r31, Y+15	; 0x0f
    1f08:	20 83       	st	Z, r18

  _written = false;
    1f0a:	18 8e       	std	Y+24, r1	; 0x18

  //set the data bits, parity, and stop bits
#if defined(__AVR_ATmega8__)
  config |= 0x80; // select UCSRC register (shared with UBRRH)
#endif
  *_ucsrc = config;
    1f0c:	ec 89       	ldd	r30, Y+20	; 0x14
    1f0e:	fd 89       	ldd	r31, Y+21	; 0x15
    1f10:	10 83       	st	Z, r17
  
  sbi(*_ucsrb, RXEN0);
    1f12:	ea 89       	ldd	r30, Y+18	; 0x12
    1f14:	fb 89       	ldd	r31, Y+19	; 0x13
    1f16:	80 81       	ld	r24, Z
    1f18:	80 61       	ori	r24, 0x10	; 16
    1f1a:	80 83       	st	Z, r24
  sbi(*_ucsrb, TXEN0);
    1f1c:	ea 89       	ldd	r30, Y+18	; 0x12
    1f1e:	fb 89       	ldd	r31, Y+19	; 0x13
    1f20:	80 81       	ld	r24, Z
    1f22:	88 60       	ori	r24, 0x08	; 8
    1f24:	80 83       	st	Z, r24
  sbi(*_ucsrb, RXCIE0);
    1f26:	ea 89       	ldd	r30, Y+18	; 0x12
    1f28:	fb 89       	ldd	r31, Y+19	; 0x13
    1f2a:	80 81       	ld	r24, Z
    1f2c:	80 68       	ori	r24, 0x80	; 128
    1f2e:	80 83       	st	Z, r24
  cbi(*_ucsrb, UDRIE0);
    1f30:	ea 89       	ldd	r30, Y+18	; 0x12
    1f32:	fb 89       	ldd	r31, Y+19	; 0x13
    1f34:	80 81       	ld	r24, Z
    1f36:	8f 7d       	andi	r24, 0xDF	; 223
    1f38:	80 83       	st	Z, r24
}
    1f3a:	df 91       	pop	r29
    1f3c:	cf 91       	pop	r28
    1f3e:	1f 91       	pop	r17
    1f40:	ff 90       	pop	r15
    1f42:	ef 90       	pop	r14
    1f44:	df 90       	pop	r13
    1f46:	cf 90       	pop	r12
    1f48:	08 95       	ret

00001f4a <__vector_18>:
#elif defined(USART_RXC_vect)
  ISR(USART_RXC_vect) // ATmega8
#else
  #error "Don't know what the Data Received vector is called for Serial"
#endif
  {
    1f4a:	1f 92       	push	r1
    1f4c:	0f 92       	push	r0
    1f4e:	0f b6       	in	r0, 0x3f	; 63
    1f50:	0f 92       	push	r0
    1f52:	11 24       	eor	r1, r1
    1f54:	2f 93       	push	r18
    1f56:	8f 93       	push	r24
    1f58:	9f 93       	push	r25
    1f5a:	ef 93       	push	r30
    1f5c:	ff 93       	push	r31

// Actual interrupt handlers //////////////////////////////////////////////////////////////

void HardwareSerial::_rx_complete_irq(void)
{
  if (bit_is_clear(*_ucsra, UPE0)) {
    1f5e:	e0 91 c8 03 	lds	r30, 0x03C8	; 0x8003c8 <Serial+0x10>
    1f62:	f0 91 c9 03 	lds	r31, 0x03C9	; 0x8003c9 <Serial+0x11>
    1f66:	80 81       	ld	r24, Z
    1f68:	e0 91 ce 03 	lds	r30, 0x03CE	; 0x8003ce <Serial+0x16>
    1f6c:	f0 91 cf 03 	lds	r31, 0x03CF	; 0x8003cf <Serial+0x17>
    1f70:	82 fd       	sbrc	r24, 2
    1f72:	12 c0       	rjmp	.+36     	; 0x1f98 <__vector_18+0x4e>
    // No Parity error, read byte and store it in the buffer if there is
    // room
    unsigned char c = *_udr;
    1f74:	90 81       	ld	r25, Z
    rx_buffer_index_t i = (unsigned int)(_rx_buffer_head + 1) % SERIAL_RX_BUFFER_SIZE;
    1f76:	80 91 d1 03 	lds	r24, 0x03D1	; 0x8003d1 <Serial+0x19>
    1f7a:	8f 5f       	subi	r24, 0xFF	; 255
    1f7c:	8f 73       	andi	r24, 0x3F	; 63

    // if we should be storing the received character into the location
    // just before the tail (meaning that the head would advance to the
    // current location of the tail), we're about to overflow the buffer
    // and so we don't write the character or advance the head.
    if (i != _rx_buffer_tail) {
    1f7e:	20 91 d2 03 	lds	r18, 0x03D2	; 0x8003d2 <Serial+0x1a>
    1f82:	82 17       	cp	r24, r18
    1f84:	51 f0       	breq	.+20     	; 0x1f9a <__vector_18+0x50>
      _rx_buffer[_rx_buffer_head] = c;
    1f86:	e0 91 d1 03 	lds	r30, 0x03D1	; 0x8003d1 <Serial+0x19>
    1f8a:	f0 e0       	ldi	r31, 0x00	; 0
    1f8c:	e8 54       	subi	r30, 0x48	; 72
    1f8e:	fc 4f       	sbci	r31, 0xFC	; 252
    1f90:	95 8f       	std	Z+29, r25	; 0x1d
      _rx_buffer_head = i;
    1f92:	80 93 d1 03 	sts	0x03D1, r24	; 0x8003d1 <Serial+0x19>
    1f96:	01 c0       	rjmp	.+2      	; 0x1f9a <__vector_18+0x50>
    }
  } else {
    // Parity error, read byte but discard it
    *_udr;
    1f98:	80 81       	ld	r24, Z
    Serial._rx_complete_irq();
  }
    1f9a:	ff 91       	pop	r31
    1f9c:	ef 91       	pop	r30
    1f9e:	9f 91       	pop	r25
    1fa0:	8f 91       	pop	r24
    1fa2:	2f 91       	pop	r18
    1fa4:	0f 90       	pop	r0
    1fa6:	0f be       	out	0x3f, r0	; 63
    1fa8:	0f 90       	pop	r0
    1faa:	1f 90       	pop	r1
    1fac:	18 95       	reti

00001fae <__vector_19>:
#elif defined(USART_UDRE_vect)
ISR(USART_UDRE_vect)
#else
  #error "Don't know what the Data Register Empty vector is called for Serial"
#endif
{
    1fae:	1f 92       	push	r1
    1fb0:	0f 92       	push	r0
    1fb2:	0f b6       	in	r0, 0x3f	; 63
    1fb4:	0f 92       	push	r0
    1fb6:	11 24       	eor	r1, r1
    1fb8:	2f 93       	push	r18
    1fba:	3f 93       	push	r19
    1fbc:	4f 93       	push	r20
    1fbe:	5f 93       	push	r21
    1fc0:	6f 93       	push	r22
    1fc2:	7f 93       	push	r23
    1fc4:	8f 93       	push	r24
    1fc6:	9f 93       	push	r25
    1fc8:	af 93       	push	r26
    1fca:	bf 93       	push	r27
    1fcc:	ef 93       	push	r30
    1fce:	ff 93       	push	r31
  Serial._tx_udr_empty_irq();
    1fd0:	88 eb       	ldi	r24, 0xB8	; 184
    1fd2:	93 e0       	ldi	r25, 0x03	; 3
    1fd4:	0e 94 af 0e 	call	0x1d5e	; 0x1d5e <_ZN14HardwareSerial17_tx_udr_empty_irqEv>
}
    1fd8:	ff 91       	pop	r31
    1fda:	ef 91       	pop	r30
    1fdc:	bf 91       	pop	r27
    1fde:	af 91       	pop	r26
    1fe0:	9f 91       	pop	r25
    1fe2:	8f 91       	pop	r24
    1fe4:	7f 91       	pop	r23
    1fe6:	6f 91       	pop	r22
    1fe8:	5f 91       	pop	r21
    1fea:	4f 91       	pop	r20
    1fec:	3f 91       	pop	r19
    1fee:	2f 91       	pop	r18
    1ff0:	0f 90       	pop	r0
    1ff2:	0f be       	out	0x3f, r0	; 63
    1ff4:	0f 90       	pop	r0
    1ff6:	1f 90       	pop	r1
    1ff8:	18 95       	reti

00001ffa <_Z17Serial0_availablev>:
#endif

// Function that can be weakly referenced by serialEventRun to prevent
// pulling in this file if it's not otherwise used.
bool Serial0_available() {
  return Serial.available();
    1ffa:	88 eb       	ldi	r24, 0xB8	; 184
    1ffc:	93 e0       	ldi	r25, 0x03	; 3
    1ffe:	0e 94 64 0e 	call	0x1cc8	; 0x1cc8 <_ZN14HardwareSerial9availableEv>
    2002:	21 e0       	ldi	r18, 0x01	; 1
    2004:	89 2b       	or	r24, r25
    2006:	09 f4       	brne	.+2      	; 0x200a <_Z17Serial0_availablev+0x10>
    2008:	20 e0       	ldi	r18, 0x00	; 0
}
    200a:	82 2f       	mov	r24, r18
    200c:	08 95       	ret

0000200e <_GLOBAL__sub_I___vector_18>:
    size_t printNumber(unsigned long, uint8_t);
    size_t printFloat(double, uint8_t);
  protected:
    void setWriteError(int err = 1) { write_error = err; }
  public:
    Print() : write_error(0) {}
    200e:	e8 eb       	ldi	r30, 0xB8	; 184
    2010:	f3 e0       	ldi	r31, 0x03	; 3
    2012:	13 82       	std	Z+3, r1	; 0x03
    2014:	12 82       	std	Z+2, r1	; 0x02
  public:
    virtual int available() = 0;
    virtual int read() = 0;
    virtual int peek() = 0;

    Stream() {_timeout=1000;}
    2016:	88 ee       	ldi	r24, 0xE8	; 232
    2018:	93 e0       	ldi	r25, 0x03	; 3
    201a:	a0 e0       	ldi	r26, 0x00	; 0
    201c:	b0 e0       	ldi	r27, 0x00	; 0
    201e:	84 83       	std	Z+4, r24	; 0x04
    2020:	95 83       	std	Z+5, r25	; 0x05
    2022:	a6 83       	std	Z+6, r26	; 0x06
    2024:	b7 83       	std	Z+7, r27	; 0x07
  volatile uint8_t *ucsrc, volatile uint8_t *udr) :
    _ubrrh(ubrrh), _ubrrl(ubrrl),
    _ucsra(ucsra), _ucsrb(ucsrb), _ucsrc(ucsrc),
    _udr(udr),
    _rx_buffer_head(0), _rx_buffer_tail(0),
    _tx_buffer_head(0), _tx_buffer_tail(0)
    2026:	8d e4       	ldi	r24, 0x4D	; 77
    2028:	92 e0       	ldi	r25, 0x02	; 2
    202a:	91 83       	std	Z+1, r25	; 0x01
    202c:	80 83       	st	Z, r24
    202e:	85 ec       	ldi	r24, 0xC5	; 197
    2030:	90 e0       	ldi	r25, 0x00	; 0
    2032:	95 87       	std	Z+13, r25	; 0x0d
    2034:	84 87       	std	Z+12, r24	; 0x0c
    2036:	84 ec       	ldi	r24, 0xC4	; 196
    2038:	90 e0       	ldi	r25, 0x00	; 0
    203a:	97 87       	std	Z+15, r25	; 0x0f
    203c:	86 87       	std	Z+14, r24	; 0x0e
    203e:	80 ec       	ldi	r24, 0xC0	; 192
    2040:	90 e0       	ldi	r25, 0x00	; 0
    2042:	91 8b       	std	Z+17, r25	; 0x11
    2044:	80 8b       	std	Z+16, r24	; 0x10
    2046:	81 ec       	ldi	r24, 0xC1	; 193
    2048:	90 e0       	ldi	r25, 0x00	; 0
    204a:	93 8b       	std	Z+19, r25	; 0x13
    204c:	82 8b       	std	Z+18, r24	; 0x12
    204e:	82 ec       	ldi	r24, 0xC2	; 194
    2050:	90 e0       	ldi	r25, 0x00	; 0
    2052:	95 8b       	std	Z+21, r25	; 0x15
    2054:	84 8b       	std	Z+20, r24	; 0x14
    2056:	86 ec       	ldi	r24, 0xC6	; 198
    2058:	90 e0       	ldi	r25, 0x00	; 0
    205a:	97 8b       	std	Z+23, r25	; 0x17
    205c:	86 8b       	std	Z+22, r24	; 0x16
    205e:	11 8e       	std	Z+25, r1	; 0x19
    2060:	12 8e       	std	Z+26, r1	; 0x1a
    2062:	13 8e       	std	Z+27, r1	; 0x1b
    2064:	14 8e       	std	Z+28, r1	; 0x1c
    2066:	08 95       	ret

00002068 <main>:
void setupUSB() __attribute__((weak));
void setupUSB() { }

int main(void)
{
	init();
    2068:	0e 94 98 13 	call	0x2730	; 0x2730 <init>

	initVariant();
    206c:	0e 94 c5 1b 	call	0x378a	; 0x378a <initVariant>

#if defined(USBCON)
	USBDevice.attach();
#endif
	
	setup();
    2070:	0e 94 72 07 	call	0xee4	; 0xee4 <setup>
    
	for (;;) {
		loop();
		if (serialEventRun) serialEventRun();
    2074:	c1 ea       	ldi	r28, 0xA1	; 161
    2076:	de e0       	ldi	r29, 0x0E	; 14
#endif
	
	setup();
    
	for (;;) {
		loop();
    2078:	0e 94 de 07 	call	0xfbc	; 0xfbc <loop>
		if (serialEventRun) serialEventRun();
    207c:	20 97       	sbiw	r28, 0x00	; 0
    207e:	e1 f3       	breq	.-8      	; 0x2078 <main+0x10>
    2080:	0e 94 a1 0e 	call	0x1d42	; 0x1d42 <_Z14serialEventRunv>
    2084:	f9 cf       	rjmp	.-14     	; 0x2078 <main+0x10>

00002086 <_ZN5Print5writeEPKhj>:
  else return printNumber(n, base);
}

size_t Print::print(double n, int digits)
{
  return printFloat(n, digits);
    2086:	cf 92       	push	r12
    2088:	df 92       	push	r13
    208a:	ef 92       	push	r14
    208c:	ff 92       	push	r15
    208e:	0f 93       	push	r16
    2090:	1f 93       	push	r17
    2092:	cf 93       	push	r28
    2094:	df 93       	push	r29
    2096:	6c 01       	movw	r12, r24
    2098:	7a 01       	movw	r14, r20
    209a:	8b 01       	movw	r16, r22
    209c:	c0 e0       	ldi	r28, 0x00	; 0
    209e:	d0 e0       	ldi	r29, 0x00	; 0
    20a0:	ce 15       	cp	r28, r14
    20a2:	df 05       	cpc	r29, r15
    20a4:	81 f0       	breq	.+32     	; 0x20c6 <_ZN5Print5writeEPKhj+0x40>
    20a6:	d8 01       	movw	r26, r16
    20a8:	6d 91       	ld	r22, X+
    20aa:	8d 01       	movw	r16, r26
    20ac:	d6 01       	movw	r26, r12
    20ae:	ed 91       	ld	r30, X+
    20b0:	fc 91       	ld	r31, X
    20b2:	01 90       	ld	r0, Z+
    20b4:	f0 81       	ld	r31, Z
    20b6:	e0 2d       	mov	r30, r0
    20b8:	c6 01       	movw	r24, r12
    20ba:	09 95       	icall
    20bc:	89 2b       	or	r24, r25
    20be:	11 f0       	breq	.+4      	; 0x20c4 <_ZN5Print5writeEPKhj+0x3e>
    20c0:	21 96       	adiw	r28, 0x01	; 1
    20c2:	ee cf       	rjmp	.-36     	; 0x20a0 <_ZN5Print5writeEPKhj+0x1a>
    20c4:	7e 01       	movw	r14, r28
    20c6:	c7 01       	movw	r24, r14
    20c8:	df 91       	pop	r29
    20ca:	cf 91       	pop	r28
    20cc:	1f 91       	pop	r17
    20ce:	0f 91       	pop	r16
    20d0:	ff 90       	pop	r15
    20d2:	ef 90       	pop	r14
    20d4:	df 90       	pop	r13
    20d6:	cf 90       	pop	r12
    20d8:	08 95       	ret

000020da <_ZN5Print5printEPK19__FlashStringHelper>:
    20da:	ef 92       	push	r14
    20dc:	ff 92       	push	r15
    20de:	0f 93       	push	r16
    20e0:	1f 93       	push	r17
    20e2:	cf 93       	push	r28
    20e4:	df 93       	push	r29
    20e6:	8c 01       	movw	r16, r24
    20e8:	7b 01       	movw	r14, r22
    20ea:	c0 e0       	ldi	r28, 0x00	; 0
    20ec:	d0 e0       	ldi	r29, 0x00	; 0
    20ee:	f7 01       	movw	r30, r14
    20f0:	ec 0f       	add	r30, r28
    20f2:	fd 1f       	adc	r31, r29
    20f4:	64 91       	lpm	r22, Z
    20f6:	66 23       	and	r22, r22
    20f8:	61 f0       	breq	.+24     	; 0x2112 <_ZN5Print5printEPK19__FlashStringHelper+0x38>
    20fa:	d8 01       	movw	r26, r16
    20fc:	ed 91       	ld	r30, X+
    20fe:	fc 91       	ld	r31, X
    2100:	01 90       	ld	r0, Z+
    2102:	f0 81       	ld	r31, Z
    2104:	e0 2d       	mov	r30, r0
    2106:	c8 01       	movw	r24, r16
    2108:	09 95       	icall
    210a:	89 2b       	or	r24, r25
    210c:	11 f0       	breq	.+4      	; 0x2112 <_ZN5Print5printEPK19__FlashStringHelper+0x38>
    210e:	21 96       	adiw	r28, 0x01	; 1
    2110:	ee cf       	rjmp	.-36     	; 0x20ee <_ZN5Print5printEPK19__FlashStringHelper+0x14>
    2112:	ce 01       	movw	r24, r28
    2114:	df 91       	pop	r29
    2116:	cf 91       	pop	r28
    2118:	1f 91       	pop	r17
    211a:	0f 91       	pop	r16
    211c:	ff 90       	pop	r15
    211e:	ef 90       	pop	r14
    2120:	08 95       	ret

00002122 <_ZN5Print5printEPKc>:
    2122:	0c 94 13 02 	jmp	0x426	; 0x426 <_ZN5Print5writeEPKc>

00002126 <_ZN5Print5printEc>:
    2126:	dc 01       	movw	r26, r24
    2128:	ed 91       	ld	r30, X+
    212a:	fc 91       	ld	r31, X
    212c:	01 90       	ld	r0, Z+
    212e:	f0 81       	ld	r31, Z
    2130:	e0 2d       	mov	r30, r0
    2132:	09 94       	ijmp

00002134 <_ZN5Print7printlnEv>:
    2134:	6b e5       	ldi	r22, 0x5B	; 91
    2136:	72 e0       	ldi	r23, 0x02	; 2
    2138:	0c 94 13 02 	jmp	0x426	; 0x426 <_ZN5Print5writeEPKc>

0000213c <_ZN5Print7printlnEPKc>:
    213c:	0f 93       	push	r16
    213e:	1f 93       	push	r17
    2140:	cf 93       	push	r28
    2142:	df 93       	push	r29
    2144:	ec 01       	movw	r28, r24
    2146:	0e 94 13 02 	call	0x426	; 0x426 <_ZN5Print5writeEPKc>
    214a:	8c 01       	movw	r16, r24
    214c:	ce 01       	movw	r24, r28
    214e:	0e 94 9a 10 	call	0x2134	; 0x2134 <_ZN5Print7printlnEv>
    2152:	80 0f       	add	r24, r16
    2154:	91 1f       	adc	r25, r17
    2156:	df 91       	pop	r29
    2158:	cf 91       	pop	r28
    215a:	1f 91       	pop	r17
    215c:	0f 91       	pop	r16
    215e:	08 95       	ret

00002160 <_ZN5Print11printNumberEmh>:
    2160:	8f 92       	push	r8
    2162:	9f 92       	push	r9
    2164:	af 92       	push	r10
    2166:	bf 92       	push	r11
    2168:	ef 92       	push	r14
    216a:	ff 92       	push	r15
    216c:	0f 93       	push	r16
    216e:	1f 93       	push	r17
    2170:	cf 93       	push	r28
    2172:	df 93       	push	r29
    2174:	cd b7       	in	r28, 0x3d	; 61
    2176:	de b7       	in	r29, 0x3e	; 62
    2178:	a1 97       	sbiw	r28, 0x21	; 33
    217a:	0f b6       	in	r0, 0x3f	; 63
    217c:	f8 94       	cli
    217e:	de bf       	out	0x3e, r29	; 62
    2180:	0f be       	out	0x3f, r0	; 63
    2182:	cd bf       	out	0x3d, r28	; 61
    2184:	7c 01       	movw	r14, r24
    2186:	fa 01       	movw	r30, r20
    2188:	cb 01       	movw	r24, r22
    218a:	19 a2       	std	Y+33, r1	; 0x21
    218c:	22 30       	cpi	r18, 0x02	; 2
    218e:	08 f4       	brcc	.+2      	; 0x2192 <_ZN5Print11printNumberEmh+0x32>
    2190:	2a e0       	ldi	r18, 0x0A	; 10
    2192:	8e 01       	movw	r16, r28
    2194:	0f 5d       	subi	r16, 0xDF	; 223
    2196:	1f 4f       	sbci	r17, 0xFF	; 255
    2198:	82 2e       	mov	r8, r18
    219a:	91 2c       	mov	r9, r1
    219c:	a1 2c       	mov	r10, r1
    219e:	b1 2c       	mov	r11, r1
    21a0:	bf 01       	movw	r22, r30
    21a2:	a5 01       	movw	r20, r10
    21a4:	94 01       	movw	r18, r8
    21a6:	0e 94 bd 21 	call	0x437a	; 0x437a <__udivmodsi4>
    21aa:	f9 01       	movw	r30, r18
    21ac:	ca 01       	movw	r24, r20
    21ae:	01 50       	subi	r16, 0x01	; 1
    21b0:	11 09       	sbc	r17, r1
    21b2:	6a 30       	cpi	r22, 0x0A	; 10
    21b4:	10 f4       	brcc	.+4      	; 0x21ba <_ZN5Print11printNumberEmh+0x5a>
    21b6:	60 5d       	subi	r22, 0xD0	; 208
    21b8:	01 c0       	rjmp	.+2      	; 0x21bc <_ZN5Print11printNumberEmh+0x5c>
    21ba:	69 5c       	subi	r22, 0xC9	; 201
    21bc:	d8 01       	movw	r26, r16
    21be:	6c 93       	st	X, r22
    21c0:	23 2b       	or	r18, r19
    21c2:	24 2b       	or	r18, r20
    21c4:	25 2b       	or	r18, r21
    21c6:	61 f7       	brne	.-40     	; 0x21a0 <_ZN5Print11printNumberEmh+0x40>
    21c8:	b8 01       	movw	r22, r16
    21ca:	c7 01       	movw	r24, r14
    21cc:	0e 94 13 02 	call	0x426	; 0x426 <_ZN5Print5writeEPKc>
    21d0:	a1 96       	adiw	r28, 0x21	; 33
    21d2:	0f b6       	in	r0, 0x3f	; 63
    21d4:	f8 94       	cli
    21d6:	de bf       	out	0x3e, r29	; 62
    21d8:	0f be       	out	0x3f, r0	; 63
    21da:	cd bf       	out	0x3d, r28	; 61
    21dc:	df 91       	pop	r29
    21de:	cf 91       	pop	r28
    21e0:	1f 91       	pop	r17
    21e2:	0f 91       	pop	r16
    21e4:	ff 90       	pop	r15
    21e6:	ef 90       	pop	r14
    21e8:	bf 90       	pop	r11
    21ea:	af 90       	pop	r10
    21ec:	9f 90       	pop	r9
    21ee:	8f 90       	pop	r8
    21f0:	08 95       	ret

000021f2 <_ZN5Print5printEmi>:
    21f2:	21 15       	cp	r18, r1
    21f4:	31 05       	cpc	r19, r1
    21f6:	41 f4       	brne	.+16     	; 0x2208 <_ZN5Print5printEmi+0x16>
    21f8:	dc 01       	movw	r26, r24
    21fa:	ed 91       	ld	r30, X+
    21fc:	fc 91       	ld	r31, X
    21fe:	01 90       	ld	r0, Z+
    2200:	f0 81       	ld	r31, Z
    2202:	e0 2d       	mov	r30, r0
    2204:	64 2f       	mov	r22, r20
    2206:	09 94       	ijmp
    2208:	0c 94 b0 10 	jmp	0x2160	; 0x2160 <_ZN5Print11printNumberEmh>

0000220c <_ZN5Print5printEhi>:
    220c:	9a 01       	movw	r18, r20
    220e:	46 2f       	mov	r20, r22
    2210:	50 e0       	ldi	r21, 0x00	; 0
    2212:	60 e0       	ldi	r22, 0x00	; 0
    2214:	70 e0       	ldi	r23, 0x00	; 0
    2216:	0c 94 f9 10 	jmp	0x21f2	; 0x21f2 <_ZN5Print5printEmi>

0000221a <_ZN5Print7printlnEhi>:
    221a:	0f 93       	push	r16
    221c:	1f 93       	push	r17
    221e:	cf 93       	push	r28
    2220:	df 93       	push	r29
    2222:	ec 01       	movw	r28, r24
    2224:	0e 94 06 11 	call	0x220c	; 0x220c <_ZN5Print5printEhi>
    2228:	8c 01       	movw	r16, r24
    222a:	ce 01       	movw	r24, r28
    222c:	0e 94 9a 10 	call	0x2134	; 0x2134 <_ZN5Print7printlnEv>
    2230:	80 0f       	add	r24, r16
    2232:	91 1f       	adc	r25, r17
    2234:	df 91       	pop	r29
    2236:	cf 91       	pop	r28
    2238:	1f 91       	pop	r17
    223a:	0f 91       	pop	r16
    223c:	08 95       	ret

0000223e <_ZN5Print5printEji>:
    223e:	9a 01       	movw	r18, r20
    2240:	ab 01       	movw	r20, r22
    2242:	60 e0       	ldi	r22, 0x00	; 0
    2244:	70 e0       	ldi	r23, 0x00	; 0
    2246:	0c 94 f9 10 	jmp	0x21f2	; 0x21f2 <_ZN5Print5printEmi>

0000224a <_ZN5Print5printEli>:
    224a:	cf 92       	push	r12
    224c:	df 92       	push	r13
    224e:	ef 92       	push	r14
    2250:	ff 92       	push	r15
    2252:	0f 93       	push	r16
    2254:	1f 93       	push	r17
    2256:	cf 93       	push	r28
    2258:	df 93       	push	r29
    225a:	21 15       	cp	r18, r1
    225c:	31 05       	cpc	r19, r1
    225e:	81 f4       	brne	.+32     	; 0x2280 <_ZN5Print5printEli+0x36>
    2260:	dc 01       	movw	r26, r24
    2262:	ed 91       	ld	r30, X+
    2264:	fc 91       	ld	r31, X
    2266:	01 90       	ld	r0, Z+
    2268:	f0 81       	ld	r31, Z
    226a:	e0 2d       	mov	r30, r0
    226c:	64 2f       	mov	r22, r20
    226e:	df 91       	pop	r29
    2270:	cf 91       	pop	r28
    2272:	1f 91       	pop	r17
    2274:	0f 91       	pop	r16
    2276:	ff 90       	pop	r15
    2278:	ef 90       	pop	r14
    227a:	df 90       	pop	r13
    227c:	cf 90       	pop	r12
    227e:	09 94       	ijmp
    2280:	2a 30       	cpi	r18, 0x0A	; 10
    2282:	31 05       	cpc	r19, r1
    2284:	01 f5       	brne	.+64     	; 0x22c6 <_ZN5Print5printEli+0x7c>
    2286:	77 ff       	sbrs	r23, 7
    2288:	1d c0       	rjmp	.+58     	; 0x22c4 <_ZN5Print5printEli+0x7a>
    228a:	6a 01       	movw	r12, r20
    228c:	7b 01       	movw	r14, r22
    228e:	ec 01       	movw	r28, r24
    2290:	6d e2       	ldi	r22, 0x2D	; 45
    2292:	0e 94 93 10 	call	0x2126	; 0x2126 <_ZN5Print5printEc>
    2296:	8c 01       	movw	r16, r24
    2298:	44 27       	eor	r20, r20
    229a:	55 27       	eor	r21, r21
    229c:	ba 01       	movw	r22, r20
    229e:	4c 19       	sub	r20, r12
    22a0:	5d 09       	sbc	r21, r13
    22a2:	6e 09       	sbc	r22, r14
    22a4:	7f 09       	sbc	r23, r15
    22a6:	2a e0       	ldi	r18, 0x0A	; 10
    22a8:	ce 01       	movw	r24, r28
    22aa:	0e 94 b0 10 	call	0x2160	; 0x2160 <_ZN5Print11printNumberEmh>
    22ae:	80 0f       	add	r24, r16
    22b0:	91 1f       	adc	r25, r17
    22b2:	df 91       	pop	r29
    22b4:	cf 91       	pop	r28
    22b6:	1f 91       	pop	r17
    22b8:	0f 91       	pop	r16
    22ba:	ff 90       	pop	r15
    22bc:	ef 90       	pop	r14
    22be:	df 90       	pop	r13
    22c0:	cf 90       	pop	r12
    22c2:	08 95       	ret
    22c4:	2a e0       	ldi	r18, 0x0A	; 10
    22c6:	df 91       	pop	r29
    22c8:	cf 91       	pop	r28
    22ca:	1f 91       	pop	r17
    22cc:	0f 91       	pop	r16
    22ce:	ff 90       	pop	r15
    22d0:	ef 90       	pop	r14
    22d2:	df 90       	pop	r13
    22d4:	cf 90       	pop	r12
    22d6:	0c 94 b0 10 	jmp	0x2160	; 0x2160 <_ZN5Print11printNumberEmh>

000022da <_ZN5Print5printEii>:
    22da:	9a 01       	movw	r18, r20
    22dc:	ab 01       	movw	r20, r22
    22de:	77 0f       	add	r23, r23
    22e0:	66 0b       	sbc	r22, r22
    22e2:	77 0b       	sbc	r23, r23
    22e4:	0c 94 25 11 	jmp	0x224a	; 0x224a <_ZN5Print5printEli>

000022e8 <_ZN5Print7printlnEii>:
    22e8:	0f 93       	push	r16
    22ea:	1f 93       	push	r17
    22ec:	cf 93       	push	r28
    22ee:	df 93       	push	r29
    22f0:	ec 01       	movw	r28, r24
    22f2:	0e 94 6d 11 	call	0x22da	; 0x22da <_ZN5Print5printEii>
    22f6:	8c 01       	movw	r16, r24
    22f8:	ce 01       	movw	r24, r28
    22fa:	0e 94 9a 10 	call	0x2134	; 0x2134 <_ZN5Print7printlnEv>
    22fe:	80 0f       	add	r24, r16
    2300:	91 1f       	adc	r25, r17
    2302:	df 91       	pop	r29
    2304:	cf 91       	pop	r28
    2306:	1f 91       	pop	r17
    2308:	0f 91       	pop	r16
    230a:	08 95       	ret

0000230c <_ZN5Print10printFloatEdh>:
    230c:	7f 92       	push	r7
    230e:	8f 92       	push	r8
    2310:	9f 92       	push	r9
    2312:	af 92       	push	r10
    2314:	bf 92       	push	r11
    2316:	cf 92       	push	r12
    2318:	df 92       	push	r13
    231a:	ef 92       	push	r14
    231c:	ff 92       	push	r15
    231e:	0f 93       	push	r16
    2320:	1f 93       	push	r17
    2322:	cf 93       	push	r28
    2324:	df 93       	push	r29
    2326:	8c 01       	movw	r16, r24
    2328:	6a 01       	movw	r12, r20
    232a:	7b 01       	movw	r14, r22
    232c:	72 2e       	mov	r7, r18
    232e:	9a 01       	movw	r18, r20
    2330:	ab 01       	movw	r20, r22
    2332:	c7 01       	movw	r24, r14
    2334:	b6 01       	movw	r22, r12
    2336:	0e 94 a4 21 	call	0x4348	; 0x4348 <__unordsf2>
    233a:	88 23       	and	r24, r24
    233c:	19 f0       	breq	.+6      	; 0x2344 <_ZN5Print10printFloatEdh+0x38>
    233e:	6e e5       	ldi	r22, 0x5E	; 94
    2340:	72 e0       	ldi	r23, 0x02	; 2
    2342:	27 c0       	rjmp	.+78     	; 0x2392 <_ZN5Print10printFloatEdh+0x86>
    2344:	46 01       	movw	r8, r12
    2346:	57 01       	movw	r10, r14
    2348:	e8 94       	clt
    234a:	b7 f8       	bld	r11, 7
    234c:	2f ef       	ldi	r18, 0xFF	; 255
    234e:	3f ef       	ldi	r19, 0xFF	; 255
    2350:	4f e7       	ldi	r20, 0x7F	; 127
    2352:	5f e7       	ldi	r21, 0x7F	; 127
    2354:	c5 01       	movw	r24, r10
    2356:	b4 01       	movw	r22, r8
    2358:	0e 94 a4 21 	call	0x4348	; 0x4348 <__unordsf2>
    235c:	81 11       	cpse	r24, r1
    235e:	0d c0       	rjmp	.+26     	; 0x237a <_ZN5Print10printFloatEdh+0x6e>
    2360:	2f ef       	ldi	r18, 0xFF	; 255
    2362:	3f ef       	ldi	r19, 0xFF	; 255
    2364:	4f e7       	ldi	r20, 0x7F	; 127
    2366:	5f e7       	ldi	r21, 0x7F	; 127
    2368:	c5 01       	movw	r24, r10
    236a:	b4 01       	movw	r22, r8
    236c:	0e 94 93 0c 	call	0x1926	; 0x1926 <__cmpsf2>
    2370:	18 16       	cp	r1, r24
    2372:	1c f4       	brge	.+6      	; 0x237a <_ZN5Print10printFloatEdh+0x6e>
    2374:	62 e6       	ldi	r22, 0x62	; 98
    2376:	72 e0       	ldi	r23, 0x02	; 2
    2378:	0c c0       	rjmp	.+24     	; 0x2392 <_ZN5Print10printFloatEdh+0x86>
    237a:	2f ef       	ldi	r18, 0xFF	; 255
    237c:	3f ef       	ldi	r19, 0xFF	; 255
    237e:	4f e7       	ldi	r20, 0x7F	; 127
    2380:	5f e4       	ldi	r21, 0x4F	; 79
    2382:	c7 01       	movw	r24, r14
    2384:	b6 01       	movw	r22, r12
    2386:	0e 94 f2 0d 	call	0x1be4	; 0x1be4 <__gesf2>
    238a:	18 16       	cp	r1, r24
    238c:	94 f4       	brge	.+36     	; 0x23b2 <_ZN5Print10printFloatEdh+0xa6>
    238e:	66 e6       	ldi	r22, 0x66	; 102
    2390:	72 e0       	ldi	r23, 0x02	; 2
    2392:	c8 01       	movw	r24, r16
    2394:	df 91       	pop	r29
    2396:	cf 91       	pop	r28
    2398:	1f 91       	pop	r17
    239a:	0f 91       	pop	r16
    239c:	ff 90       	pop	r15
    239e:	ef 90       	pop	r14
    23a0:	df 90       	pop	r13
    23a2:	cf 90       	pop	r12
    23a4:	bf 90       	pop	r11
    23a6:	af 90       	pop	r10
    23a8:	9f 90       	pop	r9
    23aa:	8f 90       	pop	r8
    23ac:	7f 90       	pop	r7
    23ae:	0c 94 13 02 	jmp	0x426	; 0x426 <_ZN5Print5writeEPKc>
    23b2:	2f ef       	ldi	r18, 0xFF	; 255
    23b4:	3f ef       	ldi	r19, 0xFF	; 255
    23b6:	4f e7       	ldi	r20, 0x7F	; 127
    23b8:	5f ec       	ldi	r21, 0xCF	; 207
    23ba:	c7 01       	movw	r24, r14
    23bc:	b6 01       	movw	r22, r12
    23be:	0e 94 93 0c 	call	0x1926	; 0x1926 <__cmpsf2>
    23c2:	87 fd       	sbrc	r24, 7
    23c4:	e4 cf       	rjmp	.-56     	; 0x238e <_ZN5Print10printFloatEdh+0x82>
    23c6:	20 e0       	ldi	r18, 0x00	; 0
    23c8:	30 e0       	ldi	r19, 0x00	; 0
    23ca:	a9 01       	movw	r20, r18
    23cc:	c7 01       	movw	r24, r14
    23ce:	b6 01       	movw	r22, r12
    23d0:	0e 94 93 0c 	call	0x1926	; 0x1926 <__cmpsf2>
    23d4:	87 ff       	sbrs	r24, 7
    23d6:	0a c0       	rjmp	.+20     	; 0x23ec <_ZN5Print10printFloatEdh+0xe0>
    23d8:	6d e2       	ldi	r22, 0x2D	; 45
    23da:	c8 01       	movw	r24, r16
    23dc:	0e 94 93 10 	call	0x2126	; 0x2126 <_ZN5Print5printEc>
    23e0:	ec 01       	movw	r28, r24
    23e2:	f7 fa       	bst	r15, 7
    23e4:	f0 94       	com	r15
    23e6:	f7 f8       	bld	r15, 7
    23e8:	f0 94       	com	r15
    23ea:	02 c0       	rjmp	.+4      	; 0x23f0 <_ZN5Print10printFloatEdh+0xe4>
    23ec:	c0 e0       	ldi	r28, 0x00	; 0
    23ee:	d0 e0       	ldi	r29, 0x00	; 0
    23f0:	b1 2c       	mov	r11, r1
    23f2:	60 e0       	ldi	r22, 0x00	; 0
    23f4:	70 e0       	ldi	r23, 0x00	; 0
    23f6:	80 e0       	ldi	r24, 0x00	; 0
    23f8:	9f e3       	ldi	r25, 0x3F	; 63
    23fa:	7b 14       	cp	r7, r11
    23fc:	41 f0       	breq	.+16     	; 0x240e <_ZN5Print10printFloatEdh+0x102>
    23fe:	20 e0       	ldi	r18, 0x00	; 0
    2400:	30 e0       	ldi	r19, 0x00	; 0
    2402:	40 e2       	ldi	r20, 0x20	; 32
    2404:	51 e4       	ldi	r21, 0x41	; 65
    2406:	0e 94 98 0c 	call	0x1930	; 0x1930 <__divsf3>
    240a:	b3 94       	inc	r11
    240c:	f6 cf       	rjmp	.-20     	; 0x23fa <_ZN5Print10printFloatEdh+0xee>
    240e:	a7 01       	movw	r20, r14
    2410:	96 01       	movw	r18, r12
    2412:	0e 94 27 0c 	call	0x184e	; 0x184e <__addsf3>
    2416:	6b 01       	movw	r12, r22
    2418:	7c 01       	movw	r14, r24
    241a:	0e 94 11 0d 	call	0x1a22	; 0x1a22 <__fixunssfsi>
    241e:	4b 01       	movw	r8, r22
    2420:	5c 01       	movw	r10, r24
    2422:	2a e0       	ldi	r18, 0x0A	; 10
    2424:	ab 01       	movw	r20, r22
    2426:	bc 01       	movw	r22, r24
    2428:	c8 01       	movw	r24, r16
    242a:	0e 94 b0 10 	call	0x2160	; 0x2160 <_ZN5Print11printNumberEmh>
    242e:	c8 0f       	add	r28, r24
    2430:	d9 1f       	adc	r29, r25
    2432:	77 20       	and	r7, r7
    2434:	b9 f1       	breq	.+110    	; 0x24a4 <_ZN5Print10printFloatEdh+0x198>
    2436:	c5 01       	movw	r24, r10
    2438:	b4 01       	movw	r22, r8
    243a:	0e 94 40 0d 	call	0x1a80	; 0x1a80 <__floatunsisf>
    243e:	9b 01       	movw	r18, r22
    2440:	ac 01       	movw	r20, r24
    2442:	c7 01       	movw	r24, r14
    2444:	b6 01       	movw	r22, r12
    2446:	0e 94 26 0c 	call	0x184c	; 0x184c <__subsf3>
    244a:	6b 01       	movw	r12, r22
    244c:	7c 01       	movw	r14, r24
    244e:	6e e2       	ldi	r22, 0x2E	; 46
    2450:	c8 01       	movw	r24, r16
    2452:	0e 94 93 10 	call	0x2126	; 0x2126 <_ZN5Print5printEc>
    2456:	c8 0f       	add	r28, r24
    2458:	d9 1f       	adc	r29, r25
    245a:	20 e0       	ldi	r18, 0x00	; 0
    245c:	30 e0       	ldi	r19, 0x00	; 0
    245e:	40 e2       	ldi	r20, 0x20	; 32
    2460:	51 e4       	ldi	r21, 0x41	; 65
    2462:	c7 01       	movw	r24, r14
    2464:	b6 01       	movw	r22, r12
    2466:	0e 94 f7 0d 	call	0x1bee	; 0x1bee <__mulsf3>
    246a:	4b 01       	movw	r8, r22
    246c:	5c 01       	movw	r10, r24
    246e:	0e 94 11 0d 	call	0x1a22	; 0x1a22 <__fixunssfsi>
    2472:	6b 01       	movw	r12, r22
    2474:	7c 01       	movw	r14, r24
    2476:	4a e0       	ldi	r20, 0x0A	; 10
    2478:	50 e0       	ldi	r21, 0x00	; 0
    247a:	c8 01       	movw	r24, r16
    247c:	0e 94 1f 11 	call	0x223e	; 0x223e <_ZN5Print5printEji>
    2480:	c8 0f       	add	r28, r24
    2482:	d9 1f       	adc	r29, r25
    2484:	b6 01       	movw	r22, r12
    2486:	80 e0       	ldi	r24, 0x00	; 0
    2488:	90 e0       	ldi	r25, 0x00	; 0
    248a:	0e 94 40 0d 	call	0x1a80	; 0x1a80 <__floatunsisf>
    248e:	9b 01       	movw	r18, r22
    2490:	ac 01       	movw	r20, r24
    2492:	c5 01       	movw	r24, r10
    2494:	b4 01       	movw	r22, r8
    2496:	0e 94 26 0c 	call	0x184c	; 0x184c <__subsf3>
    249a:	6b 01       	movw	r12, r22
    249c:	7c 01       	movw	r14, r24
    249e:	7a 94       	dec	r7
    24a0:	71 10       	cpse	r7, r1
    24a2:	db cf       	rjmp	.-74     	; 0x245a <_ZN5Print10printFloatEdh+0x14e>
    24a4:	ce 01       	movw	r24, r28
    24a6:	df 91       	pop	r29
    24a8:	cf 91       	pop	r28
    24aa:	1f 91       	pop	r17
    24ac:	0f 91       	pop	r16
    24ae:	ff 90       	pop	r15
    24b0:	ef 90       	pop	r14
    24b2:	df 90       	pop	r13
    24b4:	cf 90       	pop	r12
    24b6:	bf 90       	pop	r11
    24b8:	af 90       	pop	r10
    24ba:	9f 90       	pop	r9
    24bc:	8f 90       	pop	r8
    24be:	7f 90       	pop	r7
    24c0:	08 95       	ret

000024c2 <_ZN5Print7printlnEdi>:
  n += println();
  return n;
}

size_t Print::println(double num, int digits)
{
    24c2:	0f 93       	push	r16
    24c4:	1f 93       	push	r17
    24c6:	cf 93       	push	r28
    24c8:	df 93       	push	r29
    24ca:	ec 01       	movw	r28, r24
  else return printNumber(n, base);
}

size_t Print::print(double n, int digits)
{
  return printFloat(n, digits);
    24cc:	0e 94 86 11 	call	0x230c	; 0x230c <_ZN5Print10printFloatEdh>
    24d0:	8c 01       	movw	r16, r24
}

size_t Print::println(double num, int digits)
{
  size_t n = print(num, digits);
  n += println();
    24d2:	ce 01       	movw	r24, r28
    24d4:	0e 94 9a 10 	call	0x2134	; 0x2134 <_ZN5Print7printlnEv>
  return n;
}
    24d8:	80 0f       	add	r24, r16
    24da:	91 1f       	adc	r25, r17
    24dc:	df 91       	pop	r29
    24de:	cf 91       	pop	r28
    24e0:	1f 91       	pop	r17
    24e2:	0f 91       	pop	r16
    24e4:	08 95       	ret

000024e6 <nothing>:
    #endif
      break;       
#endif
    }
      
    intFunc[interruptNum] = nothing;
    24e6:	08 95       	ret

000024e8 <attachInterrupt>:
    24e8:	82 30       	cpi	r24, 0x02	; 2
    24ea:	e8 f4       	brcc	.+58     	; 0x2526 <attachInterrupt+0x3e>
    24ec:	e8 2f       	mov	r30, r24
    24ee:	f0 e0       	ldi	r31, 0x00	; 0
    24f0:	ee 0f       	add	r30, r30
    24f2:	ff 1f       	adc	r31, r31
    24f4:	ed 5c       	subi	r30, 0xCD	; 205
    24f6:	fe 4f       	sbci	r31, 0xFE	; 254
    24f8:	71 83       	std	Z+1, r23	; 0x01
    24fa:	60 83       	st	Z, r22
    24fc:	81 30       	cpi	r24, 0x01	; 1
    24fe:	41 f0       	breq	.+16     	; 0x2510 <attachInterrupt+0x28>
    2500:	80 91 69 00 	lds	r24, 0x0069	; 0x800069 <__DATA_REGION_ORIGIN__+0x9>
    2504:	8c 7f       	andi	r24, 0xFC	; 252
    2506:	48 2b       	or	r20, r24
    2508:	40 93 69 00 	sts	0x0069, r20	; 0x800069 <__DATA_REGION_ORIGIN__+0x9>
    250c:	e8 9a       	sbi	0x1d, 0	; 29
    250e:	08 95       	ret
    2510:	80 91 69 00 	lds	r24, 0x0069	; 0x800069 <__DATA_REGION_ORIGIN__+0x9>
    2514:	83 7f       	andi	r24, 0xF3	; 243
    2516:	44 0f       	add	r20, r20
    2518:	55 1f       	adc	r21, r21
    251a:	44 0f       	add	r20, r20
    251c:	55 1f       	adc	r21, r21
    251e:	48 2b       	or	r20, r24
    2520:	40 93 69 00 	sts	0x0069, r20	; 0x800069 <__DATA_REGION_ORIGIN__+0x9>
    2524:	e9 9a       	sbi	0x1d, 1	; 29
    2526:	08 95       	ret

00002528 <__vector_1>:
IMPLEMENT_ISR(INT6_vect, EXTERNAL_INT_6)
IMPLEMENT_ISR(INT7_vect, EXTERNAL_INT_7)

#else

IMPLEMENT_ISR(INT0_vect, EXTERNAL_INT_0)
    2528:	1f 92       	push	r1
    252a:	0f 92       	push	r0
    252c:	0f b6       	in	r0, 0x3f	; 63
    252e:	0f 92       	push	r0
    2530:	11 24       	eor	r1, r1
    2532:	2f 93       	push	r18
    2534:	3f 93       	push	r19
    2536:	4f 93       	push	r20
    2538:	5f 93       	push	r21
    253a:	6f 93       	push	r22
    253c:	7f 93       	push	r23
    253e:	8f 93       	push	r24
    2540:	9f 93       	push	r25
    2542:	af 93       	push	r26
    2544:	bf 93       	push	r27
    2546:	ef 93       	push	r30
    2548:	ff 93       	push	r31
    254a:	e0 91 33 01 	lds	r30, 0x0133	; 0x800133 <intFunc>
    254e:	f0 91 34 01 	lds	r31, 0x0134	; 0x800134 <intFunc+0x1>
    2552:	09 95       	icall
    2554:	ff 91       	pop	r31
    2556:	ef 91       	pop	r30
    2558:	bf 91       	pop	r27
    255a:	af 91       	pop	r26
    255c:	9f 91       	pop	r25
    255e:	8f 91       	pop	r24
    2560:	7f 91       	pop	r23
    2562:	6f 91       	pop	r22
    2564:	5f 91       	pop	r21
    2566:	4f 91       	pop	r20
    2568:	3f 91       	pop	r19
    256a:	2f 91       	pop	r18
    256c:	0f 90       	pop	r0
    256e:	0f be       	out	0x3f, r0	; 63
    2570:	0f 90       	pop	r0
    2572:	1f 90       	pop	r1
    2574:	18 95       	reti

00002576 <__vector_2>:
IMPLEMENT_ISR(INT1_vect, EXTERNAL_INT_1)
    2576:	1f 92       	push	r1
    2578:	0f 92       	push	r0
    257a:	0f b6       	in	r0, 0x3f	; 63
    257c:	0f 92       	push	r0
    257e:	11 24       	eor	r1, r1
    2580:	2f 93       	push	r18
    2582:	3f 93       	push	r19
    2584:	4f 93       	push	r20
    2586:	5f 93       	push	r21
    2588:	6f 93       	push	r22
    258a:	7f 93       	push	r23
    258c:	8f 93       	push	r24
    258e:	9f 93       	push	r25
    2590:	af 93       	push	r26
    2592:	bf 93       	push	r27
    2594:	ef 93       	push	r30
    2596:	ff 93       	push	r31
    2598:	e0 91 35 01 	lds	r30, 0x0135	; 0x800135 <intFunc+0x2>
    259c:	f0 91 36 01 	lds	r31, 0x0136	; 0x800136 <intFunc+0x3>
    25a0:	09 95       	icall
    25a2:	ff 91       	pop	r31
    25a4:	ef 91       	pop	r30
    25a6:	bf 91       	pop	r27
    25a8:	af 91       	pop	r26
    25aa:	9f 91       	pop	r25
    25ac:	8f 91       	pop	r24
    25ae:	7f 91       	pop	r23
    25b0:	6f 91       	pop	r22
    25b2:	5f 91       	pop	r21
    25b4:	4f 91       	pop	r20
    25b6:	3f 91       	pop	r19
    25b8:	2f 91       	pop	r18
    25ba:	0f 90       	pop	r0
    25bc:	0f be       	out	0x3f, r0	; 63
    25be:	0f 90       	pop	r0
    25c0:	1f 90       	pop	r1
    25c2:	18 95       	reti

000025c4 <__vector_16>:
	cli();
	m = timer0_millis;
	SREG = oldSREG;

	return m;
}
    25c4:	1f 92       	push	r1
    25c6:	0f 92       	push	r0
    25c8:	0f b6       	in	r0, 0x3f	; 63
    25ca:	0f 92       	push	r0
    25cc:	11 24       	eor	r1, r1
    25ce:	2f 93       	push	r18
    25d0:	3f 93       	push	r19
    25d2:	8f 93       	push	r24
    25d4:	9f 93       	push	r25
    25d6:	af 93       	push	r26
    25d8:	bf 93       	push	r27
    25da:	80 91 56 04 	lds	r24, 0x0456	; 0x800456 <timer0_millis>
    25de:	90 91 57 04 	lds	r25, 0x0457	; 0x800457 <timer0_millis+0x1>
    25e2:	a0 91 58 04 	lds	r26, 0x0458	; 0x800458 <timer0_millis+0x2>
    25e6:	b0 91 59 04 	lds	r27, 0x0459	; 0x800459 <timer0_millis+0x3>
    25ea:	30 91 55 04 	lds	r19, 0x0455	; 0x800455 <timer0_fract>
    25ee:	23 e0       	ldi	r18, 0x03	; 3
    25f0:	23 0f       	add	r18, r19
    25f2:	2d 37       	cpi	r18, 0x7D	; 125
    25f4:	20 f4       	brcc	.+8      	; 0x25fe <__vector_16+0x3a>
    25f6:	01 96       	adiw	r24, 0x01	; 1
    25f8:	a1 1d       	adc	r26, r1
    25fa:	b1 1d       	adc	r27, r1
    25fc:	05 c0       	rjmp	.+10     	; 0x2608 <__vector_16+0x44>
    25fe:	26 e8       	ldi	r18, 0x86	; 134
    2600:	23 0f       	add	r18, r19
    2602:	02 96       	adiw	r24, 0x02	; 2
    2604:	a1 1d       	adc	r26, r1
    2606:	b1 1d       	adc	r27, r1
    2608:	20 93 55 04 	sts	0x0455, r18	; 0x800455 <timer0_fract>
    260c:	80 93 56 04 	sts	0x0456, r24	; 0x800456 <timer0_millis>
    2610:	90 93 57 04 	sts	0x0457, r25	; 0x800457 <timer0_millis+0x1>
    2614:	a0 93 58 04 	sts	0x0458, r26	; 0x800458 <timer0_millis+0x2>
    2618:	b0 93 59 04 	sts	0x0459, r27	; 0x800459 <timer0_millis+0x3>
    261c:	80 91 5a 04 	lds	r24, 0x045A	; 0x80045a <timer0_overflow_count>
    2620:	90 91 5b 04 	lds	r25, 0x045B	; 0x80045b <timer0_overflow_count+0x1>
    2624:	a0 91 5c 04 	lds	r26, 0x045C	; 0x80045c <timer0_overflow_count+0x2>
    2628:	b0 91 5d 04 	lds	r27, 0x045D	; 0x80045d <timer0_overflow_count+0x3>
    262c:	01 96       	adiw	r24, 0x01	; 1
    262e:	a1 1d       	adc	r26, r1
    2630:	b1 1d       	adc	r27, r1
    2632:	80 93 5a 04 	sts	0x045A, r24	; 0x80045a <timer0_overflow_count>
    2636:	90 93 5b 04 	sts	0x045B, r25	; 0x80045b <timer0_overflow_count+0x1>
    263a:	a0 93 5c 04 	sts	0x045C, r26	; 0x80045c <timer0_overflow_count+0x2>
    263e:	b0 93 5d 04 	sts	0x045D, r27	; 0x80045d <timer0_overflow_count+0x3>
    2642:	bf 91       	pop	r27
    2644:	af 91       	pop	r26
    2646:	9f 91       	pop	r25
    2648:	8f 91       	pop	r24
    264a:	3f 91       	pop	r19
    264c:	2f 91       	pop	r18
    264e:	0f 90       	pop	r0
    2650:	0f be       	out	0x3f, r0	; 63
    2652:	0f 90       	pop	r0
    2654:	1f 90       	pop	r1
    2656:	18 95       	reti

00002658 <micros>:

unsigned long micros() {
	unsigned long m;
	uint8_t oldSREG = SREG, t;
    2658:	3f b7       	in	r19, 0x3f	; 63
	
	cli();
    265a:	f8 94       	cli
	m = timer0_overflow_count;
    265c:	80 91 5a 04 	lds	r24, 0x045A	; 0x80045a <timer0_overflow_count>
    2660:	90 91 5b 04 	lds	r25, 0x045B	; 0x80045b <timer0_overflow_count+0x1>
    2664:	a0 91 5c 04 	lds	r26, 0x045C	; 0x80045c <timer0_overflow_count+0x2>
    2668:	b0 91 5d 04 	lds	r27, 0x045D	; 0x80045d <timer0_overflow_count+0x3>
#if defined(TCNT0)
	t = TCNT0;
    266c:	26 b5       	in	r18, 0x26	; 38
#else
	#error TIMER 0 not defined
#endif

#ifdef TIFR0
	if ((TIFR0 & _BV(TOV0)) && (t < 255))
    266e:	a8 9b       	sbis	0x15, 0	; 21
    2670:	05 c0       	rjmp	.+10     	; 0x267c <micros+0x24>
    2672:	2f 3f       	cpi	r18, 0xFF	; 255
    2674:	19 f0       	breq	.+6      	; 0x267c <micros+0x24>
		m++;
    2676:	01 96       	adiw	r24, 0x01	; 1
    2678:	a1 1d       	adc	r26, r1
    267a:	b1 1d       	adc	r27, r1
#else
	if ((TIFR & _BV(TOV0)) && (t < 255))
		m++;
#endif

	SREG = oldSREG;
    267c:	3f bf       	out	0x3f, r19	; 63
	
	return ((m << 8) + t) * (64 / clockCyclesPerMicrosecond());
    267e:	ba 2f       	mov	r27, r26
    2680:	a9 2f       	mov	r26, r25
    2682:	98 2f       	mov	r25, r24
    2684:	88 27       	eor	r24, r24
    2686:	82 0f       	add	r24, r18
    2688:	91 1d       	adc	r25, r1
    268a:	a1 1d       	adc	r26, r1
    268c:	b1 1d       	adc	r27, r1
    268e:	bc 01       	movw	r22, r24
    2690:	cd 01       	movw	r24, r26
    2692:	42 e0       	ldi	r20, 0x02	; 2
    2694:	66 0f       	add	r22, r22
    2696:	77 1f       	adc	r23, r23
    2698:	88 1f       	adc	r24, r24
    269a:	99 1f       	adc	r25, r25
    269c:	4a 95       	dec	r20
    269e:	d1 f7       	brne	.-12     	; 0x2694 <micros+0x3c>
}
    26a0:	08 95       	ret

000026a2 <delay>:

void delay(unsigned long ms)
{
    26a2:	8f 92       	push	r8
    26a4:	9f 92       	push	r9
    26a6:	af 92       	push	r10
    26a8:	bf 92       	push	r11
    26aa:	cf 92       	push	r12
    26ac:	df 92       	push	r13
    26ae:	ef 92       	push	r14
    26b0:	ff 92       	push	r15
    26b2:	6b 01       	movw	r12, r22
    26b4:	7c 01       	movw	r14, r24
	uint32_t start = micros();
    26b6:	0e 94 2c 13 	call	0x2658	; 0x2658 <micros>
    26ba:	4b 01       	movw	r8, r22
    26bc:	5c 01       	movw	r10, r24

	while (ms > 0) {
    26be:	c1 14       	cp	r12, r1
    26c0:	d1 04       	cpc	r13, r1
    26c2:	e1 04       	cpc	r14, r1
    26c4:	f1 04       	cpc	r15, r1
    26c6:	01 f1       	breq	.+64     	; 0x2708 <delay+0x66>
		yield();
    26c8:	0e 94 03 1d 	call	0x3a06	; 0x3a06 <yield>
		while ( ms > 0 && (micros() - start) >= 1000) {
    26cc:	0e 94 2c 13 	call	0x2658	; 0x2658 <micros>
    26d0:	dc 01       	movw	r26, r24
    26d2:	cb 01       	movw	r24, r22
    26d4:	88 19       	sub	r24, r8
    26d6:	99 09       	sbc	r25, r9
    26d8:	aa 09       	sbc	r26, r10
    26da:	bb 09       	sbc	r27, r11
    26dc:	88 3e       	cpi	r24, 0xE8	; 232
    26de:	93 40       	sbci	r25, 0x03	; 3
    26e0:	a1 05       	cpc	r26, r1
    26e2:	b1 05       	cpc	r27, r1
    26e4:	60 f3       	brcs	.-40     	; 0x26be <delay+0x1c>
			ms--;
    26e6:	21 e0       	ldi	r18, 0x01	; 1
    26e8:	c2 1a       	sub	r12, r18
    26ea:	d1 08       	sbc	r13, r1
    26ec:	e1 08       	sbc	r14, r1
    26ee:	f1 08       	sbc	r15, r1
			start += 1000;
    26f0:	88 ee       	ldi	r24, 0xE8	; 232
    26f2:	88 0e       	add	r8, r24
    26f4:	83 e0       	ldi	r24, 0x03	; 3
    26f6:	98 1e       	adc	r9, r24
    26f8:	a1 1c       	adc	r10, r1
    26fa:	b1 1c       	adc	r11, r1
{
	uint32_t start = micros();

	while (ms > 0) {
		yield();
		while ( ms > 0 && (micros() - start) >= 1000) {
    26fc:	c1 14       	cp	r12, r1
    26fe:	d1 04       	cpc	r13, r1
    2700:	e1 04       	cpc	r14, r1
    2702:	f1 04       	cpc	r15, r1
    2704:	19 f7       	brne	.-58     	; 0x26cc <delay+0x2a>
    2706:	db cf       	rjmp	.-74     	; 0x26be <delay+0x1c>
			ms--;
			start += 1000;
		}
	}
}
    2708:	ff 90       	pop	r15
    270a:	ef 90       	pop	r14
    270c:	df 90       	pop	r13
    270e:	cf 90       	pop	r12
    2710:	bf 90       	pop	r11
    2712:	af 90       	pop	r10
    2714:	9f 90       	pop	r9
    2716:	8f 90       	pop	r8
    2718:	08 95       	ret

0000271a <delayMicroseconds>:
#elif F_CPU >= 16000000L
	// for the 16 MHz clock on most Arduino boards

	// for a one-microsecond delay, simply return.  the overhead
	// of the function call takes 14 (16) cycles, which is 1us
	if (us <= 1) return; //  = 3 cycles, (4 when true)
    271a:	82 30       	cpi	r24, 0x02	; 2
    271c:	91 05       	cpc	r25, r1
    271e:	38 f0       	brcs	.+14     	; 0x272e <delayMicroseconds+0x14>

	// the following loop takes 1/4 of a microsecond (4 cycles)
	// per iteration, so execute it four times for each microsecond of
	// delay requested.
	us <<= 2; // x4 us, = 4 cycles
    2720:	88 0f       	add	r24, r24
    2722:	99 1f       	adc	r25, r25
    2724:	88 0f       	add	r24, r24
    2726:	99 1f       	adc	r25, r25

	// account for the time taken in the preceeding commands.
	// we just burned 19 (21) cycles above, remove 5, (5*4=20)
	// us is at least 8 so we can substract 5
	us -= 5; // = 2 cycles,
    2728:	05 97       	sbiw	r24, 0x05	; 5
	

#endif

	// busy wait
	__asm__ __volatile__ (
    272a:	01 97       	sbiw	r24, 0x01	; 1
    272c:	f1 f7       	brne	.-4      	; 0x272a <delayMicroseconds+0x10>
    272e:	08 95       	ret

00002730 <init>:

void init()
{
	// this needs to be called before setup() or some functions won't
	// work there
	sei();
    2730:	78 94       	sei
	
	// on the ATmega168, timer 0 is also used for fast hardware pwm
	// (using phase-correct PWM would mean that timer 0 overflowed half as often
	// resulting in different millis() behavior on the ATmega8 and ATmega168)
#if defined(TCCR0A) && defined(WGM01)
	sbi(TCCR0A, WGM01);
    2732:	84 b5       	in	r24, 0x24	; 36
    2734:	82 60       	ori	r24, 0x02	; 2
    2736:	84 bd       	out	0x24, r24	; 36
	sbi(TCCR0A, WGM00);
    2738:	84 b5       	in	r24, 0x24	; 36
    273a:	81 60       	ori	r24, 0x01	; 1
    273c:	84 bd       	out	0x24, r24	; 36
	// this combination is for the standard atmega8
	sbi(TCCR0, CS01);
	sbi(TCCR0, CS00);
#elif defined(TCCR0B) && defined(CS01) && defined(CS00)
	// this combination is for the standard 168/328/1280/2560
	sbi(TCCR0B, CS01);
    273e:	85 b5       	in	r24, 0x25	; 37
    2740:	82 60       	ori	r24, 0x02	; 2
    2742:	85 bd       	out	0x25, r24	; 37
	sbi(TCCR0B, CS00);
    2744:	85 b5       	in	r24, 0x25	; 37
    2746:	81 60       	ori	r24, 0x01	; 1
    2748:	85 bd       	out	0x25, r24	; 37

	// enable timer 0 overflow interrupt
#if defined(TIMSK) && defined(TOIE0)
	sbi(TIMSK, TOIE0);
#elif defined(TIMSK0) && defined(TOIE0)
	sbi(TIMSK0, TOIE0);
    274a:	ee e6       	ldi	r30, 0x6E	; 110
    274c:	f0 e0       	ldi	r31, 0x00	; 0
    274e:	80 81       	ld	r24, Z
    2750:	81 60       	ori	r24, 0x01	; 1
    2752:	80 83       	st	Z, r24
	// this is better for motors as it ensures an even waveform
	// note, however, that fast pwm mode can achieve a frequency of up
	// 8 MHz (with a 16 MHz clock) at 50% duty cycle

#if defined(TCCR1B) && defined(CS11) && defined(CS10)
	TCCR1B = 0;
    2754:	e1 e8       	ldi	r30, 0x81	; 129
    2756:	f0 e0       	ldi	r31, 0x00	; 0
    2758:	10 82       	st	Z, r1

	// set timer 1 prescale factor to 64
	sbi(TCCR1B, CS11);
    275a:	80 81       	ld	r24, Z
    275c:	82 60       	ori	r24, 0x02	; 2
    275e:	80 83       	st	Z, r24
#if F_CPU >= 8000000L
	sbi(TCCR1B, CS10);
    2760:	80 81       	ld	r24, Z
    2762:	81 60       	ori	r24, 0x01	; 1
    2764:	80 83       	st	Z, r24
	sbi(TCCR1, CS10);
#endif
#endif
	// put timer 1 in 8-bit phase correct pwm mode
#if defined(TCCR1A) && defined(WGM10)
	sbi(TCCR1A, WGM10);
    2766:	e0 e8       	ldi	r30, 0x80	; 128
    2768:	f0 e0       	ldi	r31, 0x00	; 0
    276a:	80 81       	ld	r24, Z
    276c:	81 60       	ori	r24, 0x01	; 1
    276e:	80 83       	st	Z, r24

	// set timer 2 prescale factor to 64
#if defined(TCCR2) && defined(CS22)
	sbi(TCCR2, CS22);
#elif defined(TCCR2B) && defined(CS22)
	sbi(TCCR2B, CS22);
    2770:	e1 eb       	ldi	r30, 0xB1	; 177
    2772:	f0 e0       	ldi	r31, 0x00	; 0
    2774:	80 81       	ld	r24, Z
    2776:	84 60       	ori	r24, 0x04	; 4
    2778:	80 83       	st	Z, r24

	// configure timer 2 for phase correct pwm (8-bit)
#if defined(TCCR2) && defined(WGM20)
	sbi(TCCR2, WGM20);
#elif defined(TCCR2A) && defined(WGM20)
	sbi(TCCR2A, WGM20);
    277a:	e0 eb       	ldi	r30, 0xB0	; 176
    277c:	f0 e0       	ldi	r31, 0x00	; 0
    277e:	80 81       	ld	r24, Z
    2780:	81 60       	ori	r24, 0x01	; 1
    2782:	80 83       	st	Z, r24
#endif

#if defined(ADCSRA)
	// set a2d prescaler so we are inside the desired 50-200 KHz range.
	#if F_CPU >= 16000000 // 16 MHz / 128 = 125 KHz
		sbi(ADCSRA, ADPS2);
    2784:	ea e7       	ldi	r30, 0x7A	; 122
    2786:	f0 e0       	ldi	r31, 0x00	; 0
    2788:	80 81       	ld	r24, Z
    278a:	84 60       	ori	r24, 0x04	; 4
    278c:	80 83       	st	Z, r24
		sbi(ADCSRA, ADPS1);
    278e:	80 81       	ld	r24, Z
    2790:	82 60       	ori	r24, 0x02	; 2
    2792:	80 83       	st	Z, r24
		sbi(ADCSRA, ADPS0);
    2794:	80 81       	ld	r24, Z
    2796:	81 60       	ori	r24, 0x01	; 1
    2798:	80 83       	st	Z, r24
		cbi(ADCSRA, ADPS2);
		cbi(ADCSRA, ADPS1);
		sbi(ADCSRA, ADPS0);
	#endif
	// enable a2d conversions
	sbi(ADCSRA, ADEN);
    279a:	80 81       	ld	r24, Z
    279c:	80 68       	ori	r24, 0x80	; 128
    279e:	80 83       	st	Z, r24
	// here so they can be used as normal digital i/o; they will be
	// reconnected in Serial.begin()
#if defined(UCSRB)
	UCSRB = 0;
#elif defined(UCSR0B)
	UCSR0B = 0;
    27a0:	10 92 c1 00 	sts	0x00C1, r1	; 0x8000c1 <__DATA_REGION_ORIGIN__+0x61>
    27a4:	08 95       	ret

000027a6 <analogRead>:
#elif defined(__AVR_ATmega32U4__)
	if (pin >= 18) pin -= 18; // allow for channel or pin numbers
#elif defined(__AVR_ATmega1284__) || defined(__AVR_ATmega1284P__) || defined(__AVR_ATmega644__) || defined(__AVR_ATmega644A__) || defined(__AVR_ATmega644P__) || defined(__AVR_ATmega644PA__)
	if (pin >= 24) pin -= 24; // allow for channel or pin numbers
#else
	if (pin >= 14) pin -= 14; // allow for channel or pin numbers
    27a6:	8e 30       	cpi	r24, 0x0E	; 14
    27a8:	08 f0       	brcs	.+2      	; 0x27ac <analogRead+0x6>
    27aa:	8e 50       	subi	r24, 0x0E	; 14
	// to 0 (the default).
#if defined(ADMUX)
#if defined(__AVR_ATtiny25__) || defined(__AVR_ATtiny45__) || defined(__AVR_ATtiny85__)
	ADMUX = (analog_reference << 4) | (pin & 0x07);
#else
	ADMUX = (analog_reference << 6) | (pin & 0x07);
    27ac:	20 91 37 01 	lds	r18, 0x0137	; 0x800137 <analog_reference>
    27b0:	90 e4       	ldi	r25, 0x40	; 64
    27b2:	29 9f       	mul	r18, r25
    27b4:	90 01       	movw	r18, r0
    27b6:	11 24       	eor	r1, r1
    27b8:	87 70       	andi	r24, 0x07	; 7
    27ba:	82 2b       	or	r24, r18
    27bc:	80 93 7c 00 	sts	0x007C, r24	; 0x80007c <__DATA_REGION_ORIGIN__+0x1c>
	// without a delay, we seem to read from the wrong channel
	//delay(1);

#if defined(ADCSRA) && defined(ADCL)
	// start the conversion
	sbi(ADCSRA, ADSC);
    27c0:	80 91 7a 00 	lds	r24, 0x007A	; 0x80007a <__DATA_REGION_ORIGIN__+0x1a>
    27c4:	80 64       	ori	r24, 0x40	; 64
    27c6:	80 93 7a 00 	sts	0x007A, r24	; 0x80007a <__DATA_REGION_ORIGIN__+0x1a>

	// ADSC is cleared when the conversion finishes
	while (bit_is_set(ADCSRA, ADSC));
    27ca:	80 91 7a 00 	lds	r24, 0x007A	; 0x80007a <__DATA_REGION_ORIGIN__+0x1a>
    27ce:	86 fd       	sbrc	r24, 6
    27d0:	fc cf       	rjmp	.-8      	; 0x27ca <analogRead+0x24>

	// we have to read ADCL first; doing so locks both ADCL
	// and ADCH until ADCH is read.  reading ADCL second would
	// cause the results of each conversion to be discarded,
	// as ADCL and ADCH would be locked when it completed.
	low  = ADCL;
    27d2:	80 91 78 00 	lds	r24, 0x0078	; 0x800078 <__DATA_REGION_ORIGIN__+0x18>
	high = ADCH;
    27d6:	20 91 79 00 	lds	r18, 0x0079	; 0x800079 <__DATA_REGION_ORIGIN__+0x19>
	low  = 0;
	high = 0;
#endif

	// combine the two bytes
	return (high << 8) | low;
    27da:	90 e0       	ldi	r25, 0x00	; 0
}
    27dc:	92 2b       	or	r25, r18
    27de:	08 95       	ret

000027e0 <analogWrite>:
// Right now, PWM output only works on the pins with
// hardware support.  These are defined in the appropriate
// pins_*.c file.  For the rest of the pins, we default
// to digital output.
void analogWrite(uint8_t pin, int val)
{
    27e0:	1f 93       	push	r17
    27e2:	cf 93       	push	r28
    27e4:	df 93       	push	r29
    27e6:	18 2f       	mov	r17, r24
    27e8:	eb 01       	movw	r28, r22
	// We need to make sure the PWM output is enabled for those pins
	// that support it, as we turn it off when digitally reading or
	// writing with them.  Also, make sure the pin is in output mode
	// for consistenty with Wiring, which doesn't require a pinMode
	// call for the analog output pins.
	pinMode(pin, OUTPUT);
    27ea:	61 e0       	ldi	r22, 0x01	; 1
    27ec:	0e 94 78 14 	call	0x28f0	; 0x28f0 <pinMode>
	if (val == 0)
    27f0:	20 97       	sbiw	r28, 0x00	; 0
    27f2:	11 f4       	brne	.+4      	; 0x27f8 <analogWrite+0x18>
	{
		digitalWrite(pin, LOW);
    27f4:	60 e0       	ldi	r22, 0x00	; 0
    27f6:	04 c0       	rjmp	.+8      	; 0x2800 <analogWrite+0x20>
	}
	else if (val == 255)
    27f8:	cf 3f       	cpi	r28, 0xFF	; 255
    27fa:	d1 05       	cpc	r29, r1
    27fc:	39 f4       	brne	.+14     	; 0x280c <analogWrite+0x2c>
	{
		digitalWrite(pin, HIGH);
    27fe:	61 e0       	ldi	r22, 0x01	; 1
    2800:	81 2f       	mov	r24, r17
				} else {
					digitalWrite(pin, HIGH);
				}
		}
	}
}
    2802:	df 91       	pop	r29
    2804:	cf 91       	pop	r28
    2806:	1f 91       	pop	r17
	{
		digitalWrite(pin, LOW);
	}
	else if (val == 255)
	{
		digitalWrite(pin, HIGH);
    2808:	0c 94 b4 14 	jmp	0x2968	; 0x2968 <digitalWrite>
	}
	else
	{
		switch(digitalPinToTimer(pin))
    280c:	e1 2f       	mov	r30, r17
    280e:	f0 e0       	ldi	r31, 0x00	; 0
    2810:	ee 54       	subi	r30, 0x4E	; 78
    2812:	ff 4f       	sbci	r31, 0xFF	; 255
    2814:	e4 91       	lpm	r30, Z
    2816:	e3 30       	cpi	r30, 0x03	; 3
    2818:	f9 f0       	breq	.+62     	; 0x2858 <analogWrite+0x78>
    281a:	48 f4       	brcc	.+18     	; 0x282e <analogWrite+0x4e>
    281c:	e1 30       	cpi	r30, 0x01	; 1
    281e:	b9 f0       	breq	.+46     	; 0x284e <analogWrite+0x6e>
    2820:	e2 30       	cpi	r30, 0x02	; 2
    2822:	a1 f5       	brne	.+104    	; 0x288c <analogWrite+0xac>
			#endif

			#if defined(TCCR0A) && defined(COM0B1)
			case TIMER0B:
				// connect pwm to pin on timer 0, channel B
				sbi(TCCR0A, COM0B1);
    2824:	84 b5       	in	r24, 0x24	; 36
    2826:	80 62       	ori	r24, 0x20	; 32
    2828:	84 bd       	out	0x24, r24	; 36
				OCR0B = val; // set pwm duty
    282a:	c8 bd       	out	0x28, r28	; 40
				break;
    282c:	34 c0       	rjmp	.+104    	; 0x2896 <analogWrite+0xb6>
	{
		digitalWrite(pin, HIGH);
	}
	else
	{
		switch(digitalPinToTimer(pin))
    282e:	e7 30       	cpi	r30, 0x07	; 7
    2830:	e9 f0       	breq	.+58     	; 0x286c <analogWrite+0x8c>
    2832:	e8 30       	cpi	r30, 0x08	; 8
    2834:	19 f1       	breq	.+70     	; 0x287c <analogWrite+0x9c>
    2836:	e4 30       	cpi	r30, 0x04	; 4
    2838:	49 f5       	brne	.+82     	; 0x288c <analogWrite+0xac>
			#endif

			#if defined(TCCR1A) && defined(COM1B1)
			case TIMER1B:
				// connect pwm to pin on timer 1, channel B
				sbi(TCCR1A, COM1B1);
    283a:	80 91 80 00 	lds	r24, 0x0080	; 0x800080 <__DATA_REGION_ORIGIN__+0x20>
    283e:	80 62       	ori	r24, 0x20	; 32
    2840:	80 93 80 00 	sts	0x0080, r24	; 0x800080 <__DATA_REGION_ORIGIN__+0x20>
				OCR1B = val; // set pwm duty
    2844:	d0 93 8b 00 	sts	0x008B, r29	; 0x80008b <__DATA_REGION_ORIGIN__+0x2b>
    2848:	c0 93 8a 00 	sts	0x008A, r28	; 0x80008a <__DATA_REGION_ORIGIN__+0x2a>
				break;
    284c:	24 c0       	rjmp	.+72     	; 0x2896 <analogWrite+0xb6>
			#endif

			#if defined(TCCR0A) && defined(COM0A1)
			case TIMER0A:
				// connect pwm to pin on timer 0, channel A
				sbi(TCCR0A, COM0A1);
    284e:	84 b5       	in	r24, 0x24	; 36
    2850:	80 68       	ori	r24, 0x80	; 128
    2852:	84 bd       	out	0x24, r24	; 36
				OCR0A = val; // set pwm duty
    2854:	c7 bd       	out	0x27, r28	; 39
				break;
    2856:	1f c0       	rjmp	.+62     	; 0x2896 <analogWrite+0xb6>
			#endif

			#if defined(TCCR1A) && defined(COM1A1)
			case TIMER1A:
				// connect pwm to pin on timer 1, channel A
				sbi(TCCR1A, COM1A1);
    2858:	80 91 80 00 	lds	r24, 0x0080	; 0x800080 <__DATA_REGION_ORIGIN__+0x20>
    285c:	80 68       	ori	r24, 0x80	; 128
    285e:	80 93 80 00 	sts	0x0080, r24	; 0x800080 <__DATA_REGION_ORIGIN__+0x20>
				OCR1A = val; // set pwm duty
    2862:	d0 93 89 00 	sts	0x0089, r29	; 0x800089 <__DATA_REGION_ORIGIN__+0x29>
    2866:	c0 93 88 00 	sts	0x0088, r28	; 0x800088 <__DATA_REGION_ORIGIN__+0x28>
				break;
    286a:	15 c0       	rjmp	.+42     	; 0x2896 <analogWrite+0xb6>
			#endif

			#if defined(TCCR2A) && defined(COM2A1)
			case TIMER2A:
				// connect pwm to pin on timer 2, channel A
				sbi(TCCR2A, COM2A1);
    286c:	80 91 b0 00 	lds	r24, 0x00B0	; 0x8000b0 <__DATA_REGION_ORIGIN__+0x50>
    2870:	80 68       	ori	r24, 0x80	; 128
    2872:	80 93 b0 00 	sts	0x00B0, r24	; 0x8000b0 <__DATA_REGION_ORIGIN__+0x50>
				OCR2A = val; // set pwm duty
    2876:	c0 93 b3 00 	sts	0x00B3, r28	; 0x8000b3 <__DATA_REGION_ORIGIN__+0x53>
				break;
    287a:	0d c0       	rjmp	.+26     	; 0x2896 <analogWrite+0xb6>
			#endif

			#if defined(TCCR2A) && defined(COM2B1)
			case TIMER2B:
				// connect pwm to pin on timer 2, channel B
				sbi(TCCR2A, COM2B1);
    287c:	80 91 b0 00 	lds	r24, 0x00B0	; 0x8000b0 <__DATA_REGION_ORIGIN__+0x50>
    2880:	80 62       	ori	r24, 0x20	; 32
    2882:	80 93 b0 00 	sts	0x00B0, r24	; 0x8000b0 <__DATA_REGION_ORIGIN__+0x50>
				OCR2B = val; // set pwm duty
    2886:	c0 93 b4 00 	sts	0x00B4, r28	; 0x8000b4 <__DATA_REGION_ORIGIN__+0x54>
				break;
    288a:	05 c0       	rjmp	.+10     	; 0x2896 <analogWrite+0xb6>
				break;
			#endif

			case NOT_ON_TIMER:
			default:
				if (val < 128) {
    288c:	c0 38       	cpi	r28, 0x80	; 128
    288e:	d1 05       	cpc	r29, r1
    2890:	0c f0       	brlt	.+2      	; 0x2894 <analogWrite+0xb4>
    2892:	b5 cf       	rjmp	.-150    	; 0x27fe <analogWrite+0x1e>
    2894:	af cf       	rjmp	.-162    	; 0x27f4 <analogWrite+0x14>
				} else {
					digitalWrite(pin, HIGH);
				}
		}
	}
}
    2896:	df 91       	pop	r29
    2898:	cf 91       	pop	r28
    289a:	1f 91       	pop	r17
    289c:	08 95       	ret

0000289e <turnOffPWM>:
//
//static inline void turnOffPWM(uint8_t timer) __attribute__ ((always_inline));
//static inline void turnOffPWM(uint8_t timer)
static void turnOffPWM(uint8_t timer)
{
	switch (timer)
    289e:	83 30       	cpi	r24, 0x03	; 3
    28a0:	81 f0       	breq	.+32     	; 0x28c2 <turnOffPWM+0x24>
    28a2:	28 f4       	brcc	.+10     	; 0x28ae <turnOffPWM+0x10>
    28a4:	81 30       	cpi	r24, 0x01	; 1
    28a6:	99 f0       	breq	.+38     	; 0x28ce <turnOffPWM+0x30>
    28a8:	82 30       	cpi	r24, 0x02	; 2
    28aa:	a1 f0       	breq	.+40     	; 0x28d4 <turnOffPWM+0x36>
    28ac:	08 95       	ret
    28ae:	87 30       	cpi	r24, 0x07	; 7
    28b0:	a9 f0       	breq	.+42     	; 0x28dc <turnOffPWM+0x3e>
    28b2:	88 30       	cpi	r24, 0x08	; 8
    28b4:	b9 f0       	breq	.+46     	; 0x28e4 <turnOffPWM+0x46>
    28b6:	84 30       	cpi	r24, 0x04	; 4
    28b8:	d1 f4       	brne	.+52     	; 0x28ee <turnOffPWM+0x50>
	{
		#if defined(TCCR1A) && defined(COM1A1)
		case TIMER1A:   cbi(TCCR1A, COM1A1);    break;
		#endif
		#if defined(TCCR1A) && defined(COM1B1)
		case TIMER1B:   cbi(TCCR1A, COM1B1);    break;
    28ba:	80 91 80 00 	lds	r24, 0x0080	; 0x800080 <__DATA_REGION_ORIGIN__+0x20>
    28be:	8f 7d       	andi	r24, 0xDF	; 223
    28c0:	03 c0       	rjmp	.+6      	; 0x28c8 <turnOffPWM+0x2a>
static void turnOffPWM(uint8_t timer)
{
	switch (timer)
	{
		#if defined(TCCR1A) && defined(COM1A1)
		case TIMER1A:   cbi(TCCR1A, COM1A1);    break;
    28c2:	80 91 80 00 	lds	r24, 0x0080	; 0x800080 <__DATA_REGION_ORIGIN__+0x20>
    28c6:	8f 77       	andi	r24, 0x7F	; 127
		#endif
		#if defined(TCCR1A) && defined(COM1B1)
		case TIMER1B:   cbi(TCCR1A, COM1B1);    break;
    28c8:	80 93 80 00 	sts	0x0080, r24	; 0x800080 <__DATA_REGION_ORIGIN__+0x20>
    28cc:	08 95       	ret
		#if defined(TCCR2) && defined(COM21)
		case  TIMER2:   cbi(TCCR2, COM21);      break;
		#endif
		
		#if defined(TCCR0A) && defined(COM0A1)
		case  TIMER0A:  cbi(TCCR0A, COM0A1);    break;
    28ce:	84 b5       	in	r24, 0x24	; 36
    28d0:	8f 77       	andi	r24, 0x7F	; 127
    28d2:	02 c0       	rjmp	.+4      	; 0x28d8 <turnOffPWM+0x3a>
		#endif
		
		#if defined(TCCR0A) && defined(COM0B1)
		case  TIMER0B:  cbi(TCCR0A, COM0B1);    break;
    28d4:	84 b5       	in	r24, 0x24	; 36
    28d6:	8f 7d       	andi	r24, 0xDF	; 223
    28d8:	84 bd       	out	0x24, r24	; 36
    28da:	08 95       	ret
		#endif
		#if defined(TCCR2A) && defined(COM2A1)
		case  TIMER2A:  cbi(TCCR2A, COM2A1);    break;
    28dc:	80 91 b0 00 	lds	r24, 0x00B0	; 0x8000b0 <__DATA_REGION_ORIGIN__+0x50>
    28e0:	8f 77       	andi	r24, 0x7F	; 127
    28e2:	03 c0       	rjmp	.+6      	; 0x28ea <turnOffPWM+0x4c>
		#endif
		#if defined(TCCR2A) && defined(COM2B1)
		case  TIMER2B:  cbi(TCCR2A, COM2B1);    break;
    28e4:	80 91 b0 00 	lds	r24, 0x00B0	; 0x8000b0 <__DATA_REGION_ORIGIN__+0x50>
    28e8:	8f 7d       	andi	r24, 0xDF	; 223
    28ea:	80 93 b0 00 	sts	0x00B0, r24	; 0x8000b0 <__DATA_REGION_ORIGIN__+0x50>
    28ee:	08 95       	ret

000028f0 <pinMode>:
#define ARDUINO_MAIN
#include "wiring_private.h"
#include "pins_arduino.h"

void pinMode(uint8_t pin, uint8_t mode)
{
    28f0:	cf 93       	push	r28
    28f2:	df 93       	push	r29
	uint8_t bit = digitalPinToBitMask(pin);
    28f4:	90 e0       	ldi	r25, 0x00	; 0
    28f6:	fc 01       	movw	r30, r24
    28f8:	ea 53       	subi	r30, 0x3A	; 58
    28fa:	ff 4f       	sbci	r31, 0xFF	; 255
    28fc:	24 91       	lpm	r18, Z
	uint8_t port = digitalPinToPort(pin);
    28fe:	fc 01       	movw	r30, r24
    2900:	e6 52       	subi	r30, 0x26	; 38
    2902:	ff 4f       	sbci	r31, 0xFF	; 255
    2904:	84 91       	lpm	r24, Z
	volatile uint8_t *reg, *out;

	if (port == NOT_A_PIN) return;
    2906:	88 23       	and	r24, r24
    2908:	61 f1       	breq	.+88     	; 0x2962 <pinMode+0x72>

	// JWS: can I let the optimizer do this?
	reg = portModeRegister(port);
    290a:	90 e0       	ldi	r25, 0x00	; 0
    290c:	88 0f       	add	r24, r24
    290e:	99 1f       	adc	r25, r25
    2910:	fc 01       	movw	r30, r24
    2912:	ee 5f       	subi	r30, 0xFE	; 254
    2914:	fe 4f       	sbci	r31, 0xFE	; 254
    2916:	c5 91       	lpm	r28, Z+
    2918:	d4 91       	lpm	r29, Z
	out = portOutputRegister(port);
    291a:	fc 01       	movw	r30, r24
    291c:	e8 50       	subi	r30, 0x08	; 8
    291e:	ff 4f       	sbci	r31, 0xFF	; 255
    2920:	a5 91       	lpm	r26, Z+
    2922:	b4 91       	lpm	r27, Z

	if (mode == INPUT) { 
    2924:	61 11       	cpse	r22, r1
    2926:	09 c0       	rjmp	.+18     	; 0x293a <pinMode+0x4a>
		uint8_t oldSREG = SREG;
    2928:	9f b7       	in	r25, 0x3f	; 63
                cli();
    292a:	f8 94       	cli
		*reg &= ~bit;
    292c:	88 81       	ld	r24, Y
    292e:	20 95       	com	r18
    2930:	82 23       	and	r24, r18
    2932:	88 83       	st	Y, r24
		*out &= ~bit;
    2934:	ec 91       	ld	r30, X
    2936:	2e 23       	and	r18, r30
    2938:	0b c0       	rjmp	.+22     	; 0x2950 <pinMode+0x60>
		SREG = oldSREG;
	} else if (mode == INPUT_PULLUP) {
    293a:	62 30       	cpi	r22, 0x02	; 2
    293c:	61 f4       	brne	.+24     	; 0x2956 <pinMode+0x66>
		uint8_t oldSREG = SREG;
    293e:	9f b7       	in	r25, 0x3f	; 63
                cli();
    2940:	f8 94       	cli
		*reg &= ~bit;
    2942:	88 81       	ld	r24, Y
    2944:	32 2f       	mov	r19, r18
    2946:	30 95       	com	r19
    2948:	83 23       	and	r24, r19
    294a:	88 83       	st	Y, r24
		*out |= bit;
    294c:	ec 91       	ld	r30, X
    294e:	2e 2b       	or	r18, r30
    2950:	2c 93       	st	X, r18
		SREG = oldSREG;
    2952:	9f bf       	out	0x3f, r25	; 63
    2954:	06 c0       	rjmp	.+12     	; 0x2962 <pinMode+0x72>
	} else {
		uint8_t oldSREG = SREG;
    2956:	8f b7       	in	r24, 0x3f	; 63
                cli();
    2958:	f8 94       	cli
		*reg |= bit;
    295a:	e8 81       	ld	r30, Y
    295c:	2e 2b       	or	r18, r30
    295e:	28 83       	st	Y, r18
		SREG = oldSREG;
    2960:	8f bf       	out	0x3f, r24	; 63
	}
}
    2962:	df 91       	pop	r29
    2964:	cf 91       	pop	r28
    2966:	08 95       	ret

00002968 <digitalWrite>:
		#endif
	}
}

void digitalWrite(uint8_t pin, uint8_t val)
{
    2968:	1f 93       	push	r17
    296a:	cf 93       	push	r28
    296c:	df 93       	push	r29
	uint8_t timer = digitalPinToTimer(pin);
    296e:	28 2f       	mov	r18, r24
    2970:	30 e0       	ldi	r19, 0x00	; 0
    2972:	f9 01       	movw	r30, r18
    2974:	ee 54       	subi	r30, 0x4E	; 78
    2976:	ff 4f       	sbci	r31, 0xFF	; 255
    2978:	84 91       	lpm	r24, Z
	uint8_t bit = digitalPinToBitMask(pin);
    297a:	f9 01       	movw	r30, r18
    297c:	ea 53       	subi	r30, 0x3A	; 58
    297e:	ff 4f       	sbci	r31, 0xFF	; 255
    2980:	d4 91       	lpm	r29, Z
	uint8_t port = digitalPinToPort(pin);
    2982:	f9 01       	movw	r30, r18
    2984:	e6 52       	subi	r30, 0x26	; 38
    2986:	ff 4f       	sbci	r31, 0xFF	; 255
    2988:	c4 91       	lpm	r28, Z
	volatile uint8_t *out;

	if (port == NOT_A_PIN) return;
    298a:	cc 23       	and	r28, r28
    298c:	c1 f0       	breq	.+48     	; 0x29be <digitalWrite+0x56>
    298e:	16 2f       	mov	r17, r22

	// If the pin that support PWM output, we need to turn it off
	// before doing a digital write.
	if (timer != NOT_ON_TIMER) turnOffPWM(timer);
    2990:	81 11       	cpse	r24, r1
    2992:	0e 94 4f 14 	call	0x289e	; 0x289e <turnOffPWM>

	out = portOutputRegister(port);
    2996:	ec 2f       	mov	r30, r28
    2998:	f0 e0       	ldi	r31, 0x00	; 0
    299a:	ee 0f       	add	r30, r30
    299c:	ff 1f       	adc	r31, r31
    299e:	e8 50       	subi	r30, 0x08	; 8
    29a0:	ff 4f       	sbci	r31, 0xFF	; 255
    29a2:	a5 91       	lpm	r26, Z+
    29a4:	b4 91       	lpm	r27, Z

	uint8_t oldSREG = SREG;
    29a6:	9f b7       	in	r25, 0x3f	; 63
	cli();
    29a8:	f8 94       	cli

	if (val == LOW) {
    29aa:	11 11       	cpse	r17, r1
    29ac:	04 c0       	rjmp	.+8      	; 0x29b6 <digitalWrite+0x4e>
		*out &= ~bit;
    29ae:	8c 91       	ld	r24, X
    29b0:	d0 95       	com	r29
    29b2:	d8 23       	and	r29, r24
    29b4:	02 c0       	rjmp	.+4      	; 0x29ba <digitalWrite+0x52>
	} else {
		*out |= bit;
    29b6:	ec 91       	ld	r30, X
    29b8:	de 2b       	or	r29, r30
    29ba:	dc 93       	st	X, r29
	}

	SREG = oldSREG;
    29bc:	9f bf       	out	0x3f, r25	; 63
}
    29be:	df 91       	pop	r29
    29c0:	cf 91       	pop	r28
    29c2:	1f 91       	pop	r17
    29c4:	08 95       	ret

000029c6 <prvResetNextTaskUnblockTime>:
        {
            mtCOVERAGE_TEST_MARKER();
        }

        return xReturn;
    }
    29c6:	e0 91 8a 04 	lds	r30, 0x048A	; 0x80048a <pxDelayedTaskList>
    29ca:	f0 91 8b 04 	lds	r31, 0x048B	; 0x80048b <pxDelayedTaskList+0x1>
    29ce:	80 81       	ld	r24, Z
    29d0:	81 11       	cpse	r24, r1
    29d2:	03 c0       	rjmp	.+6      	; 0x29da <prvResetNextTaskUnblockTime+0x14>
    29d4:	8f ef       	ldi	r24, 0xFF	; 255
    29d6:	9f ef       	ldi	r25, 0xFF	; 255
    29d8:	0c c0       	rjmp	.+24     	; 0x29f2 <prvResetNextTaskUnblockTime+0x2c>
    29da:	e0 91 8a 04 	lds	r30, 0x048A	; 0x80048a <pxDelayedTaskList>
    29de:	f0 91 8b 04 	lds	r31, 0x048B	; 0x80048b <pxDelayedTaskList+0x1>
    29e2:	05 80       	ldd	r0, Z+5	; 0x05
    29e4:	f6 81       	ldd	r31, Z+6	; 0x06
    29e6:	e0 2d       	mov	r30, r0
    29e8:	06 80       	ldd	r0, Z+6	; 0x06
    29ea:	f7 81       	ldd	r31, Z+7	; 0x07
    29ec:	e0 2d       	mov	r30, r0
    29ee:	82 81       	ldd	r24, Z+2	; 0x02
    29f0:	93 81       	ldd	r25, Z+3	; 0x03
    29f2:	90 93 62 04 	sts	0x0462, r25	; 0x800462 <xNextTaskUnblockTime+0x1>
    29f6:	80 93 61 04 	sts	0x0461, r24	; 0x800461 <xNextTaskUnblockTime>
    29fa:	08 95       	ret

000029fc <prvAddCurrentTaskToDelayedList>:
    29fc:	ff 92       	push	r15
    29fe:	0f 93       	push	r16
    2a00:	1f 93       	push	r17
    2a02:	cf 93       	push	r28
    2a04:	df 93       	push	r29
    2a06:	ec 01       	movw	r28, r24
    2a08:	f6 2e       	mov	r15, r22
    2a0a:	00 91 69 04 	lds	r16, 0x0469	; 0x800469 <xTickCount>
    2a0e:	10 91 6a 04 	lds	r17, 0x046A	; 0x80046a <xTickCount+0x1>
    2a12:	80 91 c2 04 	lds	r24, 0x04C2	; 0x8004c2 <pxCurrentTCB>
    2a16:	90 91 c3 04 	lds	r25, 0x04C3	; 0x8004c3 <pxCurrentTCB+0x1>
    2a1a:	02 96       	adiw	r24, 0x02	; 2
    2a1c:	0e 94 93 1d 	call	0x3b26	; 0x3b26 <uxListRemove>
    2a20:	cf 3f       	cpi	r28, 0xFF	; 255
    2a22:	8f ef       	ldi	r24, 0xFF	; 255
    2a24:	d8 07       	cpc	r29, r24
    2a26:	89 f4       	brne	.+34     	; 0x2a4a <prvAddCurrentTaskToDelayedList+0x4e>
    2a28:	ff 20       	and	r15, r15
    2a2a:	79 f0       	breq	.+30     	; 0x2a4a <prvAddCurrentTaskToDelayedList+0x4e>
    2a2c:	60 91 c2 04 	lds	r22, 0x04C2	; 0x8004c2 <pxCurrentTCB>
    2a30:	70 91 c3 04 	lds	r23, 0x04C3	; 0x8004c3 <pxCurrentTCB+0x1>
    2a34:	6e 5f       	subi	r22, 0xFE	; 254
    2a36:	7f 4f       	sbci	r23, 0xFF	; 255
    2a38:	8c e6       	ldi	r24, 0x6C	; 108
    2a3a:	94 e0       	ldi	r25, 0x04	; 4
    2a3c:	df 91       	pop	r29
    2a3e:	cf 91       	pop	r28
    2a40:	1f 91       	pop	r17
    2a42:	0f 91       	pop	r16
    2a44:	ff 90       	pop	r15
    2a46:	0c 94 3a 1d 	jmp	0x3a74	; 0x3a74 <vListInsertEnd>
    2a4a:	c0 0f       	add	r28, r16
    2a4c:	d1 1f       	adc	r29, r17
    2a4e:	e0 91 c2 04 	lds	r30, 0x04C2	; 0x8004c2 <pxCurrentTCB>
    2a52:	f0 91 c3 04 	lds	r31, 0x04C3	; 0x8004c3 <pxCurrentTCB+0x1>
    2a56:	d3 83       	std	Z+3, r29	; 0x03
    2a58:	c2 83       	std	Z+2, r28	; 0x02
    2a5a:	60 91 c2 04 	lds	r22, 0x04C2	; 0x8004c2 <pxCurrentTCB>
    2a5e:	70 91 c3 04 	lds	r23, 0x04C3	; 0x8004c3 <pxCurrentTCB+0x1>
    2a62:	c0 17       	cp	r28, r16
    2a64:	d1 07       	cpc	r29, r17
    2a66:	68 f4       	brcc	.+26     	; 0x2a82 <prvAddCurrentTaskToDelayedList+0x86>
    2a68:	80 91 88 04 	lds	r24, 0x0488	; 0x800488 <pxOverflowDelayedTaskList>
    2a6c:	90 91 89 04 	lds	r25, 0x0489	; 0x800489 <pxOverflowDelayedTaskList+0x1>
    2a70:	6e 5f       	subi	r22, 0xFE	; 254
    2a72:	7f 4f       	sbci	r23, 0xFF	; 255
    2a74:	df 91       	pop	r29
    2a76:	cf 91       	pop	r28
    2a78:	1f 91       	pop	r17
    2a7a:	0f 91       	pop	r16
    2a7c:	ff 90       	pop	r15
    2a7e:	0c 94 5b 1d 	jmp	0x3ab6	; 0x3ab6 <vListInsert>
    2a82:	80 91 8a 04 	lds	r24, 0x048A	; 0x80048a <pxDelayedTaskList>
    2a86:	90 91 8b 04 	lds	r25, 0x048B	; 0x80048b <pxDelayedTaskList+0x1>
    2a8a:	6e 5f       	subi	r22, 0xFE	; 254
    2a8c:	7f 4f       	sbci	r23, 0xFF	; 255
    2a8e:	0e 94 5b 1d 	call	0x3ab6	; 0x3ab6 <vListInsert>
    2a92:	80 91 61 04 	lds	r24, 0x0461	; 0x800461 <xNextTaskUnblockTime>
    2a96:	90 91 62 04 	lds	r25, 0x0462	; 0x800462 <xNextTaskUnblockTime+0x1>
    2a9a:	c8 17       	cp	r28, r24
    2a9c:	d9 07       	cpc	r29, r25
    2a9e:	20 f4       	brcc	.+8      	; 0x2aa8 <prvAddCurrentTaskToDelayedList+0xac>
    2aa0:	d0 93 62 04 	sts	0x0462, r29	; 0x800462 <xNextTaskUnblockTime+0x1>
    2aa4:	c0 93 61 04 	sts	0x0461, r28	; 0x800461 <xNextTaskUnblockTime>
    2aa8:	df 91       	pop	r29
    2aaa:	cf 91       	pop	r28
    2aac:	1f 91       	pop	r17
    2aae:	0f 91       	pop	r16
    2ab0:	ff 90       	pop	r15
    2ab2:	08 95       	ret

00002ab4 <prvIdleTask>:
    2ab4:	80 91 75 04 	lds	r24, 0x0475	; 0x800475 <uxDeletedTasksWaitingCleanUp>
    2ab8:	88 23       	and	r24, r24
    2aba:	09 f1       	breq	.+66     	; 0x2afe <prvIdleTask+0x4a>
    2abc:	0f b6       	in	r0, 0x3f	; 63
    2abe:	f8 94       	cli
    2ac0:	0f 92       	push	r0
    2ac2:	e0 91 7b 04 	lds	r30, 0x047B	; 0x80047b <xTasksWaitingTermination+0x5>
    2ac6:	f0 91 7c 04 	lds	r31, 0x047C	; 0x80047c <xTasksWaitingTermination+0x6>
    2aca:	c6 81       	ldd	r28, Z+6	; 0x06
    2acc:	d7 81       	ldd	r29, Z+7	; 0x07
    2ace:	ce 01       	movw	r24, r28
    2ad0:	02 96       	adiw	r24, 0x02	; 2
    2ad2:	0e 94 93 1d 	call	0x3b26	; 0x3b26 <uxListRemove>
    2ad6:	80 91 6b 04 	lds	r24, 0x046B	; 0x80046b <uxCurrentNumberOfTasks>
    2ada:	81 50       	subi	r24, 0x01	; 1
    2adc:	80 93 6b 04 	sts	0x046B, r24	; 0x80046b <uxCurrentNumberOfTasks>
    2ae0:	80 91 75 04 	lds	r24, 0x0475	; 0x800475 <uxDeletedTasksWaitingCleanUp>
    2ae4:	81 50       	subi	r24, 0x01	; 1
    2ae6:	80 93 75 04 	sts	0x0475, r24	; 0x800475 <uxDeletedTasksWaitingCleanUp>
    2aea:	0f 90       	pop	r0
    2aec:	0f be       	out	0x3f, r0	; 63
    2aee:	8f 89       	ldd	r24, Y+23	; 0x17
    2af0:	98 8d       	ldd	r25, Y+24	; 0x18
    2af2:	0e 94 17 1d 	call	0x3a2e	; 0x3a2e <vPortFree>
    2af6:	ce 01       	movw	r24, r28
    2af8:	0e 94 17 1d 	call	0x3a2e	; 0x3a2e <vPortFree>
    2afc:	db cf       	rjmp	.-74     	; 0x2ab4 <prvIdleTask>
    2afe:	80 91 9e 04 	lds	r24, 0x049E	; 0x80049e <pxReadyTasksLists>
    2b02:	82 30       	cpi	r24, 0x02	; 2
    2b04:	10 f0       	brcs	.+4      	; 0x2b0a <prvIdleTask+0x56>
    2b06:	0e 94 5b 1e 	call	0x3cb6	; 0x3cb6 <vPortYield>
    2b0a:	0e 94 ca 1b 	call	0x3794	; 0x3794 <vApplicationIdleHook>
    2b0e:	d2 cf       	rjmp	.-92     	; 0x2ab4 <prvIdleTask>

00002b10 <xTaskCreate>:
    2b10:	5f 92       	push	r5
    2b12:	6f 92       	push	r6
    2b14:	7f 92       	push	r7
    2b16:	8f 92       	push	r8
    2b18:	9f 92       	push	r9
    2b1a:	af 92       	push	r10
    2b1c:	bf 92       	push	r11
    2b1e:	cf 92       	push	r12
    2b20:	df 92       	push	r13
    2b22:	ef 92       	push	r14
    2b24:	ff 92       	push	r15
    2b26:	0f 93       	push	r16
    2b28:	1f 93       	push	r17
    2b2a:	cf 93       	push	r28
    2b2c:	df 93       	push	r29
    2b2e:	3c 01       	movw	r6, r24
    2b30:	6b 01       	movw	r12, r22
    2b32:	5a 01       	movw	r10, r20
    2b34:	49 01       	movw	r8, r18
    2b36:	50 2e       	mov	r5, r16
    2b38:	ca 01       	movw	r24, r20
    2b3a:	0e 94 04 1d 	call	0x3a08	; 0x3a08 <pvPortMalloc>
    2b3e:	8c 01       	movw	r16, r24
    2b40:	89 2b       	or	r24, r25
    2b42:	09 f4       	brne	.+2      	; 0x2b46 <xTaskCreate+0x36>
    2b44:	e0 c0       	rjmp	.+448    	; 0x2d06 <xTaskCreate+0x1f6>
    2b46:	88 e2       	ldi	r24, 0x28	; 40
    2b48:	90 e0       	ldi	r25, 0x00	; 0
    2b4a:	0e 94 04 1d 	call	0x3a08	; 0x3a08 <pvPortMalloc>
    2b4e:	ec 01       	movw	r28, r24
    2b50:	89 2b       	or	r24, r25
    2b52:	c9 f0       	breq	.+50     	; 0x2b86 <xTaskCreate+0x76>
    2b54:	18 8f       	std	Y+24, r17	; 0x18
    2b56:	0f 8b       	std	Y+23, r16	; 0x17
    2b58:	a5 01       	movw	r20, r10
    2b5a:	65 ea       	ldi	r22, 0xA5	; 165
    2b5c:	70 e0       	ldi	r23, 0x00	; 0
    2b5e:	c8 01       	movw	r24, r16
    2b60:	0e 94 5c 23 	call	0x46b8	; 0x46b8 <memset>
    2b64:	21 e0       	ldi	r18, 0x01	; 1
    2b66:	a2 1a       	sub	r10, r18
    2b68:	b1 08       	sbc	r11, r1
    2b6a:	8f 89       	ldd	r24, Y+23	; 0x17
    2b6c:	98 8d       	ldd	r25, Y+24	; 0x18
    2b6e:	a8 0e       	add	r10, r24
    2b70:	b9 1e       	adc	r11, r25
    2b72:	c1 14       	cp	r12, r1
    2b74:	d1 04       	cpc	r13, r1
    2b76:	c9 f0       	breq	.+50     	; 0x2baa <xTaskCreate+0x9a>
    2b78:	be 01       	movw	r22, r28
    2b7a:	67 5e       	subi	r22, 0xE7	; 231
    2b7c:	7f 4f       	sbci	r23, 0xFF	; 255
    2b7e:	f6 01       	movw	r30, r12
    2b80:	c6 01       	movw	r24, r12
    2b82:	08 96       	adiw	r24, 0x08	; 8
    2b84:	07 c0       	rjmp	.+14     	; 0x2b94 <xTaskCreate+0x84>
    2b86:	c8 01       	movw	r24, r16
    2b88:	0e 94 17 1d 	call	0x3a2e	; 0x3a2e <vPortFree>
    2b8c:	bc c0       	rjmp	.+376    	; 0x2d06 <xTaskCreate+0x1f6>
    2b8e:	e8 17       	cp	r30, r24
    2b90:	f9 07       	cpc	r31, r25
    2b92:	49 f0       	breq	.+18     	; 0x2ba6 <xTaskCreate+0x96>
    2b94:	9f 01       	movw	r18, r30
    2b96:	41 91       	ld	r20, Z+
    2b98:	db 01       	movw	r26, r22
    2b9a:	4d 93       	st	X+, r20
    2b9c:	bd 01       	movw	r22, r26
    2b9e:	d9 01       	movw	r26, r18
    2ba0:	2c 91       	ld	r18, X
    2ba2:	21 11       	cpse	r18, r1
    2ba4:	f4 cf       	rjmp	.-24     	; 0x2b8e <xTaskCreate+0x7e>
    2ba6:	18 a2       	std	Y+32, r1	; 0x20
    2ba8:	01 c0       	rjmp	.+2      	; 0x2bac <xTaskCreate+0x9c>
    2baa:	19 8e       	std	Y+25, r1	; 0x19
    2bac:	05 2d       	mov	r16, r5
    2bae:	04 30       	cpi	r16, 0x04	; 4
    2bb0:	08 f0       	brcs	.+2      	; 0x2bb4 <xTaskCreate+0xa4>
    2bb2:	03 e0       	ldi	r16, 0x03	; 3
    2bb4:	0e 8b       	std	Y+22, r16	; 0x16
    2bb6:	09 a3       	std	Y+33, r16	; 0x21
    2bb8:	1a a2       	std	Y+34, r1	; 0x22
    2bba:	6e 01       	movw	r12, r28
    2bbc:	b2 e0       	ldi	r27, 0x02	; 2
    2bbe:	cb 0e       	add	r12, r27
    2bc0:	d1 1c       	adc	r13, r1
    2bc2:	c6 01       	movw	r24, r12
    2bc4:	0e 94 36 1d 	call	0x3a6c	; 0x3a6c <vListInitialiseItem>
    2bc8:	ce 01       	movw	r24, r28
    2bca:	0c 96       	adiw	r24, 0x0c	; 12
    2bcc:	0e 94 36 1d 	call	0x3a6c	; 0x3a6c <vListInitialiseItem>
    2bd0:	d9 87       	std	Y+9, r29	; 0x09
    2bd2:	c8 87       	std	Y+8, r28	; 0x08
    2bd4:	84 e0       	ldi	r24, 0x04	; 4
    2bd6:	90 e0       	ldi	r25, 0x00	; 0
    2bd8:	80 1b       	sub	r24, r16
    2bda:	91 09       	sbc	r25, r1
    2bdc:	9d 87       	std	Y+13, r25	; 0x0d
    2bde:	8c 87       	std	Y+12, r24	; 0x0c
    2be0:	db 8b       	std	Y+19, r29	; 0x13
    2be2:	ca 8b       	std	Y+18, r28	; 0x12
    2be4:	1b a2       	std	Y+35, r1	; 0x23
    2be6:	1c a2       	std	Y+36, r1	; 0x24
    2be8:	1d a2       	std	Y+37, r1	; 0x25
    2bea:	1e a2       	std	Y+38, r1	; 0x26
    2bec:	1f a2       	std	Y+39, r1	; 0x27
    2bee:	a4 01       	movw	r20, r8
    2bf0:	b3 01       	movw	r22, r6
    2bf2:	c5 01       	movw	r24, r10
    2bf4:	0e 94 b7 1d 	call	0x3b6e	; 0x3b6e <pxPortInitialiseStack>
    2bf8:	99 83       	std	Y+1, r25	; 0x01
    2bfa:	88 83       	st	Y, r24
    2bfc:	e1 14       	cp	r14, r1
    2bfe:	f1 04       	cpc	r15, r1
    2c00:	19 f0       	breq	.+6      	; 0x2c08 <xTaskCreate+0xf8>
    2c02:	f7 01       	movw	r30, r14
    2c04:	d1 83       	std	Z+1, r29	; 0x01
    2c06:	c0 83       	st	Z, r28
    2c08:	0f b6       	in	r0, 0x3f	; 63
    2c0a:	f8 94       	cli
    2c0c:	0f 92       	push	r0
    2c0e:	80 91 6b 04 	lds	r24, 0x046B	; 0x80046b <uxCurrentNumberOfTasks>
    2c12:	8f 5f       	subi	r24, 0xFF	; 255
    2c14:	80 93 6b 04 	sts	0x046B, r24	; 0x80046b <uxCurrentNumberOfTasks>
    2c18:	80 91 c2 04 	lds	r24, 0x04C2	; 0x8004c2 <pxCurrentTCB>
    2c1c:	90 91 c3 04 	lds	r25, 0x04C3	; 0x8004c3 <pxCurrentTCB+0x1>
    2c20:	89 2b       	or	r24, r25
    2c22:	d1 f5       	brne	.+116    	; 0x2c98 <xTaskCreate+0x188>
    2c24:	d0 93 c3 04 	sts	0x04C3, r29	; 0x8004c3 <pxCurrentTCB+0x1>
    2c28:	c0 93 c2 04 	sts	0x04C2, r28	; 0x8004c2 <pxCurrentTCB>
    2c2c:	80 91 6b 04 	lds	r24, 0x046B	; 0x80046b <uxCurrentNumberOfTasks>
    2c30:	81 30       	cpi	r24, 0x01	; 1
    2c32:	09 f0       	breq	.+2      	; 0x2c36 <xTaskCreate+0x126>
    2c34:	41 c0       	rjmp	.+130    	; 0x2cb8 <xTaskCreate+0x1a8>
    2c36:	8e e9       	ldi	r24, 0x9E	; 158
    2c38:	94 e0       	ldi	r25, 0x04	; 4
    2c3a:	0e 94 28 1d 	call	0x3a50	; 0x3a50 <vListInitialise>
    2c3e:	87 ea       	ldi	r24, 0xA7	; 167
    2c40:	94 e0       	ldi	r25, 0x04	; 4
    2c42:	0e 94 28 1d 	call	0x3a50	; 0x3a50 <vListInitialise>
    2c46:	80 eb       	ldi	r24, 0xB0	; 176
    2c48:	94 e0       	ldi	r25, 0x04	; 4
    2c4a:	0e 94 28 1d 	call	0x3a50	; 0x3a50 <vListInitialise>
    2c4e:	89 eb       	ldi	r24, 0xB9	; 185
    2c50:	94 e0       	ldi	r25, 0x04	; 4
    2c52:	0e 94 28 1d 	call	0x3a50	; 0x3a50 <vListInitialise>
    2c56:	85 e9       	ldi	r24, 0x95	; 149
    2c58:	94 e0       	ldi	r25, 0x04	; 4
    2c5a:	0e 94 28 1d 	call	0x3a50	; 0x3a50 <vListInitialise>
    2c5e:	8c e8       	ldi	r24, 0x8C	; 140
    2c60:	94 e0       	ldi	r25, 0x04	; 4
    2c62:	0e 94 28 1d 	call	0x3a50	; 0x3a50 <vListInitialise>
    2c66:	8f e7       	ldi	r24, 0x7F	; 127
    2c68:	94 e0       	ldi	r25, 0x04	; 4
    2c6a:	0e 94 28 1d 	call	0x3a50	; 0x3a50 <vListInitialise>
    2c6e:	86 e7       	ldi	r24, 0x76	; 118
    2c70:	94 e0       	ldi	r25, 0x04	; 4
    2c72:	0e 94 28 1d 	call	0x3a50	; 0x3a50 <vListInitialise>
    2c76:	8c e6       	ldi	r24, 0x6C	; 108
    2c78:	94 e0       	ldi	r25, 0x04	; 4
    2c7a:	0e 94 28 1d 	call	0x3a50	; 0x3a50 <vListInitialise>
    2c7e:	85 e9       	ldi	r24, 0x95	; 149
    2c80:	94 e0       	ldi	r25, 0x04	; 4
    2c82:	90 93 8b 04 	sts	0x048B, r25	; 0x80048b <pxDelayedTaskList+0x1>
    2c86:	80 93 8a 04 	sts	0x048A, r24	; 0x80048a <pxDelayedTaskList>
    2c8a:	8c e8       	ldi	r24, 0x8C	; 140
    2c8c:	94 e0       	ldi	r25, 0x04	; 4
    2c8e:	90 93 89 04 	sts	0x0489, r25	; 0x800489 <pxOverflowDelayedTaskList+0x1>
    2c92:	80 93 88 04 	sts	0x0488, r24	; 0x800488 <pxOverflowDelayedTaskList>
    2c96:	10 c0       	rjmp	.+32     	; 0x2cb8 <xTaskCreate+0x1a8>
    2c98:	80 91 67 04 	lds	r24, 0x0467	; 0x800467 <xSchedulerRunning>
    2c9c:	81 11       	cpse	r24, r1
    2c9e:	0c c0       	rjmp	.+24     	; 0x2cb8 <xTaskCreate+0x1a8>
    2ca0:	e0 91 c2 04 	lds	r30, 0x04C2	; 0x8004c2 <pxCurrentTCB>
    2ca4:	f0 91 c3 04 	lds	r31, 0x04C3	; 0x8004c3 <pxCurrentTCB+0x1>
    2ca8:	96 89       	ldd	r25, Z+22	; 0x16
    2caa:	8e 89       	ldd	r24, Y+22	; 0x16
    2cac:	89 17       	cp	r24, r25
    2cae:	20 f0       	brcs	.+8      	; 0x2cb8 <xTaskCreate+0x1a8>
    2cb0:	d0 93 c3 04 	sts	0x04C3, r29	; 0x8004c3 <pxCurrentTCB+0x1>
    2cb4:	c0 93 c2 04 	sts	0x04C2, r28	; 0x8004c2 <pxCurrentTCB>
    2cb8:	80 91 63 04 	lds	r24, 0x0463	; 0x800463 <uxTaskNumber>
    2cbc:	8f 5f       	subi	r24, 0xFF	; 255
    2cbe:	80 93 63 04 	sts	0x0463, r24	; 0x800463 <uxTaskNumber>
    2cc2:	8e 89       	ldd	r24, Y+22	; 0x16
    2cc4:	90 91 68 04 	lds	r25, 0x0468	; 0x800468 <uxTopReadyPriority>
    2cc8:	98 17       	cp	r25, r24
    2cca:	10 f4       	brcc	.+4      	; 0x2cd0 <xTaskCreate+0x1c0>
    2ccc:	80 93 68 04 	sts	0x0468, r24	; 0x800468 <uxTopReadyPriority>
    2cd0:	f9 e0       	ldi	r31, 0x09	; 9
    2cd2:	8f 9f       	mul	r24, r31
    2cd4:	c0 01       	movw	r24, r0
    2cd6:	11 24       	eor	r1, r1
    2cd8:	b6 01       	movw	r22, r12
    2cda:	82 56       	subi	r24, 0x62	; 98
    2cdc:	9b 4f       	sbci	r25, 0xFB	; 251
    2cde:	0e 94 3a 1d 	call	0x3a74	; 0x3a74 <vListInsertEnd>
    2ce2:	0f 90       	pop	r0
    2ce4:	0f be       	out	0x3f, r0	; 63
    2ce6:	80 91 67 04 	lds	r24, 0x0467	; 0x800467 <xSchedulerRunning>
    2cea:	88 23       	and	r24, r24
    2cec:	51 f0       	breq	.+20     	; 0x2d02 <xTaskCreate+0x1f2>
    2cee:	e0 91 c2 04 	lds	r30, 0x04C2	; 0x8004c2 <pxCurrentTCB>
    2cf2:	f0 91 c3 04 	lds	r31, 0x04C3	; 0x8004c3 <pxCurrentTCB+0x1>
    2cf6:	96 89       	ldd	r25, Z+22	; 0x16
    2cf8:	8e 89       	ldd	r24, Y+22	; 0x16
    2cfa:	98 17       	cp	r25, r24
    2cfc:	10 f4       	brcc	.+4      	; 0x2d02 <xTaskCreate+0x1f2>
    2cfe:	0e 94 5b 1e 	call	0x3cb6	; 0x3cb6 <vPortYield>
    2d02:	81 e0       	ldi	r24, 0x01	; 1
    2d04:	01 c0       	rjmp	.+2      	; 0x2d08 <xTaskCreate+0x1f8>
    2d06:	8f ef       	ldi	r24, 0xFF	; 255
    2d08:	df 91       	pop	r29
    2d0a:	cf 91       	pop	r28
    2d0c:	1f 91       	pop	r17
    2d0e:	0f 91       	pop	r16
    2d10:	ff 90       	pop	r15
    2d12:	ef 90       	pop	r14
    2d14:	df 90       	pop	r13
    2d16:	cf 90       	pop	r12
    2d18:	bf 90       	pop	r11
    2d1a:	af 90       	pop	r10
    2d1c:	9f 90       	pop	r9
    2d1e:	8f 90       	pop	r8
    2d20:	7f 90       	pop	r7
    2d22:	6f 90       	pop	r6
    2d24:	5f 90       	pop	r5
    2d26:	08 95       	ret

00002d28 <vTaskResume>:
    2d28:	0f 93       	push	r16
    2d2a:	1f 93       	push	r17
    2d2c:	cf 93       	push	r28
    2d2e:	df 93       	push	r29
    2d30:	20 91 c2 04 	lds	r18, 0x04C2	; 0x8004c2 <pxCurrentTCB>
    2d34:	30 91 c3 04 	lds	r19, 0x04C3	; 0x8004c3 <pxCurrentTCB+0x1>
    2d38:	82 17       	cp	r24, r18
    2d3a:	93 07       	cpc	r25, r19
    2d3c:	09 f4       	brne	.+2      	; 0x2d40 <vTaskResume+0x18>
    2d3e:	38 c0       	rjmp	.+112    	; 0x2db0 <vTaskResume+0x88>
    2d40:	00 97       	sbiw	r24, 0x00	; 0
    2d42:	09 f4       	brne	.+2      	; 0x2d46 <vTaskResume+0x1e>
    2d44:	35 c0       	rjmp	.+106    	; 0x2db0 <vTaskResume+0x88>
    2d46:	0f b6       	in	r0, 0x3f	; 63
    2d48:	f8 94       	cli
    2d4a:	0f 92       	push	r0
    2d4c:	fc 01       	movw	r30, r24
    2d4e:	22 85       	ldd	r18, Z+10	; 0x0a
    2d50:	33 85       	ldd	r19, Z+11	; 0x0b
    2d52:	2c 56       	subi	r18, 0x6C	; 108
    2d54:	34 40       	sbci	r19, 0x04	; 4
    2d56:	51 f5       	brne	.+84     	; 0x2dac <vTaskResume+0x84>
    2d58:	fc 01       	movw	r30, r24
    2d5a:	24 89       	ldd	r18, Z+20	; 0x14
    2d5c:	35 89       	ldd	r19, Z+21	; 0x15
    2d5e:	f4 e0       	ldi	r31, 0x04	; 4
    2d60:	2f 37       	cpi	r18, 0x7F	; 127
    2d62:	3f 07       	cpc	r19, r31
    2d64:	19 f1       	breq	.+70     	; 0x2dac <vTaskResume+0x84>
    2d66:	23 2b       	or	r18, r19
    2d68:	09 f5       	brne	.+66     	; 0x2dac <vTaskResume+0x84>
    2d6a:	ec 01       	movw	r28, r24
    2d6c:	8c 01       	movw	r16, r24
    2d6e:	0e 5f       	subi	r16, 0xFE	; 254
    2d70:	1f 4f       	sbci	r17, 0xFF	; 255
    2d72:	c8 01       	movw	r24, r16
    2d74:	0e 94 93 1d 	call	0x3b26	; 0x3b26 <uxListRemove>
    2d78:	8e 89       	ldd	r24, Y+22	; 0x16
    2d7a:	90 91 68 04 	lds	r25, 0x0468	; 0x800468 <uxTopReadyPriority>
    2d7e:	98 17       	cp	r25, r24
    2d80:	10 f4       	brcc	.+4      	; 0x2d86 <vTaskResume+0x5e>
    2d82:	80 93 68 04 	sts	0x0468, r24	; 0x800468 <uxTopReadyPriority>
    2d86:	29 e0       	ldi	r18, 0x09	; 9
    2d88:	82 9f       	mul	r24, r18
    2d8a:	c0 01       	movw	r24, r0
    2d8c:	11 24       	eor	r1, r1
    2d8e:	b8 01       	movw	r22, r16
    2d90:	82 56       	subi	r24, 0x62	; 98
    2d92:	9b 4f       	sbci	r25, 0xFB	; 251
    2d94:	0e 94 3a 1d 	call	0x3a74	; 0x3a74 <vListInsertEnd>
    2d98:	e0 91 c2 04 	lds	r30, 0x04C2	; 0x8004c2 <pxCurrentTCB>
    2d9c:	f0 91 c3 04 	lds	r31, 0x04C3	; 0x8004c3 <pxCurrentTCB+0x1>
    2da0:	9e 89       	ldd	r25, Y+22	; 0x16
    2da2:	86 89       	ldd	r24, Z+22	; 0x16
    2da4:	98 17       	cp	r25, r24
    2da6:	10 f0       	brcs	.+4      	; 0x2dac <vTaskResume+0x84>
    2da8:	0e 94 5b 1e 	call	0x3cb6	; 0x3cb6 <vPortYield>
    2dac:	0f 90       	pop	r0
    2dae:	0f be       	out	0x3f, r0	; 63
    2db0:	df 91       	pop	r29
    2db2:	cf 91       	pop	r28
    2db4:	1f 91       	pop	r17
    2db6:	0f 91       	pop	r16
    2db8:	08 95       	ret

00002dba <vTaskStartScheduler>:
    2dba:	ef 92       	push	r14
    2dbc:	ff 92       	push	r15
    2dbe:	0f 93       	push	r16
    2dc0:	8f e5       	ldi	r24, 0x5F	; 95
    2dc2:	e8 2e       	mov	r14, r24
    2dc4:	84 e0       	ldi	r24, 0x04	; 4
    2dc6:	f8 2e       	mov	r15, r24
    2dc8:	00 e0       	ldi	r16, 0x00	; 0
    2dca:	20 e0       	ldi	r18, 0x00	; 0
    2dcc:	30 e0       	ldi	r19, 0x00	; 0
    2dce:	40 ec       	ldi	r20, 0xC0	; 192
    2dd0:	50 e0       	ldi	r21, 0x00	; 0
    2dd2:	6a e6       	ldi	r22, 0x6A	; 106
    2dd4:	72 e0       	ldi	r23, 0x02	; 2
    2dd6:	8a e5       	ldi	r24, 0x5A	; 90
    2dd8:	95 e1       	ldi	r25, 0x15	; 21
    2dda:	0e 94 88 15 	call	0x2b10	; 0x2b10 <xTaskCreate>
    2dde:	81 30       	cpi	r24, 0x01	; 1
    2de0:	b1 f4       	brne	.+44     	; 0x2e0e <vTaskStartScheduler+0x54>
    2de2:	0e 94 12 1a 	call	0x3424	; 0x3424 <xTimerCreateTimerTask>
    2de6:	81 30       	cpi	r24, 0x01	; 1
    2de8:	91 f4       	brne	.+36     	; 0x2e0e <vTaskStartScheduler+0x54>
    2dea:	f8 94       	cli
    2dec:	2f ef       	ldi	r18, 0xFF	; 255
    2dee:	3f ef       	ldi	r19, 0xFF	; 255
    2df0:	30 93 62 04 	sts	0x0462, r19	; 0x800462 <xNextTaskUnblockTime+0x1>
    2df4:	20 93 61 04 	sts	0x0461, r18	; 0x800461 <xNextTaskUnblockTime>
    2df8:	80 93 67 04 	sts	0x0467, r24	; 0x800467 <xSchedulerRunning>
    2dfc:	10 92 6a 04 	sts	0x046A, r1	; 0x80046a <xTickCount+0x1>
    2e00:	10 92 69 04 	sts	0x0469, r1	; 0x800469 <xTickCount>
    2e04:	0f 91       	pop	r16
    2e06:	ff 90       	pop	r15
    2e08:	ef 90       	pop	r14
    2e0a:	0c 94 23 1e 	jmp	0x3c46	; 0x3c46 <xPortStartScheduler>
    2e0e:	0f 91       	pop	r16
    2e10:	ff 90       	pop	r15
    2e12:	ef 90       	pop	r14
    2e14:	08 95       	ret

00002e16 <vTaskSuspendAll>:
    2e16:	80 91 5e 04 	lds	r24, 0x045E	; 0x80045e <uxSchedulerSuspended>
    2e1a:	8f 5f       	subi	r24, 0xFF	; 255
    2e1c:	80 93 5e 04 	sts	0x045E, r24	; 0x80045e <uxSchedulerSuspended>
    2e20:	08 95       	ret

00002e22 <xTaskGetTickCount>:
    2e22:	0f b6       	in	r0, 0x3f	; 63
    2e24:	f8 94       	cli
    2e26:	0f 92       	push	r0
    2e28:	80 91 69 04 	lds	r24, 0x0469	; 0x800469 <xTickCount>
    2e2c:	90 91 6a 04 	lds	r25, 0x046A	; 0x80046a <xTickCount+0x1>
    2e30:	0f 90       	pop	r0
    2e32:	0f be       	out	0x3f, r0	; 63
    2e34:	08 95       	ret

00002e36 <xTaskIncrementTick>:
    2e36:	cf 92       	push	r12
    2e38:	df 92       	push	r13
    2e3a:	ef 92       	push	r14
    2e3c:	ff 92       	push	r15
    2e3e:	0f 93       	push	r16
    2e40:	1f 93       	push	r17
    2e42:	cf 93       	push	r28
    2e44:	df 93       	push	r29
    2e46:	80 91 5e 04 	lds	r24, 0x045E	; 0x80045e <uxSchedulerSuspended>
    2e4a:	81 11       	cpse	r24, r1
    2e4c:	8c c0       	rjmp	.+280    	; 0x2f66 <xTaskIncrementTick+0x130>
    2e4e:	00 91 69 04 	lds	r16, 0x0469	; 0x800469 <xTickCount>
    2e52:	10 91 6a 04 	lds	r17, 0x046A	; 0x80046a <xTickCount+0x1>
    2e56:	0f 5f       	subi	r16, 0xFF	; 255
    2e58:	1f 4f       	sbci	r17, 0xFF	; 255
    2e5a:	10 93 6a 04 	sts	0x046A, r17	; 0x80046a <xTickCount+0x1>
    2e5e:	00 93 69 04 	sts	0x0469, r16	; 0x800469 <xTickCount>
    2e62:	01 15       	cp	r16, r1
    2e64:	11 05       	cpc	r17, r1
    2e66:	b9 f4       	brne	.+46     	; 0x2e96 <xTaskIncrementTick+0x60>
    2e68:	80 91 8a 04 	lds	r24, 0x048A	; 0x80048a <pxDelayedTaskList>
    2e6c:	90 91 8b 04 	lds	r25, 0x048B	; 0x80048b <pxDelayedTaskList+0x1>
    2e70:	20 91 88 04 	lds	r18, 0x0488	; 0x800488 <pxOverflowDelayedTaskList>
    2e74:	30 91 89 04 	lds	r19, 0x0489	; 0x800489 <pxOverflowDelayedTaskList+0x1>
    2e78:	30 93 8b 04 	sts	0x048B, r19	; 0x80048b <pxDelayedTaskList+0x1>
    2e7c:	20 93 8a 04 	sts	0x048A, r18	; 0x80048a <pxDelayedTaskList>
    2e80:	90 93 89 04 	sts	0x0489, r25	; 0x800489 <pxOverflowDelayedTaskList+0x1>
    2e84:	80 93 88 04 	sts	0x0488, r24	; 0x800488 <pxOverflowDelayedTaskList>
    2e88:	80 91 64 04 	lds	r24, 0x0464	; 0x800464 <xNumOfOverflows>
    2e8c:	8f 5f       	subi	r24, 0xFF	; 255
    2e8e:	80 93 64 04 	sts	0x0464, r24	; 0x800464 <xNumOfOverflows>
    2e92:	0e 94 e3 14 	call	0x29c6	; 0x29c6 <prvResetNextTaskUnblockTime>
    2e96:	80 91 61 04 	lds	r24, 0x0461	; 0x800461 <xNextTaskUnblockTime>
    2e9a:	90 91 62 04 	lds	r25, 0x0462	; 0x800462 <xNextTaskUnblockTime+0x1>
    2e9e:	c0 e0       	ldi	r28, 0x00	; 0
    2ea0:	08 17       	cp	r16, r24
    2ea2:	19 07       	cpc	r17, r25
    2ea4:	08 f4       	brcc	.+2      	; 0x2ea8 <xTaskIncrementTick+0x72>
    2ea6:	4f c0       	rjmp	.+158    	; 0x2f46 <xTaskIncrementTick+0x110>
    2ea8:	d9 e0       	ldi	r29, 0x09	; 9
    2eaa:	e0 91 8a 04 	lds	r30, 0x048A	; 0x80048a <pxDelayedTaskList>
    2eae:	f0 91 8b 04 	lds	r31, 0x048B	; 0x80048b <pxDelayedTaskList+0x1>
    2eb2:	80 81       	ld	r24, Z
    2eb4:	81 11       	cpse	r24, r1
    2eb6:	03 c0       	rjmp	.+6      	; 0x2ebe <xTaskIncrementTick+0x88>
    2eb8:	8f ef       	ldi	r24, 0xFF	; 255
    2eba:	9f ef       	ldi	r25, 0xFF	; 255
    2ebc:	11 c0       	rjmp	.+34     	; 0x2ee0 <xTaskIncrementTick+0xaa>
    2ebe:	e0 91 8a 04 	lds	r30, 0x048A	; 0x80048a <pxDelayedTaskList>
    2ec2:	f0 91 8b 04 	lds	r31, 0x048B	; 0x80048b <pxDelayedTaskList+0x1>
    2ec6:	05 80       	ldd	r0, Z+5	; 0x05
    2ec8:	f6 81       	ldd	r31, Z+6	; 0x06
    2eca:	e0 2d       	mov	r30, r0
    2ecc:	e6 80       	ldd	r14, Z+6	; 0x06
    2ece:	f7 80       	ldd	r15, Z+7	; 0x07
    2ed0:	d7 01       	movw	r26, r14
    2ed2:	12 96       	adiw	r26, 0x02	; 2
    2ed4:	8d 91       	ld	r24, X+
    2ed6:	9c 91       	ld	r25, X
    2ed8:	13 97       	sbiw	r26, 0x03	; 3
    2eda:	08 17       	cp	r16, r24
    2edc:	19 07       	cpc	r17, r25
    2ede:	28 f4       	brcc	.+10     	; 0x2eea <xTaskIncrementTick+0xb4>
    2ee0:	90 93 62 04 	sts	0x0462, r25	; 0x800462 <xNextTaskUnblockTime+0x1>
    2ee4:	80 93 61 04 	sts	0x0461, r24	; 0x800461 <xNextTaskUnblockTime>
    2ee8:	2e c0       	rjmp	.+92     	; 0x2f46 <xTaskIncrementTick+0x110>
    2eea:	67 01       	movw	r12, r14
    2eec:	b2 e0       	ldi	r27, 0x02	; 2
    2eee:	cb 0e       	add	r12, r27
    2ef0:	d1 1c       	adc	r13, r1
    2ef2:	c6 01       	movw	r24, r12
    2ef4:	0e 94 93 1d 	call	0x3b26	; 0x3b26 <uxListRemove>
    2ef8:	f7 01       	movw	r30, r14
    2efa:	84 89       	ldd	r24, Z+20	; 0x14
    2efc:	95 89       	ldd	r25, Z+21	; 0x15
    2efe:	89 2b       	or	r24, r25
    2f00:	21 f0       	breq	.+8      	; 0x2f0a <xTaskIncrementTick+0xd4>
    2f02:	c7 01       	movw	r24, r14
    2f04:	0c 96       	adiw	r24, 0x0c	; 12
    2f06:	0e 94 93 1d 	call	0x3b26	; 0x3b26 <uxListRemove>
    2f0a:	d7 01       	movw	r26, r14
    2f0c:	56 96       	adiw	r26, 0x16	; 22
    2f0e:	8c 91       	ld	r24, X
    2f10:	90 91 68 04 	lds	r25, 0x0468	; 0x800468 <uxTopReadyPriority>
    2f14:	98 17       	cp	r25, r24
    2f16:	10 f4       	brcc	.+4      	; 0x2f1c <xTaskIncrementTick+0xe6>
    2f18:	80 93 68 04 	sts	0x0468, r24	; 0x800468 <uxTopReadyPriority>
    2f1c:	d8 9f       	mul	r29, r24
    2f1e:	c0 01       	movw	r24, r0
    2f20:	11 24       	eor	r1, r1
    2f22:	b6 01       	movw	r22, r12
    2f24:	82 56       	subi	r24, 0x62	; 98
    2f26:	9b 4f       	sbci	r25, 0xFB	; 251
    2f28:	0e 94 3a 1d 	call	0x3a74	; 0x3a74 <vListInsertEnd>
    2f2c:	e0 91 c2 04 	lds	r30, 0x04C2	; 0x8004c2 <pxCurrentTCB>
    2f30:	f0 91 c3 04 	lds	r31, 0x04C3	; 0x8004c3 <pxCurrentTCB+0x1>
    2f34:	d7 01       	movw	r26, r14
    2f36:	56 96       	adiw	r26, 0x16	; 22
    2f38:	9c 91       	ld	r25, X
    2f3a:	86 89       	ldd	r24, Z+22	; 0x16
    2f3c:	98 17       	cp	r25, r24
    2f3e:	08 f4       	brcc	.+2      	; 0x2f42 <xTaskIncrementTick+0x10c>
    2f40:	b4 cf       	rjmp	.-152    	; 0x2eaa <xTaskIncrementTick+0x74>
    2f42:	c1 e0       	ldi	r28, 0x01	; 1
    2f44:	b2 cf       	rjmp	.-156    	; 0x2eaa <xTaskIncrementTick+0x74>
    2f46:	e0 91 c2 04 	lds	r30, 0x04C2	; 0x8004c2 <pxCurrentTCB>
    2f4a:	f0 91 c3 04 	lds	r31, 0x04C3	; 0x8004c3 <pxCurrentTCB+0x1>
    2f4e:	e6 89       	ldd	r30, Z+22	; 0x16
    2f50:	b9 e0       	ldi	r27, 0x09	; 9
    2f52:	eb 9f       	mul	r30, r27
    2f54:	f0 01       	movw	r30, r0
    2f56:	11 24       	eor	r1, r1
    2f58:	e2 56       	subi	r30, 0x62	; 98
    2f5a:	fb 4f       	sbci	r31, 0xFB	; 251
    2f5c:	80 81       	ld	r24, Z
    2f5e:	82 30       	cpi	r24, 0x02	; 2
    2f60:	40 f0       	brcs	.+16     	; 0x2f72 <xTaskIncrementTick+0x13c>
    2f62:	c1 e0       	ldi	r28, 0x01	; 1
    2f64:	06 c0       	rjmp	.+12     	; 0x2f72 <xTaskIncrementTick+0x13c>
    2f66:	80 91 66 04 	lds	r24, 0x0466	; 0x800466 <uxPendedTicks>
    2f6a:	8f 5f       	subi	r24, 0xFF	; 255
    2f6c:	80 93 66 04 	sts	0x0466, r24	; 0x800466 <uxPendedTicks>
    2f70:	c0 e0       	ldi	r28, 0x00	; 0
    2f72:	80 91 65 04 	lds	r24, 0x0465	; 0x800465 <xYieldPending>
    2f76:	81 11       	cpse	r24, r1
    2f78:	c1 e0       	ldi	r28, 0x01	; 1
    2f7a:	8c 2f       	mov	r24, r28
    2f7c:	df 91       	pop	r29
    2f7e:	cf 91       	pop	r28
    2f80:	1f 91       	pop	r17
    2f82:	0f 91       	pop	r16
    2f84:	ff 90       	pop	r15
    2f86:	ef 90       	pop	r14
    2f88:	df 90       	pop	r13
    2f8a:	cf 90       	pop	r12
    2f8c:	08 95       	ret

00002f8e <xTaskResumeAll>:
    2f8e:	ef 92       	push	r14
    2f90:	ff 92       	push	r15
    2f92:	0f 93       	push	r16
    2f94:	1f 93       	push	r17
    2f96:	cf 93       	push	r28
    2f98:	df 93       	push	r29
    2f9a:	0f b6       	in	r0, 0x3f	; 63
    2f9c:	f8 94       	cli
    2f9e:	0f 92       	push	r0
    2fa0:	80 91 5e 04 	lds	r24, 0x045E	; 0x80045e <uxSchedulerSuspended>
    2fa4:	81 50       	subi	r24, 0x01	; 1
    2fa6:	80 93 5e 04 	sts	0x045E, r24	; 0x80045e <uxSchedulerSuspended>
    2faa:	80 91 5e 04 	lds	r24, 0x045E	; 0x80045e <uxSchedulerSuspended>
    2fae:	88 23       	and	r24, r24
    2fb0:	11 f0       	breq	.+4      	; 0x2fb6 <xTaskResumeAll+0x28>
    2fb2:	80 e0       	ldi	r24, 0x00	; 0
    2fb4:	52 c0       	rjmp	.+164    	; 0x305a <xTaskResumeAll+0xcc>
    2fb6:	80 91 6b 04 	lds	r24, 0x046B	; 0x80046b <uxCurrentNumberOfTasks>
    2fba:	88 23       	and	r24, r24
    2fbc:	d1 f3       	breq	.-12     	; 0x2fb2 <xTaskResumeAll+0x24>
    2fbe:	c0 e0       	ldi	r28, 0x00	; 0
    2fc0:	d0 e0       	ldi	r29, 0x00	; 0
    2fc2:	89 e0       	ldi	r24, 0x09	; 9
    2fc4:	f8 2e       	mov	r15, r24
    2fc6:	ee 24       	eor	r14, r14
    2fc8:	e3 94       	inc	r14
    2fca:	80 91 7f 04 	lds	r24, 0x047F	; 0x80047f <xPendingReadyList>
    2fce:	88 23       	and	r24, r24
    2fd0:	51 f1       	breq	.+84     	; 0x3026 <xTaskResumeAll+0x98>
    2fd2:	e0 91 84 04 	lds	r30, 0x0484	; 0x800484 <xPendingReadyList+0x5>
    2fd6:	f0 91 85 04 	lds	r31, 0x0485	; 0x800485 <xPendingReadyList+0x6>
    2fda:	c6 81       	ldd	r28, Z+6	; 0x06
    2fdc:	d7 81       	ldd	r29, Z+7	; 0x07
    2fde:	ce 01       	movw	r24, r28
    2fe0:	0c 96       	adiw	r24, 0x0c	; 12
    2fe2:	0e 94 93 1d 	call	0x3b26	; 0x3b26 <uxListRemove>
    2fe6:	8e 01       	movw	r16, r28
    2fe8:	0e 5f       	subi	r16, 0xFE	; 254
    2fea:	1f 4f       	sbci	r17, 0xFF	; 255
    2fec:	c8 01       	movw	r24, r16
    2fee:	0e 94 93 1d 	call	0x3b26	; 0x3b26 <uxListRemove>
    2ff2:	8e 89       	ldd	r24, Y+22	; 0x16
    2ff4:	90 91 68 04 	lds	r25, 0x0468	; 0x800468 <uxTopReadyPriority>
    2ff8:	98 17       	cp	r25, r24
    2ffa:	10 f4       	brcc	.+4      	; 0x3000 <xTaskResumeAll+0x72>
    2ffc:	80 93 68 04 	sts	0x0468, r24	; 0x800468 <uxTopReadyPriority>
    3000:	f8 9e       	mul	r15, r24
    3002:	c0 01       	movw	r24, r0
    3004:	11 24       	eor	r1, r1
    3006:	b8 01       	movw	r22, r16
    3008:	82 56       	subi	r24, 0x62	; 98
    300a:	9b 4f       	sbci	r25, 0xFB	; 251
    300c:	0e 94 3a 1d 	call	0x3a74	; 0x3a74 <vListInsertEnd>
    3010:	e0 91 c2 04 	lds	r30, 0x04C2	; 0x8004c2 <pxCurrentTCB>
    3014:	f0 91 c3 04 	lds	r31, 0x04C3	; 0x8004c3 <pxCurrentTCB+0x1>
    3018:	9e 89       	ldd	r25, Y+22	; 0x16
    301a:	86 89       	ldd	r24, Z+22	; 0x16
    301c:	98 17       	cp	r25, r24
    301e:	a8 f2       	brcs	.-86     	; 0x2fca <xTaskResumeAll+0x3c>
    3020:	e0 92 65 04 	sts	0x0465, r14	; 0x800465 <xYieldPending>
    3024:	d2 cf       	rjmp	.-92     	; 0x2fca <xTaskResumeAll+0x3c>
    3026:	cd 2b       	or	r28, r29
    3028:	11 f0       	breq	.+4      	; 0x302e <xTaskResumeAll+0xa0>
    302a:	0e 94 e3 14 	call	0x29c6	; 0x29c6 <prvResetNextTaskUnblockTime>
    302e:	c0 91 66 04 	lds	r28, 0x0466	; 0x800466 <uxPendedTicks>
    3032:	cc 23       	and	r28, r28
    3034:	51 f0       	breq	.+20     	; 0x304a <xTaskResumeAll+0xbc>
    3036:	d1 e0       	ldi	r29, 0x01	; 1
    3038:	0e 94 1b 17 	call	0x2e36	; 0x2e36 <xTaskIncrementTick>
    303c:	81 11       	cpse	r24, r1
    303e:	d0 93 65 04 	sts	0x0465, r29	; 0x800465 <xYieldPending>
    3042:	c1 50       	subi	r28, 0x01	; 1
    3044:	c9 f7       	brne	.-14     	; 0x3038 <xTaskResumeAll+0xaa>
    3046:	10 92 66 04 	sts	0x0466, r1	; 0x800466 <uxPendedTicks>
    304a:	80 91 65 04 	lds	r24, 0x0465	; 0x800465 <xYieldPending>
    304e:	88 23       	and	r24, r24
    3050:	09 f4       	brne	.+2      	; 0x3054 <xTaskResumeAll+0xc6>
    3052:	af cf       	rjmp	.-162    	; 0x2fb2 <xTaskResumeAll+0x24>
    3054:	0e 94 5b 1e 	call	0x3cb6	; 0x3cb6 <vPortYield>
    3058:	81 e0       	ldi	r24, 0x01	; 1
    305a:	0f 90       	pop	r0
    305c:	0f be       	out	0x3f, r0	; 63
    305e:	df 91       	pop	r29
    3060:	cf 91       	pop	r28
    3062:	1f 91       	pop	r17
    3064:	0f 91       	pop	r16
    3066:	ff 90       	pop	r15
    3068:	ef 90       	pop	r14
    306a:	08 95       	ret

0000306c <vTaskDelayUntil>:
    306c:	0f 93       	push	r16
    306e:	1f 93       	push	r17
    3070:	cf 93       	push	r28
    3072:	df 93       	push	r29
    3074:	8c 01       	movw	r16, r24
    3076:	eb 01       	movw	r28, r22
    3078:	0e 94 0b 17 	call	0x2e16	; 0x2e16 <vTaskSuspendAll>
    307c:	40 91 69 04 	lds	r20, 0x0469	; 0x800469 <xTickCount>
    3080:	50 91 6a 04 	lds	r21, 0x046A	; 0x80046a <xTickCount+0x1>
    3084:	f8 01       	movw	r30, r16
    3086:	20 81       	ld	r18, Z
    3088:	31 81       	ldd	r19, Z+1	; 0x01
    308a:	c9 01       	movw	r24, r18
    308c:	8c 0f       	add	r24, r28
    308e:	9d 1f       	adc	r25, r29
    3090:	42 17       	cp	r20, r18
    3092:	53 07       	cpc	r21, r19
    3094:	20 f4       	brcc	.+8      	; 0x309e <vTaskDelayUntil+0x32>
    3096:	82 17       	cp	r24, r18
    3098:	93 07       	cpc	r25, r19
    309a:	40 f4       	brcc	.+16     	; 0x30ac <vTaskDelayUntil+0x40>
    309c:	03 c0       	rjmp	.+6      	; 0x30a4 <vTaskDelayUntil+0x38>
    309e:	82 17       	cp	r24, r18
    30a0:	93 07       	cpc	r25, r19
    30a2:	30 f0       	brcs	.+12     	; 0x30b0 <vTaskDelayUntil+0x44>
    30a4:	21 e0       	ldi	r18, 0x01	; 1
    30a6:	48 17       	cp	r20, r24
    30a8:	59 07       	cpc	r21, r25
    30aa:	18 f0       	brcs	.+6      	; 0x30b2 <vTaskDelayUntil+0x46>
    30ac:	20 e0       	ldi	r18, 0x00	; 0
    30ae:	01 c0       	rjmp	.+2      	; 0x30b2 <vTaskDelayUntil+0x46>
    30b0:	21 e0       	ldi	r18, 0x01	; 1
    30b2:	f8 01       	movw	r30, r16
    30b4:	91 83       	std	Z+1, r25	; 0x01
    30b6:	80 83       	st	Z, r24
    30b8:	22 23       	and	r18, r18
    30ba:	29 f0       	breq	.+10     	; 0x30c6 <vTaskDelayUntil+0x5a>
    30bc:	60 e0       	ldi	r22, 0x00	; 0
    30be:	84 1b       	sub	r24, r20
    30c0:	95 0b       	sbc	r25, r21
    30c2:	0e 94 fe 14 	call	0x29fc	; 0x29fc <prvAddCurrentTaskToDelayedList>
    30c6:	0e 94 c7 17 	call	0x2f8e	; 0x2f8e <xTaskResumeAll>
    30ca:	81 11       	cpse	r24, r1
    30cc:	02 c0       	rjmp	.+4      	; 0x30d2 <vTaskDelayUntil+0x66>
    30ce:	0e 94 5b 1e 	call	0x3cb6	; 0x3cb6 <vPortYield>
    30d2:	df 91       	pop	r29
    30d4:	cf 91       	pop	r28
    30d6:	1f 91       	pop	r17
    30d8:	0f 91       	pop	r16
    30da:	08 95       	ret

000030dc <vTaskSwitchContext>:
    30dc:	80 91 5e 04 	lds	r24, 0x045E	; 0x80045e <uxSchedulerSuspended>
    30e0:	88 23       	and	r24, r24
    30e2:	21 f0       	breq	.+8      	; 0x30ec <vTaskSwitchContext+0x10>
    30e4:	81 e0       	ldi	r24, 0x01	; 1
    30e6:	80 93 65 04 	sts	0x0465, r24	; 0x800465 <xYieldPending>
    30ea:	08 95       	ret
    30ec:	10 92 65 04 	sts	0x0465, r1	; 0x800465 <xYieldPending>
    30f0:	a0 91 c2 04 	lds	r26, 0x04C2	; 0x8004c2 <pxCurrentTCB>
    30f4:	b0 91 c3 04 	lds	r27, 0x04C3	; 0x8004c3 <pxCurrentTCB+0x1>
    30f8:	e0 91 c2 04 	lds	r30, 0x04C2	; 0x8004c2 <pxCurrentTCB>
    30fc:	f0 91 c3 04 	lds	r31, 0x04C3	; 0x8004c3 <pxCurrentTCB+0x1>
    3100:	2d 91       	ld	r18, X+
    3102:	3c 91       	ld	r19, X
    3104:	87 89       	ldd	r24, Z+23	; 0x17
    3106:	90 8d       	ldd	r25, Z+24	; 0x18
    3108:	82 17       	cp	r24, r18
    310a:	93 07       	cpc	r25, r19
    310c:	60 f0       	brcs	.+24     	; 0x3126 <vTaskSwitchContext+0x4a>
    310e:	60 91 c2 04 	lds	r22, 0x04C2	; 0x8004c2 <pxCurrentTCB>
    3112:	70 91 c3 04 	lds	r23, 0x04C3	; 0x8004c3 <pxCurrentTCB+0x1>
    3116:	80 91 c2 04 	lds	r24, 0x04C2	; 0x8004c2 <pxCurrentTCB>
    311a:	90 91 c3 04 	lds	r25, 0x04C3	; 0x8004c3 <pxCurrentTCB+0x1>
    311e:	67 5e       	subi	r22, 0xE7	; 231
    3120:	7f 4f       	sbci	r23, 0xFF	; 255
    3122:	0e 94 e0 1b 	call	0x37c0	; 0x37c0 <vApplicationStackOverflowHook>
    3126:	80 91 68 04 	lds	r24, 0x0468	; 0x800468 <uxTopReadyPriority>
    312a:	69 e0       	ldi	r22, 0x09	; 9
    312c:	48 2f       	mov	r20, r24
    312e:	50 e0       	ldi	r21, 0x00	; 0
    3130:	64 9f       	mul	r22, r20
    3132:	90 01       	movw	r18, r0
    3134:	65 9f       	mul	r22, r21
    3136:	30 0d       	add	r19, r0
    3138:	11 24       	eor	r1, r1
    313a:	f9 01       	movw	r30, r18
    313c:	e2 56       	subi	r30, 0x62	; 98
    313e:	fb 4f       	sbci	r31, 0xFB	; 251
    3140:	90 81       	ld	r25, Z
    3142:	91 11       	cpse	r25, r1
    3144:	02 c0       	rjmp	.+4      	; 0x314a <vTaskSwitchContext+0x6e>
    3146:	81 50       	subi	r24, 0x01	; 1
    3148:	f1 cf       	rjmp	.-30     	; 0x312c <vTaskSwitchContext+0x50>
    314a:	a1 81       	ldd	r26, Z+1	; 0x01
    314c:	b2 81       	ldd	r27, Z+2	; 0x02
    314e:	12 96       	adiw	r26, 0x02	; 2
    3150:	0d 90       	ld	r0, X+
    3152:	bc 91       	ld	r27, X
    3154:	a0 2d       	mov	r26, r0
    3156:	b2 83       	std	Z+2, r27	; 0x02
    3158:	a1 83       	std	Z+1, r26	; 0x01
    315a:	2f 55       	subi	r18, 0x5F	; 95
    315c:	3b 4f       	sbci	r19, 0xFB	; 251
    315e:	a2 17       	cp	r26, r18
    3160:	b3 07       	cpc	r27, r19
    3162:	31 f4       	brne	.+12     	; 0x3170 <vTaskSwitchContext+0x94>
    3164:	12 96       	adiw	r26, 0x02	; 2
    3166:	2d 91       	ld	r18, X+
    3168:	3c 91       	ld	r19, X
    316a:	13 97       	sbiw	r26, 0x03	; 3
    316c:	32 83       	std	Z+2, r19	; 0x02
    316e:	21 83       	std	Z+1, r18	; 0x01
    3170:	99 e0       	ldi	r25, 0x09	; 9
    3172:	94 9f       	mul	r25, r20
    3174:	f0 01       	movw	r30, r0
    3176:	95 9f       	mul	r25, r21
    3178:	f0 0d       	add	r31, r0
    317a:	11 24       	eor	r1, r1
    317c:	e2 56       	subi	r30, 0x62	; 98
    317e:	fb 4f       	sbci	r31, 0xFB	; 251
    3180:	01 80       	ldd	r0, Z+1	; 0x01
    3182:	f2 81       	ldd	r31, Z+2	; 0x02
    3184:	e0 2d       	mov	r30, r0
    3186:	26 81       	ldd	r18, Z+6	; 0x06
    3188:	37 81       	ldd	r19, Z+7	; 0x07
    318a:	30 93 c3 04 	sts	0x04C3, r19	; 0x8004c3 <pxCurrentTCB+0x1>
    318e:	20 93 c2 04 	sts	0x04C2, r18	; 0x8004c2 <pxCurrentTCB>
    3192:	80 93 68 04 	sts	0x0468, r24	; 0x800468 <uxTopReadyPriority>
    3196:	08 95       	ret

00003198 <vTaskPlaceOnEventList>:
    3198:	cf 93       	push	r28
    319a:	df 93       	push	r29
    319c:	eb 01       	movw	r28, r22
    319e:	60 91 c2 04 	lds	r22, 0x04C2	; 0x8004c2 <pxCurrentTCB>
    31a2:	70 91 c3 04 	lds	r23, 0x04C3	; 0x8004c3 <pxCurrentTCB+0x1>
    31a6:	64 5f       	subi	r22, 0xF4	; 244
    31a8:	7f 4f       	sbci	r23, 0xFF	; 255
    31aa:	0e 94 5b 1d 	call	0x3ab6	; 0x3ab6 <vListInsert>
    31ae:	61 e0       	ldi	r22, 0x01	; 1
    31b0:	ce 01       	movw	r24, r28
    31b2:	df 91       	pop	r29
    31b4:	cf 91       	pop	r28
    31b6:	0c 94 fe 14 	jmp	0x29fc	; 0x29fc <prvAddCurrentTaskToDelayedList>

000031ba <vTaskPlaceOnEventListRestricted>:
    31ba:	1f 93       	push	r17
    31bc:	cf 93       	push	r28
    31be:	df 93       	push	r29
    31c0:	eb 01       	movw	r28, r22
    31c2:	14 2f       	mov	r17, r20
    31c4:	60 91 c2 04 	lds	r22, 0x04C2	; 0x8004c2 <pxCurrentTCB>
    31c8:	70 91 c3 04 	lds	r23, 0x04C3	; 0x8004c3 <pxCurrentTCB+0x1>
    31cc:	64 5f       	subi	r22, 0xF4	; 244
    31ce:	7f 4f       	sbci	r23, 0xFF	; 255
    31d0:	0e 94 3a 1d 	call	0x3a74	; 0x3a74 <vListInsertEnd>
    31d4:	11 23       	and	r17, r17
    31d6:	11 f0       	breq	.+4      	; 0x31dc <vTaskPlaceOnEventListRestricted+0x22>
    31d8:	cf ef       	ldi	r28, 0xFF	; 255
    31da:	df ef       	ldi	r29, 0xFF	; 255
    31dc:	61 2f       	mov	r22, r17
    31de:	ce 01       	movw	r24, r28
    31e0:	df 91       	pop	r29
    31e2:	cf 91       	pop	r28
    31e4:	1f 91       	pop	r17
    31e6:	0c 94 fe 14 	jmp	0x29fc	; 0x29fc <prvAddCurrentTaskToDelayedList>

000031ea <xTaskRemoveFromEventList>:
    31ea:	0f 93       	push	r16
    31ec:	1f 93       	push	r17
    31ee:	cf 93       	push	r28
    31f0:	df 93       	push	r29
    31f2:	dc 01       	movw	r26, r24
    31f4:	15 96       	adiw	r26, 0x05	; 5
    31f6:	ed 91       	ld	r30, X+
    31f8:	fc 91       	ld	r31, X
    31fa:	16 97       	sbiw	r26, 0x06	; 6
    31fc:	c6 81       	ldd	r28, Z+6	; 0x06
    31fe:	d7 81       	ldd	r29, Z+7	; 0x07
    3200:	8e 01       	movw	r16, r28
    3202:	04 5f       	subi	r16, 0xF4	; 244
    3204:	1f 4f       	sbci	r17, 0xFF	; 255
    3206:	c8 01       	movw	r24, r16
    3208:	0e 94 93 1d 	call	0x3b26	; 0x3b26 <uxListRemove>
    320c:	80 91 5e 04 	lds	r24, 0x045E	; 0x80045e <uxSchedulerSuspended>
    3210:	81 11       	cpse	r24, r1
    3212:	14 c0       	rjmp	.+40     	; 0x323c <xTaskRemoveFromEventList+0x52>
    3214:	0a 50       	subi	r16, 0x0A	; 10
    3216:	11 09       	sbc	r17, r1
    3218:	c8 01       	movw	r24, r16
    321a:	0e 94 93 1d 	call	0x3b26	; 0x3b26 <uxListRemove>
    321e:	8e 89       	ldd	r24, Y+22	; 0x16
    3220:	90 91 68 04 	lds	r25, 0x0468	; 0x800468 <uxTopReadyPriority>
    3224:	98 17       	cp	r25, r24
    3226:	10 f4       	brcc	.+4      	; 0x322c <xTaskRemoveFromEventList+0x42>
    3228:	80 93 68 04 	sts	0x0468, r24	; 0x800468 <uxTopReadyPriority>
    322c:	b9 e0       	ldi	r27, 0x09	; 9
    322e:	8b 9f       	mul	r24, r27
    3230:	c0 01       	movw	r24, r0
    3232:	11 24       	eor	r1, r1
    3234:	b8 01       	movw	r22, r16
    3236:	82 56       	subi	r24, 0x62	; 98
    3238:	9b 4f       	sbci	r25, 0xFB	; 251
    323a:	03 c0       	rjmp	.+6      	; 0x3242 <xTaskRemoveFromEventList+0x58>
    323c:	b8 01       	movw	r22, r16
    323e:	8f e7       	ldi	r24, 0x7F	; 127
    3240:	94 e0       	ldi	r25, 0x04	; 4
    3242:	0e 94 3a 1d 	call	0x3a74	; 0x3a74 <vListInsertEnd>
    3246:	e0 91 c2 04 	lds	r30, 0x04C2	; 0x8004c2 <pxCurrentTCB>
    324a:	f0 91 c3 04 	lds	r31, 0x04C3	; 0x8004c3 <pxCurrentTCB+0x1>
    324e:	9e 89       	ldd	r25, Y+22	; 0x16
    3250:	86 89       	ldd	r24, Z+22	; 0x16
    3252:	89 17       	cp	r24, r25
    3254:	20 f4       	brcc	.+8      	; 0x325e <xTaskRemoveFromEventList+0x74>
    3256:	81 e0       	ldi	r24, 0x01	; 1
    3258:	80 93 65 04 	sts	0x0465, r24	; 0x800465 <xYieldPending>
    325c:	01 c0       	rjmp	.+2      	; 0x3260 <xTaskRemoveFromEventList+0x76>
    325e:	80 e0       	ldi	r24, 0x00	; 0
    3260:	df 91       	pop	r29
    3262:	cf 91       	pop	r28
    3264:	1f 91       	pop	r17
    3266:	0f 91       	pop	r16
    3268:	08 95       	ret

0000326a <vTaskInternalSetTimeOutState>:
    326a:	20 91 64 04 	lds	r18, 0x0464	; 0x800464 <xNumOfOverflows>
    326e:	fc 01       	movw	r30, r24
    3270:	20 83       	st	Z, r18
    3272:	20 91 69 04 	lds	r18, 0x0469	; 0x800469 <xTickCount>
    3276:	30 91 6a 04 	lds	r19, 0x046A	; 0x80046a <xTickCount+0x1>
    327a:	32 83       	std	Z+2, r19	; 0x02
    327c:	21 83       	std	Z+1, r18	; 0x01
    327e:	08 95       	ret

00003280 <xTaskCheckForTimeOut>:
    3280:	cf 93       	push	r28
    3282:	df 93       	push	r29
    3284:	0f b6       	in	r0, 0x3f	; 63
    3286:	f8 94       	cli
    3288:	0f 92       	push	r0
    328a:	40 91 69 04 	lds	r20, 0x0469	; 0x800469 <xTickCount>
    328e:	50 91 6a 04 	lds	r21, 0x046A	; 0x80046a <xTickCount+0x1>
    3292:	db 01       	movw	r26, r22
    3294:	2d 91       	ld	r18, X+
    3296:	3c 91       	ld	r19, X
    3298:	2f 3f       	cpi	r18, 0xFF	; 255
    329a:	bf ef       	ldi	r27, 0xFF	; 255
    329c:	3b 07       	cpc	r19, r27
    329e:	d9 f0       	breq	.+54     	; 0x32d6 <xTaskCheckForTimeOut+0x56>
    32a0:	ec 01       	movw	r28, r24
    32a2:	e9 81       	ldd	r30, Y+1	; 0x01
    32a4:	fa 81       	ldd	r31, Y+2	; 0x02
    32a6:	a0 91 64 04 	lds	r26, 0x0464	; 0x800464 <xNumOfOverflows>
    32aa:	b8 81       	ld	r27, Y
    32ac:	ba 17       	cp	r27, r26
    32ae:	19 f0       	breq	.+6      	; 0x32b6 <xTaskCheckForTimeOut+0x36>
    32b0:	4e 17       	cp	r20, r30
    32b2:	5f 07       	cpc	r21, r31
    32b4:	90 f4       	brcc	.+36     	; 0x32da <xTaskCheckForTimeOut+0x5a>
    32b6:	4e 1b       	sub	r20, r30
    32b8:	5f 0b       	sbc	r21, r31
    32ba:	fb 01       	movw	r30, r22
    32bc:	42 17       	cp	r20, r18
    32be:	53 07       	cpc	r21, r19
    32c0:	38 f4       	brcc	.+14     	; 0x32d0 <xTaskCheckForTimeOut+0x50>
    32c2:	24 1b       	sub	r18, r20
    32c4:	35 0b       	sbc	r19, r21
    32c6:	31 83       	std	Z+1, r19	; 0x01
    32c8:	20 83       	st	Z, r18
    32ca:	0e 94 35 19 	call	0x326a	; 0x326a <vTaskInternalSetTimeOutState>
    32ce:	03 c0       	rjmp	.+6      	; 0x32d6 <xTaskCheckForTimeOut+0x56>
    32d0:	11 82       	std	Z+1, r1	; 0x01
    32d2:	10 82       	st	Z, r1
    32d4:	02 c0       	rjmp	.+4      	; 0x32da <xTaskCheckForTimeOut+0x5a>
    32d6:	80 e0       	ldi	r24, 0x00	; 0
    32d8:	01 c0       	rjmp	.+2      	; 0x32dc <xTaskCheckForTimeOut+0x5c>
    32da:	81 e0       	ldi	r24, 0x01	; 1
    32dc:	0f 90       	pop	r0
    32de:	0f be       	out	0x3f, r0	; 63
    32e0:	df 91       	pop	r29
    32e2:	cf 91       	pop	r28
    32e4:	08 95       	ret

000032e6 <vTaskMissedYield>:
    32e6:	81 e0       	ldi	r24, 0x01	; 1
    32e8:	80 93 65 04 	sts	0x0465, r24	; 0x800465 <xYieldPending>
    32ec:	08 95       	ret

000032ee <xTaskGetSchedulerState>:
    32ee:	80 91 67 04 	lds	r24, 0x0467	; 0x800467 <xSchedulerRunning>
    32f2:	88 23       	and	r24, r24
    32f4:	31 f0       	breq	.+12     	; 0x3302 <xTaskGetSchedulerState+0x14>
    32f6:	80 91 5e 04 	lds	r24, 0x045E	; 0x80045e <uxSchedulerSuspended>
    32fa:	88 23       	and	r24, r24
    32fc:	21 f0       	breq	.+8      	; 0x3306 <xTaskGetSchedulerState+0x18>
    32fe:	80 e0       	ldi	r24, 0x00	; 0
    3300:	08 95       	ret
    3302:	81 e0       	ldi	r24, 0x01	; 1
    3304:	08 95       	ret
    3306:	82 e0       	ldi	r24, 0x02	; 2
    3308:	08 95       	ret

0000330a <xTaskPriorityDisinherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

    BaseType_t xTaskPriorityDisinherit( TaskHandle_t const pxMutexHolder )
    {
    330a:	0f 93       	push	r16
    330c:	1f 93       	push	r17
    330e:	cf 93       	push	r28
    3310:	df 93       	push	r29
    3312:	fc 01       	movw	r30, r24
    TCB_t * const pxTCB = pxMutexHolder;
    BaseType_t xReturn = pdFALSE;

        if( pxMutexHolder != NULL )
    3314:	89 2b       	or	r24, r25
    3316:	11 f4       	brne	.+4      	; 0x331c <xTaskPriorityDisinherit+0x12>
#if ( configUSE_MUTEXES == 1 )

    BaseType_t xTaskPriorityDisinherit( TaskHandle_t const pxMutexHolder )
    {
    TCB_t * const pxTCB = pxMutexHolder;
    BaseType_t xReturn = pdFALSE;
    3318:	80 e0       	ldi	r24, 0x00	; 0
    331a:	2c c0       	rjmp	.+88     	; 0x3374 <xTaskPriorityDisinherit+0x6a>
            If the mutex is held by a task then it cannot be given from an
            interrupt, and if a mutex is given by the holding task then it must
            be the running state task. */
            configASSERT( pxTCB == pxCurrentTCB );
            configASSERT( pxTCB->uxMutexesHeld );
            ( pxTCB->uxMutexesHeld )--;
    331c:	82 a1       	ldd	r24, Z+34	; 0x22
    331e:	81 50       	subi	r24, 0x01	; 1
    3320:	82 a3       	std	Z+34, r24	; 0x22

            /* Has the holder of the mutex inherited the priority of another
            task? */
            if( pxTCB->uxPriority != pxTCB->uxBasePriority )
    3322:	26 89       	ldd	r18, Z+22	; 0x16
    3324:	91 a1       	ldd	r25, Z+33	; 0x21
    3326:	29 17       	cp	r18, r25
    3328:	b9 f3       	breq	.-18     	; 0x3318 <xTaskPriorityDisinherit+0xe>
            {
                /* Only disinherit if no other mutexes are held. */
                if( pxTCB->uxMutexesHeld == ( UBaseType_t ) 0 )
    332a:	81 11       	cpse	r24, r1
    332c:	f5 cf       	rjmp	.-22     	; 0x3318 <xTaskPriorityDisinherit+0xe>
    332e:	ef 01       	movw	r28, r30
                    /* A task can only have an inherited priority if it holds
                    the mutex.  If the mutex is held by a task then it cannot be
                    given from an interrupt, and if a mutex is given by the
                    holding task then it must be the running state task.  Remove
                    the holding task from the ready list. */
                    if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    3330:	8f 01       	movw	r16, r30
    3332:	0e 5f       	subi	r16, 0xFE	; 254
    3334:	1f 4f       	sbci	r17, 0xFF	; 255
    3336:	c8 01       	movw	r24, r16
    3338:	0e 94 93 1d 	call	0x3b26	; 0x3b26 <uxListRemove>
                    }

                    /* Disinherit the priority before adding the task into the
                    new    ready list. */
                    traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
                    pxTCB->uxPriority = pxTCB->uxBasePriority;
    333c:	89 a1       	ldd	r24, Y+33	; 0x21
    333e:	8e 8b       	std	Y+22, r24	; 0x16

                    /* Reset the event list item value.  It cannot be in use for
                    any other purpose if this task is running, and it must be
                    running to give back the mutex. */
                    listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    3340:	48 2f       	mov	r20, r24
    3342:	50 e0       	ldi	r21, 0x00	; 0
    3344:	24 e0       	ldi	r18, 0x04	; 4
    3346:	30 e0       	ldi	r19, 0x00	; 0
    3348:	24 1b       	sub	r18, r20
    334a:	35 0b       	sbc	r19, r21
    334c:	3d 87       	std	Y+13, r19	; 0x0d
    334e:	2c 87       	std	Y+12, r18	; 0x0c
                    prvAddTaskToReadyList( pxTCB );
    3350:	90 91 68 04 	lds	r25, 0x0468	; 0x800468 <uxTopReadyPriority>
    3354:	98 17       	cp	r25, r24
    3356:	10 f4       	brcc	.+4      	; 0x335c <xTaskPriorityDisinherit+0x52>
    3358:	80 93 68 04 	sts	0x0468, r24	; 0x800468 <uxTopReadyPriority>
    335c:	29 e0       	ldi	r18, 0x09	; 9
    335e:	24 9f       	mul	r18, r20
    3360:	c0 01       	movw	r24, r0
    3362:	25 9f       	mul	r18, r21
    3364:	90 0d       	add	r25, r0
    3366:	11 24       	eor	r1, r1
    3368:	b8 01       	movw	r22, r16
    336a:	82 56       	subi	r24, 0x62	; 98
    336c:	9b 4f       	sbci	r25, 0xFB	; 251
    336e:	0e 94 3a 1d 	call	0x3a74	; 0x3a74 <vListInsertEnd>
                    in an order different to that in which they were taken.
                    If a context switch did not occur when the first mutex was
                    returned, even if a task was waiting on it, then a context
                    switch should occur when the last mutex is returned whether
                    a task is waiting on it or not. */
                    xReturn = pdTRUE;
    3372:	81 e0       	ldi	r24, 0x01	; 1
        {
            mtCOVERAGE_TEST_MARKER();
        }

        return xReturn;
    }
    3374:	df 91       	pop	r29
    3376:	cf 91       	pop	r28
    3378:	1f 91       	pop	r17
    337a:	0f 91       	pop	r16
    337c:	08 95       	ret

0000337e <prvCheckForValidListAndQueue>:
            pxNewTimer->ucStatus = 0x00;
            prvInitialiseNewTimer( pcTimerName, xTimerPeriodInTicks, uxAutoReload, pvTimerID, pxCallbackFunction, pxNewTimer );
        }

        return pxNewTimer;
    }
    337e:	0f b6       	in	r0, 0x3f	; 63
    3380:	f8 94       	cli
    3382:	0f 92       	push	r0
    3384:	80 91 c8 04 	lds	r24, 0x04C8	; 0x8004c8 <xTimerQueue>
    3388:	90 91 c9 04 	lds	r25, 0x04C9	; 0x8004c9 <xTimerQueue+0x1>
    338c:	89 2b       	or	r24, r25
    338e:	e9 f4       	brne	.+58     	; 0x33ca <prvCheckForValidListAndQueue+0x4c>
    3390:	87 ed       	ldi	r24, 0xD7	; 215
    3392:	94 e0       	ldi	r25, 0x04	; 4
    3394:	0e 94 28 1d 	call	0x3a50	; 0x3a50 <vListInitialise>
    3398:	8e ec       	ldi	r24, 0xCE	; 206
    339a:	94 e0       	ldi	r25, 0x04	; 4
    339c:	0e 94 28 1d 	call	0x3a50	; 0x3a50 <vListInitialise>
    33a0:	87 ed       	ldi	r24, 0xD7	; 215
    33a2:	94 e0       	ldi	r25, 0x04	; 4
    33a4:	90 93 cd 04 	sts	0x04CD, r25	; 0x8004cd <pxCurrentTimerList+0x1>
    33a8:	80 93 cc 04 	sts	0x04CC, r24	; 0x8004cc <pxCurrentTimerList>
    33ac:	8e ec       	ldi	r24, 0xCE	; 206
    33ae:	94 e0       	ldi	r25, 0x04	; 4
    33b0:	90 93 cb 04 	sts	0x04CB, r25	; 0x8004cb <pxOverflowTimerList+0x1>
    33b4:	80 93 ca 04 	sts	0x04CA, r24	; 0x8004ca <pxOverflowTimerList>
    33b8:	40 e0       	ldi	r20, 0x00	; 0
    33ba:	65 e0       	ldi	r22, 0x05	; 5
    33bc:	8a e0       	ldi	r24, 0x0A	; 10
    33be:	0e 94 09 20 	call	0x4012	; 0x4012 <xQueueGenericCreate>
    33c2:	90 93 c9 04 	sts	0x04C9, r25	; 0x8004c9 <xTimerQueue+0x1>
    33c6:	80 93 c8 04 	sts	0x04C8, r24	; 0x8004c8 <xTimerQueue>
    33ca:	0f 90       	pop	r0
    33cc:	0f be       	out	0x3f, r0	; 63
    33ce:	08 95       	ret

000033d0 <prvInsertTimerInActiveList>:
    33d0:	fc 01       	movw	r30, r24
    33d2:	73 83       	std	Z+3, r23	; 0x03
    33d4:	62 83       	std	Z+2, r22	; 0x02
    33d6:	91 87       	std	Z+9, r25	; 0x09
    33d8:	80 87       	std	Z+8, r24	; 0x08
    33da:	46 17       	cp	r20, r22
    33dc:	57 07       	cpc	r21, r23
    33de:	78 f0       	brcs	.+30     	; 0x33fe <prvInsertTimerInActiveList+0x2e>
    33e0:	42 1b       	sub	r20, r18
    33e2:	53 0b       	sbc	r21, r19
    33e4:	84 85       	ldd	r24, Z+12	; 0x0c
    33e6:	95 85       	ldd	r25, Z+13	; 0x0d
    33e8:	48 17       	cp	r20, r24
    33ea:	59 07       	cpc	r21, r25
    33ec:	c8 f4       	brcc	.+50     	; 0x3420 <prvInsertTimerInActiveList+0x50>
    33ee:	bf 01       	movw	r22, r30
    33f0:	6e 5f       	subi	r22, 0xFE	; 254
    33f2:	7f 4f       	sbci	r23, 0xFF	; 255
    33f4:	80 91 ca 04 	lds	r24, 0x04CA	; 0x8004ca <pxOverflowTimerList>
    33f8:	90 91 cb 04 	lds	r25, 0x04CB	; 0x8004cb <pxOverflowTimerList+0x1>
    33fc:	0d c0       	rjmp	.+26     	; 0x3418 <prvInsertTimerInActiveList+0x48>
    33fe:	42 17       	cp	r20, r18
    3400:	53 07       	cpc	r21, r19
    3402:	18 f4       	brcc	.+6      	; 0x340a <prvInsertTimerInActiveList+0x3a>
    3404:	62 17       	cp	r22, r18
    3406:	73 07       	cpc	r23, r19
    3408:	58 f4       	brcc	.+22     	; 0x3420 <prvInsertTimerInActiveList+0x50>
    340a:	bf 01       	movw	r22, r30
    340c:	6e 5f       	subi	r22, 0xFE	; 254
    340e:	7f 4f       	sbci	r23, 0xFF	; 255
    3410:	80 91 cc 04 	lds	r24, 0x04CC	; 0x8004cc <pxCurrentTimerList>
    3414:	90 91 cd 04 	lds	r25, 0x04CD	; 0x8004cd <pxCurrentTimerList+0x1>
    3418:	0e 94 5b 1d 	call	0x3ab6	; 0x3ab6 <vListInsert>
    341c:	80 e0       	ldi	r24, 0x00	; 0
    341e:	08 95       	ret
    3420:	81 e0       	ldi	r24, 0x01	; 1
    3422:	08 95       	ret

00003424 <xTimerCreateTimerTask>:
    3424:	ef 92       	push	r14
    3426:	ff 92       	push	r15
    3428:	0f 93       	push	r16
    342a:	0e 94 bf 19 	call	0x337e	; 0x337e <prvCheckForValidListAndQueue>
    342e:	80 91 c8 04 	lds	r24, 0x04C8	; 0x8004c8 <xTimerQueue>
    3432:	90 91 c9 04 	lds	r25, 0x04C9	; 0x8004c9 <xTimerQueue+0x1>
    3436:	89 2b       	or	r24, r25
    3438:	81 f0       	breq	.+32     	; 0x345a <xTimerCreateTimerTask+0x36>
    343a:	86 ec       	ldi	r24, 0xC6	; 198
    343c:	e8 2e       	mov	r14, r24
    343e:	84 e0       	ldi	r24, 0x04	; 4
    3440:	f8 2e       	mov	r15, r24
    3442:	03 e0       	ldi	r16, 0x03	; 3
    3444:	20 e0       	ldi	r18, 0x00	; 0
    3446:	30 e0       	ldi	r19, 0x00	; 0
    3448:	45 e5       	ldi	r20, 0x55	; 85
    344a:	50 e0       	ldi	r21, 0x00	; 0
    344c:	6f e6       	ldi	r22, 0x6F	; 111
    344e:	72 e0       	ldi	r23, 0x02	; 2
    3450:	82 ec       	ldi	r24, 0xC2	; 194
    3452:	9a e1       	ldi	r25, 0x1A	; 26
    3454:	0e 94 88 15 	call	0x2b10	; 0x2b10 <xTaskCreate>
    3458:	01 c0       	rjmp	.+2      	; 0x345c <xTimerCreateTimerTask+0x38>
    345a:	80 e0       	ldi	r24, 0x00	; 0
    345c:	0f 91       	pop	r16
    345e:	ff 90       	pop	r15
    3460:	ef 90       	pop	r14
    3462:	08 95       	ret

00003464 <xTimerGenericCommand>:
    }
}
/*-----------------------------------------------------------*/

BaseType_t xTimerGenericCommand( TimerHandle_t xTimer, const BaseType_t xCommandID, const TickType_t xOptionalValue, BaseType_t * const pxHigherPriorityTaskWoken, const TickType_t xTicksToWait )
{
    3464:	0f 93       	push	r16
    3466:	1f 93       	push	r17
    3468:	cf 93       	push	r28
    346a:	df 93       	push	r29
    346c:	00 d0       	rcall	.+0      	; 0x346e <xTimerGenericCommand+0xa>
    346e:	00 d0       	rcall	.+0      	; 0x3470 <xTimerGenericCommand+0xc>
    3470:	1f 92       	push	r1
    3472:	cd b7       	in	r28, 0x3d	; 61
    3474:	de b7       	in	r29, 0x3e	; 62

    configASSERT( xTimer );

    /* Send a message to the timer service task to perform a particular action
    on a particular timer definition. */
    if( xTimerQueue != NULL )
    3476:	a0 91 c8 04 	lds	r26, 0x04C8	; 0x8004c8 <xTimerQueue>
    347a:	b0 91 c9 04 	lds	r27, 0x04C9	; 0x8004c9 <xTimerQueue+0x1>
    347e:	10 97       	sbiw	r26, 0x00	; 0
    3480:	29 f1       	breq	.+74     	; 0x34cc <xTimerGenericCommand+0x68>
    3482:	f9 01       	movw	r30, r18
    {
        /* Send a command to the timer service task to start the xTimer timer. */
        xMessage.xMessageID = xCommandID;
    3484:	69 83       	std	Y+1, r22	; 0x01
        xMessage.u.xTimerParameters.xMessageValue = xOptionalValue;
    3486:	5b 83       	std	Y+3, r21	; 0x03
    3488:	4a 83       	std	Y+2, r20	; 0x02
        xMessage.u.xTimerParameters.pxTimer = xTimer;
    348a:	9d 83       	std	Y+5, r25	; 0x05
    348c:	8c 83       	std	Y+4, r24	; 0x04

        if( xCommandID < tmrFIRST_FROM_ISR_COMMAND )
    348e:	66 30       	cpi	r22, 0x06	; 6
    3490:	a4 f4       	brge	.+40     	; 0x34ba <xTimerGenericCommand+0x56>
        {
            if( xTaskGetSchedulerState() == taskSCHEDULER_RUNNING )
    3492:	0e 94 77 19 	call	0x32ee	; 0x32ee <xTaskGetSchedulerState>
    3496:	e0 91 c8 04 	lds	r30, 0x04C8	; 0x8004c8 <xTimerQueue>
    349a:	f0 91 c9 04 	lds	r31, 0x04C9	; 0x8004c9 <xTimerQueue+0x1>
            {
                xReturn = xQueueSendToBack( xTimerQueue, &xMessage, xTicksToWait );
    349e:	20 e0       	ldi	r18, 0x00	; 0
        xMessage.u.xTimerParameters.xMessageValue = xOptionalValue;
        xMessage.u.xTimerParameters.pxTimer = xTimer;

        if( xCommandID < tmrFIRST_FROM_ISR_COMMAND )
        {
            if( xTaskGetSchedulerState() == taskSCHEDULER_RUNNING )
    34a0:	82 30       	cpi	r24, 0x02	; 2
    34a2:	11 f4       	brne	.+4      	; 0x34a8 <xTimerGenericCommand+0x44>
            {
                xReturn = xQueueSendToBack( xTimerQueue, &xMessage, xTicksToWait );
    34a4:	a8 01       	movw	r20, r16
    34a6:	02 c0       	rjmp	.+4      	; 0x34ac <xTimerGenericCommand+0x48>
            }
            else
            {
                xReturn = xQueueSendToBack( xTimerQueue, &xMessage, tmrNO_DELAY );
    34a8:	40 e0       	ldi	r20, 0x00	; 0
    34aa:	50 e0       	ldi	r21, 0x00	; 0
    34ac:	be 01       	movw	r22, r28
    34ae:	6f 5f       	subi	r22, 0xFF	; 255
    34b0:	7f 4f       	sbci	r23, 0xFF	; 255
    34b2:	cf 01       	movw	r24, r30
    34b4:	0e 94 31 20 	call	0x4062	; 0x4062 <xQueueGenericSend>
    34b8:	0a c0       	rjmp	.+20     	; 0x34ce <xTimerGenericCommand+0x6a>
            }
        }
        else
        {
            xReturn = xQueueSendToBackFromISR( xTimerQueue, &xMessage, pxHigherPriorityTaskWoken );
    34ba:	20 e0       	ldi	r18, 0x00	; 0
    34bc:	af 01       	movw	r20, r30
    34be:	be 01       	movw	r22, r28
    34c0:	6f 5f       	subi	r22, 0xFF	; 255
    34c2:	7f 4f       	sbci	r23, 0xFF	; 255
    34c4:	cd 01       	movw	r24, r26
    34c6:	0e 94 c7 20 	call	0x418e	; 0x418e <xQueueGenericSendFromISR>
    34ca:	01 c0       	rjmp	.+2      	; 0x34ce <xTimerGenericCommand+0x6a>
}
/*-----------------------------------------------------------*/

BaseType_t xTimerGenericCommand( TimerHandle_t xTimer, const BaseType_t xCommandID, const TickType_t xOptionalValue, BaseType_t * const pxHigherPriorityTaskWoken, const TickType_t xTicksToWait )
{
BaseType_t xReturn = pdFAIL;
    34cc:	80 e0       	ldi	r24, 0x00	; 0
    {
        mtCOVERAGE_TEST_MARKER();
    }

    return xReturn;
}
    34ce:	0f 90       	pop	r0
    34d0:	0f 90       	pop	r0
    34d2:	0f 90       	pop	r0
    34d4:	0f 90       	pop	r0
    34d6:	0f 90       	pop	r0
    34d8:	df 91       	pop	r29
    34da:	cf 91       	pop	r28
    34dc:	1f 91       	pop	r17
    34de:	0f 91       	pop	r16
    34e0:	08 95       	ret

000034e2 <prvSwitchTimerLists>:
    }
}
/*-----------------------------------------------------------*/

static void prvSwitchTimerLists( void )
{
    34e2:	ef 92       	push	r14
    34e4:	ff 92       	push	r15
    34e6:	0f 93       	push	r16
    34e8:	1f 93       	push	r17
    34ea:	cf 93       	push	r28
    34ec:	df 93       	push	r29

    /* The tick count has overflowed.  The timer lists must be switched.
    If there are any timers still referenced from the current timer list
    then they must have expired and should be processed before the lists
    are switched. */
    while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
    34ee:	e0 91 cc 04 	lds	r30, 0x04CC	; 0x8004cc <pxCurrentTimerList>
    34f2:	f0 91 cd 04 	lds	r31, 0x04CD	; 0x8004cd <pxCurrentTimerList+0x1>
    34f6:	80 81       	ld	r24, Z
    34f8:	88 23       	and	r24, r24
    34fa:	89 f1       	breq	.+98     	; 0x355e <prvSwitchTimerLists+0x7c>
    {
        xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
    34fc:	05 80       	ldd	r0, Z+5	; 0x05
    34fe:	f6 81       	ldd	r31, Z+6	; 0x06
    3500:	e0 2d       	mov	r30, r0
    3502:	e0 80       	ld	r14, Z
    3504:	f1 80       	ldd	r15, Z+1	; 0x01

        /* Remove the timer from the list. */
        pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList ); /*lint !e9087 !e9079 void * is used as this macro is used with tasks and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    3506:	c6 81       	ldd	r28, Z+6	; 0x06
    3508:	d7 81       	ldd	r29, Z+7	; 0x07
        ( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
    350a:	8e 01       	movw	r16, r28
    350c:	0e 5f       	subi	r16, 0xFE	; 254
    350e:	1f 4f       	sbci	r17, 0xFF	; 255
    3510:	c8 01       	movw	r24, r16
    3512:	0e 94 93 1d 	call	0x3b26	; 0x3b26 <uxListRemove>
        traceTIMER_EXPIRED( pxTimer );

        /* Execute its callback, then send a command to restart the timer if
        it is an auto-reload timer.  It cannot be restarted here as the lists
        have not yet been switched. */
        pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
    3516:	e8 89       	ldd	r30, Y+16	; 0x10
    3518:	f9 89       	ldd	r31, Y+17	; 0x11
    351a:	ce 01       	movw	r24, r28
    351c:	09 95       	icall

        if( ( pxTimer->ucStatus & tmrSTATUS_IS_AUTORELOAD ) != 0 )
    351e:	8a 89       	ldd	r24, Y+18	; 0x12
    3520:	82 ff       	sbrs	r24, 2
    3522:	e5 cf       	rjmp	.-54     	; 0x34ee <prvSwitchTimerLists+0xc>
            the timer going into the same timer list then it has already expired
            and the timer should be re-inserted into the current list so it is
            processed again within this loop.  Otherwise a command should be sent
            to restart the timer to ensure it is only inserted into a list after
            the lists have been swapped. */
            xReloadTime = ( xNextExpireTime + pxTimer->xTimerPeriodInTicks );
    3524:	8c 85       	ldd	r24, Y+12	; 0x0c
    3526:	9d 85       	ldd	r25, Y+13	; 0x0d
    3528:	8e 0d       	add	r24, r14
    352a:	9f 1d       	adc	r25, r15
            if( xReloadTime > xNextExpireTime )
    352c:	e8 16       	cp	r14, r24
    352e:	f9 06       	cpc	r15, r25
    3530:	60 f4       	brcc	.+24     	; 0x354a <prvSwitchTimerLists+0x68>
            {
                listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xReloadTime );
    3532:	9b 83       	std	Y+3, r25	; 0x03
    3534:	8a 83       	std	Y+2, r24	; 0x02
                listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
    3536:	d9 87       	std	Y+9, r29	; 0x09
    3538:	c8 87       	std	Y+8, r28	; 0x08
                vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
    353a:	b8 01       	movw	r22, r16
    353c:	80 91 cc 04 	lds	r24, 0x04CC	; 0x8004cc <pxCurrentTimerList>
    3540:	90 91 cd 04 	lds	r25, 0x04CD	; 0x8004cd <pxCurrentTimerList+0x1>
    3544:	0e 94 5b 1d 	call	0x3ab6	; 0x3ab6 <vListInsert>
    3548:	d2 cf       	rjmp	.-92     	; 0x34ee <prvSwitchTimerLists+0xc>
            }
            else
            {
                xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY );
    354a:	00 e0       	ldi	r16, 0x00	; 0
    354c:	10 e0       	ldi	r17, 0x00	; 0
    354e:	20 e0       	ldi	r18, 0x00	; 0
    3550:	30 e0       	ldi	r19, 0x00	; 0
    3552:	a7 01       	movw	r20, r14
    3554:	60 e0       	ldi	r22, 0x00	; 0
    3556:	ce 01       	movw	r24, r28
    3558:	0e 94 32 1a 	call	0x3464	; 0x3464 <xTimerGenericCommand>
    355c:	c8 cf       	rjmp	.-112    	; 0x34ee <prvSwitchTimerLists+0xc>
            mtCOVERAGE_TEST_MARKER();
        }
    }

    pxTemp = pxCurrentTimerList;
    pxCurrentTimerList = pxOverflowTimerList;
    355e:	80 91 ca 04 	lds	r24, 0x04CA	; 0x8004ca <pxOverflowTimerList>
    3562:	90 91 cb 04 	lds	r25, 0x04CB	; 0x8004cb <pxOverflowTimerList+0x1>
    3566:	90 93 cd 04 	sts	0x04CD, r25	; 0x8004cd <pxCurrentTimerList+0x1>
    356a:	80 93 cc 04 	sts	0x04CC, r24	; 0x8004cc <pxCurrentTimerList>
    pxOverflowTimerList = pxTemp;
    356e:	f0 93 cb 04 	sts	0x04CB, r31	; 0x8004cb <pxOverflowTimerList+0x1>
    3572:	e0 93 ca 04 	sts	0x04CA, r30	; 0x8004ca <pxOverflowTimerList>
}
    3576:	df 91       	pop	r29
    3578:	cf 91       	pop	r28
    357a:	1f 91       	pop	r17
    357c:	0f 91       	pop	r16
    357e:	ff 90       	pop	r15
    3580:	ef 90       	pop	r14
    3582:	08 95       	ret

00003584 <prvTimerTask>:
    pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
}
/*-----------------------------------------------------------*/

static portTASK_FUNCTION( prvTimerTask, pvParameters )
{
    3584:	cf 93       	push	r28
    3586:	df 93       	push	r29
    3588:	00 d0       	rcall	.+0      	; 0x358a <prvTimerTask+0x6>
    358a:	00 d0       	rcall	.+0      	; 0x358c <prvTimerTask+0x8>
    358c:	1f 92       	push	r1
    358e:	cd b7       	in	r28, 0x3d	; 61
    3590:	de b7       	in	r29, 0x3e	; 62
    the timer with the nearest expiry time will expire.  If there are no
    active timers then just set the next expire time to 0.  That will cause
    this task to unblock when the tick count overflows, at which point the
    timer lists will be switched and the next expiry time can be
    re-assessed.  */
    *pxListWasEmpty = listLIST_IS_EMPTY( pxCurrentTimerList );
    3592:	e0 91 cc 04 	lds	r30, 0x04CC	; 0x8004cc <pxCurrentTimerList>
    3596:	f0 91 cd 04 	lds	r31, 0x04CD	; 0x8004cd <pxCurrentTimerList+0x1>
    359a:	d0 80       	ld	r13, Z
    if( *pxListWasEmpty == pdFALSE )
    359c:	dd 20       	and	r13, r13
    359e:	31 f0       	breq	.+12     	; 0x35ac <prvTimerTask+0x28>
    {
        xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
    35a0:	05 80       	ldd	r0, Z+5	; 0x05
    35a2:	f6 81       	ldd	r31, Z+6	; 0x06
    35a4:	e0 2d       	mov	r30, r0
    35a6:	e0 80       	ld	r14, Z
    35a8:	f1 80       	ldd	r15, Z+1	; 0x01
    35aa:	02 c0       	rjmp	.+4      	; 0x35b0 <prvTimerTask+0x2c>
    }
    else
    {
        /* Ensure the task unblocks when the tick count rolls over. */
        xNextExpireTime = ( TickType_t ) 0U;
    35ac:	e1 2c       	mov	r14, r1
    35ae:	f1 2c       	mov	r15, r1
static void prvProcessTimerOrBlockTask( const TickType_t xNextExpireTime, BaseType_t xListWasEmpty )
{
TickType_t xTimeNow;
BaseType_t xTimerListsWereSwitched;

    vTaskSuspendAll();
    35b0:	0e 94 0b 17 	call	0x2e16	; 0x2e16 <vTaskSuspendAll>
static TickType_t prvSampleTimeNow( BaseType_t * const pxTimerListsWereSwitched )
{
TickType_t xTimeNow;
PRIVILEGED_DATA static TickType_t xLastTime = ( TickType_t ) 0U; /*lint !e956 Variable is only accessible to one task. */

    xTimeNow = xTaskGetTickCount();
    35b4:	0e 94 11 17 	call	0x2e22	; 0x2e22 <xTaskGetTickCount>
    35b8:	8c 01       	movw	r16, r24

    if( xTimeNow < xLastTime )
    35ba:	80 91 c4 04 	lds	r24, 0x04C4	; 0x8004c4 <xLastTime.2412>
    35be:	90 91 c5 04 	lds	r25, 0x04C5	; 0x8004c5 <xLastTime.2412+0x1>
    35c2:	08 17       	cp	r16, r24
    35c4:	19 07       	cpc	r17, r25
    35c6:	20 f4       	brcc	.+8      	; 0x35d0 <prvTimerTask+0x4c>
    {
        prvSwitchTimerLists();
    35c8:	0e 94 71 1a 	call	0x34e2	; 0x34e2 <prvSwitchTimerLists>
        *pxTimerListsWereSwitched = pdTRUE;
    35cc:	81 e0       	ldi	r24, 0x01	; 1
    35ce:	01 c0       	rjmp	.+2      	; 0x35d2 <prvTimerTask+0x4e>
    }
    else
    {
        *pxTimerListsWereSwitched = pdFALSE;
    35d0:	80 e0       	ldi	r24, 0x00	; 0
    }

    xLastTime = xTimeNow;
    35d2:	10 93 c5 04 	sts	0x04C5, r17	; 0x8004c5 <xLastTime.2412+0x1>
    35d6:	00 93 c4 04 	sts	0x04C4, r16	; 0x8004c4 <xLastTime.2412>
        has expired or not.  If obtaining the time causes the lists to switch
        then don't process this timer as any timers that remained in the list
        when the lists were switched will have been processed within the
        prvSampleTimeNow() function. */
        xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
        if( xTimerListsWereSwitched == pdFALSE )
    35da:	81 11       	cpse	r24, r1
    35dc:	55 c0       	rjmp	.+170    	; 0x3688 <prvTimerTask+0x104>
        {
            /* The tick count has not overflowed, has the timer expired? */
            if( ( xListWasEmpty == pdFALSE ) && ( xNextExpireTime <= xTimeNow ) )
    35de:	dd 20       	and	r13, r13
    35e0:	d9 f1       	breq	.+118    	; 0x3658 <prvTimerTask+0xd4>
    35e2:	0e 15       	cp	r16, r14
    35e4:	1f 05       	cpc	r17, r15
    35e6:	08 f4       	brcc	.+2      	; 0x35ea <prvTimerTask+0x66>
    35e8:	3e c0       	rjmp	.+124    	; 0x3666 <prvTimerTask+0xe2>
            {
                ( void ) xTaskResumeAll();
    35ea:	0e 94 c7 17 	call	0x2f8e	; 0x2f8e <xTaskResumeAll>
/*-----------------------------------------------------------*/

static void prvProcessExpiredTimer( const TickType_t xNextExpireTime, const TickType_t xTimeNow )
{
BaseType_t xResult;
Timer_t * const pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList ); /*lint !e9087 !e9079 void * is used as this macro is used with tasks and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    35ee:	e0 91 cc 04 	lds	r30, 0x04CC	; 0x8004cc <pxCurrentTimerList>
    35f2:	f0 91 cd 04 	lds	r31, 0x04CD	; 0x8004cd <pxCurrentTimerList+0x1>
    35f6:	05 80       	ldd	r0, Z+5	; 0x05
    35f8:	f6 81       	ldd	r31, Z+6	; 0x06
    35fa:	e0 2d       	mov	r30, r0
    35fc:	c6 80       	ldd	r12, Z+6	; 0x06
    35fe:	d7 80       	ldd	r13, Z+7	; 0x07

    /* Remove the timer from the list of active timers.  A check has already
    been performed to ensure the list is not empty. */
    ( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
    3600:	c6 01       	movw	r24, r12
    3602:	02 96       	adiw	r24, 0x02	; 2
    3604:	0e 94 93 1d 	call	0x3b26	; 0x3b26 <uxListRemove>
    traceTIMER_EXPIRED( pxTimer );

    /* If the timer is an auto reload timer then calculate the next
    expiry time and re-insert the timer in the list of active timers. */
    if( ( pxTimer->ucStatus & tmrSTATUS_IS_AUTORELOAD ) != 0 )
    3608:	d6 01       	movw	r26, r12
    360a:	52 96       	adiw	r26, 0x12	; 18
    360c:	8c 91       	ld	r24, X
    360e:	52 97       	sbiw	r26, 0x12	; 18
    3610:	82 ff       	sbrs	r24, 2
    3612:	17 c0       	rjmp	.+46     	; 0x3642 <prvTimerTask+0xbe>
    {
        /* The timer is inserted into a list using a time relative to anything
        other than the current time.  It will therefore be inserted into the
        correct list relative to the time this task thinks it is now. */
        if( prvInsertTimerInActiveList( pxTimer, ( xNextExpireTime + pxTimer->xTimerPeriodInTicks ), xTimeNow, xNextExpireTime ) != pdFALSE )
    3614:	1c 96       	adiw	r26, 0x0c	; 12
    3616:	6d 91       	ld	r22, X+
    3618:	7c 91       	ld	r23, X
    361a:	1d 97       	sbiw	r26, 0x0d	; 13
    361c:	6e 0d       	add	r22, r14
    361e:	7f 1d       	adc	r23, r15
    3620:	97 01       	movw	r18, r14
    3622:	a8 01       	movw	r20, r16
    3624:	c6 01       	movw	r24, r12
    3626:	0e 94 e8 19 	call	0x33d0	; 0x33d0 <prvInsertTimerInActiveList>
    362a:	88 23       	and	r24, r24
    362c:	69 f0       	breq	.+26     	; 0x3648 <prvTimerTask+0xc4>
        {
            /* The timer expired before it was added to the active timer
            list.  Reload it now.  */
            xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY );
    362e:	00 e0       	ldi	r16, 0x00	; 0
    3630:	10 e0       	ldi	r17, 0x00	; 0
    3632:	20 e0       	ldi	r18, 0x00	; 0
    3634:	30 e0       	ldi	r19, 0x00	; 0
    3636:	a7 01       	movw	r20, r14
    3638:	60 e0       	ldi	r22, 0x00	; 0
    363a:	c6 01       	movw	r24, r12
    363c:	0e 94 32 1a 	call	0x3464	; 0x3464 <xTimerGenericCommand>
    3640:	03 c0       	rjmp	.+6      	; 0x3648 <prvTimerTask+0xc4>
            mtCOVERAGE_TEST_MARKER();
        }
    }
    else
    {
        pxTimer->ucStatus &= ~tmrSTATUS_IS_ACTIVE;
    3642:	8e 7f       	andi	r24, 0xFE	; 254
    3644:	f6 01       	movw	r30, r12
    3646:	82 8b       	std	Z+18, r24	; 0x12
        mtCOVERAGE_TEST_MARKER();
    }

    /* Call the timer callback. */
    pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
    3648:	d6 01       	movw	r26, r12
    364a:	50 96       	adiw	r26, 0x10	; 16
    364c:	ed 91       	ld	r30, X+
    364e:	fc 91       	ld	r31, X
    3650:	51 97       	sbiw	r26, 0x11	; 17
    3652:	c6 01       	movw	r24, r12
    3654:	09 95       	icall
    3656:	1e c0       	rjmp	.+60     	; 0x3694 <prvTimerTask+0x110>
                case when the current timer list is empty. */
                if( xListWasEmpty != pdFALSE )
                {
                    /* The current timer list is empty - is the overflow list
                    also empty? */
                    xListWasEmpty = listLIST_IS_EMPTY( pxOverflowTimerList );
    3658:	e0 91 ca 04 	lds	r30, 0x04CA	; 0x8004ca <pxOverflowTimerList>
    365c:	f0 91 cb 04 	lds	r31, 0x04CB	; 0x8004cb <pxOverflowTimerList+0x1>
    3660:	80 81       	ld	r24, Z
    3662:	41 e0       	ldi	r20, 0x01	; 1
    3664:	81 11       	cpse	r24, r1
        prvSampleTimeNow() function. */
        xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
        if( xTimerListsWereSwitched == pdFALSE )
        {
            /* The tick count has not overflowed, has the timer expired? */
            if( ( xListWasEmpty == pdFALSE ) && ( xNextExpireTime <= xTimeNow ) )
    3666:	40 e0       	ldi	r20, 0x00	; 0
                    /* The current timer list is empty - is the overflow list
                    also empty? */
                    xListWasEmpty = listLIST_IS_EMPTY( pxOverflowTimerList );
                }

                vQueueWaitForMessageRestricted( xTimerQueue, ( xNextExpireTime - xTimeNow ), xListWasEmpty );
    3668:	b7 01       	movw	r22, r14
    366a:	60 1b       	sub	r22, r16
    366c:	71 0b       	sbc	r23, r17
    366e:	80 91 c8 04 	lds	r24, 0x04C8	; 0x8004c8 <xTimerQueue>
    3672:	90 91 c9 04 	lds	r25, 0x04C9	; 0x8004c9 <xTimerQueue+0x1>
    3676:	0e 94 88 21 	call	0x4310	; 0x4310 <vQueueWaitForMessageRestricted>

                if( xTaskResumeAll() == pdFALSE )
    367a:	0e 94 c7 17 	call	0x2f8e	; 0x2f8e <xTaskResumeAll>
    367e:	81 11       	cpse	r24, r1
    3680:	09 c0       	rjmp	.+18     	; 0x3694 <prvTimerTask+0x110>
                {
                    /* Yield to wait for either a command to arrive, or the
                    block time to expire.  If a command arrived between the
                    critical section being exited and this yield then the yield
                    will not cause the task to block. */
                    portYIELD_WITHIN_API();
    3682:	0e 94 5b 1e 	call	0x3cb6	; 0x3cb6 <vPortYield>
    3686:	06 c0       	rjmp	.+12     	; 0x3694 <prvTimerTask+0x110>
                }
            }
        }
        else
        {
            ( void ) xTaskResumeAll();
    3688:	0e 94 c7 17 	call	0x2f8e	; 0x2f8e <xTaskResumeAll>
    368c:	03 c0       	rjmp	.+6      	; 0x3694 <prvTimerTask+0x110>
        }
        #endif /* INCLUDE_xTimerPendFunctionCall */

        /* Commands that are positive are timer commands rather than pended
        function calls. */
        if( xMessage.xMessageID >= ( BaseType_t ) 0 )
    368e:	89 81       	ldd	r24, Y+1	; 0x01
    3690:	87 ff       	sbrs	r24, 7
    3692:	0e c0       	rjmp	.+28     	; 0x36b0 <prvTimerTask+0x12c>
DaemonTaskMessage_t xMessage;
Timer_t *pxTimer;
BaseType_t xTimerListsWereSwitched, xResult;
TickType_t xTimeNow;

    while( xQueueReceive( xTimerQueue, &xMessage, tmrNO_DELAY ) != pdFAIL ) /*lint !e603 xMessage does not have to be initialised as it is passed out, not in, and it is not used unless xQueueReceive() returns pdTRUE. */
    3694:	40 e0       	ldi	r20, 0x00	; 0
    3696:	50 e0       	ldi	r21, 0x00	; 0
    3698:	be 01       	movw	r22, r28
    369a:	6f 5f       	subi	r22, 0xFF	; 255
    369c:	7f 4f       	sbci	r23, 0xFF	; 255
    369e:	80 91 c8 04 	lds	r24, 0x04C8	; 0x8004c8 <xTimerQueue>
    36a2:	90 91 c9 04 	lds	r25, 0x04C9	; 0x8004c9 <xTimerQueue+0x1>
    36a6:	0e 94 f6 20 	call	0x41ec	; 0x41ec <xQueueReceive>
    36aa:	81 11       	cpse	r24, r1
    36ac:	f0 cf       	rjmp	.-32     	; 0x368e <prvTimerTask+0x10a>
    36ae:	71 cf       	rjmp	.-286    	; 0x3592 <prvTimerTask+0xe>
        function calls. */
        if( xMessage.xMessageID >= ( BaseType_t ) 0 )
        {
            /* The messages uses the xTimerParameters member to work on a
            software timer. */
            pxTimer = xMessage.u.xTimerParameters.pxTimer;
    36b0:	ec 80       	ldd	r14, Y+4	; 0x04
    36b2:	fd 80       	ldd	r15, Y+5	; 0x05

        if( listIS_CONTAINED_WITHIN( NULL, &( pxTimer->xTimerListItem ) ) == pdFALSE ) /*lint !e961. The cast is only redundant when NULL is passed into the macro. */
    36b4:	f7 01       	movw	r30, r14
    36b6:	82 85       	ldd	r24, Z+10	; 0x0a
    36b8:	93 85       	ldd	r25, Z+11	; 0x0b
    36ba:	89 2b       	or	r24, r25
    36bc:	21 f0       	breq	.+8      	; 0x36c6 <prvTimerTask+0x142>
            {
                /* The timer is in a list, remove it. */
                ( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
    36be:	c7 01       	movw	r24, r14
    36c0:	02 96       	adiw	r24, 0x02	; 2
    36c2:	0e 94 93 1d 	call	0x3b26	; 0x3b26 <uxListRemove>
static TickType_t prvSampleTimeNow( BaseType_t * const pxTimerListsWereSwitched )
{
TickType_t xTimeNow;
PRIVILEGED_DATA static TickType_t xLastTime = ( TickType_t ) 0U; /*lint !e956 Variable is only accessible to one task. */

    xTimeNow = xTaskGetTickCount();
    36c6:	0e 94 11 17 	call	0x2e22	; 0x2e22 <xTaskGetTickCount>
    36ca:	6c 01       	movw	r12, r24

    if( xTimeNow < xLastTime )
    36cc:	80 91 c4 04 	lds	r24, 0x04C4	; 0x8004c4 <xLastTime.2412>
    36d0:	90 91 c5 04 	lds	r25, 0x04C5	; 0x8004c5 <xLastTime.2412+0x1>
    36d4:	c8 16       	cp	r12, r24
    36d6:	d9 06       	cpc	r13, r25
    36d8:	10 f4       	brcc	.+4      	; 0x36de <prvTimerTask+0x15a>
    {
        prvSwitchTimerLists();
    36da:	0e 94 71 1a 	call	0x34e2	; 0x34e2 <prvSwitchTimerLists>
    else
    {
        *pxTimerListsWereSwitched = pdFALSE;
    }

    xLastTime = xTimeNow;
    36de:	d0 92 c5 04 	sts	0x04C5, r13	; 0x8004c5 <xLastTime.2412+0x1>
    36e2:	c0 92 c4 04 	sts	0x04C4, r12	; 0x8004c4 <xLastTime.2412>
            possibility of a higher priority task adding a message to the message
            queue with a time that is ahead of the timer daemon task (because it
            pre-empted the timer daemon task after the xTimeNow value was set). */
            xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );

            switch( xMessage.xMessageID )
    36e6:	e9 81       	ldd	r30, Y+1	; 0x01
    36e8:	0e 2e       	mov	r0, r30
    36ea:	00 0c       	add	r0, r0
    36ec:	ff 0b       	sbc	r31, r31
    36ee:	ea 30       	cpi	r30, 0x0A	; 10
    36f0:	f1 05       	cpc	r31, r1
    36f2:	80 f6       	brcc	.-96     	; 0x3694 <prvTimerTask+0x110>
    36f4:	ec 5c       	subi	r30, 0xCC	; 204
    36f6:	ff 4f       	sbci	r31, 0xFF	; 255
    36f8:	d7 01       	movw	r26, r14
    36fa:	52 96       	adiw	r26, 0x12	; 18
    36fc:	8c 91       	ld	r24, X
    36fe:	0c 94 fe 21 	jmp	0x43fc	; 0x43fc <__tablejump2__>
                case tmrCOMMAND_START_FROM_ISR :
                case tmrCOMMAND_RESET :
                case tmrCOMMAND_RESET_FROM_ISR :
                case tmrCOMMAND_START_DONT_TRACE :
                    /* Start or restart a timer. */
                    pxTimer->ucStatus |= tmrSTATUS_IS_ACTIVE;
    3702:	81 60       	ori	r24, 0x01	; 1
    3704:	f7 01       	movw	r30, r14
    3706:	82 8b       	std	Z+18, r24	; 0x12
                    if( prvInsertTimerInActiveList( pxTimer,  xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, xTimeNow, xMessage.u.xTimerParameters.xMessageValue ) != pdFALSE )
    3708:	2a 81       	ldd	r18, Y+2	; 0x02
    370a:	3b 81       	ldd	r19, Y+3	; 0x03
    370c:	64 85       	ldd	r22, Z+12	; 0x0c
    370e:	75 85       	ldd	r23, Z+13	; 0x0d
    3710:	62 0f       	add	r22, r18
    3712:	73 1f       	adc	r23, r19
    3714:	a6 01       	movw	r20, r12
    3716:	c7 01       	movw	r24, r14
    3718:	0e 94 e8 19 	call	0x33d0	; 0x33d0 <prvInsertTimerInActiveList>
    371c:	88 23       	and	r24, r24
    371e:	09 f4       	brne	.+2      	; 0x3722 <prvTimerTask+0x19e>
    3720:	b9 cf       	rjmp	.-142    	; 0x3694 <prvTimerTask+0x110>
                    {
                        /* The timer expired before it was added to the active
                        timer list.  Process it now. */
                        pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
    3722:	d7 01       	movw	r26, r14
    3724:	50 96       	adiw	r26, 0x10	; 16
    3726:	ed 91       	ld	r30, X+
    3728:	fc 91       	ld	r31, X
    372a:	51 97       	sbiw	r26, 0x11	; 17
    372c:	c7 01       	movw	r24, r14
    372e:	09 95       	icall
                        traceTIMER_EXPIRED( pxTimer );

                        if( ( pxTimer->ucStatus & tmrSTATUS_IS_AUTORELOAD ) != 0 )
    3730:	f7 01       	movw	r30, r14
    3732:	82 89       	ldd	r24, Z+18	; 0x12
    3734:	82 ff       	sbrs	r24, 2
    3736:	ae cf       	rjmp	.-164    	; 0x3694 <prvTimerTask+0x110>
                        {
                            xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, NULL, tmrNO_DELAY );
    3738:	4a 81       	ldd	r20, Y+2	; 0x02
    373a:	5b 81       	ldd	r21, Y+3	; 0x03
    373c:	84 85       	ldd	r24, Z+12	; 0x0c
    373e:	95 85       	ldd	r25, Z+13	; 0x0d
    3740:	48 0f       	add	r20, r24
    3742:	59 1f       	adc	r21, r25
    3744:	00 e0       	ldi	r16, 0x00	; 0
    3746:	10 e0       	ldi	r17, 0x00	; 0
    3748:	20 e0       	ldi	r18, 0x00	; 0
    374a:	30 e0       	ldi	r19, 0x00	; 0
    374c:	60 e0       	ldi	r22, 0x00	; 0
    374e:	c7 01       	movw	r24, r14
    3750:	0e 94 32 1a 	call	0x3464	; 0x3464 <xTimerGenericCommand>
    3754:	9f cf       	rjmp	.-194    	; 0x3694 <prvTimerTask+0x110>
                    pxTimer->ucStatus &= ~tmrSTATUS_IS_ACTIVE;
                    break;

                case tmrCOMMAND_CHANGE_PERIOD :
                case tmrCOMMAND_CHANGE_PERIOD_FROM_ISR :
                    pxTimer->ucStatus |= tmrSTATUS_IS_ACTIVE;
    3756:	81 60       	ori	r24, 0x01	; 1
    3758:	f7 01       	movw	r30, r14
    375a:	82 8b       	std	Z+18, r24	; 0x12
                    pxTimer->xTimerPeriodInTicks = xMessage.u.xTimerParameters.xMessageValue;
    375c:	6a 81       	ldd	r22, Y+2	; 0x02
    375e:	7b 81       	ldd	r23, Y+3	; 0x03
    3760:	75 87       	std	Z+13, r23	; 0x0d
    3762:	64 87       	std	Z+12, r22	; 0x0c
                    be longer or shorter than the old one.  The command time is
                    therefore set to the current time, and as the period cannot
                    be zero the next expiry time can only be in the future,
                    meaning (unlike for the xTimerStart() case above) there is
                    no fail case that needs to be handled here. */
                    ( void ) prvInsertTimerInActiveList( pxTimer, ( xTimeNow + pxTimer->xTimerPeriodInTicks ), xTimeNow, xTimeNow );
    3764:	6c 0d       	add	r22, r12
    3766:	7d 1d       	adc	r23, r13
    3768:	96 01       	movw	r18, r12
    376a:	a6 01       	movw	r20, r12
    376c:	c7 01       	movw	r24, r14
    376e:	0e 94 e8 19 	call	0x33d0	; 0x33d0 <prvInsertTimerInActiveList>
    3772:	90 cf       	rjmp	.-224    	; 0x3694 <prvTimerTask+0x110>
                    #if ( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
                    {
                    /* The timer has already been removed from the active list,
                    just free up the memory if the memory was dynamically
                    allocated. */
                        if( ( pxTimer->ucStatus & tmrSTATUS_IS_STATICALLY_ALLOCATED ) == ( uint8_t ) 0 )
    3774:	81 fd       	sbrc	r24, 1
    3776:	04 c0       	rjmp	.+8      	; 0x3780 <prvTimerTask+0x1fc>
                        {
                            vPortFree( pxTimer );
    3778:	c7 01       	movw	r24, r14
    377a:	0e 94 17 1d 	call	0x3a2e	; 0x3a2e <vPortFree>
    377e:	8a cf       	rjmp	.-236    	; 0x3694 <prvTimerTask+0x110>
                        }
                        else
                        {
                            pxTimer->ucStatus &= ~tmrSTATUS_IS_ACTIVE;
    3780:	8e 7f       	andi	r24, 0xFE	; 254
    3782:	d7 01       	movw	r26, r14
    3784:	52 96       	adiw	r26, 0x12	; 18
    3786:	8c 93       	st	X, r24
    3788:	85 cf       	rjmp	.-246    	; 0x3694 <prvTimerTask+0x110>

0000378a <initVariant>:
{
#if defined(USBCON)
    USBDevice.attach();
#endif

    setup();        // the normal Arduino setup() function is run here.
    378a:	0e 94 72 07 	call	0xee4	; 0xee4 <setup>
    vTaskStartScheduler(); // initialise and run the freeRTOS scheduler. Execution should never return here.
    378e:	0e 94 dd 16 	call	0x2dba	; 0x2dba <vTaskStartScheduler>
    3792:	08 95       	ret

00003794 <vApplicationIdleHook>:
 */
void vApplicationIdleHook( void ) __attribute__((weak));

void vApplicationIdleHook( void )
{
    loop();        // the normal Arduino loop() function is run here.
    3794:	0e 94 de 07 	call	0xfbc	; 0xfbc <loop>
    if (serialEventRun) serialEventRun();
    3798:	81 ea       	ldi	r24, 0xA1	; 161
    379a:	9e e0       	ldi	r25, 0x0E	; 14
    379c:	89 2b       	or	r24, r25
    379e:	11 f0       	breq	.+4      	; 0x37a4 <vApplicationIdleHook+0x10>
    37a0:	0c 94 a1 0e 	jmp	0x1d42	; 0x1d42 <_Z14serialEventRunv>
    37a4:	08 95       	ret

000037a6 <vApplicationMallocFailedHook>:
#elif defined(__AVR_ATmega644P__) || defined(__AVR_ATmega644PA__) || defined(__AVR_ATmega1284P__) || defined(__AVR_ATmega1284PA__) // Seeed Goldilocks with 1284p
    DDRB  |= _BV(DDB7);
    PORTB |= _BV(PORTB7);       // Main (red PB7) LED on. Main LED on.

#elif defined(__AVR_ATmega328P__) || defined(__AVR_ATmega168__) || defined(__AVR_ATmega8__) // assume we're using an Arduino Uno with 328p
    DDRB  |= _BV(DDB5);
    37a6:	25 9a       	sbi	0x04, 5	; 4
    PORTB |= _BV(PORTB5);       // Main (red PB5) LED on. Main LED on.
    37a8:	2d 9a       	sbi	0x05, 5	; 5
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    37aa:	2f ef       	ldi	r18, 0xFF	; 255
    37ac:	80 e7       	ldi	r24, 0x70	; 112
    37ae:	92 e0       	ldi	r25, 0x02	; 2
    37b0:	21 50       	subi	r18, 0x01	; 1
    37b2:	80 40       	sbci	r24, 0x00	; 0
    37b4:	90 40       	sbci	r25, 0x00	; 0
    37b6:	e1 f7       	brne	.-8      	; 0x37b0 <vApplicationMallocFailedHook+0xa>
    37b8:	00 c0       	rjmp	.+0      	; 0x37ba <vApplicationMallocFailedHook+0x14>
    37ba:	00 00       	nop

#elif defined(__AVR_ATmega644P__) || defined(__AVR_ATmega644PA__) || defined(__AVR_ATmega1284P__) || defined(__AVR_ATmega1284PA__) // Seeed Goldilocks with 1284p
        PINB  |= _BV(PINB7);       // Main (red PB7) LED toggle. Main LED fast blink.

#elif defined(__AVR_ATmega328P__) || defined(__AVR_ATmega168__) || defined(__AVR_ATmega8__) // assume we're using an Arduino Uno with 328p
        PINB  |= _BV(PINB5);       // Main (red PB5) LED toggle. Main LED fast blink.
    37bc:	1d 9a       	sbi	0x03, 5	; 3
    37be:	f5 cf       	rjmp	.-22     	; 0x37aa <vApplicationMallocFailedHook+0x4>

000037c0 <vApplicationStackOverflowHook>:
#elif defined(__AVR_ATmega644P__) || defined(__AVR_ATmega644PA__) || defined(__AVR_ATmega1284P__) || defined(__AVR_ATmega1284PA__) // Seeed Goldilocks with 1284p
    DDRB  |= _BV(DDB7);
    PORTB |= _BV(PORTB7);       // Main (red PB7) LED on. Main LED on.

#elif defined(__AVR_ATmega328P__) || defined(__AVR_ATmega168__) || defined(__AVR_ATmega8__) // assume we're using an Arduino Uno with 328p
    DDRB  |= _BV(DDB5);
    37c0:	25 9a       	sbi	0x04, 5	; 4
    PORTB |= _BV(PORTB5);       // Main (red PB5) LED on. Main LED on.
    37c2:	2d 9a       	sbi	0x05, 5	; 5
    37c4:	2f ef       	ldi	r18, 0xFF	; 255
    37c6:	87 ea       	ldi	r24, 0xA7	; 167
    37c8:	91 e6       	ldi	r25, 0x61	; 97
    37ca:	21 50       	subi	r18, 0x01	; 1
    37cc:	80 40       	sbci	r24, 0x00	; 0
    37ce:	90 40       	sbci	r25, 0x00	; 0
    37d0:	e1 f7       	brne	.-8      	; 0x37ca <vApplicationStackOverflowHook+0xa>
    37d2:	00 c0       	rjmp	.+0      	; 0x37d4 <vApplicationStackOverflowHook+0x14>
    37d4:	00 00       	nop

#elif defined(__AVR_ATmega644P__) || defined(__AVR_ATmega644PA__) || defined(__AVR_ATmega1284P__) || defined(__AVR_ATmega1284PA__) // Seeed Goldilocks with 1284p
        PINB  |= _BV(PINB7);       // Main (red PB7) LED toggle. Main LED slow blink.

#elif defined(__AVR_ATmega328P__) || defined(__AVR_ATmega168__) || defined(__AVR_ATmega8__) // assume we're using an Arduino Uno with 328p
        PINB  |= _BV(PINB5);       // Main (red PB5) LED toggle. Main LED slow blink.
    37d6:	1d 9a       	sbi	0x03, 5	; 3
    37d8:	f5 cf       	rjmp	.-22     	; 0x37c4 <vApplicationStackOverflowHook+0x4>

000037da <_ZN14FreqCountClass5beginEj>:
static uint16_t gate_index;


void FreqCountClass::begin(uint16_t msec)
{
	if (msec < 1) return;
    37da:	00 97       	sbiw	r24, 0x00	; 0
    37dc:	09 f4       	brne	.+2      	; 0x37e0 <_ZN14FreqCountClass5beginEj+0x6>
    37de:	74 c0       	rjmp	.+232    	; 0x38c8 <L_130_loop+0xc>
	gate_index = 0;
    37e0:	10 92 e1 04 	sts	0x04E1, r1	; 0x8004e1 <_ZL10gate_index+0x1>
    37e4:	10 92 e0 04 	sts	0x04E0, r1	; 0x8004e0 <_ZL10gate_index>
	count_msw = 0;
    37e8:	10 92 ee 04 	sts	0x04EE, r1	; 0x8004ee <_ZL9count_msw+0x1>
    37ec:	10 92 ed 04 	sts	0x04ED, r1	; 0x8004ed <_ZL9count_msw>
	count_prev = 0;
    37f0:	10 92 e9 04 	sts	0x04E9, r1	; 0x8004e9 <_ZL10count_prev>
    37f4:	10 92 ea 04 	sts	0x04EA, r1	; 0x8004ea <_ZL10count_prev+0x1>
    37f8:	10 92 eb 04 	sts	0x04EB, r1	; 0x8004eb <_ZL10count_prev+0x2>
    37fc:	10 92 ec 04 	sts	0x04EC, r1	; 0x8004ec <_ZL10count_prev+0x3>
	count_ready = 0;
    3800:	10 92 e4 04 	sts	0x04E4, r1	; 0x8004e4 <_ZL11count_ready>

static uint8_t saveTCCR1A, saveTCCR1B;

static inline void counter_init(void)
{
	saveTCCR1A = TCCR1A;
    3804:	20 91 80 00 	lds	r18, 0x0080	; 0x800080 <__DATA_REGION_ORIGIN__+0x20>
    3808:	20 93 f3 04 	sts	0x04F3, r18	; 0x8004f3 <_ZL10saveTCCR1A>
	saveTCCR1B = TCCR1B;
    380c:	20 91 81 00 	lds	r18, 0x0081	; 0x800081 <__DATA_REGION_ORIGIN__+0x21>
    3810:	20 93 f2 04 	sts	0x04F2, r18	; 0x8004f2 <_ZL10saveTCCR1B>
	TCCR1B = 0;
    3814:	10 92 81 00 	sts	0x0081, r1	; 0x800081 <__DATA_REGION_ORIGIN__+0x21>
	TCCR1A = 0;
    3818:	10 92 80 00 	sts	0x0080, r1	; 0x800080 <__DATA_REGION_ORIGIN__+0x20>
	TCNT1 = 0;
    381c:	10 92 85 00 	sts	0x0085, r1	; 0x800085 <__DATA_REGION_ORIGIN__+0x25>
    3820:	10 92 84 00 	sts	0x0084, r1	; 0x800084 <__DATA_REGION_ORIGIN__+0x24>
	TIFR1 = (1<<TOV1);
    3824:	21 e0       	ldi	r18, 0x01	; 1
    3826:	26 bb       	out	0x16, r18	; 22
	TIMSK1 = 0;
    3828:	10 92 6f 00 	sts	0x006F, r1	; 0x80006f <__DATA_REGION_ORIGIN__+0xf>

static inline uint16_t timer_init(uint16_t msec)
{
	uint16_t gate_len;

	saveTCCR2A = TCCR2A;
    382c:	20 91 b0 00 	lds	r18, 0x00B0	; 0x8000b0 <__DATA_REGION_ORIGIN__+0x50>
    3830:	20 93 f1 04 	sts	0x04F1, r18	; 0x8004f1 <_ZL10saveTCCR2A>
	saveTCCR2B = TCCR2B;
    3834:	20 91 b1 00 	lds	r18, 0x00B1	; 0x8000b1 <__DATA_REGION_ORIGIN__+0x51>
    3838:	20 93 f0 04 	sts	0x04F0, r18	; 0x8004f0 <_ZL10saveTCCR2B>
	TCCR2B = 0;
    383c:	10 92 b1 00 	sts	0x00B1, r1	; 0x8000b1 <__DATA_REGION_ORIGIN__+0x51>
	TCCR2A = (1<<WGM21);
    3840:	22 e0       	ldi	r18, 0x02	; 2
    3842:	20 93 b0 00 	sts	0x00B0, r18	; 0x8000b0 <__DATA_REGION_ORIGIN__+0x50>
	if ((msec & 7) == 0) {
    3846:	9c 01       	movw	r18, r24
    3848:	27 70       	andi	r18, 0x07	; 7
    384a:	33 27       	eor	r19, r19
    384c:	23 2b       	or	r18, r19
    384e:	51 f4       	brne	.+20     	; 0x3864 <_ZN14FreqCountClass5beginEj+0x8a>
		gate_len = msec >> 3;
    3850:	43 e0       	ldi	r20, 0x03	; 3
    3852:	96 95       	lsr	r25
    3854:	87 95       	ror	r24
    3856:	4a 95       	dec	r20
    3858:	e1 f7       	brne	.-8      	; 0x3852 <_ZN14FreqCountClass5beginEj+0x78>
		OCR2A = TIMER2_OCR2A_8MS_VAL;
    385a:	2c e7       	ldi	r18, 0x7C	; 124
    385c:	20 93 b3 00 	sts	0x00B3, r18	; 0x8000b3 <__DATA_REGION_ORIGIN__+0x53>
		startTCCR2B = TIMER2_TCCR2B_8MS_VAL;
    3860:	27 e0       	ldi	r18, 0x07	; 7
    3862:	18 c0       	rjmp	.+48     	; 0x3894 <_ZN14FreqCountClass5beginEj+0xba>
	} else if ((msec & 3) == 0) {
    3864:	9c 01       	movw	r18, r24
    3866:	23 70       	andi	r18, 0x03	; 3
    3868:	33 27       	eor	r19, r19
    386a:	23 2b       	or	r18, r19
    386c:	31 f4       	brne	.+12     	; 0x387a <_ZN14FreqCountClass5beginEj+0xa0>
		gate_len = msec >> 2;
    386e:	96 95       	lsr	r25
    3870:	87 95       	ror	r24
    3872:	96 95       	lsr	r25
    3874:	87 95       	ror	r24
		OCR2A = TIMER2_OCR2A_4MS_VAL;
    3876:	29 ef       	ldi	r18, 0xF9	; 249
    3878:	05 c0       	rjmp	.+10     	; 0x3884 <_ZN14FreqCountClass5beginEj+0xaa>
		startTCCR2B = TIMER2_TCCR2B_4MS_VAL;
	} else if ((msec & 1) == 0) {
    387a:	80 fd       	sbrc	r24, 0
    387c:	07 c0       	rjmp	.+14     	; 0x388c <_ZN14FreqCountClass5beginEj+0xb2>
		gate_len = msec >> 1;
    387e:	96 95       	lsr	r25
    3880:	87 95       	ror	r24
		OCR2A = TIMER2_OCR2A_2MS_VAL;
    3882:	2c e7       	ldi	r18, 0x7C	; 124
    3884:	20 93 b3 00 	sts	0x00B3, r18	; 0x8000b3 <__DATA_REGION_ORIGIN__+0x53>
		startTCCR2B = TIMER2_TCCR2B_2MS_VAL;
    3888:	26 e0       	ldi	r18, 0x06	; 6
    388a:	04 c0       	rjmp	.+8      	; 0x3894 <_ZN14FreqCountClass5beginEj+0xba>
	} else {
		gate_len = msec;
		OCR2A = TIMER2_OCR2A_1MS_VAL;
    388c:	2c e7       	ldi	r18, 0x7C	; 124
    388e:	20 93 b3 00 	sts	0x00B3, r18	; 0x8000b3 <__DATA_REGION_ORIGIN__+0x53>
		startTCCR2B = TIMER2_TCCR2B_1MS_VAL;
    3892:	25 e0       	ldi	r18, 0x05	; 5
    3894:	20 93 ef 04 	sts	0x04EF, r18	; 0x8004ef <_ZL11startTCCR2B>
	}
	TIFR2 = (1<<OCF2A);
    3898:	22 e0       	ldi	r18, 0x02	; 2
    389a:	27 bb       	out	0x17, r18	; 23
	TCNT2 = 0;
    389c:	10 92 b2 00 	sts	0x00B2, r1	; 0x8000b2 <__DATA_REGION_ORIGIN__+0x52>
	counter_init();
	gate_length = timer_init(msec);
    38a0:	90 93 e3 04 	sts	0x04E3, r25	; 0x8004e3 <_ZL11gate_length+0x1>
    38a4:	80 93 e2 04 	sts	0x04E2, r24	; 0x8004e2 <_ZL11gate_length>
	uint8_t status = SREG;
    38a8:	9f b7       	in	r25, 0x3f	; 63
	cli();
    38aa:	f8 94       	cli
	return gate_len;
}

static inline void timer_start(void)
{
	GTCCR = (1<<PSRASY);
    38ac:	23 bd       	out	0x23, r18	; 35
	TCCR2B = startTCCR2B;
    38ae:	80 91 ef 04 	lds	r24, 0x04EF	; 0x8004ef <_ZL11startTCCR2B>
    38b2:	80 93 b1 00 	sts	0x00B1, r24	; 0x8000b1 <__DATA_REGION_ORIGIN__+0x51>
	TIMSK2 = (1<<OCIE2A);
    38b6:	20 93 70 00 	sts	0x0070, r18	; 0x800070 <__DATA_REGION_ORIGIN__+0x10>
		"L_%=_loop:"
		"subi   %0, 1"		"\n\t"
		"brne   L_%=_loop"	"\n\t"
		: "+d" (cycles_times_3)
		: "0" (cycles_times_3)
	);
    38ba:	8b e0       	ldi	r24, 0x0B	; 11

000038bc <L_130_loop>:
    38bc:	81 50       	subi	r24, 0x01	; 1
    38be:	f1 f7       	brne	.-4      	; 0x38bc <L_130_loop>
	TIMSK1 = 0;
}

static inline void counter_start(void)
{
	TCCR1B = (1<<CS12) | (1<<CS11) | (1<<CS10);
    38c0:	87 e0       	ldi	r24, 0x07	; 7
    38c2:	80 93 81 00 	sts	0x0081, r24	; 0x800081 <__DATA_REGION_ORIGIN__+0x21>
	timer_start();
	timer_isr_latency_delay();
	counter_start();
	SREG = status;
    38c6:	9f bf       	out	0x3f, r25	; 63
    38c8:	08 95       	ret

000038ca <_ZN14FreqCountClass9availableEv>:
}

uint8_t FreqCountClass::available(void)
{
	return count_ready;
    38ca:	80 91 e4 04 	lds	r24, 0x04E4	; 0x8004e4 <_ZL11count_ready>
}
    38ce:	08 95       	ret

000038d0 <_ZN14FreqCountClass4readEv>:
uint32_t FreqCountClass::read(void)
{
	uint32_t count;
	uint8_t status;

	status = SREG;
    38d0:	2f b7       	in	r18, 0x3f	; 63
	cli();
    38d2:	f8 94       	cli
	count = count_output;
    38d4:	60 91 e5 04 	lds	r22, 0x04E5	; 0x8004e5 <_ZL12count_output>
    38d8:	70 91 e6 04 	lds	r23, 0x04E6	; 0x8004e6 <_ZL12count_output+0x1>
    38dc:	80 91 e7 04 	lds	r24, 0x04E7	; 0x8004e7 <_ZL12count_output+0x2>
    38e0:	90 91 e8 04 	lds	r25, 0x04E8	; 0x8004e8 <_ZL12count_output+0x3>
	count_ready = 0;
    38e4:	10 92 e4 04 	sts	0x04E4, r1	; 0x8004e4 <_ZL11count_ready>
	SREG = status;
    38e8:	2f bf       	out	0x3f, r18	; 63
	return count;
}
    38ea:	08 95       	ret

000038ec <_ZN14FreqCountClass3endEv>:
	TIMSK2 = (1<<OCIE2A);
}

static inline void timer_shutdown(void)
{
	TCCR2B = 0;
    38ec:	e1 eb       	ldi	r30, 0xB1	; 177
    38ee:	f0 e0       	ldi	r31, 0x00	; 0
    38f0:	10 82       	st	Z, r1
	TIMSK2 = 0;
    38f2:	10 92 70 00 	sts	0x0070, r1	; 0x800070 <__DATA_REGION_ORIGIN__+0x10>
	TCCR2A = saveTCCR2A;
    38f6:	80 91 f1 04 	lds	r24, 0x04F1	; 0x8004f1 <_ZL10saveTCCR2A>
    38fa:	80 93 b0 00 	sts	0x00B0, r24	; 0x8000b0 <__DATA_REGION_ORIGIN__+0x50>
	TCCR2B = saveTCCR2B;
    38fe:	80 91 f0 04 	lds	r24, 0x04F0	; 0x8004f0 <_ZL10saveTCCR2B>
    3902:	80 83       	st	Z, r24
	TCCR1B = (1<<CS12) | (1<<CS11) | (1<<CS10);
}

static inline void counter_shutdown(void)
{
	TCCR1B = 0;
    3904:	e1 e8       	ldi	r30, 0x81	; 129
    3906:	f0 e0       	ldi	r31, 0x00	; 0
    3908:	10 82       	st	Z, r1
	TCCR1A = saveTCCR1A;
    390a:	80 91 f3 04 	lds	r24, 0x04F3	; 0x8004f3 <_ZL10saveTCCR1A>
    390e:	80 93 80 00 	sts	0x0080, r24	; 0x800080 <__DATA_REGION_ORIGIN__+0x20>
	TCCR1B = saveTCCR1B;
    3912:	80 91 f2 04 	lds	r24, 0x04F2	; 0x8004f2 <_ZL10saveTCCR1B>
    3916:	80 83       	st	Z, r24
    3918:	08 95       	ret

0000391a <__vector_7>:
	counter_shutdown();
}


ISR(TIMER_ISR_VECTOR)
{
    391a:	1f 92       	push	r1
    391c:	0f 92       	push	r0
    391e:	0f b6       	in	r0, 0x3f	; 63
    3920:	0f 92       	push	r0
    3922:	11 24       	eor	r1, r1
    3924:	0f 93       	push	r16
    3926:	1f 93       	push	r17
    3928:	2f 93       	push	r18
    392a:	3f 93       	push	r19
    392c:	4f 93       	push	r20
    392e:	5f 93       	push	r21
    3930:	6f 93       	push	r22
    3932:	7f 93       	push	r23
    3934:	8f 93       	push	r24
    3936:	9f 93       	push	r25
    3938:	af 93       	push	r26
    393a:	bf 93       	push	r27
}

static inline uint16_t counter_read(void)
{
	return TCNT1;
    393c:	20 91 84 00 	lds	r18, 0x0084	; 0x800084 <__DATA_REGION_ORIGIN__+0x24>
    3940:	30 91 85 00 	lds	r19, 0x0085	; 0x800085 <__DATA_REGION_ORIGIN__+0x25>
	uint16_t count_lsw;
	uint32_t count;
	uint16_t index, length;

	count_lsw = counter_read();
	if (counter_overflow()) {
    3944:	b0 9b       	sbis	0x16, 0	; 22
    3946:	0b c0       	rjmp	.+22     	; 0x395e <__vector_7+0x44>
	return TIFR1 & (1<<TOV1);
}

static inline void counter_overflow_reset(void)
{
	TIFR1 = (1<<TOV1);
    3948:	81 e0       	ldi	r24, 0x01	; 1
    394a:	86 bb       	out	0x16, r24	; 22
		counter_overflow_reset();
		count_msw++;
    394c:	80 91 ed 04 	lds	r24, 0x04ED	; 0x8004ed <_ZL9count_msw>
    3950:	90 91 ee 04 	lds	r25, 0x04EE	; 0x8004ee <_ZL9count_msw+0x1>
    3954:	01 96       	adiw	r24, 0x01	; 1
    3956:	90 93 ee 04 	sts	0x04EE, r25	; 0x8004ee <_ZL9count_msw+0x1>
    395a:	80 93 ed 04 	sts	0x04ED, r24	; 0x8004ed <_ZL9count_msw>
	}
	index = gate_index + 1;
    395e:	80 91 e0 04 	lds	r24, 0x04E0	; 0x8004e0 <_ZL10gate_index>
    3962:	90 91 e1 04 	lds	r25, 0x04E1	; 0x8004e1 <_ZL10gate_index+0x1>
    3966:	01 96       	adiw	r24, 0x01	; 1
	length = gate_length;
	if (index >= length) {
    3968:	40 91 e2 04 	lds	r20, 0x04E2	; 0x8004e2 <_ZL11gate_length>
    396c:	50 91 e3 04 	lds	r21, 0x04E3	; 0x8004e3 <_ZL11gate_length+0x1>
    3970:	84 17       	cp	r24, r20
    3972:	95 07       	cpc	r25, r21
    3974:	98 f1       	brcs	.+102    	; 0x39dc <__vector_7+0xc2>
		gate_index = 0;
    3976:	10 92 e1 04 	sts	0x04E1, r1	; 0x8004e1 <_ZL10gate_index+0x1>
    397a:	10 92 e0 04 	sts	0x04E0, r1	; 0x8004e0 <_ZL10gate_index>
		count = ((uint32_t)count_msw << 16) + count_lsw;
    397e:	80 91 ed 04 	lds	r24, 0x04ED	; 0x8004ed <_ZL9count_msw>
    3982:	90 91 ee 04 	lds	r25, 0x04EE	; 0x8004ee <_ZL9count_msw+0x1>
    3986:	a0 e0       	ldi	r26, 0x00	; 0
    3988:	b0 e0       	ldi	r27, 0x00	; 0
    398a:	dc 01       	movw	r26, r24
    398c:	99 27       	eor	r25, r25
    398e:	88 27       	eor	r24, r24
    3990:	82 0f       	add	r24, r18
    3992:	93 1f       	adc	r25, r19
    3994:	a1 1d       	adc	r26, r1
    3996:	b1 1d       	adc	r27, r1
		count_output = count - count_prev;
    3998:	40 91 e9 04 	lds	r20, 0x04E9	; 0x8004e9 <_ZL10count_prev>
    399c:	50 91 ea 04 	lds	r21, 0x04EA	; 0x8004ea <_ZL10count_prev+0x1>
    39a0:	60 91 eb 04 	lds	r22, 0x04EB	; 0x8004eb <_ZL10count_prev+0x2>
    39a4:	70 91 ec 04 	lds	r23, 0x04EC	; 0x8004ec <_ZL10count_prev+0x3>
    39a8:	8c 01       	movw	r16, r24
    39aa:	9d 01       	movw	r18, r26
    39ac:	04 1b       	sub	r16, r20
    39ae:	15 0b       	sbc	r17, r21
    39b0:	26 0b       	sbc	r18, r22
    39b2:	37 0b       	sbc	r19, r23
    39b4:	00 93 e5 04 	sts	0x04E5, r16	; 0x8004e5 <_ZL12count_output>
    39b8:	10 93 e6 04 	sts	0x04E6, r17	; 0x8004e6 <_ZL12count_output+0x1>
    39bc:	20 93 e7 04 	sts	0x04E7, r18	; 0x8004e7 <_ZL12count_output+0x2>
    39c0:	30 93 e8 04 	sts	0x04E8, r19	; 0x8004e8 <_ZL12count_output+0x3>
		count_prev = count;
    39c4:	80 93 e9 04 	sts	0x04E9, r24	; 0x8004e9 <_ZL10count_prev>
    39c8:	90 93 ea 04 	sts	0x04EA, r25	; 0x8004ea <_ZL10count_prev+0x1>
    39cc:	a0 93 eb 04 	sts	0x04EB, r26	; 0x8004eb <_ZL10count_prev+0x2>
    39d0:	b0 93 ec 04 	sts	0x04EC, r27	; 0x8004ec <_ZL10count_prev+0x3>
		count_ready = 1;
    39d4:	81 e0       	ldi	r24, 0x01	; 1
    39d6:	80 93 e4 04 	sts	0x04E4, r24	; 0x8004e4 <_ZL11count_ready>
    39da:	04 c0       	rjmp	.+8      	; 0x39e4 <__vector_7+0xca>
		restore_other_interrupts();
	} else {
		if (index == length - 1) disable_other_interrupts();
		gate_index = index;
    39dc:	90 93 e1 04 	sts	0x04E1, r25	; 0x8004e1 <_ZL10gate_index+0x1>
    39e0:	80 93 e0 04 	sts	0x04E0, r24	; 0x8004e0 <_ZL10gate_index>
	}
}
    39e4:	bf 91       	pop	r27
    39e6:	af 91       	pop	r26
    39e8:	9f 91       	pop	r25
    39ea:	8f 91       	pop	r24
    39ec:	7f 91       	pop	r23
    39ee:	6f 91       	pop	r22
    39f0:	5f 91       	pop	r21
    39f2:	4f 91       	pop	r20
    39f4:	3f 91       	pop	r19
    39f6:	2f 91       	pop	r18
    39f8:	1f 91       	pop	r17
    39fa:	0f 91       	pop	r16
    39fc:	0f 90       	pop	r0
    39fe:	0f be       	out	0x3f, r0	; 63
    3a00:	0f 90       	pop	r0
    3a02:	1f 90       	pop	r1
    3a04:	18 95       	reti

00003a06 <yield>:
 * libraries or sketches that supports cooperative threads.
 *
 * Its defined as a weak symbol and it can be redefined to implement a
 * real cooperative scheduler.
 */
static void __empty() {
    3a06:	08 95       	ret

00003a08 <pvPortMalloc>:
#if( configSUPPORT_DYNAMIC_ALLOCATION > 0 )

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
    3a08:	cf 93       	push	r28
    3a0a:	df 93       	push	r29
    3a0c:	ec 01       	movw	r28, r24
void *pvReturn;

    vTaskSuspendAll();
    3a0e:	0e 94 0b 17 	call	0x2e16	; 0x2e16 <vTaskSuspendAll>
    {
        pvReturn = malloc( xWantedSize );
    3a12:	ce 01       	movw	r24, r28
    3a14:	0e 94 32 22 	call	0x4464	; 0x4464 <malloc>
    3a18:	ec 01       	movw	r28, r24
        traceMALLOC( pvReturn, xWantedSize );
    }
    ( void ) xTaskResumeAll();
    3a1a:	0e 94 c7 17 	call	0x2f8e	; 0x2f8e <xTaskResumeAll>

    #if( configUSE_MALLOC_FAILED_HOOK == 1 )
    {
        if( pvReturn == NULL )
    3a1e:	20 97       	sbiw	r28, 0x00	; 0
    3a20:	11 f4       	brne	.+4      	; 0x3a26 <pvPortMalloc+0x1e>
        {
            extern void vApplicationMallocFailedHook( void );
            vApplicationMallocFailedHook();
    3a22:	0e 94 d3 1b 	call	0x37a6	; 0x37a6 <vApplicationMallocFailedHook>
        }
    }
    #endif

    return pvReturn;
}
    3a26:	ce 01       	movw	r24, r28
    3a28:	df 91       	pop	r29
    3a2a:	cf 91       	pop	r28
    3a2c:	08 95       	ret

00003a2e <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
    3a2e:	cf 93       	push	r28
    3a30:	df 93       	push	r29
    if( pv )
    3a32:	00 97       	sbiw	r24, 0x00	; 0
    3a34:	51 f0       	breq	.+20     	; 0x3a4a <vPortFree+0x1c>
    3a36:	ec 01       	movw	r28, r24
    {
        vTaskSuspendAll();
    3a38:	0e 94 0b 17 	call	0x2e16	; 0x2e16 <vTaskSuspendAll>
        {
            free( pv );
    3a3c:	ce 01       	movw	r24, r28
    3a3e:	0e 94 ca 22 	call	0x4594	; 0x4594 <free>
            traceFREE( pv, 0 );
        }
        ( void ) xTaskResumeAll();
    }
}
    3a42:	df 91       	pop	r29
    3a44:	cf 91       	pop	r28
        vTaskSuspendAll();
        {
            free( pv );
            traceFREE( pv, 0 );
        }
        ( void ) xTaskResumeAll();
    3a46:	0c 94 c7 17 	jmp	0x2f8e	; 0x2f8e <xTaskResumeAll>
    }
}
    3a4a:	df 91       	pop	r29
    3a4c:	cf 91       	pop	r28
    3a4e:	08 95       	ret

00003a50 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
    3a50:	fc 01       	movw	r30, r24
    /* The list structure contains a list item which is used to mark the
    end of the list.  To initialise the list the list end is inserted
    as the only list entry. */
    pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );            /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    3a52:	03 96       	adiw	r24, 0x03	; 3
    3a54:	92 83       	std	Z+2, r25	; 0x02
    3a56:	81 83       	std	Z+1, r24	; 0x01

    /* The list end value is the highest possible value in the list to
    ensure it remains at the end of the list. */
    pxList->xListEnd.xItemValue = portMAX_DELAY;
    3a58:	2f ef       	ldi	r18, 0xFF	; 255
    3a5a:	3f ef       	ldi	r19, 0xFF	; 255
    3a5c:	34 83       	std	Z+4, r19	; 0x04
    3a5e:	23 83       	std	Z+3, r18	; 0x03

    /* The list end next and previous pointers point to itself so we know
    when the list is empty. */
    pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );    /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    3a60:	96 83       	std	Z+6, r25	; 0x06
    3a62:	85 83       	std	Z+5, r24	; 0x05
    pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    3a64:	90 87       	std	Z+8, r25	; 0x08
    3a66:	87 83       	std	Z+7, r24	; 0x07

    pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
    3a68:	10 82       	st	Z, r1
    3a6a:	08 95       	ret

00003a6c <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
    /* Make sure the list item is not recorded as being on a list. */
    pxItem->pxContainer = NULL;
    3a6c:	fc 01       	movw	r30, r24
    3a6e:	11 86       	std	Z+9, r1	; 0x09
    3a70:	10 86       	std	Z+8, r1	; 0x08
    3a72:	08 95       	ret

00003a74 <vListInsertEnd>:
    listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    3a74:	cf 93       	push	r28
    3a76:	df 93       	push	r29
    3a78:	9c 01       	movw	r18, r24
    3a7a:	fb 01       	movw	r30, r22
ListItem_t * const pxIndex = pxList->pxIndex;
    3a7c:	dc 01       	movw	r26, r24
    3a7e:	11 96       	adiw	r26, 0x01	; 1
    3a80:	cd 91       	ld	r28, X+
    3a82:	dc 91       	ld	r29, X
    3a84:	12 97       	sbiw	r26, 0x02	; 2
    listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

    /* Insert a new list item into pxList, but rather than sort the list,
    makes the new list item the last item to be removed by a call to
    listGET_OWNER_OF_NEXT_ENTRY(). */
    pxNewListItem->pxNext = pxIndex;
    3a86:	d3 83       	std	Z+3, r29	; 0x03
    3a88:	c2 83       	std	Z+2, r28	; 0x02
    pxNewListItem->pxPrevious = pxIndex->pxPrevious;
    3a8a:	8c 81       	ldd	r24, Y+4	; 0x04
    3a8c:	9d 81       	ldd	r25, Y+5	; 0x05
    3a8e:	95 83       	std	Z+5, r25	; 0x05
    3a90:	84 83       	std	Z+4, r24	; 0x04

    /* Only used during decision coverage testing. */
    mtCOVERAGE_TEST_DELAY();

    pxIndex->pxPrevious->pxNext = pxNewListItem;
    3a92:	8c 81       	ldd	r24, Y+4	; 0x04
    3a94:	9d 81       	ldd	r25, Y+5	; 0x05
    3a96:	dc 01       	movw	r26, r24
    3a98:	13 96       	adiw	r26, 0x03	; 3
    3a9a:	7c 93       	st	X, r23
    3a9c:	6e 93       	st	-X, r22
    3a9e:	12 97       	sbiw	r26, 0x02	; 2
    pxIndex->pxPrevious = pxNewListItem;
    3aa0:	7d 83       	std	Y+5, r23	; 0x05
    3aa2:	6c 83       	std	Y+4, r22	; 0x04

    /* Remember which list the item is in. */
    pxNewListItem->pxContainer = pxList;
    3aa4:	31 87       	std	Z+9, r19	; 0x09
    3aa6:	20 87       	std	Z+8, r18	; 0x08

    ( pxList->uxNumberOfItems )++;
    3aa8:	f9 01       	movw	r30, r18
    3aaa:	80 81       	ld	r24, Z
    3aac:	8f 5f       	subi	r24, 0xFF	; 255
    3aae:	80 83       	st	Z, r24
}
    3ab0:	df 91       	pop	r29
    3ab2:	cf 91       	pop	r28
    3ab4:	08 95       	ret

00003ab6 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    3ab6:	0f 93       	push	r16
    3ab8:	1f 93       	push	r17
    3aba:	cf 93       	push	r28
    3abc:	df 93       	push	r29
    3abe:	8c 01       	movw	r16, r24
    3ac0:	fb 01       	movw	r30, r22
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
    3ac2:	80 81       	ld	r24, Z
    3ac4:	91 81       	ldd	r25, Z+1	; 0x01
    new list item should be placed after it.  This ensures that TCBs which are
    stored in ready lists (all of which have the same xItemValue value) get a
    share of the CPU.  However, if the xItemValue is the same as the back marker
    the iteration loop below will not end.  Therefore the value is checked
    first, and the algorithm slightly modified if necessary. */
    if( xValueOfInsertion == portMAX_DELAY )
    3ac6:	8f 3f       	cpi	r24, 0xFF	; 255
    3ac8:	2f ef       	ldi	r18, 0xFF	; 255
    3aca:	92 07       	cpc	r25, r18
    3acc:	21 f4       	brne	.+8      	; 0x3ad6 <vListInsert+0x20>
    {
        pxIterator = pxList->xListEnd.pxPrevious;
    3ace:	e8 01       	movw	r28, r16
    3ad0:	af 81       	ldd	r26, Y+7	; 0x07
    3ad2:	b8 85       	ldd	r27, Y+8	; 0x08
    3ad4:	0e c0       	rjmp	.+28     	; 0x3af2 <vListInsert+0x3c>
            4) Using a queue or semaphore before it has been initialised or
               before the scheduler has been started (are interrupts firing
               before vTaskStartScheduler() has been called?).
        **********************************************************************/

        for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. *//*lint !e440 The iterator moves to a different value, not xValueOfInsertion. */
    3ad6:	d8 01       	movw	r26, r16
    3ad8:	13 96       	adiw	r26, 0x03	; 3
    3ada:	12 96       	adiw	r26, 0x02	; 2
    3adc:	2d 91       	ld	r18, X+
    3ade:	3c 91       	ld	r19, X
    3ae0:	13 97       	sbiw	r26, 0x03	; 3
    3ae2:	e9 01       	movw	r28, r18
    3ae4:	48 81       	ld	r20, Y
    3ae6:	59 81       	ldd	r21, Y+1	; 0x01
    3ae8:	84 17       	cp	r24, r20
    3aea:	95 07       	cpc	r25, r21
    3aec:	10 f0       	brcs	.+4      	; 0x3af2 <vListInsert+0x3c>
    3aee:	d9 01       	movw	r26, r18
    3af0:	f4 cf       	rjmp	.-24     	; 0x3ada <vListInsert+0x24>
            /* There is nothing to do here, just iterating to the wanted
            insertion position. */
        }
    }

    pxNewListItem->pxNext = pxIterator->pxNext;
    3af2:	12 96       	adiw	r26, 0x02	; 2
    3af4:	8d 91       	ld	r24, X+
    3af6:	9c 91       	ld	r25, X
    3af8:	13 97       	sbiw	r26, 0x03	; 3
    3afa:	93 83       	std	Z+3, r25	; 0x03
    3afc:	82 83       	std	Z+2, r24	; 0x02
    pxNewListItem->pxNext->pxPrevious = pxNewListItem;
    3afe:	ec 01       	movw	r28, r24
    3b00:	fd 83       	std	Y+5, r31	; 0x05
    3b02:	ec 83       	std	Y+4, r30	; 0x04
    pxNewListItem->pxPrevious = pxIterator;
    3b04:	b5 83       	std	Z+5, r27	; 0x05
    3b06:	a4 83       	std	Z+4, r26	; 0x04
    pxIterator->pxNext = pxNewListItem;
    3b08:	13 96       	adiw	r26, 0x03	; 3
    3b0a:	fc 93       	st	X, r31
    3b0c:	ee 93       	st	-X, r30
    3b0e:	12 97       	sbiw	r26, 0x02	; 2

    /* Remember which list the item is in.  This allows fast removal of the
    item later. */
    pxNewListItem->pxContainer = pxList;
    3b10:	11 87       	std	Z+9, r17	; 0x09
    3b12:	00 87       	std	Z+8, r16	; 0x08

    ( pxList->uxNumberOfItems )++;
    3b14:	f8 01       	movw	r30, r16
    3b16:	80 81       	ld	r24, Z
    3b18:	8f 5f       	subi	r24, 0xFF	; 255
    3b1a:	80 83       	st	Z, r24
}
    3b1c:	df 91       	pop	r29
    3b1e:	cf 91       	pop	r28
    3b20:	1f 91       	pop	r17
    3b22:	0f 91       	pop	r16
    3b24:	08 95       	ret

00003b26 <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
    3b26:	cf 93       	push	r28
    3b28:	df 93       	push	r29
    3b2a:	fc 01       	movw	r30, r24
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = pxItemToRemove->pxContainer;
    3b2c:	a0 85       	ldd	r26, Z+8	; 0x08
    3b2e:	b1 85       	ldd	r27, Z+9	; 0x09

    pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    3b30:	82 81       	ldd	r24, Z+2	; 0x02
    3b32:	93 81       	ldd	r25, Z+3	; 0x03
    3b34:	24 81       	ldd	r18, Z+4	; 0x04
    3b36:	35 81       	ldd	r19, Z+5	; 0x05
    3b38:	ec 01       	movw	r28, r24
    3b3a:	3d 83       	std	Y+5, r19	; 0x05
    3b3c:	2c 83       	std	Y+4, r18	; 0x04
    pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    3b3e:	c4 81       	ldd	r28, Z+4	; 0x04
    3b40:	d5 81       	ldd	r29, Z+5	; 0x05
    3b42:	9b 83       	std	Y+3, r25	; 0x03
    3b44:	8a 83       	std	Y+2, r24	; 0x02

    /* Only used during decision coverage testing. */
    mtCOVERAGE_TEST_DELAY();

    /* Make sure the index is left pointing to a valid item. */
    if( pxList->pxIndex == pxItemToRemove )
    3b46:	11 96       	adiw	r26, 0x01	; 1
    3b48:	8d 91       	ld	r24, X+
    3b4a:	9c 91       	ld	r25, X
    3b4c:	12 97       	sbiw	r26, 0x02	; 2
    3b4e:	e8 17       	cp	r30, r24
    3b50:	f9 07       	cpc	r31, r25
    3b52:	21 f4       	brne	.+8      	; 0x3b5c <uxListRemove+0x36>
    {
        pxList->pxIndex = pxItemToRemove->pxPrevious;
    3b54:	12 96       	adiw	r26, 0x02	; 2
    3b56:	dc 93       	st	X, r29
    3b58:	ce 93       	st	-X, r28
    3b5a:	11 97       	sbiw	r26, 0x01	; 1
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }

    pxItemToRemove->pxContainer = NULL;
    3b5c:	11 86       	std	Z+9, r1	; 0x09
    3b5e:	10 86       	std	Z+8, r1	; 0x08
    ( pxList->uxNumberOfItems )--;
    3b60:	8c 91       	ld	r24, X
    3b62:	81 50       	subi	r24, 0x01	; 1
    3b64:	8c 93       	st	X, r24

    return pxList->uxNumberOfItems;
    3b66:	8c 91       	ld	r24, X
}
    3b68:	df 91       	pop	r29
    3b6a:	cf 91       	pop	r28
    3b6c:	08 95       	ret

00003b6e <pxPortInitialiseStack>:
		);
	}
	else
	{
        uint8_t register temp_reg;
		__asm__ __volatile__ (
    3b6e:	31 e1       	ldi	r19, 0x11	; 17
    3b70:	fc 01       	movw	r30, r24
    3b72:	30 83       	st	Z, r19
    3b74:	31 97       	sbiw	r30, 0x01	; 1
    3b76:	22 e2       	ldi	r18, 0x22	; 34
    3b78:	20 83       	st	Z, r18
    3b7a:	31 97       	sbiw	r30, 0x01	; 1
    3b7c:	a3 e3       	ldi	r26, 0x33	; 51
    3b7e:	a0 83       	st	Z, r26
    3b80:	31 97       	sbiw	r30, 0x01	; 1
    3b82:	60 83       	st	Z, r22
    3b84:	31 97       	sbiw	r30, 0x01	; 1
    3b86:	70 83       	st	Z, r23
    3b88:	31 97       	sbiw	r30, 0x01	; 1
    3b8a:	10 82       	st	Z, r1
    3b8c:	31 97       	sbiw	r30, 0x01	; 1
    3b8e:	60 e8       	ldi	r22, 0x80	; 128
    3b90:	60 83       	st	Z, r22
    3b92:	31 97       	sbiw	r30, 0x01	; 1
    3b94:	10 82       	st	Z, r1
    3b96:	31 97       	sbiw	r30, 0x01	; 1
    3b98:	62 e0       	ldi	r22, 0x02	; 2
    3b9a:	60 83       	st	Z, r22
    3b9c:	31 97       	sbiw	r30, 0x01	; 1
    3b9e:	63 e0       	ldi	r22, 0x03	; 3
    3ba0:	60 83       	st	Z, r22
    3ba2:	31 97       	sbiw	r30, 0x01	; 1
    3ba4:	64 e0       	ldi	r22, 0x04	; 4
    3ba6:	60 83       	st	Z, r22
    3ba8:	31 97       	sbiw	r30, 0x01	; 1
    3baa:	65 e0       	ldi	r22, 0x05	; 5
    3bac:	60 83       	st	Z, r22
    3bae:	31 97       	sbiw	r30, 0x01	; 1
    3bb0:	66 e0       	ldi	r22, 0x06	; 6
    3bb2:	60 83       	st	Z, r22
    3bb4:	31 97       	sbiw	r30, 0x01	; 1
    3bb6:	67 e0       	ldi	r22, 0x07	; 7
    3bb8:	60 83       	st	Z, r22
    3bba:	31 97       	sbiw	r30, 0x01	; 1
    3bbc:	68 e0       	ldi	r22, 0x08	; 8
    3bbe:	60 83       	st	Z, r22
    3bc0:	31 97       	sbiw	r30, 0x01	; 1
    3bc2:	69 e0       	ldi	r22, 0x09	; 9
    3bc4:	60 83       	st	Z, r22
    3bc6:	31 97       	sbiw	r30, 0x01	; 1
    3bc8:	60 e1       	ldi	r22, 0x10	; 16
    3bca:	60 83       	st	Z, r22
    3bcc:	31 97       	sbiw	r30, 0x01	; 1
    3bce:	30 83       	st	Z, r19
    3bd0:	31 97       	sbiw	r30, 0x01	; 1
    3bd2:	32 e1       	ldi	r19, 0x12	; 18
    3bd4:	30 83       	st	Z, r19
    3bd6:	31 97       	sbiw	r30, 0x01	; 1
    3bd8:	33 e1       	ldi	r19, 0x13	; 19
    3bda:	30 83       	st	Z, r19
    3bdc:	31 97       	sbiw	r30, 0x01	; 1
    3bde:	34 e1       	ldi	r19, 0x14	; 20
    3be0:	30 83       	st	Z, r19
    3be2:	31 97       	sbiw	r30, 0x01	; 1
    3be4:	35 e1       	ldi	r19, 0x15	; 21
    3be6:	30 83       	st	Z, r19
    3be8:	31 97       	sbiw	r30, 0x01	; 1
    3bea:	36 e1       	ldi	r19, 0x16	; 22
    3bec:	30 83       	st	Z, r19
    3bee:	31 97       	sbiw	r30, 0x01	; 1
    3bf0:	37 e1       	ldi	r19, 0x17	; 23
    3bf2:	30 83       	st	Z, r19
    3bf4:	31 97       	sbiw	r30, 0x01	; 1
    3bf6:	38 e1       	ldi	r19, 0x18	; 24
    3bf8:	30 83       	st	Z, r19
    3bfa:	31 97       	sbiw	r30, 0x01	; 1
    3bfc:	39 e1       	ldi	r19, 0x19	; 25
    3bfe:	30 83       	st	Z, r19
    3c00:	31 97       	sbiw	r30, 0x01	; 1
    3c02:	30 e2       	ldi	r19, 0x20	; 32
    3c04:	30 83       	st	Z, r19
    3c06:	31 97       	sbiw	r30, 0x01	; 1
    3c08:	31 e2       	ldi	r19, 0x21	; 33
    3c0a:	30 83       	st	Z, r19
    3c0c:	31 97       	sbiw	r30, 0x01	; 1
    3c0e:	20 83       	st	Z, r18
    3c10:	31 97       	sbiw	r30, 0x01	; 1
    3c12:	23 e2       	ldi	r18, 0x23	; 35
    3c14:	20 83       	st	Z, r18
    3c16:	31 97       	sbiw	r30, 0x01	; 1
    3c18:	40 83       	st	Z, r20
    3c1a:	31 97       	sbiw	r30, 0x01	; 1
    3c1c:	50 83       	st	Z, r21
    3c1e:	31 97       	sbiw	r30, 0x01	; 1
    3c20:	26 e2       	ldi	r18, 0x26	; 38
    3c22:	20 83       	st	Z, r18
    3c24:	31 97       	sbiw	r30, 0x01	; 1
    3c26:	27 e2       	ldi	r18, 0x27	; 39
    3c28:	20 83       	st	Z, r18
    3c2a:	31 97       	sbiw	r30, 0x01	; 1
    3c2c:	28 e2       	ldi	r18, 0x28	; 40
    3c2e:	20 83       	st	Z, r18
    3c30:	31 97       	sbiw	r30, 0x01	; 1
    3c32:	29 e2       	ldi	r18, 0x29	; 41
    3c34:	20 83       	st	Z, r18
    3c36:	31 97       	sbiw	r30, 0x01	; 1
    3c38:	20 e3       	ldi	r18, 0x30	; 48
    3c3a:	20 83       	st	Z, r18
    3c3c:	31 97       	sbiw	r30, 0x01	; 1
    3c3e:	21 e3       	ldi	r18, 0x31	; 49
    3c40:	20 83       	st	Z, r18
    3c42:	86 97       	sbiw	r24, 0x26	; 38
    3c44:	08 95       	ret

00003c46 <xPortStartScheduler>:
    3c46:	a8 95       	wdr
    3c48:	90 ec       	ldi	r25, 0xC0	; 192
    3c4a:	88 e1       	ldi	r24, 0x18	; 24
    3c4c:	0f b6       	in	r0, 0x3f	; 63
    3c4e:	f8 94       	cli
    3c50:	a8 95       	wdr
    3c52:	80 93 60 00 	sts	0x0060, r24	; 0x800060 <__DATA_REGION_ORIGIN__>
    3c56:	0f be       	out	0x3f, r0	; 63
    3c58:	90 93 60 00 	sts	0x0060, r25	; 0x800060 <__DATA_REGION_ORIGIN__>
    3c5c:	a0 91 c2 04 	lds	r26, 0x04C2	; 0x8004c2 <pxCurrentTCB>
    3c60:	b0 91 c3 04 	lds	r27, 0x04C3	; 0x8004c3 <pxCurrentTCB+0x1>
    3c64:	cd 91       	ld	r28, X+
    3c66:	cd bf       	out	0x3d, r28	; 61
    3c68:	dd 91       	ld	r29, X+
    3c6a:	de bf       	out	0x3e, r29	; 62
    3c6c:	ff 91       	pop	r31
    3c6e:	ef 91       	pop	r30
    3c70:	df 91       	pop	r29
    3c72:	cf 91       	pop	r28
    3c74:	bf 91       	pop	r27
    3c76:	af 91       	pop	r26
    3c78:	9f 91       	pop	r25
    3c7a:	8f 91       	pop	r24
    3c7c:	7f 91       	pop	r23
    3c7e:	6f 91       	pop	r22
    3c80:	5f 91       	pop	r21
    3c82:	4f 91       	pop	r20
    3c84:	3f 91       	pop	r19
    3c86:	2f 91       	pop	r18
    3c88:	1f 91       	pop	r17
    3c8a:	0f 91       	pop	r16
    3c8c:	ff 90       	pop	r15
    3c8e:	ef 90       	pop	r14
    3c90:	df 90       	pop	r13
    3c92:	cf 90       	pop	r12
    3c94:	bf 90       	pop	r11
    3c96:	af 90       	pop	r10
    3c98:	9f 90       	pop	r9
    3c9a:	8f 90       	pop	r8
    3c9c:	7f 90       	pop	r7
    3c9e:	6f 90       	pop	r6
    3ca0:	5f 90       	pop	r5
    3ca2:	4f 90       	pop	r4
    3ca4:	3f 90       	pop	r3
    3ca6:	2f 90       	pop	r2
    3ca8:	1f 90       	pop	r1
    3caa:	0f 90       	pop	r0
    3cac:	0f be       	out	0x3f, r0	; 63
    3cae:	0f 90       	pop	r0
    3cb0:	08 95       	ret
    3cb2:	81 e0       	ldi	r24, 0x01	; 1
    3cb4:	08 95       	ret

00003cb6 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( hot, flatten, naked ) );
void vPortYield( void )
{
    portSAVE_CONTEXT();
    3cb6:	0f 92       	push	r0
    3cb8:	0f b6       	in	r0, 0x3f	; 63
    3cba:	f8 94       	cli
    3cbc:	0f 92       	push	r0
    3cbe:	1f 92       	push	r1
    3cc0:	11 24       	eor	r1, r1
    3cc2:	2f 92       	push	r2
    3cc4:	3f 92       	push	r3
    3cc6:	4f 92       	push	r4
    3cc8:	5f 92       	push	r5
    3cca:	6f 92       	push	r6
    3ccc:	7f 92       	push	r7
    3cce:	8f 92       	push	r8
    3cd0:	9f 92       	push	r9
    3cd2:	af 92       	push	r10
    3cd4:	bf 92       	push	r11
    3cd6:	cf 92       	push	r12
    3cd8:	df 92       	push	r13
    3cda:	ef 92       	push	r14
    3cdc:	ff 92       	push	r15
    3cde:	0f 93       	push	r16
    3ce0:	1f 93       	push	r17
    3ce2:	2f 93       	push	r18
    3ce4:	3f 93       	push	r19
    3ce6:	4f 93       	push	r20
    3ce8:	5f 93       	push	r21
    3cea:	6f 93       	push	r22
    3cec:	7f 93       	push	r23
    3cee:	8f 93       	push	r24
    3cf0:	9f 93       	push	r25
    3cf2:	af 93       	push	r26
    3cf4:	bf 93       	push	r27
    3cf6:	cf 93       	push	r28
    3cf8:	df 93       	push	r29
    3cfa:	ef 93       	push	r30
    3cfc:	ff 93       	push	r31
    3cfe:	a0 91 c2 04 	lds	r26, 0x04C2	; 0x8004c2 <pxCurrentTCB>
    3d02:	b0 91 c3 04 	lds	r27, 0x04C3	; 0x8004c3 <pxCurrentTCB+0x1>
    3d06:	0d b6       	in	r0, 0x3d	; 61
    3d08:	0d 92       	st	X+, r0
    3d0a:	0e b6       	in	r0, 0x3e	; 62
    3d0c:	0d 92       	st	X+, r0
    vTaskSwitchContext();
    3d0e:	0e 94 6e 18 	call	0x30dc	; 0x30dc <vTaskSwitchContext>
    portRESTORE_CONTEXT();
    3d12:	a0 91 c2 04 	lds	r26, 0x04C2	; 0x8004c2 <pxCurrentTCB>
    3d16:	b0 91 c3 04 	lds	r27, 0x04C3	; 0x8004c3 <pxCurrentTCB+0x1>
    3d1a:	cd 91       	ld	r28, X+
    3d1c:	cd bf       	out	0x3d, r28	; 61
    3d1e:	dd 91       	ld	r29, X+
    3d20:	de bf       	out	0x3e, r29	; 62
    3d22:	ff 91       	pop	r31
    3d24:	ef 91       	pop	r30
    3d26:	df 91       	pop	r29
    3d28:	cf 91       	pop	r28
    3d2a:	bf 91       	pop	r27
    3d2c:	af 91       	pop	r26
    3d2e:	9f 91       	pop	r25
    3d30:	8f 91       	pop	r24
    3d32:	7f 91       	pop	r23
    3d34:	6f 91       	pop	r22
    3d36:	5f 91       	pop	r21
    3d38:	4f 91       	pop	r20
    3d3a:	3f 91       	pop	r19
    3d3c:	2f 91       	pop	r18
    3d3e:	1f 91       	pop	r17
    3d40:	0f 91       	pop	r16
    3d42:	ff 90       	pop	r15
    3d44:	ef 90       	pop	r14
    3d46:	df 90       	pop	r13
    3d48:	cf 90       	pop	r12
    3d4a:	bf 90       	pop	r11
    3d4c:	af 90       	pop	r10
    3d4e:	9f 90       	pop	r9
    3d50:	8f 90       	pop	r8
    3d52:	7f 90       	pop	r7
    3d54:	6f 90       	pop	r6
    3d56:	5f 90       	pop	r5
    3d58:	4f 90       	pop	r4
    3d5a:	3f 90       	pop	r3
    3d5c:	2f 90       	pop	r2
    3d5e:	1f 90       	pop	r1
    3d60:	0f 90       	pop	r0
    3d62:	0f be       	out	0x3f, r0	; 63
    3d64:	0f 90       	pop	r0

    __asm__ __volatile__ ( "ret" );
    3d66:	08 95       	ret

00003d68 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( hot, flatten, naked ) );
void vPortYieldFromTick( void )
{
    portSAVE_CONTEXT();
    3d68:	0f 92       	push	r0
    3d6a:	0f b6       	in	r0, 0x3f	; 63
    3d6c:	f8 94       	cli
    3d6e:	0f 92       	push	r0
    3d70:	1f 92       	push	r1
    3d72:	11 24       	eor	r1, r1
    3d74:	2f 92       	push	r2
    3d76:	3f 92       	push	r3
    3d78:	4f 92       	push	r4
    3d7a:	5f 92       	push	r5
    3d7c:	6f 92       	push	r6
    3d7e:	7f 92       	push	r7
    3d80:	8f 92       	push	r8
    3d82:	9f 92       	push	r9
    3d84:	af 92       	push	r10
    3d86:	bf 92       	push	r11
    3d88:	cf 92       	push	r12
    3d8a:	df 92       	push	r13
    3d8c:	ef 92       	push	r14
    3d8e:	ff 92       	push	r15
    3d90:	0f 93       	push	r16
    3d92:	1f 93       	push	r17
    3d94:	2f 93       	push	r18
    3d96:	3f 93       	push	r19
    3d98:	4f 93       	push	r20
    3d9a:	5f 93       	push	r21
    3d9c:	6f 93       	push	r22
    3d9e:	7f 93       	push	r23
    3da0:	8f 93       	push	r24
    3da2:	9f 93       	push	r25
    3da4:	af 93       	push	r26
    3da6:	bf 93       	push	r27
    3da8:	cf 93       	push	r28
    3daa:	df 93       	push	r29
    3dac:	ef 93       	push	r30
    3dae:	ff 93       	push	r31
    3db0:	a0 91 c2 04 	lds	r26, 0x04C2	; 0x8004c2 <pxCurrentTCB>
    3db4:	b0 91 c3 04 	lds	r27, 0x04C3	; 0x8004c3 <pxCurrentTCB+0x1>
    3db8:	0d b6       	in	r0, 0x3d	; 61
    3dba:	0d 92       	st	X+, r0
    3dbc:	0e b6       	in	r0, 0x3e	; 62
    3dbe:	0d 92       	st	X+, r0

    sleep_reset();        //     reset the sleep_mode() faster than sleep_disable();
    3dc0:	13 be       	out	0x33, r1	; 51

    if( xTaskIncrementTick() != pdFALSE )
    3dc2:	0e 94 1b 17 	call	0x2e36	; 0x2e36 <xTaskIncrementTick>
    3dc6:	81 11       	cpse	r24, r1
    {
        vTaskSwitchContext();
    3dc8:	0e 94 6e 18 	call	0x30dc	; 0x30dc <vTaskSwitchContext>
    }

    portRESTORE_CONTEXT();
    3dcc:	a0 91 c2 04 	lds	r26, 0x04C2	; 0x8004c2 <pxCurrentTCB>
    3dd0:	b0 91 c3 04 	lds	r27, 0x04C3	; 0x8004c3 <pxCurrentTCB+0x1>
    3dd4:	cd 91       	ld	r28, X+
    3dd6:	cd bf       	out	0x3d, r28	; 61
    3dd8:	dd 91       	ld	r29, X+
    3dda:	de bf       	out	0x3e, r29	; 62
    3ddc:	ff 91       	pop	r31
    3dde:	ef 91       	pop	r30
    3de0:	df 91       	pop	r29
    3de2:	cf 91       	pop	r28
    3de4:	bf 91       	pop	r27
    3de6:	af 91       	pop	r26
    3de8:	9f 91       	pop	r25
    3dea:	8f 91       	pop	r24
    3dec:	7f 91       	pop	r23
    3dee:	6f 91       	pop	r22
    3df0:	5f 91       	pop	r21
    3df2:	4f 91       	pop	r20
    3df4:	3f 91       	pop	r19
    3df6:	2f 91       	pop	r18
    3df8:	1f 91       	pop	r17
    3dfa:	0f 91       	pop	r16
    3dfc:	ff 90       	pop	r15
    3dfe:	ef 90       	pop	r14
    3e00:	df 90       	pop	r13
    3e02:	cf 90       	pop	r12
    3e04:	bf 90       	pop	r11
    3e06:	af 90       	pop	r10
    3e08:	9f 90       	pop	r9
    3e0a:	8f 90       	pop	r8
    3e0c:	7f 90       	pop	r7
    3e0e:	6f 90       	pop	r6
    3e10:	5f 90       	pop	r5
    3e12:	4f 90       	pop	r4
    3e14:	3f 90       	pop	r3
    3e16:	2f 90       	pop	r2
    3e18:	1f 90       	pop	r1
    3e1a:	0f 90       	pop	r0
    3e1c:	0f be       	out	0x3f, r0	; 63
    3e1e:	0f 90       	pop	r0

    __asm__ __volatile__ ( "ret" );
    3e20:	08 95       	ret

00003e22 <__vector_6>:
     */
    ISR(portSCHEDULER_ISR, ISR_NAKED) __attribute__ ((hot, flatten));
//  ISR(portSCHEDULER_ISR, ISR_NAKED ISR_NOBLOCK) __attribute__ ((hot, flatten));
    ISR(portSCHEDULER_ISR)
    {
        vPortYieldFromTick();
    3e22:	0e 94 b4 1e 	call	0x3d68	; 0x3d68 <vPortYieldFromTick>
        __asm__ __volatile__ ( "reti" );
    3e26:	18 95       	reti

00003e28 <prvIsQueueEmpty>:
    {
        xReturn = pdFALSE;
    }

    return xReturn;
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
    3e28:	0f b6       	in	r0, 0x3f	; 63
    3e2a:	f8 94       	cli
    3e2c:	0f 92       	push	r0
    3e2e:	fc 01       	movw	r30, r24
    3e30:	92 8d       	ldd	r25, Z+26	; 0x1a
    3e32:	0f 90       	pop	r0
    3e34:	0f be       	out	0x3f, r0	; 63
    3e36:	81 e0       	ldi	r24, 0x01	; 1
    3e38:	91 11       	cpse	r25, r1
    3e3a:	80 e0       	ldi	r24, 0x00	; 0
    3e3c:	08 95       	ret

00003e3e <prvCopyDataToQueue>:
    3e3e:	0f 93       	push	r16
    3e40:	1f 93       	push	r17
    3e42:	cf 93       	push	r28
    3e44:	df 93       	push	r29
    3e46:	ec 01       	movw	r28, r24
    3e48:	04 2f       	mov	r16, r20
    3e4a:	1a 8d       	ldd	r17, Y+26	; 0x1a
    3e4c:	4c 8d       	ldd	r20, Y+28	; 0x1c
    3e4e:	41 11       	cpse	r20, r1
    3e50:	0b c0       	rjmp	.+22     	; 0x3e68 <prvCopyDataToQueue+0x2a>
    3e52:	88 81       	ld	r24, Y
    3e54:	99 81       	ldd	r25, Y+1	; 0x01
    3e56:	89 2b       	or	r24, r25
    3e58:	e9 f5       	brne	.+122    	; 0x3ed4 <prvCopyDataToQueue+0x96>
    3e5a:	8c 81       	ldd	r24, Y+4	; 0x04
    3e5c:	9d 81       	ldd	r25, Y+5	; 0x05
    3e5e:	0e 94 85 19 	call	0x330a	; 0x330a <xTaskPriorityDisinherit>
    3e62:	1d 82       	std	Y+5, r1	; 0x05
    3e64:	1c 82       	std	Y+4, r1	; 0x04
    3e66:	37 c0       	rjmp	.+110    	; 0x3ed6 <prvCopyDataToQueue+0x98>
    3e68:	50 e0       	ldi	r21, 0x00	; 0
    3e6a:	01 11       	cpse	r16, r1
    3e6c:	15 c0       	rjmp	.+42     	; 0x3e98 <prvCopyDataToQueue+0x5a>
    3e6e:	8a 81       	ldd	r24, Y+2	; 0x02
    3e70:	9b 81       	ldd	r25, Y+3	; 0x03
    3e72:	0e 94 53 23 	call	0x46a6	; 0x46a6 <memcpy>
    3e76:	2c 8d       	ldd	r18, Y+28	; 0x1c
    3e78:	8a 81       	ldd	r24, Y+2	; 0x02
    3e7a:	9b 81       	ldd	r25, Y+3	; 0x03
    3e7c:	82 0f       	add	r24, r18
    3e7e:	91 1d       	adc	r25, r1
    3e80:	9b 83       	std	Y+3, r25	; 0x03
    3e82:	8a 83       	std	Y+2, r24	; 0x02
    3e84:	2c 81       	ldd	r18, Y+4	; 0x04
    3e86:	3d 81       	ldd	r19, Y+5	; 0x05
    3e88:	82 17       	cp	r24, r18
    3e8a:	93 07       	cpc	r25, r19
    3e8c:	18 f1       	brcs	.+70     	; 0x3ed4 <prvCopyDataToQueue+0x96>
    3e8e:	88 81       	ld	r24, Y
    3e90:	99 81       	ldd	r25, Y+1	; 0x01
    3e92:	9b 83       	std	Y+3, r25	; 0x03
    3e94:	8a 83       	std	Y+2, r24	; 0x02
    3e96:	1e c0       	rjmp	.+60     	; 0x3ed4 <prvCopyDataToQueue+0x96>
    3e98:	8e 81       	ldd	r24, Y+6	; 0x06
    3e9a:	9f 81       	ldd	r25, Y+7	; 0x07
    3e9c:	0e 94 53 23 	call	0x46a6	; 0x46a6 <memcpy>
    3ea0:	8c 8d       	ldd	r24, Y+28	; 0x1c
    3ea2:	90 e0       	ldi	r25, 0x00	; 0
    3ea4:	91 95       	neg	r25
    3ea6:	81 95       	neg	r24
    3ea8:	91 09       	sbc	r25, r1
    3eaa:	2e 81       	ldd	r18, Y+6	; 0x06
    3eac:	3f 81       	ldd	r19, Y+7	; 0x07
    3eae:	28 0f       	add	r18, r24
    3eb0:	39 1f       	adc	r19, r25
    3eb2:	3f 83       	std	Y+7, r19	; 0x07
    3eb4:	2e 83       	std	Y+6, r18	; 0x06
    3eb6:	48 81       	ld	r20, Y
    3eb8:	59 81       	ldd	r21, Y+1	; 0x01
    3eba:	24 17       	cp	r18, r20
    3ebc:	35 07       	cpc	r19, r21
    3ebe:	30 f4       	brcc	.+12     	; 0x3ecc <prvCopyDataToQueue+0x8e>
    3ec0:	2c 81       	ldd	r18, Y+4	; 0x04
    3ec2:	3d 81       	ldd	r19, Y+5	; 0x05
    3ec4:	82 0f       	add	r24, r18
    3ec6:	93 1f       	adc	r25, r19
    3ec8:	9f 83       	std	Y+7, r25	; 0x07
    3eca:	8e 83       	std	Y+6, r24	; 0x06
    3ecc:	02 30       	cpi	r16, 0x02	; 2
    3ece:	11 f4       	brne	.+4      	; 0x3ed4 <prvCopyDataToQueue+0x96>
    3ed0:	11 11       	cpse	r17, r1
    3ed2:	11 50       	subi	r17, 0x01	; 1
    3ed4:	80 e0       	ldi	r24, 0x00	; 0
    3ed6:	1f 5f       	subi	r17, 0xFF	; 255
    3ed8:	1a 8f       	std	Y+26, r17	; 0x1a
    3eda:	df 91       	pop	r29
    3edc:	cf 91       	pop	r28
    3ede:	1f 91       	pop	r17
    3ee0:	0f 91       	pop	r16
    3ee2:	08 95       	ret

00003ee4 <prvCopyDataFromQueue>:
    3ee4:	fc 01       	movw	r30, r24
    3ee6:	cb 01       	movw	r24, r22
    3ee8:	44 8d       	ldd	r20, Z+28	; 0x1c
    3eea:	44 23       	and	r20, r20
    3eec:	a1 f0       	breq	.+40     	; 0x3f16 <prvCopyDataFromQueue+0x32>
    3eee:	50 e0       	ldi	r21, 0x00	; 0
    3ef0:	26 81       	ldd	r18, Z+6	; 0x06
    3ef2:	37 81       	ldd	r19, Z+7	; 0x07
    3ef4:	24 0f       	add	r18, r20
    3ef6:	35 1f       	adc	r19, r21
    3ef8:	37 83       	std	Z+7, r19	; 0x07
    3efa:	26 83       	std	Z+6, r18	; 0x06
    3efc:	64 81       	ldd	r22, Z+4	; 0x04
    3efe:	75 81       	ldd	r23, Z+5	; 0x05
    3f00:	26 17       	cp	r18, r22
    3f02:	37 07       	cpc	r19, r23
    3f04:	20 f0       	brcs	.+8      	; 0x3f0e <prvCopyDataFromQueue+0x2a>
    3f06:	20 81       	ld	r18, Z
    3f08:	31 81       	ldd	r19, Z+1	; 0x01
    3f0a:	37 83       	std	Z+7, r19	; 0x07
    3f0c:	26 83       	std	Z+6, r18	; 0x06
    3f0e:	66 81       	ldd	r22, Z+6	; 0x06
    3f10:	77 81       	ldd	r23, Z+7	; 0x07
    3f12:	0c 94 53 23 	jmp	0x46a6	; 0x46a6 <memcpy>
    3f16:	08 95       	ret

00003f18 <prvUnlockQueue>:
    3f18:	ef 92       	push	r14
    3f1a:	ff 92       	push	r15
    3f1c:	1f 93       	push	r17
    3f1e:	cf 93       	push	r28
    3f20:	df 93       	push	r29
    3f22:	ec 01       	movw	r28, r24
    3f24:	0f b6       	in	r0, 0x3f	; 63
    3f26:	f8 94       	cli
    3f28:	0f 92       	push	r0
    3f2a:	1e 8d       	ldd	r17, Y+30	; 0x1e
    3f2c:	7c 01       	movw	r14, r24
    3f2e:	81 e1       	ldi	r24, 0x11	; 17
    3f30:	e8 0e       	add	r14, r24
    3f32:	f1 1c       	adc	r15, r1
    3f34:	11 16       	cp	r1, r17
    3f36:	5c f4       	brge	.+22     	; 0x3f4e <prvUnlockQueue+0x36>
    3f38:	89 89       	ldd	r24, Y+17	; 0x11
    3f3a:	88 23       	and	r24, r24
    3f3c:	41 f0       	breq	.+16     	; 0x3f4e <prvUnlockQueue+0x36>
    3f3e:	c7 01       	movw	r24, r14
    3f40:	0e 94 f5 18 	call	0x31ea	; 0x31ea <xTaskRemoveFromEventList>
    3f44:	81 11       	cpse	r24, r1
    3f46:	0e 94 73 19 	call	0x32e6	; 0x32e6 <vTaskMissedYield>
    3f4a:	11 50       	subi	r17, 0x01	; 1
    3f4c:	f3 cf       	rjmp	.-26     	; 0x3f34 <prvUnlockQueue+0x1c>
    3f4e:	8f ef       	ldi	r24, 0xFF	; 255
    3f50:	8e 8f       	std	Y+30, r24	; 0x1e
    3f52:	0f 90       	pop	r0
    3f54:	0f be       	out	0x3f, r0	; 63
    3f56:	0f b6       	in	r0, 0x3f	; 63
    3f58:	f8 94       	cli
    3f5a:	0f 92       	push	r0
    3f5c:	1d 8d       	ldd	r17, Y+29	; 0x1d
    3f5e:	7e 01       	movw	r14, r28
    3f60:	88 e0       	ldi	r24, 0x08	; 8
    3f62:	e8 0e       	add	r14, r24
    3f64:	f1 1c       	adc	r15, r1
    3f66:	11 16       	cp	r1, r17
    3f68:	5c f4       	brge	.+22     	; 0x3f80 <prvUnlockQueue+0x68>
    3f6a:	88 85       	ldd	r24, Y+8	; 0x08
    3f6c:	88 23       	and	r24, r24
    3f6e:	41 f0       	breq	.+16     	; 0x3f80 <prvUnlockQueue+0x68>
    3f70:	c7 01       	movw	r24, r14
    3f72:	0e 94 f5 18 	call	0x31ea	; 0x31ea <xTaskRemoveFromEventList>
    3f76:	81 11       	cpse	r24, r1
    3f78:	0e 94 73 19 	call	0x32e6	; 0x32e6 <vTaskMissedYield>
    3f7c:	11 50       	subi	r17, 0x01	; 1
    3f7e:	f3 cf       	rjmp	.-26     	; 0x3f66 <prvUnlockQueue+0x4e>
    3f80:	8f ef       	ldi	r24, 0xFF	; 255
    3f82:	8d 8f       	std	Y+29, r24	; 0x1d
    3f84:	0f 90       	pop	r0
    3f86:	0f be       	out	0x3f, r0	; 63
    3f88:	df 91       	pop	r29
    3f8a:	cf 91       	pop	r28
    3f8c:	1f 91       	pop	r17
    3f8e:	ff 90       	pop	r15
    3f90:	ef 90       	pop	r14
    3f92:	08 95       	ret

00003f94 <xQueueGenericReset>:
    3f94:	cf 93       	push	r28
    3f96:	df 93       	push	r29
    3f98:	ec 01       	movw	r28, r24
    3f9a:	0f b6       	in	r0, 0x3f	; 63
    3f9c:	f8 94       	cli
    3f9e:	0f 92       	push	r0
    3fa0:	48 81       	ld	r20, Y
    3fa2:	59 81       	ldd	r21, Y+1	; 0x01
    3fa4:	8b 8d       	ldd	r24, Y+27	; 0x1b
    3fa6:	7c 8d       	ldd	r23, Y+28	; 0x1c
    3fa8:	9a 01       	movw	r18, r20
    3faa:	87 9f       	mul	r24, r23
    3fac:	20 0d       	add	r18, r0
    3fae:	31 1d       	adc	r19, r1
    3fb0:	11 24       	eor	r1, r1
    3fb2:	3d 83       	std	Y+5, r19	; 0x05
    3fb4:	2c 83       	std	Y+4, r18	; 0x04
    3fb6:	1a 8e       	std	Y+26, r1	; 0x1a
    3fb8:	5b 83       	std	Y+3, r21	; 0x03
    3fba:	4a 83       	std	Y+2, r20	; 0x02
    3fbc:	90 e0       	ldi	r25, 0x00	; 0
    3fbe:	01 97       	sbiw	r24, 0x01	; 1
    3fc0:	78 9f       	mul	r23, r24
    3fc2:	90 01       	movw	r18, r0
    3fc4:	79 9f       	mul	r23, r25
    3fc6:	30 0d       	add	r19, r0
    3fc8:	11 24       	eor	r1, r1
    3fca:	ca 01       	movw	r24, r20
    3fcc:	82 0f       	add	r24, r18
    3fce:	93 1f       	adc	r25, r19
    3fd0:	9f 83       	std	Y+7, r25	; 0x07
    3fd2:	8e 83       	std	Y+6, r24	; 0x06
    3fd4:	8f ef       	ldi	r24, 0xFF	; 255
    3fd6:	8d 8f       	std	Y+29, r24	; 0x1d
    3fd8:	8e 8f       	std	Y+30, r24	; 0x1e
    3fda:	61 11       	cpse	r22, r1
    3fdc:	0c c0       	rjmp	.+24     	; 0x3ff6 <xQueueGenericReset+0x62>
    3fde:	88 85       	ldd	r24, Y+8	; 0x08
    3fe0:	88 23       	and	r24, r24
    3fe2:	89 f0       	breq	.+34     	; 0x4006 <xQueueGenericReset+0x72>
    3fe4:	ce 01       	movw	r24, r28
    3fe6:	08 96       	adiw	r24, 0x08	; 8
    3fe8:	0e 94 f5 18 	call	0x31ea	; 0x31ea <xTaskRemoveFromEventList>
    3fec:	88 23       	and	r24, r24
    3fee:	59 f0       	breq	.+22     	; 0x4006 <xQueueGenericReset+0x72>
    3ff0:	0e 94 5b 1e 	call	0x3cb6	; 0x3cb6 <vPortYield>
    3ff4:	08 c0       	rjmp	.+16     	; 0x4006 <xQueueGenericReset+0x72>
    3ff6:	ce 01       	movw	r24, r28
    3ff8:	08 96       	adiw	r24, 0x08	; 8
    3ffa:	0e 94 28 1d 	call	0x3a50	; 0x3a50 <vListInitialise>
    3ffe:	ce 01       	movw	r24, r28
    4000:	41 96       	adiw	r24, 0x11	; 17
    4002:	0e 94 28 1d 	call	0x3a50	; 0x3a50 <vListInitialise>
    4006:	0f 90       	pop	r0
    4008:	0f be       	out	0x3f, r0	; 63
    400a:	81 e0       	ldi	r24, 0x01	; 1
    400c:	df 91       	pop	r29
    400e:	cf 91       	pop	r28
    4010:	08 95       	ret

00004012 <xQueueGenericCreate>:
    4012:	0f 93       	push	r16
    4014:	1f 93       	push	r17
    4016:	cf 93       	push	r28
    4018:	df 93       	push	r29
    401a:	08 2f       	mov	r16, r24
    401c:	16 2f       	mov	r17, r22
    401e:	66 23       	and	r22, r22
    4020:	21 f0       	breq	.+8      	; 0x402a <xQueueGenericCreate+0x18>
    4022:	86 9f       	mul	r24, r22
    4024:	c0 01       	movw	r24, r0
    4026:	11 24       	eor	r1, r1
    4028:	02 c0       	rjmp	.+4      	; 0x402e <xQueueGenericCreate+0x1c>
    402a:	80 e0       	ldi	r24, 0x00	; 0
    402c:	90 e0       	ldi	r25, 0x00	; 0
    402e:	4f 96       	adiw	r24, 0x1f	; 31
    4030:	0e 94 04 1d 	call	0x3a08	; 0x3a08 <pvPortMalloc>
    4034:	ec 01       	movw	r28, r24
    4036:	00 97       	sbiw	r24, 0x00	; 0
    4038:	71 f0       	breq	.+28     	; 0x4056 <xQueueGenericCreate+0x44>
    403a:	11 11       	cpse	r17, r1
    403c:	03 c0       	rjmp	.+6      	; 0x4044 <xQueueGenericCreate+0x32>
    403e:	99 83       	std	Y+1, r25	; 0x01
    4040:	88 83       	st	Y, r24
    4042:	03 c0       	rjmp	.+6      	; 0x404a <xQueueGenericCreate+0x38>
    4044:	4f 96       	adiw	r24, 0x1f	; 31
    4046:	99 83       	std	Y+1, r25	; 0x01
    4048:	88 83       	st	Y, r24
    404a:	0b 8f       	std	Y+27, r16	; 0x1b
    404c:	1c 8f       	std	Y+28, r17	; 0x1c
    404e:	61 e0       	ldi	r22, 0x01	; 1
    4050:	ce 01       	movw	r24, r28
    4052:	0e 94 ca 1f 	call	0x3f94	; 0x3f94 <xQueueGenericReset>
    4056:	ce 01       	movw	r24, r28
    4058:	df 91       	pop	r29
    405a:	cf 91       	pop	r28
    405c:	1f 91       	pop	r17
    405e:	0f 91       	pop	r16
    4060:	08 95       	ret

00004062 <xQueueGenericSend>:
    4062:	af 92       	push	r10
    4064:	bf 92       	push	r11
    4066:	cf 92       	push	r12
    4068:	df 92       	push	r13
    406a:	ff 92       	push	r15
    406c:	0f 93       	push	r16
    406e:	1f 93       	push	r17
    4070:	cf 93       	push	r28
    4072:	df 93       	push	r29
    4074:	00 d0       	rcall	.+0      	; 0x4076 <xQueueGenericSend+0x14>
    4076:	00 d0       	rcall	.+0      	; 0x4078 <xQueueGenericSend+0x16>
    4078:	1f 92       	push	r1
    407a:	cd b7       	in	r28, 0x3d	; 61
    407c:	de b7       	in	r29, 0x3e	; 62
    407e:	8c 01       	movw	r16, r24
    4080:	6b 01       	movw	r12, r22
    4082:	5d 83       	std	Y+5, r21	; 0x05
    4084:	4c 83       	std	Y+4, r20	; 0x04
    4086:	f2 2e       	mov	r15, r18
    4088:	80 e0       	ldi	r24, 0x00	; 0
    408a:	58 01       	movw	r10, r16
    408c:	98 e0       	ldi	r25, 0x08	; 8
    408e:	a9 0e       	add	r10, r25
    4090:	b1 1c       	adc	r11, r1
    4092:	0f b6       	in	r0, 0x3f	; 63
    4094:	f8 94       	cli
    4096:	0f 92       	push	r0
    4098:	f8 01       	movw	r30, r16
    409a:	22 8d       	ldd	r18, Z+26	; 0x1a
    409c:	93 8d       	ldd	r25, Z+27	; 0x1b
    409e:	29 17       	cp	r18, r25
    40a0:	18 f0       	brcs	.+6      	; 0x40a8 <xQueueGenericSend+0x46>
    40a2:	f2 e0       	ldi	r31, 0x02	; 2
    40a4:	ff 12       	cpse	r15, r31
    40a6:	14 c0       	rjmp	.+40     	; 0x40d0 <xQueueGenericSend+0x6e>
    40a8:	4f 2d       	mov	r20, r15
    40aa:	b6 01       	movw	r22, r12
    40ac:	c8 01       	movw	r24, r16
    40ae:	0e 94 1f 1f 	call	0x3e3e	; 0x3e3e <prvCopyDataToQueue>
    40b2:	f8 01       	movw	r30, r16
    40b4:	91 89       	ldd	r25, Z+17	; 0x11
    40b6:	99 23       	and	r25, r25
    40b8:	21 f0       	breq	.+8      	; 0x40c2 <xQueueGenericSend+0x60>
    40ba:	c8 01       	movw	r24, r16
    40bc:	41 96       	adiw	r24, 0x11	; 17
    40be:	0e 94 f5 18 	call	0x31ea	; 0x31ea <xTaskRemoveFromEventList>
    40c2:	81 11       	cpse	r24, r1
    40c4:	0e 94 5b 1e 	call	0x3cb6	; 0x3cb6 <vPortYield>
    40c8:	0f 90       	pop	r0
    40ca:	0f be       	out	0x3f, r0	; 63
    40cc:	81 e0       	ldi	r24, 0x01	; 1
    40ce:	50 c0       	rjmp	.+160    	; 0x4170 <xQueueGenericSend+0x10e>
    40d0:	2c 81       	ldd	r18, Y+4	; 0x04
    40d2:	3d 81       	ldd	r19, Y+5	; 0x05
    40d4:	23 2b       	or	r18, r19
    40d6:	19 f4       	brne	.+6      	; 0x40de <xQueueGenericSend+0x7c>
    40d8:	0f 90       	pop	r0
    40da:	0f be       	out	0x3f, r0	; 63
    40dc:	48 c0       	rjmp	.+144    	; 0x416e <xQueueGenericSend+0x10c>
    40de:	81 11       	cpse	r24, r1
    40e0:	04 c0       	rjmp	.+8      	; 0x40ea <xQueueGenericSend+0x88>
    40e2:	ce 01       	movw	r24, r28
    40e4:	01 96       	adiw	r24, 0x01	; 1
    40e6:	0e 94 35 19 	call	0x326a	; 0x326a <vTaskInternalSetTimeOutState>
    40ea:	0f 90       	pop	r0
    40ec:	0f be       	out	0x3f, r0	; 63
    40ee:	0e 94 0b 17 	call	0x2e16	; 0x2e16 <vTaskSuspendAll>
    40f2:	0f b6       	in	r0, 0x3f	; 63
    40f4:	f8 94       	cli
    40f6:	0f 92       	push	r0
    40f8:	f8 01       	movw	r30, r16
    40fa:	85 8d       	ldd	r24, Z+29	; 0x1d
    40fc:	8f 3f       	cpi	r24, 0xFF	; 255
    40fe:	09 f4       	brne	.+2      	; 0x4102 <xQueueGenericSend+0xa0>
    4100:	15 8e       	std	Z+29, r1	; 0x1d
    4102:	f8 01       	movw	r30, r16
    4104:	86 8d       	ldd	r24, Z+30	; 0x1e
    4106:	8f 3f       	cpi	r24, 0xFF	; 255
    4108:	09 f4       	brne	.+2      	; 0x410c <xQueueGenericSend+0xaa>
    410a:	16 8e       	std	Z+30, r1	; 0x1e
    410c:	0f 90       	pop	r0
    410e:	0f be       	out	0x3f, r0	; 63
    4110:	be 01       	movw	r22, r28
    4112:	6c 5f       	subi	r22, 0xFC	; 252
    4114:	7f 4f       	sbci	r23, 0xFF	; 255
    4116:	ce 01       	movw	r24, r28
    4118:	01 96       	adiw	r24, 0x01	; 1
    411a:	0e 94 40 19 	call	0x3280	; 0x3280 <xTaskCheckForTimeOut>
    411e:	81 11       	cpse	r24, r1
    4120:	21 c0       	rjmp	.+66     	; 0x4164 <xQueueGenericSend+0x102>
    4122:	0f b6       	in	r0, 0x3f	; 63
    4124:	f8 94       	cli
    4126:	0f 92       	push	r0
    4128:	f8 01       	movw	r30, r16
    412a:	92 8d       	ldd	r25, Z+26	; 0x1a
    412c:	83 8d       	ldd	r24, Z+27	; 0x1b
    412e:	0f 90       	pop	r0
    4130:	0f be       	out	0x3f, r0	; 63
    4132:	98 13       	cpse	r25, r24
    4134:	11 c0       	rjmp	.+34     	; 0x4158 <xQueueGenericSend+0xf6>
    4136:	6c 81       	ldd	r22, Y+4	; 0x04
    4138:	7d 81       	ldd	r23, Y+5	; 0x05
    413a:	c5 01       	movw	r24, r10
    413c:	0e 94 cc 18 	call	0x3198	; 0x3198 <vTaskPlaceOnEventList>
    4140:	c8 01       	movw	r24, r16
    4142:	0e 94 8c 1f 	call	0x3f18	; 0x3f18 <prvUnlockQueue>
    4146:	0e 94 c7 17 	call	0x2f8e	; 0x2f8e <xTaskResumeAll>
    414a:	88 23       	and	r24, r24
    414c:	11 f0       	breq	.+4      	; 0x4152 <xQueueGenericSend+0xf0>
    414e:	81 e0       	ldi	r24, 0x01	; 1
    4150:	a0 cf       	rjmp	.-192    	; 0x4092 <xQueueGenericSend+0x30>
    4152:	0e 94 5b 1e 	call	0x3cb6	; 0x3cb6 <vPortYield>
    4156:	fb cf       	rjmp	.-10     	; 0x414e <xQueueGenericSend+0xec>
    4158:	c8 01       	movw	r24, r16
    415a:	0e 94 8c 1f 	call	0x3f18	; 0x3f18 <prvUnlockQueue>
    415e:	0e 94 c7 17 	call	0x2f8e	; 0x2f8e <xTaskResumeAll>
    4162:	f5 cf       	rjmp	.-22     	; 0x414e <xQueueGenericSend+0xec>
    4164:	c8 01       	movw	r24, r16
    4166:	0e 94 8c 1f 	call	0x3f18	; 0x3f18 <prvUnlockQueue>
    416a:	0e 94 c7 17 	call	0x2f8e	; 0x2f8e <xTaskResumeAll>
    416e:	80 e0       	ldi	r24, 0x00	; 0
    4170:	0f 90       	pop	r0
    4172:	0f 90       	pop	r0
    4174:	0f 90       	pop	r0
    4176:	0f 90       	pop	r0
    4178:	0f 90       	pop	r0
    417a:	df 91       	pop	r29
    417c:	cf 91       	pop	r28
    417e:	1f 91       	pop	r17
    4180:	0f 91       	pop	r16
    4182:	ff 90       	pop	r15
    4184:	df 90       	pop	r13
    4186:	cf 90       	pop	r12
    4188:	bf 90       	pop	r11
    418a:	af 90       	pop	r10
    418c:	08 95       	ret

0000418e <xQueueGenericSendFromISR>:
    418e:	ef 92       	push	r14
    4190:	ff 92       	push	r15
    4192:	1f 93       	push	r17
    4194:	cf 93       	push	r28
    4196:	df 93       	push	r29
    4198:	ec 01       	movw	r28, r24
    419a:	9a 8d       	ldd	r25, Y+26	; 0x1a
    419c:	8b 8d       	ldd	r24, Y+27	; 0x1b
    419e:	98 17       	cp	r25, r24
    41a0:	10 f0       	brcs	.+4      	; 0x41a6 <xQueueGenericSendFromISR+0x18>
    41a2:	22 30       	cpi	r18, 0x02	; 2
    41a4:	e1 f4       	brne	.+56     	; 0x41de <xQueueGenericSendFromISR+0x50>
    41a6:	7a 01       	movw	r14, r20
    41a8:	1e 8d       	ldd	r17, Y+30	; 0x1e
    41aa:	42 2f       	mov	r20, r18
    41ac:	ce 01       	movw	r24, r28
    41ae:	0e 94 1f 1f 	call	0x3e3e	; 0x3e3e <prvCopyDataToQueue>
    41b2:	1f 3f       	cpi	r17, 0xFF	; 255
    41b4:	81 f4       	brne	.+32     	; 0x41d6 <xQueueGenericSendFromISR+0x48>
    41b6:	89 89       	ldd	r24, Y+17	; 0x11
    41b8:	88 23       	and	r24, r24
    41ba:	79 f0       	breq	.+30     	; 0x41da <xQueueGenericSendFromISR+0x4c>
    41bc:	ce 01       	movw	r24, r28
    41be:	41 96       	adiw	r24, 0x11	; 17
    41c0:	0e 94 f5 18 	call	0x31ea	; 0x31ea <xTaskRemoveFromEventList>
    41c4:	88 23       	and	r24, r24
    41c6:	49 f0       	breq	.+18     	; 0x41da <xQueueGenericSendFromISR+0x4c>
    41c8:	e1 14       	cp	r14, r1
    41ca:	f1 04       	cpc	r15, r1
    41cc:	31 f0       	breq	.+12     	; 0x41da <xQueueGenericSendFromISR+0x4c>
    41ce:	81 e0       	ldi	r24, 0x01	; 1
    41d0:	f7 01       	movw	r30, r14
    41d2:	80 83       	st	Z, r24
    41d4:	05 c0       	rjmp	.+10     	; 0x41e0 <xQueueGenericSendFromISR+0x52>
    41d6:	1f 5f       	subi	r17, 0xFF	; 255
    41d8:	1e 8f       	std	Y+30, r17	; 0x1e
    41da:	81 e0       	ldi	r24, 0x01	; 1
    41dc:	01 c0       	rjmp	.+2      	; 0x41e0 <xQueueGenericSendFromISR+0x52>
    41de:	80 e0       	ldi	r24, 0x00	; 0
    41e0:	df 91       	pop	r29
    41e2:	cf 91       	pop	r28
    41e4:	1f 91       	pop	r17
    41e6:	ff 90       	pop	r15
    41e8:	ef 90       	pop	r14
    41ea:	08 95       	ret

000041ec <xQueueReceive>:
    41ec:	af 92       	push	r10
    41ee:	bf 92       	push	r11
    41f0:	cf 92       	push	r12
    41f2:	df 92       	push	r13
    41f4:	ff 92       	push	r15
    41f6:	0f 93       	push	r16
    41f8:	1f 93       	push	r17
    41fa:	cf 93       	push	r28
    41fc:	df 93       	push	r29
    41fe:	00 d0       	rcall	.+0      	; 0x4200 <xQueueReceive+0x14>
    4200:	00 d0       	rcall	.+0      	; 0x4202 <xQueueReceive+0x16>
    4202:	1f 92       	push	r1
    4204:	cd b7       	in	r28, 0x3d	; 61
    4206:	de b7       	in	r29, 0x3e	; 62
    4208:	8c 01       	movw	r16, r24
    420a:	6b 01       	movw	r12, r22
    420c:	5d 83       	std	Y+5, r21	; 0x05
    420e:	4c 83       	std	Y+4, r20	; 0x04
    4210:	80 e0       	ldi	r24, 0x00	; 0
    4212:	58 01       	movw	r10, r16
    4214:	91 e1       	ldi	r25, 0x11	; 17
    4216:	a9 0e       	add	r10, r25
    4218:	b1 1c       	adc	r11, r1
    421a:	0f b6       	in	r0, 0x3f	; 63
    421c:	f8 94       	cli
    421e:	0f 92       	push	r0
    4220:	f8 01       	movw	r30, r16
    4222:	f2 8c       	ldd	r15, Z+26	; 0x1a
    4224:	ff 20       	and	r15, r15
    4226:	a9 f0       	breq	.+42     	; 0x4252 <xQueueReceive+0x66>
    4228:	b6 01       	movw	r22, r12
    422a:	c8 01       	movw	r24, r16
    422c:	0e 94 72 1f 	call	0x3ee4	; 0x3ee4 <prvCopyDataFromQueue>
    4230:	fa 94       	dec	r15
    4232:	f8 01       	movw	r30, r16
    4234:	f2 8e       	std	Z+26, r15	; 0x1a
    4236:	80 85       	ldd	r24, Z+8	; 0x08
    4238:	88 23       	and	r24, r24
    423a:	39 f0       	breq	.+14     	; 0x424a <xQueueReceive+0x5e>
    423c:	c8 01       	movw	r24, r16
    423e:	08 96       	adiw	r24, 0x08	; 8
    4240:	0e 94 f5 18 	call	0x31ea	; 0x31ea <xTaskRemoveFromEventList>
    4244:	81 11       	cpse	r24, r1
    4246:	0e 94 5b 1e 	call	0x3cb6	; 0x3cb6 <vPortYield>
    424a:	0f 90       	pop	r0
    424c:	0f be       	out	0x3f, r0	; 63
    424e:	81 e0       	ldi	r24, 0x01	; 1
    4250:	50 c0       	rjmp	.+160    	; 0x42f2 <xQueueReceive+0x106>
    4252:	2c 81       	ldd	r18, Y+4	; 0x04
    4254:	3d 81       	ldd	r19, Y+5	; 0x05
    4256:	23 2b       	or	r18, r19
    4258:	19 f4       	brne	.+6      	; 0x4260 <xQueueReceive+0x74>
    425a:	0f 90       	pop	r0
    425c:	0f be       	out	0x3f, r0	; 63
    425e:	48 c0       	rjmp	.+144    	; 0x42f0 <xQueueReceive+0x104>
    4260:	81 11       	cpse	r24, r1
    4262:	04 c0       	rjmp	.+8      	; 0x426c <xQueueReceive+0x80>
    4264:	ce 01       	movw	r24, r28
    4266:	01 96       	adiw	r24, 0x01	; 1
    4268:	0e 94 35 19 	call	0x326a	; 0x326a <vTaskInternalSetTimeOutState>
    426c:	0f 90       	pop	r0
    426e:	0f be       	out	0x3f, r0	; 63
    4270:	0e 94 0b 17 	call	0x2e16	; 0x2e16 <vTaskSuspendAll>
    4274:	0f b6       	in	r0, 0x3f	; 63
    4276:	f8 94       	cli
    4278:	0f 92       	push	r0
    427a:	f8 01       	movw	r30, r16
    427c:	85 8d       	ldd	r24, Z+29	; 0x1d
    427e:	8f 3f       	cpi	r24, 0xFF	; 255
    4280:	09 f4       	brne	.+2      	; 0x4284 <xQueueReceive+0x98>
    4282:	15 8e       	std	Z+29, r1	; 0x1d
    4284:	f8 01       	movw	r30, r16
    4286:	86 8d       	ldd	r24, Z+30	; 0x1e
    4288:	8f 3f       	cpi	r24, 0xFF	; 255
    428a:	09 f4       	brne	.+2      	; 0x428e <xQueueReceive+0xa2>
    428c:	16 8e       	std	Z+30, r1	; 0x1e
    428e:	0f 90       	pop	r0
    4290:	0f be       	out	0x3f, r0	; 63
    4292:	be 01       	movw	r22, r28
    4294:	6c 5f       	subi	r22, 0xFC	; 252
    4296:	7f 4f       	sbci	r23, 0xFF	; 255
    4298:	ce 01       	movw	r24, r28
    429a:	01 96       	adiw	r24, 0x01	; 1
    429c:	0e 94 40 19 	call	0x3280	; 0x3280 <xTaskCheckForTimeOut>
    42a0:	81 11       	cpse	r24, r1
    42a2:	1c c0       	rjmp	.+56     	; 0x42dc <xQueueReceive+0xf0>
    42a4:	c8 01       	movw	r24, r16
    42a6:	0e 94 14 1f 	call	0x3e28	; 0x3e28 <prvIsQueueEmpty>
    42aa:	88 23       	and	r24, r24
    42ac:	89 f0       	breq	.+34     	; 0x42d0 <xQueueReceive+0xe4>
    42ae:	6c 81       	ldd	r22, Y+4	; 0x04
    42b0:	7d 81       	ldd	r23, Y+5	; 0x05
    42b2:	c5 01       	movw	r24, r10
    42b4:	0e 94 cc 18 	call	0x3198	; 0x3198 <vTaskPlaceOnEventList>
    42b8:	c8 01       	movw	r24, r16
    42ba:	0e 94 8c 1f 	call	0x3f18	; 0x3f18 <prvUnlockQueue>
    42be:	0e 94 c7 17 	call	0x2f8e	; 0x2f8e <xTaskResumeAll>
    42c2:	88 23       	and	r24, r24
    42c4:	11 f0       	breq	.+4      	; 0x42ca <xQueueReceive+0xde>
    42c6:	81 e0       	ldi	r24, 0x01	; 1
    42c8:	a8 cf       	rjmp	.-176    	; 0x421a <xQueueReceive+0x2e>
    42ca:	0e 94 5b 1e 	call	0x3cb6	; 0x3cb6 <vPortYield>
    42ce:	fb cf       	rjmp	.-10     	; 0x42c6 <xQueueReceive+0xda>
    42d0:	c8 01       	movw	r24, r16
    42d2:	0e 94 8c 1f 	call	0x3f18	; 0x3f18 <prvUnlockQueue>
    42d6:	0e 94 c7 17 	call	0x2f8e	; 0x2f8e <xTaskResumeAll>
    42da:	f5 cf       	rjmp	.-22     	; 0x42c6 <xQueueReceive+0xda>
    42dc:	c8 01       	movw	r24, r16
    42de:	0e 94 8c 1f 	call	0x3f18	; 0x3f18 <prvUnlockQueue>
    42e2:	0e 94 c7 17 	call	0x2f8e	; 0x2f8e <xTaskResumeAll>
    42e6:	c8 01       	movw	r24, r16
    42e8:	0e 94 14 1f 	call	0x3e28	; 0x3e28 <prvIsQueueEmpty>
    42ec:	88 23       	and	r24, r24
    42ee:	59 f3       	breq	.-42     	; 0x42c6 <xQueueReceive+0xda>
    42f0:	80 e0       	ldi	r24, 0x00	; 0
    42f2:	0f 90       	pop	r0
    42f4:	0f 90       	pop	r0
    42f6:	0f 90       	pop	r0
    42f8:	0f 90       	pop	r0
    42fa:	0f 90       	pop	r0
    42fc:	df 91       	pop	r29
    42fe:	cf 91       	pop	r28
    4300:	1f 91       	pop	r17
    4302:	0f 91       	pop	r16
    4304:	ff 90       	pop	r15
    4306:	df 90       	pop	r13
    4308:	cf 90       	pop	r12
    430a:	bf 90       	pop	r11
    430c:	af 90       	pop	r10
    430e:	08 95       	ret

00004310 <vQueueWaitForMessageRestricted>:
/*-----------------------------------------------------------*/

#if ( configUSE_TIMERS == 1 )

    void vQueueWaitForMessageRestricted( QueueHandle_t xQueue, TickType_t xTicksToWait, const BaseType_t xWaitIndefinitely )
    {
    4310:	cf 93       	push	r28
    4312:	df 93       	push	r29
    4314:	ec 01       	movw	r28, r24
        will not actually cause the task to block, just place it on a blocked
        list.  It will not block until the scheduler is unlocked - at which
        time a yield will be performed.  If an item is added to the queue while
        the queue is locked, and the calling task blocks on the queue, then the
        calling task will be immediately unblocked when the queue is unlocked. */
        prvLockQueue( pxQueue );
    4316:	0f b6       	in	r0, 0x3f	; 63
    4318:	f8 94       	cli
    431a:	0f 92       	push	r0
    431c:	8d 8d       	ldd	r24, Y+29	; 0x1d
    431e:	8f 3f       	cpi	r24, 0xFF	; 255
    4320:	09 f4       	brne	.+2      	; 0x4324 <vQueueWaitForMessageRestricted+0x14>
    4322:	1d 8e       	std	Y+29, r1	; 0x1d
    4324:	8e 8d       	ldd	r24, Y+30	; 0x1e
    4326:	8f 3f       	cpi	r24, 0xFF	; 255
    4328:	09 f4       	brne	.+2      	; 0x432c <vQueueWaitForMessageRestricted+0x1c>
    432a:	1e 8e       	std	Y+30, r1	; 0x1e
    432c:	0f 90       	pop	r0
    432e:	0f be       	out	0x3f, r0	; 63
        if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0U )
    4330:	8a 8d       	ldd	r24, Y+26	; 0x1a
    4332:	81 11       	cpse	r24, r1
    4334:	04 c0       	rjmp	.+8      	; 0x433e <vQueueWaitForMessageRestricted+0x2e>
        {
            /* There is nothing in the queue, block for the specified period. */
            vTaskPlaceOnEventListRestricted( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait, xWaitIndefinitely );
    4336:	ce 01       	movw	r24, r28
    4338:	41 96       	adiw	r24, 0x11	; 17
    433a:	0e 94 dd 18 	call	0x31ba	; 0x31ba <vTaskPlaceOnEventListRestricted>
        }
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }
        prvUnlockQueue( pxQueue );
    433e:	ce 01       	movw	r24, r28
    }
    4340:	df 91       	pop	r29
    4342:	cf 91       	pop	r28
        }
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }
        prvUnlockQueue( pxQueue );
    4344:	0c 94 8c 1f 	jmp	0x3f18	; 0x3f18 <prvUnlockQueue>

00004348 <__unordsf2>:
    4348:	0e 94 7d 0d 	call	0x1afa	; 0x1afa <__fp_cmp>
    434c:	88 0b       	sbc	r24, r24
    434e:	99 0b       	sbc	r25, r25
    4350:	08 95       	ret

00004352 <__divmodhi4>:
    4352:	97 fb       	bst	r25, 7
    4354:	07 2e       	mov	r0, r23
    4356:	16 f4       	brtc	.+4      	; 0x435c <__divmodhi4+0xa>
    4358:	00 94       	com	r0
    435a:	07 d0       	rcall	.+14     	; 0x436a <__divmodhi4_neg1>
    435c:	77 fd       	sbrc	r23, 7
    435e:	09 d0       	rcall	.+18     	; 0x4372 <__divmodhi4_neg2>
    4360:	0e 94 0f 22 	call	0x441e	; 0x441e <__udivmodhi4>
    4364:	07 fc       	sbrc	r0, 7
    4366:	05 d0       	rcall	.+10     	; 0x4372 <__divmodhi4_neg2>
    4368:	3e f4       	brtc	.+14     	; 0x4378 <__divmodhi4_exit>

0000436a <__divmodhi4_neg1>:
    436a:	90 95       	com	r25
    436c:	81 95       	neg	r24
    436e:	9f 4f       	sbci	r25, 0xFF	; 255
    4370:	08 95       	ret

00004372 <__divmodhi4_neg2>:
    4372:	70 95       	com	r23
    4374:	61 95       	neg	r22
    4376:	7f 4f       	sbci	r23, 0xFF	; 255

00004378 <__divmodhi4_exit>:
    4378:	08 95       	ret

0000437a <__udivmodsi4>:
    437a:	a1 e2       	ldi	r26, 0x21	; 33
    437c:	1a 2e       	mov	r1, r26
    437e:	aa 1b       	sub	r26, r26
    4380:	bb 1b       	sub	r27, r27
    4382:	fd 01       	movw	r30, r26
    4384:	0d c0       	rjmp	.+26     	; 0x43a0 <__udivmodsi4_ep>

00004386 <__udivmodsi4_loop>:
    4386:	aa 1f       	adc	r26, r26
    4388:	bb 1f       	adc	r27, r27
    438a:	ee 1f       	adc	r30, r30
    438c:	ff 1f       	adc	r31, r31
    438e:	a2 17       	cp	r26, r18
    4390:	b3 07       	cpc	r27, r19
    4392:	e4 07       	cpc	r30, r20
    4394:	f5 07       	cpc	r31, r21
    4396:	20 f0       	brcs	.+8      	; 0x43a0 <__udivmodsi4_ep>
    4398:	a2 1b       	sub	r26, r18
    439a:	b3 0b       	sbc	r27, r19
    439c:	e4 0b       	sbc	r30, r20
    439e:	f5 0b       	sbc	r31, r21

000043a0 <__udivmodsi4_ep>:
    43a0:	66 1f       	adc	r22, r22
    43a2:	77 1f       	adc	r23, r23
    43a4:	88 1f       	adc	r24, r24
    43a6:	99 1f       	adc	r25, r25
    43a8:	1a 94       	dec	r1
    43aa:	69 f7       	brne	.-38     	; 0x4386 <__udivmodsi4_loop>
    43ac:	60 95       	com	r22
    43ae:	70 95       	com	r23
    43b0:	80 95       	com	r24
    43b2:	90 95       	com	r25
    43b4:	9b 01       	movw	r18, r22
    43b6:	ac 01       	movw	r20, r24
    43b8:	bd 01       	movw	r22, r26
    43ba:	cf 01       	movw	r24, r30
    43bc:	08 95       	ret

000043be <__divmodsi4>:
    43be:	05 2e       	mov	r0, r21
    43c0:	97 fb       	bst	r25, 7
    43c2:	1e f4       	brtc	.+6      	; 0x43ca <__divmodsi4+0xc>
    43c4:	00 94       	com	r0
    43c6:	0e 94 f6 21 	call	0x43ec	; 0x43ec <__negsi2>
    43ca:	57 fd       	sbrc	r21, 7
    43cc:	07 d0       	rcall	.+14     	; 0x43dc <__divmodsi4_neg2>
    43ce:	0e 94 bd 21 	call	0x437a	; 0x437a <__udivmodsi4>
    43d2:	07 fc       	sbrc	r0, 7
    43d4:	03 d0       	rcall	.+6      	; 0x43dc <__divmodsi4_neg2>
    43d6:	4e f4       	brtc	.+18     	; 0x43ea <__divmodsi4_exit>
    43d8:	0c 94 f6 21 	jmp	0x43ec	; 0x43ec <__negsi2>

000043dc <__divmodsi4_neg2>:
    43dc:	50 95       	com	r21
    43de:	40 95       	com	r20
    43e0:	30 95       	com	r19
    43e2:	21 95       	neg	r18
    43e4:	3f 4f       	sbci	r19, 0xFF	; 255
    43e6:	4f 4f       	sbci	r20, 0xFF	; 255
    43e8:	5f 4f       	sbci	r21, 0xFF	; 255

000043ea <__divmodsi4_exit>:
    43ea:	08 95       	ret

000043ec <__negsi2>:
    43ec:	90 95       	com	r25
    43ee:	80 95       	com	r24
    43f0:	70 95       	com	r23
    43f2:	61 95       	neg	r22
    43f4:	7f 4f       	sbci	r23, 0xFF	; 255
    43f6:	8f 4f       	sbci	r24, 0xFF	; 255
    43f8:	9f 4f       	sbci	r25, 0xFF	; 255
    43fa:	08 95       	ret

000043fc <__tablejump2__>:
    43fc:	ee 0f       	add	r30, r30
    43fe:	ff 1f       	adc	r31, r31
    4400:	05 90       	lpm	r0, Z+
    4402:	f4 91       	lpm	r31, Z
    4404:	e0 2d       	mov	r30, r0
    4406:	09 94       	ijmp

00004408 <__muluhisi3>:
    4408:	0e 94 23 22 	call	0x4446	; 0x4446 <__umulhisi3>
    440c:	a5 9f       	mul	r26, r21
    440e:	90 0d       	add	r25, r0
    4410:	b4 9f       	mul	r27, r20
    4412:	90 0d       	add	r25, r0
    4414:	a4 9f       	mul	r26, r20
    4416:	80 0d       	add	r24, r0
    4418:	91 1d       	adc	r25, r1
    441a:	11 24       	eor	r1, r1
    441c:	08 95       	ret

0000441e <__udivmodhi4>:
    441e:	aa 1b       	sub	r26, r26
    4420:	bb 1b       	sub	r27, r27
    4422:	51 e1       	ldi	r21, 0x11	; 17
    4424:	07 c0       	rjmp	.+14     	; 0x4434 <__udivmodhi4_ep>

00004426 <__udivmodhi4_loop>:
    4426:	aa 1f       	adc	r26, r26
    4428:	bb 1f       	adc	r27, r27
    442a:	a6 17       	cp	r26, r22
    442c:	b7 07       	cpc	r27, r23
    442e:	10 f0       	brcs	.+4      	; 0x4434 <__udivmodhi4_ep>
    4430:	a6 1b       	sub	r26, r22
    4432:	b7 0b       	sbc	r27, r23

00004434 <__udivmodhi4_ep>:
    4434:	88 1f       	adc	r24, r24
    4436:	99 1f       	adc	r25, r25
    4438:	5a 95       	dec	r21
    443a:	a9 f7       	brne	.-22     	; 0x4426 <__udivmodhi4_loop>
    443c:	80 95       	com	r24
    443e:	90 95       	com	r25
    4440:	bc 01       	movw	r22, r24
    4442:	cd 01       	movw	r24, r26
    4444:	08 95       	ret

00004446 <__umulhisi3>:
    4446:	a2 9f       	mul	r26, r18
    4448:	b0 01       	movw	r22, r0
    444a:	b3 9f       	mul	r27, r19
    444c:	c0 01       	movw	r24, r0
    444e:	a3 9f       	mul	r26, r19
    4450:	70 0d       	add	r23, r0
    4452:	81 1d       	adc	r24, r1
    4454:	11 24       	eor	r1, r1
    4456:	91 1d       	adc	r25, r1
    4458:	b2 9f       	mul	r27, r18
    445a:	70 0d       	add	r23, r0
    445c:	81 1d       	adc	r24, r1
    445e:	11 24       	eor	r1, r1
    4460:	91 1d       	adc	r25, r1
    4462:	08 95       	ret

00004464 <malloc>:
    4464:	0f 93       	push	r16
    4466:	1f 93       	push	r17
    4468:	cf 93       	push	r28
    446a:	df 93       	push	r29
    446c:	82 30       	cpi	r24, 0x02	; 2
    446e:	91 05       	cpc	r25, r1
    4470:	10 f4       	brcc	.+4      	; 0x4476 <malloc+0x12>
    4472:	82 e0       	ldi	r24, 0x02	; 2
    4474:	90 e0       	ldi	r25, 0x00	; 0
    4476:	e0 91 f6 04 	lds	r30, 0x04F6	; 0x8004f6 <__flp>
    447a:	f0 91 f7 04 	lds	r31, 0x04F7	; 0x8004f7 <__flp+0x1>
    447e:	20 e0       	ldi	r18, 0x00	; 0
    4480:	30 e0       	ldi	r19, 0x00	; 0
    4482:	a0 e0       	ldi	r26, 0x00	; 0
    4484:	b0 e0       	ldi	r27, 0x00	; 0
    4486:	30 97       	sbiw	r30, 0x00	; 0
    4488:	19 f1       	breq	.+70     	; 0x44d0 <malloc+0x6c>
    448a:	40 81       	ld	r20, Z
    448c:	51 81       	ldd	r21, Z+1	; 0x01
    448e:	02 81       	ldd	r16, Z+2	; 0x02
    4490:	13 81       	ldd	r17, Z+3	; 0x03
    4492:	48 17       	cp	r20, r24
    4494:	59 07       	cpc	r21, r25
    4496:	c8 f0       	brcs	.+50     	; 0x44ca <malloc+0x66>
    4498:	84 17       	cp	r24, r20
    449a:	95 07       	cpc	r25, r21
    449c:	69 f4       	brne	.+26     	; 0x44b8 <malloc+0x54>
    449e:	10 97       	sbiw	r26, 0x00	; 0
    44a0:	31 f0       	breq	.+12     	; 0x44ae <malloc+0x4a>
    44a2:	12 96       	adiw	r26, 0x02	; 2
    44a4:	0c 93       	st	X, r16
    44a6:	12 97       	sbiw	r26, 0x02	; 2
    44a8:	13 96       	adiw	r26, 0x03	; 3
    44aa:	1c 93       	st	X, r17
    44ac:	27 c0       	rjmp	.+78     	; 0x44fc <malloc+0x98>
    44ae:	00 93 f6 04 	sts	0x04F6, r16	; 0x8004f6 <__flp>
    44b2:	10 93 f7 04 	sts	0x04F7, r17	; 0x8004f7 <__flp+0x1>
    44b6:	22 c0       	rjmp	.+68     	; 0x44fc <malloc+0x98>
    44b8:	21 15       	cp	r18, r1
    44ba:	31 05       	cpc	r19, r1
    44bc:	19 f0       	breq	.+6      	; 0x44c4 <malloc+0x60>
    44be:	42 17       	cp	r20, r18
    44c0:	53 07       	cpc	r21, r19
    44c2:	18 f4       	brcc	.+6      	; 0x44ca <malloc+0x66>
    44c4:	9a 01       	movw	r18, r20
    44c6:	bd 01       	movw	r22, r26
    44c8:	ef 01       	movw	r28, r30
    44ca:	df 01       	movw	r26, r30
    44cc:	f8 01       	movw	r30, r16
    44ce:	db cf       	rjmp	.-74     	; 0x4486 <malloc+0x22>
    44d0:	21 15       	cp	r18, r1
    44d2:	31 05       	cpc	r19, r1
    44d4:	f9 f0       	breq	.+62     	; 0x4514 <malloc+0xb0>
    44d6:	28 1b       	sub	r18, r24
    44d8:	39 0b       	sbc	r19, r25
    44da:	24 30       	cpi	r18, 0x04	; 4
    44dc:	31 05       	cpc	r19, r1
    44de:	80 f4       	brcc	.+32     	; 0x4500 <malloc+0x9c>
    44e0:	8a 81       	ldd	r24, Y+2	; 0x02
    44e2:	9b 81       	ldd	r25, Y+3	; 0x03
    44e4:	61 15       	cp	r22, r1
    44e6:	71 05       	cpc	r23, r1
    44e8:	21 f0       	breq	.+8      	; 0x44f2 <malloc+0x8e>
    44ea:	fb 01       	movw	r30, r22
    44ec:	93 83       	std	Z+3, r25	; 0x03
    44ee:	82 83       	std	Z+2, r24	; 0x02
    44f0:	04 c0       	rjmp	.+8      	; 0x44fa <malloc+0x96>
    44f2:	90 93 f7 04 	sts	0x04F7, r25	; 0x8004f7 <__flp+0x1>
    44f6:	80 93 f6 04 	sts	0x04F6, r24	; 0x8004f6 <__flp>
    44fa:	fe 01       	movw	r30, r28
    44fc:	32 96       	adiw	r30, 0x02	; 2
    44fe:	44 c0       	rjmp	.+136    	; 0x4588 <malloc+0x124>
    4500:	fe 01       	movw	r30, r28
    4502:	e2 0f       	add	r30, r18
    4504:	f3 1f       	adc	r31, r19
    4506:	81 93       	st	Z+, r24
    4508:	91 93       	st	Z+, r25
    450a:	22 50       	subi	r18, 0x02	; 2
    450c:	31 09       	sbc	r19, r1
    450e:	39 83       	std	Y+1, r19	; 0x01
    4510:	28 83       	st	Y, r18
    4512:	3a c0       	rjmp	.+116    	; 0x4588 <malloc+0x124>
    4514:	20 91 f4 04 	lds	r18, 0x04F4	; 0x8004f4 <__brkval>
    4518:	30 91 f5 04 	lds	r19, 0x04F5	; 0x8004f5 <__brkval+0x1>
    451c:	23 2b       	or	r18, r19
    451e:	41 f4       	brne	.+16     	; 0x4530 <malloc+0xcc>
    4520:	20 91 02 01 	lds	r18, 0x0102	; 0x800102 <__malloc_heap_start>
    4524:	30 91 03 01 	lds	r19, 0x0103	; 0x800103 <__malloc_heap_start+0x1>
    4528:	30 93 f5 04 	sts	0x04F5, r19	; 0x8004f5 <__brkval+0x1>
    452c:	20 93 f4 04 	sts	0x04F4, r18	; 0x8004f4 <__brkval>
    4530:	20 91 00 01 	lds	r18, 0x0100	; 0x800100 <__data_start>
    4534:	30 91 01 01 	lds	r19, 0x0101	; 0x800101 <__data_start+0x1>
    4538:	21 15       	cp	r18, r1
    453a:	31 05       	cpc	r19, r1
    453c:	41 f4       	brne	.+16     	; 0x454e <malloc+0xea>
    453e:	2d b7       	in	r18, 0x3d	; 61
    4540:	3e b7       	in	r19, 0x3e	; 62
    4542:	40 91 04 01 	lds	r20, 0x0104	; 0x800104 <__malloc_margin>
    4546:	50 91 05 01 	lds	r21, 0x0105	; 0x800105 <__malloc_margin+0x1>
    454a:	24 1b       	sub	r18, r20
    454c:	35 0b       	sbc	r19, r21
    454e:	e0 91 f4 04 	lds	r30, 0x04F4	; 0x8004f4 <__brkval>
    4552:	f0 91 f5 04 	lds	r31, 0x04F5	; 0x8004f5 <__brkval+0x1>
    4556:	e2 17       	cp	r30, r18
    4558:	f3 07       	cpc	r31, r19
    455a:	a0 f4       	brcc	.+40     	; 0x4584 <malloc+0x120>
    455c:	2e 1b       	sub	r18, r30
    455e:	3f 0b       	sbc	r19, r31
    4560:	28 17       	cp	r18, r24
    4562:	39 07       	cpc	r19, r25
    4564:	78 f0       	brcs	.+30     	; 0x4584 <malloc+0x120>
    4566:	ac 01       	movw	r20, r24
    4568:	4e 5f       	subi	r20, 0xFE	; 254
    456a:	5f 4f       	sbci	r21, 0xFF	; 255
    456c:	24 17       	cp	r18, r20
    456e:	35 07       	cpc	r19, r21
    4570:	48 f0       	brcs	.+18     	; 0x4584 <malloc+0x120>
    4572:	4e 0f       	add	r20, r30
    4574:	5f 1f       	adc	r21, r31
    4576:	50 93 f5 04 	sts	0x04F5, r21	; 0x8004f5 <__brkval+0x1>
    457a:	40 93 f4 04 	sts	0x04F4, r20	; 0x8004f4 <__brkval>
    457e:	81 93       	st	Z+, r24
    4580:	91 93       	st	Z+, r25
    4582:	02 c0       	rjmp	.+4      	; 0x4588 <malloc+0x124>
    4584:	e0 e0       	ldi	r30, 0x00	; 0
    4586:	f0 e0       	ldi	r31, 0x00	; 0
    4588:	cf 01       	movw	r24, r30
    458a:	df 91       	pop	r29
    458c:	cf 91       	pop	r28
    458e:	1f 91       	pop	r17
    4590:	0f 91       	pop	r16
    4592:	08 95       	ret

00004594 <free>:
    4594:	cf 93       	push	r28
    4596:	df 93       	push	r29
    4598:	00 97       	sbiw	r24, 0x00	; 0
    459a:	09 f4       	brne	.+2      	; 0x459e <free+0xa>
    459c:	81 c0       	rjmp	.+258    	; 0x46a0 <free+0x10c>
    459e:	fc 01       	movw	r30, r24
    45a0:	32 97       	sbiw	r30, 0x02	; 2
    45a2:	13 82       	std	Z+3, r1	; 0x03
    45a4:	12 82       	std	Z+2, r1	; 0x02
    45a6:	a0 91 f6 04 	lds	r26, 0x04F6	; 0x8004f6 <__flp>
    45aa:	b0 91 f7 04 	lds	r27, 0x04F7	; 0x8004f7 <__flp+0x1>
    45ae:	10 97       	sbiw	r26, 0x00	; 0
    45b0:	81 f4       	brne	.+32     	; 0x45d2 <free+0x3e>
    45b2:	20 81       	ld	r18, Z
    45b4:	31 81       	ldd	r19, Z+1	; 0x01
    45b6:	82 0f       	add	r24, r18
    45b8:	93 1f       	adc	r25, r19
    45ba:	20 91 f4 04 	lds	r18, 0x04F4	; 0x8004f4 <__brkval>
    45be:	30 91 f5 04 	lds	r19, 0x04F5	; 0x8004f5 <__brkval+0x1>
    45c2:	28 17       	cp	r18, r24
    45c4:	39 07       	cpc	r19, r25
    45c6:	51 f5       	brne	.+84     	; 0x461c <free+0x88>
    45c8:	f0 93 f5 04 	sts	0x04F5, r31	; 0x8004f5 <__brkval+0x1>
    45cc:	e0 93 f4 04 	sts	0x04F4, r30	; 0x8004f4 <__brkval>
    45d0:	67 c0       	rjmp	.+206    	; 0x46a0 <free+0x10c>
    45d2:	ed 01       	movw	r28, r26
    45d4:	20 e0       	ldi	r18, 0x00	; 0
    45d6:	30 e0       	ldi	r19, 0x00	; 0
    45d8:	ce 17       	cp	r28, r30
    45da:	df 07       	cpc	r29, r31
    45dc:	40 f4       	brcc	.+16     	; 0x45ee <free+0x5a>
    45de:	4a 81       	ldd	r20, Y+2	; 0x02
    45e0:	5b 81       	ldd	r21, Y+3	; 0x03
    45e2:	9e 01       	movw	r18, r28
    45e4:	41 15       	cp	r20, r1
    45e6:	51 05       	cpc	r21, r1
    45e8:	f1 f0       	breq	.+60     	; 0x4626 <free+0x92>
    45ea:	ea 01       	movw	r28, r20
    45ec:	f5 cf       	rjmp	.-22     	; 0x45d8 <free+0x44>
    45ee:	d3 83       	std	Z+3, r29	; 0x03
    45f0:	c2 83       	std	Z+2, r28	; 0x02
    45f2:	40 81       	ld	r20, Z
    45f4:	51 81       	ldd	r21, Z+1	; 0x01
    45f6:	84 0f       	add	r24, r20
    45f8:	95 1f       	adc	r25, r21
    45fa:	c8 17       	cp	r28, r24
    45fc:	d9 07       	cpc	r29, r25
    45fe:	59 f4       	brne	.+22     	; 0x4616 <free+0x82>
    4600:	88 81       	ld	r24, Y
    4602:	99 81       	ldd	r25, Y+1	; 0x01
    4604:	84 0f       	add	r24, r20
    4606:	95 1f       	adc	r25, r21
    4608:	02 96       	adiw	r24, 0x02	; 2
    460a:	91 83       	std	Z+1, r25	; 0x01
    460c:	80 83       	st	Z, r24
    460e:	8a 81       	ldd	r24, Y+2	; 0x02
    4610:	9b 81       	ldd	r25, Y+3	; 0x03
    4612:	93 83       	std	Z+3, r25	; 0x03
    4614:	82 83       	std	Z+2, r24	; 0x02
    4616:	21 15       	cp	r18, r1
    4618:	31 05       	cpc	r19, r1
    461a:	29 f4       	brne	.+10     	; 0x4626 <free+0x92>
    461c:	f0 93 f7 04 	sts	0x04F7, r31	; 0x8004f7 <__flp+0x1>
    4620:	e0 93 f6 04 	sts	0x04F6, r30	; 0x8004f6 <__flp>
    4624:	3d c0       	rjmp	.+122    	; 0x46a0 <free+0x10c>
    4626:	e9 01       	movw	r28, r18
    4628:	fb 83       	std	Y+3, r31	; 0x03
    462a:	ea 83       	std	Y+2, r30	; 0x02
    462c:	49 91       	ld	r20, Y+
    462e:	59 91       	ld	r21, Y+
    4630:	c4 0f       	add	r28, r20
    4632:	d5 1f       	adc	r29, r21
    4634:	ec 17       	cp	r30, r28
    4636:	fd 07       	cpc	r31, r29
    4638:	61 f4       	brne	.+24     	; 0x4652 <free+0xbe>
    463a:	80 81       	ld	r24, Z
    463c:	91 81       	ldd	r25, Z+1	; 0x01
    463e:	84 0f       	add	r24, r20
    4640:	95 1f       	adc	r25, r21
    4642:	02 96       	adiw	r24, 0x02	; 2
    4644:	e9 01       	movw	r28, r18
    4646:	99 83       	std	Y+1, r25	; 0x01
    4648:	88 83       	st	Y, r24
    464a:	82 81       	ldd	r24, Z+2	; 0x02
    464c:	93 81       	ldd	r25, Z+3	; 0x03
    464e:	9b 83       	std	Y+3, r25	; 0x03
    4650:	8a 83       	std	Y+2, r24	; 0x02
    4652:	e0 e0       	ldi	r30, 0x00	; 0
    4654:	f0 e0       	ldi	r31, 0x00	; 0
    4656:	12 96       	adiw	r26, 0x02	; 2
    4658:	8d 91       	ld	r24, X+
    465a:	9c 91       	ld	r25, X
    465c:	13 97       	sbiw	r26, 0x03	; 3
    465e:	00 97       	sbiw	r24, 0x00	; 0
    4660:	19 f0       	breq	.+6      	; 0x4668 <free+0xd4>
    4662:	fd 01       	movw	r30, r26
    4664:	dc 01       	movw	r26, r24
    4666:	f7 cf       	rjmp	.-18     	; 0x4656 <free+0xc2>
    4668:	8d 91       	ld	r24, X+
    466a:	9c 91       	ld	r25, X
    466c:	11 97       	sbiw	r26, 0x01	; 1
    466e:	9d 01       	movw	r18, r26
    4670:	2e 5f       	subi	r18, 0xFE	; 254
    4672:	3f 4f       	sbci	r19, 0xFF	; 255
    4674:	82 0f       	add	r24, r18
    4676:	93 1f       	adc	r25, r19
    4678:	20 91 f4 04 	lds	r18, 0x04F4	; 0x8004f4 <__brkval>
    467c:	30 91 f5 04 	lds	r19, 0x04F5	; 0x8004f5 <__brkval+0x1>
    4680:	28 17       	cp	r18, r24
    4682:	39 07       	cpc	r19, r25
    4684:	69 f4       	brne	.+26     	; 0x46a0 <free+0x10c>
    4686:	30 97       	sbiw	r30, 0x00	; 0
    4688:	29 f4       	brne	.+10     	; 0x4694 <free+0x100>
    468a:	10 92 f7 04 	sts	0x04F7, r1	; 0x8004f7 <__flp+0x1>
    468e:	10 92 f6 04 	sts	0x04F6, r1	; 0x8004f6 <__flp>
    4692:	02 c0       	rjmp	.+4      	; 0x4698 <free+0x104>
    4694:	13 82       	std	Z+3, r1	; 0x03
    4696:	12 82       	std	Z+2, r1	; 0x02
    4698:	b0 93 f5 04 	sts	0x04F5, r27	; 0x8004f5 <__brkval+0x1>
    469c:	a0 93 f4 04 	sts	0x04F4, r26	; 0x8004f4 <__brkval>
    46a0:	df 91       	pop	r29
    46a2:	cf 91       	pop	r28
    46a4:	08 95       	ret

000046a6 <memcpy>:
    46a6:	fb 01       	movw	r30, r22
    46a8:	dc 01       	movw	r26, r24
    46aa:	02 c0       	rjmp	.+4      	; 0x46b0 <memcpy+0xa>
    46ac:	01 90       	ld	r0, Z+
    46ae:	0d 92       	st	X+, r0
    46b0:	41 50       	subi	r20, 0x01	; 1
    46b2:	50 40       	sbci	r21, 0x00	; 0
    46b4:	d8 f7       	brcc	.-10     	; 0x46ac <memcpy+0x6>
    46b6:	08 95       	ret

000046b8 <memset>:
    46b8:	dc 01       	movw	r26, r24
    46ba:	01 c0       	rjmp	.+2      	; 0x46be <memset+0x6>
    46bc:	6d 93       	st	X+, r22
    46be:	41 50       	subi	r20, 0x01	; 1
    46c0:	50 40       	sbci	r21, 0x00	; 0
    46c2:	e0 f7       	brcc	.-8      	; 0x46bc <memset+0x4>
    46c4:	08 95       	ret

000046c6 <eeprom_read_byte>:
    46c6:	f9 99       	sbic	0x1f, 1	; 31
    46c8:	fe cf       	rjmp	.-4      	; 0x46c6 <eeprom_read_byte>
    46ca:	92 bd       	out	0x22, r25	; 34
    46cc:	81 bd       	out	0x21, r24	; 33
    46ce:	f8 9a       	sbi	0x1f, 0	; 31
    46d0:	99 27       	eor	r25, r25
    46d2:	80 b5       	in	r24, 0x20	; 32
    46d4:	08 95       	ret

000046d6 <eeprom_write_byte>:
    46d6:	26 2f       	mov	r18, r22

000046d8 <eeprom_write_r18>:
    46d8:	f9 99       	sbic	0x1f, 1	; 31
    46da:	fe cf       	rjmp	.-4      	; 0x46d8 <eeprom_write_r18>
    46dc:	1f ba       	out	0x1f, r1	; 31
    46de:	92 bd       	out	0x22, r25	; 34
    46e0:	81 bd       	out	0x21, r24	; 33
    46e2:	20 bd       	out	0x20, r18	; 32
    46e4:	0f b6       	in	r0, 0x3f	; 63
    46e6:	f8 94       	cli
    46e8:	fa 9a       	sbi	0x1f, 2	; 31
    46ea:	f9 9a       	sbi	0x1f, 1	; 31
    46ec:	0f be       	out	0x3f, r0	; 63
    46ee:	01 96       	adiw	r24, 0x01	; 1
    46f0:	08 95       	ret

000046f2 <__do_global_dtors>:
    46f2:	10 e0       	ldi	r17, 0x00	; 0
    46f4:	c9 e8       	ldi	r28, 0x89	; 137
    46f6:	d0 e0       	ldi	r29, 0x00	; 0
    46f8:	04 c0       	rjmp	.+8      	; 0x4702 <__do_global_dtors+0x10>
    46fa:	fe 01       	movw	r30, r28
    46fc:	0e 94 fe 21 	call	0x43fc	; 0x43fc <__tablejump2__>
    4700:	21 96       	adiw	r28, 0x01	; 1
    4702:	cb 38       	cpi	r28, 0x8B	; 139
    4704:	d1 07       	cpc	r29, r17
    4706:	c9 f7       	brne	.-14     	; 0x46fa <__do_global_dtors+0x8>
    4708:	f8 94       	cli

0000470a <__stop_program>:
    470a:	ff cf       	rjmp	.-2      	; 0x470a <__stop_program>
