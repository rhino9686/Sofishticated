
lil_fish_tanks_arduino.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         000000ae  00800100  00003f64  00003ff8  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00003f64  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000240  008001ae  008001ae  000040a6  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  000040a6  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  000040d8  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000918  00000000  00000000  00004118  2**3
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   000117d9  00000000  00000000  00004a30  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00003696  00000000  00000000  00016209  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00005df4  00000000  00000000  0001989f  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00001b7c  00000000  00000000  0001f694  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    0000473b  00000000  00000000  00021210  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    0000a207  00000000  00000000  0002594b  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000868  00000000  00000000  0002fb52  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 74 00 	jmp	0xe8	; 0xe8 <__dtors_end>
       4:	0c 94 9a 0b 	jmp	0x1734	; 0x1734 <__vector_1>
       8:	0c 94 c1 0b 	jmp	0x1782	; 0x1782 <__vector_2>
       c:	0c 94 9c 00 	jmp	0x138	; 0x138 <__bad_interrupt>
      10:	0c 94 9c 00 	jmp	0x138	; 0x138 <__bad_interrupt>
      14:	0c 94 9c 00 	jmp	0x138	; 0x138 <__bad_interrupt>
      18:	0c 94 88 1c 	jmp	0x3910	; 0x3910 <__vector_6>
      1c:	0c 94 2b 1d 	jmp	0x3a56	; 0x3a56 <__vector_7>
      20:	0c 94 9c 00 	jmp	0x138	; 0x138 <__bad_interrupt>
      24:	0c 94 9c 00 	jmp	0x138	; 0x138 <__bad_interrupt>
      28:	0c 94 9c 00 	jmp	0x138	; 0x138 <__bad_interrupt>
      2c:	0c 94 9c 00 	jmp	0x138	; 0x138 <__bad_interrupt>
      30:	0c 94 9c 00 	jmp	0x138	; 0x138 <__bad_interrupt>
      34:	0c 94 9c 00 	jmp	0x138	; 0x138 <__bad_interrupt>
      38:	0c 94 9c 00 	jmp	0x138	; 0x138 <__bad_interrupt>
      3c:	0c 94 9c 00 	jmp	0x138	; 0x138 <__bad_interrupt>
      40:	0c 94 e8 0b 	jmp	0x17d0	; 0x17d0 <__vector_16>
      44:	0c 94 9c 00 	jmp	0x138	; 0x138 <__bad_interrupt>
      48:	0c 94 22 09 	jmp	0x1244	; 0x1244 <__vector_18>
      4c:	0c 94 54 09 	jmp	0x12a8	; 0x12a8 <__vector_19>
      50:	0c 94 9c 00 	jmp	0x138	; 0x138 <__bad_interrupt>
      54:	0c 94 9c 00 	jmp	0x138	; 0x138 <__bad_interrupt>
      58:	0c 94 9c 00 	jmp	0x138	; 0x138 <__bad_interrupt>
      5c:	0c 94 9c 00 	jmp	0x138	; 0x138 <__bad_interrupt>
      60:	0c 94 9c 00 	jmp	0x138	; 0x138 <__bad_interrupt>
      64:	0c 94 9c 00 	jmp	0x138	; 0x138 <__bad_interrupt>
      68:	94 18       	sub	r9, r4
      6a:	94 18       	sub	r9, r4
      6c:	94 18       	sub	r9, r4
      6e:	d3 18       	sub	r13, r3
      70:	be 18       	sub	r11, r14
      72:	cd 18       	sub	r12, r13
      74:	94 18       	sub	r9, r4
      76:	94 18       	sub	r9, r4
      78:	d3 18       	sub	r13, r3
      7a:	be 18       	sub	r11, r14

0000007c <__trampolines_end>:
      7c:	0a 46       	sbci	r16, 0x6A	; 106
      7e:	6f 75       	andi	r22, 0x5F	; 95
      80:	6e 64       	ori	r22, 0x4E	; 78
      82:	20 4d       	sbci	r18, 0xD0	; 208
      84:	61 74       	andi	r22, 0x41	; 65
      86:	63 68       	ori	r22, 0x83	; 131
      88:	69 6e       	ori	r22, 0xE9	; 233
      8a:	67 20       	and	r6, r7
      8c:	43 6f       	ori	r20, 0xF3	; 243
      8e:	6c 6f       	ori	r22, 0xFC	; 252
      90:	72 00       	.word	0x0072	; ????

00000092 <digital_pin_to_timer_PGM>:
      92:	00 00 00 08 00 02 01 00 00 03 04 07 00 00 00 00     ................
      a2:	00 00 00 00                                         ....

000000a6 <digital_pin_to_bit_mask_PGM>:
      a6:	01 02 04 08 10 20 40 80 01 02 04 08 10 20 01 02     ..... @...... ..
      b6:	04 08 10 20                                         ... 

000000ba <digital_pin_to_port_PGM>:
      ba:	04 04 04 04 04 04 04 04 02 02 02 02 02 02 03 03     ................
      ca:	03 03 03 03                                         ....

000000ce <port_to_output_PGM>:
      ce:	00 00 00 00 25 00 28 00 2b 00                       ....%.(.+.

000000d8 <port_to_mode_PGM>:
      d8:	00 00 00 00 24 00 27 00 2a 00                       ....$.'.*.

000000e2 <__ctors_start>:
      e2:	c6 05       	cpc	r28, r6
      e4:	84 09       	sbc	r24, r4

000000e6 <__ctors_end>:
      e6:	d1 05       	cpc	r29, r1

000000e8 <__dtors_end>:
      e8:	11 24       	eor	r1, r1
      ea:	1f be       	out	0x3f, r1	; 63
      ec:	cf ef       	ldi	r28, 0xFF	; 255
      ee:	d8 e0       	ldi	r29, 0x08	; 8
      f0:	de bf       	out	0x3e, r29	; 62
      f2:	cd bf       	out	0x3d, r28	; 61

000000f4 <__do_copy_data>:
      f4:	11 e0       	ldi	r17, 0x01	; 1
      f6:	a0 e0       	ldi	r26, 0x00	; 0
      f8:	b1 e0       	ldi	r27, 0x01	; 1
      fa:	e4 e6       	ldi	r30, 0x64	; 100
      fc:	ff e3       	ldi	r31, 0x3F	; 63
      fe:	02 c0       	rjmp	.+4      	; 0x104 <__do_copy_data+0x10>
     100:	05 90       	lpm	r0, Z+
     102:	0d 92       	st	X+, r0
     104:	ae 3a       	cpi	r26, 0xAE	; 174
     106:	b1 07       	cpc	r27, r17
     108:	d9 f7       	brne	.-10     	; 0x100 <__do_copy_data+0xc>

0000010a <__do_clear_bss>:
     10a:	23 e0       	ldi	r18, 0x03	; 3
     10c:	ae ea       	ldi	r26, 0xAE	; 174
     10e:	b1 e0       	ldi	r27, 0x01	; 1
     110:	01 c0       	rjmp	.+2      	; 0x114 <.do_clear_bss_start>

00000112 <.do_clear_bss_loop>:
     112:	1d 92       	st	X+, r1

00000114 <.do_clear_bss_start>:
     114:	ae 3e       	cpi	r26, 0xEE	; 238
     116:	b2 07       	cpc	r27, r18
     118:	e1 f7       	brne	.-8      	; 0x112 <.do_clear_bss_loop>

0000011a <__do_global_ctors>:
     11a:	10 e0       	ldi	r17, 0x00	; 0
     11c:	c3 e7       	ldi	r28, 0x73	; 115
     11e:	d0 e0       	ldi	r29, 0x00	; 0
     120:	04 c0       	rjmp	.+8      	; 0x12a <__do_global_ctors+0x10>
     122:	21 97       	sbiw	r28, 0x01	; 1
     124:	fe 01       	movw	r30, r28
     126:	0e 94 2a 1e 	call	0x3c54	; 0x3c54 <__tablejump2__>
     12a:	c1 37       	cpi	r28, 0x71	; 113
     12c:	d1 07       	cpc	r29, r17
     12e:	c9 f7       	brne	.-14     	; 0x122 <__do_global_ctors+0x8>
     130:	0e 94 b1 09 	call	0x1362	; 0x1362 <main>
     134:	0c 94 a5 1f 	jmp	0x3f4a	; 0x3f4a <__do_global_dtors>

00000138 <__bad_interrupt>:
     138:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

0000013c <_ZN11EEPROMClass4readEi.isra.0>:

    EERef( const int index )
        : index( index )                 {}
    
    //Access/read members.
    uint8_t operator*() const            { return eeprom_read_byte( (uint8_t*) index ); }
     13c:	0c 94 8f 1f 	jmp	0x3f1e	; 0x3f1e <eeprom_read_byte>

00000140 <_ZN10DFRobot_PHC1Ev>:
#define EEPROM_read(address, p)  {int i = 0; byte *pp = (byte*)&(p);for(; i < sizeof(p); i++) pp[i]=EEPROM.read(address+i);}

#define PHVALUEADDR 0x00    //the start address of the pH calibration parameters stored in the EEPROM


DFRobot_PH::DFRobot_PH()
     140:	fc 01       	movw	r30, r24
{
    this->_temperature    = 25.0;
     142:	80 e0       	ldi	r24, 0x00	; 0
     144:	90 e0       	ldi	r25, 0x00	; 0
     146:	a8 ec       	ldi	r26, 0xC8	; 200
     148:	b1 e4       	ldi	r27, 0x41	; 65
     14a:	80 8b       	std	Z+16, r24	; 0x10
     14c:	91 8b       	std	Z+17, r25	; 0x11
     14e:	a2 8b       	std	Z+18, r26	; 0x12
     150:	b3 8b       	std	Z+19, r27	; 0x13
    this->_phValue        = 7.0;
     152:	80 e0       	ldi	r24, 0x00	; 0
     154:	90 e0       	ldi	r25, 0x00	; 0
     156:	a0 ee       	ldi	r26, 0xE0	; 224
     158:	b0 e4       	ldi	r27, 0x40	; 64
     15a:	80 83       	st	Z, r24
     15c:	91 83       	std	Z+1, r25	; 0x01
     15e:	a2 83       	std	Z+2, r26	; 0x02
     160:	b3 83       	std	Z+3, r27	; 0x03
    this->_acidVoltage    = 2032.44;    //buffer solution 4.0 at 25C
     162:	84 e1       	ldi	r24, 0x14	; 20
     164:	9e e0       	ldi	r25, 0x0E	; 14
     166:	ae ef       	ldi	r26, 0xFE	; 254
     168:	b4 e4       	ldi	r27, 0x44	; 68
     16a:	84 83       	std	Z+4, r24	; 0x04
     16c:	95 83       	std	Z+5, r25	; 0x05
     16e:	a6 83       	std	Z+6, r26	; 0x06
     170:	b7 83       	std	Z+7, r27	; 0x07
    this->_neutralVoltage = 1500.0;     //buffer solution 7.0 at 25C
     172:	80 e0       	ldi	r24, 0x00	; 0
     174:	90 e8       	ldi	r25, 0x80	; 128
     176:	ab eb       	ldi	r26, 0xBB	; 187
     178:	b4 e4       	ldi	r27, 0x44	; 68
     17a:	80 87       	std	Z+8, r24	; 0x08
     17c:	91 87       	std	Z+9, r25	; 0x09
     17e:	a2 87       	std	Z+10, r26	; 0x0a
     180:	b3 87       	std	Z+11, r27	; 0x0b
    this->_voltage        = 1500.0;
     182:	84 87       	std	Z+12, r24	; 0x0c
     184:	95 87       	std	Z+13, r25	; 0x0d
     186:	a6 87       	std	Z+14, r26	; 0x0e
     188:	b7 87       	std	Z+15, r27	; 0x0f
     18a:	08 95       	ret

0000018c <_ZN10DFRobot_PHD1Ev>:
}

DFRobot_PH::~DFRobot_PH()
     18c:	08 95       	ret

0000018e <_ZN10DFRobot_PH5beginEv>:
{

}

void DFRobot_PH::begin()
{
     18e:	cf 92       	push	r12
     190:	df 92       	push	r13
     192:	ef 92       	push	r14
     194:	ff 92       	push	r15
     196:	0f 93       	push	r16
     198:	1f 93       	push	r17
     19a:	cf 93       	push	r28
     19c:	df 93       	push	r29
     19e:	ec 01       	movw	r28, r24
    EEPROM_read(PHVALUEADDR, this->_neutralVoltage);  //load the neutral (pH = 7.0)voltage of the pH board from the EEPROM
     1a0:	7c 01       	movw	r14, r24
     1a2:	88 e0       	ldi	r24, 0x08	; 8
     1a4:	e8 0e       	add	r14, r24
     1a6:	f1 1c       	adc	r15, r1
     1a8:	67 01       	movw	r12, r14
     1aa:	00 e0       	ldi	r16, 0x00	; 0
     1ac:	10 e0       	ldi	r17, 0x00	; 0
     1ae:	c8 01       	movw	r24, r16
     1b0:	0e 94 9e 00 	call	0x13c	; 0x13c <_ZN11EEPROMClass4readEi.isra.0>
     1b4:	f6 01       	movw	r30, r12
     1b6:	81 93       	st	Z+, r24
     1b8:	6f 01       	movw	r12, r30
     1ba:	0f 5f       	subi	r16, 0xFF	; 255
     1bc:	1f 4f       	sbci	r17, 0xFF	; 255
     1be:	04 30       	cpi	r16, 0x04	; 4
     1c0:	11 05       	cpc	r17, r1
     1c2:	a9 f7       	brne	.-22     	; 0x1ae <_ZN10DFRobot_PH5beginEv+0x20>
    Serial.print("_neutralVoltage:");
     1c4:	61 e2       	ldi	r22, 0x21	; 33
     1c6:	71 e0       	ldi	r23, 0x01	; 1
     1c8:	8d ea       	ldi	r24, 0xAD	; 173
     1ca:	92 e0       	ldi	r25, 0x02	; 2
     1cc:	0e 94 23 0a 	call	0x1446	; 0x1446 <_ZN5Print5printEPKc>
    Serial.println(this->_neutralVoltage);
     1d0:	48 85       	ldd	r20, Y+8	; 0x08
     1d2:	59 85       	ldd	r21, Y+9	; 0x09
     1d4:	6a 85       	ldd	r22, Y+10	; 0x0a
     1d6:	7b 85       	ldd	r23, Y+11	; 0x0b
     1d8:	22 e0       	ldi	r18, 0x02	; 2
     1da:	30 e0       	ldi	r19, 0x00	; 0
     1dc:	8d ea       	ldi	r24, 0xAD	; 173
     1de:	92 e0       	ldi	r25, 0x02	; 2
     1e0:	0e 94 67 0b 	call	0x16ce	; 0x16ce <_ZN5Print7printlnEdi>
    if(EEPROM.read(PHVALUEADDR)==0xFF && EEPROM.read(PHVALUEADDR+1)==0xFF && EEPROM.read(PHVALUEADDR+2)==0xFF && EEPROM.read(PHVALUEADDR+3)==0xFF){
     1e4:	80 e0       	ldi	r24, 0x00	; 0
     1e6:	90 e0       	ldi	r25, 0x00	; 0
     1e8:	0e 94 9e 00 	call	0x13c	; 0x13c <_ZN11EEPROMClass4readEi.isra.0>
     1ec:	8f 3f       	cpi	r24, 0xFF	; 255
     1ee:	39 f5       	brne	.+78     	; 0x23e <_ZN10DFRobot_PH5beginEv+0xb0>
     1f0:	81 e0       	ldi	r24, 0x01	; 1
     1f2:	90 e0       	ldi	r25, 0x00	; 0
     1f4:	0e 94 9e 00 	call	0x13c	; 0x13c <_ZN11EEPROMClass4readEi.isra.0>
     1f8:	8f 3f       	cpi	r24, 0xFF	; 255
     1fa:	09 f5       	brne	.+66     	; 0x23e <_ZN10DFRobot_PH5beginEv+0xb0>
     1fc:	82 e0       	ldi	r24, 0x02	; 2
     1fe:	90 e0       	ldi	r25, 0x00	; 0
     200:	0e 94 9e 00 	call	0x13c	; 0x13c <_ZN11EEPROMClass4readEi.isra.0>
     204:	8f 3f       	cpi	r24, 0xFF	; 255
     206:	d9 f4       	brne	.+54     	; 0x23e <_ZN10DFRobot_PH5beginEv+0xb0>
     208:	83 e0       	ldi	r24, 0x03	; 3
     20a:	90 e0       	ldi	r25, 0x00	; 0
     20c:	0e 94 9e 00 	call	0x13c	; 0x13c <_ZN11EEPROMClass4readEi.isra.0>
     210:	8f 3f       	cpi	r24, 0xFF	; 255
     212:	a9 f4       	brne	.+42     	; 0x23e <_ZN10DFRobot_PH5beginEv+0xb0>
        this->_neutralVoltage = 1500.0;  // new EEPROM, write typical voltage
     214:	80 e0       	ldi	r24, 0x00	; 0
     216:	90 e8       	ldi	r25, 0x80	; 128
     218:	ab eb       	ldi	r26, 0xBB	; 187
     21a:	b4 e4       	ldi	r27, 0x44	; 68
     21c:	88 87       	std	Y+8, r24	; 0x08
     21e:	99 87       	std	Y+9, r25	; 0x09
     220:	aa 87       	std	Y+10, r26	; 0x0a
     222:	bb 87       	std	Y+11, r27	; 0x0b
        EEPROM_write(PHVALUEADDR, this->_neutralVoltage);
     224:	00 e0       	ldi	r16, 0x00	; 0
     226:	10 e0       	ldi	r17, 0x00	; 0
     228:	f7 01       	movw	r30, r14
     22a:	61 91       	ld	r22, Z+
     22c:	7f 01       	movw	r14, r30
    operator uint8_t() const             { return **this; }
    
    //Assignment/write members.
    EERef &operator=( const EERef &ref ) { return *this = *ref; }
    EERef &operator=( uint8_t in )       { return eeprom_write_byte( (uint8_t*) index, in ), *this;  }
     22e:	c8 01       	movw	r24, r16
     230:	0e 94 97 1f 	call	0x3f2e	; 0x3f2e <eeprom_write_byte>
     234:	0f 5f       	subi	r16, 0xFF	; 255
     236:	1f 4f       	sbci	r17, 0xFF	; 255
     238:	04 30       	cpi	r16, 0x04	; 4
     23a:	11 05       	cpc	r17, r1
     23c:	a9 f7       	brne	.-22     	; 0x228 <_ZN10DFRobot_PH5beginEv+0x9a>
    }
    EEPROM_read(PHVALUEADDR+4, this->_acidVoltage);//load the acid (pH = 4.0) voltage of the pH board from the EEPROM
     23e:	7e 01       	movw	r14, r28
     240:	f4 e0       	ldi	r31, 0x04	; 4
     242:	ef 0e       	add	r14, r31
     244:	f1 1c       	adc	r15, r1
     246:	67 01       	movw	r12, r14
     248:	04 e0       	ldi	r16, 0x04	; 4
     24a:	10 e0       	ldi	r17, 0x00	; 0
     24c:	c8 01       	movw	r24, r16
     24e:	0e 94 9e 00 	call	0x13c	; 0x13c <_ZN11EEPROMClass4readEi.isra.0>
     252:	f6 01       	movw	r30, r12
     254:	81 93       	st	Z+, r24
     256:	6f 01       	movw	r12, r30
     258:	0f 5f       	subi	r16, 0xFF	; 255
     25a:	1f 4f       	sbci	r17, 0xFF	; 255
     25c:	08 30       	cpi	r16, 0x08	; 8
     25e:	11 05       	cpc	r17, r1
     260:	a9 f7       	brne	.-22     	; 0x24c <_ZN10DFRobot_PH5beginEv+0xbe>
    Serial.print("_acidVoltage:");
     262:	62 e3       	ldi	r22, 0x32	; 50
     264:	71 e0       	ldi	r23, 0x01	; 1
     266:	8d ea       	ldi	r24, 0xAD	; 173
     268:	92 e0       	ldi	r25, 0x02	; 2
     26a:	0e 94 23 0a 	call	0x1446	; 0x1446 <_ZN5Print5printEPKc>
    Serial.println(this->_acidVoltage);
     26e:	4c 81       	ldd	r20, Y+4	; 0x04
     270:	5d 81       	ldd	r21, Y+5	; 0x05
     272:	6e 81       	ldd	r22, Y+6	; 0x06
     274:	7f 81       	ldd	r23, Y+7	; 0x07
     276:	22 e0       	ldi	r18, 0x02	; 2
     278:	30 e0       	ldi	r19, 0x00	; 0
     27a:	8d ea       	ldi	r24, 0xAD	; 173
     27c:	92 e0       	ldi	r25, 0x02	; 2
     27e:	0e 94 67 0b 	call	0x16ce	; 0x16ce <_ZN5Print7printlnEdi>
    if(EEPROM.read(PHVALUEADDR+4)==0xFF && EEPROM.read(PHVALUEADDR+5)==0xFF && EEPROM.read(PHVALUEADDR+6)==0xFF && EEPROM.read(PHVALUEADDR+7)==0xFF){
     282:	84 e0       	ldi	r24, 0x04	; 4
     284:	90 e0       	ldi	r25, 0x00	; 0
     286:	0e 94 9e 00 	call	0x13c	; 0x13c <_ZN11EEPROMClass4readEi.isra.0>
     28a:	8f 3f       	cpi	r24, 0xFF	; 255
     28c:	31 f5       	brne	.+76     	; 0x2da <_ZN10DFRobot_PH5beginEv+0x14c>
     28e:	85 e0       	ldi	r24, 0x05	; 5
     290:	90 e0       	ldi	r25, 0x00	; 0
     292:	0e 94 9e 00 	call	0x13c	; 0x13c <_ZN11EEPROMClass4readEi.isra.0>
     296:	8f 3f       	cpi	r24, 0xFF	; 255
     298:	01 f5       	brne	.+64     	; 0x2da <_ZN10DFRobot_PH5beginEv+0x14c>
     29a:	86 e0       	ldi	r24, 0x06	; 6
     29c:	90 e0       	ldi	r25, 0x00	; 0
     29e:	0e 94 9e 00 	call	0x13c	; 0x13c <_ZN11EEPROMClass4readEi.isra.0>
     2a2:	8f 3f       	cpi	r24, 0xFF	; 255
     2a4:	d1 f4       	brne	.+52     	; 0x2da <_ZN10DFRobot_PH5beginEv+0x14c>
     2a6:	87 e0       	ldi	r24, 0x07	; 7
     2a8:	90 e0       	ldi	r25, 0x00	; 0
     2aa:	0e 94 9e 00 	call	0x13c	; 0x13c <_ZN11EEPROMClass4readEi.isra.0>
     2ae:	8f 3f       	cpi	r24, 0xFF	; 255
     2b0:	a1 f4       	brne	.+40     	; 0x2da <_ZN10DFRobot_PH5beginEv+0x14c>
        this->_acidVoltage = 2032.44;  // new EEPROM, write typical voltage
     2b2:	84 e1       	ldi	r24, 0x14	; 20
     2b4:	9e e0       	ldi	r25, 0x0E	; 14
     2b6:	ae ef       	ldi	r26, 0xFE	; 254
     2b8:	b4 e4       	ldi	r27, 0x44	; 68
     2ba:	8c 83       	std	Y+4, r24	; 0x04
     2bc:	9d 83       	std	Y+5, r25	; 0x05
     2be:	ae 83       	std	Y+6, r26	; 0x06
     2c0:	bf 83       	std	Y+7, r27	; 0x07
     2c2:	c4 e0       	ldi	r28, 0x04	; 4
     2c4:	d0 e0       	ldi	r29, 0x00	; 0
        EEPROM_write(PHVALUEADDR+4, this->_acidVoltage);
     2c6:	f7 01       	movw	r30, r14
     2c8:	61 91       	ld	r22, Z+
     2ca:	7f 01       	movw	r14, r30
     2cc:	ce 01       	movw	r24, r28
     2ce:	0e 94 97 1f 	call	0x3f2e	; 0x3f2e <eeprom_write_byte>
     2d2:	21 96       	adiw	r28, 0x01	; 1
     2d4:	c8 30       	cpi	r28, 0x08	; 8
     2d6:	d1 05       	cpc	r29, r1
     2d8:	b1 f7       	brne	.-20     	; 0x2c6 <_ZN10DFRobot_PH5beginEv+0x138>
    }
}
     2da:	df 91       	pop	r29
     2dc:	cf 91       	pop	r28
     2de:	1f 91       	pop	r17
     2e0:	0f 91       	pop	r16
     2e2:	ff 90       	pop	r15
     2e4:	ef 90       	pop	r14
     2e6:	df 90       	pop	r13
     2e8:	cf 90       	pop	r12
     2ea:	08 95       	ret

000002ec <_ZN10DFRobot_PH6readPHEff>:

float DFRobot_PH::readPH(float voltage, float temperature)
{
     2ec:	4f 92       	push	r4
     2ee:	5f 92       	push	r5
     2f0:	6f 92       	push	r6
     2f2:	7f 92       	push	r7
     2f4:	8f 92       	push	r8
     2f6:	9f 92       	push	r9
     2f8:	af 92       	push	r10
     2fa:	bf 92       	push	r11
     2fc:	cf 92       	push	r12
     2fe:	df 92       	push	r13
     300:	ef 92       	push	r14
     302:	ff 92       	push	r15
     304:	cf 93       	push	r28
     306:	df 93       	push	r29
     308:	ec 01       	movw	r28, r24
     30a:	2a 01       	movw	r4, r20
     30c:	3b 01       	movw	r6, r22
    float slope = (7.0-4.0)/((this->_neutralVoltage-1500.0)/3.0 - (this->_acidVoltage-1500.0)/3.0);  // two point: (_neutralVoltage,7.0),(_acidVoltage,4.0)
     30e:	20 e0       	ldi	r18, 0x00	; 0
     310:	30 e8       	ldi	r19, 0x80	; 128
     312:	4b eb       	ldi	r20, 0xBB	; 187
     314:	54 e4       	ldi	r21, 0x44	; 68
     316:	68 85       	ldd	r22, Y+8	; 0x08
     318:	79 85       	ldd	r23, Y+9	; 0x09
     31a:	8a 85       	ldd	r24, Y+10	; 0x0a
     31c:	9b 85       	ldd	r25, Y+11	; 0x0b
     31e:	0e 94 d9 05 	call	0xbb2	; 0xbb2 <__subsf3>
     322:	4b 01       	movw	r8, r22
     324:	5c 01       	movw	r10, r24
     326:	20 e0       	ldi	r18, 0x00	; 0
     328:	30 e0       	ldi	r19, 0x00	; 0
     32a:	40 e4       	ldi	r20, 0x40	; 64
     32c:	50 e4       	ldi	r21, 0x40	; 64
     32e:	0e 94 4b 06 	call	0xc96	; 0xc96 <__divsf3>
     332:	6b 01       	movw	r12, r22
     334:	7c 01       	movw	r14, r24
     336:	20 e0       	ldi	r18, 0x00	; 0
     338:	30 e8       	ldi	r19, 0x80	; 128
     33a:	4b eb       	ldi	r20, 0xBB	; 187
     33c:	54 e4       	ldi	r21, 0x44	; 68
     33e:	6c 81       	ldd	r22, Y+4	; 0x04
     340:	7d 81       	ldd	r23, Y+5	; 0x05
     342:	8e 81       	ldd	r24, Y+6	; 0x06
     344:	9f 81       	ldd	r25, Y+7	; 0x07
     346:	0e 94 d9 05 	call	0xbb2	; 0xbb2 <__subsf3>
     34a:	20 e0       	ldi	r18, 0x00	; 0
     34c:	30 e0       	ldi	r19, 0x00	; 0
     34e:	40 e4       	ldi	r20, 0x40	; 64
     350:	50 e4       	ldi	r21, 0x40	; 64
     352:	0e 94 4b 06 	call	0xc96	; 0xc96 <__divsf3>
     356:	9b 01       	movw	r18, r22
     358:	ac 01       	movw	r20, r24
     35a:	c7 01       	movw	r24, r14
     35c:	b6 01       	movw	r22, r12
     35e:	0e 94 d9 05 	call	0xbb2	; 0xbb2 <__subsf3>
     362:	9b 01       	movw	r18, r22
     364:	ac 01       	movw	r20, r24
     366:	60 e0       	ldi	r22, 0x00	; 0
     368:	70 e0       	ldi	r23, 0x00	; 0
     36a:	80 e4       	ldi	r24, 0x40	; 64
     36c:	90 e4       	ldi	r25, 0x40	; 64
     36e:	0e 94 4b 06 	call	0xc96	; 0xc96 <__divsf3>
     372:	6b 01       	movw	r12, r22
     374:	7c 01       	movw	r14, r24
    float intercept =  7.0 - slope*(this->_neutralVoltage-1500.0)/3.0;
    //Serial.print("slope:");
    //Serial.print(slope);
    //Serial.print(",intercept:");
    //Serial.println(intercept);
    this->_phValue = slope*(voltage-1500.0)/3.0+intercept;  //y = k*x + b
     376:	9b 01       	movw	r18, r22
     378:	ac 01       	movw	r20, r24
     37a:	c5 01       	movw	r24, r10
     37c:	b4 01       	movw	r22, r8
     37e:	0e 94 74 07 	call	0xee8	; 0xee8 <__mulsf3>
     382:	20 e0       	ldi	r18, 0x00	; 0
     384:	30 e0       	ldi	r19, 0x00	; 0
     386:	40 e4       	ldi	r20, 0x40	; 64
     388:	50 e4       	ldi	r21, 0x40	; 64
     38a:	0e 94 4b 06 	call	0xc96	; 0xc96 <__divsf3>
     38e:	9b 01       	movw	r18, r22
     390:	ac 01       	movw	r20, r24
     392:	60 e0       	ldi	r22, 0x00	; 0
     394:	70 e0       	ldi	r23, 0x00	; 0
     396:	80 ee       	ldi	r24, 0xE0	; 224
     398:	90 e4       	ldi	r25, 0x40	; 64
     39a:	0e 94 d9 05 	call	0xbb2	; 0xbb2 <__subsf3>
     39e:	4b 01       	movw	r8, r22
     3a0:	5c 01       	movw	r10, r24
     3a2:	20 e0       	ldi	r18, 0x00	; 0
     3a4:	30 e8       	ldi	r19, 0x80	; 128
     3a6:	4b eb       	ldi	r20, 0xBB	; 187
     3a8:	54 e4       	ldi	r21, 0x44	; 68
     3aa:	c3 01       	movw	r24, r6
     3ac:	b2 01       	movw	r22, r4
     3ae:	0e 94 d9 05 	call	0xbb2	; 0xbb2 <__subsf3>
     3b2:	a7 01       	movw	r20, r14
     3b4:	96 01       	movw	r18, r12
     3b6:	0e 94 74 07 	call	0xee8	; 0xee8 <__mulsf3>
     3ba:	20 e0       	ldi	r18, 0x00	; 0
     3bc:	30 e0       	ldi	r19, 0x00	; 0
     3be:	40 e4       	ldi	r20, 0x40	; 64
     3c0:	50 e4       	ldi	r21, 0x40	; 64
     3c2:	0e 94 4b 06 	call	0xc96	; 0xc96 <__divsf3>
     3c6:	9b 01       	movw	r18, r22
     3c8:	ac 01       	movw	r20, r24
     3ca:	c5 01       	movw	r24, r10
     3cc:	b4 01       	movw	r22, r8
     3ce:	0e 94 da 05 	call	0xbb4	; 0xbb4 <__addsf3>
     3d2:	68 83       	st	Y, r22
     3d4:	79 83       	std	Y+1, r23	; 0x01
     3d6:	8a 83       	std	Y+2, r24	; 0x02
     3d8:	9b 83       	std	Y+3, r25	; 0x03
    return _phValue;
}
     3da:	df 91       	pop	r29
     3dc:	cf 91       	pop	r28
     3de:	ff 90       	pop	r15
     3e0:	ef 90       	pop	r14
     3e2:	df 90       	pop	r13
     3e4:	cf 90       	pop	r12
     3e6:	bf 90       	pop	r11
     3e8:	af 90       	pop	r10
     3ea:	9f 90       	pop	r9
     3ec:	8f 90       	pop	r8
     3ee:	7f 90       	pop	r7
     3f0:	6f 90       	pop	r6
     3f2:	5f 90       	pop	r5
     3f4:	4f 90       	pop	r4
     3f6:	08 95       	ret

000003f8 <_Z19TaskTemperatureReadPv>:
	phValue = ph.readPH(voltage, temperature);
	return phValue;
}
void calibratePH() {
	ph.calibration(voltage, temperature);
     3f8:	cf 93       	push	r28
     3fa:	df 93       	push	r29
     3fc:	00 d0       	rcall	.+0      	; 0x3fe <_Z19TaskTemperatureReadPv+0x6>
     3fe:	cd b7       	in	r28, 0x3d	; 61
     400:	de b7       	in	r29, 0x3e	; 62
     402:	0e 94 fd 12 	call	0x25fa	; 0x25fa <xTaskGetTickCount>
     406:	9a 83       	std	Y+2, r25	; 0x02
     408:	89 83       	std	Y+1, r24	; 0x01
     40a:	60 e0       	ldi	r22, 0x00	; 0
     40c:	8d e0       	ldi	r24, 0x0D	; 13
     40e:	0e 94 4e 0d 	call	0x1a9c	; 0x1a9c <digitalWrite>
     412:	6a eb       	ldi	r22, 0xBA	; 186
     414:	7b ed       	ldi	r23, 0xDB	; 219
     416:	ce 01       	movw	r24, r28
     418:	01 96       	adiw	r24, 0x01	; 1
     41a:	0e 94 22 14 	call	0x2844	; 0x2844 <vTaskDelayUntil>
     41e:	f5 cf       	rjmp	.-22     	; 0x40a <__LOCK_REGION_LENGTH__+0xa>

00000420 <_Z8fromWifiv>:
     420:	80 91 b6 01 	lds	r24, 0x01B6	; 0x8001b6 <xAmmonia>
     424:	90 91 b7 01 	lds	r25, 0x01B7	; 0x8001b7 <xAmmonia+0x1>
     428:	0c 94 80 12 	jmp	0x2500	; 0x2500 <vTaskResume>

0000042c <_Z9addColorsv>:
     42c:	0f 93       	push	r16
     42e:	1f 93       	push	r17
     430:	cf 93       	push	r28
     432:	df 93       	push	r29
     434:	c9 e8       	ldi	r28, 0x89	; 137
     436:	d2 e0       	ldi	r29, 0x02	; 2
     438:	18 82       	st	Y, r1
     43a:	19 82       	std	Y+1, r1	; 0x01
     43c:	1a 82       	std	Y+2, r1	; 0x02
     43e:	1b 82       	std	Y+3, r1	; 0x03
     440:	1c 82       	std	Y+4, r1	; 0x04
     442:	1d 82       	std	Y+5, r1	; 0x05
     444:	1e 82       	std	Y+6, r1	; 0x06
     446:	a8 e5       	ldi	r26, 0x58	; 88
     448:	b2 e0       	ldi	r27, 0x02	; 2
     44a:	1d 92       	st	X+, r1
     44c:	1d 92       	st	X+, r1
     44e:	1d 92       	st	X+, r1
     450:	1c 92       	st	X, r1
     452:	13 97       	sbiw	r26, 0x03	; 3
     454:	14 96       	adiw	r26, 0x04	; 4
     456:	1c 92       	st	X, r1
     458:	14 97       	sbiw	r26, 0x04	; 4
     45a:	15 96       	adiw	r26, 0x05	; 5
     45c:	1c 92       	st	X, r1
     45e:	15 97       	sbiw	r26, 0x05	; 5
     460:	16 96       	adiw	r26, 0x06	; 6
     462:	1c 92       	st	X, r1
     464:	16 97       	sbiw	r26, 0x06	; 6
     466:	e7 e2       	ldi	r30, 0x27	; 39
     468:	f2 e0       	ldi	r31, 0x02	; 2
     46a:	10 82       	st	Z, r1
     46c:	11 82       	std	Z+1, r1	; 0x01
     46e:	12 82       	std	Z+2, r1	; 0x02
     470:	13 82       	std	Z+3, r1	; 0x03
     472:	14 82       	std	Z+4, r1	; 0x04
     474:	15 82       	std	Z+5, r1	; 0x05
     476:	16 82       	std	Z+6, r1	; 0x06
     478:	40 e0       	ldi	r20, 0x00	; 0
     47a:	50 e0       	ldi	r21, 0x00	; 0
     47c:	60 e8       	ldi	r22, 0x80	; 128
     47e:	7e e3       	ldi	r23, 0x3E	; 62
     480:	4f 83       	std	Y+7, r20	; 0x07
     482:	58 87       	std	Y+8, r21	; 0x08
     484:	69 87       	std	Y+9, r22	; 0x09
     486:	7a 87       	std	Y+10, r23	; 0x0a
     488:	1b 86       	std	Y+11, r1	; 0x0b
     48a:	1c 86       	std	Y+12, r1	; 0x0c
     48c:	1d 86       	std	Y+13, r1	; 0x0d
     48e:	4a e9       	ldi	r20, 0x9A	; 154
     490:	59 e9       	ldi	r21, 0x99	; 153
     492:	69 e1       	ldi	r22, 0x19	; 25
     494:	7e e3       	ldi	r23, 0x3E	; 62
     496:	17 96       	adiw	r26, 0x07	; 7
     498:	4d 93       	st	X+, r20
     49a:	5d 93       	st	X+, r21
     49c:	6d 93       	st	X+, r22
     49e:	7c 93       	st	X, r23
     4a0:	1a 97       	sbiw	r26, 0x0a	; 10
     4a2:	1b 96       	adiw	r26, 0x0b	; 11
     4a4:	1c 92       	st	X, r1
     4a6:	1b 97       	sbiw	r26, 0x0b	; 11
     4a8:	1c 96       	adiw	r26, 0x0c	; 12
     4aa:	1c 92       	st	X, r1
     4ac:	1c 97       	sbiw	r26, 0x0c	; 12
     4ae:	1d 96       	adiw	r26, 0x0d	; 13
     4b0:	1c 92       	st	X, r1
     4b2:	1d 97       	sbiw	r26, 0x0d	; 13
     4b4:	40 e0       	ldi	r20, 0x00	; 0
     4b6:	50 e0       	ldi	r21, 0x00	; 0
     4b8:	60 e0       	ldi	r22, 0x00	; 0
     4ba:	7f e3       	ldi	r23, 0x3F	; 63
     4bc:	47 83       	std	Z+7, r20	; 0x07
     4be:	50 87       	std	Z+8, r21	; 0x08
     4c0:	61 87       	std	Z+9, r22	; 0x09
     4c2:	72 87       	std	Z+10, r23	; 0x0a
     4c4:	13 86       	std	Z+11, r1	; 0x0b
     4c6:	14 86       	std	Z+12, r1	; 0x0c
     4c8:	15 86       	std	Z+13, r1	; 0x0d
     4ca:	4e 87       	std	Y+14, r20	; 0x0e
     4cc:	5f 87       	std	Y+15, r21	; 0x0f
     4ce:	68 8b       	std	Y+16, r22	; 0x10
     4d0:	79 8b       	std	Y+17, r23	; 0x11
     4d2:	1a 8a       	std	Y+18, r1	; 0x12
     4d4:	1b 8a       	std	Y+19, r1	; 0x13
     4d6:	1c 8a       	std	Y+20, r1	; 0x14
     4d8:	4a e9       	ldi	r20, 0x9A	; 154
     4da:	59 e9       	ldi	r21, 0x99	; 153
     4dc:	69 e9       	ldi	r22, 0x99	; 153
     4de:	7e e3       	ldi	r23, 0x3E	; 62
     4e0:	1e 96       	adiw	r26, 0x0e	; 14
     4e2:	4d 93       	st	X+, r20
     4e4:	5d 93       	st	X+, r21
     4e6:	6d 93       	st	X+, r22
     4e8:	7c 93       	st	X, r23
     4ea:	51 97       	sbiw	r26, 0x11	; 17
     4ec:	52 96       	adiw	r26, 0x12	; 18
     4ee:	1c 92       	st	X, r1
     4f0:	52 97       	sbiw	r26, 0x12	; 18
     4f2:	53 96       	adiw	r26, 0x13	; 19
     4f4:	1c 92       	st	X, r1
     4f6:	53 97       	sbiw	r26, 0x13	; 19
     4f8:	54 96       	adiw	r26, 0x14	; 20
     4fa:	1c 92       	st	X, r1
     4fc:	54 97       	sbiw	r26, 0x14	; 20
     4fe:	40 e0       	ldi	r20, 0x00	; 0
     500:	50 e0       	ldi	r21, 0x00	; 0
     502:	60 e0       	ldi	r22, 0x00	; 0
     504:	70 e4       	ldi	r23, 0x40	; 64
     506:	46 87       	std	Z+14, r20	; 0x0e
     508:	57 87       	std	Z+15, r21	; 0x0f
     50a:	60 8b       	std	Z+16, r22	; 0x10
     50c:	71 8b       	std	Z+17, r23	; 0x11
     50e:	12 8a       	std	Z+18, r1	; 0x12
     510:	13 8a       	std	Z+19, r1	; 0x13
     512:	14 8a       	std	Z+20, r1	; 0x14
     514:	00 e0       	ldi	r16, 0x00	; 0
     516:	10 e0       	ldi	r17, 0x00	; 0
     518:	20 e4       	ldi	r18, 0x40	; 64
     51a:	30 e4       	ldi	r19, 0x40	; 64
     51c:	0d 8b       	std	Y+21, r16	; 0x15
     51e:	1e 8b       	std	Y+22, r17	; 0x16
     520:	2f 8b       	std	Y+23, r18	; 0x17
     522:	38 8f       	std	Y+24, r19	; 0x18
     524:	19 8e       	std	Y+25, r1	; 0x19
     526:	1a 8e       	std	Y+26, r1	; 0x1a
     528:	1b 8e       	std	Y+27, r1	; 0x1b
     52a:	40 e0       	ldi	r20, 0x00	; 0
     52c:	50 e0       	ldi	r21, 0x00	; 0
     52e:	60 e8       	ldi	r22, 0x80	; 128
     530:	7f e3       	ldi	r23, 0x3F	; 63
     532:	55 96       	adiw	r26, 0x15	; 21
     534:	4d 93       	st	X+, r20
     536:	5d 93       	st	X+, r21
     538:	6d 93       	st	X+, r22
     53a:	7c 93       	st	X, r23
     53c:	58 97       	sbiw	r26, 0x18	; 24
     53e:	59 96       	adiw	r26, 0x19	; 25
     540:	1c 92       	st	X, r1
     542:	59 97       	sbiw	r26, 0x19	; 25
     544:	5a 96       	adiw	r26, 0x1a	; 26
     546:	1c 92       	st	X, r1
     548:	5a 97       	sbiw	r26, 0x1a	; 26
     54a:	5b 96       	adiw	r26, 0x1b	; 27
     54c:	1c 92       	st	X, r1
     54e:	5b 97       	sbiw	r26, 0x1b	; 27
     550:	40 e0       	ldi	r20, 0x00	; 0
     552:	50 e0       	ldi	r21, 0x00	; 0
     554:	60 ea       	ldi	r22, 0xA0	; 160
     556:	70 e4       	ldi	r23, 0x40	; 64
     558:	45 8b       	std	Z+21, r20	; 0x15
     55a:	56 8b       	std	Z+22, r21	; 0x16
     55c:	67 8b       	std	Z+23, r22	; 0x17
     55e:	70 8f       	std	Z+24, r23	; 0x18
     560:	11 8e       	std	Z+25, r1	; 0x19
     562:	12 8e       	std	Z+26, r1	; 0x1a
     564:	13 8e       	std	Z+27, r1	; 0x1b
     566:	40 e0       	ldi	r20, 0x00	; 0
     568:	50 e0       	ldi	r21, 0x00	; 0
     56a:	60 ec       	ldi	r22, 0xC0	; 192
     56c:	70 e4       	ldi	r23, 0x40	; 64
     56e:	4c 8f       	std	Y+28, r20	; 0x1c
     570:	5d 8f       	std	Y+29, r21	; 0x1d
     572:	6e 8f       	std	Y+30, r22	; 0x1e
     574:	7f 8f       	std	Y+31, r23	; 0x1f
     576:	18 a2       	std	Y+32, r1	; 0x20
     578:	19 a2       	std	Y+33, r1	; 0x21
     57a:	1a a2       	std	Y+34, r1	; 0x22
     57c:	40 e0       	ldi	r20, 0x00	; 0
     57e:	50 e0       	ldi	r21, 0x00	; 0
     580:	60 ec       	ldi	r22, 0xC0	; 192
     582:	7f e3       	ldi	r23, 0x3F	; 63
     584:	5c 96       	adiw	r26, 0x1c	; 28
     586:	4d 93       	st	X+, r20
     588:	5d 93       	st	X+, r21
     58a:	6d 93       	st	X+, r22
     58c:	7c 93       	st	X, r23
     58e:	5f 97       	sbiw	r26, 0x1f	; 31
     590:	90 96       	adiw	r26, 0x20	; 32
     592:	1c 92       	st	X, r1
     594:	90 97       	sbiw	r26, 0x20	; 32
     596:	91 96       	adiw	r26, 0x21	; 33
     598:	1c 92       	st	X, r1
     59a:	91 97       	sbiw	r26, 0x21	; 33
     59c:	92 96       	adiw	r26, 0x22	; 34
     59e:	1c 92       	st	X, r1
     5a0:	92 97       	sbiw	r26, 0x22	; 34
     5a2:	40 e0       	ldi	r20, 0x00	; 0
     5a4:	50 e0       	ldi	r21, 0x00	; 0
     5a6:	60 e2       	ldi	r22, 0x20	; 32
     5a8:	71 e4       	ldi	r23, 0x41	; 65
     5aa:	44 8f       	std	Z+28, r20	; 0x1c
     5ac:	55 8f       	std	Z+29, r21	; 0x1d
     5ae:	66 8f       	std	Z+30, r22	; 0x1e
     5b0:	77 8f       	std	Z+31, r23	; 0x1f
     5b2:	10 a2       	std	Z+32, r1	; 0x20
     5b4:	11 a2       	std	Z+33, r1	; 0x21
     5b6:	12 a2       	std	Z+34, r1	; 0x22
     5b8:	93 96       	adiw	r26, 0x23	; 35
     5ba:	0d 93       	st	X+, r16
     5bc:	1d 93       	st	X+, r17
     5be:	2d 93       	st	X+, r18
     5c0:	3c 93       	st	X, r19
     5c2:	96 97       	sbiw	r26, 0x26	; 38
     5c4:	97 96       	adiw	r26, 0x27	; 39
     5c6:	1c 92       	st	X, r1
     5c8:	97 97       	sbiw	r26, 0x27	; 39
     5ca:	98 96       	adiw	r26, 0x28	; 40
     5cc:	1c 92       	st	X, r1
     5ce:	98 97       	sbiw	r26, 0x28	; 40
     5d0:	99 96       	adiw	r26, 0x29	; 41
     5d2:	1c 92       	st	X, r1
     5d4:	99 97       	sbiw	r26, 0x29	; 41
     5d6:	00 e0       	ldi	r16, 0x00	; 0
     5d8:	10 e0       	ldi	r17, 0x00	; 0
     5da:	20 ea       	ldi	r18, 0xA0	; 160
     5dc:	31 e4       	ldi	r19, 0x41	; 65
     5de:	03 a3       	std	Z+35, r16	; 0x23
     5e0:	14 a3       	std	Z+36, r17	; 0x24
     5e2:	25 a3       	std	Z+37, r18	; 0x25
     5e4:	36 a3       	std	Z+38, r19	; 0x26
     5e6:	17 a2       	std	Z+39, r1	; 0x27
     5e8:	10 a6       	std	Z+40, r1	; 0x28
     5ea:	11 a6       	std	Z+41, r1	; 0x29
     5ec:	9a 96       	adiw	r26, 0x2a	; 42
     5ee:	4d 93       	st	X+, r20
     5f0:	5d 93       	st	X+, r21
     5f2:	6d 93       	st	X+, r22
     5f4:	7c 93       	st	X, r23
     5f6:	9d 97       	sbiw	r26, 0x2d	; 45
     5f8:	9e 96       	adiw	r26, 0x2e	; 46
     5fa:	1c 92       	st	X, r1
     5fc:	9e 97       	sbiw	r26, 0x2e	; 46
     5fe:	9f 96       	adiw	r26, 0x2f	; 47
     600:	1c 92       	st	X, r1
     602:	9f 97       	sbiw	r26, 0x2f	; 47
     604:	d0 96       	adiw	r26, 0x30	; 48
     606:	1c 92       	st	X, r1
     608:	80 e0       	ldi	r24, 0x00	; 0
     60a:	90 e0       	ldi	r25, 0x00	; 0
     60c:	a8 e4       	ldi	r26, 0x48	; 72
     60e:	b2 e4       	ldi	r27, 0x42	; 66
     610:	82 a7       	std	Z+42, r24	; 0x2a
     612:	93 a7       	std	Z+43, r25	; 0x2b
     614:	a4 a7       	std	Z+44, r26	; 0x2c
     616:	b5 a7       	std	Z+45, r27	; 0x2d
     618:	16 a6       	std	Z+46, r1	; 0x2e
     61a:	17 a6       	std	Z+47, r1	; 0x2f
     61c:	10 aa       	std	Z+48, r1	; 0x30
     61e:	df 91       	pop	r29
     620:	cf 91       	pop	r28
     622:	1f 91       	pop	r17
     624:	0f 91       	pop	r16
     626:	08 95       	ret

00000628 <_Z9SameColorv>:
     628:	20 91 1a 02 	lds	r18, 0x021A	; 0x80021a <c+0x4>
     62c:	30 e0       	ldi	r19, 0x00	; 0
     62e:	80 91 1d 02 	lds	r24, 0x021D	; 0x80021d <rgb>
     632:	90 e0       	ldi	r25, 0x00	; 0
     634:	ac 01       	movw	r20, r24
     636:	43 52       	subi	r20, 0x23	; 35
     638:	51 09       	sbc	r21, r1
     63a:	24 17       	cp	r18, r20
     63c:	35 07       	cpc	r19, r21
     63e:	f4 f0       	brlt	.+60     	; 0x67c <_Z9SameColorv+0x54>
     640:	83 96       	adiw	r24, 0x23	; 35
     642:	82 17       	cp	r24, r18
     644:	93 07       	cpc	r25, r19
     646:	d4 f0       	brlt	.+52     	; 0x67c <_Z9SameColorv+0x54>
     648:	20 91 1b 02 	lds	r18, 0x021B	; 0x80021b <c+0x5>
     64c:	30 e0       	ldi	r19, 0x00	; 0
     64e:	24 17       	cp	r18, r20
     650:	35 07       	cpc	r19, r21
     652:	a4 f0       	brlt	.+40     	; 0x67c <_Z9SameColorv+0x54>
     654:	82 17       	cp	r24, r18
     656:	93 07       	cpc	r25, r19
     658:	8c f0       	brlt	.+34     	; 0x67c <_Z9SameColorv+0x54>
     65a:	20 91 1c 02 	lds	r18, 0x021C	; 0x80021c <c+0x6>
     65e:	30 e0       	ldi	r19, 0x00	; 0
     660:	24 17       	cp	r18, r20
     662:	35 07       	cpc	r19, r21
     664:	5c f0       	brlt	.+22     	; 0x67c <_Z9SameColorv+0x54>
     666:	82 17       	cp	r24, r18
     668:	93 07       	cpc	r25, r19
     66a:	44 f0       	brlt	.+16     	; 0x67c <_Z9SameColorv+0x54>
     66c:	6c e7       	ldi	r22, 0x7C	; 124
     66e:	70 e0       	ldi	r23, 0x00	; 0
     670:	8d ea       	ldi	r24, 0xAD	; 173
     672:	92 e0       	ldi	r25, 0x02	; 2
     674:	0e 94 ff 09 	call	0x13fe	; 0x13fe <_ZN5Print5printEPK19__FlashStringHelper>
     678:	81 e0       	ldi	r24, 0x01	; 1
     67a:	08 95       	ret
     67c:	80 e0       	ldi	r24, 0x00	; 0
     67e:	08 95       	ret

00000680 <_Z9FindMatchv>:
     680:	0f 93       	push	r16
     682:	1f 93       	push	r17
     684:	cf 93       	push	r28
     686:	df 93       	push	r29
     688:	80 91 ac 02 	lds	r24, 0x02AC	; 0x8002ac <typeToRead>
     68c:	81 30       	cpi	r24, 0x01	; 1
     68e:	09 f4       	brne	.+2      	; 0x692 <_Z9FindMatchv+0x12>
     690:	48 c0       	rjmp	.+144    	; 0x722 <_Z9FindMatchv+0xa2>
     692:	40 f0       	brcs	.+16     	; 0x6a4 <_Z9FindMatchv+0x24>
     694:	82 30       	cpi	r24, 0x02	; 2
     696:	09 f0       	breq	.+2      	; 0x69a <_Z9FindMatchv+0x1a>
     698:	6e c0       	rjmp	.+220    	; 0x776 <_Z9FindMatchv+0xf6>
     69a:	08 e5       	ldi	r16, 0x58	; 88
     69c:	12 e0       	ldi	r17, 0x02	; 2
     69e:	c6 e0       	ldi	r28, 0x06	; 6
     6a0:	d0 e0       	ldi	r29, 0x00	; 0
     6a2:	29 c0       	rjmp	.+82     	; 0x6f6 <_Z9FindMatchv+0x76>
     6a4:	09 e8       	ldi	r16, 0x89	; 137
     6a6:	12 e0       	ldi	r17, 0x02	; 2
     6a8:	c4 e0       	ldi	r28, 0x04	; 4
     6aa:	d0 e0       	ldi	r29, 0x00	; 0
     6ac:	87 e0       	ldi	r24, 0x07	; 7
     6ae:	f8 01       	movw	r30, r16
     6b0:	7c 96       	adiw	r30, 0x1c	; 28
     6b2:	a6 e1       	ldi	r26, 0x16	; 22
     6b4:	b2 e0       	ldi	r27, 0x02	; 2
     6b6:	01 90       	ld	r0, Z+
     6b8:	0d 92       	st	X+, r0
     6ba:	8a 95       	dec	r24
     6bc:	e1 f7       	brne	.-8      	; 0x6b6 <_Z9FindMatchv+0x36>
     6be:	0e 94 14 03 	call	0x628	; 0x628 <_Z9SameColorv>
     6c2:	88 23       	and	r24, r24
     6c4:	49 f0       	breq	.+18     	; 0x6d8 <_Z9FindMatchv+0x58>
     6c6:	87 e0       	ldi	r24, 0x07	; 7
     6c8:	8c 9f       	mul	r24, r28
     6ca:	f0 01       	movw	r30, r0
     6cc:	8d 9f       	mul	r24, r29
     6ce:	f0 0d       	add	r31, r0
     6d0:	11 24       	eor	r1, r1
     6d2:	e7 57       	subi	r30, 0x77	; 119
     6d4:	fd 4f       	sbci	r31, 0xFD	; 253
     6d6:	3e c0       	rjmp	.+124    	; 0x754 <_Z9FindMatchv+0xd4>
     6d8:	21 97       	sbiw	r28, 0x01	; 1
     6da:	07 50       	subi	r16, 0x07	; 7
     6dc:	11 09       	sbc	r17, r1
     6de:	cf 3f       	cpi	r28, 0xFF	; 255
     6e0:	8f ef       	ldi	r24, 0xFF	; 255
     6e2:	d8 07       	cpc	r29, r24
     6e4:	19 f7       	brne	.-58     	; 0x6ac <_Z9FindMatchv+0x2c>
     6e6:	42 c0       	rjmp	.+132    	; 0x76c <_Z9FindMatchv+0xec>
     6e8:	21 97       	sbiw	r28, 0x01	; 1
     6ea:	07 50       	subi	r16, 0x07	; 7
     6ec:	11 09       	sbc	r17, r1
     6ee:	cf 3f       	cpi	r28, 0xFF	; 255
     6f0:	8f ef       	ldi	r24, 0xFF	; 255
     6f2:	d8 07       	cpc	r29, r24
     6f4:	d9 f1       	breq	.+118    	; 0x76c <_Z9FindMatchv+0xec>
     6f6:	87 e0       	ldi	r24, 0x07	; 7
     6f8:	f8 01       	movw	r30, r16
     6fa:	ba 96       	adiw	r30, 0x2a	; 42
     6fc:	a6 e1       	ldi	r26, 0x16	; 22
     6fe:	b2 e0       	ldi	r27, 0x02	; 2
     700:	01 90       	ld	r0, Z+
     702:	0d 92       	st	X+, r0
     704:	8a 95       	dec	r24
     706:	e1 f7       	brne	.-8      	; 0x700 <_Z9FindMatchv+0x80>
     708:	0e 94 14 03 	call	0x628	; 0x628 <_Z9SameColorv>
     70c:	88 23       	and	r24, r24
     70e:	61 f3       	breq	.-40     	; 0x6e8 <_Z9FindMatchv+0x68>
     710:	87 e0       	ldi	r24, 0x07	; 7
     712:	8c 9f       	mul	r24, r28
     714:	f0 01       	movw	r30, r0
     716:	8d 9f       	mul	r24, r29
     718:	f0 0d       	add	r31, r0
     71a:	11 24       	eor	r1, r1
     71c:	e8 5a       	subi	r30, 0xA8	; 168
     71e:	fd 4f       	sbci	r31, 0xFD	; 253
     720:	19 c0       	rjmp	.+50     	; 0x754 <_Z9FindMatchv+0xd4>
     722:	07 e2       	ldi	r16, 0x27	; 39
     724:	12 e0       	ldi	r17, 0x02	; 2
     726:	c6 e0       	ldi	r28, 0x06	; 6
     728:	d0 e0       	ldi	r29, 0x00	; 0
     72a:	87 e0       	ldi	r24, 0x07	; 7
     72c:	f8 01       	movw	r30, r16
     72e:	ba 96       	adiw	r30, 0x2a	; 42
     730:	a6 e1       	ldi	r26, 0x16	; 22
     732:	b2 e0       	ldi	r27, 0x02	; 2
     734:	01 90       	ld	r0, Z+
     736:	0d 92       	st	X+, r0
     738:	8a 95       	dec	r24
     73a:	e1 f7       	brne	.-8      	; 0x734 <_Z9FindMatchv+0xb4>
     73c:	0e 94 14 03 	call	0x628	; 0x628 <_Z9SameColorv>
     740:	88 23       	and	r24, r24
     742:	69 f0       	breq	.+26     	; 0x75e <_Z9FindMatchv+0xde>
     744:	87 e0       	ldi	r24, 0x07	; 7
     746:	8c 9f       	mul	r24, r28
     748:	f0 01       	movw	r30, r0
     74a:	8d 9f       	mul	r24, r29
     74c:	f0 0d       	add	r31, r0
     74e:	11 24       	eor	r1, r1
     750:	e9 5d       	subi	r30, 0xD9	; 217
     752:	fd 4f       	sbci	r31, 0xFD	; 253
     754:	30 81       	ld	r19, Z
     756:	21 81       	ldd	r18, Z+1	; 0x01
     758:	92 81       	ldd	r25, Z+2	; 0x02
     75a:	83 81       	ldd	r24, Z+3	; 0x03
     75c:	0b c0       	rjmp	.+22     	; 0x774 <_Z9FindMatchv+0xf4>
     75e:	21 97       	sbiw	r28, 0x01	; 1
     760:	07 50       	subi	r16, 0x07	; 7
     762:	11 09       	sbc	r17, r1
     764:	cf 3f       	cpi	r28, 0xFF	; 255
     766:	8f ef       	ldi	r24, 0xFF	; 255
     768:	d8 07       	cpc	r29, r24
     76a:	f9 f6       	brne	.-66     	; 0x72a <_Z9FindMatchv+0xaa>
     76c:	30 e0       	ldi	r19, 0x00	; 0
     76e:	20 e0       	ldi	r18, 0x00	; 0
     770:	90 e8       	ldi	r25, 0x80	; 128
     772:	8f eb       	ldi	r24, 0xBF	; 191
     774:	ac 01       	movw	r20, r24
     776:	63 2f       	mov	r22, r19
     778:	72 2f       	mov	r23, r18
     77a:	85 2f       	mov	r24, r21
     77c:	94 2f       	mov	r25, r20
     77e:	df 91       	pop	r29
     780:	cf 91       	pop	r28
     782:	1f 91       	pop	r17
     784:	0f 91       	pop	r16
     786:	08 95       	ret

00000788 <_Z9ScanColorv>:
     788:	87 ee       	ldi	r24, 0xE7	; 231
     78a:	91 e0       	ldi	r25, 0x01	; 1
     78c:	0e 94 63 1a 	call	0x34c6	; 0x34c6 <_ZN9MD_TCS2304readEv>
     790:	87 ee       	ldi	r24, 0xE7	; 231
     792:	91 e0       	ldi	r25, 0x01	; 1
     794:	0e 94 6d 1a 	call	0x34da	; 0x34da <_ZN9MD_TCS2309availableEv>
     798:	88 23       	and	r24, r24
     79a:	d1 f3       	breq	.-12     	; 0x790 <_Z9ScanColorv+0x8>
     79c:	6d e1       	ldi	r22, 0x1D	; 29
     79e:	72 e0       	ldi	r23, 0x02	; 2
     7a0:	87 ee       	ldi	r24, 0xE7	; 231
     7a2:	91 e0       	ldi	r25, 0x01	; 1
     7a4:	0e 94 99 19 	call	0x3332	; 0x3332 <_ZN9MD_TCS2306getRGBEP9colorData>
     7a8:	0c 94 40 03 	jmp	0x680	; 0x680 <_Z9FindMatchv>

000007ac <_Z13findTestStripv>:
     7ac:	87 ee       	ldi	r24, 0xE7	; 231
     7ae:	91 e0       	ldi	r25, 0x01	; 1
     7b0:	0e 94 63 1a 	call	0x34c6	; 0x34c6 <_ZN9MD_TCS2304readEv>
     7b4:	87 ee       	ldi	r24, 0xE7	; 231
     7b6:	91 e0       	ldi	r25, 0x01	; 1
     7b8:	0e 94 6d 1a 	call	0x34da	; 0x34da <_ZN9MD_TCS2309availableEv>
     7bc:	88 23       	and	r24, r24
     7be:	d1 f3       	breq	.-12     	; 0x7b4 <_Z13findTestStripv+0x8>
     7c0:	6d e1       	ldi	r22, 0x1D	; 29
     7c2:	72 e0       	ldi	r23, 0x02	; 2
     7c4:	87 ee       	ldi	r24, 0xE7	; 231
     7c6:	91 e0       	ldi	r25, 0x01	; 1
     7c8:	0e 94 99 19 	call	0x3332	; 0x3332 <_ZN9MD_TCS2306getRGBEP9colorData>
     7cc:	87 e0       	ldi	r24, 0x07	; 7
     7ce:	e0 e2       	ldi	r30, 0x20	; 32
     7d0:	f2 e0       	ldi	r31, 0x02	; 2
     7d2:	a6 e1       	ldi	r26, 0x16	; 22
     7d4:	b2 e0       	ldi	r27, 0x02	; 2
     7d6:	01 90       	ld	r0, Z+
     7d8:	0d 92       	st	X+, r0
     7da:	8a 95       	dec	r24
     7dc:	e1 f7       	brne	.-8      	; 0x7d6 <_Z13findTestStripv+0x2a>
     7de:	0c 94 14 03 	jmp	0x628	; 0x628 <_Z9SameColorv>

000007e2 <_Z6setLED8LEDColor>:
     7e2:	cf 93       	push	r28
     7e4:	df 93       	push	r29
     7e6:	00 d0       	rcall	.+0      	; 0x7e8 <_Z6setLED8LEDColor+0x6>
     7e8:	00 d0       	rcall	.+0      	; 0x7ea <_Z6setLED8LEDColor+0x8>
     7ea:	00 d0       	rcall	.+0      	; 0x7ec <_Z6setLED8LEDColor+0xa>
     7ec:	cd b7       	in	r28, 0x3d	; 61
     7ee:	de b7       	in	r29, 0x3e	; 62
     7f0:	49 83       	std	Y+1, r20	; 0x01
     7f2:	5a 83       	std	Y+2, r21	; 0x02
     7f4:	6b 83       	std	Y+3, r22	; 0x03
     7f6:	7c 83       	std	Y+4, r23	; 0x04
     7f8:	8d 83       	std	Y+5, r24	; 0x05
     7fa:	9e 83       	std	Y+6, r25	; 0x06
     7fc:	69 81       	ldd	r22, Y+1	; 0x01
     7fe:	7a 81       	ldd	r23, Y+2	; 0x02
     800:	82 e0       	ldi	r24, 0x02	; 2
     802:	0e 94 8a 0c 	call	0x1914	; 0x1914 <analogWrite>
     806:	6b 81       	ldd	r22, Y+3	; 0x03
     808:	7c 81       	ldd	r23, Y+4	; 0x04
     80a:	83 e0       	ldi	r24, 0x03	; 3
     80c:	0e 94 8a 0c 	call	0x1914	; 0x1914 <analogWrite>
     810:	6d 81       	ldd	r22, Y+5	; 0x05
     812:	7e 81       	ldd	r23, Y+6	; 0x06
     814:	84 e0       	ldi	r24, 0x04	; 4
     816:	26 96       	adiw	r28, 0x06	; 6
     818:	0f b6       	in	r0, 0x3f	; 63
     81a:	f8 94       	cli
     81c:	de bf       	out	0x3e, r29	; 62
     81e:	0f be       	out	0x3f, r0	; 63
     820:	cd bf       	out	0x3d, r28	; 61
     822:	df 91       	pop	r29
     824:	cf 91       	pop	r28
     826:	0c 94 8a 0c 	jmp	0x1914	; 0x1914 <analogWrite>

0000082a <_Z15TaskAmmoniaReadPv>:
     82a:	0e 94 fd 12 	call	0x25fa	; 0x25fa <xTaskGetTickCount>
     82e:	61 e0       	ldi	r22, 0x01	; 1
     830:	8d e0       	ldi	r24, 0x0D	; 13
     832:	0e 94 12 0d 	call	0x1a24	; 0x1a24 <pinMode>
     836:	61 e0       	ldi	r22, 0x01	; 1
     838:	70 e0       	ldi	r23, 0x00	; 0
     83a:	80 91 b8 01 	lds	r24, 0x01B8	; 0x8001b8 <xSerialSemaphoreColorSensor>
     83e:	90 91 b9 01 	lds	r25, 0x01B9	; 0x8001b9 <xSerialSemaphoreColorSensor+0x1>
     842:	0e 94 f1 0f 	call	0x1fe2	; 0x1fe2 <xQueueSemaphoreTake>
     846:	81 30       	cpi	r24, 0x01	; 1
     848:	a9 f5       	brne	.+106    	; 0x8b4 <_Z15TaskAmmoniaReadPv+0x8a>
     84a:	0e 94 d6 03 	call	0x7ac	; 0x7ac <_Z13findTestStripv>
     84e:	40 91 16 01 	lds	r20, 0x0116	; 0x800116 <Red>
     852:	50 91 17 01 	lds	r21, 0x0117	; 0x800117 <Red+0x1>
     856:	60 91 18 01 	lds	r22, 0x0118	; 0x800118 <Red+0x2>
     85a:	70 91 19 01 	lds	r23, 0x0119	; 0x800119 <Red+0x3>
     85e:	80 91 1a 01 	lds	r24, 0x011A	; 0x80011a <Red+0x4>
     862:	90 91 1b 01 	lds	r25, 0x011B	; 0x80011b <Red+0x5>
     866:	0e 94 f1 03 	call	0x7e2	; 0x7e2 <_Z6setLED8LEDColor>
     86a:	10 92 ac 02 	sts	0x02AC, r1	; 0x8002ac <typeToRead>
     86e:	8c eb       	ldi	r24, 0xBC	; 188
     870:	92 e0       	ldi	r25, 0x02	; 2
     872:	0e 94 5a 14 	call	0x28b4	; 0x28b4 <vTaskDelay>
     876:	0e 94 c4 03 	call	0x788	; 0x788 <_Z9ScanColorv>
     87a:	40 91 e1 01 	lds	r20, 0x01E1	; 0x8001e1 <Black>
     87e:	50 91 e2 01 	lds	r21, 0x01E2	; 0x8001e2 <Black+0x1>
     882:	60 91 e3 01 	lds	r22, 0x01E3	; 0x8001e3 <Black+0x2>
     886:	70 91 e4 01 	lds	r23, 0x01E4	; 0x8001e4 <Black+0x3>
     88a:	80 91 e5 01 	lds	r24, 0x01E5	; 0x8001e5 <Black+0x4>
     88e:	90 91 e6 01 	lds	r25, 0x01E6	; 0x8001e6 <Black+0x5>
     892:	0e 94 f1 03 	call	0x7e2	; 0x7e2 <_Z6setLED8LEDColor>
     896:	20 e0       	ldi	r18, 0x00	; 0
     898:	40 e0       	ldi	r20, 0x00	; 0
     89a:	50 e0       	ldi	r21, 0x00	; 0
     89c:	60 e0       	ldi	r22, 0x00	; 0
     89e:	70 e0       	ldi	r23, 0x00	; 0
     8a0:	80 91 b8 01 	lds	r24, 0x01B8	; 0x8001b8 <xSerialSemaphoreColorSensor>
     8a4:	90 91 b9 01 	lds	r25, 0x01B9	; 0x8001b9 <xSerialSemaphoreColorSensor+0x1>
     8a8:	0e 94 9a 0e 	call	0x1d34	; 0x1d34 <xQueueGenericSend>
     8ac:	80 e0       	ldi	r24, 0x00	; 0
     8ae:	90 e0       	ldi	r25, 0x00	; 0
     8b0:	0e 94 cd 14 	call	0x299a	; 0x299a <vTaskSuspend>
     8b4:	81 e0       	ldi	r24, 0x01	; 1
     8b6:	90 e0       	ldi	r25, 0x00	; 0
     8b8:	0e 94 5a 14 	call	0x28b4	; 0x28b4 <vTaskDelay>
     8bc:	bc cf       	rjmp	.-136    	; 0x836 <_Z15TaskAmmoniaReadPv+0xc>

000008be <_Z15TaskNitriteReadPv>:
     8be:	0e 94 fd 12 	call	0x25fa	; 0x25fa <xTaskGetTickCount>
     8c2:	61 e0       	ldi	r22, 0x01	; 1
     8c4:	8d e0       	ldi	r24, 0x0D	; 13
     8c6:	0e 94 12 0d 	call	0x1a24	; 0x1a24 <pinMode>
     8ca:	c2 e0       	ldi	r28, 0x02	; 2
     8cc:	61 e0       	ldi	r22, 0x01	; 1
     8ce:	70 e0       	ldi	r23, 0x00	; 0
     8d0:	80 91 b8 01 	lds	r24, 0x01B8	; 0x8001b8 <xSerialSemaphoreColorSensor>
     8d4:	90 91 b9 01 	lds	r25, 0x01B9	; 0x8001b9 <xSerialSemaphoreColorSensor+0x1>
     8d8:	0e 94 f1 0f 	call	0x1fe2	; 0x1fe2 <xQueueSemaphoreTake>
     8dc:	81 30       	cpi	r24, 0x01	; 1
     8de:	a9 f5       	brne	.+106    	; 0x94a <__stack+0x4b>
     8e0:	0e 94 d6 03 	call	0x7ac	; 0x7ac <_Z13findTestStripv>
     8e4:	40 91 10 01 	lds	r20, 0x0110	; 0x800110 <Green>
     8e8:	50 91 11 01 	lds	r21, 0x0111	; 0x800111 <Green+0x1>
     8ec:	60 91 12 01 	lds	r22, 0x0112	; 0x800112 <Green+0x2>
     8f0:	70 91 13 01 	lds	r23, 0x0113	; 0x800113 <Green+0x3>
     8f4:	80 91 14 01 	lds	r24, 0x0114	; 0x800114 <Green+0x4>
     8f8:	90 91 15 01 	lds	r25, 0x0115	; 0x800115 <Green+0x5>
     8fc:	0e 94 f1 03 	call	0x7e2	; 0x7e2 <_Z6setLED8LEDColor>
     900:	c0 93 ac 02 	sts	0x02AC, r28	; 0x8002ac <typeToRead>
     904:	80 ea       	ldi	r24, 0xA0	; 160
     906:	9f e0       	ldi	r25, 0x0F	; 15
     908:	0e 94 5a 14 	call	0x28b4	; 0x28b4 <vTaskDelay>
     90c:	0e 94 c4 03 	call	0x788	; 0x788 <_Z9ScanColorv>
     910:	40 91 e1 01 	lds	r20, 0x01E1	; 0x8001e1 <Black>
     914:	50 91 e2 01 	lds	r21, 0x01E2	; 0x8001e2 <Black+0x1>
     918:	60 91 e3 01 	lds	r22, 0x01E3	; 0x8001e3 <Black+0x2>
     91c:	70 91 e4 01 	lds	r23, 0x01E4	; 0x8001e4 <Black+0x3>
     920:	80 91 e5 01 	lds	r24, 0x01E5	; 0x8001e5 <Black+0x4>
     924:	90 91 e6 01 	lds	r25, 0x01E6	; 0x8001e6 <Black+0x5>
     928:	0e 94 f1 03 	call	0x7e2	; 0x7e2 <_Z6setLED8LEDColor>
     92c:	20 e0       	ldi	r18, 0x00	; 0
     92e:	40 e0       	ldi	r20, 0x00	; 0
     930:	50 e0       	ldi	r21, 0x00	; 0
     932:	60 e0       	ldi	r22, 0x00	; 0
     934:	70 e0       	ldi	r23, 0x00	; 0
     936:	80 91 b8 01 	lds	r24, 0x01B8	; 0x8001b8 <xSerialSemaphoreColorSensor>
     93a:	90 91 b9 01 	lds	r25, 0x01B9	; 0x8001b9 <xSerialSemaphoreColorSensor+0x1>
     93e:	0e 94 9a 0e 	call	0x1d34	; 0x1d34 <xQueueGenericSend>
     942:	80 e0       	ldi	r24, 0x00	; 0
     944:	90 e0       	ldi	r25, 0x00	; 0
     946:	0e 94 cd 14 	call	0x299a	; 0x299a <vTaskSuspend>
     94a:	81 e0       	ldi	r24, 0x01	; 1
     94c:	90 e0       	ldi	r25, 0x00	; 0
     94e:	0e 94 5a 14 	call	0x28b4	; 0x28b4 <vTaskDelay>
     952:	bc cf       	rjmp	.-136    	; 0x8cc <_Z15TaskNitriteReadPv+0xe>

00000954 <_Z15TaskNitrateReadPv>:
     954:	0e 94 fd 12 	call	0x25fa	; 0x25fa <xTaskGetTickCount>
     958:	61 e0       	ldi	r22, 0x01	; 1
     95a:	8d e0       	ldi	r24, 0x0D	; 13
     95c:	0e 94 12 0d 	call	0x1a24	; 0x1a24 <pinMode>
     960:	61 e0       	ldi	r22, 0x01	; 1
     962:	70 e0       	ldi	r23, 0x00	; 0
     964:	80 91 b8 01 	lds	r24, 0x01B8	; 0x8001b8 <xSerialSemaphoreColorSensor>
     968:	90 91 b9 01 	lds	r25, 0x01B9	; 0x8001b9 <xSerialSemaphoreColorSensor+0x1>
     96c:	0e 94 f1 0f 	call	0x1fe2	; 0x1fe2 <xQueueSemaphoreTake>
     970:	c8 2f       	mov	r28, r24
     972:	81 30       	cpi	r24, 0x01	; 1
     974:	a9 f5       	brne	.+106    	; 0x9e0 <_Z15TaskNitrateReadPv+0x8c>
     976:	0e 94 d6 03 	call	0x7ac	; 0x7ac <_Z13findTestStripv>
     97a:	40 91 0a 01 	lds	r20, 0x010A	; 0x80010a <Blue>
     97e:	50 91 0b 01 	lds	r21, 0x010B	; 0x80010b <Blue+0x1>
     982:	60 91 0c 01 	lds	r22, 0x010C	; 0x80010c <Blue+0x2>
     986:	70 91 0d 01 	lds	r23, 0x010D	; 0x80010d <Blue+0x3>
     98a:	80 91 0e 01 	lds	r24, 0x010E	; 0x80010e <Blue+0x4>
     98e:	90 91 0f 01 	lds	r25, 0x010F	; 0x80010f <Blue+0x5>
     992:	0e 94 f1 03 	call	0x7e2	; 0x7e2 <_Z6setLED8LEDColor>
     996:	c0 93 ac 02 	sts	0x02AC, r28	; 0x8002ac <typeToRead>
     99a:	80 ea       	ldi	r24, 0xA0	; 160
     99c:	9f e0       	ldi	r25, 0x0F	; 15
     99e:	0e 94 5a 14 	call	0x28b4	; 0x28b4 <vTaskDelay>
     9a2:	0e 94 c4 03 	call	0x788	; 0x788 <_Z9ScanColorv>
     9a6:	40 91 e1 01 	lds	r20, 0x01E1	; 0x8001e1 <Black>
     9aa:	50 91 e2 01 	lds	r21, 0x01E2	; 0x8001e2 <Black+0x1>
     9ae:	60 91 e3 01 	lds	r22, 0x01E3	; 0x8001e3 <Black+0x2>
     9b2:	70 91 e4 01 	lds	r23, 0x01E4	; 0x8001e4 <Black+0x3>
     9b6:	80 91 e5 01 	lds	r24, 0x01E5	; 0x8001e5 <Black+0x4>
     9ba:	90 91 e6 01 	lds	r25, 0x01E6	; 0x8001e6 <Black+0x5>
     9be:	0e 94 f1 03 	call	0x7e2	; 0x7e2 <_Z6setLED8LEDColor>
     9c2:	20 e0       	ldi	r18, 0x00	; 0
     9c4:	40 e0       	ldi	r20, 0x00	; 0
     9c6:	50 e0       	ldi	r21, 0x00	; 0
     9c8:	60 e0       	ldi	r22, 0x00	; 0
     9ca:	70 e0       	ldi	r23, 0x00	; 0
     9cc:	80 91 b8 01 	lds	r24, 0x01B8	; 0x8001b8 <xSerialSemaphoreColorSensor>
     9d0:	90 91 b9 01 	lds	r25, 0x01B9	; 0x8001b9 <xSerialSemaphoreColorSensor+0x1>
     9d4:	0e 94 9a 0e 	call	0x1d34	; 0x1d34 <xQueueGenericSend>
     9d8:	80 e0       	ldi	r24, 0x00	; 0
     9da:	90 e0       	ldi	r25, 0x00	; 0
     9dc:	0e 94 cd 14 	call	0x299a	; 0x299a <vTaskSuspend>
     9e0:	81 e0       	ldi	r24, 0x01	; 1
     9e2:	90 e0       	ldi	r25, 0x00	; 0
     9e4:	0e 94 5a 14 	call	0x28b4	; 0x28b4 <vTaskDelay>
     9e8:	bb cf       	rjmp	.-138    	; 0x960 <_Z15TaskNitrateReadPv+0xc>

000009ea <_Z8setupLEDv>:
     9ea:	61 e0       	ldi	r22, 0x01	; 1
     9ec:	82 e0       	ldi	r24, 0x02	; 2
     9ee:	0e 94 12 0d 	call	0x1a24	; 0x1a24 <pinMode>
     9f2:	61 e0       	ldi	r22, 0x01	; 1
     9f4:	83 e0       	ldi	r24, 0x03	; 3
     9f6:	0e 94 12 0d 	call	0x1a24	; 0x1a24 <pinMode>
     9fa:	61 e0       	ldi	r22, 0x01	; 1
     9fc:	84 e0       	ldi	r24, 0x04	; 4
     9fe:	0e 94 12 0d 	call	0x1a24	; 0x1a24 <pinMode>
     a02:	40 91 e1 01 	lds	r20, 0x01E1	; 0x8001e1 <Black>
     a06:	50 91 e2 01 	lds	r21, 0x01E2	; 0x8001e2 <Black+0x1>
     a0a:	60 91 e3 01 	lds	r22, 0x01E3	; 0x8001e3 <Black+0x2>
     a0e:	70 91 e4 01 	lds	r23, 0x01E4	; 0x8001e4 <Black+0x3>
     a12:	80 91 e5 01 	lds	r24, 0x01E5	; 0x8001e5 <Black+0x4>
     a16:	90 91 e6 01 	lds	r25, 0x01E6	; 0x8001e6 <Black+0x5>
     a1a:	0c 94 f1 03 	jmp	0x7e2	; 0x7e2 <_Z6setLED8LEDColor>

00000a1e <_Z6phInitv>:
     a1e:	8a eb       	ldi	r24, 0xBA	; 186
     a20:	91 e0       	ldi	r25, 0x01	; 1
     a22:	0c 94 c7 00 	jmp	0x18e	; 0x18e <_ZN10DFRobot_PH5beginEv>

00000a26 <_Z5getPHv>:
     a26:	0f 93       	push	r16
     a28:	1f 93       	push	r17
     a2a:	8f e0       	ldi	r24, 0x0F	; 15
     a2c:	0e 94 6d 0c 	call	0x18da	; 0x18da <analogRead>
     a30:	bc 01       	movw	r22, r24
     a32:	99 0f       	add	r25, r25
     a34:	88 0b       	sbc	r24, r24
     a36:	99 0b       	sbc	r25, r25
     a38:	0e 94 bf 06 	call	0xd7e	; 0xd7e <__floatsisf>
     a3c:	20 e0       	ldi	r18, 0x00	; 0
     a3e:	30 e0       	ldi	r19, 0x00	; 0
     a40:	40 e8       	ldi	r20, 0x80	; 128
     a42:	5a e3       	ldi	r21, 0x3A	; 58
     a44:	0e 94 74 07 	call	0xee8	; 0xee8 <__mulsf3>
     a48:	20 e0       	ldi	r18, 0x00	; 0
     a4a:	30 e4       	ldi	r19, 0x40	; 64
     a4c:	4c e9       	ldi	r20, 0x9C	; 156
     a4e:	55 e4       	ldi	r21, 0x45	; 69
     a50:	0e 94 74 07 	call	0xee8	; 0xee8 <__mulsf3>
     a54:	ab 01       	movw	r20, r22
     a56:	bc 01       	movw	r22, r24
     a58:	40 93 dd 01 	sts	0x01DD, r20	; 0x8001dd <voltage>
     a5c:	50 93 de 01 	sts	0x01DE, r21	; 0x8001de <voltage+0x1>
     a60:	60 93 df 01 	sts	0x01DF, r22	; 0x8001df <voltage+0x2>
     a64:	70 93 e0 01 	sts	0x01E0, r23	; 0x8001e0 <voltage+0x3>
     a68:	00 91 06 01 	lds	r16, 0x0106	; 0x800106 <temperature>
     a6c:	10 91 07 01 	lds	r17, 0x0107	; 0x800107 <temperature+0x1>
     a70:	20 91 08 01 	lds	r18, 0x0108	; 0x800108 <temperature+0x2>
     a74:	30 91 09 01 	lds	r19, 0x0109	; 0x800109 <temperature+0x3>
     a78:	8a eb       	ldi	r24, 0xBA	; 186
     a7a:	91 e0       	ldi	r25, 0x01	; 1
     a7c:	0e 94 76 01 	call	0x2ec	; 0x2ec <_ZN10DFRobot_PH6readPHEff>
     a80:	60 93 d9 01 	sts	0x01D9, r22	; 0x8001d9 <phValue>
     a84:	70 93 da 01 	sts	0x01DA, r23	; 0x8001da <phValue+0x1>
     a88:	80 93 db 01 	sts	0x01DB, r24	; 0x8001db <phValue+0x2>
     a8c:	90 93 dc 01 	sts	0x01DC, r25	; 0x8001dc <phValue+0x3>
     a90:	1f 91       	pop	r17
     a92:	0f 91       	pop	r16
     a94:	08 95       	ret

00000a96 <_Z10TaskPHReadPv>:
     a96:	cf 93       	push	r28
     a98:	df 93       	push	r29
     a9a:	00 d0       	rcall	.+0      	; 0xa9c <_Z10TaskPHReadPv+0x6>
     a9c:	cd b7       	in	r28, 0x3d	; 61
     a9e:	de b7       	in	r29, 0x3e	; 62
     aa0:	0e 94 fd 12 	call	0x25fa	; 0x25fa <xTaskGetTickCount>
     aa4:	9a 83       	std	Y+2, r25	; 0x02
     aa6:	89 83       	std	Y+1, r24	; 0x01
     aa8:	0e 94 0f 05 	call	0xa1e	; 0xa1e <_Z6phInitv>
     aac:	0e 94 13 05 	call	0xa26	; 0xa26 <_Z5getPHv>
     ab0:	60 e0       	ldi	r22, 0x00	; 0
     ab2:	8d e0       	ldi	r24, 0x0D	; 13
     ab4:	0e 94 4e 0d 	call	0x1a9c	; 0x1a9c <digitalWrite>
     ab8:	6a eb       	ldi	r22, 0xBA	; 186
     aba:	7b ed       	ldi	r23, 0xDB	; 219
     abc:	ce 01       	movw	r24, r28
     abe:	01 96       	adiw	r24, 0x01	; 1
     ac0:	0e 94 22 14 	call	0x2844	; 0x2844 <vTaskDelayUntil>
     ac4:	f1 cf       	rjmp	.-30     	; 0xaa8 <_Z10TaskPHReadPv+0x12>

00000ac6 <setup>:
TaskHandle_t xNitrate;
TaskHandle_t xPH;
TaskHandle_t xTemperature;

// the setup function runs once when you press reset or power the board
void setup() {
     ac6:	ef 92       	push	r14
     ac8:	ff 92       	push	r15
     aca:	0f 93       	push	r16
  public:
    inline HardwareSerial(
      volatile uint8_t *ubrrh, volatile uint8_t *ubrrl,
      volatile uint8_t *ucsra, volatile uint8_t *ucsrb,
      volatile uint8_t *ucsrc, volatile uint8_t *udr);
    void begin(unsigned long baud) { begin(baud, SERIAL_8N1); }
     acc:	26 e0       	ldi	r18, 0x06	; 6
     ace:	40 e8       	ldi	r20, 0x80	; 128
     ad0:	55 e2       	ldi	r21, 0x25	; 37
     ad2:	60 e0       	ldi	r22, 0x00	; 0
     ad4:	70 e0       	ldi	r23, 0x00	; 0
     ad6:	8d ea       	ldi	r24, 0xAD	; 173
     ad8:	92 e0       	ldi	r25, 0x02	; 2
     ada:	0e 94 bd 08 	call	0x117a	; 0x117a <_ZN14HardwareSerial5beginEmh>
  while (!Serial) {
    ; // wait for serial port to connect. Needed for native USB, on LEONARDO, MICRO, YUN, and other 32u4 based boards.
  }

  // load test strip color data and initialize indicator LED
  addColors();
     ade:	0e 94 16 02 	call	0x42c	; 0x42c <_Z9addColorsv>
  setupLED();
     ae2:	0e 94 f5 04 	call	0x9ea	; 0x9ea <_Z8setupLEDv>

  // TODO: Not sure how Wifi module indicates that it is getting data - replace that with the interrupt from pin2 
  attachInterrupt(digitalPinToInterrupt(2), fromWifi, RISING);
     ae6:	43 e0       	ldi	r20, 0x03	; 3
     ae8:	50 e0       	ldi	r21, 0x00	; 0
     aea:	60 e1       	ldi	r22, 0x10	; 16
     aec:	72 e0       	ldi	r23, 0x02	; 2
     aee:	80 e0       	ldi	r24, 0x00	; 0
     af0:	0e 94 7a 0b 	call	0x16f4	; 0x16f4 <attachInterrupt>
    TaskAmmoniaRead
    ,  (const portCHAR *)"Ammonia"
    ,  128
    ,  NULL
    ,  2
    ,  &xAmmonia );
     af4:	86 eb       	ldi	r24, 0xB6	; 182
     af6:	e8 2e       	mov	r14, r24
     af8:	81 e0       	ldi	r24, 0x01	; 1
     afa:	f8 2e       	mov	r15, r24
     afc:	02 e0       	ldi	r16, 0x02	; 2
     afe:	20 e0       	ldi	r18, 0x00	; 0
     b00:	30 e0       	ldi	r19, 0x00	; 0
     b02:	40 e8       	ldi	r20, 0x80	; 128
     b04:	50 e0       	ldi	r21, 0x00	; 0
     b06:	65 e5       	ldi	r22, 0x55	; 85
     b08:	71 e0       	ldi	r23, 0x01	; 1
     b0a:	85 e1       	ldi	r24, 0x15	; 21
     b0c:	94 e0       	ldi	r25, 0x04	; 4
     b0e:	0e 94 74 11 	call	0x22e8	; 0x22e8 <xTaskCreate>
    TaskNitriteRead
    ,  (const portCHAR *) "Nitrite"
    ,  128  // Stack size
    ,  NULL
    ,  2  // Priority
    ,  &xNitrite );
     b12:	94 eb       	ldi	r25, 0xB4	; 180
     b14:	e9 2e       	mov	r14, r25
     b16:	91 e0       	ldi	r25, 0x01	; 1
     b18:	f9 2e       	mov	r15, r25
     b1a:	20 e0       	ldi	r18, 0x00	; 0
     b1c:	30 e0       	ldi	r19, 0x00	; 0
     b1e:	40 e8       	ldi	r20, 0x80	; 128
     b20:	50 e0       	ldi	r21, 0x00	; 0
     b22:	6d e5       	ldi	r22, 0x5D	; 93
     b24:	71 e0       	ldi	r23, 0x01	; 1
     b26:	8f e5       	ldi	r24, 0x5F	; 95
     b28:	94 e0       	ldi	r25, 0x04	; 4
     b2a:	0e 94 74 11 	call	0x22e8	; 0x22e8 <xTaskCreate>
    TaskNitrateRead
    ,  (const portCHAR *) "Nitrate"
    ,  128  // Stack size
    ,  NULL
    ,  2  // Priority
    ,  &xNitrate );
     b2e:	22 eb       	ldi	r18, 0xB2	; 178
     b30:	e2 2e       	mov	r14, r18
     b32:	21 e0       	ldi	r18, 0x01	; 1
     b34:	f2 2e       	mov	r15, r18
     b36:	20 e0       	ldi	r18, 0x00	; 0
     b38:	30 e0       	ldi	r19, 0x00	; 0
     b3a:	40 e8       	ldi	r20, 0x80	; 128
     b3c:	50 e0       	ldi	r21, 0x00	; 0
     b3e:	65 e6       	ldi	r22, 0x65	; 101
     b40:	71 e0       	ldi	r23, 0x01	; 1
     b42:	8a ea       	ldi	r24, 0xAA	; 170
     b44:	94 e0       	ldi	r25, 0x04	; 4
     b46:	0e 94 74 11 	call	0x22e8	; 0x22e8 <xTaskCreate>
    TaskPHRead
    ,  (const portCHAR *) "pH"
    ,  128  // Stack size
    ,  NULL
    ,  2  // Priority
    ,  &xPH );
     b4a:	30 eb       	ldi	r19, 0xB0	; 176
     b4c:	e3 2e       	mov	r14, r19
     b4e:	31 e0       	ldi	r19, 0x01	; 1
     b50:	f3 2e       	mov	r15, r19
     b52:	20 e0       	ldi	r18, 0x00	; 0
     b54:	30 e0       	ldi	r19, 0x00	; 0
     b56:	40 e8       	ldi	r20, 0x80	; 128
     b58:	50 e0       	ldi	r21, 0x00	; 0
     b5a:	6d e6       	ldi	r22, 0x6D	; 109
     b5c:	71 e0       	ldi	r23, 0x01	; 1
     b5e:	8b e4       	ldi	r24, 0x4B	; 75
     b60:	95 e0       	ldi	r25, 0x05	; 5
     b62:	0e 94 74 11 	call	0x22e8	; 0x22e8 <xTaskCreate>
    TaskTemperatureRead
    ,  (const portCHAR *) "Temperature"
    ,  128  // Stack size
    ,  NULL
    ,  2  // Priority
    ,  &xTemperature );
     b66:	4e ea       	ldi	r20, 0xAE	; 174
     b68:	e4 2e       	mov	r14, r20
     b6a:	41 e0       	ldi	r20, 0x01	; 1
     b6c:	f4 2e       	mov	r15, r20
     b6e:	20 e0       	ldi	r18, 0x00	; 0
     b70:	30 e0       	ldi	r19, 0x00	; 0
     b72:	40 e8       	ldi	r20, 0x80	; 128
     b74:	50 e0       	ldi	r21, 0x00	; 0
     b76:	60 e7       	ldi	r22, 0x70	; 112
     b78:	71 e0       	ldi	r23, 0x01	; 1
     b7a:	8c ef       	ldi	r24, 0xFC	; 252
     b7c:	91 e0       	ldi	r25, 0x01	; 1
     b7e:	0e 94 74 11 	call	0x22e8	; 0x22e8 <xTaskCreate>

  // Now the task scheduler, which takes over control of scheduling individual tasks, is automatically started.
}
     b82:	0f 91       	pop	r16
     b84:	ff 90       	pop	r15
     b86:	ef 90       	pop	r14
     b88:	08 95       	ret

00000b8a <loop>:

void loop()
{
     b8a:	08 95       	ret

00000b8c <_GLOBAL__sub_I_typeToRead>:
Color EmptyTestBox {0, {0, 0, 0}};

colorData rgb;
Color c;

MD_TCS230  CS(S2, S3, OE);
     b8c:	28 e0       	ldi	r18, 0x08	; 8
     b8e:	4d e0       	ldi	r20, 0x0D	; 13
     b90:	6c e0       	ldi	r22, 0x0C	; 12
     b92:	87 ee       	ldi	r24, 0xE7	; 231
     b94:	91 e0       	ldi	r25, 0x01	; 1
     b96:	0e 94 27 19 	call	0x324e	; 0x324e <_ZN9MD_TCS230C1Ehhh>
#include "DFRobot_PH.h"
#include <EEPROM.h>

#define PH_PIN A1
float voltage, phValue, temperature = 25;
DFRobot_PH ph;
     b9a:	8a eb       	ldi	r24, 0xBA	; 186
     b9c:	91 e0       	ldi	r25, 0x01	; 1
     b9e:	0c 94 a0 00 	jmp	0x140	; 0x140 <_ZN10DFRobot_PHC1Ev>

00000ba2 <_GLOBAL__sub_D_typeToRead>:
     ba2:	8a eb       	ldi	r24, 0xBA	; 186
     ba4:	91 e0       	ldi	r25, 0x01	; 1
     ba6:	0e 94 c6 00 	call	0x18c	; 0x18c <_ZN10DFRobot_PHD1Ev>
     baa:	87 ee       	ldi	r24, 0xE7	; 231
     bac:	91 e0       	ldi	r25, 0x01	; 1
     bae:	0c 94 3b 19 	jmp	0x3276	; 0x3276 <_ZN9MD_TCS230D1Ev>

00000bb2 <__subsf3>:
     bb2:	50 58       	subi	r21, 0x80	; 128

00000bb4 <__addsf3>:
     bb4:	bb 27       	eor	r27, r27
     bb6:	aa 27       	eor	r26, r26
     bb8:	0e 94 f1 05 	call	0xbe2	; 0xbe2 <__addsf3x>
     bbc:	0c 94 35 07 	jmp	0xe6a	; 0xe6a <__fp_round>
     bc0:	0e 94 27 07 	call	0xe4e	; 0xe4e <__fp_pscA>
     bc4:	38 f0       	brcs	.+14     	; 0xbd4 <__addsf3+0x20>
     bc6:	0e 94 2e 07 	call	0xe5c	; 0xe5c <__fp_pscB>
     bca:	20 f0       	brcs	.+8      	; 0xbd4 <__addsf3+0x20>
     bcc:	39 f4       	brne	.+14     	; 0xbdc <__addsf3+0x28>
     bce:	9f 3f       	cpi	r25, 0xFF	; 255
     bd0:	19 f4       	brne	.+6      	; 0xbd8 <__addsf3+0x24>
     bd2:	26 f4       	brtc	.+8      	; 0xbdc <__addsf3+0x28>
     bd4:	0c 94 24 07 	jmp	0xe48	; 0xe48 <__fp_nan>
     bd8:	0e f4       	brtc	.+2      	; 0xbdc <__addsf3+0x28>
     bda:	e0 95       	com	r30
     bdc:	e7 fb       	bst	r30, 7
     bde:	0c 94 1e 07 	jmp	0xe3c	; 0xe3c <__fp_inf>

00000be2 <__addsf3x>:
     be2:	e9 2f       	mov	r30, r25
     be4:	0e 94 46 07 	call	0xe8c	; 0xe8c <__fp_split3>
     be8:	58 f3       	brcs	.-42     	; 0xbc0 <__addsf3+0xc>
     bea:	ba 17       	cp	r27, r26
     bec:	62 07       	cpc	r22, r18
     bee:	73 07       	cpc	r23, r19
     bf0:	84 07       	cpc	r24, r20
     bf2:	95 07       	cpc	r25, r21
     bf4:	20 f0       	brcs	.+8      	; 0xbfe <__addsf3x+0x1c>
     bf6:	79 f4       	brne	.+30     	; 0xc16 <__addsf3x+0x34>
     bf8:	a6 f5       	brtc	.+104    	; 0xc62 <__addsf3x+0x80>
     bfa:	0c 94 68 07 	jmp	0xed0	; 0xed0 <__fp_zero>
     bfe:	0e f4       	brtc	.+2      	; 0xc02 <__addsf3x+0x20>
     c00:	e0 95       	com	r30
     c02:	0b 2e       	mov	r0, r27
     c04:	ba 2f       	mov	r27, r26
     c06:	a0 2d       	mov	r26, r0
     c08:	0b 01       	movw	r0, r22
     c0a:	b9 01       	movw	r22, r18
     c0c:	90 01       	movw	r18, r0
     c0e:	0c 01       	movw	r0, r24
     c10:	ca 01       	movw	r24, r20
     c12:	a0 01       	movw	r20, r0
     c14:	11 24       	eor	r1, r1
     c16:	ff 27       	eor	r31, r31
     c18:	59 1b       	sub	r21, r25
     c1a:	99 f0       	breq	.+38     	; 0xc42 <__addsf3x+0x60>
     c1c:	59 3f       	cpi	r21, 0xF9	; 249
     c1e:	50 f4       	brcc	.+20     	; 0xc34 <__addsf3x+0x52>
     c20:	50 3e       	cpi	r21, 0xE0	; 224
     c22:	68 f1       	brcs	.+90     	; 0xc7e <__addsf3x+0x9c>
     c24:	1a 16       	cp	r1, r26
     c26:	f0 40       	sbci	r31, 0x00	; 0
     c28:	a2 2f       	mov	r26, r18
     c2a:	23 2f       	mov	r18, r19
     c2c:	34 2f       	mov	r19, r20
     c2e:	44 27       	eor	r20, r20
     c30:	58 5f       	subi	r21, 0xF8	; 248
     c32:	f3 cf       	rjmp	.-26     	; 0xc1a <__addsf3x+0x38>
     c34:	46 95       	lsr	r20
     c36:	37 95       	ror	r19
     c38:	27 95       	ror	r18
     c3a:	a7 95       	ror	r26
     c3c:	f0 40       	sbci	r31, 0x00	; 0
     c3e:	53 95       	inc	r21
     c40:	c9 f7       	brne	.-14     	; 0xc34 <__addsf3x+0x52>
     c42:	7e f4       	brtc	.+30     	; 0xc62 <__addsf3x+0x80>
     c44:	1f 16       	cp	r1, r31
     c46:	ba 0b       	sbc	r27, r26
     c48:	62 0b       	sbc	r22, r18
     c4a:	73 0b       	sbc	r23, r19
     c4c:	84 0b       	sbc	r24, r20
     c4e:	ba f0       	brmi	.+46     	; 0xc7e <__addsf3x+0x9c>
     c50:	91 50       	subi	r25, 0x01	; 1
     c52:	a1 f0       	breq	.+40     	; 0xc7c <__addsf3x+0x9a>
     c54:	ff 0f       	add	r31, r31
     c56:	bb 1f       	adc	r27, r27
     c58:	66 1f       	adc	r22, r22
     c5a:	77 1f       	adc	r23, r23
     c5c:	88 1f       	adc	r24, r24
     c5e:	c2 f7       	brpl	.-16     	; 0xc50 <__addsf3x+0x6e>
     c60:	0e c0       	rjmp	.+28     	; 0xc7e <__addsf3x+0x9c>
     c62:	ba 0f       	add	r27, r26
     c64:	62 1f       	adc	r22, r18
     c66:	73 1f       	adc	r23, r19
     c68:	84 1f       	adc	r24, r20
     c6a:	48 f4       	brcc	.+18     	; 0xc7e <__addsf3x+0x9c>
     c6c:	87 95       	ror	r24
     c6e:	77 95       	ror	r23
     c70:	67 95       	ror	r22
     c72:	b7 95       	ror	r27
     c74:	f7 95       	ror	r31
     c76:	9e 3f       	cpi	r25, 0xFE	; 254
     c78:	08 f0       	brcs	.+2      	; 0xc7c <__addsf3x+0x9a>
     c7a:	b0 cf       	rjmp	.-160    	; 0xbdc <__addsf3+0x28>
     c7c:	93 95       	inc	r25
     c7e:	88 0f       	add	r24, r24
     c80:	08 f0       	brcs	.+2      	; 0xc84 <__addsf3x+0xa2>
     c82:	99 27       	eor	r25, r25
     c84:	ee 0f       	add	r30, r30
     c86:	97 95       	ror	r25
     c88:	87 95       	ror	r24
     c8a:	08 95       	ret

00000c8c <__cmpsf2>:
     c8c:	0e 94 fa 06 	call	0xdf4	; 0xdf4 <__fp_cmp>
     c90:	08 f4       	brcc	.+2      	; 0xc94 <__cmpsf2+0x8>
     c92:	81 e0       	ldi	r24, 0x01	; 1
     c94:	08 95       	ret

00000c96 <__divsf3>:
     c96:	0e 94 5f 06 	call	0xcbe	; 0xcbe <__divsf3x>
     c9a:	0c 94 35 07 	jmp	0xe6a	; 0xe6a <__fp_round>
     c9e:	0e 94 2e 07 	call	0xe5c	; 0xe5c <__fp_pscB>
     ca2:	58 f0       	brcs	.+22     	; 0xcba <__divsf3+0x24>
     ca4:	0e 94 27 07 	call	0xe4e	; 0xe4e <__fp_pscA>
     ca8:	40 f0       	brcs	.+16     	; 0xcba <__divsf3+0x24>
     caa:	29 f4       	brne	.+10     	; 0xcb6 <__divsf3+0x20>
     cac:	5f 3f       	cpi	r21, 0xFF	; 255
     cae:	29 f0       	breq	.+10     	; 0xcba <__divsf3+0x24>
     cb0:	0c 94 1e 07 	jmp	0xe3c	; 0xe3c <__fp_inf>
     cb4:	51 11       	cpse	r21, r1
     cb6:	0c 94 69 07 	jmp	0xed2	; 0xed2 <__fp_szero>
     cba:	0c 94 24 07 	jmp	0xe48	; 0xe48 <__fp_nan>

00000cbe <__divsf3x>:
     cbe:	0e 94 46 07 	call	0xe8c	; 0xe8c <__fp_split3>
     cc2:	68 f3       	brcs	.-38     	; 0xc9e <__divsf3+0x8>

00000cc4 <__divsf3_pse>:
     cc4:	99 23       	and	r25, r25
     cc6:	b1 f3       	breq	.-20     	; 0xcb4 <__divsf3+0x1e>
     cc8:	55 23       	and	r21, r21
     cca:	91 f3       	breq	.-28     	; 0xcb0 <__divsf3+0x1a>
     ccc:	95 1b       	sub	r25, r21
     cce:	55 0b       	sbc	r21, r21
     cd0:	bb 27       	eor	r27, r27
     cd2:	aa 27       	eor	r26, r26
     cd4:	62 17       	cp	r22, r18
     cd6:	73 07       	cpc	r23, r19
     cd8:	84 07       	cpc	r24, r20
     cda:	38 f0       	brcs	.+14     	; 0xcea <__divsf3_pse+0x26>
     cdc:	9f 5f       	subi	r25, 0xFF	; 255
     cde:	5f 4f       	sbci	r21, 0xFF	; 255
     ce0:	22 0f       	add	r18, r18
     ce2:	33 1f       	adc	r19, r19
     ce4:	44 1f       	adc	r20, r20
     ce6:	aa 1f       	adc	r26, r26
     ce8:	a9 f3       	breq	.-22     	; 0xcd4 <__divsf3_pse+0x10>
     cea:	35 d0       	rcall	.+106    	; 0xd56 <__divsf3_pse+0x92>
     cec:	0e 2e       	mov	r0, r30
     cee:	3a f0       	brmi	.+14     	; 0xcfe <__divsf3_pse+0x3a>
     cf0:	e0 e8       	ldi	r30, 0x80	; 128
     cf2:	32 d0       	rcall	.+100    	; 0xd58 <__divsf3_pse+0x94>
     cf4:	91 50       	subi	r25, 0x01	; 1
     cf6:	50 40       	sbci	r21, 0x00	; 0
     cf8:	e6 95       	lsr	r30
     cfa:	00 1c       	adc	r0, r0
     cfc:	ca f7       	brpl	.-14     	; 0xcf0 <__divsf3_pse+0x2c>
     cfe:	2b d0       	rcall	.+86     	; 0xd56 <__divsf3_pse+0x92>
     d00:	fe 2f       	mov	r31, r30
     d02:	29 d0       	rcall	.+82     	; 0xd56 <__divsf3_pse+0x92>
     d04:	66 0f       	add	r22, r22
     d06:	77 1f       	adc	r23, r23
     d08:	88 1f       	adc	r24, r24
     d0a:	bb 1f       	adc	r27, r27
     d0c:	26 17       	cp	r18, r22
     d0e:	37 07       	cpc	r19, r23
     d10:	48 07       	cpc	r20, r24
     d12:	ab 07       	cpc	r26, r27
     d14:	b0 e8       	ldi	r27, 0x80	; 128
     d16:	09 f0       	breq	.+2      	; 0xd1a <__divsf3_pse+0x56>
     d18:	bb 0b       	sbc	r27, r27
     d1a:	80 2d       	mov	r24, r0
     d1c:	bf 01       	movw	r22, r30
     d1e:	ff 27       	eor	r31, r31
     d20:	93 58       	subi	r25, 0x83	; 131
     d22:	5f 4f       	sbci	r21, 0xFF	; 255
     d24:	3a f0       	brmi	.+14     	; 0xd34 <__divsf3_pse+0x70>
     d26:	9e 3f       	cpi	r25, 0xFE	; 254
     d28:	51 05       	cpc	r21, r1
     d2a:	78 f0       	brcs	.+30     	; 0xd4a <__divsf3_pse+0x86>
     d2c:	0c 94 1e 07 	jmp	0xe3c	; 0xe3c <__fp_inf>
     d30:	0c 94 69 07 	jmp	0xed2	; 0xed2 <__fp_szero>
     d34:	5f 3f       	cpi	r21, 0xFF	; 255
     d36:	e4 f3       	brlt	.-8      	; 0xd30 <__divsf3_pse+0x6c>
     d38:	98 3e       	cpi	r25, 0xE8	; 232
     d3a:	d4 f3       	brlt	.-12     	; 0xd30 <__divsf3_pse+0x6c>
     d3c:	86 95       	lsr	r24
     d3e:	77 95       	ror	r23
     d40:	67 95       	ror	r22
     d42:	b7 95       	ror	r27
     d44:	f7 95       	ror	r31
     d46:	9f 5f       	subi	r25, 0xFF	; 255
     d48:	c9 f7       	brne	.-14     	; 0xd3c <__divsf3_pse+0x78>
     d4a:	88 0f       	add	r24, r24
     d4c:	91 1d       	adc	r25, r1
     d4e:	96 95       	lsr	r25
     d50:	87 95       	ror	r24
     d52:	97 f9       	bld	r25, 7
     d54:	08 95       	ret
     d56:	e1 e0       	ldi	r30, 0x01	; 1
     d58:	66 0f       	add	r22, r22
     d5a:	77 1f       	adc	r23, r23
     d5c:	88 1f       	adc	r24, r24
     d5e:	bb 1f       	adc	r27, r27
     d60:	62 17       	cp	r22, r18
     d62:	73 07       	cpc	r23, r19
     d64:	84 07       	cpc	r24, r20
     d66:	ba 07       	cpc	r27, r26
     d68:	20 f0       	brcs	.+8      	; 0xd72 <__divsf3_pse+0xae>
     d6a:	62 1b       	sub	r22, r18
     d6c:	73 0b       	sbc	r23, r19
     d6e:	84 0b       	sbc	r24, r20
     d70:	ba 0b       	sbc	r27, r26
     d72:	ee 1f       	adc	r30, r30
     d74:	88 f7       	brcc	.-30     	; 0xd58 <__divsf3_pse+0x94>
     d76:	e0 95       	com	r30
     d78:	08 95       	ret

00000d7a <__floatunsisf>:
     d7a:	e8 94       	clt
     d7c:	09 c0       	rjmp	.+18     	; 0xd90 <__floatsisf+0x12>

00000d7e <__floatsisf>:
     d7e:	97 fb       	bst	r25, 7
     d80:	3e f4       	brtc	.+14     	; 0xd90 <__floatsisf+0x12>
     d82:	90 95       	com	r25
     d84:	80 95       	com	r24
     d86:	70 95       	com	r23
     d88:	61 95       	neg	r22
     d8a:	7f 4f       	sbci	r23, 0xFF	; 255
     d8c:	8f 4f       	sbci	r24, 0xFF	; 255
     d8e:	9f 4f       	sbci	r25, 0xFF	; 255
     d90:	99 23       	and	r25, r25
     d92:	a9 f0       	breq	.+42     	; 0xdbe <__floatsisf+0x40>
     d94:	f9 2f       	mov	r31, r25
     d96:	96 e9       	ldi	r25, 0x96	; 150
     d98:	bb 27       	eor	r27, r27
     d9a:	93 95       	inc	r25
     d9c:	f6 95       	lsr	r31
     d9e:	87 95       	ror	r24
     da0:	77 95       	ror	r23
     da2:	67 95       	ror	r22
     da4:	b7 95       	ror	r27
     da6:	f1 11       	cpse	r31, r1
     da8:	f8 cf       	rjmp	.-16     	; 0xd9a <__floatsisf+0x1c>
     daa:	fa f4       	brpl	.+62     	; 0xdea <__floatsisf+0x6c>
     dac:	bb 0f       	add	r27, r27
     dae:	11 f4       	brne	.+4      	; 0xdb4 <__floatsisf+0x36>
     db0:	60 ff       	sbrs	r22, 0
     db2:	1b c0       	rjmp	.+54     	; 0xdea <__floatsisf+0x6c>
     db4:	6f 5f       	subi	r22, 0xFF	; 255
     db6:	7f 4f       	sbci	r23, 0xFF	; 255
     db8:	8f 4f       	sbci	r24, 0xFF	; 255
     dba:	9f 4f       	sbci	r25, 0xFF	; 255
     dbc:	16 c0       	rjmp	.+44     	; 0xdea <__floatsisf+0x6c>
     dbe:	88 23       	and	r24, r24
     dc0:	11 f0       	breq	.+4      	; 0xdc6 <__floatsisf+0x48>
     dc2:	96 e9       	ldi	r25, 0x96	; 150
     dc4:	11 c0       	rjmp	.+34     	; 0xde8 <__floatsisf+0x6a>
     dc6:	77 23       	and	r23, r23
     dc8:	21 f0       	breq	.+8      	; 0xdd2 <__floatsisf+0x54>
     dca:	9e e8       	ldi	r25, 0x8E	; 142
     dcc:	87 2f       	mov	r24, r23
     dce:	76 2f       	mov	r23, r22
     dd0:	05 c0       	rjmp	.+10     	; 0xddc <__floatsisf+0x5e>
     dd2:	66 23       	and	r22, r22
     dd4:	71 f0       	breq	.+28     	; 0xdf2 <__floatsisf+0x74>
     dd6:	96 e8       	ldi	r25, 0x86	; 134
     dd8:	86 2f       	mov	r24, r22
     dda:	70 e0       	ldi	r23, 0x00	; 0
     ddc:	60 e0       	ldi	r22, 0x00	; 0
     dde:	2a f0       	brmi	.+10     	; 0xdea <__floatsisf+0x6c>
     de0:	9a 95       	dec	r25
     de2:	66 0f       	add	r22, r22
     de4:	77 1f       	adc	r23, r23
     de6:	88 1f       	adc	r24, r24
     de8:	da f7       	brpl	.-10     	; 0xde0 <__floatsisf+0x62>
     dea:	88 0f       	add	r24, r24
     dec:	96 95       	lsr	r25
     dee:	87 95       	ror	r24
     df0:	97 f9       	bld	r25, 7
     df2:	08 95       	ret

00000df4 <__fp_cmp>:
     df4:	99 0f       	add	r25, r25
     df6:	00 08       	sbc	r0, r0
     df8:	55 0f       	add	r21, r21
     dfa:	aa 0b       	sbc	r26, r26
     dfc:	e0 e8       	ldi	r30, 0x80	; 128
     dfe:	fe ef       	ldi	r31, 0xFE	; 254
     e00:	16 16       	cp	r1, r22
     e02:	17 06       	cpc	r1, r23
     e04:	e8 07       	cpc	r30, r24
     e06:	f9 07       	cpc	r31, r25
     e08:	c0 f0       	brcs	.+48     	; 0xe3a <__fp_cmp+0x46>
     e0a:	12 16       	cp	r1, r18
     e0c:	13 06       	cpc	r1, r19
     e0e:	e4 07       	cpc	r30, r20
     e10:	f5 07       	cpc	r31, r21
     e12:	98 f0       	brcs	.+38     	; 0xe3a <__fp_cmp+0x46>
     e14:	62 1b       	sub	r22, r18
     e16:	73 0b       	sbc	r23, r19
     e18:	84 0b       	sbc	r24, r20
     e1a:	95 0b       	sbc	r25, r21
     e1c:	39 f4       	brne	.+14     	; 0xe2c <__fp_cmp+0x38>
     e1e:	0a 26       	eor	r0, r26
     e20:	61 f0       	breq	.+24     	; 0xe3a <__fp_cmp+0x46>
     e22:	23 2b       	or	r18, r19
     e24:	24 2b       	or	r18, r20
     e26:	25 2b       	or	r18, r21
     e28:	21 f4       	brne	.+8      	; 0xe32 <__fp_cmp+0x3e>
     e2a:	08 95       	ret
     e2c:	0a 26       	eor	r0, r26
     e2e:	09 f4       	brne	.+2      	; 0xe32 <__fp_cmp+0x3e>
     e30:	a1 40       	sbci	r26, 0x01	; 1
     e32:	a6 95       	lsr	r26
     e34:	8f ef       	ldi	r24, 0xFF	; 255
     e36:	81 1d       	adc	r24, r1
     e38:	81 1d       	adc	r24, r1
     e3a:	08 95       	ret

00000e3c <__fp_inf>:
     e3c:	97 f9       	bld	r25, 7
     e3e:	9f 67       	ori	r25, 0x7F	; 127
     e40:	80 e8       	ldi	r24, 0x80	; 128
     e42:	70 e0       	ldi	r23, 0x00	; 0
     e44:	60 e0       	ldi	r22, 0x00	; 0
     e46:	08 95       	ret

00000e48 <__fp_nan>:
     e48:	9f ef       	ldi	r25, 0xFF	; 255
     e4a:	80 ec       	ldi	r24, 0xC0	; 192
     e4c:	08 95       	ret

00000e4e <__fp_pscA>:
     e4e:	00 24       	eor	r0, r0
     e50:	0a 94       	dec	r0
     e52:	16 16       	cp	r1, r22
     e54:	17 06       	cpc	r1, r23
     e56:	18 06       	cpc	r1, r24
     e58:	09 06       	cpc	r0, r25
     e5a:	08 95       	ret

00000e5c <__fp_pscB>:
     e5c:	00 24       	eor	r0, r0
     e5e:	0a 94       	dec	r0
     e60:	12 16       	cp	r1, r18
     e62:	13 06       	cpc	r1, r19
     e64:	14 06       	cpc	r1, r20
     e66:	05 06       	cpc	r0, r21
     e68:	08 95       	ret

00000e6a <__fp_round>:
     e6a:	09 2e       	mov	r0, r25
     e6c:	03 94       	inc	r0
     e6e:	00 0c       	add	r0, r0
     e70:	11 f4       	brne	.+4      	; 0xe76 <__fp_round+0xc>
     e72:	88 23       	and	r24, r24
     e74:	52 f0       	brmi	.+20     	; 0xe8a <__fp_round+0x20>
     e76:	bb 0f       	add	r27, r27
     e78:	40 f4       	brcc	.+16     	; 0xe8a <__fp_round+0x20>
     e7a:	bf 2b       	or	r27, r31
     e7c:	11 f4       	brne	.+4      	; 0xe82 <__fp_round+0x18>
     e7e:	60 ff       	sbrs	r22, 0
     e80:	04 c0       	rjmp	.+8      	; 0xe8a <__fp_round+0x20>
     e82:	6f 5f       	subi	r22, 0xFF	; 255
     e84:	7f 4f       	sbci	r23, 0xFF	; 255
     e86:	8f 4f       	sbci	r24, 0xFF	; 255
     e88:	9f 4f       	sbci	r25, 0xFF	; 255
     e8a:	08 95       	ret

00000e8c <__fp_split3>:
     e8c:	57 fd       	sbrc	r21, 7
     e8e:	90 58       	subi	r25, 0x80	; 128
     e90:	44 0f       	add	r20, r20
     e92:	55 1f       	adc	r21, r21
     e94:	59 f0       	breq	.+22     	; 0xeac <__fp_splitA+0x10>
     e96:	5f 3f       	cpi	r21, 0xFF	; 255
     e98:	71 f0       	breq	.+28     	; 0xeb6 <__fp_splitA+0x1a>
     e9a:	47 95       	ror	r20

00000e9c <__fp_splitA>:
     e9c:	88 0f       	add	r24, r24
     e9e:	97 fb       	bst	r25, 7
     ea0:	99 1f       	adc	r25, r25
     ea2:	61 f0       	breq	.+24     	; 0xebc <__fp_splitA+0x20>
     ea4:	9f 3f       	cpi	r25, 0xFF	; 255
     ea6:	79 f0       	breq	.+30     	; 0xec6 <__fp_splitA+0x2a>
     ea8:	87 95       	ror	r24
     eaa:	08 95       	ret
     eac:	12 16       	cp	r1, r18
     eae:	13 06       	cpc	r1, r19
     eb0:	14 06       	cpc	r1, r20
     eb2:	55 1f       	adc	r21, r21
     eb4:	f2 cf       	rjmp	.-28     	; 0xe9a <__fp_split3+0xe>
     eb6:	46 95       	lsr	r20
     eb8:	f1 df       	rcall	.-30     	; 0xe9c <__fp_splitA>
     eba:	08 c0       	rjmp	.+16     	; 0xecc <__fp_splitA+0x30>
     ebc:	16 16       	cp	r1, r22
     ebe:	17 06       	cpc	r1, r23
     ec0:	18 06       	cpc	r1, r24
     ec2:	99 1f       	adc	r25, r25
     ec4:	f1 cf       	rjmp	.-30     	; 0xea8 <__fp_splitA+0xc>
     ec6:	86 95       	lsr	r24
     ec8:	71 05       	cpc	r23, r1
     eca:	61 05       	cpc	r22, r1
     ecc:	08 94       	sec
     ece:	08 95       	ret

00000ed0 <__fp_zero>:
     ed0:	e8 94       	clt

00000ed2 <__fp_szero>:
     ed2:	bb 27       	eor	r27, r27
     ed4:	66 27       	eor	r22, r22
     ed6:	77 27       	eor	r23, r23
     ed8:	cb 01       	movw	r24, r22
     eda:	97 f9       	bld	r25, 7
     edc:	08 95       	ret

00000ede <__gesf2>:
     ede:	0e 94 fa 06 	call	0xdf4	; 0xdf4 <__fp_cmp>
     ee2:	08 f4       	brcc	.+2      	; 0xee6 <__gesf2+0x8>
     ee4:	8f ef       	ldi	r24, 0xFF	; 255
     ee6:	08 95       	ret

00000ee8 <__mulsf3>:
     ee8:	0e 94 87 07 	call	0xf0e	; 0xf0e <__mulsf3x>
     eec:	0c 94 35 07 	jmp	0xe6a	; 0xe6a <__fp_round>
     ef0:	0e 94 27 07 	call	0xe4e	; 0xe4e <__fp_pscA>
     ef4:	38 f0       	brcs	.+14     	; 0xf04 <__mulsf3+0x1c>
     ef6:	0e 94 2e 07 	call	0xe5c	; 0xe5c <__fp_pscB>
     efa:	20 f0       	brcs	.+8      	; 0xf04 <__mulsf3+0x1c>
     efc:	95 23       	and	r25, r21
     efe:	11 f0       	breq	.+4      	; 0xf04 <__mulsf3+0x1c>
     f00:	0c 94 1e 07 	jmp	0xe3c	; 0xe3c <__fp_inf>
     f04:	0c 94 24 07 	jmp	0xe48	; 0xe48 <__fp_nan>
     f08:	11 24       	eor	r1, r1
     f0a:	0c 94 69 07 	jmp	0xed2	; 0xed2 <__fp_szero>

00000f0e <__mulsf3x>:
     f0e:	0e 94 46 07 	call	0xe8c	; 0xe8c <__fp_split3>
     f12:	70 f3       	brcs	.-36     	; 0xef0 <__mulsf3+0x8>

00000f14 <__mulsf3_pse>:
     f14:	95 9f       	mul	r25, r21
     f16:	c1 f3       	breq	.-16     	; 0xf08 <__mulsf3+0x20>
     f18:	95 0f       	add	r25, r21
     f1a:	50 e0       	ldi	r21, 0x00	; 0
     f1c:	55 1f       	adc	r21, r21
     f1e:	62 9f       	mul	r22, r18
     f20:	f0 01       	movw	r30, r0
     f22:	72 9f       	mul	r23, r18
     f24:	bb 27       	eor	r27, r27
     f26:	f0 0d       	add	r31, r0
     f28:	b1 1d       	adc	r27, r1
     f2a:	63 9f       	mul	r22, r19
     f2c:	aa 27       	eor	r26, r26
     f2e:	f0 0d       	add	r31, r0
     f30:	b1 1d       	adc	r27, r1
     f32:	aa 1f       	adc	r26, r26
     f34:	64 9f       	mul	r22, r20
     f36:	66 27       	eor	r22, r22
     f38:	b0 0d       	add	r27, r0
     f3a:	a1 1d       	adc	r26, r1
     f3c:	66 1f       	adc	r22, r22
     f3e:	82 9f       	mul	r24, r18
     f40:	22 27       	eor	r18, r18
     f42:	b0 0d       	add	r27, r0
     f44:	a1 1d       	adc	r26, r1
     f46:	62 1f       	adc	r22, r18
     f48:	73 9f       	mul	r23, r19
     f4a:	b0 0d       	add	r27, r0
     f4c:	a1 1d       	adc	r26, r1
     f4e:	62 1f       	adc	r22, r18
     f50:	83 9f       	mul	r24, r19
     f52:	a0 0d       	add	r26, r0
     f54:	61 1d       	adc	r22, r1
     f56:	22 1f       	adc	r18, r18
     f58:	74 9f       	mul	r23, r20
     f5a:	33 27       	eor	r19, r19
     f5c:	a0 0d       	add	r26, r0
     f5e:	61 1d       	adc	r22, r1
     f60:	23 1f       	adc	r18, r19
     f62:	84 9f       	mul	r24, r20
     f64:	60 0d       	add	r22, r0
     f66:	21 1d       	adc	r18, r1
     f68:	82 2f       	mov	r24, r18
     f6a:	76 2f       	mov	r23, r22
     f6c:	6a 2f       	mov	r22, r26
     f6e:	11 24       	eor	r1, r1
     f70:	9f 57       	subi	r25, 0x7F	; 127
     f72:	50 40       	sbci	r21, 0x00	; 0
     f74:	9a f0       	brmi	.+38     	; 0xf9c <__mulsf3_pse+0x88>
     f76:	f1 f0       	breq	.+60     	; 0xfb4 <__mulsf3_pse+0xa0>
     f78:	88 23       	and	r24, r24
     f7a:	4a f0       	brmi	.+18     	; 0xf8e <__mulsf3_pse+0x7a>
     f7c:	ee 0f       	add	r30, r30
     f7e:	ff 1f       	adc	r31, r31
     f80:	bb 1f       	adc	r27, r27
     f82:	66 1f       	adc	r22, r22
     f84:	77 1f       	adc	r23, r23
     f86:	88 1f       	adc	r24, r24
     f88:	91 50       	subi	r25, 0x01	; 1
     f8a:	50 40       	sbci	r21, 0x00	; 0
     f8c:	a9 f7       	brne	.-22     	; 0xf78 <__mulsf3_pse+0x64>
     f8e:	9e 3f       	cpi	r25, 0xFE	; 254
     f90:	51 05       	cpc	r21, r1
     f92:	80 f0       	brcs	.+32     	; 0xfb4 <__mulsf3_pse+0xa0>
     f94:	0c 94 1e 07 	jmp	0xe3c	; 0xe3c <__fp_inf>
     f98:	0c 94 69 07 	jmp	0xed2	; 0xed2 <__fp_szero>
     f9c:	5f 3f       	cpi	r21, 0xFF	; 255
     f9e:	e4 f3       	brlt	.-8      	; 0xf98 <__mulsf3_pse+0x84>
     fa0:	98 3e       	cpi	r25, 0xE8	; 232
     fa2:	d4 f3       	brlt	.-12     	; 0xf98 <__mulsf3_pse+0x84>
     fa4:	86 95       	lsr	r24
     fa6:	77 95       	ror	r23
     fa8:	67 95       	ror	r22
     faa:	b7 95       	ror	r27
     fac:	f7 95       	ror	r31
     fae:	e7 95       	ror	r30
     fb0:	9f 5f       	subi	r25, 0xFF	; 255
     fb2:	c1 f7       	brne	.-16     	; 0xfa4 <__mulsf3_pse+0x90>
     fb4:	fe 2b       	or	r31, r30
     fb6:	88 0f       	add	r24, r24
     fb8:	91 1d       	adc	r25, r1
     fba:	96 95       	lsr	r25
     fbc:	87 95       	ror	r24
     fbe:	97 f9       	bld	r25, 7
     fc0:	08 95       	ret

00000fc2 <_ZN14HardwareSerial9availableEv>:
  // clear any received data
  _rx_buffer_head = _rx_buffer_tail;
}

int HardwareSerial::available(void)
{
     fc2:	fc 01       	movw	r30, r24
  return ((unsigned int)(SERIAL_RX_BUFFER_SIZE + _rx_buffer_head - _rx_buffer_tail)) % SERIAL_RX_BUFFER_SIZE;
     fc4:	91 8d       	ldd	r25, Z+25	; 0x19
     fc6:	22 8d       	ldd	r18, Z+26	; 0x1a
     fc8:	89 2f       	mov	r24, r25
     fca:	90 e0       	ldi	r25, 0x00	; 0
     fcc:	80 5c       	subi	r24, 0xC0	; 192
     fce:	9f 4f       	sbci	r25, 0xFF	; 255
     fd0:	82 1b       	sub	r24, r18
     fd2:	91 09       	sbc	r25, r1
}
     fd4:	8f 73       	andi	r24, 0x3F	; 63
     fd6:	99 27       	eor	r25, r25
     fd8:	08 95       	ret

00000fda <_ZN14HardwareSerial4peekEv>:

int HardwareSerial::peek(void)
{
     fda:	fc 01       	movw	r30, r24
  if (_rx_buffer_head == _rx_buffer_tail) {
     fdc:	91 8d       	ldd	r25, Z+25	; 0x19
     fde:	82 8d       	ldd	r24, Z+26	; 0x1a
     fe0:	98 17       	cp	r25, r24
     fe2:	31 f0       	breq	.+12     	; 0xff0 <_ZN14HardwareSerial4peekEv+0x16>
    return -1;
  } else {
    return _rx_buffer[_rx_buffer_tail];
     fe4:	82 8d       	ldd	r24, Z+26	; 0x1a
     fe6:	e8 0f       	add	r30, r24
     fe8:	f1 1d       	adc	r31, r1
     fea:	85 8d       	ldd	r24, Z+29	; 0x1d
     fec:	90 e0       	ldi	r25, 0x00	; 0
     fee:	08 95       	ret
}

int HardwareSerial::peek(void)
{
  if (_rx_buffer_head == _rx_buffer_tail) {
    return -1;
     ff0:	8f ef       	ldi	r24, 0xFF	; 255
     ff2:	9f ef       	ldi	r25, 0xFF	; 255
  } else {
    return _rx_buffer[_rx_buffer_tail];
  }
}
     ff4:	08 95       	ret

00000ff6 <_ZN14HardwareSerial4readEv>:

int HardwareSerial::read(void)
{
     ff6:	fc 01       	movw	r30, r24
  // if the head isn't ahead of the tail, we don't have any characters
  if (_rx_buffer_head == _rx_buffer_tail) {
     ff8:	91 8d       	ldd	r25, Z+25	; 0x19
     ffa:	82 8d       	ldd	r24, Z+26	; 0x1a
     ffc:	98 17       	cp	r25, r24
     ffe:	61 f0       	breq	.+24     	; 0x1018 <_ZN14HardwareSerial4readEv+0x22>
    return -1;
  } else {
    unsigned char c = _rx_buffer[_rx_buffer_tail];
    1000:	82 8d       	ldd	r24, Z+26	; 0x1a
    1002:	df 01       	movw	r26, r30
    1004:	a8 0f       	add	r26, r24
    1006:	b1 1d       	adc	r27, r1
    1008:	5d 96       	adiw	r26, 0x1d	; 29
    100a:	8c 91       	ld	r24, X
    _rx_buffer_tail = (rx_buffer_index_t)(_rx_buffer_tail + 1) % SERIAL_RX_BUFFER_SIZE;
    100c:	92 8d       	ldd	r25, Z+26	; 0x1a
    100e:	9f 5f       	subi	r25, 0xFF	; 255
    1010:	9f 73       	andi	r25, 0x3F	; 63
    1012:	92 8f       	std	Z+26, r25	; 0x1a
    return c;
    1014:	90 e0       	ldi	r25, 0x00	; 0
    1016:	08 95       	ret

int HardwareSerial::read(void)
{
  // if the head isn't ahead of the tail, we don't have any characters
  if (_rx_buffer_head == _rx_buffer_tail) {
    return -1;
    1018:	8f ef       	ldi	r24, 0xFF	; 255
    101a:	9f ef       	ldi	r25, 0xFF	; 255
  } else {
    unsigned char c = _rx_buffer[_rx_buffer_tail];
    _rx_buffer_tail = (rx_buffer_index_t)(_rx_buffer_tail + 1) % SERIAL_RX_BUFFER_SIZE;
    return c;
  }
}
    101c:	08 95       	ret

0000101e <_ZN14HardwareSerial17availableForWriteEv>:
{
  tx_buffer_index_t head;
  tx_buffer_index_t tail;

  TX_BUFFER_ATOMIC {
    head = _tx_buffer_head;
    101e:	fc 01       	movw	r30, r24
    1020:	53 8d       	ldd	r21, Z+27	; 0x1b
    tail = _tx_buffer_tail;
    1022:	44 8d       	ldd	r20, Z+28	; 0x1c
    1024:	25 2f       	mov	r18, r21
    1026:	30 e0       	ldi	r19, 0x00	; 0
    1028:	84 2f       	mov	r24, r20
    102a:	90 e0       	ldi	r25, 0x00	; 0
  }
  if (head >= tail) return SERIAL_TX_BUFFER_SIZE - 1 - head + tail;
    102c:	82 1b       	sub	r24, r18
    102e:	93 0b       	sbc	r25, r19
    1030:	54 17       	cp	r21, r20
    1032:	10 f0       	brcs	.+4      	; 0x1038 <_ZN14HardwareSerial17availableForWriteEv+0x1a>
    1034:	cf 96       	adiw	r24, 0x3f	; 63
    1036:	08 95       	ret
  return tail - head - 1;
    1038:	01 97       	sbiw	r24, 0x01	; 1
}
    103a:	08 95       	ret

0000103c <_Z14serialEventRunv>:
#endif

void serialEventRun(void)
{
#if defined(HAVE_HWSERIAL0)
  if (Serial0_available && serialEvent && Serial0_available()) serialEvent();
    103c:	8a e7       	ldi	r24, 0x7A	; 122
    103e:	99 e0       	ldi	r25, 0x09	; 9
    1040:	89 2b       	or	r24, r25
    1042:	49 f0       	breq	.+18     	; 0x1056 <_Z14serialEventRunv+0x1a>
    1044:	80 e0       	ldi	r24, 0x00	; 0
    1046:	90 e0       	ldi	r25, 0x00	; 0
    1048:	89 2b       	or	r24, r25
    104a:	29 f0       	breq	.+10     	; 0x1056 <_Z14serialEventRunv+0x1a>
    104c:	0e 94 7a 09 	call	0x12f4	; 0x12f4 <_Z17Serial0_availablev>
    1050:	81 11       	cpse	r24, r1
    1052:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>
    1056:	08 95       	ret

00001058 <_ZN14HardwareSerial17_tx_udr_empty_irqEv>:
#endif

// Actual interrupt handlers //////////////////////////////////////////////////////////////

void HardwareSerial::_tx_udr_empty_irq(void)
{
    1058:	fc 01       	movw	r30, r24
  // If interrupts are enabled, there must be more data in the output
  // buffer. Send the next byte
  unsigned char c = _tx_buffer[_tx_buffer_tail];
    105a:	84 8d       	ldd	r24, Z+28	; 0x1c
    105c:	df 01       	movw	r26, r30
    105e:	a8 0f       	add	r26, r24
    1060:	b1 1d       	adc	r27, r1
    1062:	a3 5a       	subi	r26, 0xA3	; 163
    1064:	bf 4f       	sbci	r27, 0xFF	; 255
    1066:	2c 91       	ld	r18, X
  _tx_buffer_tail = (_tx_buffer_tail + 1) % SERIAL_TX_BUFFER_SIZE;
    1068:	84 8d       	ldd	r24, Z+28	; 0x1c
    106a:	90 e0       	ldi	r25, 0x00	; 0
    106c:	01 96       	adiw	r24, 0x01	; 1
    106e:	8f 73       	andi	r24, 0x3F	; 63
    1070:	99 27       	eor	r25, r25
    1072:	84 8f       	std	Z+28, r24	; 0x1c

  *_udr = c;
    1074:	a6 89       	ldd	r26, Z+22	; 0x16
    1076:	b7 89       	ldd	r27, Z+23	; 0x17
    1078:	2c 93       	st	X, r18
  // location". This makes sure flush() won't return until the bytes
  // actually got written. Other r/w bits are preserved, and zeroes
  // written to the rest.

#ifdef MPCM0
  *_ucsra = ((*_ucsra) & ((1 << U2X0) | (1 << MPCM0))) | (1 << TXC0);
    107a:	a0 89       	ldd	r26, Z+16	; 0x10
    107c:	b1 89       	ldd	r27, Z+17	; 0x11
    107e:	8c 91       	ld	r24, X
    1080:	83 70       	andi	r24, 0x03	; 3
    1082:	80 64       	ori	r24, 0x40	; 64
    1084:	8c 93       	st	X, r24
#else
  *_ucsra = ((*_ucsra) & ((1 << U2X0) | (1 << TXC0)));
#endif

  if (_tx_buffer_head == _tx_buffer_tail) {
    1086:	93 8d       	ldd	r25, Z+27	; 0x1b
    1088:	84 8d       	ldd	r24, Z+28	; 0x1c
    108a:	98 13       	cpse	r25, r24
    108c:	06 c0       	rjmp	.+12     	; 0x109a <_ZN14HardwareSerial17_tx_udr_empty_irqEv+0x42>
    // Buffer empty, so disable interrupts
    cbi(*_ucsrb, UDRIE0);
    108e:	02 88       	ldd	r0, Z+18	; 0x12
    1090:	f3 89       	ldd	r31, Z+19	; 0x13
    1092:	e0 2d       	mov	r30, r0
    1094:	80 81       	ld	r24, Z
    1096:	8f 7d       	andi	r24, 0xDF	; 223
    1098:	80 83       	st	Z, r24
    109a:	08 95       	ret

0000109c <_ZN14HardwareSerial5writeEh>:
  // If we get here, nothing is queued anymore (DRIE is disabled) and
  // the hardware finished tranmission (TXC is set).
}

size_t HardwareSerial::write(uint8_t c)
{
    109c:	ef 92       	push	r14
    109e:	ff 92       	push	r15
    10a0:	0f 93       	push	r16
    10a2:	1f 93       	push	r17
    10a4:	cf 93       	push	r28
    10a6:	df 93       	push	r29
    10a8:	ec 01       	movw	r28, r24
  _written = true;
    10aa:	81 e0       	ldi	r24, 0x01	; 1
    10ac:	88 8f       	std	Y+24, r24	; 0x18
  // If the buffer and the data register is empty, just write the byte
  // to the data register and be done. This shortcut helps
  // significantly improve the effective datarate at high (>
  // 500kbit/s) bitrates, where interrupt overhead becomes a slowdown.
  if (_tx_buffer_head == _tx_buffer_tail && bit_is_set(*_ucsra, UDRE0)) {
    10ae:	9b 8d       	ldd	r25, Y+27	; 0x1b
    10b0:	8c 8d       	ldd	r24, Y+28	; 0x1c
    10b2:	98 13       	cpse	r25, r24
    10b4:	05 c0       	rjmp	.+10     	; 0x10c0 <_ZN14HardwareSerial5writeEh+0x24>
    10b6:	e8 89       	ldd	r30, Y+16	; 0x10
    10b8:	f9 89       	ldd	r31, Y+17	; 0x11
    10ba:	80 81       	ld	r24, Z
    10bc:	85 fd       	sbrc	r24, 5
    10be:	26 c0       	rjmp	.+76     	; 0x110c <_ZN14HardwareSerial5writeEh+0x70>
    10c0:	f6 2e       	mov	r15, r22
      *_ucsra = ((*_ucsra) & ((1 << U2X0) | (1 << TXC0)));
#endif
    }
    return 1;
  }
  tx_buffer_index_t i = (_tx_buffer_head + 1) % SERIAL_TX_BUFFER_SIZE;
    10c2:	0b 8d       	ldd	r16, Y+27	; 0x1b
    10c4:	10 e0       	ldi	r17, 0x00	; 0
    10c6:	0f 5f       	subi	r16, 0xFF	; 255
    10c8:	1f 4f       	sbci	r17, 0xFF	; 255
    10ca:	0f 73       	andi	r16, 0x3F	; 63
    10cc:	11 27       	eor	r17, r17
    10ce:	e0 2e       	mov	r14, r16
	
  // If the output buffer is full, there's nothing for it other than to 
  // wait for the interrupt handler to empty it a bit
  while (i == _tx_buffer_tail) {
    10d0:	8c 8d       	ldd	r24, Y+28	; 0x1c
    10d2:	e8 12       	cpse	r14, r24
    10d4:	0c c0       	rjmp	.+24     	; 0x10ee <_ZN14HardwareSerial5writeEh+0x52>
    if (bit_is_clear(SREG, SREG_I)) {
    10d6:	0f b6       	in	r0, 0x3f	; 63
    10d8:	07 fc       	sbrc	r0, 7
    10da:	fa cf       	rjmp	.-12     	; 0x10d0 <_ZN14HardwareSerial5writeEh+0x34>
      // Interrupts are disabled, so we'll have to poll the data
      // register empty flag ourselves. If it is set, pretend an
      // interrupt has happened and call the handler to free up
      // space for us.
      if(bit_is_set(*_ucsra, UDRE0))
    10dc:	e8 89       	ldd	r30, Y+16	; 0x10
    10de:	f9 89       	ldd	r31, Y+17	; 0x11
    10e0:	80 81       	ld	r24, Z
    10e2:	85 ff       	sbrs	r24, 5
    10e4:	f5 cf       	rjmp	.-22     	; 0x10d0 <_ZN14HardwareSerial5writeEh+0x34>
	_tx_udr_empty_irq();
    10e6:	ce 01       	movw	r24, r28
    10e8:	0e 94 2c 08 	call	0x1058	; 0x1058 <_ZN14HardwareSerial17_tx_udr_empty_irqEv>
    10ec:	f1 cf       	rjmp	.-30     	; 0x10d0 <_ZN14HardwareSerial5writeEh+0x34>
    } else {
      // nop, the interrupt handler will free up space for us
    }
  }

  _tx_buffer[_tx_buffer_head] = c;
    10ee:	8b 8d       	ldd	r24, Y+27	; 0x1b
    10f0:	fe 01       	movw	r30, r28
    10f2:	e8 0f       	add	r30, r24
    10f4:	f1 1d       	adc	r31, r1
    10f6:	e3 5a       	subi	r30, 0xA3	; 163
    10f8:	ff 4f       	sbci	r31, 0xFF	; 255
    10fa:	f0 82       	st	Z, r15

  // make atomic to prevent execution of ISR between setting the
  // head pointer and setting the interrupt flag resulting in buffer
  // retransmission
  ATOMIC_BLOCK(ATOMIC_RESTORESTATE) {
    10fc:	9f b7       	in	r25, 0x3f	; 63
    return 1;
}

static __inline__ uint8_t __iCliRetVal(void)
{
    cli();
    10fe:	f8 94       	cli
    _tx_buffer_head = i;
    1100:	0b 8f       	std	Y+27, r16	; 0x1b
    sbi(*_ucsrb, UDRIE0);
    1102:	ea 89       	ldd	r30, Y+18	; 0x12
    1104:	fb 89       	ldd	r31, Y+19	; 0x13
    1106:	80 81       	ld	r24, Z
    1108:	80 62       	ori	r24, 0x20	; 32
    110a:	0a c0       	rjmp	.+20     	; 0x1120 <_ZN14HardwareSerial5writeEh+0x84>
    // So writing UDR must happen first.
    // Writing UDR and clearing TC must be done atomically, otherwise
    // interrupts might delay the TXC clear so the byte written to UDR
    // is transmitted (setting TXC) before clearing TXC. Then TXC will
    // be cleared when no bytes are left, causing flush() to hang
    ATOMIC_BLOCK(ATOMIC_RESTORESTATE) {
    110c:	9f b7       	in	r25, 0x3f	; 63
    110e:	f8 94       	cli
      *_udr = c;
    1110:	ee 89       	ldd	r30, Y+22	; 0x16
    1112:	ff 89       	ldd	r31, Y+23	; 0x17
    1114:	60 83       	st	Z, r22
#ifdef MPCM0
      *_ucsra = ((*_ucsra) & ((1 << U2X0) | (1 << MPCM0))) | (1 << TXC0);
    1116:	e8 89       	ldd	r30, Y+16	; 0x10
    1118:	f9 89       	ldd	r31, Y+17	; 0x11
    111a:	80 81       	ld	r24, Z
    111c:	83 70       	andi	r24, 0x03	; 3
    111e:	80 64       	ori	r24, 0x40	; 64
    1120:	80 83       	st	Z, r24
    (void)__s;
}

static __inline__ void __iRestore(const  uint8_t *__s)
{
    SREG = *__s;
    1122:	9f bf       	out	0x3f, r25	; 63
    _tx_buffer_head = i;
    sbi(*_ucsrb, UDRIE0);
  }
  
  return 1;
}
    1124:	81 e0       	ldi	r24, 0x01	; 1
    1126:	90 e0       	ldi	r25, 0x00	; 0
    1128:	df 91       	pop	r29
    112a:	cf 91       	pop	r28
    112c:	1f 91       	pop	r17
    112e:	0f 91       	pop	r16
    1130:	ff 90       	pop	r15
    1132:	ef 90       	pop	r14
    1134:	08 95       	ret

00001136 <_ZN14HardwareSerial5flushEv>:
  if (head >= tail) return SERIAL_TX_BUFFER_SIZE - 1 - head + tail;
  return tail - head - 1;
}

void HardwareSerial::flush()
{
    1136:	cf 93       	push	r28
    1138:	df 93       	push	r29
    113a:	ec 01       	movw	r28, r24
  // If we have never written a byte, no need to flush. This special
  // case is needed since there is no way to force the TXC (transmit
  // complete) bit to 1 during initialization
  if (!_written)
    113c:	88 8d       	ldd	r24, Y+24	; 0x18
    113e:	88 23       	and	r24, r24
    1140:	c9 f0       	breq	.+50     	; 0x1174 <_ZN14HardwareSerial5flushEv+0x3e>
    return;

  while (bit_is_set(*_ucsrb, UDRIE0) || bit_is_clear(*_ucsra, TXC0)) {
    1142:	ea 89       	ldd	r30, Y+18	; 0x12
    1144:	fb 89       	ldd	r31, Y+19	; 0x13
    1146:	80 81       	ld	r24, Z
    1148:	85 fd       	sbrc	r24, 5
    114a:	05 c0       	rjmp	.+10     	; 0x1156 <_ZN14HardwareSerial5flushEv+0x20>
    114c:	a8 89       	ldd	r26, Y+16	; 0x10
    114e:	b9 89       	ldd	r27, Y+17	; 0x11
    1150:	8c 91       	ld	r24, X
    1152:	86 fd       	sbrc	r24, 6
    1154:	0f c0       	rjmp	.+30     	; 0x1174 <_ZN14HardwareSerial5flushEv+0x3e>
    if (bit_is_clear(SREG, SREG_I) && bit_is_set(*_ucsrb, UDRIE0))
    1156:	0f b6       	in	r0, 0x3f	; 63
    1158:	07 fc       	sbrc	r0, 7
    115a:	f5 cf       	rjmp	.-22     	; 0x1146 <_ZN14HardwareSerial5flushEv+0x10>
    115c:	80 81       	ld	r24, Z
    115e:	85 ff       	sbrs	r24, 5
    1160:	f2 cf       	rjmp	.-28     	; 0x1146 <_ZN14HardwareSerial5flushEv+0x10>
	// Interrupts are globally disabled, but the DR empty
	// interrupt should be enabled, so poll the DR empty flag to
	// prevent deadlock
	if (bit_is_set(*_ucsra, UDRE0))
    1162:	a8 89       	ldd	r26, Y+16	; 0x10
    1164:	b9 89       	ldd	r27, Y+17	; 0x11
    1166:	8c 91       	ld	r24, X
    1168:	85 ff       	sbrs	r24, 5
    116a:	ed cf       	rjmp	.-38     	; 0x1146 <_ZN14HardwareSerial5flushEv+0x10>
	  _tx_udr_empty_irq();
    116c:	ce 01       	movw	r24, r28
    116e:	0e 94 2c 08 	call	0x1058	; 0x1058 <_ZN14HardwareSerial17_tx_udr_empty_irqEv>
    1172:	e7 cf       	rjmp	.-50     	; 0x1142 <_ZN14HardwareSerial5flushEv+0xc>
  }
  // If we get here, nothing is queued anymore (DRIE is disabled) and
  // the hardware finished tranmission (TXC is set).
}
    1174:	df 91       	pop	r29
    1176:	cf 91       	pop	r28
    1178:	08 95       	ret

0000117a <_ZN14HardwareSerial5beginEmh>:
}

// Public Methods //////////////////////////////////////////////////////////////

void HardwareSerial::begin(unsigned long baud, byte config)
{
    117a:	cf 92       	push	r12
    117c:	df 92       	push	r13
    117e:	ef 92       	push	r14
    1180:	ff 92       	push	r15
    1182:	1f 93       	push	r17
    1184:	cf 93       	push	r28
    1186:	df 93       	push	r29
    1188:	ec 01       	movw	r28, r24
    118a:	6a 01       	movw	r12, r20
    118c:	7b 01       	movw	r14, r22
    118e:	12 2f       	mov	r17, r18
  // Try u2x mode first
  uint16_t baud_setting = (F_CPU / 4 / baud - 1) / 2;
  *_ucsra = 1 << U2X0;
    1190:	e8 89       	ldd	r30, Y+16	; 0x10
    1192:	f9 89       	ldd	r31, Y+17	; 0x11
    1194:	82 e0       	ldi	r24, 0x02	; 2
    1196:	80 83       	st	Z, r24
  // hardcoded exception for 57600 for compatibility with the bootloader
  // shipped with the Duemilanove and previous boards and the firmware
  // on the 8U2 on the Uno and Mega 2560. Also, The baud_setting cannot
  // be > 4095, so switch back to non-u2x mode if the baud rate is too
  // low.
  if (((F_CPU == 16000000UL) && (baud == 57600)) || (baud_setting >4095))
    1198:	41 15       	cp	r20, r1
    119a:	51 4e       	sbci	r21, 0xE1	; 225
    119c:	61 05       	cpc	r22, r1
    119e:	71 05       	cpc	r23, r1
    11a0:	b1 f0       	breq	.+44     	; 0x11ce <_ZN14HardwareSerial5beginEmh+0x54>
// Public Methods //////////////////////////////////////////////////////////////

void HardwareSerial::begin(unsigned long baud, byte config)
{
  // Try u2x mode first
  uint16_t baud_setting = (F_CPU / 4 / baud - 1) / 2;
    11a2:	60 e0       	ldi	r22, 0x00	; 0
    11a4:	79 e0       	ldi	r23, 0x09	; 9
    11a6:	8d e3       	ldi	r24, 0x3D	; 61
    11a8:	90 e0       	ldi	r25, 0x00	; 0
    11aa:	a7 01       	movw	r20, r14
    11ac:	96 01       	movw	r18, r12
    11ae:	0e 94 e9 1d 	call	0x3bd2	; 0x3bd2 <__udivmodsi4>
    11b2:	da 01       	movw	r26, r20
    11b4:	c9 01       	movw	r24, r18
    11b6:	01 97       	sbiw	r24, 0x01	; 1
    11b8:	a1 09       	sbc	r26, r1
    11ba:	b1 09       	sbc	r27, r1
    11bc:	b6 95       	lsr	r27
    11be:	a7 95       	ror	r26
    11c0:	97 95       	ror	r25
    11c2:	87 95       	ror	r24
    11c4:	9c 01       	movw	r18, r24
  // hardcoded exception for 57600 for compatibility with the bootloader
  // shipped with the Duemilanove and previous boards and the firmware
  // on the 8U2 on the Uno and Mega 2560. Also, The baud_setting cannot
  // be > 4095, so switch back to non-u2x mode if the baud rate is too
  // low.
  if (((F_CPU == 16000000UL) && (baud == 57600)) || (baud_setting >4095))
    11c6:	21 15       	cp	r18, r1
    11c8:	80 e1       	ldi	r24, 0x10	; 16
    11ca:	38 07       	cpc	r19, r24
    11cc:	a8 f0       	brcs	.+42     	; 0x11f8 <_ZN14HardwareSerial5beginEmh+0x7e>
  {
    *_ucsra = 0;
    11ce:	e8 89       	ldd	r30, Y+16	; 0x10
    11d0:	f9 89       	ldd	r31, Y+17	; 0x11
    11d2:	10 82       	st	Z, r1
    baud_setting = (F_CPU / 8 / baud - 1) / 2;
    11d4:	60 e8       	ldi	r22, 0x80	; 128
    11d6:	74 e8       	ldi	r23, 0x84	; 132
    11d8:	8e e1       	ldi	r24, 0x1E	; 30
    11da:	90 e0       	ldi	r25, 0x00	; 0
    11dc:	a7 01       	movw	r20, r14
    11de:	96 01       	movw	r18, r12
    11e0:	0e 94 e9 1d 	call	0x3bd2	; 0x3bd2 <__udivmodsi4>
    11e4:	da 01       	movw	r26, r20
    11e6:	c9 01       	movw	r24, r18
    11e8:	01 97       	sbiw	r24, 0x01	; 1
    11ea:	a1 09       	sbc	r26, r1
    11ec:	b1 09       	sbc	r27, r1
    11ee:	b6 95       	lsr	r27
    11f0:	a7 95       	ror	r26
    11f2:	97 95       	ror	r25
    11f4:	87 95       	ror	r24
    11f6:	9c 01       	movw	r18, r24
  }

  // assign the baud_setting, a.k.a. ubrr (USART Baud Rate Register)
  *_ubrrh = baud_setting >> 8;
    11f8:	ec 85       	ldd	r30, Y+12	; 0x0c
    11fa:	fd 85       	ldd	r31, Y+13	; 0x0d
    11fc:	30 83       	st	Z, r19
  *_ubrrl = baud_setting;
    11fe:	ee 85       	ldd	r30, Y+14	; 0x0e
    1200:	ff 85       	ldd	r31, Y+15	; 0x0f
    1202:	20 83       	st	Z, r18

  _written = false;
    1204:	18 8e       	std	Y+24, r1	; 0x18

  //set the data bits, parity, and stop bits
#if defined(__AVR_ATmega8__)
  config |= 0x80; // select UCSRC register (shared with UBRRH)
#endif
  *_ucsrc = config;
    1206:	ec 89       	ldd	r30, Y+20	; 0x14
    1208:	fd 89       	ldd	r31, Y+21	; 0x15
    120a:	10 83       	st	Z, r17
  
  sbi(*_ucsrb, RXEN0);
    120c:	ea 89       	ldd	r30, Y+18	; 0x12
    120e:	fb 89       	ldd	r31, Y+19	; 0x13
    1210:	80 81       	ld	r24, Z
    1212:	80 61       	ori	r24, 0x10	; 16
    1214:	80 83       	st	Z, r24
  sbi(*_ucsrb, TXEN0);
    1216:	ea 89       	ldd	r30, Y+18	; 0x12
    1218:	fb 89       	ldd	r31, Y+19	; 0x13
    121a:	80 81       	ld	r24, Z
    121c:	88 60       	ori	r24, 0x08	; 8
    121e:	80 83       	st	Z, r24
  sbi(*_ucsrb, RXCIE0);
    1220:	ea 89       	ldd	r30, Y+18	; 0x12
    1222:	fb 89       	ldd	r31, Y+19	; 0x13
    1224:	80 81       	ld	r24, Z
    1226:	80 68       	ori	r24, 0x80	; 128
    1228:	80 83       	st	Z, r24
  cbi(*_ucsrb, UDRIE0);
    122a:	ea 89       	ldd	r30, Y+18	; 0x12
    122c:	fb 89       	ldd	r31, Y+19	; 0x13
    122e:	80 81       	ld	r24, Z
    1230:	8f 7d       	andi	r24, 0xDF	; 223
    1232:	80 83       	st	Z, r24
}
    1234:	df 91       	pop	r29
    1236:	cf 91       	pop	r28
    1238:	1f 91       	pop	r17
    123a:	ff 90       	pop	r15
    123c:	ef 90       	pop	r14
    123e:	df 90       	pop	r13
    1240:	cf 90       	pop	r12
    1242:	08 95       	ret

00001244 <__vector_18>:
#elif defined(USART_RXC_vect)
  ISR(USART_RXC_vect) // ATmega8
#else
  #error "Don't know what the Data Received vector is called for Serial"
#endif
  {
    1244:	1f 92       	push	r1
    1246:	0f 92       	push	r0
    1248:	0f b6       	in	r0, 0x3f	; 63
    124a:	0f 92       	push	r0
    124c:	11 24       	eor	r1, r1
    124e:	2f 93       	push	r18
    1250:	8f 93       	push	r24
    1252:	9f 93       	push	r25
    1254:	ef 93       	push	r30
    1256:	ff 93       	push	r31

// Actual interrupt handlers //////////////////////////////////////////////////////////////

void HardwareSerial::_rx_complete_irq(void)
{
  if (bit_is_clear(*_ucsra, UPE0)) {
    1258:	e0 91 bd 02 	lds	r30, 0x02BD	; 0x8002bd <Serial+0x10>
    125c:	f0 91 be 02 	lds	r31, 0x02BE	; 0x8002be <Serial+0x11>
    1260:	80 81       	ld	r24, Z
    1262:	e0 91 c3 02 	lds	r30, 0x02C3	; 0x8002c3 <Serial+0x16>
    1266:	f0 91 c4 02 	lds	r31, 0x02C4	; 0x8002c4 <Serial+0x17>
    126a:	82 fd       	sbrc	r24, 2
    126c:	12 c0       	rjmp	.+36     	; 0x1292 <__vector_18+0x4e>
    // No Parity error, read byte and store it in the buffer if there is
    // room
    unsigned char c = *_udr;
    126e:	90 81       	ld	r25, Z
    rx_buffer_index_t i = (unsigned int)(_rx_buffer_head + 1) % SERIAL_RX_BUFFER_SIZE;
    1270:	80 91 c6 02 	lds	r24, 0x02C6	; 0x8002c6 <Serial+0x19>
    1274:	8f 5f       	subi	r24, 0xFF	; 255
    1276:	8f 73       	andi	r24, 0x3F	; 63

    // if we should be storing the received character into the location
    // just before the tail (meaning that the head would advance to the
    // current location of the tail), we're about to overflow the buffer
    // and so we don't write the character or advance the head.
    if (i != _rx_buffer_tail) {
    1278:	20 91 c7 02 	lds	r18, 0x02C7	; 0x8002c7 <Serial+0x1a>
    127c:	82 17       	cp	r24, r18
    127e:	51 f0       	breq	.+20     	; 0x1294 <__vector_18+0x50>
      _rx_buffer[_rx_buffer_head] = c;
    1280:	e0 91 c6 02 	lds	r30, 0x02C6	; 0x8002c6 <Serial+0x19>
    1284:	f0 e0       	ldi	r31, 0x00	; 0
    1286:	e3 55       	subi	r30, 0x53	; 83
    1288:	fd 4f       	sbci	r31, 0xFD	; 253
    128a:	95 8f       	std	Z+29, r25	; 0x1d
      _rx_buffer_head = i;
    128c:	80 93 c6 02 	sts	0x02C6, r24	; 0x8002c6 <Serial+0x19>
    1290:	01 c0       	rjmp	.+2      	; 0x1294 <__vector_18+0x50>
    }
  } else {
    // Parity error, read byte but discard it
    *_udr;
    1292:	80 81       	ld	r24, Z
    Serial._rx_complete_irq();
  }
    1294:	ff 91       	pop	r31
    1296:	ef 91       	pop	r30
    1298:	9f 91       	pop	r25
    129a:	8f 91       	pop	r24
    129c:	2f 91       	pop	r18
    129e:	0f 90       	pop	r0
    12a0:	0f be       	out	0x3f, r0	; 63
    12a2:	0f 90       	pop	r0
    12a4:	1f 90       	pop	r1
    12a6:	18 95       	reti

000012a8 <__vector_19>:
#elif defined(USART_UDRE_vect)
ISR(USART_UDRE_vect)
#else
  #error "Don't know what the Data Register Empty vector is called for Serial"
#endif
{
    12a8:	1f 92       	push	r1
    12aa:	0f 92       	push	r0
    12ac:	0f b6       	in	r0, 0x3f	; 63
    12ae:	0f 92       	push	r0
    12b0:	11 24       	eor	r1, r1
    12b2:	2f 93       	push	r18
    12b4:	3f 93       	push	r19
    12b6:	4f 93       	push	r20
    12b8:	5f 93       	push	r21
    12ba:	6f 93       	push	r22
    12bc:	7f 93       	push	r23
    12be:	8f 93       	push	r24
    12c0:	9f 93       	push	r25
    12c2:	af 93       	push	r26
    12c4:	bf 93       	push	r27
    12c6:	ef 93       	push	r30
    12c8:	ff 93       	push	r31
  Serial._tx_udr_empty_irq();
    12ca:	8d ea       	ldi	r24, 0xAD	; 173
    12cc:	92 e0       	ldi	r25, 0x02	; 2
    12ce:	0e 94 2c 08 	call	0x1058	; 0x1058 <_ZN14HardwareSerial17_tx_udr_empty_irqEv>
}
    12d2:	ff 91       	pop	r31
    12d4:	ef 91       	pop	r30
    12d6:	bf 91       	pop	r27
    12d8:	af 91       	pop	r26
    12da:	9f 91       	pop	r25
    12dc:	8f 91       	pop	r24
    12de:	7f 91       	pop	r23
    12e0:	6f 91       	pop	r22
    12e2:	5f 91       	pop	r21
    12e4:	4f 91       	pop	r20
    12e6:	3f 91       	pop	r19
    12e8:	2f 91       	pop	r18
    12ea:	0f 90       	pop	r0
    12ec:	0f be       	out	0x3f, r0	; 63
    12ee:	0f 90       	pop	r0
    12f0:	1f 90       	pop	r1
    12f2:	18 95       	reti

000012f4 <_Z17Serial0_availablev>:
#endif

// Function that can be weakly referenced by serialEventRun to prevent
// pulling in this file if it's not otherwise used.
bool Serial0_available() {
  return Serial.available();
    12f4:	8d ea       	ldi	r24, 0xAD	; 173
    12f6:	92 e0       	ldi	r25, 0x02	; 2
    12f8:	0e 94 e1 07 	call	0xfc2	; 0xfc2 <_ZN14HardwareSerial9availableEv>
    12fc:	21 e0       	ldi	r18, 0x01	; 1
    12fe:	89 2b       	or	r24, r25
    1300:	09 f4       	brne	.+2      	; 0x1304 <_Z17Serial0_availablev+0x10>
    1302:	20 e0       	ldi	r18, 0x00	; 0
}
    1304:	82 2f       	mov	r24, r18
    1306:	08 95       	ret

00001308 <_GLOBAL__sub_I___vector_18>:
    size_t printNumber(unsigned long, uint8_t);
    size_t printFloat(double, uint8_t);
  protected:
    void setWriteError(int err = 1) { write_error = err; }
  public:
    Print() : write_error(0) {}
    1308:	ed ea       	ldi	r30, 0xAD	; 173
    130a:	f2 e0       	ldi	r31, 0x02	; 2
    130c:	13 82       	std	Z+3, r1	; 0x03
    130e:	12 82       	std	Z+2, r1	; 0x02
  public:
    virtual int available() = 0;
    virtual int read() = 0;
    virtual int peek() = 0;

    Stream() {_timeout=1000;}
    1310:	88 ee       	ldi	r24, 0xE8	; 232
    1312:	93 e0       	ldi	r25, 0x03	; 3
    1314:	a0 e0       	ldi	r26, 0x00	; 0
    1316:	b0 e0       	ldi	r27, 0x00	; 0
    1318:	84 83       	std	Z+4, r24	; 0x04
    131a:	95 83       	std	Z+5, r25	; 0x05
    131c:	a6 83       	std	Z+6, r26	; 0x06
    131e:	b7 83       	std	Z+7, r27	; 0x07
  volatile uint8_t *ucsrc, volatile uint8_t *udr) :
    _ubrrh(ubrrh), _ubrrl(ubrrl),
    _ucsra(ucsra), _ucsrb(ucsrb), _ucsrc(ucsrc),
    _udr(udr),
    _rx_buffer_head(0), _rx_buffer_tail(0),
    _tx_buffer_head(0), _tx_buffer_tail(0)
    1320:	80 e8       	ldi	r24, 0x80	; 128
    1322:	91 e0       	ldi	r25, 0x01	; 1
    1324:	91 83       	std	Z+1, r25	; 0x01
    1326:	80 83       	st	Z, r24
    1328:	85 ec       	ldi	r24, 0xC5	; 197
    132a:	90 e0       	ldi	r25, 0x00	; 0
    132c:	95 87       	std	Z+13, r25	; 0x0d
    132e:	84 87       	std	Z+12, r24	; 0x0c
    1330:	84 ec       	ldi	r24, 0xC4	; 196
    1332:	90 e0       	ldi	r25, 0x00	; 0
    1334:	97 87       	std	Z+15, r25	; 0x0f
    1336:	86 87       	std	Z+14, r24	; 0x0e
    1338:	80 ec       	ldi	r24, 0xC0	; 192
    133a:	90 e0       	ldi	r25, 0x00	; 0
    133c:	91 8b       	std	Z+17, r25	; 0x11
    133e:	80 8b       	std	Z+16, r24	; 0x10
    1340:	81 ec       	ldi	r24, 0xC1	; 193
    1342:	90 e0       	ldi	r25, 0x00	; 0
    1344:	93 8b       	std	Z+19, r25	; 0x13
    1346:	82 8b       	std	Z+18, r24	; 0x12
    1348:	82 ec       	ldi	r24, 0xC2	; 194
    134a:	90 e0       	ldi	r25, 0x00	; 0
    134c:	95 8b       	std	Z+21, r25	; 0x15
    134e:	84 8b       	std	Z+20, r24	; 0x14
    1350:	86 ec       	ldi	r24, 0xC6	; 198
    1352:	90 e0       	ldi	r25, 0x00	; 0
    1354:	97 8b       	std	Z+23, r25	; 0x17
    1356:	86 8b       	std	Z+22, r24	; 0x16
    1358:	11 8e       	std	Z+25, r1	; 0x19
    135a:	12 8e       	std	Z+26, r1	; 0x1a
    135c:	13 8e       	std	Z+27, r1	; 0x1b
    135e:	14 8e       	std	Z+28, r1	; 0x1c
    1360:	08 95       	ret

00001362 <main>:
void setupUSB() __attribute__((weak));
void setupUSB() { }

int main(void)
{
	init();
    1362:	0e 94 32 0c 	call	0x1864	; 0x1864 <init>

	initVariant();
    1366:	0e 94 d8 18 	call	0x31b0	; 0x31b0 <initVariant>

#if defined(USBCON)
	USBDevice.attach();
#endif
	
	setup();
    136a:	0e 94 63 05 	call	0xac6	; 0xac6 <setup>
    
	for (;;) {
		loop();
		if (serialEventRun) serialEventRun();
    136e:	ce e1       	ldi	r28, 0x1E	; 30
    1370:	d8 e0       	ldi	r29, 0x08	; 8
#endif
	
	setup();
    
	for (;;) {
		loop();
    1372:	0e 94 c5 05 	call	0xb8a	; 0xb8a <loop>
		if (serialEventRun) serialEventRun();
    1376:	20 97       	sbiw	r28, 0x00	; 0
    1378:	e1 f3       	breq	.-8      	; 0x1372 <main+0x10>
    137a:	0e 94 1e 08 	call	0x103c	; 0x103c <_Z14serialEventRunv>
    137e:	f9 cf       	rjmp	.-14     	; 0x1372 <main+0x10>

00001380 <_ZN5Print5writeEPKhj>:
  else return printNumber(n, base);
}

size_t Print::print(double n, int digits)
{
  return printFloat(n, digits);
    1380:	cf 92       	push	r12
    1382:	df 92       	push	r13
    1384:	ef 92       	push	r14
    1386:	ff 92       	push	r15
    1388:	0f 93       	push	r16
    138a:	1f 93       	push	r17
    138c:	cf 93       	push	r28
    138e:	df 93       	push	r29
    1390:	6c 01       	movw	r12, r24
    1392:	7a 01       	movw	r14, r20
    1394:	8b 01       	movw	r16, r22
    1396:	c0 e0       	ldi	r28, 0x00	; 0
    1398:	d0 e0       	ldi	r29, 0x00	; 0
    139a:	ce 15       	cp	r28, r14
    139c:	df 05       	cpc	r29, r15
    139e:	81 f0       	breq	.+32     	; 0x13c0 <_ZN5Print5writeEPKhj+0x40>
    13a0:	d8 01       	movw	r26, r16
    13a2:	6d 91       	ld	r22, X+
    13a4:	8d 01       	movw	r16, r26
    13a6:	d6 01       	movw	r26, r12
    13a8:	ed 91       	ld	r30, X+
    13aa:	fc 91       	ld	r31, X
    13ac:	01 90       	ld	r0, Z+
    13ae:	f0 81       	ld	r31, Z
    13b0:	e0 2d       	mov	r30, r0
    13b2:	c6 01       	movw	r24, r12
    13b4:	09 95       	icall
    13b6:	89 2b       	or	r24, r25
    13b8:	11 f0       	breq	.+4      	; 0x13be <_ZN5Print5writeEPKhj+0x3e>
    13ba:	21 96       	adiw	r28, 0x01	; 1
    13bc:	ee cf       	rjmp	.-36     	; 0x139a <_ZN5Print5writeEPKhj+0x1a>
    13be:	7e 01       	movw	r14, r28
    13c0:	c7 01       	movw	r24, r14
    13c2:	df 91       	pop	r29
    13c4:	cf 91       	pop	r28
    13c6:	1f 91       	pop	r17
    13c8:	0f 91       	pop	r16
    13ca:	ff 90       	pop	r15
    13cc:	ef 90       	pop	r14
    13ce:	df 90       	pop	r13
    13d0:	cf 90       	pop	r12
    13d2:	08 95       	ret

000013d4 <_ZN5Print5writeEPKc>:
    13d4:	61 15       	cp	r22, r1
    13d6:	71 05       	cpc	r23, r1
    13d8:	79 f0       	breq	.+30     	; 0x13f8 <_ZN5Print5writeEPKc+0x24>
    13da:	fb 01       	movw	r30, r22
    13dc:	01 90       	ld	r0, Z+
    13de:	00 20       	and	r0, r0
    13e0:	e9 f7       	brne	.-6      	; 0x13dc <_ZN5Print5writeEPKc+0x8>
    13e2:	31 97       	sbiw	r30, 0x01	; 1
    13e4:	af 01       	movw	r20, r30
    13e6:	46 1b       	sub	r20, r22
    13e8:	57 0b       	sbc	r21, r23
    13ea:	dc 01       	movw	r26, r24
    13ec:	ed 91       	ld	r30, X+
    13ee:	fc 91       	ld	r31, X
    13f0:	02 80       	ldd	r0, Z+2	; 0x02
    13f2:	f3 81       	ldd	r31, Z+3	; 0x03
    13f4:	e0 2d       	mov	r30, r0
    13f6:	09 94       	ijmp
    13f8:	80 e0       	ldi	r24, 0x00	; 0
    13fa:	90 e0       	ldi	r25, 0x00	; 0
    13fc:	08 95       	ret

000013fe <_ZN5Print5printEPK19__FlashStringHelper>:
    13fe:	ef 92       	push	r14
    1400:	ff 92       	push	r15
    1402:	0f 93       	push	r16
    1404:	1f 93       	push	r17
    1406:	cf 93       	push	r28
    1408:	df 93       	push	r29
    140a:	8c 01       	movw	r16, r24
    140c:	7b 01       	movw	r14, r22
    140e:	c0 e0       	ldi	r28, 0x00	; 0
    1410:	d0 e0       	ldi	r29, 0x00	; 0
    1412:	f7 01       	movw	r30, r14
    1414:	ec 0f       	add	r30, r28
    1416:	fd 1f       	adc	r31, r29
    1418:	64 91       	lpm	r22, Z
    141a:	66 23       	and	r22, r22
    141c:	61 f0       	breq	.+24     	; 0x1436 <_ZN5Print5printEPK19__FlashStringHelper+0x38>
    141e:	d8 01       	movw	r26, r16
    1420:	ed 91       	ld	r30, X+
    1422:	fc 91       	ld	r31, X
    1424:	01 90       	ld	r0, Z+
    1426:	f0 81       	ld	r31, Z
    1428:	e0 2d       	mov	r30, r0
    142a:	c8 01       	movw	r24, r16
    142c:	09 95       	icall
    142e:	89 2b       	or	r24, r25
    1430:	11 f0       	breq	.+4      	; 0x1436 <_ZN5Print5printEPK19__FlashStringHelper+0x38>
    1432:	21 96       	adiw	r28, 0x01	; 1
    1434:	ee cf       	rjmp	.-36     	; 0x1412 <_ZN5Print5printEPK19__FlashStringHelper+0x14>
    1436:	ce 01       	movw	r24, r28
    1438:	df 91       	pop	r29
    143a:	cf 91       	pop	r28
    143c:	1f 91       	pop	r17
    143e:	0f 91       	pop	r16
    1440:	ff 90       	pop	r15
    1442:	ef 90       	pop	r14
    1444:	08 95       	ret

00001446 <_ZN5Print5printEPKc>:
    1446:	0c 94 ea 09 	jmp	0x13d4	; 0x13d4 <_ZN5Print5writeEPKc>

0000144a <_ZN5Print5printEc>:
    144a:	dc 01       	movw	r26, r24
    144c:	ed 91       	ld	r30, X+
    144e:	fc 91       	ld	r31, X
    1450:	01 90       	ld	r0, Z+
    1452:	f0 81       	ld	r31, Z
    1454:	e0 2d       	mov	r30, r0
    1456:	09 94       	ijmp

00001458 <_ZN5Print7printlnEv>:
    1458:	6e e8       	ldi	r22, 0x8E	; 142
    145a:	71 e0       	ldi	r23, 0x01	; 1
    145c:	0c 94 ea 09 	jmp	0x13d4	; 0x13d4 <_ZN5Print5writeEPKc>

00001460 <_ZN5Print11printNumberEmh>:
    1460:	8f 92       	push	r8
    1462:	9f 92       	push	r9
    1464:	af 92       	push	r10
    1466:	bf 92       	push	r11
    1468:	ef 92       	push	r14
    146a:	ff 92       	push	r15
    146c:	0f 93       	push	r16
    146e:	1f 93       	push	r17
    1470:	cf 93       	push	r28
    1472:	df 93       	push	r29
    1474:	cd b7       	in	r28, 0x3d	; 61
    1476:	de b7       	in	r29, 0x3e	; 62
    1478:	a1 97       	sbiw	r28, 0x21	; 33
    147a:	0f b6       	in	r0, 0x3f	; 63
    147c:	f8 94       	cli
    147e:	de bf       	out	0x3e, r29	; 62
    1480:	0f be       	out	0x3f, r0	; 63
    1482:	cd bf       	out	0x3d, r28	; 61
    1484:	7c 01       	movw	r14, r24
    1486:	fa 01       	movw	r30, r20
    1488:	cb 01       	movw	r24, r22
    148a:	19 a2       	std	Y+33, r1	; 0x21
    148c:	22 30       	cpi	r18, 0x02	; 2
    148e:	08 f4       	brcc	.+2      	; 0x1492 <_ZN5Print11printNumberEmh+0x32>
    1490:	2a e0       	ldi	r18, 0x0A	; 10
    1492:	8e 01       	movw	r16, r28
    1494:	0f 5d       	subi	r16, 0xDF	; 223
    1496:	1f 4f       	sbci	r17, 0xFF	; 255
    1498:	82 2e       	mov	r8, r18
    149a:	91 2c       	mov	r9, r1
    149c:	a1 2c       	mov	r10, r1
    149e:	b1 2c       	mov	r11, r1
    14a0:	bf 01       	movw	r22, r30
    14a2:	a5 01       	movw	r20, r10
    14a4:	94 01       	movw	r18, r8
    14a6:	0e 94 e9 1d 	call	0x3bd2	; 0x3bd2 <__udivmodsi4>
    14aa:	f9 01       	movw	r30, r18
    14ac:	ca 01       	movw	r24, r20
    14ae:	01 50       	subi	r16, 0x01	; 1
    14b0:	11 09       	sbc	r17, r1
    14b2:	6a 30       	cpi	r22, 0x0A	; 10
    14b4:	10 f4       	brcc	.+4      	; 0x14ba <_ZN5Print11printNumberEmh+0x5a>
    14b6:	60 5d       	subi	r22, 0xD0	; 208
    14b8:	01 c0       	rjmp	.+2      	; 0x14bc <_ZN5Print11printNumberEmh+0x5c>
    14ba:	69 5c       	subi	r22, 0xC9	; 201
    14bc:	d8 01       	movw	r26, r16
    14be:	6c 93       	st	X, r22
    14c0:	23 2b       	or	r18, r19
    14c2:	24 2b       	or	r18, r20
    14c4:	25 2b       	or	r18, r21
    14c6:	61 f7       	brne	.-40     	; 0x14a0 <_ZN5Print11printNumberEmh+0x40>
    14c8:	b8 01       	movw	r22, r16
    14ca:	c7 01       	movw	r24, r14
    14cc:	0e 94 ea 09 	call	0x13d4	; 0x13d4 <_ZN5Print5writeEPKc>
    14d0:	a1 96       	adiw	r28, 0x21	; 33
    14d2:	0f b6       	in	r0, 0x3f	; 63
    14d4:	f8 94       	cli
    14d6:	de bf       	out	0x3e, r29	; 62
    14d8:	0f be       	out	0x3f, r0	; 63
    14da:	cd bf       	out	0x3d, r28	; 61
    14dc:	df 91       	pop	r29
    14de:	cf 91       	pop	r28
    14e0:	1f 91       	pop	r17
    14e2:	0f 91       	pop	r16
    14e4:	ff 90       	pop	r15
    14e6:	ef 90       	pop	r14
    14e8:	bf 90       	pop	r11
    14ea:	af 90       	pop	r10
    14ec:	9f 90       	pop	r9
    14ee:	8f 90       	pop	r8
    14f0:	08 95       	ret

000014f2 <_ZN5Print5printEmi>:
    14f2:	21 15       	cp	r18, r1
    14f4:	31 05       	cpc	r19, r1
    14f6:	41 f4       	brne	.+16     	; 0x1508 <_ZN5Print5printEmi+0x16>
    14f8:	dc 01       	movw	r26, r24
    14fa:	ed 91       	ld	r30, X+
    14fc:	fc 91       	ld	r31, X
    14fe:	01 90       	ld	r0, Z+
    1500:	f0 81       	ld	r31, Z
    1502:	e0 2d       	mov	r30, r0
    1504:	64 2f       	mov	r22, r20
    1506:	09 94       	ijmp
    1508:	0c 94 30 0a 	jmp	0x1460	; 0x1460 <_ZN5Print11printNumberEmh>

0000150c <_ZN5Print5printEji>:
    150c:	9a 01       	movw	r18, r20
    150e:	ab 01       	movw	r20, r22
    1510:	60 e0       	ldi	r22, 0x00	; 0
    1512:	70 e0       	ldi	r23, 0x00	; 0
    1514:	0c 94 79 0a 	jmp	0x14f2	; 0x14f2 <_ZN5Print5printEmi>

00001518 <_ZN5Print10printFloatEdh>:
    1518:	7f 92       	push	r7
    151a:	8f 92       	push	r8
    151c:	9f 92       	push	r9
    151e:	af 92       	push	r10
    1520:	bf 92       	push	r11
    1522:	cf 92       	push	r12
    1524:	df 92       	push	r13
    1526:	ef 92       	push	r14
    1528:	ff 92       	push	r15
    152a:	0f 93       	push	r16
    152c:	1f 93       	push	r17
    152e:	cf 93       	push	r28
    1530:	df 93       	push	r29
    1532:	8c 01       	movw	r16, r24
    1534:	6a 01       	movw	r12, r20
    1536:	7b 01       	movw	r14, r22
    1538:	72 2e       	mov	r7, r18
    153a:	9a 01       	movw	r18, r20
    153c:	ab 01       	movw	r20, r22
    153e:	c7 01       	movw	r24, r14
    1540:	b6 01       	movw	r22, r12
    1542:	0e 94 d0 1d 	call	0x3ba0	; 0x3ba0 <__unordsf2>
    1546:	88 23       	and	r24, r24
    1548:	19 f0       	breq	.+6      	; 0x1550 <_ZN5Print10printFloatEdh+0x38>
    154a:	61 e9       	ldi	r22, 0x91	; 145
    154c:	71 e0       	ldi	r23, 0x01	; 1
    154e:	27 c0       	rjmp	.+78     	; 0x159e <_ZN5Print10printFloatEdh+0x86>
    1550:	46 01       	movw	r8, r12
    1552:	57 01       	movw	r10, r14
    1554:	e8 94       	clt
    1556:	b7 f8       	bld	r11, 7
    1558:	2f ef       	ldi	r18, 0xFF	; 255
    155a:	3f ef       	ldi	r19, 0xFF	; 255
    155c:	4f e7       	ldi	r20, 0x7F	; 127
    155e:	5f e7       	ldi	r21, 0x7F	; 127
    1560:	c5 01       	movw	r24, r10
    1562:	b4 01       	movw	r22, r8
    1564:	0e 94 d0 1d 	call	0x3ba0	; 0x3ba0 <__unordsf2>
    1568:	81 11       	cpse	r24, r1
    156a:	0d c0       	rjmp	.+26     	; 0x1586 <_ZN5Print10printFloatEdh+0x6e>
    156c:	2f ef       	ldi	r18, 0xFF	; 255
    156e:	3f ef       	ldi	r19, 0xFF	; 255
    1570:	4f e7       	ldi	r20, 0x7F	; 127
    1572:	5f e7       	ldi	r21, 0x7F	; 127
    1574:	c5 01       	movw	r24, r10
    1576:	b4 01       	movw	r22, r8
    1578:	0e 94 46 06 	call	0xc8c	; 0xc8c <__cmpsf2>
    157c:	18 16       	cp	r1, r24
    157e:	1c f4       	brge	.+6      	; 0x1586 <_ZN5Print10printFloatEdh+0x6e>
    1580:	65 e9       	ldi	r22, 0x95	; 149
    1582:	71 e0       	ldi	r23, 0x01	; 1
    1584:	0c c0       	rjmp	.+24     	; 0x159e <_ZN5Print10printFloatEdh+0x86>
    1586:	2f ef       	ldi	r18, 0xFF	; 255
    1588:	3f ef       	ldi	r19, 0xFF	; 255
    158a:	4f e7       	ldi	r20, 0x7F	; 127
    158c:	5f e4       	ldi	r21, 0x4F	; 79
    158e:	c7 01       	movw	r24, r14
    1590:	b6 01       	movw	r22, r12
    1592:	0e 94 6f 07 	call	0xede	; 0xede <__gesf2>
    1596:	18 16       	cp	r1, r24
    1598:	94 f4       	brge	.+36     	; 0x15be <_ZN5Print10printFloatEdh+0xa6>
    159a:	69 e9       	ldi	r22, 0x99	; 153
    159c:	71 e0       	ldi	r23, 0x01	; 1
    159e:	c8 01       	movw	r24, r16
    15a0:	df 91       	pop	r29
    15a2:	cf 91       	pop	r28
    15a4:	1f 91       	pop	r17
    15a6:	0f 91       	pop	r16
    15a8:	ff 90       	pop	r15
    15aa:	ef 90       	pop	r14
    15ac:	df 90       	pop	r13
    15ae:	cf 90       	pop	r12
    15b0:	bf 90       	pop	r11
    15b2:	af 90       	pop	r10
    15b4:	9f 90       	pop	r9
    15b6:	8f 90       	pop	r8
    15b8:	7f 90       	pop	r7
    15ba:	0c 94 ea 09 	jmp	0x13d4	; 0x13d4 <_ZN5Print5writeEPKc>
    15be:	2f ef       	ldi	r18, 0xFF	; 255
    15c0:	3f ef       	ldi	r19, 0xFF	; 255
    15c2:	4f e7       	ldi	r20, 0x7F	; 127
    15c4:	5f ec       	ldi	r21, 0xCF	; 207
    15c6:	c7 01       	movw	r24, r14
    15c8:	b6 01       	movw	r22, r12
    15ca:	0e 94 46 06 	call	0xc8c	; 0xc8c <__cmpsf2>
    15ce:	87 fd       	sbrc	r24, 7
    15d0:	e4 cf       	rjmp	.-56     	; 0x159a <_ZN5Print10printFloatEdh+0x82>
    15d2:	20 e0       	ldi	r18, 0x00	; 0
    15d4:	30 e0       	ldi	r19, 0x00	; 0
    15d6:	a9 01       	movw	r20, r18
    15d8:	c7 01       	movw	r24, r14
    15da:	b6 01       	movw	r22, r12
    15dc:	0e 94 46 06 	call	0xc8c	; 0xc8c <__cmpsf2>
    15e0:	87 ff       	sbrs	r24, 7
    15e2:	0a c0       	rjmp	.+20     	; 0x15f8 <_ZN5Print10printFloatEdh+0xe0>
    15e4:	6d e2       	ldi	r22, 0x2D	; 45
    15e6:	c8 01       	movw	r24, r16
    15e8:	0e 94 25 0a 	call	0x144a	; 0x144a <_ZN5Print5printEc>
    15ec:	ec 01       	movw	r28, r24
    15ee:	f7 fa       	bst	r15, 7
    15f0:	f0 94       	com	r15
    15f2:	f7 f8       	bld	r15, 7
    15f4:	f0 94       	com	r15
    15f6:	02 c0       	rjmp	.+4      	; 0x15fc <_ZN5Print10printFloatEdh+0xe4>
    15f8:	c0 e0       	ldi	r28, 0x00	; 0
    15fa:	d0 e0       	ldi	r29, 0x00	; 0
    15fc:	b1 2c       	mov	r11, r1
    15fe:	60 e0       	ldi	r22, 0x00	; 0
    1600:	70 e0       	ldi	r23, 0x00	; 0
    1602:	80 e0       	ldi	r24, 0x00	; 0
    1604:	9f e3       	ldi	r25, 0x3F	; 63
    1606:	7b 14       	cp	r7, r11
    1608:	41 f0       	breq	.+16     	; 0x161a <_ZN5Print10printFloatEdh+0x102>
    160a:	20 e0       	ldi	r18, 0x00	; 0
    160c:	30 e0       	ldi	r19, 0x00	; 0
    160e:	40 e2       	ldi	r20, 0x20	; 32
    1610:	51 e4       	ldi	r21, 0x41	; 65
    1612:	0e 94 4b 06 	call	0xc96	; 0xc96 <__divsf3>
    1616:	b3 94       	inc	r11
    1618:	f6 cf       	rjmp	.-20     	; 0x1606 <_ZN5Print10printFloatEdh+0xee>
    161a:	a7 01       	movw	r20, r14
    161c:	96 01       	movw	r18, r12
    161e:	0e 94 da 05 	call	0xbb4	; 0xbb4 <__addsf3>
    1622:	6b 01       	movw	r12, r22
    1624:	7c 01       	movw	r14, r24
    1626:	0e 94 a1 1d 	call	0x3b42	; 0x3b42 <__fixunssfsi>
    162a:	4b 01       	movw	r8, r22
    162c:	5c 01       	movw	r10, r24
    162e:	2a e0       	ldi	r18, 0x0A	; 10
    1630:	ab 01       	movw	r20, r22
    1632:	bc 01       	movw	r22, r24
    1634:	c8 01       	movw	r24, r16
    1636:	0e 94 30 0a 	call	0x1460	; 0x1460 <_ZN5Print11printNumberEmh>
    163a:	c8 0f       	add	r28, r24
    163c:	d9 1f       	adc	r29, r25
    163e:	77 20       	and	r7, r7
    1640:	b9 f1       	breq	.+110    	; 0x16b0 <_ZN5Print10printFloatEdh+0x198>
    1642:	c5 01       	movw	r24, r10
    1644:	b4 01       	movw	r22, r8
    1646:	0e 94 bd 06 	call	0xd7a	; 0xd7a <__floatunsisf>
    164a:	9b 01       	movw	r18, r22
    164c:	ac 01       	movw	r20, r24
    164e:	c7 01       	movw	r24, r14
    1650:	b6 01       	movw	r22, r12
    1652:	0e 94 d9 05 	call	0xbb2	; 0xbb2 <__subsf3>
    1656:	6b 01       	movw	r12, r22
    1658:	7c 01       	movw	r14, r24
    165a:	6e e2       	ldi	r22, 0x2E	; 46
    165c:	c8 01       	movw	r24, r16
    165e:	0e 94 25 0a 	call	0x144a	; 0x144a <_ZN5Print5printEc>
    1662:	c8 0f       	add	r28, r24
    1664:	d9 1f       	adc	r29, r25
    1666:	20 e0       	ldi	r18, 0x00	; 0
    1668:	30 e0       	ldi	r19, 0x00	; 0
    166a:	40 e2       	ldi	r20, 0x20	; 32
    166c:	51 e4       	ldi	r21, 0x41	; 65
    166e:	c7 01       	movw	r24, r14
    1670:	b6 01       	movw	r22, r12
    1672:	0e 94 74 07 	call	0xee8	; 0xee8 <__mulsf3>
    1676:	4b 01       	movw	r8, r22
    1678:	5c 01       	movw	r10, r24
    167a:	0e 94 a1 1d 	call	0x3b42	; 0x3b42 <__fixunssfsi>
    167e:	6b 01       	movw	r12, r22
    1680:	7c 01       	movw	r14, r24
    1682:	4a e0       	ldi	r20, 0x0A	; 10
    1684:	50 e0       	ldi	r21, 0x00	; 0
    1686:	c8 01       	movw	r24, r16
    1688:	0e 94 86 0a 	call	0x150c	; 0x150c <_ZN5Print5printEji>
    168c:	c8 0f       	add	r28, r24
    168e:	d9 1f       	adc	r29, r25
    1690:	b6 01       	movw	r22, r12
    1692:	80 e0       	ldi	r24, 0x00	; 0
    1694:	90 e0       	ldi	r25, 0x00	; 0
    1696:	0e 94 bd 06 	call	0xd7a	; 0xd7a <__floatunsisf>
    169a:	9b 01       	movw	r18, r22
    169c:	ac 01       	movw	r20, r24
    169e:	c5 01       	movw	r24, r10
    16a0:	b4 01       	movw	r22, r8
    16a2:	0e 94 d9 05 	call	0xbb2	; 0xbb2 <__subsf3>
    16a6:	6b 01       	movw	r12, r22
    16a8:	7c 01       	movw	r14, r24
    16aa:	7a 94       	dec	r7
    16ac:	71 10       	cpse	r7, r1
    16ae:	db cf       	rjmp	.-74     	; 0x1666 <_ZN5Print10printFloatEdh+0x14e>
    16b0:	ce 01       	movw	r24, r28
    16b2:	df 91       	pop	r29
    16b4:	cf 91       	pop	r28
    16b6:	1f 91       	pop	r17
    16b8:	0f 91       	pop	r16
    16ba:	ff 90       	pop	r15
    16bc:	ef 90       	pop	r14
    16be:	df 90       	pop	r13
    16c0:	cf 90       	pop	r12
    16c2:	bf 90       	pop	r11
    16c4:	af 90       	pop	r10
    16c6:	9f 90       	pop	r9
    16c8:	8f 90       	pop	r8
    16ca:	7f 90       	pop	r7
    16cc:	08 95       	ret

000016ce <_ZN5Print7printlnEdi>:
  n += println();
  return n;
}

size_t Print::println(double num, int digits)
{
    16ce:	0f 93       	push	r16
    16d0:	1f 93       	push	r17
    16d2:	cf 93       	push	r28
    16d4:	df 93       	push	r29
    16d6:	ec 01       	movw	r28, r24
  else return printNumber(n, base);
}

size_t Print::print(double n, int digits)
{
  return printFloat(n, digits);
    16d8:	0e 94 8c 0a 	call	0x1518	; 0x1518 <_ZN5Print10printFloatEdh>
    16dc:	8c 01       	movw	r16, r24
}

size_t Print::println(double num, int digits)
{
  size_t n = print(num, digits);
  n += println();
    16de:	ce 01       	movw	r24, r28
    16e0:	0e 94 2c 0a 	call	0x1458	; 0x1458 <_ZN5Print7printlnEv>
  return n;
}
    16e4:	80 0f       	add	r24, r16
    16e6:	91 1f       	adc	r25, r17
    16e8:	df 91       	pop	r29
    16ea:	cf 91       	pop	r28
    16ec:	1f 91       	pop	r17
    16ee:	0f 91       	pop	r16
    16f0:	08 95       	ret

000016f2 <nothing>:
    #endif
      break;       
#endif
    }
      
    intFunc[interruptNum] = nothing;
    16f2:	08 95       	ret

000016f4 <attachInterrupt>:
    16f4:	82 30       	cpi	r24, 0x02	; 2
    16f6:	e8 f4       	brcc	.+58     	; 0x1732 <attachInterrupt+0x3e>
    16f8:	e8 2f       	mov	r30, r24
    16fa:	f0 e0       	ldi	r31, 0x00	; 0
    16fc:	ee 0f       	add	r30, r30
    16fe:	ff 1f       	adc	r31, r31
    1700:	e4 5e       	subi	r30, 0xE4	; 228
    1702:	fe 4f       	sbci	r31, 0xFE	; 254
    1704:	71 83       	std	Z+1, r23	; 0x01
    1706:	60 83       	st	Z, r22
    1708:	81 30       	cpi	r24, 0x01	; 1
    170a:	41 f0       	breq	.+16     	; 0x171c <attachInterrupt+0x28>
    170c:	80 91 69 00 	lds	r24, 0x0069	; 0x800069 <__DATA_REGION_ORIGIN__+0x9>
    1710:	8c 7f       	andi	r24, 0xFC	; 252
    1712:	48 2b       	or	r20, r24
    1714:	40 93 69 00 	sts	0x0069, r20	; 0x800069 <__DATA_REGION_ORIGIN__+0x9>
    1718:	e8 9a       	sbi	0x1d, 0	; 29
    171a:	08 95       	ret
    171c:	80 91 69 00 	lds	r24, 0x0069	; 0x800069 <__DATA_REGION_ORIGIN__+0x9>
    1720:	83 7f       	andi	r24, 0xF3	; 243
    1722:	44 0f       	add	r20, r20
    1724:	55 1f       	adc	r21, r21
    1726:	44 0f       	add	r20, r20
    1728:	55 1f       	adc	r21, r21
    172a:	48 2b       	or	r20, r24
    172c:	40 93 69 00 	sts	0x0069, r20	; 0x800069 <__DATA_REGION_ORIGIN__+0x9>
    1730:	e9 9a       	sbi	0x1d, 1	; 29
    1732:	08 95       	ret

00001734 <__vector_1>:
IMPLEMENT_ISR(INT6_vect, EXTERNAL_INT_6)
IMPLEMENT_ISR(INT7_vect, EXTERNAL_INT_7)

#else

IMPLEMENT_ISR(INT0_vect, EXTERNAL_INT_0)
    1734:	1f 92       	push	r1
    1736:	0f 92       	push	r0
    1738:	0f b6       	in	r0, 0x3f	; 63
    173a:	0f 92       	push	r0
    173c:	11 24       	eor	r1, r1
    173e:	2f 93       	push	r18
    1740:	3f 93       	push	r19
    1742:	4f 93       	push	r20
    1744:	5f 93       	push	r21
    1746:	6f 93       	push	r22
    1748:	7f 93       	push	r23
    174a:	8f 93       	push	r24
    174c:	9f 93       	push	r25
    174e:	af 93       	push	r26
    1750:	bf 93       	push	r27
    1752:	ef 93       	push	r30
    1754:	ff 93       	push	r31
    1756:	e0 91 1c 01 	lds	r30, 0x011C	; 0x80011c <intFunc>
    175a:	f0 91 1d 01 	lds	r31, 0x011D	; 0x80011d <intFunc+0x1>
    175e:	09 95       	icall
    1760:	ff 91       	pop	r31
    1762:	ef 91       	pop	r30
    1764:	bf 91       	pop	r27
    1766:	af 91       	pop	r26
    1768:	9f 91       	pop	r25
    176a:	8f 91       	pop	r24
    176c:	7f 91       	pop	r23
    176e:	6f 91       	pop	r22
    1770:	5f 91       	pop	r21
    1772:	4f 91       	pop	r20
    1774:	3f 91       	pop	r19
    1776:	2f 91       	pop	r18
    1778:	0f 90       	pop	r0
    177a:	0f be       	out	0x3f, r0	; 63
    177c:	0f 90       	pop	r0
    177e:	1f 90       	pop	r1
    1780:	18 95       	reti

00001782 <__vector_2>:
IMPLEMENT_ISR(INT1_vect, EXTERNAL_INT_1)
    1782:	1f 92       	push	r1
    1784:	0f 92       	push	r0
    1786:	0f b6       	in	r0, 0x3f	; 63
    1788:	0f 92       	push	r0
    178a:	11 24       	eor	r1, r1
    178c:	2f 93       	push	r18
    178e:	3f 93       	push	r19
    1790:	4f 93       	push	r20
    1792:	5f 93       	push	r21
    1794:	6f 93       	push	r22
    1796:	7f 93       	push	r23
    1798:	8f 93       	push	r24
    179a:	9f 93       	push	r25
    179c:	af 93       	push	r26
    179e:	bf 93       	push	r27
    17a0:	ef 93       	push	r30
    17a2:	ff 93       	push	r31
    17a4:	e0 91 1e 01 	lds	r30, 0x011E	; 0x80011e <intFunc+0x2>
    17a8:	f0 91 1f 01 	lds	r31, 0x011F	; 0x80011f <intFunc+0x3>
    17ac:	09 95       	icall
    17ae:	ff 91       	pop	r31
    17b0:	ef 91       	pop	r30
    17b2:	bf 91       	pop	r27
    17b4:	af 91       	pop	r26
    17b6:	9f 91       	pop	r25
    17b8:	8f 91       	pop	r24
    17ba:	7f 91       	pop	r23
    17bc:	6f 91       	pop	r22
    17be:	5f 91       	pop	r21
    17c0:	4f 91       	pop	r20
    17c2:	3f 91       	pop	r19
    17c4:	2f 91       	pop	r18
    17c6:	0f 90       	pop	r0
    17c8:	0f be       	out	0x3f, r0	; 63
    17ca:	0f 90       	pop	r0
    17cc:	1f 90       	pop	r1
    17ce:	18 95       	reti

000017d0 <__vector_16>:
	

#endif

	// busy wait
	__asm__ __volatile__ (
    17d0:	1f 92       	push	r1
    17d2:	0f 92       	push	r0
    17d4:	0f b6       	in	r0, 0x3f	; 63
    17d6:	0f 92       	push	r0
    17d8:	11 24       	eor	r1, r1
    17da:	2f 93       	push	r18
    17dc:	3f 93       	push	r19
    17de:	8f 93       	push	r24
    17e0:	9f 93       	push	r25
    17e2:	af 93       	push	r26
    17e4:	bf 93       	push	r27
    17e6:	80 91 4b 03 	lds	r24, 0x034B	; 0x80034b <timer0_millis>
    17ea:	90 91 4c 03 	lds	r25, 0x034C	; 0x80034c <timer0_millis+0x1>
    17ee:	a0 91 4d 03 	lds	r26, 0x034D	; 0x80034d <timer0_millis+0x2>
    17f2:	b0 91 4e 03 	lds	r27, 0x034E	; 0x80034e <timer0_millis+0x3>
    17f6:	30 91 4a 03 	lds	r19, 0x034A	; 0x80034a <timer0_fract>
    17fa:	23 e0       	ldi	r18, 0x03	; 3
    17fc:	23 0f       	add	r18, r19
    17fe:	2d 37       	cpi	r18, 0x7D	; 125
    1800:	20 f4       	brcc	.+8      	; 0x180a <__vector_16+0x3a>
    1802:	01 96       	adiw	r24, 0x01	; 1
    1804:	a1 1d       	adc	r26, r1
    1806:	b1 1d       	adc	r27, r1
    1808:	05 c0       	rjmp	.+10     	; 0x1814 <__vector_16+0x44>
    180a:	26 e8       	ldi	r18, 0x86	; 134
    180c:	23 0f       	add	r18, r19
    180e:	02 96       	adiw	r24, 0x02	; 2
    1810:	a1 1d       	adc	r26, r1
    1812:	b1 1d       	adc	r27, r1
    1814:	20 93 4a 03 	sts	0x034A, r18	; 0x80034a <timer0_fract>
    1818:	80 93 4b 03 	sts	0x034B, r24	; 0x80034b <timer0_millis>
    181c:	90 93 4c 03 	sts	0x034C, r25	; 0x80034c <timer0_millis+0x1>
    1820:	a0 93 4d 03 	sts	0x034D, r26	; 0x80034d <timer0_millis+0x2>
    1824:	b0 93 4e 03 	sts	0x034E, r27	; 0x80034e <timer0_millis+0x3>
    1828:	80 91 4f 03 	lds	r24, 0x034F	; 0x80034f <timer0_overflow_count>
    182c:	90 91 50 03 	lds	r25, 0x0350	; 0x800350 <timer0_overflow_count+0x1>
    1830:	a0 91 51 03 	lds	r26, 0x0351	; 0x800351 <timer0_overflow_count+0x2>
    1834:	b0 91 52 03 	lds	r27, 0x0352	; 0x800352 <timer0_overflow_count+0x3>
    1838:	01 96       	adiw	r24, 0x01	; 1
    183a:	a1 1d       	adc	r26, r1
    183c:	b1 1d       	adc	r27, r1
    183e:	80 93 4f 03 	sts	0x034F, r24	; 0x80034f <timer0_overflow_count>
    1842:	90 93 50 03 	sts	0x0350, r25	; 0x800350 <timer0_overflow_count+0x1>
    1846:	a0 93 51 03 	sts	0x0351, r26	; 0x800351 <timer0_overflow_count+0x2>
    184a:	b0 93 52 03 	sts	0x0352, r27	; 0x800352 <timer0_overflow_count+0x3>
    184e:	bf 91       	pop	r27
    1850:	af 91       	pop	r26
    1852:	9f 91       	pop	r25
    1854:	8f 91       	pop	r24
    1856:	3f 91       	pop	r19
    1858:	2f 91       	pop	r18
    185a:	0f 90       	pop	r0
    185c:	0f be       	out	0x3f, r0	; 63
    185e:	0f 90       	pop	r0
    1860:	1f 90       	pop	r1
    1862:	18 95       	reti

00001864 <init>:

void init()
{
	// this needs to be called before setup() or some functions won't
	// work there
	sei();
    1864:	78 94       	sei
	
	// on the ATmega168, timer 0 is also used for fast hardware pwm
	// (using phase-correct PWM would mean that timer 0 overflowed half as often
	// resulting in different millis() behavior on the ATmega8 and ATmega168)
#if defined(TCCR0A) && defined(WGM01)
	sbi(TCCR0A, WGM01);
    1866:	84 b5       	in	r24, 0x24	; 36
    1868:	82 60       	ori	r24, 0x02	; 2
    186a:	84 bd       	out	0x24, r24	; 36
	sbi(TCCR0A, WGM00);
    186c:	84 b5       	in	r24, 0x24	; 36
    186e:	81 60       	ori	r24, 0x01	; 1
    1870:	84 bd       	out	0x24, r24	; 36
	// this combination is for the standard atmega8
	sbi(TCCR0, CS01);
	sbi(TCCR0, CS00);
#elif defined(TCCR0B) && defined(CS01) && defined(CS00)
	// this combination is for the standard 168/328/1280/2560
	sbi(TCCR0B, CS01);
    1872:	85 b5       	in	r24, 0x25	; 37
    1874:	82 60       	ori	r24, 0x02	; 2
    1876:	85 bd       	out	0x25, r24	; 37
	sbi(TCCR0B, CS00);
    1878:	85 b5       	in	r24, 0x25	; 37
    187a:	81 60       	ori	r24, 0x01	; 1
    187c:	85 bd       	out	0x25, r24	; 37

	// enable timer 0 overflow interrupt
#if defined(TIMSK) && defined(TOIE0)
	sbi(TIMSK, TOIE0);
#elif defined(TIMSK0) && defined(TOIE0)
	sbi(TIMSK0, TOIE0);
    187e:	ee e6       	ldi	r30, 0x6E	; 110
    1880:	f0 e0       	ldi	r31, 0x00	; 0
    1882:	80 81       	ld	r24, Z
    1884:	81 60       	ori	r24, 0x01	; 1
    1886:	80 83       	st	Z, r24
	// this is better for motors as it ensures an even waveform
	// note, however, that fast pwm mode can achieve a frequency of up
	// 8 MHz (with a 16 MHz clock) at 50% duty cycle

#if defined(TCCR1B) && defined(CS11) && defined(CS10)
	TCCR1B = 0;
    1888:	e1 e8       	ldi	r30, 0x81	; 129
    188a:	f0 e0       	ldi	r31, 0x00	; 0
    188c:	10 82       	st	Z, r1

	// set timer 1 prescale factor to 64
	sbi(TCCR1B, CS11);
    188e:	80 81       	ld	r24, Z
    1890:	82 60       	ori	r24, 0x02	; 2
    1892:	80 83       	st	Z, r24
#if F_CPU >= 8000000L
	sbi(TCCR1B, CS10);
    1894:	80 81       	ld	r24, Z
    1896:	81 60       	ori	r24, 0x01	; 1
    1898:	80 83       	st	Z, r24
	sbi(TCCR1, CS10);
#endif
#endif
	// put timer 1 in 8-bit phase correct pwm mode
#if defined(TCCR1A) && defined(WGM10)
	sbi(TCCR1A, WGM10);
    189a:	e0 e8       	ldi	r30, 0x80	; 128
    189c:	f0 e0       	ldi	r31, 0x00	; 0
    189e:	80 81       	ld	r24, Z
    18a0:	81 60       	ori	r24, 0x01	; 1
    18a2:	80 83       	st	Z, r24

	// set timer 2 prescale factor to 64
#if defined(TCCR2) && defined(CS22)
	sbi(TCCR2, CS22);
#elif defined(TCCR2B) && defined(CS22)
	sbi(TCCR2B, CS22);
    18a4:	e1 eb       	ldi	r30, 0xB1	; 177
    18a6:	f0 e0       	ldi	r31, 0x00	; 0
    18a8:	80 81       	ld	r24, Z
    18aa:	84 60       	ori	r24, 0x04	; 4
    18ac:	80 83       	st	Z, r24

	// configure timer 2 for phase correct pwm (8-bit)
#if defined(TCCR2) && defined(WGM20)
	sbi(TCCR2, WGM20);
#elif defined(TCCR2A) && defined(WGM20)
	sbi(TCCR2A, WGM20);
    18ae:	e0 eb       	ldi	r30, 0xB0	; 176
    18b0:	f0 e0       	ldi	r31, 0x00	; 0
    18b2:	80 81       	ld	r24, Z
    18b4:	81 60       	ori	r24, 0x01	; 1
    18b6:	80 83       	st	Z, r24
#endif

#if defined(ADCSRA)
	// set a2d prescaler so we are inside the desired 50-200 KHz range.
	#if F_CPU >= 16000000 // 16 MHz / 128 = 125 KHz
		sbi(ADCSRA, ADPS2);
    18b8:	ea e7       	ldi	r30, 0x7A	; 122
    18ba:	f0 e0       	ldi	r31, 0x00	; 0
    18bc:	80 81       	ld	r24, Z
    18be:	84 60       	ori	r24, 0x04	; 4
    18c0:	80 83       	st	Z, r24
		sbi(ADCSRA, ADPS1);
    18c2:	80 81       	ld	r24, Z
    18c4:	82 60       	ori	r24, 0x02	; 2
    18c6:	80 83       	st	Z, r24
		sbi(ADCSRA, ADPS0);
    18c8:	80 81       	ld	r24, Z
    18ca:	81 60       	ori	r24, 0x01	; 1
    18cc:	80 83       	st	Z, r24
		cbi(ADCSRA, ADPS2);
		cbi(ADCSRA, ADPS1);
		sbi(ADCSRA, ADPS0);
	#endif
	// enable a2d conversions
	sbi(ADCSRA, ADEN);
    18ce:	80 81       	ld	r24, Z
    18d0:	80 68       	ori	r24, 0x80	; 128
    18d2:	80 83       	st	Z, r24
	// here so they can be used as normal digital i/o; they will be
	// reconnected in Serial.begin()
#if defined(UCSRB)
	UCSRB = 0;
#elif defined(UCSR0B)
	UCSR0B = 0;
    18d4:	10 92 c1 00 	sts	0x00C1, r1	; 0x8000c1 <__DATA_REGION_ORIGIN__+0x61>
    18d8:	08 95       	ret

000018da <analogRead>:
#elif defined(__AVR_ATmega32U4__)
	if (pin >= 18) pin -= 18; // allow for channel or pin numbers
#elif defined(__AVR_ATmega1284__) || defined(__AVR_ATmega1284P__) || defined(__AVR_ATmega644__) || defined(__AVR_ATmega644A__) || defined(__AVR_ATmega644P__) || defined(__AVR_ATmega644PA__)
	if (pin >= 24) pin -= 24; // allow for channel or pin numbers
#else
	if (pin >= 14) pin -= 14; // allow for channel or pin numbers
    18da:	8e 30       	cpi	r24, 0x0E	; 14
    18dc:	08 f0       	brcs	.+2      	; 0x18e0 <analogRead+0x6>
    18de:	8e 50       	subi	r24, 0x0E	; 14
	// to 0 (the default).
#if defined(ADMUX)
#if defined(__AVR_ATtiny25__) || defined(__AVR_ATtiny45__) || defined(__AVR_ATtiny85__)
	ADMUX = (analog_reference << 4) | (pin & 0x07);
#else
	ADMUX = (analog_reference << 6) | (pin & 0x07);
    18e0:	20 91 20 01 	lds	r18, 0x0120	; 0x800120 <analog_reference>
    18e4:	90 e4       	ldi	r25, 0x40	; 64
    18e6:	29 9f       	mul	r18, r25
    18e8:	90 01       	movw	r18, r0
    18ea:	11 24       	eor	r1, r1
    18ec:	87 70       	andi	r24, 0x07	; 7
    18ee:	82 2b       	or	r24, r18
    18f0:	80 93 7c 00 	sts	0x007C, r24	; 0x80007c <__DATA_REGION_ORIGIN__+0x1c>
	// without a delay, we seem to read from the wrong channel
	//delay(1);

#if defined(ADCSRA) && defined(ADCL)
	// start the conversion
	sbi(ADCSRA, ADSC);
    18f4:	80 91 7a 00 	lds	r24, 0x007A	; 0x80007a <__DATA_REGION_ORIGIN__+0x1a>
    18f8:	80 64       	ori	r24, 0x40	; 64
    18fa:	80 93 7a 00 	sts	0x007A, r24	; 0x80007a <__DATA_REGION_ORIGIN__+0x1a>

	// ADSC is cleared when the conversion finishes
	while (bit_is_set(ADCSRA, ADSC));
    18fe:	80 91 7a 00 	lds	r24, 0x007A	; 0x80007a <__DATA_REGION_ORIGIN__+0x1a>
    1902:	86 fd       	sbrc	r24, 6
    1904:	fc cf       	rjmp	.-8      	; 0x18fe <analogRead+0x24>

	// we have to read ADCL first; doing so locks both ADCL
	// and ADCH until ADCH is read.  reading ADCL second would
	// cause the results of each conversion to be discarded,
	// as ADCL and ADCH would be locked when it completed.
	low  = ADCL;
    1906:	80 91 78 00 	lds	r24, 0x0078	; 0x800078 <__DATA_REGION_ORIGIN__+0x18>
	high = ADCH;
    190a:	20 91 79 00 	lds	r18, 0x0079	; 0x800079 <__DATA_REGION_ORIGIN__+0x19>
	low  = 0;
	high = 0;
#endif

	// combine the two bytes
	return (high << 8) | low;
    190e:	90 e0       	ldi	r25, 0x00	; 0
}
    1910:	92 2b       	or	r25, r18
    1912:	08 95       	ret

00001914 <analogWrite>:
// Right now, PWM output only works on the pins with
// hardware support.  These are defined in the appropriate
// pins_*.c file.  For the rest of the pins, we default
// to digital output.
void analogWrite(uint8_t pin, int val)
{
    1914:	1f 93       	push	r17
    1916:	cf 93       	push	r28
    1918:	df 93       	push	r29
    191a:	18 2f       	mov	r17, r24
    191c:	eb 01       	movw	r28, r22
	// We need to make sure the PWM output is enabled for those pins
	// that support it, as we turn it off when digitally reading or
	// writing with them.  Also, make sure the pin is in output mode
	// for consistenty with Wiring, which doesn't require a pinMode
	// call for the analog output pins.
	pinMode(pin, OUTPUT);
    191e:	61 e0       	ldi	r22, 0x01	; 1
    1920:	0e 94 12 0d 	call	0x1a24	; 0x1a24 <pinMode>
	if (val == 0)
    1924:	20 97       	sbiw	r28, 0x00	; 0
    1926:	11 f4       	brne	.+4      	; 0x192c <analogWrite+0x18>
	{
		digitalWrite(pin, LOW);
    1928:	60 e0       	ldi	r22, 0x00	; 0
    192a:	04 c0       	rjmp	.+8      	; 0x1934 <analogWrite+0x20>
	}
	else if (val == 255)
    192c:	cf 3f       	cpi	r28, 0xFF	; 255
    192e:	d1 05       	cpc	r29, r1
    1930:	39 f4       	brne	.+14     	; 0x1940 <analogWrite+0x2c>
	{
		digitalWrite(pin, HIGH);
    1932:	61 e0       	ldi	r22, 0x01	; 1
    1934:	81 2f       	mov	r24, r17
				} else {
					digitalWrite(pin, HIGH);
				}
		}
	}
}
    1936:	df 91       	pop	r29
    1938:	cf 91       	pop	r28
    193a:	1f 91       	pop	r17
	{
		digitalWrite(pin, LOW);
	}
	else if (val == 255)
	{
		digitalWrite(pin, HIGH);
    193c:	0c 94 4e 0d 	jmp	0x1a9c	; 0x1a9c <digitalWrite>
	}
	else
	{
		switch(digitalPinToTimer(pin))
    1940:	e1 2f       	mov	r30, r17
    1942:	f0 e0       	ldi	r31, 0x00	; 0
    1944:	ee 56       	subi	r30, 0x6E	; 110
    1946:	ff 4f       	sbci	r31, 0xFF	; 255
    1948:	e4 91       	lpm	r30, Z
    194a:	e3 30       	cpi	r30, 0x03	; 3
    194c:	f9 f0       	breq	.+62     	; 0x198c <analogWrite+0x78>
    194e:	48 f4       	brcc	.+18     	; 0x1962 <analogWrite+0x4e>
    1950:	e1 30       	cpi	r30, 0x01	; 1
    1952:	b9 f0       	breq	.+46     	; 0x1982 <analogWrite+0x6e>
    1954:	e2 30       	cpi	r30, 0x02	; 2
    1956:	a1 f5       	brne	.+104    	; 0x19c0 <analogWrite+0xac>
			#endif

			#if defined(TCCR0A) && defined(COM0B1)
			case TIMER0B:
				// connect pwm to pin on timer 0, channel B
				sbi(TCCR0A, COM0B1);
    1958:	84 b5       	in	r24, 0x24	; 36
    195a:	80 62       	ori	r24, 0x20	; 32
    195c:	84 bd       	out	0x24, r24	; 36
				OCR0B = val; // set pwm duty
    195e:	c8 bd       	out	0x28, r28	; 40
				break;
    1960:	34 c0       	rjmp	.+104    	; 0x19ca <analogWrite+0xb6>
	{
		digitalWrite(pin, HIGH);
	}
	else
	{
		switch(digitalPinToTimer(pin))
    1962:	e7 30       	cpi	r30, 0x07	; 7
    1964:	e9 f0       	breq	.+58     	; 0x19a0 <analogWrite+0x8c>
    1966:	e8 30       	cpi	r30, 0x08	; 8
    1968:	19 f1       	breq	.+70     	; 0x19b0 <analogWrite+0x9c>
    196a:	e4 30       	cpi	r30, 0x04	; 4
    196c:	49 f5       	brne	.+82     	; 0x19c0 <analogWrite+0xac>
			#endif

			#if defined(TCCR1A) && defined(COM1B1)
			case TIMER1B:
				// connect pwm to pin on timer 1, channel B
				sbi(TCCR1A, COM1B1);
    196e:	80 91 80 00 	lds	r24, 0x0080	; 0x800080 <__DATA_REGION_ORIGIN__+0x20>
    1972:	80 62       	ori	r24, 0x20	; 32
    1974:	80 93 80 00 	sts	0x0080, r24	; 0x800080 <__DATA_REGION_ORIGIN__+0x20>
				OCR1B = val; // set pwm duty
    1978:	d0 93 8b 00 	sts	0x008B, r29	; 0x80008b <__DATA_REGION_ORIGIN__+0x2b>
    197c:	c0 93 8a 00 	sts	0x008A, r28	; 0x80008a <__DATA_REGION_ORIGIN__+0x2a>
				break;
    1980:	24 c0       	rjmp	.+72     	; 0x19ca <analogWrite+0xb6>
			#endif

			#if defined(TCCR0A) && defined(COM0A1)
			case TIMER0A:
				// connect pwm to pin on timer 0, channel A
				sbi(TCCR0A, COM0A1);
    1982:	84 b5       	in	r24, 0x24	; 36
    1984:	80 68       	ori	r24, 0x80	; 128
    1986:	84 bd       	out	0x24, r24	; 36
				OCR0A = val; // set pwm duty
    1988:	c7 bd       	out	0x27, r28	; 39
				break;
    198a:	1f c0       	rjmp	.+62     	; 0x19ca <analogWrite+0xb6>
			#endif

			#if defined(TCCR1A) && defined(COM1A1)
			case TIMER1A:
				// connect pwm to pin on timer 1, channel A
				sbi(TCCR1A, COM1A1);
    198c:	80 91 80 00 	lds	r24, 0x0080	; 0x800080 <__DATA_REGION_ORIGIN__+0x20>
    1990:	80 68       	ori	r24, 0x80	; 128
    1992:	80 93 80 00 	sts	0x0080, r24	; 0x800080 <__DATA_REGION_ORIGIN__+0x20>
				OCR1A = val; // set pwm duty
    1996:	d0 93 89 00 	sts	0x0089, r29	; 0x800089 <__DATA_REGION_ORIGIN__+0x29>
    199a:	c0 93 88 00 	sts	0x0088, r28	; 0x800088 <__DATA_REGION_ORIGIN__+0x28>
				break;
    199e:	15 c0       	rjmp	.+42     	; 0x19ca <analogWrite+0xb6>
			#endif

			#if defined(TCCR2A) && defined(COM2A1)
			case TIMER2A:
				// connect pwm to pin on timer 2, channel A
				sbi(TCCR2A, COM2A1);
    19a0:	80 91 b0 00 	lds	r24, 0x00B0	; 0x8000b0 <__DATA_REGION_ORIGIN__+0x50>
    19a4:	80 68       	ori	r24, 0x80	; 128
    19a6:	80 93 b0 00 	sts	0x00B0, r24	; 0x8000b0 <__DATA_REGION_ORIGIN__+0x50>
				OCR2A = val; // set pwm duty
    19aa:	c0 93 b3 00 	sts	0x00B3, r28	; 0x8000b3 <__DATA_REGION_ORIGIN__+0x53>
				break;
    19ae:	0d c0       	rjmp	.+26     	; 0x19ca <analogWrite+0xb6>
			#endif

			#if defined(TCCR2A) && defined(COM2B1)
			case TIMER2B:
				// connect pwm to pin on timer 2, channel B
				sbi(TCCR2A, COM2B1);
    19b0:	80 91 b0 00 	lds	r24, 0x00B0	; 0x8000b0 <__DATA_REGION_ORIGIN__+0x50>
    19b4:	80 62       	ori	r24, 0x20	; 32
    19b6:	80 93 b0 00 	sts	0x00B0, r24	; 0x8000b0 <__DATA_REGION_ORIGIN__+0x50>
				OCR2B = val; // set pwm duty
    19ba:	c0 93 b4 00 	sts	0x00B4, r28	; 0x8000b4 <__DATA_REGION_ORIGIN__+0x54>
				break;
    19be:	05 c0       	rjmp	.+10     	; 0x19ca <analogWrite+0xb6>
				break;
			#endif

			case NOT_ON_TIMER:
			default:
				if (val < 128) {
    19c0:	c0 38       	cpi	r28, 0x80	; 128
    19c2:	d1 05       	cpc	r29, r1
    19c4:	0c f0       	brlt	.+2      	; 0x19c8 <analogWrite+0xb4>
    19c6:	b5 cf       	rjmp	.-150    	; 0x1932 <analogWrite+0x1e>
    19c8:	af cf       	rjmp	.-162    	; 0x1928 <analogWrite+0x14>
				} else {
					digitalWrite(pin, HIGH);
				}
		}
	}
}
    19ca:	df 91       	pop	r29
    19cc:	cf 91       	pop	r28
    19ce:	1f 91       	pop	r17
    19d0:	08 95       	ret

000019d2 <turnOffPWM>:
//
//static inline void turnOffPWM(uint8_t timer) __attribute__ ((always_inline));
//static inline void turnOffPWM(uint8_t timer)
static void turnOffPWM(uint8_t timer)
{
	switch (timer)
    19d2:	83 30       	cpi	r24, 0x03	; 3
    19d4:	81 f0       	breq	.+32     	; 0x19f6 <turnOffPWM+0x24>
    19d6:	28 f4       	brcc	.+10     	; 0x19e2 <turnOffPWM+0x10>
    19d8:	81 30       	cpi	r24, 0x01	; 1
    19da:	99 f0       	breq	.+38     	; 0x1a02 <turnOffPWM+0x30>
    19dc:	82 30       	cpi	r24, 0x02	; 2
    19de:	a1 f0       	breq	.+40     	; 0x1a08 <turnOffPWM+0x36>
    19e0:	08 95       	ret
    19e2:	87 30       	cpi	r24, 0x07	; 7
    19e4:	a9 f0       	breq	.+42     	; 0x1a10 <turnOffPWM+0x3e>
    19e6:	88 30       	cpi	r24, 0x08	; 8
    19e8:	b9 f0       	breq	.+46     	; 0x1a18 <turnOffPWM+0x46>
    19ea:	84 30       	cpi	r24, 0x04	; 4
    19ec:	d1 f4       	brne	.+52     	; 0x1a22 <turnOffPWM+0x50>
	{
		#if defined(TCCR1A) && defined(COM1A1)
		case TIMER1A:   cbi(TCCR1A, COM1A1);    break;
		#endif
		#if defined(TCCR1A) && defined(COM1B1)
		case TIMER1B:   cbi(TCCR1A, COM1B1);    break;
    19ee:	80 91 80 00 	lds	r24, 0x0080	; 0x800080 <__DATA_REGION_ORIGIN__+0x20>
    19f2:	8f 7d       	andi	r24, 0xDF	; 223
    19f4:	03 c0       	rjmp	.+6      	; 0x19fc <turnOffPWM+0x2a>
static void turnOffPWM(uint8_t timer)
{
	switch (timer)
	{
		#if defined(TCCR1A) && defined(COM1A1)
		case TIMER1A:   cbi(TCCR1A, COM1A1);    break;
    19f6:	80 91 80 00 	lds	r24, 0x0080	; 0x800080 <__DATA_REGION_ORIGIN__+0x20>
    19fa:	8f 77       	andi	r24, 0x7F	; 127
		#endif
		#if defined(TCCR1A) && defined(COM1B1)
		case TIMER1B:   cbi(TCCR1A, COM1B1);    break;
    19fc:	80 93 80 00 	sts	0x0080, r24	; 0x800080 <__DATA_REGION_ORIGIN__+0x20>
    1a00:	08 95       	ret
		#if defined(TCCR2) && defined(COM21)
		case  TIMER2:   cbi(TCCR2, COM21);      break;
		#endif
		
		#if defined(TCCR0A) && defined(COM0A1)
		case  TIMER0A:  cbi(TCCR0A, COM0A1);    break;
    1a02:	84 b5       	in	r24, 0x24	; 36
    1a04:	8f 77       	andi	r24, 0x7F	; 127
    1a06:	02 c0       	rjmp	.+4      	; 0x1a0c <turnOffPWM+0x3a>
		#endif
		
		#if defined(TCCR0A) && defined(COM0B1)
		case  TIMER0B:  cbi(TCCR0A, COM0B1);    break;
    1a08:	84 b5       	in	r24, 0x24	; 36
    1a0a:	8f 7d       	andi	r24, 0xDF	; 223
    1a0c:	84 bd       	out	0x24, r24	; 36
    1a0e:	08 95       	ret
		#endif
		#if defined(TCCR2A) && defined(COM2A1)
		case  TIMER2A:  cbi(TCCR2A, COM2A1);    break;
    1a10:	80 91 b0 00 	lds	r24, 0x00B0	; 0x8000b0 <__DATA_REGION_ORIGIN__+0x50>
    1a14:	8f 77       	andi	r24, 0x7F	; 127
    1a16:	03 c0       	rjmp	.+6      	; 0x1a1e <turnOffPWM+0x4c>
		#endif
		#if defined(TCCR2A) && defined(COM2B1)
		case  TIMER2B:  cbi(TCCR2A, COM2B1);    break;
    1a18:	80 91 b0 00 	lds	r24, 0x00B0	; 0x8000b0 <__DATA_REGION_ORIGIN__+0x50>
    1a1c:	8f 7d       	andi	r24, 0xDF	; 223
    1a1e:	80 93 b0 00 	sts	0x00B0, r24	; 0x8000b0 <__DATA_REGION_ORIGIN__+0x50>
    1a22:	08 95       	ret

00001a24 <pinMode>:
#define ARDUINO_MAIN
#include "wiring_private.h"
#include "pins_arduino.h"

void pinMode(uint8_t pin, uint8_t mode)
{
    1a24:	cf 93       	push	r28
    1a26:	df 93       	push	r29
	uint8_t bit = digitalPinToBitMask(pin);
    1a28:	90 e0       	ldi	r25, 0x00	; 0
    1a2a:	fc 01       	movw	r30, r24
    1a2c:	ea 55       	subi	r30, 0x5A	; 90
    1a2e:	ff 4f       	sbci	r31, 0xFF	; 255
    1a30:	24 91       	lpm	r18, Z
	uint8_t port = digitalPinToPort(pin);
    1a32:	fc 01       	movw	r30, r24
    1a34:	e6 54       	subi	r30, 0x46	; 70
    1a36:	ff 4f       	sbci	r31, 0xFF	; 255
    1a38:	84 91       	lpm	r24, Z
	volatile uint8_t *reg, *out;

	if (port == NOT_A_PIN) return;
    1a3a:	88 23       	and	r24, r24
    1a3c:	61 f1       	breq	.+88     	; 0x1a96 <pinMode+0x72>

	// JWS: can I let the optimizer do this?
	reg = portModeRegister(port);
    1a3e:	90 e0       	ldi	r25, 0x00	; 0
    1a40:	88 0f       	add	r24, r24
    1a42:	99 1f       	adc	r25, r25
    1a44:	fc 01       	movw	r30, r24
    1a46:	e8 52       	subi	r30, 0x28	; 40
    1a48:	ff 4f       	sbci	r31, 0xFF	; 255
    1a4a:	c5 91       	lpm	r28, Z+
    1a4c:	d4 91       	lpm	r29, Z
	out = portOutputRegister(port);
    1a4e:	fc 01       	movw	r30, r24
    1a50:	e2 53       	subi	r30, 0x32	; 50
    1a52:	ff 4f       	sbci	r31, 0xFF	; 255
    1a54:	a5 91       	lpm	r26, Z+
    1a56:	b4 91       	lpm	r27, Z

	if (mode == INPUT) { 
    1a58:	61 11       	cpse	r22, r1
    1a5a:	09 c0       	rjmp	.+18     	; 0x1a6e <pinMode+0x4a>
		uint8_t oldSREG = SREG;
    1a5c:	9f b7       	in	r25, 0x3f	; 63
                cli();
    1a5e:	f8 94       	cli
		*reg &= ~bit;
    1a60:	88 81       	ld	r24, Y
    1a62:	20 95       	com	r18
    1a64:	82 23       	and	r24, r18
    1a66:	88 83       	st	Y, r24
		*out &= ~bit;
    1a68:	ec 91       	ld	r30, X
    1a6a:	2e 23       	and	r18, r30
    1a6c:	0b c0       	rjmp	.+22     	; 0x1a84 <pinMode+0x60>
		SREG = oldSREG;
	} else if (mode == INPUT_PULLUP) {
    1a6e:	62 30       	cpi	r22, 0x02	; 2
    1a70:	61 f4       	brne	.+24     	; 0x1a8a <pinMode+0x66>
		uint8_t oldSREG = SREG;
    1a72:	9f b7       	in	r25, 0x3f	; 63
                cli();
    1a74:	f8 94       	cli
		*reg &= ~bit;
    1a76:	88 81       	ld	r24, Y
    1a78:	32 2f       	mov	r19, r18
    1a7a:	30 95       	com	r19
    1a7c:	83 23       	and	r24, r19
    1a7e:	88 83       	st	Y, r24
		*out |= bit;
    1a80:	ec 91       	ld	r30, X
    1a82:	2e 2b       	or	r18, r30
    1a84:	2c 93       	st	X, r18
		SREG = oldSREG;
    1a86:	9f bf       	out	0x3f, r25	; 63
    1a88:	06 c0       	rjmp	.+12     	; 0x1a96 <pinMode+0x72>
	} else {
		uint8_t oldSREG = SREG;
    1a8a:	8f b7       	in	r24, 0x3f	; 63
                cli();
    1a8c:	f8 94       	cli
		*reg |= bit;
    1a8e:	e8 81       	ld	r30, Y
    1a90:	2e 2b       	or	r18, r30
    1a92:	28 83       	st	Y, r18
		SREG = oldSREG;
    1a94:	8f bf       	out	0x3f, r24	; 63
	}
}
    1a96:	df 91       	pop	r29
    1a98:	cf 91       	pop	r28
    1a9a:	08 95       	ret

00001a9c <digitalWrite>:
		#endif
	}
}

void digitalWrite(uint8_t pin, uint8_t val)
{
    1a9c:	1f 93       	push	r17
    1a9e:	cf 93       	push	r28
    1aa0:	df 93       	push	r29
	uint8_t timer = digitalPinToTimer(pin);
    1aa2:	28 2f       	mov	r18, r24
    1aa4:	30 e0       	ldi	r19, 0x00	; 0
    1aa6:	f9 01       	movw	r30, r18
    1aa8:	ee 56       	subi	r30, 0x6E	; 110
    1aaa:	ff 4f       	sbci	r31, 0xFF	; 255
    1aac:	84 91       	lpm	r24, Z
	uint8_t bit = digitalPinToBitMask(pin);
    1aae:	f9 01       	movw	r30, r18
    1ab0:	ea 55       	subi	r30, 0x5A	; 90
    1ab2:	ff 4f       	sbci	r31, 0xFF	; 255
    1ab4:	d4 91       	lpm	r29, Z
	uint8_t port = digitalPinToPort(pin);
    1ab6:	f9 01       	movw	r30, r18
    1ab8:	e6 54       	subi	r30, 0x46	; 70
    1aba:	ff 4f       	sbci	r31, 0xFF	; 255
    1abc:	c4 91       	lpm	r28, Z
	volatile uint8_t *out;

	if (port == NOT_A_PIN) return;
    1abe:	cc 23       	and	r28, r28
    1ac0:	c1 f0       	breq	.+48     	; 0x1af2 <digitalWrite+0x56>
    1ac2:	16 2f       	mov	r17, r22

	// If the pin that support PWM output, we need to turn it off
	// before doing a digital write.
	if (timer != NOT_ON_TIMER) turnOffPWM(timer);
    1ac4:	81 11       	cpse	r24, r1
    1ac6:	0e 94 e9 0c 	call	0x19d2	; 0x19d2 <turnOffPWM>

	out = portOutputRegister(port);
    1aca:	ec 2f       	mov	r30, r28
    1acc:	f0 e0       	ldi	r31, 0x00	; 0
    1ace:	ee 0f       	add	r30, r30
    1ad0:	ff 1f       	adc	r31, r31
    1ad2:	e2 53       	subi	r30, 0x32	; 50
    1ad4:	ff 4f       	sbci	r31, 0xFF	; 255
    1ad6:	a5 91       	lpm	r26, Z+
    1ad8:	b4 91       	lpm	r27, Z

	uint8_t oldSREG = SREG;
    1ada:	9f b7       	in	r25, 0x3f	; 63
	cli();
    1adc:	f8 94       	cli

	if (val == LOW) {
    1ade:	11 11       	cpse	r17, r1
    1ae0:	04 c0       	rjmp	.+8      	; 0x1aea <digitalWrite+0x4e>
		*out &= ~bit;
    1ae2:	8c 91       	ld	r24, X
    1ae4:	d0 95       	com	r29
    1ae6:	d8 23       	and	r29, r24
    1ae8:	02 c0       	rjmp	.+4      	; 0x1aee <digitalWrite+0x52>
	} else {
		*out |= bit;
    1aea:	ec 91       	ld	r30, X
    1aec:	de 2b       	or	r29, r30
    1aee:	dc 93       	st	X, r29
	}

	SREG = oldSREG;
    1af0:	9f bf       	out	0x3f, r25	; 63
}
    1af2:	df 91       	pop	r29
    1af4:	cf 91       	pop	r28
    1af6:	1f 91       	pop	r17
    1af8:	08 95       	ret

00001afa <prvIsQueueEmpty>:
    {
        xReturn = pdFALSE;
    }

    return xReturn;
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
    1afa:	0f b6       	in	r0, 0x3f	; 63
    1afc:	f8 94       	cli
    1afe:	0f 92       	push	r0
    1b00:	fc 01       	movw	r30, r24
    1b02:	92 8d       	ldd	r25, Z+26	; 0x1a
    1b04:	0f 90       	pop	r0
    1b06:	0f be       	out	0x3f, r0	; 63
    1b08:	81 e0       	ldi	r24, 0x01	; 1
    1b0a:	91 11       	cpse	r25, r1
    1b0c:	80 e0       	ldi	r24, 0x00	; 0
    1b0e:	08 95       	ret

00001b10 <prvCopyDataToQueue>:
    1b10:	0f 93       	push	r16
    1b12:	1f 93       	push	r17
    1b14:	cf 93       	push	r28
    1b16:	df 93       	push	r29
    1b18:	ec 01       	movw	r28, r24
    1b1a:	04 2f       	mov	r16, r20
    1b1c:	1a 8d       	ldd	r17, Y+26	; 0x1a
    1b1e:	4c 8d       	ldd	r20, Y+28	; 0x1c
    1b20:	41 11       	cpse	r20, r1
    1b22:	0b c0       	rjmp	.+22     	; 0x1b3a <prvCopyDataToQueue+0x2a>
    1b24:	88 81       	ld	r24, Y
    1b26:	99 81       	ldd	r25, Y+1	; 0x01
    1b28:	89 2b       	or	r24, r25
    1b2a:	e9 f5       	brne	.+122    	; 0x1ba6 <prvCopyDataToQueue+0x96>
    1b2c:	8c 81       	ldd	r24, Y+4	; 0x04
    1b2e:	9d 81       	ldd	r25, Y+5	; 0x05
    1b30:	0e 94 3f 16 	call	0x2c7e	; 0x2c7e <xTaskPriorityDisinherit>
    1b34:	1d 82       	std	Y+5, r1	; 0x05
    1b36:	1c 82       	std	Y+4, r1	; 0x04
    1b38:	37 c0       	rjmp	.+110    	; 0x1ba8 <prvCopyDataToQueue+0x98>
    1b3a:	50 e0       	ldi	r21, 0x00	; 0
    1b3c:	01 11       	cpse	r16, r1
    1b3e:	15 c0       	rjmp	.+42     	; 0x1b6a <prvCopyDataToQueue+0x5a>
    1b40:	8a 81       	ldd	r24, Y+2	; 0x02
    1b42:	9b 81       	ldd	r25, Y+3	; 0x03
    1b44:	0e 94 7f 1f 	call	0x3efe	; 0x3efe <memcpy>
    1b48:	2c 8d       	ldd	r18, Y+28	; 0x1c
    1b4a:	8a 81       	ldd	r24, Y+2	; 0x02
    1b4c:	9b 81       	ldd	r25, Y+3	; 0x03
    1b4e:	82 0f       	add	r24, r18
    1b50:	91 1d       	adc	r25, r1
    1b52:	9b 83       	std	Y+3, r25	; 0x03
    1b54:	8a 83       	std	Y+2, r24	; 0x02
    1b56:	2c 81       	ldd	r18, Y+4	; 0x04
    1b58:	3d 81       	ldd	r19, Y+5	; 0x05
    1b5a:	82 17       	cp	r24, r18
    1b5c:	93 07       	cpc	r25, r19
    1b5e:	18 f1       	brcs	.+70     	; 0x1ba6 <prvCopyDataToQueue+0x96>
    1b60:	88 81       	ld	r24, Y
    1b62:	99 81       	ldd	r25, Y+1	; 0x01
    1b64:	9b 83       	std	Y+3, r25	; 0x03
    1b66:	8a 83       	std	Y+2, r24	; 0x02
    1b68:	1e c0       	rjmp	.+60     	; 0x1ba6 <prvCopyDataToQueue+0x96>
    1b6a:	8e 81       	ldd	r24, Y+6	; 0x06
    1b6c:	9f 81       	ldd	r25, Y+7	; 0x07
    1b6e:	0e 94 7f 1f 	call	0x3efe	; 0x3efe <memcpy>
    1b72:	8c 8d       	ldd	r24, Y+28	; 0x1c
    1b74:	90 e0       	ldi	r25, 0x00	; 0
    1b76:	91 95       	neg	r25
    1b78:	81 95       	neg	r24
    1b7a:	91 09       	sbc	r25, r1
    1b7c:	2e 81       	ldd	r18, Y+6	; 0x06
    1b7e:	3f 81       	ldd	r19, Y+7	; 0x07
    1b80:	28 0f       	add	r18, r24
    1b82:	39 1f       	adc	r19, r25
    1b84:	3f 83       	std	Y+7, r19	; 0x07
    1b86:	2e 83       	std	Y+6, r18	; 0x06
    1b88:	48 81       	ld	r20, Y
    1b8a:	59 81       	ldd	r21, Y+1	; 0x01
    1b8c:	24 17       	cp	r18, r20
    1b8e:	35 07       	cpc	r19, r21
    1b90:	30 f4       	brcc	.+12     	; 0x1b9e <prvCopyDataToQueue+0x8e>
    1b92:	2c 81       	ldd	r18, Y+4	; 0x04
    1b94:	3d 81       	ldd	r19, Y+5	; 0x05
    1b96:	82 0f       	add	r24, r18
    1b98:	93 1f       	adc	r25, r19
    1b9a:	9f 83       	std	Y+7, r25	; 0x07
    1b9c:	8e 83       	std	Y+6, r24	; 0x06
    1b9e:	02 30       	cpi	r16, 0x02	; 2
    1ba0:	11 f4       	brne	.+4      	; 0x1ba6 <prvCopyDataToQueue+0x96>
    1ba2:	11 11       	cpse	r17, r1
    1ba4:	11 50       	subi	r17, 0x01	; 1
    1ba6:	80 e0       	ldi	r24, 0x00	; 0
    1ba8:	1f 5f       	subi	r17, 0xFF	; 255
    1baa:	1a 8f       	std	Y+26, r17	; 0x1a
    1bac:	df 91       	pop	r29
    1bae:	cf 91       	pop	r28
    1bb0:	1f 91       	pop	r17
    1bb2:	0f 91       	pop	r16
    1bb4:	08 95       	ret

00001bb6 <prvCopyDataFromQueue>:
    1bb6:	fc 01       	movw	r30, r24
    1bb8:	cb 01       	movw	r24, r22
    1bba:	44 8d       	ldd	r20, Z+28	; 0x1c
    1bbc:	44 23       	and	r20, r20
    1bbe:	a1 f0       	breq	.+40     	; 0x1be8 <prvCopyDataFromQueue+0x32>
    1bc0:	50 e0       	ldi	r21, 0x00	; 0
    1bc2:	26 81       	ldd	r18, Z+6	; 0x06
    1bc4:	37 81       	ldd	r19, Z+7	; 0x07
    1bc6:	24 0f       	add	r18, r20
    1bc8:	35 1f       	adc	r19, r21
    1bca:	37 83       	std	Z+7, r19	; 0x07
    1bcc:	26 83       	std	Z+6, r18	; 0x06
    1bce:	64 81       	ldd	r22, Z+4	; 0x04
    1bd0:	75 81       	ldd	r23, Z+5	; 0x05
    1bd2:	26 17       	cp	r18, r22
    1bd4:	37 07       	cpc	r19, r23
    1bd6:	20 f0       	brcs	.+8      	; 0x1be0 <prvCopyDataFromQueue+0x2a>
    1bd8:	20 81       	ld	r18, Z
    1bda:	31 81       	ldd	r19, Z+1	; 0x01
    1bdc:	37 83       	std	Z+7, r19	; 0x07
    1bde:	26 83       	std	Z+6, r18	; 0x06
    1be0:	66 81       	ldd	r22, Z+6	; 0x06
    1be2:	77 81       	ldd	r23, Z+7	; 0x07
    1be4:	0c 94 7f 1f 	jmp	0x3efe	; 0x3efe <memcpy>
    1be8:	08 95       	ret

00001bea <prvUnlockQueue>:
    1bea:	ef 92       	push	r14
    1bec:	ff 92       	push	r15
    1bee:	1f 93       	push	r17
    1bf0:	cf 93       	push	r28
    1bf2:	df 93       	push	r29
    1bf4:	ec 01       	movw	r28, r24
    1bf6:	0f b6       	in	r0, 0x3f	; 63
    1bf8:	f8 94       	cli
    1bfa:	0f 92       	push	r0
    1bfc:	1e 8d       	ldd	r17, Y+30	; 0x1e
    1bfe:	7c 01       	movw	r14, r24
    1c00:	81 e1       	ldi	r24, 0x11	; 17
    1c02:	e8 0e       	add	r14, r24
    1c04:	f1 1c       	adc	r15, r1
    1c06:	11 16       	cp	r1, r17
    1c08:	5c f4       	brge	.+22     	; 0x1c20 <prvUnlockQueue+0x36>
    1c0a:	89 89       	ldd	r24, Y+17	; 0x11
    1c0c:	88 23       	and	r24, r24
    1c0e:	41 f0       	breq	.+16     	; 0x1c20 <prvUnlockQueue+0x36>
    1c10:	c7 01       	movw	r24, r14
    1c12:	0e 94 4c 15 	call	0x2a98	; 0x2a98 <xTaskRemoveFromEventList>
    1c16:	81 11       	cpse	r24, r1
    1c18:	0e 94 ca 15 	call	0x2b94	; 0x2b94 <vTaskMissedYield>
    1c1c:	11 50       	subi	r17, 0x01	; 1
    1c1e:	f3 cf       	rjmp	.-26     	; 0x1c06 <prvUnlockQueue+0x1c>
    1c20:	8f ef       	ldi	r24, 0xFF	; 255
    1c22:	8e 8f       	std	Y+30, r24	; 0x1e
    1c24:	0f 90       	pop	r0
    1c26:	0f be       	out	0x3f, r0	; 63
    1c28:	0f b6       	in	r0, 0x3f	; 63
    1c2a:	f8 94       	cli
    1c2c:	0f 92       	push	r0
    1c2e:	1d 8d       	ldd	r17, Y+29	; 0x1d
    1c30:	7e 01       	movw	r14, r28
    1c32:	88 e0       	ldi	r24, 0x08	; 8
    1c34:	e8 0e       	add	r14, r24
    1c36:	f1 1c       	adc	r15, r1
    1c38:	11 16       	cp	r1, r17
    1c3a:	5c f4       	brge	.+22     	; 0x1c52 <prvUnlockQueue+0x68>
    1c3c:	88 85       	ldd	r24, Y+8	; 0x08
    1c3e:	88 23       	and	r24, r24
    1c40:	41 f0       	breq	.+16     	; 0x1c52 <prvUnlockQueue+0x68>
    1c42:	c7 01       	movw	r24, r14
    1c44:	0e 94 4c 15 	call	0x2a98	; 0x2a98 <xTaskRemoveFromEventList>
    1c48:	81 11       	cpse	r24, r1
    1c4a:	0e 94 ca 15 	call	0x2b94	; 0x2b94 <vTaskMissedYield>
    1c4e:	11 50       	subi	r17, 0x01	; 1
    1c50:	f3 cf       	rjmp	.-26     	; 0x1c38 <prvUnlockQueue+0x4e>
    1c52:	8f ef       	ldi	r24, 0xFF	; 255
    1c54:	8d 8f       	std	Y+29, r24	; 0x1d
    1c56:	0f 90       	pop	r0
    1c58:	0f be       	out	0x3f, r0	; 63
    1c5a:	df 91       	pop	r29
    1c5c:	cf 91       	pop	r28
    1c5e:	1f 91       	pop	r17
    1c60:	ff 90       	pop	r15
    1c62:	ef 90       	pop	r14
    1c64:	08 95       	ret

00001c66 <xQueueGenericReset>:
    1c66:	cf 93       	push	r28
    1c68:	df 93       	push	r29
    1c6a:	ec 01       	movw	r28, r24
    1c6c:	0f b6       	in	r0, 0x3f	; 63
    1c6e:	f8 94       	cli
    1c70:	0f 92       	push	r0
    1c72:	48 81       	ld	r20, Y
    1c74:	59 81       	ldd	r21, Y+1	; 0x01
    1c76:	8b 8d       	ldd	r24, Y+27	; 0x1b
    1c78:	7c 8d       	ldd	r23, Y+28	; 0x1c
    1c7a:	9a 01       	movw	r18, r20
    1c7c:	87 9f       	mul	r24, r23
    1c7e:	20 0d       	add	r18, r0
    1c80:	31 1d       	adc	r19, r1
    1c82:	11 24       	eor	r1, r1
    1c84:	3d 83       	std	Y+5, r19	; 0x05
    1c86:	2c 83       	std	Y+4, r18	; 0x04
    1c88:	1a 8e       	std	Y+26, r1	; 0x1a
    1c8a:	5b 83       	std	Y+3, r21	; 0x03
    1c8c:	4a 83       	std	Y+2, r20	; 0x02
    1c8e:	90 e0       	ldi	r25, 0x00	; 0
    1c90:	01 97       	sbiw	r24, 0x01	; 1
    1c92:	78 9f       	mul	r23, r24
    1c94:	90 01       	movw	r18, r0
    1c96:	79 9f       	mul	r23, r25
    1c98:	30 0d       	add	r19, r0
    1c9a:	11 24       	eor	r1, r1
    1c9c:	ca 01       	movw	r24, r20
    1c9e:	82 0f       	add	r24, r18
    1ca0:	93 1f       	adc	r25, r19
    1ca2:	9f 83       	std	Y+7, r25	; 0x07
    1ca4:	8e 83       	std	Y+6, r24	; 0x06
    1ca6:	8f ef       	ldi	r24, 0xFF	; 255
    1ca8:	8d 8f       	std	Y+29, r24	; 0x1d
    1caa:	8e 8f       	std	Y+30, r24	; 0x1e
    1cac:	61 11       	cpse	r22, r1
    1cae:	0c c0       	rjmp	.+24     	; 0x1cc8 <xQueueGenericReset+0x62>
    1cb0:	88 85       	ldd	r24, Y+8	; 0x08
    1cb2:	88 23       	and	r24, r24
    1cb4:	89 f0       	breq	.+34     	; 0x1cd8 <xQueueGenericReset+0x72>
    1cb6:	ce 01       	movw	r24, r28
    1cb8:	08 96       	adiw	r24, 0x08	; 8
    1cba:	0e 94 4c 15 	call	0x2a98	; 0x2a98 <xTaskRemoveFromEventList>
    1cbe:	88 23       	and	r24, r24
    1cc0:	59 f0       	breq	.+22     	; 0x1cd8 <xQueueGenericReset+0x72>
    1cc2:	0e 94 d2 1b 	call	0x37a4	; 0x37a4 <vPortYield>
    1cc6:	08 c0       	rjmp	.+16     	; 0x1cd8 <xQueueGenericReset+0x72>
    1cc8:	ce 01       	movw	r24, r28
    1cca:	08 96       	adiw	r24, 0x08	; 8
    1ccc:	0e 94 9f 1a 	call	0x353e	; 0x353e <vListInitialise>
    1cd0:	ce 01       	movw	r24, r28
    1cd2:	41 96       	adiw	r24, 0x11	; 17
    1cd4:	0e 94 9f 1a 	call	0x353e	; 0x353e <vListInitialise>
    1cd8:	0f 90       	pop	r0
    1cda:	0f be       	out	0x3f, r0	; 63
    1cdc:	81 e0       	ldi	r24, 0x01	; 1
    1cde:	df 91       	pop	r29
    1ce0:	cf 91       	pop	r28
    1ce2:	08 95       	ret

00001ce4 <xQueueGenericCreate>:
    1ce4:	0f 93       	push	r16
    1ce6:	1f 93       	push	r17
    1ce8:	cf 93       	push	r28
    1cea:	df 93       	push	r29
    1cec:	08 2f       	mov	r16, r24
    1cee:	16 2f       	mov	r17, r22
    1cf0:	66 23       	and	r22, r22
    1cf2:	21 f0       	breq	.+8      	; 0x1cfc <xQueueGenericCreate+0x18>
    1cf4:	86 9f       	mul	r24, r22
    1cf6:	c0 01       	movw	r24, r0
    1cf8:	11 24       	eor	r1, r1
    1cfa:	02 c0       	rjmp	.+4      	; 0x1d00 <xQueueGenericCreate+0x1c>
    1cfc:	80 e0       	ldi	r24, 0x00	; 0
    1cfe:	90 e0       	ldi	r25, 0x00	; 0
    1d00:	4f 96       	adiw	r24, 0x1f	; 31
    1d02:	0e 94 7b 1a 	call	0x34f6	; 0x34f6 <pvPortMalloc>
    1d06:	ec 01       	movw	r28, r24
    1d08:	00 97       	sbiw	r24, 0x00	; 0
    1d0a:	71 f0       	breq	.+28     	; 0x1d28 <xQueueGenericCreate+0x44>
    1d0c:	11 11       	cpse	r17, r1
    1d0e:	03 c0       	rjmp	.+6      	; 0x1d16 <xQueueGenericCreate+0x32>
    1d10:	99 83       	std	Y+1, r25	; 0x01
    1d12:	88 83       	st	Y, r24
    1d14:	03 c0       	rjmp	.+6      	; 0x1d1c <xQueueGenericCreate+0x38>
    1d16:	4f 96       	adiw	r24, 0x1f	; 31
    1d18:	99 83       	std	Y+1, r25	; 0x01
    1d1a:	88 83       	st	Y, r24
    1d1c:	0b 8f       	std	Y+27, r16	; 0x1b
    1d1e:	1c 8f       	std	Y+28, r17	; 0x1c
    1d20:	61 e0       	ldi	r22, 0x01	; 1
    1d22:	ce 01       	movw	r24, r28
    1d24:	0e 94 33 0e 	call	0x1c66	; 0x1c66 <xQueueGenericReset>
    1d28:	ce 01       	movw	r24, r28
    1d2a:	df 91       	pop	r29
    1d2c:	cf 91       	pop	r28
    1d2e:	1f 91       	pop	r17
    1d30:	0f 91       	pop	r16
    1d32:	08 95       	ret

00001d34 <xQueueGenericSend>:
    1d34:	af 92       	push	r10
    1d36:	bf 92       	push	r11
    1d38:	cf 92       	push	r12
    1d3a:	df 92       	push	r13
    1d3c:	ff 92       	push	r15
    1d3e:	0f 93       	push	r16
    1d40:	1f 93       	push	r17
    1d42:	cf 93       	push	r28
    1d44:	df 93       	push	r29
    1d46:	00 d0       	rcall	.+0      	; 0x1d48 <xQueueGenericSend+0x14>
    1d48:	00 d0       	rcall	.+0      	; 0x1d4a <xQueueGenericSend+0x16>
    1d4a:	1f 92       	push	r1
    1d4c:	cd b7       	in	r28, 0x3d	; 61
    1d4e:	de b7       	in	r29, 0x3e	; 62
    1d50:	8c 01       	movw	r16, r24
    1d52:	6b 01       	movw	r12, r22
    1d54:	5d 83       	std	Y+5, r21	; 0x05
    1d56:	4c 83       	std	Y+4, r20	; 0x04
    1d58:	f2 2e       	mov	r15, r18
    1d5a:	80 e0       	ldi	r24, 0x00	; 0
    1d5c:	58 01       	movw	r10, r16
    1d5e:	98 e0       	ldi	r25, 0x08	; 8
    1d60:	a9 0e       	add	r10, r25
    1d62:	b1 1c       	adc	r11, r1
    1d64:	0f b6       	in	r0, 0x3f	; 63
    1d66:	f8 94       	cli
    1d68:	0f 92       	push	r0
    1d6a:	f8 01       	movw	r30, r16
    1d6c:	22 8d       	ldd	r18, Z+26	; 0x1a
    1d6e:	93 8d       	ldd	r25, Z+27	; 0x1b
    1d70:	29 17       	cp	r18, r25
    1d72:	18 f0       	brcs	.+6      	; 0x1d7a <xQueueGenericSend+0x46>
    1d74:	f2 e0       	ldi	r31, 0x02	; 2
    1d76:	ff 12       	cpse	r15, r31
    1d78:	14 c0       	rjmp	.+40     	; 0x1da2 <xQueueGenericSend+0x6e>
    1d7a:	4f 2d       	mov	r20, r15
    1d7c:	b6 01       	movw	r22, r12
    1d7e:	c8 01       	movw	r24, r16
    1d80:	0e 94 88 0d 	call	0x1b10	; 0x1b10 <prvCopyDataToQueue>
    1d84:	f8 01       	movw	r30, r16
    1d86:	91 89       	ldd	r25, Z+17	; 0x11
    1d88:	99 23       	and	r25, r25
    1d8a:	21 f0       	breq	.+8      	; 0x1d94 <xQueueGenericSend+0x60>
    1d8c:	c8 01       	movw	r24, r16
    1d8e:	41 96       	adiw	r24, 0x11	; 17
    1d90:	0e 94 4c 15 	call	0x2a98	; 0x2a98 <xTaskRemoveFromEventList>
    1d94:	81 11       	cpse	r24, r1
    1d96:	0e 94 d2 1b 	call	0x37a4	; 0x37a4 <vPortYield>
    1d9a:	0f 90       	pop	r0
    1d9c:	0f be       	out	0x3f, r0	; 63
    1d9e:	81 e0       	ldi	r24, 0x01	; 1
    1da0:	50 c0       	rjmp	.+160    	; 0x1e42 <xQueueGenericSend+0x10e>
    1da2:	2c 81       	ldd	r18, Y+4	; 0x04
    1da4:	3d 81       	ldd	r19, Y+5	; 0x05
    1da6:	23 2b       	or	r18, r19
    1da8:	19 f4       	brne	.+6      	; 0x1db0 <xQueueGenericSend+0x7c>
    1daa:	0f 90       	pop	r0
    1dac:	0f be       	out	0x3f, r0	; 63
    1dae:	48 c0       	rjmp	.+144    	; 0x1e40 <xQueueGenericSend+0x10c>
    1db0:	81 11       	cpse	r24, r1
    1db2:	04 c0       	rjmp	.+8      	; 0x1dbc <xQueueGenericSend+0x88>
    1db4:	ce 01       	movw	r24, r28
    1db6:	01 96       	adiw	r24, 0x01	; 1
    1db8:	0e 94 8c 15 	call	0x2b18	; 0x2b18 <vTaskInternalSetTimeOutState>
    1dbc:	0f 90       	pop	r0
    1dbe:	0f be       	out	0x3f, r0	; 63
    1dc0:	0e 94 f7 12 	call	0x25ee	; 0x25ee <vTaskSuspendAll>
    1dc4:	0f b6       	in	r0, 0x3f	; 63
    1dc6:	f8 94       	cli
    1dc8:	0f 92       	push	r0
    1dca:	f8 01       	movw	r30, r16
    1dcc:	85 8d       	ldd	r24, Z+29	; 0x1d
    1dce:	8f 3f       	cpi	r24, 0xFF	; 255
    1dd0:	09 f4       	brne	.+2      	; 0x1dd4 <xQueueGenericSend+0xa0>
    1dd2:	15 8e       	std	Z+29, r1	; 0x1d
    1dd4:	f8 01       	movw	r30, r16
    1dd6:	86 8d       	ldd	r24, Z+30	; 0x1e
    1dd8:	8f 3f       	cpi	r24, 0xFF	; 255
    1dda:	09 f4       	brne	.+2      	; 0x1dde <xQueueGenericSend+0xaa>
    1ddc:	16 8e       	std	Z+30, r1	; 0x1e
    1dde:	0f 90       	pop	r0
    1de0:	0f be       	out	0x3f, r0	; 63
    1de2:	be 01       	movw	r22, r28
    1de4:	6c 5f       	subi	r22, 0xFC	; 252
    1de6:	7f 4f       	sbci	r23, 0xFF	; 255
    1de8:	ce 01       	movw	r24, r28
    1dea:	01 96       	adiw	r24, 0x01	; 1
    1dec:	0e 94 97 15 	call	0x2b2e	; 0x2b2e <xTaskCheckForTimeOut>
    1df0:	81 11       	cpse	r24, r1
    1df2:	21 c0       	rjmp	.+66     	; 0x1e36 <xQueueGenericSend+0x102>
    1df4:	0f b6       	in	r0, 0x3f	; 63
    1df6:	f8 94       	cli
    1df8:	0f 92       	push	r0
    1dfa:	f8 01       	movw	r30, r16
    1dfc:	92 8d       	ldd	r25, Z+26	; 0x1a
    1dfe:	83 8d       	ldd	r24, Z+27	; 0x1b
    1e00:	0f 90       	pop	r0
    1e02:	0f be       	out	0x3f, r0	; 63
    1e04:	98 13       	cpse	r25, r24
    1e06:	11 c0       	rjmp	.+34     	; 0x1e2a <xQueueGenericSend+0xf6>
    1e08:	6c 81       	ldd	r22, Y+4	; 0x04
    1e0a:	7d 81       	ldd	r23, Y+5	; 0x05
    1e0c:	c5 01       	movw	r24, r10
    1e0e:	0e 94 23 15 	call	0x2a46	; 0x2a46 <vTaskPlaceOnEventList>
    1e12:	c8 01       	movw	r24, r16
    1e14:	0e 94 f5 0d 	call	0x1bea	; 0x1bea <prvUnlockQueue>
    1e18:	0e 94 b3 13 	call	0x2766	; 0x2766 <xTaskResumeAll>
    1e1c:	88 23       	and	r24, r24
    1e1e:	11 f0       	breq	.+4      	; 0x1e24 <xQueueGenericSend+0xf0>
    1e20:	81 e0       	ldi	r24, 0x01	; 1
    1e22:	a0 cf       	rjmp	.-192    	; 0x1d64 <xQueueGenericSend+0x30>
    1e24:	0e 94 d2 1b 	call	0x37a4	; 0x37a4 <vPortYield>
    1e28:	fb cf       	rjmp	.-10     	; 0x1e20 <xQueueGenericSend+0xec>
    1e2a:	c8 01       	movw	r24, r16
    1e2c:	0e 94 f5 0d 	call	0x1bea	; 0x1bea <prvUnlockQueue>
    1e30:	0e 94 b3 13 	call	0x2766	; 0x2766 <xTaskResumeAll>
    1e34:	f5 cf       	rjmp	.-22     	; 0x1e20 <xQueueGenericSend+0xec>
    1e36:	c8 01       	movw	r24, r16
    1e38:	0e 94 f5 0d 	call	0x1bea	; 0x1bea <prvUnlockQueue>
    1e3c:	0e 94 b3 13 	call	0x2766	; 0x2766 <xTaskResumeAll>
    1e40:	80 e0       	ldi	r24, 0x00	; 0
    1e42:	0f 90       	pop	r0
    1e44:	0f 90       	pop	r0
    1e46:	0f 90       	pop	r0
    1e48:	0f 90       	pop	r0
    1e4a:	0f 90       	pop	r0
    1e4c:	df 91       	pop	r29
    1e4e:	cf 91       	pop	r28
    1e50:	1f 91       	pop	r17
    1e52:	0f 91       	pop	r16
    1e54:	ff 90       	pop	r15
    1e56:	df 90       	pop	r13
    1e58:	cf 90       	pop	r12
    1e5a:	bf 90       	pop	r11
    1e5c:	af 90       	pop	r10
    1e5e:	08 95       	ret

00001e60 <xQueueGenericSendFromISR>:
    1e60:	ef 92       	push	r14
    1e62:	ff 92       	push	r15
    1e64:	1f 93       	push	r17
    1e66:	cf 93       	push	r28
    1e68:	df 93       	push	r29
    1e6a:	ec 01       	movw	r28, r24
    1e6c:	9a 8d       	ldd	r25, Y+26	; 0x1a
    1e6e:	8b 8d       	ldd	r24, Y+27	; 0x1b
    1e70:	98 17       	cp	r25, r24
    1e72:	10 f0       	brcs	.+4      	; 0x1e78 <xQueueGenericSendFromISR+0x18>
    1e74:	22 30       	cpi	r18, 0x02	; 2
    1e76:	e1 f4       	brne	.+56     	; 0x1eb0 <xQueueGenericSendFromISR+0x50>
    1e78:	7a 01       	movw	r14, r20
    1e7a:	1e 8d       	ldd	r17, Y+30	; 0x1e
    1e7c:	42 2f       	mov	r20, r18
    1e7e:	ce 01       	movw	r24, r28
    1e80:	0e 94 88 0d 	call	0x1b10	; 0x1b10 <prvCopyDataToQueue>
    1e84:	1f 3f       	cpi	r17, 0xFF	; 255
    1e86:	81 f4       	brne	.+32     	; 0x1ea8 <xQueueGenericSendFromISR+0x48>
    1e88:	89 89       	ldd	r24, Y+17	; 0x11
    1e8a:	88 23       	and	r24, r24
    1e8c:	79 f0       	breq	.+30     	; 0x1eac <xQueueGenericSendFromISR+0x4c>
    1e8e:	ce 01       	movw	r24, r28
    1e90:	41 96       	adiw	r24, 0x11	; 17
    1e92:	0e 94 4c 15 	call	0x2a98	; 0x2a98 <xTaskRemoveFromEventList>
    1e96:	88 23       	and	r24, r24
    1e98:	49 f0       	breq	.+18     	; 0x1eac <xQueueGenericSendFromISR+0x4c>
    1e9a:	e1 14       	cp	r14, r1
    1e9c:	f1 04       	cpc	r15, r1
    1e9e:	31 f0       	breq	.+12     	; 0x1eac <xQueueGenericSendFromISR+0x4c>
    1ea0:	81 e0       	ldi	r24, 0x01	; 1
    1ea2:	f7 01       	movw	r30, r14
    1ea4:	80 83       	st	Z, r24
    1ea6:	05 c0       	rjmp	.+10     	; 0x1eb2 <xQueueGenericSendFromISR+0x52>
    1ea8:	1f 5f       	subi	r17, 0xFF	; 255
    1eaa:	1e 8f       	std	Y+30, r17	; 0x1e
    1eac:	81 e0       	ldi	r24, 0x01	; 1
    1eae:	01 c0       	rjmp	.+2      	; 0x1eb2 <xQueueGenericSendFromISR+0x52>
    1eb0:	80 e0       	ldi	r24, 0x00	; 0
    1eb2:	df 91       	pop	r29
    1eb4:	cf 91       	pop	r28
    1eb6:	1f 91       	pop	r17
    1eb8:	ff 90       	pop	r15
    1eba:	ef 90       	pop	r14
    1ebc:	08 95       	ret

00001ebe <xQueueReceive>:
    1ebe:	af 92       	push	r10
    1ec0:	bf 92       	push	r11
    1ec2:	cf 92       	push	r12
    1ec4:	df 92       	push	r13
    1ec6:	ff 92       	push	r15
    1ec8:	0f 93       	push	r16
    1eca:	1f 93       	push	r17
    1ecc:	cf 93       	push	r28
    1ece:	df 93       	push	r29
    1ed0:	00 d0       	rcall	.+0      	; 0x1ed2 <xQueueReceive+0x14>
    1ed2:	00 d0       	rcall	.+0      	; 0x1ed4 <xQueueReceive+0x16>
    1ed4:	1f 92       	push	r1
    1ed6:	cd b7       	in	r28, 0x3d	; 61
    1ed8:	de b7       	in	r29, 0x3e	; 62
    1eda:	8c 01       	movw	r16, r24
    1edc:	6b 01       	movw	r12, r22
    1ede:	5d 83       	std	Y+5, r21	; 0x05
    1ee0:	4c 83       	std	Y+4, r20	; 0x04
    1ee2:	80 e0       	ldi	r24, 0x00	; 0
    1ee4:	58 01       	movw	r10, r16
    1ee6:	91 e1       	ldi	r25, 0x11	; 17
    1ee8:	a9 0e       	add	r10, r25
    1eea:	b1 1c       	adc	r11, r1
    1eec:	0f b6       	in	r0, 0x3f	; 63
    1eee:	f8 94       	cli
    1ef0:	0f 92       	push	r0
    1ef2:	f8 01       	movw	r30, r16
    1ef4:	f2 8c       	ldd	r15, Z+26	; 0x1a
    1ef6:	ff 20       	and	r15, r15
    1ef8:	a9 f0       	breq	.+42     	; 0x1f24 <xQueueReceive+0x66>
    1efa:	b6 01       	movw	r22, r12
    1efc:	c8 01       	movw	r24, r16
    1efe:	0e 94 db 0d 	call	0x1bb6	; 0x1bb6 <prvCopyDataFromQueue>
    1f02:	fa 94       	dec	r15
    1f04:	f8 01       	movw	r30, r16
    1f06:	f2 8e       	std	Z+26, r15	; 0x1a
    1f08:	80 85       	ldd	r24, Z+8	; 0x08
    1f0a:	88 23       	and	r24, r24
    1f0c:	39 f0       	breq	.+14     	; 0x1f1c <xQueueReceive+0x5e>
    1f0e:	c8 01       	movw	r24, r16
    1f10:	08 96       	adiw	r24, 0x08	; 8
    1f12:	0e 94 4c 15 	call	0x2a98	; 0x2a98 <xTaskRemoveFromEventList>
    1f16:	81 11       	cpse	r24, r1
    1f18:	0e 94 d2 1b 	call	0x37a4	; 0x37a4 <vPortYield>
    1f1c:	0f 90       	pop	r0
    1f1e:	0f be       	out	0x3f, r0	; 63
    1f20:	81 e0       	ldi	r24, 0x01	; 1
    1f22:	50 c0       	rjmp	.+160    	; 0x1fc4 <xQueueReceive+0x106>
    1f24:	2c 81       	ldd	r18, Y+4	; 0x04
    1f26:	3d 81       	ldd	r19, Y+5	; 0x05
    1f28:	23 2b       	or	r18, r19
    1f2a:	19 f4       	brne	.+6      	; 0x1f32 <xQueueReceive+0x74>
    1f2c:	0f 90       	pop	r0
    1f2e:	0f be       	out	0x3f, r0	; 63
    1f30:	48 c0       	rjmp	.+144    	; 0x1fc2 <xQueueReceive+0x104>
    1f32:	81 11       	cpse	r24, r1
    1f34:	04 c0       	rjmp	.+8      	; 0x1f3e <xQueueReceive+0x80>
    1f36:	ce 01       	movw	r24, r28
    1f38:	01 96       	adiw	r24, 0x01	; 1
    1f3a:	0e 94 8c 15 	call	0x2b18	; 0x2b18 <vTaskInternalSetTimeOutState>
    1f3e:	0f 90       	pop	r0
    1f40:	0f be       	out	0x3f, r0	; 63
    1f42:	0e 94 f7 12 	call	0x25ee	; 0x25ee <vTaskSuspendAll>
    1f46:	0f b6       	in	r0, 0x3f	; 63
    1f48:	f8 94       	cli
    1f4a:	0f 92       	push	r0
    1f4c:	f8 01       	movw	r30, r16
    1f4e:	85 8d       	ldd	r24, Z+29	; 0x1d
    1f50:	8f 3f       	cpi	r24, 0xFF	; 255
    1f52:	09 f4       	brne	.+2      	; 0x1f56 <xQueueReceive+0x98>
    1f54:	15 8e       	std	Z+29, r1	; 0x1d
    1f56:	f8 01       	movw	r30, r16
    1f58:	86 8d       	ldd	r24, Z+30	; 0x1e
    1f5a:	8f 3f       	cpi	r24, 0xFF	; 255
    1f5c:	09 f4       	brne	.+2      	; 0x1f60 <xQueueReceive+0xa2>
    1f5e:	16 8e       	std	Z+30, r1	; 0x1e
    1f60:	0f 90       	pop	r0
    1f62:	0f be       	out	0x3f, r0	; 63
    1f64:	be 01       	movw	r22, r28
    1f66:	6c 5f       	subi	r22, 0xFC	; 252
    1f68:	7f 4f       	sbci	r23, 0xFF	; 255
    1f6a:	ce 01       	movw	r24, r28
    1f6c:	01 96       	adiw	r24, 0x01	; 1
    1f6e:	0e 94 97 15 	call	0x2b2e	; 0x2b2e <xTaskCheckForTimeOut>
    1f72:	81 11       	cpse	r24, r1
    1f74:	1c c0       	rjmp	.+56     	; 0x1fae <xQueueReceive+0xf0>
    1f76:	c8 01       	movw	r24, r16
    1f78:	0e 94 7d 0d 	call	0x1afa	; 0x1afa <prvIsQueueEmpty>
    1f7c:	88 23       	and	r24, r24
    1f7e:	89 f0       	breq	.+34     	; 0x1fa2 <xQueueReceive+0xe4>
    1f80:	6c 81       	ldd	r22, Y+4	; 0x04
    1f82:	7d 81       	ldd	r23, Y+5	; 0x05
    1f84:	c5 01       	movw	r24, r10
    1f86:	0e 94 23 15 	call	0x2a46	; 0x2a46 <vTaskPlaceOnEventList>
    1f8a:	c8 01       	movw	r24, r16
    1f8c:	0e 94 f5 0d 	call	0x1bea	; 0x1bea <prvUnlockQueue>
    1f90:	0e 94 b3 13 	call	0x2766	; 0x2766 <xTaskResumeAll>
    1f94:	88 23       	and	r24, r24
    1f96:	11 f0       	breq	.+4      	; 0x1f9c <xQueueReceive+0xde>
    1f98:	81 e0       	ldi	r24, 0x01	; 1
    1f9a:	a8 cf       	rjmp	.-176    	; 0x1eec <xQueueReceive+0x2e>
    1f9c:	0e 94 d2 1b 	call	0x37a4	; 0x37a4 <vPortYield>
    1fa0:	fb cf       	rjmp	.-10     	; 0x1f98 <xQueueReceive+0xda>
    1fa2:	c8 01       	movw	r24, r16
    1fa4:	0e 94 f5 0d 	call	0x1bea	; 0x1bea <prvUnlockQueue>
    1fa8:	0e 94 b3 13 	call	0x2766	; 0x2766 <xTaskResumeAll>
    1fac:	f5 cf       	rjmp	.-22     	; 0x1f98 <xQueueReceive+0xda>
    1fae:	c8 01       	movw	r24, r16
    1fb0:	0e 94 f5 0d 	call	0x1bea	; 0x1bea <prvUnlockQueue>
    1fb4:	0e 94 b3 13 	call	0x2766	; 0x2766 <xTaskResumeAll>
    1fb8:	c8 01       	movw	r24, r16
    1fba:	0e 94 7d 0d 	call	0x1afa	; 0x1afa <prvIsQueueEmpty>
    1fbe:	88 23       	and	r24, r24
    1fc0:	59 f3       	breq	.-42     	; 0x1f98 <xQueueReceive+0xda>
    1fc2:	80 e0       	ldi	r24, 0x00	; 0
    1fc4:	0f 90       	pop	r0
    1fc6:	0f 90       	pop	r0
    1fc8:	0f 90       	pop	r0
    1fca:	0f 90       	pop	r0
    1fcc:	0f 90       	pop	r0
    1fce:	df 91       	pop	r29
    1fd0:	cf 91       	pop	r28
    1fd2:	1f 91       	pop	r17
    1fd4:	0f 91       	pop	r16
    1fd6:	ff 90       	pop	r15
    1fd8:	df 90       	pop	r13
    1fda:	cf 90       	pop	r12
    1fdc:	bf 90       	pop	r11
    1fde:	af 90       	pop	r10
    1fe0:	08 95       	ret

00001fe2 <xQueueSemaphoreTake>:
    1fe2:	cf 92       	push	r12
    1fe4:	df 92       	push	r13
    1fe6:	ff 92       	push	r15
    1fe8:	0f 93       	push	r16
    1fea:	1f 93       	push	r17
    1fec:	cf 93       	push	r28
    1fee:	df 93       	push	r29
    1ff0:	00 d0       	rcall	.+0      	; 0x1ff2 <xQueueSemaphoreTake+0x10>
    1ff2:	00 d0       	rcall	.+0      	; 0x1ff4 <xQueueSemaphoreTake+0x12>
    1ff4:	1f 92       	push	r1
    1ff6:	cd b7       	in	r28, 0x3d	; 61
    1ff8:	de b7       	in	r29, 0x3e	; 62
    1ffa:	8c 01       	movw	r16, r24
    1ffc:	7d 83       	std	Y+5, r23	; 0x05
    1ffe:	6c 83       	std	Y+4, r22	; 0x04
    2000:	f1 2c       	mov	r15, r1
    2002:	90 e0       	ldi	r25, 0x00	; 0
    2004:	68 01       	movw	r12, r16
    2006:	81 e1       	ldi	r24, 0x11	; 17
    2008:	c8 0e       	add	r12, r24
    200a:	d1 1c       	adc	r13, r1
    200c:	0f b6       	in	r0, 0x3f	; 63
    200e:	f8 94       	cli
    2010:	0f 92       	push	r0
    2012:	d8 01       	movw	r26, r16
    2014:	5a 96       	adiw	r26, 0x1a	; 26
    2016:	8c 91       	ld	r24, X
    2018:	5a 97       	sbiw	r26, 0x1a	; 26
    201a:	88 23       	and	r24, r24
    201c:	e9 f0       	breq	.+58     	; 0x2058 <xQueueSemaphoreTake+0x76>
    201e:	81 50       	subi	r24, 0x01	; 1
    2020:	5a 96       	adiw	r26, 0x1a	; 26
    2022:	8c 93       	st	X, r24
    2024:	5a 97       	sbiw	r26, 0x1a	; 26
    2026:	8d 91       	ld	r24, X+
    2028:	9c 91       	ld	r25, X
    202a:	89 2b       	or	r24, r25
    202c:	29 f4       	brne	.+10     	; 0x2038 <xQueueSemaphoreTake+0x56>
    202e:	0e 94 c0 16 	call	0x2d80	; 0x2d80 <pvTaskIncrementMutexHeldCount>
    2032:	f8 01       	movw	r30, r16
    2034:	95 83       	std	Z+5, r25	; 0x05
    2036:	84 83       	std	Z+4, r24	; 0x04
    2038:	d8 01       	movw	r26, r16
    203a:	18 96       	adiw	r26, 0x08	; 8
    203c:	8c 91       	ld	r24, X
    203e:	88 23       	and	r24, r24
    2040:	39 f0       	breq	.+14     	; 0x2050 <xQueueSemaphoreTake+0x6e>
    2042:	c8 01       	movw	r24, r16
    2044:	08 96       	adiw	r24, 0x08	; 8
    2046:	0e 94 4c 15 	call	0x2a98	; 0x2a98 <xTaskRemoveFromEventList>
    204a:	81 11       	cpse	r24, r1
    204c:	0e 94 d2 1b 	call	0x37a4	; 0x37a4 <vPortYield>
    2050:	0f 90       	pop	r0
    2052:	0f be       	out	0x3f, r0	; 63
    2054:	81 e0       	ldi	r24, 0x01	; 1
    2056:	7a c0       	rjmp	.+244    	; 0x214c <xQueueSemaphoreTake+0x16a>
    2058:	2c 81       	ldd	r18, Y+4	; 0x04
    205a:	3d 81       	ldd	r19, Y+5	; 0x05
    205c:	23 2b       	or	r18, r19
    205e:	09 f4       	brne	.+2      	; 0x2062 <xQueueSemaphoreTake+0x80>
    2060:	72 c0       	rjmp	.+228    	; 0x2146 <xQueueSemaphoreTake+0x164>
    2062:	91 11       	cpse	r25, r1
    2064:	04 c0       	rjmp	.+8      	; 0x206e <xQueueSemaphoreTake+0x8c>
    2066:	ce 01       	movw	r24, r28
    2068:	01 96       	adiw	r24, 0x01	; 1
    206a:	0e 94 8c 15 	call	0x2b18	; 0x2b18 <vTaskInternalSetTimeOutState>
    206e:	0f 90       	pop	r0
    2070:	0f be       	out	0x3f, r0	; 63
    2072:	0e 94 f7 12 	call	0x25ee	; 0x25ee <vTaskSuspendAll>
    2076:	0f b6       	in	r0, 0x3f	; 63
    2078:	f8 94       	cli
    207a:	0f 92       	push	r0
    207c:	f8 01       	movw	r30, r16
    207e:	85 8d       	ldd	r24, Z+29	; 0x1d
    2080:	8f 3f       	cpi	r24, 0xFF	; 255
    2082:	09 f4       	brne	.+2      	; 0x2086 <xQueueSemaphoreTake+0xa4>
    2084:	15 8e       	std	Z+29, r1	; 0x1d
    2086:	d8 01       	movw	r26, r16
    2088:	5e 96       	adiw	r26, 0x1e	; 30
    208a:	8c 91       	ld	r24, X
    208c:	5e 97       	sbiw	r26, 0x1e	; 30
    208e:	8f 3f       	cpi	r24, 0xFF	; 255
    2090:	11 f4       	brne	.+4      	; 0x2096 <xQueueSemaphoreTake+0xb4>
    2092:	5e 96       	adiw	r26, 0x1e	; 30
    2094:	1c 92       	st	X, r1
    2096:	0f 90       	pop	r0
    2098:	0f be       	out	0x3f, r0	; 63
    209a:	be 01       	movw	r22, r28
    209c:	6c 5f       	subi	r22, 0xFC	; 252
    209e:	7f 4f       	sbci	r23, 0xFF	; 255
    20a0:	ce 01       	movw	r24, r28
    20a2:	01 96       	adiw	r24, 0x01	; 1
    20a4:	0e 94 97 15 	call	0x2b2e	; 0x2b2e <xTaskCheckForTimeOut>
    20a8:	81 11       	cpse	r24, r1
    20aa:	2b c0       	rjmp	.+86     	; 0x2102 <xQueueSemaphoreTake+0x120>
    20ac:	c8 01       	movw	r24, r16
    20ae:	0e 94 7d 0d 	call	0x1afa	; 0x1afa <prvIsQueueEmpty>
    20b2:	88 23       	and	r24, r24
    20b4:	01 f1       	breq	.+64     	; 0x20f6 <xQueueSemaphoreTake+0x114>
    20b6:	f8 01       	movw	r30, r16
    20b8:	80 81       	ld	r24, Z
    20ba:	91 81       	ldd	r25, Z+1	; 0x01
    20bc:	89 2b       	or	r24, r25
    20be:	51 f4       	brne	.+20     	; 0x20d4 <xQueueSemaphoreTake+0xf2>
    20c0:	0f b6       	in	r0, 0x3f	; 63
    20c2:	f8 94       	cli
    20c4:	0f 92       	push	r0
    20c6:	84 81       	ldd	r24, Z+4	; 0x04
    20c8:	95 81       	ldd	r25, Z+5	; 0x05
    20ca:	0e 94 dc 15 	call	0x2bb8	; 0x2bb8 <xTaskPriorityInherit>
    20ce:	f8 2e       	mov	r15, r24
    20d0:	0f 90       	pop	r0
    20d2:	0f be       	out	0x3f, r0	; 63
    20d4:	6c 81       	ldd	r22, Y+4	; 0x04
    20d6:	7d 81       	ldd	r23, Y+5	; 0x05
    20d8:	c6 01       	movw	r24, r12
    20da:	0e 94 23 15 	call	0x2a46	; 0x2a46 <vTaskPlaceOnEventList>
    20de:	c8 01       	movw	r24, r16
    20e0:	0e 94 f5 0d 	call	0x1bea	; 0x1bea <prvUnlockQueue>
    20e4:	0e 94 b3 13 	call	0x2766	; 0x2766 <xTaskResumeAll>
    20e8:	88 23       	and	r24, r24
    20ea:	11 f0       	breq	.+4      	; 0x20f0 <xQueueSemaphoreTake+0x10e>
    20ec:	91 e0       	ldi	r25, 0x01	; 1
    20ee:	8e cf       	rjmp	.-228    	; 0x200c <xQueueSemaphoreTake+0x2a>
    20f0:	0e 94 d2 1b 	call	0x37a4	; 0x37a4 <vPortYield>
    20f4:	fb cf       	rjmp	.-10     	; 0x20ec <xQueueSemaphoreTake+0x10a>
    20f6:	c8 01       	movw	r24, r16
    20f8:	0e 94 f5 0d 	call	0x1bea	; 0x1bea <prvUnlockQueue>
    20fc:	0e 94 b3 13 	call	0x2766	; 0x2766 <xTaskResumeAll>
    2100:	f5 cf       	rjmp	.-22     	; 0x20ec <xQueueSemaphoreTake+0x10a>
    2102:	c8 01       	movw	r24, r16
    2104:	0e 94 f5 0d 	call	0x1bea	; 0x1bea <prvUnlockQueue>
    2108:	0e 94 b3 13 	call	0x2766	; 0x2766 <xTaskResumeAll>
    210c:	c8 01       	movw	r24, r16
    210e:	0e 94 7d 0d 	call	0x1afa	; 0x1afa <prvIsQueueEmpty>
    2112:	88 23       	and	r24, r24
    2114:	59 f3       	breq	.-42     	; 0x20ec <xQueueSemaphoreTake+0x10a>
    2116:	ff 20       	and	r15, r15
    2118:	c1 f0       	breq	.+48     	; 0x214a <xQueueSemaphoreTake+0x168>
    211a:	0f b6       	in	r0, 0x3f	; 63
    211c:	f8 94       	cli
    211e:	0f 92       	push	r0
    2120:	f8 01       	movw	r30, r16
    2122:	81 89       	ldd	r24, Z+17	; 0x11
    2124:	88 23       	and	r24, r24
    2126:	39 f0       	breq	.+14     	; 0x2136 <xQueueSemaphoreTake+0x154>
    2128:	06 88       	ldd	r0, Z+22	; 0x16
    212a:	f7 89       	ldd	r31, Z+23	; 0x17
    212c:	e0 2d       	mov	r30, r0
    212e:	80 81       	ld	r24, Z
    2130:	64 e0       	ldi	r22, 0x04	; 4
    2132:	68 1b       	sub	r22, r24
    2134:	01 c0       	rjmp	.+2      	; 0x2138 <xQueueSemaphoreTake+0x156>
    2136:	60 e0       	ldi	r22, 0x00	; 0
    2138:	d8 01       	movw	r26, r16
    213a:	14 96       	adiw	r26, 0x04	; 4
    213c:	8d 91       	ld	r24, X+
    213e:	9c 91       	ld	r25, X
    2140:	15 97       	sbiw	r26, 0x05	; 5
    2142:	0e 94 79 16 	call	0x2cf2	; 0x2cf2 <vTaskPriorityDisinheritAfterTimeout>
    2146:	0f 90       	pop	r0
    2148:	0f be       	out	0x3f, r0	; 63
    214a:	80 e0       	ldi	r24, 0x00	; 0
    214c:	0f 90       	pop	r0
    214e:	0f 90       	pop	r0
    2150:	0f 90       	pop	r0
    2152:	0f 90       	pop	r0
    2154:	0f 90       	pop	r0
    2156:	df 91       	pop	r29
    2158:	cf 91       	pop	r28
    215a:	1f 91       	pop	r17
    215c:	0f 91       	pop	r16
    215e:	ff 90       	pop	r15
    2160:	df 90       	pop	r13
    2162:	cf 90       	pop	r12
    2164:	08 95       	ret

00002166 <vQueueWaitForMessageRestricted>:
/*-----------------------------------------------------------*/

#if ( configUSE_TIMERS == 1 )

    void vQueueWaitForMessageRestricted( QueueHandle_t xQueue, TickType_t xTicksToWait, const BaseType_t xWaitIndefinitely )
    {
    2166:	cf 93       	push	r28
    2168:	df 93       	push	r29
    216a:	ec 01       	movw	r28, r24
        will not actually cause the task to block, just place it on a blocked
        list.  It will not block until the scheduler is unlocked - at which
        time a yield will be performed.  If an item is added to the queue while
        the queue is locked, and the calling task blocks on the queue, then the
        calling task will be immediately unblocked when the queue is unlocked. */
        prvLockQueue( pxQueue );
    216c:	0f b6       	in	r0, 0x3f	; 63
    216e:	f8 94       	cli
    2170:	0f 92       	push	r0
    2172:	8d 8d       	ldd	r24, Y+29	; 0x1d
    2174:	8f 3f       	cpi	r24, 0xFF	; 255
    2176:	09 f4       	brne	.+2      	; 0x217a <vQueueWaitForMessageRestricted+0x14>
    2178:	1d 8e       	std	Y+29, r1	; 0x1d
    217a:	8e 8d       	ldd	r24, Y+30	; 0x1e
    217c:	8f 3f       	cpi	r24, 0xFF	; 255
    217e:	09 f4       	brne	.+2      	; 0x2182 <vQueueWaitForMessageRestricted+0x1c>
    2180:	1e 8e       	std	Y+30, r1	; 0x1e
    2182:	0f 90       	pop	r0
    2184:	0f be       	out	0x3f, r0	; 63
        if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0U )
    2186:	8a 8d       	ldd	r24, Y+26	; 0x1a
    2188:	81 11       	cpse	r24, r1
    218a:	04 c0       	rjmp	.+8      	; 0x2194 <vQueueWaitForMessageRestricted+0x2e>
        {
            /* There is nothing in the queue, block for the specified period. */
            vTaskPlaceOnEventListRestricted( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait, xWaitIndefinitely );
    218c:	ce 01       	movw	r24, r28
    218e:	41 96       	adiw	r24, 0x11	; 17
    2190:	0e 94 34 15 	call	0x2a68	; 0x2a68 <vTaskPlaceOnEventListRestricted>
        }
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }
        prvUnlockQueue( pxQueue );
    2194:	ce 01       	movw	r24, r28
    }
    2196:	df 91       	pop	r29
    2198:	cf 91       	pop	r28
        }
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }
        prvUnlockQueue( pxQueue );
    219a:	0c 94 f5 0d 	jmp	0x1bea	; 0x1bea <prvUnlockQueue>

0000219e <prvResetNextTaskUnblockTime>:
    /* Reset the event list item to its normal value - so it can be used with
    queues and semaphores. */
    listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */

    return uxReturn;
}
    219e:	e0 91 7f 03 	lds	r30, 0x037F	; 0x80037f <pxDelayedTaskList>
    21a2:	f0 91 80 03 	lds	r31, 0x0380	; 0x800380 <pxDelayedTaskList+0x1>
    21a6:	80 81       	ld	r24, Z
    21a8:	81 11       	cpse	r24, r1
    21aa:	03 c0       	rjmp	.+6      	; 0x21b2 <prvResetNextTaskUnblockTime+0x14>
    21ac:	8f ef       	ldi	r24, 0xFF	; 255
    21ae:	9f ef       	ldi	r25, 0xFF	; 255
    21b0:	0c c0       	rjmp	.+24     	; 0x21ca <prvResetNextTaskUnblockTime+0x2c>
    21b2:	e0 91 7f 03 	lds	r30, 0x037F	; 0x80037f <pxDelayedTaskList>
    21b6:	f0 91 80 03 	lds	r31, 0x0380	; 0x800380 <pxDelayedTaskList+0x1>
    21ba:	05 80       	ldd	r0, Z+5	; 0x05
    21bc:	f6 81       	ldd	r31, Z+6	; 0x06
    21be:	e0 2d       	mov	r30, r0
    21c0:	06 80       	ldd	r0, Z+6	; 0x06
    21c2:	f7 81       	ldd	r31, Z+7	; 0x07
    21c4:	e0 2d       	mov	r30, r0
    21c6:	82 81       	ldd	r24, Z+2	; 0x02
    21c8:	93 81       	ldd	r25, Z+3	; 0x03
    21ca:	90 93 57 03 	sts	0x0357, r25	; 0x800357 <xNextTaskUnblockTime+0x1>
    21ce:	80 93 56 03 	sts	0x0356, r24	; 0x800356 <xNextTaskUnblockTime>
    21d2:	08 95       	ret

000021d4 <prvAddCurrentTaskToDelayedList>:
    21d4:	ff 92       	push	r15
    21d6:	0f 93       	push	r16
    21d8:	1f 93       	push	r17
    21da:	cf 93       	push	r28
    21dc:	df 93       	push	r29
    21de:	ec 01       	movw	r28, r24
    21e0:	f6 2e       	mov	r15, r22
    21e2:	00 91 5e 03 	lds	r16, 0x035E	; 0x80035e <xTickCount>
    21e6:	10 91 5f 03 	lds	r17, 0x035F	; 0x80035f <xTickCount+0x1>
    21ea:	80 91 b7 03 	lds	r24, 0x03B7	; 0x8003b7 <pxCurrentTCB>
    21ee:	90 91 b8 03 	lds	r25, 0x03B8	; 0x8003b8 <pxCurrentTCB+0x1>
    21f2:	02 96       	adiw	r24, 0x02	; 2
    21f4:	0e 94 0a 1b 	call	0x3614	; 0x3614 <uxListRemove>
    21f8:	cf 3f       	cpi	r28, 0xFF	; 255
    21fa:	8f ef       	ldi	r24, 0xFF	; 255
    21fc:	d8 07       	cpc	r29, r24
    21fe:	89 f4       	brne	.+34     	; 0x2222 <prvAddCurrentTaskToDelayedList+0x4e>
    2200:	ff 20       	and	r15, r15
    2202:	79 f0       	breq	.+30     	; 0x2222 <prvAddCurrentTaskToDelayedList+0x4e>
    2204:	60 91 b7 03 	lds	r22, 0x03B7	; 0x8003b7 <pxCurrentTCB>
    2208:	70 91 b8 03 	lds	r23, 0x03B8	; 0x8003b8 <pxCurrentTCB+0x1>
    220c:	6e 5f       	subi	r22, 0xFE	; 254
    220e:	7f 4f       	sbci	r23, 0xFF	; 255
    2210:	81 e6       	ldi	r24, 0x61	; 97
    2212:	93 e0       	ldi	r25, 0x03	; 3
    2214:	df 91       	pop	r29
    2216:	cf 91       	pop	r28
    2218:	1f 91       	pop	r17
    221a:	0f 91       	pop	r16
    221c:	ff 90       	pop	r15
    221e:	0c 94 b1 1a 	jmp	0x3562	; 0x3562 <vListInsertEnd>
    2222:	c0 0f       	add	r28, r16
    2224:	d1 1f       	adc	r29, r17
    2226:	e0 91 b7 03 	lds	r30, 0x03B7	; 0x8003b7 <pxCurrentTCB>
    222a:	f0 91 b8 03 	lds	r31, 0x03B8	; 0x8003b8 <pxCurrentTCB+0x1>
    222e:	d3 83       	std	Z+3, r29	; 0x03
    2230:	c2 83       	std	Z+2, r28	; 0x02
    2232:	60 91 b7 03 	lds	r22, 0x03B7	; 0x8003b7 <pxCurrentTCB>
    2236:	70 91 b8 03 	lds	r23, 0x03B8	; 0x8003b8 <pxCurrentTCB+0x1>
    223a:	c0 17       	cp	r28, r16
    223c:	d1 07       	cpc	r29, r17
    223e:	68 f4       	brcc	.+26     	; 0x225a <prvAddCurrentTaskToDelayedList+0x86>
    2240:	80 91 7d 03 	lds	r24, 0x037D	; 0x80037d <pxOverflowDelayedTaskList>
    2244:	90 91 7e 03 	lds	r25, 0x037E	; 0x80037e <pxOverflowDelayedTaskList+0x1>
    2248:	6e 5f       	subi	r22, 0xFE	; 254
    224a:	7f 4f       	sbci	r23, 0xFF	; 255
    224c:	df 91       	pop	r29
    224e:	cf 91       	pop	r28
    2250:	1f 91       	pop	r17
    2252:	0f 91       	pop	r16
    2254:	ff 90       	pop	r15
    2256:	0c 94 d2 1a 	jmp	0x35a4	; 0x35a4 <vListInsert>
    225a:	80 91 7f 03 	lds	r24, 0x037F	; 0x80037f <pxDelayedTaskList>
    225e:	90 91 80 03 	lds	r25, 0x0380	; 0x800380 <pxDelayedTaskList+0x1>
    2262:	6e 5f       	subi	r22, 0xFE	; 254
    2264:	7f 4f       	sbci	r23, 0xFF	; 255
    2266:	0e 94 d2 1a 	call	0x35a4	; 0x35a4 <vListInsert>
    226a:	80 91 56 03 	lds	r24, 0x0356	; 0x800356 <xNextTaskUnblockTime>
    226e:	90 91 57 03 	lds	r25, 0x0357	; 0x800357 <xNextTaskUnblockTime+0x1>
    2272:	c8 17       	cp	r28, r24
    2274:	d9 07       	cpc	r29, r25
    2276:	20 f4       	brcc	.+8      	; 0x2280 <prvAddCurrentTaskToDelayedList+0xac>
    2278:	d0 93 57 03 	sts	0x0357, r29	; 0x800357 <xNextTaskUnblockTime+0x1>
    227c:	c0 93 56 03 	sts	0x0356, r28	; 0x800356 <xNextTaskUnblockTime>
    2280:	df 91       	pop	r29
    2282:	cf 91       	pop	r28
    2284:	1f 91       	pop	r17
    2286:	0f 91       	pop	r16
    2288:	ff 90       	pop	r15
    228a:	08 95       	ret

0000228c <prvIdleTask>:
    228c:	80 91 6a 03 	lds	r24, 0x036A	; 0x80036a <uxDeletedTasksWaitingCleanUp>
    2290:	88 23       	and	r24, r24
    2292:	09 f1       	breq	.+66     	; 0x22d6 <prvIdleTask+0x4a>
    2294:	0f b6       	in	r0, 0x3f	; 63
    2296:	f8 94       	cli
    2298:	0f 92       	push	r0
    229a:	e0 91 70 03 	lds	r30, 0x0370	; 0x800370 <xTasksWaitingTermination+0x5>
    229e:	f0 91 71 03 	lds	r31, 0x0371	; 0x800371 <xTasksWaitingTermination+0x6>
    22a2:	c6 81       	ldd	r28, Z+6	; 0x06
    22a4:	d7 81       	ldd	r29, Z+7	; 0x07
    22a6:	ce 01       	movw	r24, r28
    22a8:	02 96       	adiw	r24, 0x02	; 2
    22aa:	0e 94 0a 1b 	call	0x3614	; 0x3614 <uxListRemove>
    22ae:	80 91 60 03 	lds	r24, 0x0360	; 0x800360 <uxCurrentNumberOfTasks>
    22b2:	81 50       	subi	r24, 0x01	; 1
    22b4:	80 93 60 03 	sts	0x0360, r24	; 0x800360 <uxCurrentNumberOfTasks>
    22b8:	80 91 6a 03 	lds	r24, 0x036A	; 0x80036a <uxDeletedTasksWaitingCleanUp>
    22bc:	81 50       	subi	r24, 0x01	; 1
    22be:	80 93 6a 03 	sts	0x036A, r24	; 0x80036a <uxDeletedTasksWaitingCleanUp>
    22c2:	0f 90       	pop	r0
    22c4:	0f be       	out	0x3f, r0	; 63
    22c6:	8f 89       	ldd	r24, Y+23	; 0x17
    22c8:	98 8d       	ldd	r25, Y+24	; 0x18
    22ca:	0e 94 8e 1a 	call	0x351c	; 0x351c <vPortFree>
    22ce:	ce 01       	movw	r24, r28
    22d0:	0e 94 8e 1a 	call	0x351c	; 0x351c <vPortFree>
    22d4:	db cf       	rjmp	.-74     	; 0x228c <prvIdleTask>
    22d6:	80 91 93 03 	lds	r24, 0x0393	; 0x800393 <pxReadyTasksLists>
    22da:	82 30       	cpi	r24, 0x02	; 2
    22dc:	10 f0       	brcs	.+4      	; 0x22e2 <prvIdleTask+0x56>
    22de:	0e 94 d2 1b 	call	0x37a4	; 0x37a4 <vPortYield>
    22e2:	0e 94 dd 18 	call	0x31ba	; 0x31ba <vApplicationIdleHook>
    22e6:	d2 cf       	rjmp	.-92     	; 0x228c <prvIdleTask>

000022e8 <xTaskCreate>:
    22e8:	5f 92       	push	r5
    22ea:	6f 92       	push	r6
    22ec:	7f 92       	push	r7
    22ee:	8f 92       	push	r8
    22f0:	9f 92       	push	r9
    22f2:	af 92       	push	r10
    22f4:	bf 92       	push	r11
    22f6:	cf 92       	push	r12
    22f8:	df 92       	push	r13
    22fa:	ef 92       	push	r14
    22fc:	ff 92       	push	r15
    22fe:	0f 93       	push	r16
    2300:	1f 93       	push	r17
    2302:	cf 93       	push	r28
    2304:	df 93       	push	r29
    2306:	3c 01       	movw	r6, r24
    2308:	6b 01       	movw	r12, r22
    230a:	5a 01       	movw	r10, r20
    230c:	49 01       	movw	r8, r18
    230e:	50 2e       	mov	r5, r16
    2310:	ca 01       	movw	r24, r20
    2312:	0e 94 7b 1a 	call	0x34f6	; 0x34f6 <pvPortMalloc>
    2316:	8c 01       	movw	r16, r24
    2318:	89 2b       	or	r24, r25
    231a:	09 f4       	brne	.+2      	; 0x231e <xTaskCreate+0x36>
    231c:	e0 c0       	rjmp	.+448    	; 0x24de <xTaskCreate+0x1f6>
    231e:	88 e2       	ldi	r24, 0x28	; 40
    2320:	90 e0       	ldi	r25, 0x00	; 0
    2322:	0e 94 7b 1a 	call	0x34f6	; 0x34f6 <pvPortMalloc>
    2326:	ec 01       	movw	r28, r24
    2328:	89 2b       	or	r24, r25
    232a:	c9 f0       	breq	.+50     	; 0x235e <xTaskCreate+0x76>
    232c:	18 8f       	std	Y+24, r17	; 0x18
    232e:	0f 8b       	std	Y+23, r16	; 0x17
    2330:	a5 01       	movw	r20, r10
    2332:	65 ea       	ldi	r22, 0xA5	; 165
    2334:	70 e0       	ldi	r23, 0x00	; 0
    2336:	c8 01       	movw	r24, r16
    2338:	0e 94 88 1f 	call	0x3f10	; 0x3f10 <memset>
    233c:	21 e0       	ldi	r18, 0x01	; 1
    233e:	a2 1a       	sub	r10, r18
    2340:	b1 08       	sbc	r11, r1
    2342:	8f 89       	ldd	r24, Y+23	; 0x17
    2344:	98 8d       	ldd	r25, Y+24	; 0x18
    2346:	a8 0e       	add	r10, r24
    2348:	b9 1e       	adc	r11, r25
    234a:	c1 14       	cp	r12, r1
    234c:	d1 04       	cpc	r13, r1
    234e:	c9 f0       	breq	.+50     	; 0x2382 <xTaskCreate+0x9a>
    2350:	be 01       	movw	r22, r28
    2352:	67 5e       	subi	r22, 0xE7	; 231
    2354:	7f 4f       	sbci	r23, 0xFF	; 255
    2356:	f6 01       	movw	r30, r12
    2358:	c6 01       	movw	r24, r12
    235a:	08 96       	adiw	r24, 0x08	; 8
    235c:	07 c0       	rjmp	.+14     	; 0x236c <xTaskCreate+0x84>
    235e:	c8 01       	movw	r24, r16
    2360:	0e 94 8e 1a 	call	0x351c	; 0x351c <vPortFree>
    2364:	bc c0       	rjmp	.+376    	; 0x24de <xTaskCreate+0x1f6>
    2366:	e8 17       	cp	r30, r24
    2368:	f9 07       	cpc	r31, r25
    236a:	49 f0       	breq	.+18     	; 0x237e <xTaskCreate+0x96>
    236c:	9f 01       	movw	r18, r30
    236e:	41 91       	ld	r20, Z+
    2370:	db 01       	movw	r26, r22
    2372:	4d 93       	st	X+, r20
    2374:	bd 01       	movw	r22, r26
    2376:	d9 01       	movw	r26, r18
    2378:	2c 91       	ld	r18, X
    237a:	21 11       	cpse	r18, r1
    237c:	f4 cf       	rjmp	.-24     	; 0x2366 <xTaskCreate+0x7e>
    237e:	18 a2       	std	Y+32, r1	; 0x20
    2380:	01 c0       	rjmp	.+2      	; 0x2384 <xTaskCreate+0x9c>
    2382:	19 8e       	std	Y+25, r1	; 0x19
    2384:	05 2d       	mov	r16, r5
    2386:	04 30       	cpi	r16, 0x04	; 4
    2388:	08 f0       	brcs	.+2      	; 0x238c <xTaskCreate+0xa4>
    238a:	03 e0       	ldi	r16, 0x03	; 3
    238c:	0e 8b       	std	Y+22, r16	; 0x16
    238e:	09 a3       	std	Y+33, r16	; 0x21
    2390:	1a a2       	std	Y+34, r1	; 0x22
    2392:	6e 01       	movw	r12, r28
    2394:	b2 e0       	ldi	r27, 0x02	; 2
    2396:	cb 0e       	add	r12, r27
    2398:	d1 1c       	adc	r13, r1
    239a:	c6 01       	movw	r24, r12
    239c:	0e 94 ad 1a 	call	0x355a	; 0x355a <vListInitialiseItem>
    23a0:	ce 01       	movw	r24, r28
    23a2:	0c 96       	adiw	r24, 0x0c	; 12
    23a4:	0e 94 ad 1a 	call	0x355a	; 0x355a <vListInitialiseItem>
    23a8:	d9 87       	std	Y+9, r29	; 0x09
    23aa:	c8 87       	std	Y+8, r28	; 0x08
    23ac:	84 e0       	ldi	r24, 0x04	; 4
    23ae:	90 e0       	ldi	r25, 0x00	; 0
    23b0:	80 1b       	sub	r24, r16
    23b2:	91 09       	sbc	r25, r1
    23b4:	9d 87       	std	Y+13, r25	; 0x0d
    23b6:	8c 87       	std	Y+12, r24	; 0x0c
    23b8:	db 8b       	std	Y+19, r29	; 0x13
    23ba:	ca 8b       	std	Y+18, r28	; 0x12
    23bc:	1b a2       	std	Y+35, r1	; 0x23
    23be:	1c a2       	std	Y+36, r1	; 0x24
    23c0:	1d a2       	std	Y+37, r1	; 0x25
    23c2:	1e a2       	std	Y+38, r1	; 0x26
    23c4:	1f a2       	std	Y+39, r1	; 0x27
    23c6:	a4 01       	movw	r20, r8
    23c8:	b3 01       	movw	r22, r6
    23ca:	c5 01       	movw	r24, r10
    23cc:	0e 94 2e 1b 	call	0x365c	; 0x365c <pxPortInitialiseStack>
    23d0:	99 83       	std	Y+1, r25	; 0x01
    23d2:	88 83       	st	Y, r24
    23d4:	e1 14       	cp	r14, r1
    23d6:	f1 04       	cpc	r15, r1
    23d8:	19 f0       	breq	.+6      	; 0x23e0 <xTaskCreate+0xf8>
    23da:	f7 01       	movw	r30, r14
    23dc:	d1 83       	std	Z+1, r29	; 0x01
    23de:	c0 83       	st	Z, r28
    23e0:	0f b6       	in	r0, 0x3f	; 63
    23e2:	f8 94       	cli
    23e4:	0f 92       	push	r0
    23e6:	80 91 60 03 	lds	r24, 0x0360	; 0x800360 <uxCurrentNumberOfTasks>
    23ea:	8f 5f       	subi	r24, 0xFF	; 255
    23ec:	80 93 60 03 	sts	0x0360, r24	; 0x800360 <uxCurrentNumberOfTasks>
    23f0:	80 91 b7 03 	lds	r24, 0x03B7	; 0x8003b7 <pxCurrentTCB>
    23f4:	90 91 b8 03 	lds	r25, 0x03B8	; 0x8003b8 <pxCurrentTCB+0x1>
    23f8:	89 2b       	or	r24, r25
    23fa:	d1 f5       	brne	.+116    	; 0x2470 <xTaskCreate+0x188>
    23fc:	d0 93 b8 03 	sts	0x03B8, r29	; 0x8003b8 <pxCurrentTCB+0x1>
    2400:	c0 93 b7 03 	sts	0x03B7, r28	; 0x8003b7 <pxCurrentTCB>
    2404:	80 91 60 03 	lds	r24, 0x0360	; 0x800360 <uxCurrentNumberOfTasks>
    2408:	81 30       	cpi	r24, 0x01	; 1
    240a:	09 f0       	breq	.+2      	; 0x240e <xTaskCreate+0x126>
    240c:	41 c0       	rjmp	.+130    	; 0x2490 <xTaskCreate+0x1a8>
    240e:	83 e9       	ldi	r24, 0x93	; 147
    2410:	93 e0       	ldi	r25, 0x03	; 3
    2412:	0e 94 9f 1a 	call	0x353e	; 0x353e <vListInitialise>
    2416:	8c e9       	ldi	r24, 0x9C	; 156
    2418:	93 e0       	ldi	r25, 0x03	; 3
    241a:	0e 94 9f 1a 	call	0x353e	; 0x353e <vListInitialise>
    241e:	85 ea       	ldi	r24, 0xA5	; 165
    2420:	93 e0       	ldi	r25, 0x03	; 3
    2422:	0e 94 9f 1a 	call	0x353e	; 0x353e <vListInitialise>
    2426:	8e ea       	ldi	r24, 0xAE	; 174
    2428:	93 e0       	ldi	r25, 0x03	; 3
    242a:	0e 94 9f 1a 	call	0x353e	; 0x353e <vListInitialise>
    242e:	8a e8       	ldi	r24, 0x8A	; 138
    2430:	93 e0       	ldi	r25, 0x03	; 3
    2432:	0e 94 9f 1a 	call	0x353e	; 0x353e <vListInitialise>
    2436:	81 e8       	ldi	r24, 0x81	; 129
    2438:	93 e0       	ldi	r25, 0x03	; 3
    243a:	0e 94 9f 1a 	call	0x353e	; 0x353e <vListInitialise>
    243e:	84 e7       	ldi	r24, 0x74	; 116
    2440:	93 e0       	ldi	r25, 0x03	; 3
    2442:	0e 94 9f 1a 	call	0x353e	; 0x353e <vListInitialise>
    2446:	8b e6       	ldi	r24, 0x6B	; 107
    2448:	93 e0       	ldi	r25, 0x03	; 3
    244a:	0e 94 9f 1a 	call	0x353e	; 0x353e <vListInitialise>
    244e:	81 e6       	ldi	r24, 0x61	; 97
    2450:	93 e0       	ldi	r25, 0x03	; 3
    2452:	0e 94 9f 1a 	call	0x353e	; 0x353e <vListInitialise>
    2456:	8a e8       	ldi	r24, 0x8A	; 138
    2458:	93 e0       	ldi	r25, 0x03	; 3
    245a:	90 93 80 03 	sts	0x0380, r25	; 0x800380 <pxDelayedTaskList+0x1>
    245e:	80 93 7f 03 	sts	0x037F, r24	; 0x80037f <pxDelayedTaskList>
    2462:	81 e8       	ldi	r24, 0x81	; 129
    2464:	93 e0       	ldi	r25, 0x03	; 3
    2466:	90 93 7e 03 	sts	0x037E, r25	; 0x80037e <pxOverflowDelayedTaskList+0x1>
    246a:	80 93 7d 03 	sts	0x037D, r24	; 0x80037d <pxOverflowDelayedTaskList>
    246e:	10 c0       	rjmp	.+32     	; 0x2490 <xTaskCreate+0x1a8>
    2470:	80 91 5c 03 	lds	r24, 0x035C	; 0x80035c <xSchedulerRunning>
    2474:	81 11       	cpse	r24, r1
    2476:	0c c0       	rjmp	.+24     	; 0x2490 <xTaskCreate+0x1a8>
    2478:	e0 91 b7 03 	lds	r30, 0x03B7	; 0x8003b7 <pxCurrentTCB>
    247c:	f0 91 b8 03 	lds	r31, 0x03B8	; 0x8003b8 <pxCurrentTCB+0x1>
    2480:	96 89       	ldd	r25, Z+22	; 0x16
    2482:	8e 89       	ldd	r24, Y+22	; 0x16
    2484:	89 17       	cp	r24, r25
    2486:	20 f0       	brcs	.+8      	; 0x2490 <xTaskCreate+0x1a8>
    2488:	d0 93 b8 03 	sts	0x03B8, r29	; 0x8003b8 <pxCurrentTCB+0x1>
    248c:	c0 93 b7 03 	sts	0x03B7, r28	; 0x8003b7 <pxCurrentTCB>
    2490:	80 91 58 03 	lds	r24, 0x0358	; 0x800358 <uxTaskNumber>
    2494:	8f 5f       	subi	r24, 0xFF	; 255
    2496:	80 93 58 03 	sts	0x0358, r24	; 0x800358 <uxTaskNumber>
    249a:	8e 89       	ldd	r24, Y+22	; 0x16
    249c:	90 91 5d 03 	lds	r25, 0x035D	; 0x80035d <uxTopReadyPriority>
    24a0:	98 17       	cp	r25, r24
    24a2:	10 f4       	brcc	.+4      	; 0x24a8 <xTaskCreate+0x1c0>
    24a4:	80 93 5d 03 	sts	0x035D, r24	; 0x80035d <uxTopReadyPriority>
    24a8:	f9 e0       	ldi	r31, 0x09	; 9
    24aa:	8f 9f       	mul	r24, r31
    24ac:	c0 01       	movw	r24, r0
    24ae:	11 24       	eor	r1, r1
    24b0:	b6 01       	movw	r22, r12
    24b2:	8d 56       	subi	r24, 0x6D	; 109
    24b4:	9c 4f       	sbci	r25, 0xFC	; 252
    24b6:	0e 94 b1 1a 	call	0x3562	; 0x3562 <vListInsertEnd>
    24ba:	0f 90       	pop	r0
    24bc:	0f be       	out	0x3f, r0	; 63
    24be:	80 91 5c 03 	lds	r24, 0x035C	; 0x80035c <xSchedulerRunning>
    24c2:	88 23       	and	r24, r24
    24c4:	51 f0       	breq	.+20     	; 0x24da <xTaskCreate+0x1f2>
    24c6:	e0 91 b7 03 	lds	r30, 0x03B7	; 0x8003b7 <pxCurrentTCB>
    24ca:	f0 91 b8 03 	lds	r31, 0x03B8	; 0x8003b8 <pxCurrentTCB+0x1>
    24ce:	96 89       	ldd	r25, Z+22	; 0x16
    24d0:	8e 89       	ldd	r24, Y+22	; 0x16
    24d2:	98 17       	cp	r25, r24
    24d4:	10 f4       	brcc	.+4      	; 0x24da <xTaskCreate+0x1f2>
    24d6:	0e 94 d2 1b 	call	0x37a4	; 0x37a4 <vPortYield>
    24da:	81 e0       	ldi	r24, 0x01	; 1
    24dc:	01 c0       	rjmp	.+2      	; 0x24e0 <xTaskCreate+0x1f8>
    24de:	8f ef       	ldi	r24, 0xFF	; 255
    24e0:	df 91       	pop	r29
    24e2:	cf 91       	pop	r28
    24e4:	1f 91       	pop	r17
    24e6:	0f 91       	pop	r16
    24e8:	ff 90       	pop	r15
    24ea:	ef 90       	pop	r14
    24ec:	df 90       	pop	r13
    24ee:	cf 90       	pop	r12
    24f0:	bf 90       	pop	r11
    24f2:	af 90       	pop	r10
    24f4:	9f 90       	pop	r9
    24f6:	8f 90       	pop	r8
    24f8:	7f 90       	pop	r7
    24fa:	6f 90       	pop	r6
    24fc:	5f 90       	pop	r5
    24fe:	08 95       	ret

00002500 <vTaskResume>:
    2500:	0f 93       	push	r16
    2502:	1f 93       	push	r17
    2504:	cf 93       	push	r28
    2506:	df 93       	push	r29
    2508:	20 91 b7 03 	lds	r18, 0x03B7	; 0x8003b7 <pxCurrentTCB>
    250c:	30 91 b8 03 	lds	r19, 0x03B8	; 0x8003b8 <pxCurrentTCB+0x1>
    2510:	82 17       	cp	r24, r18
    2512:	93 07       	cpc	r25, r19
    2514:	09 f4       	brne	.+2      	; 0x2518 <vTaskResume+0x18>
    2516:	38 c0       	rjmp	.+112    	; 0x2588 <vTaskResume+0x88>
    2518:	00 97       	sbiw	r24, 0x00	; 0
    251a:	09 f4       	brne	.+2      	; 0x251e <vTaskResume+0x1e>
    251c:	35 c0       	rjmp	.+106    	; 0x2588 <vTaskResume+0x88>
    251e:	0f b6       	in	r0, 0x3f	; 63
    2520:	f8 94       	cli
    2522:	0f 92       	push	r0
    2524:	fc 01       	movw	r30, r24
    2526:	22 85       	ldd	r18, Z+10	; 0x0a
    2528:	33 85       	ldd	r19, Z+11	; 0x0b
    252a:	21 56       	subi	r18, 0x61	; 97
    252c:	33 40       	sbci	r19, 0x03	; 3
    252e:	51 f5       	brne	.+84     	; 0x2584 <vTaskResume+0x84>
    2530:	fc 01       	movw	r30, r24
    2532:	24 89       	ldd	r18, Z+20	; 0x14
    2534:	35 89       	ldd	r19, Z+21	; 0x15
    2536:	f3 e0       	ldi	r31, 0x03	; 3
    2538:	24 37       	cpi	r18, 0x74	; 116
    253a:	3f 07       	cpc	r19, r31
    253c:	19 f1       	breq	.+70     	; 0x2584 <vTaskResume+0x84>
    253e:	23 2b       	or	r18, r19
    2540:	09 f5       	brne	.+66     	; 0x2584 <vTaskResume+0x84>
    2542:	ec 01       	movw	r28, r24
    2544:	8c 01       	movw	r16, r24
    2546:	0e 5f       	subi	r16, 0xFE	; 254
    2548:	1f 4f       	sbci	r17, 0xFF	; 255
    254a:	c8 01       	movw	r24, r16
    254c:	0e 94 0a 1b 	call	0x3614	; 0x3614 <uxListRemove>
    2550:	8e 89       	ldd	r24, Y+22	; 0x16
    2552:	90 91 5d 03 	lds	r25, 0x035D	; 0x80035d <uxTopReadyPriority>
    2556:	98 17       	cp	r25, r24
    2558:	10 f4       	brcc	.+4      	; 0x255e <vTaskResume+0x5e>
    255a:	80 93 5d 03 	sts	0x035D, r24	; 0x80035d <uxTopReadyPriority>
    255e:	29 e0       	ldi	r18, 0x09	; 9
    2560:	82 9f       	mul	r24, r18
    2562:	c0 01       	movw	r24, r0
    2564:	11 24       	eor	r1, r1
    2566:	b8 01       	movw	r22, r16
    2568:	8d 56       	subi	r24, 0x6D	; 109
    256a:	9c 4f       	sbci	r25, 0xFC	; 252
    256c:	0e 94 b1 1a 	call	0x3562	; 0x3562 <vListInsertEnd>
    2570:	e0 91 b7 03 	lds	r30, 0x03B7	; 0x8003b7 <pxCurrentTCB>
    2574:	f0 91 b8 03 	lds	r31, 0x03B8	; 0x8003b8 <pxCurrentTCB+0x1>
    2578:	9e 89       	ldd	r25, Y+22	; 0x16
    257a:	86 89       	ldd	r24, Z+22	; 0x16
    257c:	98 17       	cp	r25, r24
    257e:	10 f0       	brcs	.+4      	; 0x2584 <vTaskResume+0x84>
    2580:	0e 94 d2 1b 	call	0x37a4	; 0x37a4 <vPortYield>
    2584:	0f 90       	pop	r0
    2586:	0f be       	out	0x3f, r0	; 63
    2588:	df 91       	pop	r29
    258a:	cf 91       	pop	r28
    258c:	1f 91       	pop	r17
    258e:	0f 91       	pop	r16
    2590:	08 95       	ret

00002592 <vTaskStartScheduler>:
    2592:	ef 92       	push	r14
    2594:	ff 92       	push	r15
    2596:	0f 93       	push	r16
    2598:	84 e5       	ldi	r24, 0x54	; 84
    259a:	e8 2e       	mov	r14, r24
    259c:	83 e0       	ldi	r24, 0x03	; 3
    259e:	f8 2e       	mov	r15, r24
    25a0:	00 e0       	ldi	r16, 0x00	; 0
    25a2:	20 e0       	ldi	r18, 0x00	; 0
    25a4:	30 e0       	ldi	r19, 0x00	; 0
    25a6:	40 ec       	ldi	r20, 0xC0	; 192
    25a8:	50 e0       	ldi	r21, 0x00	; 0
    25aa:	6d e9       	ldi	r22, 0x9D	; 157
    25ac:	71 e0       	ldi	r23, 0x01	; 1
    25ae:	86 e4       	ldi	r24, 0x46	; 70
    25b0:	91 e1       	ldi	r25, 0x11	; 17
    25b2:	0e 94 74 11 	call	0x22e8	; 0x22e8 <xTaskCreate>
    25b6:	81 30       	cpi	r24, 0x01	; 1
    25b8:	b1 f4       	brne	.+44     	; 0x25e6 <vTaskStartScheduler+0x54>
    25ba:	0e 94 25 17 	call	0x2e4a	; 0x2e4a <xTimerCreateTimerTask>
    25be:	81 30       	cpi	r24, 0x01	; 1
    25c0:	91 f4       	brne	.+36     	; 0x25e6 <vTaskStartScheduler+0x54>
    25c2:	f8 94       	cli
    25c4:	2f ef       	ldi	r18, 0xFF	; 255
    25c6:	3f ef       	ldi	r19, 0xFF	; 255
    25c8:	30 93 57 03 	sts	0x0357, r19	; 0x800357 <xNextTaskUnblockTime+0x1>
    25cc:	20 93 56 03 	sts	0x0356, r18	; 0x800356 <xNextTaskUnblockTime>
    25d0:	80 93 5c 03 	sts	0x035C, r24	; 0x80035c <xSchedulerRunning>
    25d4:	10 92 5f 03 	sts	0x035F, r1	; 0x80035f <xTickCount+0x1>
    25d8:	10 92 5e 03 	sts	0x035E, r1	; 0x80035e <xTickCount>
    25dc:	0f 91       	pop	r16
    25de:	ff 90       	pop	r15
    25e0:	ef 90       	pop	r14
    25e2:	0c 94 9a 1b 	jmp	0x3734	; 0x3734 <xPortStartScheduler>
    25e6:	0f 91       	pop	r16
    25e8:	ff 90       	pop	r15
    25ea:	ef 90       	pop	r14
    25ec:	08 95       	ret

000025ee <vTaskSuspendAll>:
    25ee:	80 91 53 03 	lds	r24, 0x0353	; 0x800353 <uxSchedulerSuspended>
    25f2:	8f 5f       	subi	r24, 0xFF	; 255
    25f4:	80 93 53 03 	sts	0x0353, r24	; 0x800353 <uxSchedulerSuspended>
    25f8:	08 95       	ret

000025fa <xTaskGetTickCount>:
    25fa:	0f b6       	in	r0, 0x3f	; 63
    25fc:	f8 94       	cli
    25fe:	0f 92       	push	r0
    2600:	80 91 5e 03 	lds	r24, 0x035E	; 0x80035e <xTickCount>
    2604:	90 91 5f 03 	lds	r25, 0x035F	; 0x80035f <xTickCount+0x1>
    2608:	0f 90       	pop	r0
    260a:	0f be       	out	0x3f, r0	; 63
    260c:	08 95       	ret

0000260e <xTaskIncrementTick>:
    260e:	cf 92       	push	r12
    2610:	df 92       	push	r13
    2612:	ef 92       	push	r14
    2614:	ff 92       	push	r15
    2616:	0f 93       	push	r16
    2618:	1f 93       	push	r17
    261a:	cf 93       	push	r28
    261c:	df 93       	push	r29
    261e:	80 91 53 03 	lds	r24, 0x0353	; 0x800353 <uxSchedulerSuspended>
    2622:	81 11       	cpse	r24, r1
    2624:	8c c0       	rjmp	.+280    	; 0x273e <xTaskIncrementTick+0x130>
    2626:	00 91 5e 03 	lds	r16, 0x035E	; 0x80035e <xTickCount>
    262a:	10 91 5f 03 	lds	r17, 0x035F	; 0x80035f <xTickCount+0x1>
    262e:	0f 5f       	subi	r16, 0xFF	; 255
    2630:	1f 4f       	sbci	r17, 0xFF	; 255
    2632:	10 93 5f 03 	sts	0x035F, r17	; 0x80035f <xTickCount+0x1>
    2636:	00 93 5e 03 	sts	0x035E, r16	; 0x80035e <xTickCount>
    263a:	01 15       	cp	r16, r1
    263c:	11 05       	cpc	r17, r1
    263e:	b9 f4       	brne	.+46     	; 0x266e <xTaskIncrementTick+0x60>
    2640:	80 91 7f 03 	lds	r24, 0x037F	; 0x80037f <pxDelayedTaskList>
    2644:	90 91 80 03 	lds	r25, 0x0380	; 0x800380 <pxDelayedTaskList+0x1>
    2648:	20 91 7d 03 	lds	r18, 0x037D	; 0x80037d <pxOverflowDelayedTaskList>
    264c:	30 91 7e 03 	lds	r19, 0x037E	; 0x80037e <pxOverflowDelayedTaskList+0x1>
    2650:	30 93 80 03 	sts	0x0380, r19	; 0x800380 <pxDelayedTaskList+0x1>
    2654:	20 93 7f 03 	sts	0x037F, r18	; 0x80037f <pxDelayedTaskList>
    2658:	90 93 7e 03 	sts	0x037E, r25	; 0x80037e <pxOverflowDelayedTaskList+0x1>
    265c:	80 93 7d 03 	sts	0x037D, r24	; 0x80037d <pxOverflowDelayedTaskList>
    2660:	80 91 59 03 	lds	r24, 0x0359	; 0x800359 <xNumOfOverflows>
    2664:	8f 5f       	subi	r24, 0xFF	; 255
    2666:	80 93 59 03 	sts	0x0359, r24	; 0x800359 <xNumOfOverflows>
    266a:	0e 94 cf 10 	call	0x219e	; 0x219e <prvResetNextTaskUnblockTime>
    266e:	80 91 56 03 	lds	r24, 0x0356	; 0x800356 <xNextTaskUnblockTime>
    2672:	90 91 57 03 	lds	r25, 0x0357	; 0x800357 <xNextTaskUnblockTime+0x1>
    2676:	c0 e0       	ldi	r28, 0x00	; 0
    2678:	08 17       	cp	r16, r24
    267a:	19 07       	cpc	r17, r25
    267c:	08 f4       	brcc	.+2      	; 0x2680 <xTaskIncrementTick+0x72>
    267e:	4f c0       	rjmp	.+158    	; 0x271e <xTaskIncrementTick+0x110>
    2680:	d9 e0       	ldi	r29, 0x09	; 9
    2682:	e0 91 7f 03 	lds	r30, 0x037F	; 0x80037f <pxDelayedTaskList>
    2686:	f0 91 80 03 	lds	r31, 0x0380	; 0x800380 <pxDelayedTaskList+0x1>
    268a:	80 81       	ld	r24, Z
    268c:	81 11       	cpse	r24, r1
    268e:	03 c0       	rjmp	.+6      	; 0x2696 <xTaskIncrementTick+0x88>
    2690:	8f ef       	ldi	r24, 0xFF	; 255
    2692:	9f ef       	ldi	r25, 0xFF	; 255
    2694:	11 c0       	rjmp	.+34     	; 0x26b8 <xTaskIncrementTick+0xaa>
    2696:	e0 91 7f 03 	lds	r30, 0x037F	; 0x80037f <pxDelayedTaskList>
    269a:	f0 91 80 03 	lds	r31, 0x0380	; 0x800380 <pxDelayedTaskList+0x1>
    269e:	05 80       	ldd	r0, Z+5	; 0x05
    26a0:	f6 81       	ldd	r31, Z+6	; 0x06
    26a2:	e0 2d       	mov	r30, r0
    26a4:	e6 80       	ldd	r14, Z+6	; 0x06
    26a6:	f7 80       	ldd	r15, Z+7	; 0x07
    26a8:	d7 01       	movw	r26, r14
    26aa:	12 96       	adiw	r26, 0x02	; 2
    26ac:	8d 91       	ld	r24, X+
    26ae:	9c 91       	ld	r25, X
    26b0:	13 97       	sbiw	r26, 0x03	; 3
    26b2:	08 17       	cp	r16, r24
    26b4:	19 07       	cpc	r17, r25
    26b6:	28 f4       	brcc	.+10     	; 0x26c2 <xTaskIncrementTick+0xb4>
    26b8:	90 93 57 03 	sts	0x0357, r25	; 0x800357 <xNextTaskUnblockTime+0x1>
    26bc:	80 93 56 03 	sts	0x0356, r24	; 0x800356 <xNextTaskUnblockTime>
    26c0:	2e c0       	rjmp	.+92     	; 0x271e <xTaskIncrementTick+0x110>
    26c2:	67 01       	movw	r12, r14
    26c4:	b2 e0       	ldi	r27, 0x02	; 2
    26c6:	cb 0e       	add	r12, r27
    26c8:	d1 1c       	adc	r13, r1
    26ca:	c6 01       	movw	r24, r12
    26cc:	0e 94 0a 1b 	call	0x3614	; 0x3614 <uxListRemove>
    26d0:	f7 01       	movw	r30, r14
    26d2:	84 89       	ldd	r24, Z+20	; 0x14
    26d4:	95 89       	ldd	r25, Z+21	; 0x15
    26d6:	89 2b       	or	r24, r25
    26d8:	21 f0       	breq	.+8      	; 0x26e2 <xTaskIncrementTick+0xd4>
    26da:	c7 01       	movw	r24, r14
    26dc:	0c 96       	adiw	r24, 0x0c	; 12
    26de:	0e 94 0a 1b 	call	0x3614	; 0x3614 <uxListRemove>
    26e2:	d7 01       	movw	r26, r14
    26e4:	56 96       	adiw	r26, 0x16	; 22
    26e6:	8c 91       	ld	r24, X
    26e8:	90 91 5d 03 	lds	r25, 0x035D	; 0x80035d <uxTopReadyPriority>
    26ec:	98 17       	cp	r25, r24
    26ee:	10 f4       	brcc	.+4      	; 0x26f4 <xTaskIncrementTick+0xe6>
    26f0:	80 93 5d 03 	sts	0x035D, r24	; 0x80035d <uxTopReadyPriority>
    26f4:	d8 9f       	mul	r29, r24
    26f6:	c0 01       	movw	r24, r0
    26f8:	11 24       	eor	r1, r1
    26fa:	b6 01       	movw	r22, r12
    26fc:	8d 56       	subi	r24, 0x6D	; 109
    26fe:	9c 4f       	sbci	r25, 0xFC	; 252
    2700:	0e 94 b1 1a 	call	0x3562	; 0x3562 <vListInsertEnd>
    2704:	e0 91 b7 03 	lds	r30, 0x03B7	; 0x8003b7 <pxCurrentTCB>
    2708:	f0 91 b8 03 	lds	r31, 0x03B8	; 0x8003b8 <pxCurrentTCB+0x1>
    270c:	d7 01       	movw	r26, r14
    270e:	56 96       	adiw	r26, 0x16	; 22
    2710:	9c 91       	ld	r25, X
    2712:	86 89       	ldd	r24, Z+22	; 0x16
    2714:	98 17       	cp	r25, r24
    2716:	08 f4       	brcc	.+2      	; 0x271a <xTaskIncrementTick+0x10c>
    2718:	b4 cf       	rjmp	.-152    	; 0x2682 <xTaskIncrementTick+0x74>
    271a:	c1 e0       	ldi	r28, 0x01	; 1
    271c:	b2 cf       	rjmp	.-156    	; 0x2682 <xTaskIncrementTick+0x74>
    271e:	e0 91 b7 03 	lds	r30, 0x03B7	; 0x8003b7 <pxCurrentTCB>
    2722:	f0 91 b8 03 	lds	r31, 0x03B8	; 0x8003b8 <pxCurrentTCB+0x1>
    2726:	e6 89       	ldd	r30, Z+22	; 0x16
    2728:	b9 e0       	ldi	r27, 0x09	; 9
    272a:	eb 9f       	mul	r30, r27
    272c:	f0 01       	movw	r30, r0
    272e:	11 24       	eor	r1, r1
    2730:	ed 56       	subi	r30, 0x6D	; 109
    2732:	fc 4f       	sbci	r31, 0xFC	; 252
    2734:	80 81       	ld	r24, Z
    2736:	82 30       	cpi	r24, 0x02	; 2
    2738:	40 f0       	brcs	.+16     	; 0x274a <xTaskIncrementTick+0x13c>
    273a:	c1 e0       	ldi	r28, 0x01	; 1
    273c:	06 c0       	rjmp	.+12     	; 0x274a <xTaskIncrementTick+0x13c>
    273e:	80 91 5b 03 	lds	r24, 0x035B	; 0x80035b <uxPendedTicks>
    2742:	8f 5f       	subi	r24, 0xFF	; 255
    2744:	80 93 5b 03 	sts	0x035B, r24	; 0x80035b <uxPendedTicks>
    2748:	c0 e0       	ldi	r28, 0x00	; 0
    274a:	80 91 5a 03 	lds	r24, 0x035A	; 0x80035a <xYieldPending>
    274e:	81 11       	cpse	r24, r1
    2750:	c1 e0       	ldi	r28, 0x01	; 1
    2752:	8c 2f       	mov	r24, r28
    2754:	df 91       	pop	r29
    2756:	cf 91       	pop	r28
    2758:	1f 91       	pop	r17
    275a:	0f 91       	pop	r16
    275c:	ff 90       	pop	r15
    275e:	ef 90       	pop	r14
    2760:	df 90       	pop	r13
    2762:	cf 90       	pop	r12
    2764:	08 95       	ret

00002766 <xTaskResumeAll>:
    2766:	ef 92       	push	r14
    2768:	ff 92       	push	r15
    276a:	0f 93       	push	r16
    276c:	1f 93       	push	r17
    276e:	cf 93       	push	r28
    2770:	df 93       	push	r29
    2772:	0f b6       	in	r0, 0x3f	; 63
    2774:	f8 94       	cli
    2776:	0f 92       	push	r0
    2778:	80 91 53 03 	lds	r24, 0x0353	; 0x800353 <uxSchedulerSuspended>
    277c:	81 50       	subi	r24, 0x01	; 1
    277e:	80 93 53 03 	sts	0x0353, r24	; 0x800353 <uxSchedulerSuspended>
    2782:	80 91 53 03 	lds	r24, 0x0353	; 0x800353 <uxSchedulerSuspended>
    2786:	88 23       	and	r24, r24
    2788:	11 f0       	breq	.+4      	; 0x278e <xTaskResumeAll+0x28>
    278a:	80 e0       	ldi	r24, 0x00	; 0
    278c:	52 c0       	rjmp	.+164    	; 0x2832 <xTaskResumeAll+0xcc>
    278e:	80 91 60 03 	lds	r24, 0x0360	; 0x800360 <uxCurrentNumberOfTasks>
    2792:	88 23       	and	r24, r24
    2794:	d1 f3       	breq	.-12     	; 0x278a <xTaskResumeAll+0x24>
    2796:	c0 e0       	ldi	r28, 0x00	; 0
    2798:	d0 e0       	ldi	r29, 0x00	; 0
    279a:	89 e0       	ldi	r24, 0x09	; 9
    279c:	f8 2e       	mov	r15, r24
    279e:	ee 24       	eor	r14, r14
    27a0:	e3 94       	inc	r14
    27a2:	80 91 74 03 	lds	r24, 0x0374	; 0x800374 <xPendingReadyList>
    27a6:	88 23       	and	r24, r24
    27a8:	51 f1       	breq	.+84     	; 0x27fe <xTaskResumeAll+0x98>
    27aa:	e0 91 79 03 	lds	r30, 0x0379	; 0x800379 <xPendingReadyList+0x5>
    27ae:	f0 91 7a 03 	lds	r31, 0x037A	; 0x80037a <xPendingReadyList+0x6>
    27b2:	c6 81       	ldd	r28, Z+6	; 0x06
    27b4:	d7 81       	ldd	r29, Z+7	; 0x07
    27b6:	ce 01       	movw	r24, r28
    27b8:	0c 96       	adiw	r24, 0x0c	; 12
    27ba:	0e 94 0a 1b 	call	0x3614	; 0x3614 <uxListRemove>
    27be:	8e 01       	movw	r16, r28
    27c0:	0e 5f       	subi	r16, 0xFE	; 254
    27c2:	1f 4f       	sbci	r17, 0xFF	; 255
    27c4:	c8 01       	movw	r24, r16
    27c6:	0e 94 0a 1b 	call	0x3614	; 0x3614 <uxListRemove>
    27ca:	8e 89       	ldd	r24, Y+22	; 0x16
    27cc:	90 91 5d 03 	lds	r25, 0x035D	; 0x80035d <uxTopReadyPriority>
    27d0:	98 17       	cp	r25, r24
    27d2:	10 f4       	brcc	.+4      	; 0x27d8 <xTaskResumeAll+0x72>
    27d4:	80 93 5d 03 	sts	0x035D, r24	; 0x80035d <uxTopReadyPriority>
    27d8:	f8 9e       	mul	r15, r24
    27da:	c0 01       	movw	r24, r0
    27dc:	11 24       	eor	r1, r1
    27de:	b8 01       	movw	r22, r16
    27e0:	8d 56       	subi	r24, 0x6D	; 109
    27e2:	9c 4f       	sbci	r25, 0xFC	; 252
    27e4:	0e 94 b1 1a 	call	0x3562	; 0x3562 <vListInsertEnd>
    27e8:	e0 91 b7 03 	lds	r30, 0x03B7	; 0x8003b7 <pxCurrentTCB>
    27ec:	f0 91 b8 03 	lds	r31, 0x03B8	; 0x8003b8 <pxCurrentTCB+0x1>
    27f0:	9e 89       	ldd	r25, Y+22	; 0x16
    27f2:	86 89       	ldd	r24, Z+22	; 0x16
    27f4:	98 17       	cp	r25, r24
    27f6:	a8 f2       	brcs	.-86     	; 0x27a2 <xTaskResumeAll+0x3c>
    27f8:	e0 92 5a 03 	sts	0x035A, r14	; 0x80035a <xYieldPending>
    27fc:	d2 cf       	rjmp	.-92     	; 0x27a2 <xTaskResumeAll+0x3c>
    27fe:	cd 2b       	or	r28, r29
    2800:	11 f0       	breq	.+4      	; 0x2806 <xTaskResumeAll+0xa0>
    2802:	0e 94 cf 10 	call	0x219e	; 0x219e <prvResetNextTaskUnblockTime>
    2806:	c0 91 5b 03 	lds	r28, 0x035B	; 0x80035b <uxPendedTicks>
    280a:	cc 23       	and	r28, r28
    280c:	51 f0       	breq	.+20     	; 0x2822 <xTaskResumeAll+0xbc>
    280e:	d1 e0       	ldi	r29, 0x01	; 1
    2810:	0e 94 07 13 	call	0x260e	; 0x260e <xTaskIncrementTick>
    2814:	81 11       	cpse	r24, r1
    2816:	d0 93 5a 03 	sts	0x035A, r29	; 0x80035a <xYieldPending>
    281a:	c1 50       	subi	r28, 0x01	; 1
    281c:	c9 f7       	brne	.-14     	; 0x2810 <xTaskResumeAll+0xaa>
    281e:	10 92 5b 03 	sts	0x035B, r1	; 0x80035b <uxPendedTicks>
    2822:	80 91 5a 03 	lds	r24, 0x035A	; 0x80035a <xYieldPending>
    2826:	88 23       	and	r24, r24
    2828:	09 f4       	brne	.+2      	; 0x282c <xTaskResumeAll+0xc6>
    282a:	af cf       	rjmp	.-162    	; 0x278a <xTaskResumeAll+0x24>
    282c:	0e 94 d2 1b 	call	0x37a4	; 0x37a4 <vPortYield>
    2830:	81 e0       	ldi	r24, 0x01	; 1
    2832:	0f 90       	pop	r0
    2834:	0f be       	out	0x3f, r0	; 63
    2836:	df 91       	pop	r29
    2838:	cf 91       	pop	r28
    283a:	1f 91       	pop	r17
    283c:	0f 91       	pop	r16
    283e:	ff 90       	pop	r15
    2840:	ef 90       	pop	r14
    2842:	08 95       	ret

00002844 <vTaskDelayUntil>:
    2844:	0f 93       	push	r16
    2846:	1f 93       	push	r17
    2848:	cf 93       	push	r28
    284a:	df 93       	push	r29
    284c:	8c 01       	movw	r16, r24
    284e:	eb 01       	movw	r28, r22
    2850:	0e 94 f7 12 	call	0x25ee	; 0x25ee <vTaskSuspendAll>
    2854:	40 91 5e 03 	lds	r20, 0x035E	; 0x80035e <xTickCount>
    2858:	50 91 5f 03 	lds	r21, 0x035F	; 0x80035f <xTickCount+0x1>
    285c:	f8 01       	movw	r30, r16
    285e:	20 81       	ld	r18, Z
    2860:	31 81       	ldd	r19, Z+1	; 0x01
    2862:	c9 01       	movw	r24, r18
    2864:	8c 0f       	add	r24, r28
    2866:	9d 1f       	adc	r25, r29
    2868:	42 17       	cp	r20, r18
    286a:	53 07       	cpc	r21, r19
    286c:	20 f4       	brcc	.+8      	; 0x2876 <vTaskDelayUntil+0x32>
    286e:	82 17       	cp	r24, r18
    2870:	93 07       	cpc	r25, r19
    2872:	40 f4       	brcc	.+16     	; 0x2884 <vTaskDelayUntil+0x40>
    2874:	03 c0       	rjmp	.+6      	; 0x287c <vTaskDelayUntil+0x38>
    2876:	82 17       	cp	r24, r18
    2878:	93 07       	cpc	r25, r19
    287a:	30 f0       	brcs	.+12     	; 0x2888 <vTaskDelayUntil+0x44>
    287c:	21 e0       	ldi	r18, 0x01	; 1
    287e:	48 17       	cp	r20, r24
    2880:	59 07       	cpc	r21, r25
    2882:	18 f0       	brcs	.+6      	; 0x288a <vTaskDelayUntil+0x46>
    2884:	20 e0       	ldi	r18, 0x00	; 0
    2886:	01 c0       	rjmp	.+2      	; 0x288a <vTaskDelayUntil+0x46>
    2888:	21 e0       	ldi	r18, 0x01	; 1
    288a:	f8 01       	movw	r30, r16
    288c:	91 83       	std	Z+1, r25	; 0x01
    288e:	80 83       	st	Z, r24
    2890:	22 23       	and	r18, r18
    2892:	29 f0       	breq	.+10     	; 0x289e <vTaskDelayUntil+0x5a>
    2894:	60 e0       	ldi	r22, 0x00	; 0
    2896:	84 1b       	sub	r24, r20
    2898:	95 0b       	sbc	r25, r21
    289a:	0e 94 ea 10 	call	0x21d4	; 0x21d4 <prvAddCurrentTaskToDelayedList>
    289e:	0e 94 b3 13 	call	0x2766	; 0x2766 <xTaskResumeAll>
    28a2:	81 11       	cpse	r24, r1
    28a4:	02 c0       	rjmp	.+4      	; 0x28aa <vTaskDelayUntil+0x66>
    28a6:	0e 94 d2 1b 	call	0x37a4	; 0x37a4 <vPortYield>
    28aa:	df 91       	pop	r29
    28ac:	cf 91       	pop	r28
    28ae:	1f 91       	pop	r17
    28b0:	0f 91       	pop	r16
    28b2:	08 95       	ret

000028b4 <vTaskDelay>:
    28b4:	cf 93       	push	r28
    28b6:	df 93       	push	r29
    28b8:	ec 01       	movw	r28, r24
    28ba:	89 2b       	or	r24, r25
    28bc:	19 f4       	brne	.+6      	; 0x28c4 <vTaskDelay+0x10>
    28be:	0e 94 d2 1b 	call	0x37a4	; 0x37a4 <vPortYield>
    28c2:	0a c0       	rjmp	.+20     	; 0x28d8 <vTaskDelay+0x24>
    28c4:	0e 94 f7 12 	call	0x25ee	; 0x25ee <vTaskSuspendAll>
    28c8:	60 e0       	ldi	r22, 0x00	; 0
    28ca:	ce 01       	movw	r24, r28
    28cc:	0e 94 ea 10 	call	0x21d4	; 0x21d4 <prvAddCurrentTaskToDelayedList>
    28d0:	0e 94 b3 13 	call	0x2766	; 0x2766 <xTaskResumeAll>
    28d4:	88 23       	and	r24, r24
    28d6:	99 f3       	breq	.-26     	; 0x28be <vTaskDelay+0xa>
    28d8:	df 91       	pop	r29
    28da:	cf 91       	pop	r28
    28dc:	08 95       	ret

000028de <vTaskSwitchContext>:
    28de:	80 91 53 03 	lds	r24, 0x0353	; 0x800353 <uxSchedulerSuspended>
    28e2:	88 23       	and	r24, r24
    28e4:	21 f0       	breq	.+8      	; 0x28ee <vTaskSwitchContext+0x10>
    28e6:	81 e0       	ldi	r24, 0x01	; 1
    28e8:	80 93 5a 03 	sts	0x035A, r24	; 0x80035a <xYieldPending>
    28ec:	08 95       	ret
    28ee:	10 92 5a 03 	sts	0x035A, r1	; 0x80035a <xYieldPending>
    28f2:	a0 91 b7 03 	lds	r26, 0x03B7	; 0x8003b7 <pxCurrentTCB>
    28f6:	b0 91 b8 03 	lds	r27, 0x03B8	; 0x8003b8 <pxCurrentTCB+0x1>
    28fa:	e0 91 b7 03 	lds	r30, 0x03B7	; 0x8003b7 <pxCurrentTCB>
    28fe:	f0 91 b8 03 	lds	r31, 0x03B8	; 0x8003b8 <pxCurrentTCB+0x1>
    2902:	2d 91       	ld	r18, X+
    2904:	3c 91       	ld	r19, X
    2906:	87 89       	ldd	r24, Z+23	; 0x17
    2908:	90 8d       	ldd	r25, Z+24	; 0x18
    290a:	82 17       	cp	r24, r18
    290c:	93 07       	cpc	r25, r19
    290e:	60 f0       	brcs	.+24     	; 0x2928 <vTaskSwitchContext+0x4a>
    2910:	60 91 b7 03 	lds	r22, 0x03B7	; 0x8003b7 <pxCurrentTCB>
    2914:	70 91 b8 03 	lds	r23, 0x03B8	; 0x8003b8 <pxCurrentTCB+0x1>
    2918:	80 91 b7 03 	lds	r24, 0x03B7	; 0x8003b7 <pxCurrentTCB>
    291c:	90 91 b8 03 	lds	r25, 0x03B8	; 0x8003b8 <pxCurrentTCB+0x1>
    2920:	67 5e       	subi	r22, 0xE7	; 231
    2922:	7f 4f       	sbci	r23, 0xFF	; 255
    2924:	0e 94 f3 18 	call	0x31e6	; 0x31e6 <vApplicationStackOverflowHook>
    2928:	80 91 5d 03 	lds	r24, 0x035D	; 0x80035d <uxTopReadyPriority>
    292c:	69 e0       	ldi	r22, 0x09	; 9
    292e:	48 2f       	mov	r20, r24
    2930:	50 e0       	ldi	r21, 0x00	; 0
    2932:	64 9f       	mul	r22, r20
    2934:	90 01       	movw	r18, r0
    2936:	65 9f       	mul	r22, r21
    2938:	30 0d       	add	r19, r0
    293a:	11 24       	eor	r1, r1
    293c:	f9 01       	movw	r30, r18
    293e:	ed 56       	subi	r30, 0x6D	; 109
    2940:	fc 4f       	sbci	r31, 0xFC	; 252
    2942:	90 81       	ld	r25, Z
    2944:	91 11       	cpse	r25, r1
    2946:	02 c0       	rjmp	.+4      	; 0x294c <vTaskSwitchContext+0x6e>
    2948:	81 50       	subi	r24, 0x01	; 1
    294a:	f1 cf       	rjmp	.-30     	; 0x292e <vTaskSwitchContext+0x50>
    294c:	a1 81       	ldd	r26, Z+1	; 0x01
    294e:	b2 81       	ldd	r27, Z+2	; 0x02
    2950:	12 96       	adiw	r26, 0x02	; 2
    2952:	0d 90       	ld	r0, X+
    2954:	bc 91       	ld	r27, X
    2956:	a0 2d       	mov	r26, r0
    2958:	b2 83       	std	Z+2, r27	; 0x02
    295a:	a1 83       	std	Z+1, r26	; 0x01
    295c:	2a 56       	subi	r18, 0x6A	; 106
    295e:	3c 4f       	sbci	r19, 0xFC	; 252
    2960:	a2 17       	cp	r26, r18
    2962:	b3 07       	cpc	r27, r19
    2964:	31 f4       	brne	.+12     	; 0x2972 <vTaskSwitchContext+0x94>
    2966:	12 96       	adiw	r26, 0x02	; 2
    2968:	2d 91       	ld	r18, X+
    296a:	3c 91       	ld	r19, X
    296c:	13 97       	sbiw	r26, 0x03	; 3
    296e:	32 83       	std	Z+2, r19	; 0x02
    2970:	21 83       	std	Z+1, r18	; 0x01
    2972:	99 e0       	ldi	r25, 0x09	; 9
    2974:	94 9f       	mul	r25, r20
    2976:	f0 01       	movw	r30, r0
    2978:	95 9f       	mul	r25, r21
    297a:	f0 0d       	add	r31, r0
    297c:	11 24       	eor	r1, r1
    297e:	ed 56       	subi	r30, 0x6D	; 109
    2980:	fc 4f       	sbci	r31, 0xFC	; 252
    2982:	01 80       	ldd	r0, Z+1	; 0x01
    2984:	f2 81       	ldd	r31, Z+2	; 0x02
    2986:	e0 2d       	mov	r30, r0
    2988:	26 81       	ldd	r18, Z+6	; 0x06
    298a:	37 81       	ldd	r19, Z+7	; 0x07
    298c:	30 93 b8 03 	sts	0x03B8, r19	; 0x8003b8 <pxCurrentTCB+0x1>
    2990:	20 93 b7 03 	sts	0x03B7, r18	; 0x8003b7 <pxCurrentTCB>
    2994:	80 93 5d 03 	sts	0x035D, r24	; 0x80035d <uxTopReadyPriority>
    2998:	08 95       	ret

0000299a <vTaskSuspend>:
    299a:	0f 93       	push	r16
    299c:	1f 93       	push	r17
    299e:	cf 93       	push	r28
    29a0:	df 93       	push	r29
    29a2:	ec 01       	movw	r28, r24
    29a4:	0f b6       	in	r0, 0x3f	; 63
    29a6:	f8 94       	cli
    29a8:	0f 92       	push	r0
    29aa:	89 2b       	or	r24, r25
    29ac:	21 f4       	brne	.+8      	; 0x29b6 <vTaskSuspend+0x1c>
    29ae:	c0 91 b7 03 	lds	r28, 0x03B7	; 0x8003b7 <pxCurrentTCB>
    29b2:	d0 91 b8 03 	lds	r29, 0x03B8	; 0x8003b8 <pxCurrentTCB+0x1>
    29b6:	8e 01       	movw	r16, r28
    29b8:	0e 5f       	subi	r16, 0xFE	; 254
    29ba:	1f 4f       	sbci	r17, 0xFF	; 255
    29bc:	c8 01       	movw	r24, r16
    29be:	0e 94 0a 1b 	call	0x3614	; 0x3614 <uxListRemove>
    29c2:	8c 89       	ldd	r24, Y+20	; 0x14
    29c4:	9d 89       	ldd	r25, Y+21	; 0x15
    29c6:	89 2b       	or	r24, r25
    29c8:	21 f0       	breq	.+8      	; 0x29d2 <vTaskSuspend+0x38>
    29ca:	ce 01       	movw	r24, r28
    29cc:	0c 96       	adiw	r24, 0x0c	; 12
    29ce:	0e 94 0a 1b 	call	0x3614	; 0x3614 <uxListRemove>
    29d2:	b8 01       	movw	r22, r16
    29d4:	81 e6       	ldi	r24, 0x61	; 97
    29d6:	93 e0       	ldi	r25, 0x03	; 3
    29d8:	0e 94 b1 1a 	call	0x3562	; 0x3562 <vListInsertEnd>
    29dc:	8f a1       	ldd	r24, Y+39	; 0x27
    29de:	81 30       	cpi	r24, 0x01	; 1
    29e0:	09 f4       	brne	.+2      	; 0x29e4 <vTaskSuspend+0x4a>
    29e2:	1f a2       	std	Y+39, r1	; 0x27
    29e4:	0f 90       	pop	r0
    29e6:	0f be       	out	0x3f, r0	; 63
    29e8:	80 91 5c 03 	lds	r24, 0x035C	; 0x80035c <xSchedulerRunning>
    29ec:	88 23       	and	r24, r24
    29ee:	39 f0       	breq	.+14     	; 0x29fe <vTaskSuspend+0x64>
    29f0:	0f b6       	in	r0, 0x3f	; 63
    29f2:	f8 94       	cli
    29f4:	0f 92       	push	r0
    29f6:	0e 94 cf 10 	call	0x219e	; 0x219e <prvResetNextTaskUnblockTime>
    29fa:	0f 90       	pop	r0
    29fc:	0f be       	out	0x3f, r0	; 63
    29fe:	80 91 b7 03 	lds	r24, 0x03B7	; 0x8003b7 <pxCurrentTCB>
    2a02:	90 91 b8 03 	lds	r25, 0x03B8	; 0x8003b8 <pxCurrentTCB+0x1>
    2a06:	c8 17       	cp	r28, r24
    2a08:	d9 07       	cpc	r29, r25
    2a0a:	c1 f4       	brne	.+48     	; 0x2a3c <vTaskSuspend+0xa2>
    2a0c:	80 91 5c 03 	lds	r24, 0x035C	; 0x80035c <xSchedulerRunning>
    2a10:	88 23       	and	r24, r24
    2a12:	19 f0       	breq	.+6      	; 0x2a1a <vTaskSuspend+0x80>
    2a14:	0e 94 d2 1b 	call	0x37a4	; 0x37a4 <vPortYield>
    2a18:	11 c0       	rjmp	.+34     	; 0x2a3c <vTaskSuspend+0xa2>
    2a1a:	90 91 61 03 	lds	r25, 0x0361	; 0x800361 <xSuspendedTaskList>
    2a1e:	80 91 60 03 	lds	r24, 0x0360	; 0x800360 <uxCurrentNumberOfTasks>
    2a22:	98 13       	cpse	r25, r24
    2a24:	05 c0       	rjmp	.+10     	; 0x2a30 <vTaskSuspend+0x96>
    2a26:	10 92 b8 03 	sts	0x03B8, r1	; 0x8003b8 <pxCurrentTCB+0x1>
    2a2a:	10 92 b7 03 	sts	0x03B7, r1	; 0x8003b7 <pxCurrentTCB>
    2a2e:	06 c0       	rjmp	.+12     	; 0x2a3c <vTaskSuspend+0xa2>
    2a30:	df 91       	pop	r29
    2a32:	cf 91       	pop	r28
    2a34:	1f 91       	pop	r17
    2a36:	0f 91       	pop	r16
    2a38:	0c 94 6f 14 	jmp	0x28de	; 0x28de <vTaskSwitchContext>
    2a3c:	df 91       	pop	r29
    2a3e:	cf 91       	pop	r28
    2a40:	1f 91       	pop	r17
    2a42:	0f 91       	pop	r16
    2a44:	08 95       	ret

00002a46 <vTaskPlaceOnEventList>:
    2a46:	cf 93       	push	r28
    2a48:	df 93       	push	r29
    2a4a:	eb 01       	movw	r28, r22
    2a4c:	60 91 b7 03 	lds	r22, 0x03B7	; 0x8003b7 <pxCurrentTCB>
    2a50:	70 91 b8 03 	lds	r23, 0x03B8	; 0x8003b8 <pxCurrentTCB+0x1>
    2a54:	64 5f       	subi	r22, 0xF4	; 244
    2a56:	7f 4f       	sbci	r23, 0xFF	; 255
    2a58:	0e 94 d2 1a 	call	0x35a4	; 0x35a4 <vListInsert>
    2a5c:	61 e0       	ldi	r22, 0x01	; 1
    2a5e:	ce 01       	movw	r24, r28
    2a60:	df 91       	pop	r29
    2a62:	cf 91       	pop	r28
    2a64:	0c 94 ea 10 	jmp	0x21d4	; 0x21d4 <prvAddCurrentTaskToDelayedList>

00002a68 <vTaskPlaceOnEventListRestricted>:
    2a68:	1f 93       	push	r17
    2a6a:	cf 93       	push	r28
    2a6c:	df 93       	push	r29
    2a6e:	eb 01       	movw	r28, r22
    2a70:	14 2f       	mov	r17, r20
    2a72:	60 91 b7 03 	lds	r22, 0x03B7	; 0x8003b7 <pxCurrentTCB>
    2a76:	70 91 b8 03 	lds	r23, 0x03B8	; 0x8003b8 <pxCurrentTCB+0x1>
    2a7a:	64 5f       	subi	r22, 0xF4	; 244
    2a7c:	7f 4f       	sbci	r23, 0xFF	; 255
    2a7e:	0e 94 b1 1a 	call	0x3562	; 0x3562 <vListInsertEnd>
    2a82:	11 23       	and	r17, r17
    2a84:	11 f0       	breq	.+4      	; 0x2a8a <vTaskPlaceOnEventListRestricted+0x22>
    2a86:	cf ef       	ldi	r28, 0xFF	; 255
    2a88:	df ef       	ldi	r29, 0xFF	; 255
    2a8a:	61 2f       	mov	r22, r17
    2a8c:	ce 01       	movw	r24, r28
    2a8e:	df 91       	pop	r29
    2a90:	cf 91       	pop	r28
    2a92:	1f 91       	pop	r17
    2a94:	0c 94 ea 10 	jmp	0x21d4	; 0x21d4 <prvAddCurrentTaskToDelayedList>

00002a98 <xTaskRemoveFromEventList>:
    2a98:	0f 93       	push	r16
    2a9a:	1f 93       	push	r17
    2a9c:	cf 93       	push	r28
    2a9e:	df 93       	push	r29
    2aa0:	dc 01       	movw	r26, r24
    2aa2:	15 96       	adiw	r26, 0x05	; 5
    2aa4:	ed 91       	ld	r30, X+
    2aa6:	fc 91       	ld	r31, X
    2aa8:	16 97       	sbiw	r26, 0x06	; 6
    2aaa:	c6 81       	ldd	r28, Z+6	; 0x06
    2aac:	d7 81       	ldd	r29, Z+7	; 0x07
    2aae:	8e 01       	movw	r16, r28
    2ab0:	04 5f       	subi	r16, 0xF4	; 244
    2ab2:	1f 4f       	sbci	r17, 0xFF	; 255
    2ab4:	c8 01       	movw	r24, r16
    2ab6:	0e 94 0a 1b 	call	0x3614	; 0x3614 <uxListRemove>
    2aba:	80 91 53 03 	lds	r24, 0x0353	; 0x800353 <uxSchedulerSuspended>
    2abe:	81 11       	cpse	r24, r1
    2ac0:	14 c0       	rjmp	.+40     	; 0x2aea <xTaskRemoveFromEventList+0x52>
    2ac2:	0a 50       	subi	r16, 0x0A	; 10
    2ac4:	11 09       	sbc	r17, r1
    2ac6:	c8 01       	movw	r24, r16
    2ac8:	0e 94 0a 1b 	call	0x3614	; 0x3614 <uxListRemove>
    2acc:	8e 89       	ldd	r24, Y+22	; 0x16
    2ace:	90 91 5d 03 	lds	r25, 0x035D	; 0x80035d <uxTopReadyPriority>
    2ad2:	98 17       	cp	r25, r24
    2ad4:	10 f4       	brcc	.+4      	; 0x2ada <xTaskRemoveFromEventList+0x42>
    2ad6:	80 93 5d 03 	sts	0x035D, r24	; 0x80035d <uxTopReadyPriority>
    2ada:	b9 e0       	ldi	r27, 0x09	; 9
    2adc:	8b 9f       	mul	r24, r27
    2ade:	c0 01       	movw	r24, r0
    2ae0:	11 24       	eor	r1, r1
    2ae2:	b8 01       	movw	r22, r16
    2ae4:	8d 56       	subi	r24, 0x6D	; 109
    2ae6:	9c 4f       	sbci	r25, 0xFC	; 252
    2ae8:	03 c0       	rjmp	.+6      	; 0x2af0 <xTaskRemoveFromEventList+0x58>
    2aea:	b8 01       	movw	r22, r16
    2aec:	84 e7       	ldi	r24, 0x74	; 116
    2aee:	93 e0       	ldi	r25, 0x03	; 3
    2af0:	0e 94 b1 1a 	call	0x3562	; 0x3562 <vListInsertEnd>
    2af4:	e0 91 b7 03 	lds	r30, 0x03B7	; 0x8003b7 <pxCurrentTCB>
    2af8:	f0 91 b8 03 	lds	r31, 0x03B8	; 0x8003b8 <pxCurrentTCB+0x1>
    2afc:	9e 89       	ldd	r25, Y+22	; 0x16
    2afe:	86 89       	ldd	r24, Z+22	; 0x16
    2b00:	89 17       	cp	r24, r25
    2b02:	20 f4       	brcc	.+8      	; 0x2b0c <xTaskRemoveFromEventList+0x74>
    2b04:	81 e0       	ldi	r24, 0x01	; 1
    2b06:	80 93 5a 03 	sts	0x035A, r24	; 0x80035a <xYieldPending>
    2b0a:	01 c0       	rjmp	.+2      	; 0x2b0e <xTaskRemoveFromEventList+0x76>
    2b0c:	80 e0       	ldi	r24, 0x00	; 0
    2b0e:	df 91       	pop	r29
    2b10:	cf 91       	pop	r28
    2b12:	1f 91       	pop	r17
    2b14:	0f 91       	pop	r16
    2b16:	08 95       	ret

00002b18 <vTaskInternalSetTimeOutState>:
    2b18:	20 91 59 03 	lds	r18, 0x0359	; 0x800359 <xNumOfOverflows>
    2b1c:	fc 01       	movw	r30, r24
    2b1e:	20 83       	st	Z, r18
    2b20:	20 91 5e 03 	lds	r18, 0x035E	; 0x80035e <xTickCount>
    2b24:	30 91 5f 03 	lds	r19, 0x035F	; 0x80035f <xTickCount+0x1>
    2b28:	32 83       	std	Z+2, r19	; 0x02
    2b2a:	21 83       	std	Z+1, r18	; 0x01
    2b2c:	08 95       	ret

00002b2e <xTaskCheckForTimeOut>:
    2b2e:	cf 93       	push	r28
    2b30:	df 93       	push	r29
    2b32:	0f b6       	in	r0, 0x3f	; 63
    2b34:	f8 94       	cli
    2b36:	0f 92       	push	r0
    2b38:	40 91 5e 03 	lds	r20, 0x035E	; 0x80035e <xTickCount>
    2b3c:	50 91 5f 03 	lds	r21, 0x035F	; 0x80035f <xTickCount+0x1>
    2b40:	db 01       	movw	r26, r22
    2b42:	2d 91       	ld	r18, X+
    2b44:	3c 91       	ld	r19, X
    2b46:	2f 3f       	cpi	r18, 0xFF	; 255
    2b48:	bf ef       	ldi	r27, 0xFF	; 255
    2b4a:	3b 07       	cpc	r19, r27
    2b4c:	d9 f0       	breq	.+54     	; 0x2b84 <xTaskCheckForTimeOut+0x56>
    2b4e:	ec 01       	movw	r28, r24
    2b50:	e9 81       	ldd	r30, Y+1	; 0x01
    2b52:	fa 81       	ldd	r31, Y+2	; 0x02
    2b54:	a0 91 59 03 	lds	r26, 0x0359	; 0x800359 <xNumOfOverflows>
    2b58:	b8 81       	ld	r27, Y
    2b5a:	ba 17       	cp	r27, r26
    2b5c:	19 f0       	breq	.+6      	; 0x2b64 <xTaskCheckForTimeOut+0x36>
    2b5e:	4e 17       	cp	r20, r30
    2b60:	5f 07       	cpc	r21, r31
    2b62:	90 f4       	brcc	.+36     	; 0x2b88 <xTaskCheckForTimeOut+0x5a>
    2b64:	4e 1b       	sub	r20, r30
    2b66:	5f 0b       	sbc	r21, r31
    2b68:	fb 01       	movw	r30, r22
    2b6a:	42 17       	cp	r20, r18
    2b6c:	53 07       	cpc	r21, r19
    2b6e:	38 f4       	brcc	.+14     	; 0x2b7e <xTaskCheckForTimeOut+0x50>
    2b70:	24 1b       	sub	r18, r20
    2b72:	35 0b       	sbc	r19, r21
    2b74:	31 83       	std	Z+1, r19	; 0x01
    2b76:	20 83       	st	Z, r18
    2b78:	0e 94 8c 15 	call	0x2b18	; 0x2b18 <vTaskInternalSetTimeOutState>
    2b7c:	03 c0       	rjmp	.+6      	; 0x2b84 <xTaskCheckForTimeOut+0x56>
    2b7e:	11 82       	std	Z+1, r1	; 0x01
    2b80:	10 82       	st	Z, r1
    2b82:	02 c0       	rjmp	.+4      	; 0x2b88 <xTaskCheckForTimeOut+0x5a>
    2b84:	80 e0       	ldi	r24, 0x00	; 0
    2b86:	01 c0       	rjmp	.+2      	; 0x2b8a <xTaskCheckForTimeOut+0x5c>
    2b88:	81 e0       	ldi	r24, 0x01	; 1
    2b8a:	0f 90       	pop	r0
    2b8c:	0f be       	out	0x3f, r0	; 63
    2b8e:	df 91       	pop	r29
    2b90:	cf 91       	pop	r28
    2b92:	08 95       	ret

00002b94 <vTaskMissedYield>:
    2b94:	81 e0       	ldi	r24, 0x01	; 1
    2b96:	80 93 5a 03 	sts	0x035A, r24	; 0x80035a <xYieldPending>
    2b9a:	08 95       	ret

00002b9c <xTaskGetSchedulerState>:
    2b9c:	80 91 5c 03 	lds	r24, 0x035C	; 0x80035c <xSchedulerRunning>
    2ba0:	88 23       	and	r24, r24
    2ba2:	31 f0       	breq	.+12     	; 0x2bb0 <xTaskGetSchedulerState+0x14>
    2ba4:	80 91 53 03 	lds	r24, 0x0353	; 0x800353 <uxSchedulerSuspended>
    2ba8:	88 23       	and	r24, r24
    2baa:	21 f0       	breq	.+8      	; 0x2bb4 <xTaskGetSchedulerState+0x18>
    2bac:	80 e0       	ldi	r24, 0x00	; 0
    2bae:	08 95       	ret
    2bb0:	81 e0       	ldi	r24, 0x01	; 1
    2bb2:	08 95       	ret
    2bb4:	82 e0       	ldi	r24, 0x02	; 2
    2bb6:	08 95       	ret

00002bb8 <xTaskPriorityInherit>:
    2bb8:	0f 93       	push	r16
    2bba:	1f 93       	push	r17
    2bbc:	cf 93       	push	r28
    2bbe:	df 93       	push	r29
    2bc0:	fc 01       	movw	r30, r24
    2bc2:	89 2b       	or	r24, r25
    2bc4:	09 f4       	brne	.+2      	; 0x2bc8 <xTaskPriorityInherit+0x10>
    2bc6:	55 c0       	rjmp	.+170    	; 0x2c72 <xTaskPriorityInherit+0xba>
    2bc8:	86 89       	ldd	r24, Z+22	; 0x16
    2bca:	a0 91 b7 03 	lds	r26, 0x03B7	; 0x8003b7 <pxCurrentTCB>
    2bce:	b0 91 b8 03 	lds	r27, 0x03B8	; 0x8003b8 <pxCurrentTCB+0x1>
    2bd2:	56 96       	adiw	r26, 0x16	; 22
    2bd4:	9c 91       	ld	r25, X
    2bd6:	89 17       	cp	r24, r25
    2bd8:	08 f0       	brcs	.+2      	; 0x2bdc <xTaskPriorityInherit+0x24>
    2bda:	41 c0       	rjmp	.+130    	; 0x2c5e <xTaskPriorityInherit+0xa6>
    2bdc:	24 85       	ldd	r18, Z+12	; 0x0c
    2bde:	35 85       	ldd	r19, Z+13	; 0x0d
    2be0:	37 fd       	sbrc	r19, 7
    2be2:	0c c0       	rjmp	.+24     	; 0x2bfc <xTaskPriorityInherit+0x44>
    2be4:	a0 91 b7 03 	lds	r26, 0x03B7	; 0x8003b7 <pxCurrentTCB>
    2be8:	b0 91 b8 03 	lds	r27, 0x03B8	; 0x8003b8 <pxCurrentTCB+0x1>
    2bec:	56 96       	adiw	r26, 0x16	; 22
    2bee:	9c 91       	ld	r25, X
    2bf0:	24 e0       	ldi	r18, 0x04	; 4
    2bf2:	30 e0       	ldi	r19, 0x00	; 0
    2bf4:	29 1b       	sub	r18, r25
    2bf6:	31 09       	sbc	r19, r1
    2bf8:	35 87       	std	Z+13, r19	; 0x0d
    2bfa:	24 87       	std	Z+12, r18	; 0x0c
    2bfc:	29 e0       	ldi	r18, 0x09	; 9
    2bfe:	82 9f       	mul	r24, r18
    2c00:	c0 01       	movw	r24, r0
    2c02:	11 24       	eor	r1, r1
    2c04:	8d 56       	subi	r24, 0x6D	; 109
    2c06:	9c 4f       	sbci	r25, 0xFC	; 252
    2c08:	22 85       	ldd	r18, Z+10	; 0x0a
    2c0a:	33 85       	ldd	r19, Z+11	; 0x0b
    2c0c:	28 17       	cp	r18, r24
    2c0e:	39 07       	cpc	r19, r25
    2c10:	e9 f4       	brne	.+58     	; 0x2c4c <xTaskPriorityInherit+0x94>
    2c12:	8f 01       	movw	r16, r30
    2c14:	ef 01       	movw	r28, r30
    2c16:	22 96       	adiw	r28, 0x02	; 2
    2c18:	ce 01       	movw	r24, r28
    2c1a:	0e 94 0a 1b 	call	0x3614	; 0x3614 <uxListRemove>
    2c1e:	e0 91 b7 03 	lds	r30, 0x03B7	; 0x8003b7 <pxCurrentTCB>
    2c22:	f0 91 b8 03 	lds	r31, 0x03B8	; 0x8003b8 <pxCurrentTCB+0x1>
    2c26:	86 89       	ldd	r24, Z+22	; 0x16
    2c28:	f8 01       	movw	r30, r16
    2c2a:	86 8b       	std	Z+22, r24	; 0x16
    2c2c:	90 91 5d 03 	lds	r25, 0x035D	; 0x80035d <uxTopReadyPriority>
    2c30:	98 17       	cp	r25, r24
    2c32:	10 f4       	brcc	.+4      	; 0x2c38 <xTaskPriorityInherit+0x80>
    2c34:	80 93 5d 03 	sts	0x035D, r24	; 0x80035d <uxTopReadyPriority>
    2c38:	f9 e0       	ldi	r31, 0x09	; 9
    2c3a:	8f 9f       	mul	r24, r31
    2c3c:	c0 01       	movw	r24, r0
    2c3e:	11 24       	eor	r1, r1
    2c40:	be 01       	movw	r22, r28
    2c42:	8d 56       	subi	r24, 0x6D	; 109
    2c44:	9c 4f       	sbci	r25, 0xFC	; 252
    2c46:	0e 94 b1 1a 	call	0x3562	; 0x3562 <vListInsertEnd>
    2c4a:	07 c0       	rjmp	.+14     	; 0x2c5a <xTaskPriorityInherit+0xa2>
    2c4c:	a0 91 b7 03 	lds	r26, 0x03B7	; 0x8003b7 <pxCurrentTCB>
    2c50:	b0 91 b8 03 	lds	r27, 0x03B8	; 0x8003b8 <pxCurrentTCB+0x1>
    2c54:	56 96       	adiw	r26, 0x16	; 22
    2c56:	8c 91       	ld	r24, X
    2c58:	86 8b       	std	Z+22, r24	; 0x16
    2c5a:	81 e0       	ldi	r24, 0x01	; 1
    2c5c:	0b c0       	rjmp	.+22     	; 0x2c74 <xTaskPriorityInherit+0xbc>
    2c5e:	a0 91 b7 03 	lds	r26, 0x03B7	; 0x8003b7 <pxCurrentTCB>
    2c62:	b0 91 b8 03 	lds	r27, 0x03B8	; 0x8003b8 <pxCurrentTCB+0x1>
    2c66:	81 e0       	ldi	r24, 0x01	; 1
    2c68:	21 a1       	ldd	r18, Z+33	; 0x21
    2c6a:	56 96       	adiw	r26, 0x16	; 22
    2c6c:	9c 91       	ld	r25, X
    2c6e:	29 17       	cp	r18, r25
    2c70:	08 f0       	brcs	.+2      	; 0x2c74 <xTaskPriorityInherit+0xbc>
    2c72:	80 e0       	ldi	r24, 0x00	; 0
    2c74:	df 91       	pop	r29
    2c76:	cf 91       	pop	r28
    2c78:	1f 91       	pop	r17
    2c7a:	0f 91       	pop	r16
    2c7c:	08 95       	ret

00002c7e <xTaskPriorityDisinherit>:
    2c7e:	0f 93       	push	r16
    2c80:	1f 93       	push	r17
    2c82:	cf 93       	push	r28
    2c84:	df 93       	push	r29
    2c86:	fc 01       	movw	r30, r24
    2c88:	89 2b       	or	r24, r25
    2c8a:	11 f4       	brne	.+4      	; 0x2c90 <xTaskPriorityDisinherit+0x12>
    2c8c:	80 e0       	ldi	r24, 0x00	; 0
    2c8e:	2c c0       	rjmp	.+88     	; 0x2ce8 <xTaskPriorityDisinherit+0x6a>
    2c90:	82 a1       	ldd	r24, Z+34	; 0x22
    2c92:	81 50       	subi	r24, 0x01	; 1
    2c94:	82 a3       	std	Z+34, r24	; 0x22
    2c96:	26 89       	ldd	r18, Z+22	; 0x16
    2c98:	91 a1       	ldd	r25, Z+33	; 0x21
    2c9a:	29 17       	cp	r18, r25
    2c9c:	b9 f3       	breq	.-18     	; 0x2c8c <xTaskPriorityDisinherit+0xe>
    2c9e:	81 11       	cpse	r24, r1
    2ca0:	f5 cf       	rjmp	.-22     	; 0x2c8c <xTaskPriorityDisinherit+0xe>
    2ca2:	ef 01       	movw	r28, r30
    2ca4:	8f 01       	movw	r16, r30
    2ca6:	0e 5f       	subi	r16, 0xFE	; 254
    2ca8:	1f 4f       	sbci	r17, 0xFF	; 255
    2caa:	c8 01       	movw	r24, r16
    2cac:	0e 94 0a 1b 	call	0x3614	; 0x3614 <uxListRemove>
    2cb0:	89 a1       	ldd	r24, Y+33	; 0x21
    2cb2:	8e 8b       	std	Y+22, r24	; 0x16
    2cb4:	48 2f       	mov	r20, r24
    2cb6:	50 e0       	ldi	r21, 0x00	; 0
    2cb8:	24 e0       	ldi	r18, 0x04	; 4
    2cba:	30 e0       	ldi	r19, 0x00	; 0
    2cbc:	24 1b       	sub	r18, r20
    2cbe:	35 0b       	sbc	r19, r21
    2cc0:	3d 87       	std	Y+13, r19	; 0x0d
    2cc2:	2c 87       	std	Y+12, r18	; 0x0c
    2cc4:	90 91 5d 03 	lds	r25, 0x035D	; 0x80035d <uxTopReadyPriority>
    2cc8:	98 17       	cp	r25, r24
    2cca:	10 f4       	brcc	.+4      	; 0x2cd0 <xTaskPriorityDisinherit+0x52>
    2ccc:	80 93 5d 03 	sts	0x035D, r24	; 0x80035d <uxTopReadyPriority>
    2cd0:	29 e0       	ldi	r18, 0x09	; 9
    2cd2:	24 9f       	mul	r18, r20
    2cd4:	c0 01       	movw	r24, r0
    2cd6:	25 9f       	mul	r18, r21
    2cd8:	90 0d       	add	r25, r0
    2cda:	11 24       	eor	r1, r1
    2cdc:	b8 01       	movw	r22, r16
    2cde:	8d 56       	subi	r24, 0x6D	; 109
    2ce0:	9c 4f       	sbci	r25, 0xFC	; 252
    2ce2:	0e 94 b1 1a 	call	0x3562	; 0x3562 <vListInsertEnd>
    2ce6:	81 e0       	ldi	r24, 0x01	; 1
    2ce8:	df 91       	pop	r29
    2cea:	cf 91       	pop	r28
    2cec:	1f 91       	pop	r17
    2cee:	0f 91       	pop	r16
    2cf0:	08 95       	ret

00002cf2 <vTaskPriorityDisinheritAfterTimeout>:
    2cf2:	0f 93       	push	r16
    2cf4:	1f 93       	push	r17
    2cf6:	cf 93       	push	r28
    2cf8:	df 93       	push	r29
    2cfa:	fc 01       	movw	r30, r24
    2cfc:	89 2b       	or	r24, r25
    2cfe:	d9 f1       	breq	.+118    	; 0x2d76 <vTaskPriorityDisinheritAfterTimeout+0x84>
    2d00:	91 a1       	ldd	r25, Z+33	; 0x21
    2d02:	96 17       	cp	r25, r22
    2d04:	08 f4       	brcc	.+2      	; 0x2d08 <vTaskPriorityDisinheritAfterTimeout+0x16>
    2d06:	96 2f       	mov	r25, r22
    2d08:	86 89       	ldd	r24, Z+22	; 0x16
    2d0a:	89 17       	cp	r24, r25
    2d0c:	a1 f1       	breq	.+104    	; 0x2d76 <vTaskPriorityDisinheritAfterTimeout+0x84>
    2d0e:	22 a1       	ldd	r18, Z+34	; 0x22
    2d10:	21 30       	cpi	r18, 0x01	; 1
    2d12:	89 f5       	brne	.+98     	; 0x2d76 <vTaskPriorityDisinheritAfterTimeout+0x84>
    2d14:	96 8b       	std	Z+22, r25	; 0x16
    2d16:	24 85       	ldd	r18, Z+12	; 0x0c
    2d18:	35 85       	ldd	r19, Z+13	; 0x0d
    2d1a:	37 fd       	sbrc	r19, 7
    2d1c:	06 c0       	rjmp	.+12     	; 0x2d2a <vTaskPriorityDisinheritAfterTimeout+0x38>
    2d1e:	24 e0       	ldi	r18, 0x04	; 4
    2d20:	30 e0       	ldi	r19, 0x00	; 0
    2d22:	29 1b       	sub	r18, r25
    2d24:	31 09       	sbc	r19, r1
    2d26:	35 87       	std	Z+13, r19	; 0x0d
    2d28:	24 87       	std	Z+12, r18	; 0x0c
    2d2a:	29 e0       	ldi	r18, 0x09	; 9
    2d2c:	82 9f       	mul	r24, r18
    2d2e:	c0 01       	movw	r24, r0
    2d30:	11 24       	eor	r1, r1
    2d32:	8d 56       	subi	r24, 0x6D	; 109
    2d34:	9c 4f       	sbci	r25, 0xFC	; 252
    2d36:	22 85       	ldd	r18, Z+10	; 0x0a
    2d38:	33 85       	ldd	r19, Z+11	; 0x0b
    2d3a:	28 17       	cp	r18, r24
    2d3c:	39 07       	cpc	r19, r25
    2d3e:	d9 f4       	brne	.+54     	; 0x2d76 <vTaskPriorityDisinheritAfterTimeout+0x84>
    2d40:	ef 01       	movw	r28, r30
    2d42:	8f 01       	movw	r16, r30
    2d44:	0e 5f       	subi	r16, 0xFE	; 254
    2d46:	1f 4f       	sbci	r17, 0xFF	; 255
    2d48:	c8 01       	movw	r24, r16
    2d4a:	0e 94 0a 1b 	call	0x3614	; 0x3614 <uxListRemove>
    2d4e:	8e 89       	ldd	r24, Y+22	; 0x16
    2d50:	90 91 5d 03 	lds	r25, 0x035D	; 0x80035d <uxTopReadyPriority>
    2d54:	98 17       	cp	r25, r24
    2d56:	10 f4       	brcc	.+4      	; 0x2d5c <vTaskPriorityDisinheritAfterTimeout+0x6a>
    2d58:	80 93 5d 03 	sts	0x035D, r24	; 0x80035d <uxTopReadyPriority>
    2d5c:	29 e0       	ldi	r18, 0x09	; 9
    2d5e:	82 9f       	mul	r24, r18
    2d60:	c0 01       	movw	r24, r0
    2d62:	11 24       	eor	r1, r1
    2d64:	b8 01       	movw	r22, r16
    2d66:	8d 56       	subi	r24, 0x6D	; 109
    2d68:	9c 4f       	sbci	r25, 0xFC	; 252
    2d6a:	df 91       	pop	r29
    2d6c:	cf 91       	pop	r28
    2d6e:	1f 91       	pop	r17
    2d70:	0f 91       	pop	r16
    2d72:	0c 94 b1 1a 	jmp	0x3562	; 0x3562 <vListInsertEnd>
    2d76:	df 91       	pop	r29
    2d78:	cf 91       	pop	r28
    2d7a:	1f 91       	pop	r17
    2d7c:	0f 91       	pop	r16
    2d7e:	08 95       	ret

00002d80 <pvTaskIncrementMutexHeldCount>:

    TaskHandle_t pvTaskIncrementMutexHeldCount( void )
    {
        /* If xSemaphoreCreateMutex() is called before any tasks have been created
        then pxCurrentTCB will be NULL. */
        if( pxCurrentTCB != NULL )
    2d80:	80 91 b7 03 	lds	r24, 0x03B7	; 0x8003b7 <pxCurrentTCB>
    2d84:	90 91 b8 03 	lds	r25, 0x03B8	; 0x8003b8 <pxCurrentTCB+0x1>
    2d88:	89 2b       	or	r24, r25
    2d8a:	39 f0       	breq	.+14     	; 0x2d9a <pvTaskIncrementMutexHeldCount+0x1a>
        {
            ( pxCurrentTCB->uxMutexesHeld )++;
    2d8c:	e0 91 b7 03 	lds	r30, 0x03B7	; 0x8003b7 <pxCurrentTCB>
    2d90:	f0 91 b8 03 	lds	r31, 0x03B8	; 0x8003b8 <pxCurrentTCB+0x1>
    2d94:	82 a1       	ldd	r24, Z+34	; 0x22
    2d96:	8f 5f       	subi	r24, 0xFF	; 255
    2d98:	82 a3       	std	Z+34, r24	; 0x22
        }

        return pxCurrentTCB;
    2d9a:	80 91 b7 03 	lds	r24, 0x03B7	; 0x8003b7 <pxCurrentTCB>
    2d9e:	90 91 b8 03 	lds	r25, 0x03B8	; 0x8003b8 <pxCurrentTCB+0x1>
    }
    2da2:	08 95       	ret

00002da4 <prvCheckForValidListAndQueue>:
            pxNewTimer->ucStatus = 0x00;
            prvInitialiseNewTimer( pcTimerName, xTimerPeriodInTicks, uxAutoReload, pvTimerID, pxCallbackFunction, pxNewTimer );
        }

        return pxNewTimer;
    }
    2da4:	0f b6       	in	r0, 0x3f	; 63
    2da6:	f8 94       	cli
    2da8:	0f 92       	push	r0
    2daa:	80 91 bd 03 	lds	r24, 0x03BD	; 0x8003bd <xTimerQueue>
    2dae:	90 91 be 03 	lds	r25, 0x03BE	; 0x8003be <xTimerQueue+0x1>
    2db2:	89 2b       	or	r24, r25
    2db4:	e9 f4       	brne	.+58     	; 0x2df0 <prvCheckForValidListAndQueue+0x4c>
    2db6:	8c ec       	ldi	r24, 0xCC	; 204
    2db8:	93 e0       	ldi	r25, 0x03	; 3
    2dba:	0e 94 9f 1a 	call	0x353e	; 0x353e <vListInitialise>
    2dbe:	83 ec       	ldi	r24, 0xC3	; 195
    2dc0:	93 e0       	ldi	r25, 0x03	; 3
    2dc2:	0e 94 9f 1a 	call	0x353e	; 0x353e <vListInitialise>
    2dc6:	8c ec       	ldi	r24, 0xCC	; 204
    2dc8:	93 e0       	ldi	r25, 0x03	; 3
    2dca:	90 93 c2 03 	sts	0x03C2, r25	; 0x8003c2 <pxCurrentTimerList+0x1>
    2dce:	80 93 c1 03 	sts	0x03C1, r24	; 0x8003c1 <pxCurrentTimerList>
    2dd2:	83 ec       	ldi	r24, 0xC3	; 195
    2dd4:	93 e0       	ldi	r25, 0x03	; 3
    2dd6:	90 93 c0 03 	sts	0x03C0, r25	; 0x8003c0 <pxOverflowTimerList+0x1>
    2dda:	80 93 bf 03 	sts	0x03BF, r24	; 0x8003bf <pxOverflowTimerList>
    2dde:	40 e0       	ldi	r20, 0x00	; 0
    2de0:	65 e0       	ldi	r22, 0x05	; 5
    2de2:	8a e0       	ldi	r24, 0x0A	; 10
    2de4:	0e 94 72 0e 	call	0x1ce4	; 0x1ce4 <xQueueGenericCreate>
    2de8:	90 93 be 03 	sts	0x03BE, r25	; 0x8003be <xTimerQueue+0x1>
    2dec:	80 93 bd 03 	sts	0x03BD, r24	; 0x8003bd <xTimerQueue>
    2df0:	0f 90       	pop	r0
    2df2:	0f be       	out	0x3f, r0	; 63
    2df4:	08 95       	ret

00002df6 <prvInsertTimerInActiveList>:
    2df6:	fc 01       	movw	r30, r24
    2df8:	73 83       	std	Z+3, r23	; 0x03
    2dfa:	62 83       	std	Z+2, r22	; 0x02
    2dfc:	91 87       	std	Z+9, r25	; 0x09
    2dfe:	80 87       	std	Z+8, r24	; 0x08
    2e00:	46 17       	cp	r20, r22
    2e02:	57 07       	cpc	r21, r23
    2e04:	78 f0       	brcs	.+30     	; 0x2e24 <prvInsertTimerInActiveList+0x2e>
    2e06:	42 1b       	sub	r20, r18
    2e08:	53 0b       	sbc	r21, r19
    2e0a:	84 85       	ldd	r24, Z+12	; 0x0c
    2e0c:	95 85       	ldd	r25, Z+13	; 0x0d
    2e0e:	48 17       	cp	r20, r24
    2e10:	59 07       	cpc	r21, r25
    2e12:	c8 f4       	brcc	.+50     	; 0x2e46 <prvInsertTimerInActiveList+0x50>
    2e14:	bf 01       	movw	r22, r30
    2e16:	6e 5f       	subi	r22, 0xFE	; 254
    2e18:	7f 4f       	sbci	r23, 0xFF	; 255
    2e1a:	80 91 bf 03 	lds	r24, 0x03BF	; 0x8003bf <pxOverflowTimerList>
    2e1e:	90 91 c0 03 	lds	r25, 0x03C0	; 0x8003c0 <pxOverflowTimerList+0x1>
    2e22:	0d c0       	rjmp	.+26     	; 0x2e3e <prvInsertTimerInActiveList+0x48>
    2e24:	42 17       	cp	r20, r18
    2e26:	53 07       	cpc	r21, r19
    2e28:	18 f4       	brcc	.+6      	; 0x2e30 <prvInsertTimerInActiveList+0x3a>
    2e2a:	62 17       	cp	r22, r18
    2e2c:	73 07       	cpc	r23, r19
    2e2e:	58 f4       	brcc	.+22     	; 0x2e46 <prvInsertTimerInActiveList+0x50>
    2e30:	bf 01       	movw	r22, r30
    2e32:	6e 5f       	subi	r22, 0xFE	; 254
    2e34:	7f 4f       	sbci	r23, 0xFF	; 255
    2e36:	80 91 c1 03 	lds	r24, 0x03C1	; 0x8003c1 <pxCurrentTimerList>
    2e3a:	90 91 c2 03 	lds	r25, 0x03C2	; 0x8003c2 <pxCurrentTimerList+0x1>
    2e3e:	0e 94 d2 1a 	call	0x35a4	; 0x35a4 <vListInsert>
    2e42:	80 e0       	ldi	r24, 0x00	; 0
    2e44:	08 95       	ret
    2e46:	81 e0       	ldi	r24, 0x01	; 1
    2e48:	08 95       	ret

00002e4a <xTimerCreateTimerTask>:
    2e4a:	ef 92       	push	r14
    2e4c:	ff 92       	push	r15
    2e4e:	0f 93       	push	r16
    2e50:	0e 94 d2 16 	call	0x2da4	; 0x2da4 <prvCheckForValidListAndQueue>
    2e54:	80 91 bd 03 	lds	r24, 0x03BD	; 0x8003bd <xTimerQueue>
    2e58:	90 91 be 03 	lds	r25, 0x03BE	; 0x8003be <xTimerQueue+0x1>
    2e5c:	89 2b       	or	r24, r25
    2e5e:	81 f0       	breq	.+32     	; 0x2e80 <xTimerCreateTimerTask+0x36>
    2e60:	8b eb       	ldi	r24, 0xBB	; 187
    2e62:	e8 2e       	mov	r14, r24
    2e64:	83 e0       	ldi	r24, 0x03	; 3
    2e66:	f8 2e       	mov	r15, r24
    2e68:	03 e0       	ldi	r16, 0x03	; 3
    2e6a:	20 e0       	ldi	r18, 0x00	; 0
    2e6c:	30 e0       	ldi	r19, 0x00	; 0
    2e6e:	45 e5       	ldi	r20, 0x55	; 85
    2e70:	50 e0       	ldi	r21, 0x00	; 0
    2e72:	62 ea       	ldi	r22, 0xA2	; 162
    2e74:	71 e0       	ldi	r23, 0x01	; 1
    2e76:	85 ed       	ldi	r24, 0xD5	; 213
    2e78:	97 e1       	ldi	r25, 0x17	; 23
    2e7a:	0e 94 74 11 	call	0x22e8	; 0x22e8 <xTaskCreate>
    2e7e:	01 c0       	rjmp	.+2      	; 0x2e82 <xTimerCreateTimerTask+0x38>
    2e80:	80 e0       	ldi	r24, 0x00	; 0
    2e82:	0f 91       	pop	r16
    2e84:	ff 90       	pop	r15
    2e86:	ef 90       	pop	r14
    2e88:	08 95       	ret

00002e8a <xTimerGenericCommand>:
    }
}
/*-----------------------------------------------------------*/

BaseType_t xTimerGenericCommand( TimerHandle_t xTimer, const BaseType_t xCommandID, const TickType_t xOptionalValue, BaseType_t * const pxHigherPriorityTaskWoken, const TickType_t xTicksToWait )
{
    2e8a:	0f 93       	push	r16
    2e8c:	1f 93       	push	r17
    2e8e:	cf 93       	push	r28
    2e90:	df 93       	push	r29
    2e92:	00 d0       	rcall	.+0      	; 0x2e94 <xTimerGenericCommand+0xa>
    2e94:	00 d0       	rcall	.+0      	; 0x2e96 <xTimerGenericCommand+0xc>
    2e96:	1f 92       	push	r1
    2e98:	cd b7       	in	r28, 0x3d	; 61
    2e9a:	de b7       	in	r29, 0x3e	; 62

    configASSERT( xTimer );

    /* Send a message to the timer service task to perform a particular action
    on a particular timer definition. */
    if( xTimerQueue != NULL )
    2e9c:	a0 91 bd 03 	lds	r26, 0x03BD	; 0x8003bd <xTimerQueue>
    2ea0:	b0 91 be 03 	lds	r27, 0x03BE	; 0x8003be <xTimerQueue+0x1>
    2ea4:	10 97       	sbiw	r26, 0x00	; 0
    2ea6:	29 f1       	breq	.+74     	; 0x2ef2 <xTimerGenericCommand+0x68>
    2ea8:	f9 01       	movw	r30, r18
    {
        /* Send a command to the timer service task to start the xTimer timer. */
        xMessage.xMessageID = xCommandID;
    2eaa:	69 83       	std	Y+1, r22	; 0x01
        xMessage.u.xTimerParameters.xMessageValue = xOptionalValue;
    2eac:	5b 83       	std	Y+3, r21	; 0x03
    2eae:	4a 83       	std	Y+2, r20	; 0x02
        xMessage.u.xTimerParameters.pxTimer = xTimer;
    2eb0:	9d 83       	std	Y+5, r25	; 0x05
    2eb2:	8c 83       	std	Y+4, r24	; 0x04

        if( xCommandID < tmrFIRST_FROM_ISR_COMMAND )
    2eb4:	66 30       	cpi	r22, 0x06	; 6
    2eb6:	a4 f4       	brge	.+40     	; 0x2ee0 <xTimerGenericCommand+0x56>
        {
            if( xTaskGetSchedulerState() == taskSCHEDULER_RUNNING )
    2eb8:	0e 94 ce 15 	call	0x2b9c	; 0x2b9c <xTaskGetSchedulerState>
    2ebc:	e0 91 bd 03 	lds	r30, 0x03BD	; 0x8003bd <xTimerQueue>
    2ec0:	f0 91 be 03 	lds	r31, 0x03BE	; 0x8003be <xTimerQueue+0x1>
            {
                xReturn = xQueueSendToBack( xTimerQueue, &xMessage, xTicksToWait );
    2ec4:	20 e0       	ldi	r18, 0x00	; 0
        xMessage.u.xTimerParameters.xMessageValue = xOptionalValue;
        xMessage.u.xTimerParameters.pxTimer = xTimer;

        if( xCommandID < tmrFIRST_FROM_ISR_COMMAND )
        {
            if( xTaskGetSchedulerState() == taskSCHEDULER_RUNNING )
    2ec6:	82 30       	cpi	r24, 0x02	; 2
    2ec8:	11 f4       	brne	.+4      	; 0x2ece <xTimerGenericCommand+0x44>
            {
                xReturn = xQueueSendToBack( xTimerQueue, &xMessage, xTicksToWait );
    2eca:	a8 01       	movw	r20, r16
    2ecc:	02 c0       	rjmp	.+4      	; 0x2ed2 <xTimerGenericCommand+0x48>
            }
            else
            {
                xReturn = xQueueSendToBack( xTimerQueue, &xMessage, tmrNO_DELAY );
    2ece:	40 e0       	ldi	r20, 0x00	; 0
    2ed0:	50 e0       	ldi	r21, 0x00	; 0
    2ed2:	be 01       	movw	r22, r28
    2ed4:	6f 5f       	subi	r22, 0xFF	; 255
    2ed6:	7f 4f       	sbci	r23, 0xFF	; 255
    2ed8:	cf 01       	movw	r24, r30
    2eda:	0e 94 9a 0e 	call	0x1d34	; 0x1d34 <xQueueGenericSend>
    2ede:	0a c0       	rjmp	.+20     	; 0x2ef4 <xTimerGenericCommand+0x6a>
            }
        }
        else
        {
            xReturn = xQueueSendToBackFromISR( xTimerQueue, &xMessage, pxHigherPriorityTaskWoken );
    2ee0:	20 e0       	ldi	r18, 0x00	; 0
    2ee2:	af 01       	movw	r20, r30
    2ee4:	be 01       	movw	r22, r28
    2ee6:	6f 5f       	subi	r22, 0xFF	; 255
    2ee8:	7f 4f       	sbci	r23, 0xFF	; 255
    2eea:	cd 01       	movw	r24, r26
    2eec:	0e 94 30 0f 	call	0x1e60	; 0x1e60 <xQueueGenericSendFromISR>
    2ef0:	01 c0       	rjmp	.+2      	; 0x2ef4 <xTimerGenericCommand+0x6a>
}
/*-----------------------------------------------------------*/

BaseType_t xTimerGenericCommand( TimerHandle_t xTimer, const BaseType_t xCommandID, const TickType_t xOptionalValue, BaseType_t * const pxHigherPriorityTaskWoken, const TickType_t xTicksToWait )
{
BaseType_t xReturn = pdFAIL;
    2ef2:	80 e0       	ldi	r24, 0x00	; 0
    {
        mtCOVERAGE_TEST_MARKER();
    }

    return xReturn;
}
    2ef4:	0f 90       	pop	r0
    2ef6:	0f 90       	pop	r0
    2ef8:	0f 90       	pop	r0
    2efa:	0f 90       	pop	r0
    2efc:	0f 90       	pop	r0
    2efe:	df 91       	pop	r29
    2f00:	cf 91       	pop	r28
    2f02:	1f 91       	pop	r17
    2f04:	0f 91       	pop	r16
    2f06:	08 95       	ret

00002f08 <prvSwitchTimerLists>:
    }
}
/*-----------------------------------------------------------*/

static void prvSwitchTimerLists( void )
{
    2f08:	ef 92       	push	r14
    2f0a:	ff 92       	push	r15
    2f0c:	0f 93       	push	r16
    2f0e:	1f 93       	push	r17
    2f10:	cf 93       	push	r28
    2f12:	df 93       	push	r29

    /* The tick count has overflowed.  The timer lists must be switched.
    If there are any timers still referenced from the current timer list
    then they must have expired and should be processed before the lists
    are switched. */
    while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
    2f14:	e0 91 c1 03 	lds	r30, 0x03C1	; 0x8003c1 <pxCurrentTimerList>
    2f18:	f0 91 c2 03 	lds	r31, 0x03C2	; 0x8003c2 <pxCurrentTimerList+0x1>
    2f1c:	80 81       	ld	r24, Z
    2f1e:	88 23       	and	r24, r24
    2f20:	89 f1       	breq	.+98     	; 0x2f84 <prvSwitchTimerLists+0x7c>
    {
        xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
    2f22:	05 80       	ldd	r0, Z+5	; 0x05
    2f24:	f6 81       	ldd	r31, Z+6	; 0x06
    2f26:	e0 2d       	mov	r30, r0
    2f28:	e0 80       	ld	r14, Z
    2f2a:	f1 80       	ldd	r15, Z+1	; 0x01

        /* Remove the timer from the list. */
        pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList ); /*lint !e9087 !e9079 void * is used as this macro is used with tasks and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    2f2c:	c6 81       	ldd	r28, Z+6	; 0x06
    2f2e:	d7 81       	ldd	r29, Z+7	; 0x07
        ( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
    2f30:	8e 01       	movw	r16, r28
    2f32:	0e 5f       	subi	r16, 0xFE	; 254
    2f34:	1f 4f       	sbci	r17, 0xFF	; 255
    2f36:	c8 01       	movw	r24, r16
    2f38:	0e 94 0a 1b 	call	0x3614	; 0x3614 <uxListRemove>
        traceTIMER_EXPIRED( pxTimer );

        /* Execute its callback, then send a command to restart the timer if
        it is an auto-reload timer.  It cannot be restarted here as the lists
        have not yet been switched. */
        pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
    2f3c:	e8 89       	ldd	r30, Y+16	; 0x10
    2f3e:	f9 89       	ldd	r31, Y+17	; 0x11
    2f40:	ce 01       	movw	r24, r28
    2f42:	09 95       	icall

        if( ( pxTimer->ucStatus & tmrSTATUS_IS_AUTORELOAD ) != 0 )
    2f44:	8a 89       	ldd	r24, Y+18	; 0x12
    2f46:	82 ff       	sbrs	r24, 2
    2f48:	e5 cf       	rjmp	.-54     	; 0x2f14 <prvSwitchTimerLists+0xc>
            the timer going into the same timer list then it has already expired
            and the timer should be re-inserted into the current list so it is
            processed again within this loop.  Otherwise a command should be sent
            to restart the timer to ensure it is only inserted into a list after
            the lists have been swapped. */
            xReloadTime = ( xNextExpireTime + pxTimer->xTimerPeriodInTicks );
    2f4a:	8c 85       	ldd	r24, Y+12	; 0x0c
    2f4c:	9d 85       	ldd	r25, Y+13	; 0x0d
    2f4e:	8e 0d       	add	r24, r14
    2f50:	9f 1d       	adc	r25, r15
            if( xReloadTime > xNextExpireTime )
    2f52:	e8 16       	cp	r14, r24
    2f54:	f9 06       	cpc	r15, r25
    2f56:	60 f4       	brcc	.+24     	; 0x2f70 <prvSwitchTimerLists+0x68>
            {
                listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xReloadTime );
    2f58:	9b 83       	std	Y+3, r25	; 0x03
    2f5a:	8a 83       	std	Y+2, r24	; 0x02
                listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
    2f5c:	d9 87       	std	Y+9, r29	; 0x09
    2f5e:	c8 87       	std	Y+8, r28	; 0x08
                vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
    2f60:	b8 01       	movw	r22, r16
    2f62:	80 91 c1 03 	lds	r24, 0x03C1	; 0x8003c1 <pxCurrentTimerList>
    2f66:	90 91 c2 03 	lds	r25, 0x03C2	; 0x8003c2 <pxCurrentTimerList+0x1>
    2f6a:	0e 94 d2 1a 	call	0x35a4	; 0x35a4 <vListInsert>
    2f6e:	d2 cf       	rjmp	.-92     	; 0x2f14 <prvSwitchTimerLists+0xc>
            }
            else
            {
                xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY );
    2f70:	00 e0       	ldi	r16, 0x00	; 0
    2f72:	10 e0       	ldi	r17, 0x00	; 0
    2f74:	20 e0       	ldi	r18, 0x00	; 0
    2f76:	30 e0       	ldi	r19, 0x00	; 0
    2f78:	a7 01       	movw	r20, r14
    2f7a:	60 e0       	ldi	r22, 0x00	; 0
    2f7c:	ce 01       	movw	r24, r28
    2f7e:	0e 94 45 17 	call	0x2e8a	; 0x2e8a <xTimerGenericCommand>
    2f82:	c8 cf       	rjmp	.-112    	; 0x2f14 <prvSwitchTimerLists+0xc>
            mtCOVERAGE_TEST_MARKER();
        }
    }

    pxTemp = pxCurrentTimerList;
    pxCurrentTimerList = pxOverflowTimerList;
    2f84:	80 91 bf 03 	lds	r24, 0x03BF	; 0x8003bf <pxOverflowTimerList>
    2f88:	90 91 c0 03 	lds	r25, 0x03C0	; 0x8003c0 <pxOverflowTimerList+0x1>
    2f8c:	90 93 c2 03 	sts	0x03C2, r25	; 0x8003c2 <pxCurrentTimerList+0x1>
    2f90:	80 93 c1 03 	sts	0x03C1, r24	; 0x8003c1 <pxCurrentTimerList>
    pxOverflowTimerList = pxTemp;
    2f94:	f0 93 c0 03 	sts	0x03C0, r31	; 0x8003c0 <pxOverflowTimerList+0x1>
    2f98:	e0 93 bf 03 	sts	0x03BF, r30	; 0x8003bf <pxOverflowTimerList>
}
    2f9c:	df 91       	pop	r29
    2f9e:	cf 91       	pop	r28
    2fa0:	1f 91       	pop	r17
    2fa2:	0f 91       	pop	r16
    2fa4:	ff 90       	pop	r15
    2fa6:	ef 90       	pop	r14
    2fa8:	08 95       	ret

00002faa <prvTimerTask>:
    pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
}
/*-----------------------------------------------------------*/

static portTASK_FUNCTION( prvTimerTask, pvParameters )
{
    2faa:	cf 93       	push	r28
    2fac:	df 93       	push	r29
    2fae:	00 d0       	rcall	.+0      	; 0x2fb0 <prvTimerTask+0x6>
    2fb0:	00 d0       	rcall	.+0      	; 0x2fb2 <prvTimerTask+0x8>
    2fb2:	1f 92       	push	r1
    2fb4:	cd b7       	in	r28, 0x3d	; 61
    2fb6:	de b7       	in	r29, 0x3e	; 62
    the timer with the nearest expiry time will expire.  If there are no
    active timers then just set the next expire time to 0.  That will cause
    this task to unblock when the tick count overflows, at which point the
    timer lists will be switched and the next expiry time can be
    re-assessed.  */
    *pxListWasEmpty = listLIST_IS_EMPTY( pxCurrentTimerList );
    2fb8:	e0 91 c1 03 	lds	r30, 0x03C1	; 0x8003c1 <pxCurrentTimerList>
    2fbc:	f0 91 c2 03 	lds	r31, 0x03C2	; 0x8003c2 <pxCurrentTimerList+0x1>
    2fc0:	d0 80       	ld	r13, Z
    if( *pxListWasEmpty == pdFALSE )
    2fc2:	dd 20       	and	r13, r13
    2fc4:	31 f0       	breq	.+12     	; 0x2fd2 <prvTimerTask+0x28>
    {
        xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
    2fc6:	05 80       	ldd	r0, Z+5	; 0x05
    2fc8:	f6 81       	ldd	r31, Z+6	; 0x06
    2fca:	e0 2d       	mov	r30, r0
    2fcc:	e0 80       	ld	r14, Z
    2fce:	f1 80       	ldd	r15, Z+1	; 0x01
    2fd0:	02 c0       	rjmp	.+4      	; 0x2fd6 <prvTimerTask+0x2c>
    }
    else
    {
        /* Ensure the task unblocks when the tick count rolls over. */
        xNextExpireTime = ( TickType_t ) 0U;
    2fd2:	e1 2c       	mov	r14, r1
    2fd4:	f1 2c       	mov	r15, r1
static void prvProcessTimerOrBlockTask( const TickType_t xNextExpireTime, BaseType_t xListWasEmpty )
{
TickType_t xTimeNow;
BaseType_t xTimerListsWereSwitched;

    vTaskSuspendAll();
    2fd6:	0e 94 f7 12 	call	0x25ee	; 0x25ee <vTaskSuspendAll>
static TickType_t prvSampleTimeNow( BaseType_t * const pxTimerListsWereSwitched )
{
TickType_t xTimeNow;
PRIVILEGED_DATA static TickType_t xLastTime = ( TickType_t ) 0U; /*lint !e956 Variable is only accessible to one task. */

    xTimeNow = xTaskGetTickCount();
    2fda:	0e 94 fd 12 	call	0x25fa	; 0x25fa <xTaskGetTickCount>
    2fde:	8c 01       	movw	r16, r24

    if( xTimeNow < xLastTime )
    2fe0:	80 91 b9 03 	lds	r24, 0x03B9	; 0x8003b9 <xLastTime.2412>
    2fe4:	90 91 ba 03 	lds	r25, 0x03BA	; 0x8003ba <xLastTime.2412+0x1>
    2fe8:	08 17       	cp	r16, r24
    2fea:	19 07       	cpc	r17, r25
    2fec:	20 f4       	brcc	.+8      	; 0x2ff6 <prvTimerTask+0x4c>
    {
        prvSwitchTimerLists();
    2fee:	0e 94 84 17 	call	0x2f08	; 0x2f08 <prvSwitchTimerLists>
        *pxTimerListsWereSwitched = pdTRUE;
    2ff2:	81 e0       	ldi	r24, 0x01	; 1
    2ff4:	01 c0       	rjmp	.+2      	; 0x2ff8 <prvTimerTask+0x4e>
    }
    else
    {
        *pxTimerListsWereSwitched = pdFALSE;
    2ff6:	80 e0       	ldi	r24, 0x00	; 0
    }

    xLastTime = xTimeNow;
    2ff8:	10 93 ba 03 	sts	0x03BA, r17	; 0x8003ba <xLastTime.2412+0x1>
    2ffc:	00 93 b9 03 	sts	0x03B9, r16	; 0x8003b9 <xLastTime.2412>
        has expired or not.  If obtaining the time causes the lists to switch
        then don't process this timer as any timers that remained in the list
        when the lists were switched will have been processed within the
        prvSampleTimeNow() function. */
        xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
        if( xTimerListsWereSwitched == pdFALSE )
    3000:	81 11       	cpse	r24, r1
    3002:	55 c0       	rjmp	.+170    	; 0x30ae <prvTimerTask+0x104>
        {
            /* The tick count has not overflowed, has the timer expired? */
            if( ( xListWasEmpty == pdFALSE ) && ( xNextExpireTime <= xTimeNow ) )
    3004:	dd 20       	and	r13, r13
    3006:	d9 f1       	breq	.+118    	; 0x307e <prvTimerTask+0xd4>
    3008:	0e 15       	cp	r16, r14
    300a:	1f 05       	cpc	r17, r15
    300c:	08 f4       	brcc	.+2      	; 0x3010 <prvTimerTask+0x66>
    300e:	3e c0       	rjmp	.+124    	; 0x308c <prvTimerTask+0xe2>
            {
                ( void ) xTaskResumeAll();
    3010:	0e 94 b3 13 	call	0x2766	; 0x2766 <xTaskResumeAll>
/*-----------------------------------------------------------*/

static void prvProcessExpiredTimer( const TickType_t xNextExpireTime, const TickType_t xTimeNow )
{
BaseType_t xResult;
Timer_t * const pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList ); /*lint !e9087 !e9079 void * is used as this macro is used with tasks and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    3014:	e0 91 c1 03 	lds	r30, 0x03C1	; 0x8003c1 <pxCurrentTimerList>
    3018:	f0 91 c2 03 	lds	r31, 0x03C2	; 0x8003c2 <pxCurrentTimerList+0x1>
    301c:	05 80       	ldd	r0, Z+5	; 0x05
    301e:	f6 81       	ldd	r31, Z+6	; 0x06
    3020:	e0 2d       	mov	r30, r0
    3022:	c6 80       	ldd	r12, Z+6	; 0x06
    3024:	d7 80       	ldd	r13, Z+7	; 0x07

    /* Remove the timer from the list of active timers.  A check has already
    been performed to ensure the list is not empty. */
    ( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
    3026:	c6 01       	movw	r24, r12
    3028:	02 96       	adiw	r24, 0x02	; 2
    302a:	0e 94 0a 1b 	call	0x3614	; 0x3614 <uxListRemove>
    traceTIMER_EXPIRED( pxTimer );

    /* If the timer is an auto reload timer then calculate the next
    expiry time and re-insert the timer in the list of active timers. */
    if( ( pxTimer->ucStatus & tmrSTATUS_IS_AUTORELOAD ) != 0 )
    302e:	d6 01       	movw	r26, r12
    3030:	52 96       	adiw	r26, 0x12	; 18
    3032:	8c 91       	ld	r24, X
    3034:	52 97       	sbiw	r26, 0x12	; 18
    3036:	82 ff       	sbrs	r24, 2
    3038:	17 c0       	rjmp	.+46     	; 0x3068 <prvTimerTask+0xbe>
    {
        /* The timer is inserted into a list using a time relative to anything
        other than the current time.  It will therefore be inserted into the
        correct list relative to the time this task thinks it is now. */
        if( prvInsertTimerInActiveList( pxTimer, ( xNextExpireTime + pxTimer->xTimerPeriodInTicks ), xTimeNow, xNextExpireTime ) != pdFALSE )
    303a:	1c 96       	adiw	r26, 0x0c	; 12
    303c:	6d 91       	ld	r22, X+
    303e:	7c 91       	ld	r23, X
    3040:	1d 97       	sbiw	r26, 0x0d	; 13
    3042:	6e 0d       	add	r22, r14
    3044:	7f 1d       	adc	r23, r15
    3046:	97 01       	movw	r18, r14
    3048:	a8 01       	movw	r20, r16
    304a:	c6 01       	movw	r24, r12
    304c:	0e 94 fb 16 	call	0x2df6	; 0x2df6 <prvInsertTimerInActiveList>
    3050:	88 23       	and	r24, r24
    3052:	69 f0       	breq	.+26     	; 0x306e <prvTimerTask+0xc4>
        {
            /* The timer expired before it was added to the active timer
            list.  Reload it now.  */
            xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY );
    3054:	00 e0       	ldi	r16, 0x00	; 0
    3056:	10 e0       	ldi	r17, 0x00	; 0
    3058:	20 e0       	ldi	r18, 0x00	; 0
    305a:	30 e0       	ldi	r19, 0x00	; 0
    305c:	a7 01       	movw	r20, r14
    305e:	60 e0       	ldi	r22, 0x00	; 0
    3060:	c6 01       	movw	r24, r12
    3062:	0e 94 45 17 	call	0x2e8a	; 0x2e8a <xTimerGenericCommand>
    3066:	03 c0       	rjmp	.+6      	; 0x306e <prvTimerTask+0xc4>
            mtCOVERAGE_TEST_MARKER();
        }
    }
    else
    {
        pxTimer->ucStatus &= ~tmrSTATUS_IS_ACTIVE;
    3068:	8e 7f       	andi	r24, 0xFE	; 254
    306a:	f6 01       	movw	r30, r12
    306c:	82 8b       	std	Z+18, r24	; 0x12
        mtCOVERAGE_TEST_MARKER();
    }

    /* Call the timer callback. */
    pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
    306e:	d6 01       	movw	r26, r12
    3070:	50 96       	adiw	r26, 0x10	; 16
    3072:	ed 91       	ld	r30, X+
    3074:	fc 91       	ld	r31, X
    3076:	51 97       	sbiw	r26, 0x11	; 17
    3078:	c6 01       	movw	r24, r12
    307a:	09 95       	icall
    307c:	1e c0       	rjmp	.+60     	; 0x30ba <prvTimerTask+0x110>
                case when the current timer list is empty. */
                if( xListWasEmpty != pdFALSE )
                {
                    /* The current timer list is empty - is the overflow list
                    also empty? */
                    xListWasEmpty = listLIST_IS_EMPTY( pxOverflowTimerList );
    307e:	e0 91 bf 03 	lds	r30, 0x03BF	; 0x8003bf <pxOverflowTimerList>
    3082:	f0 91 c0 03 	lds	r31, 0x03C0	; 0x8003c0 <pxOverflowTimerList+0x1>
    3086:	80 81       	ld	r24, Z
    3088:	41 e0       	ldi	r20, 0x01	; 1
    308a:	81 11       	cpse	r24, r1
        prvSampleTimeNow() function. */
        xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
        if( xTimerListsWereSwitched == pdFALSE )
        {
            /* The tick count has not overflowed, has the timer expired? */
            if( ( xListWasEmpty == pdFALSE ) && ( xNextExpireTime <= xTimeNow ) )
    308c:	40 e0       	ldi	r20, 0x00	; 0
                    /* The current timer list is empty - is the overflow list
                    also empty? */
                    xListWasEmpty = listLIST_IS_EMPTY( pxOverflowTimerList );
                }

                vQueueWaitForMessageRestricted( xTimerQueue, ( xNextExpireTime - xTimeNow ), xListWasEmpty );
    308e:	b7 01       	movw	r22, r14
    3090:	60 1b       	sub	r22, r16
    3092:	71 0b       	sbc	r23, r17
    3094:	80 91 bd 03 	lds	r24, 0x03BD	; 0x8003bd <xTimerQueue>
    3098:	90 91 be 03 	lds	r25, 0x03BE	; 0x8003be <xTimerQueue+0x1>
    309c:	0e 94 b3 10 	call	0x2166	; 0x2166 <vQueueWaitForMessageRestricted>

                if( xTaskResumeAll() == pdFALSE )
    30a0:	0e 94 b3 13 	call	0x2766	; 0x2766 <xTaskResumeAll>
    30a4:	81 11       	cpse	r24, r1
    30a6:	09 c0       	rjmp	.+18     	; 0x30ba <prvTimerTask+0x110>
                {
                    /* Yield to wait for either a command to arrive, or the
                    block time to expire.  If a command arrived between the
                    critical section being exited and this yield then the yield
                    will not cause the task to block. */
                    portYIELD_WITHIN_API();
    30a8:	0e 94 d2 1b 	call	0x37a4	; 0x37a4 <vPortYield>
    30ac:	06 c0       	rjmp	.+12     	; 0x30ba <prvTimerTask+0x110>
                }
            }
        }
        else
        {
            ( void ) xTaskResumeAll();
    30ae:	0e 94 b3 13 	call	0x2766	; 0x2766 <xTaskResumeAll>
    30b2:	03 c0       	rjmp	.+6      	; 0x30ba <prvTimerTask+0x110>
        }
        #endif /* INCLUDE_xTimerPendFunctionCall */

        /* Commands that are positive are timer commands rather than pended
        function calls. */
        if( xMessage.xMessageID >= ( BaseType_t ) 0 )
    30b4:	89 81       	ldd	r24, Y+1	; 0x01
    30b6:	87 ff       	sbrs	r24, 7
    30b8:	0e c0       	rjmp	.+28     	; 0x30d6 <prvTimerTask+0x12c>
DaemonTaskMessage_t xMessage;
Timer_t *pxTimer;
BaseType_t xTimerListsWereSwitched, xResult;
TickType_t xTimeNow;

    while( xQueueReceive( xTimerQueue, &xMessage, tmrNO_DELAY ) != pdFAIL ) /*lint !e603 xMessage does not have to be initialised as it is passed out, not in, and it is not used unless xQueueReceive() returns pdTRUE. */
    30ba:	40 e0       	ldi	r20, 0x00	; 0
    30bc:	50 e0       	ldi	r21, 0x00	; 0
    30be:	be 01       	movw	r22, r28
    30c0:	6f 5f       	subi	r22, 0xFF	; 255
    30c2:	7f 4f       	sbci	r23, 0xFF	; 255
    30c4:	80 91 bd 03 	lds	r24, 0x03BD	; 0x8003bd <xTimerQueue>
    30c8:	90 91 be 03 	lds	r25, 0x03BE	; 0x8003be <xTimerQueue+0x1>
    30cc:	0e 94 5f 0f 	call	0x1ebe	; 0x1ebe <xQueueReceive>
    30d0:	81 11       	cpse	r24, r1
    30d2:	f0 cf       	rjmp	.-32     	; 0x30b4 <prvTimerTask+0x10a>
    30d4:	71 cf       	rjmp	.-286    	; 0x2fb8 <prvTimerTask+0xe>
        function calls. */
        if( xMessage.xMessageID >= ( BaseType_t ) 0 )
        {
            /* The messages uses the xTimerParameters member to work on a
            software timer. */
            pxTimer = xMessage.u.xTimerParameters.pxTimer;
    30d6:	ec 80       	ldd	r14, Y+4	; 0x04
    30d8:	fd 80       	ldd	r15, Y+5	; 0x05

        if( listIS_CONTAINED_WITHIN( NULL, &( pxTimer->xTimerListItem ) ) == pdFALSE ) /*lint !e961. The cast is only redundant when NULL is passed into the macro. */
    30da:	f7 01       	movw	r30, r14
    30dc:	82 85       	ldd	r24, Z+10	; 0x0a
    30de:	93 85       	ldd	r25, Z+11	; 0x0b
    30e0:	89 2b       	or	r24, r25
    30e2:	21 f0       	breq	.+8      	; 0x30ec <prvTimerTask+0x142>
            {
                /* The timer is in a list, remove it. */
                ( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
    30e4:	c7 01       	movw	r24, r14
    30e6:	02 96       	adiw	r24, 0x02	; 2
    30e8:	0e 94 0a 1b 	call	0x3614	; 0x3614 <uxListRemove>
static TickType_t prvSampleTimeNow( BaseType_t * const pxTimerListsWereSwitched )
{
TickType_t xTimeNow;
PRIVILEGED_DATA static TickType_t xLastTime = ( TickType_t ) 0U; /*lint !e956 Variable is only accessible to one task. */

    xTimeNow = xTaskGetTickCount();
    30ec:	0e 94 fd 12 	call	0x25fa	; 0x25fa <xTaskGetTickCount>
    30f0:	6c 01       	movw	r12, r24

    if( xTimeNow < xLastTime )
    30f2:	80 91 b9 03 	lds	r24, 0x03B9	; 0x8003b9 <xLastTime.2412>
    30f6:	90 91 ba 03 	lds	r25, 0x03BA	; 0x8003ba <xLastTime.2412+0x1>
    30fa:	c8 16       	cp	r12, r24
    30fc:	d9 06       	cpc	r13, r25
    30fe:	10 f4       	brcc	.+4      	; 0x3104 <prvTimerTask+0x15a>
    {
        prvSwitchTimerLists();
    3100:	0e 94 84 17 	call	0x2f08	; 0x2f08 <prvSwitchTimerLists>
    else
    {
        *pxTimerListsWereSwitched = pdFALSE;
    }

    xLastTime = xTimeNow;
    3104:	d0 92 ba 03 	sts	0x03BA, r13	; 0x8003ba <xLastTime.2412+0x1>
    3108:	c0 92 b9 03 	sts	0x03B9, r12	; 0x8003b9 <xLastTime.2412>
            possibility of a higher priority task adding a message to the message
            queue with a time that is ahead of the timer daemon task (because it
            pre-empted the timer daemon task after the xTimeNow value was set). */
            xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );

            switch( xMessage.xMessageID )
    310c:	e9 81       	ldd	r30, Y+1	; 0x01
    310e:	0e 2e       	mov	r0, r30
    3110:	00 0c       	add	r0, r0
    3112:	ff 0b       	sbc	r31, r31
    3114:	ea 30       	cpi	r30, 0x0A	; 10
    3116:	f1 05       	cpc	r31, r1
    3118:	80 f6       	brcc	.-96     	; 0x30ba <prvTimerTask+0x110>
    311a:	ec 5c       	subi	r30, 0xCC	; 204
    311c:	ff 4f       	sbci	r31, 0xFF	; 255
    311e:	d7 01       	movw	r26, r14
    3120:	52 96       	adiw	r26, 0x12	; 18
    3122:	8c 91       	ld	r24, X
    3124:	0c 94 2a 1e 	jmp	0x3c54	; 0x3c54 <__tablejump2__>
                case tmrCOMMAND_START_FROM_ISR :
                case tmrCOMMAND_RESET :
                case tmrCOMMAND_RESET_FROM_ISR :
                case tmrCOMMAND_START_DONT_TRACE :
                    /* Start or restart a timer. */
                    pxTimer->ucStatus |= tmrSTATUS_IS_ACTIVE;
    3128:	81 60       	ori	r24, 0x01	; 1
    312a:	f7 01       	movw	r30, r14
    312c:	82 8b       	std	Z+18, r24	; 0x12
                    if( prvInsertTimerInActiveList( pxTimer,  xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, xTimeNow, xMessage.u.xTimerParameters.xMessageValue ) != pdFALSE )
    312e:	2a 81       	ldd	r18, Y+2	; 0x02
    3130:	3b 81       	ldd	r19, Y+3	; 0x03
    3132:	64 85       	ldd	r22, Z+12	; 0x0c
    3134:	75 85       	ldd	r23, Z+13	; 0x0d
    3136:	62 0f       	add	r22, r18
    3138:	73 1f       	adc	r23, r19
    313a:	a6 01       	movw	r20, r12
    313c:	c7 01       	movw	r24, r14
    313e:	0e 94 fb 16 	call	0x2df6	; 0x2df6 <prvInsertTimerInActiveList>
    3142:	88 23       	and	r24, r24
    3144:	09 f4       	brne	.+2      	; 0x3148 <prvTimerTask+0x19e>
    3146:	b9 cf       	rjmp	.-142    	; 0x30ba <prvTimerTask+0x110>
                    {
                        /* The timer expired before it was added to the active
                        timer list.  Process it now. */
                        pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
    3148:	d7 01       	movw	r26, r14
    314a:	50 96       	adiw	r26, 0x10	; 16
    314c:	ed 91       	ld	r30, X+
    314e:	fc 91       	ld	r31, X
    3150:	51 97       	sbiw	r26, 0x11	; 17
    3152:	c7 01       	movw	r24, r14
    3154:	09 95       	icall
                        traceTIMER_EXPIRED( pxTimer );

                        if( ( pxTimer->ucStatus & tmrSTATUS_IS_AUTORELOAD ) != 0 )
    3156:	f7 01       	movw	r30, r14
    3158:	82 89       	ldd	r24, Z+18	; 0x12
    315a:	82 ff       	sbrs	r24, 2
    315c:	ae cf       	rjmp	.-164    	; 0x30ba <prvTimerTask+0x110>
                        {
                            xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, NULL, tmrNO_DELAY );
    315e:	4a 81       	ldd	r20, Y+2	; 0x02
    3160:	5b 81       	ldd	r21, Y+3	; 0x03
    3162:	84 85       	ldd	r24, Z+12	; 0x0c
    3164:	95 85       	ldd	r25, Z+13	; 0x0d
    3166:	48 0f       	add	r20, r24
    3168:	59 1f       	adc	r21, r25
    316a:	00 e0       	ldi	r16, 0x00	; 0
    316c:	10 e0       	ldi	r17, 0x00	; 0
    316e:	20 e0       	ldi	r18, 0x00	; 0
    3170:	30 e0       	ldi	r19, 0x00	; 0
    3172:	60 e0       	ldi	r22, 0x00	; 0
    3174:	c7 01       	movw	r24, r14
    3176:	0e 94 45 17 	call	0x2e8a	; 0x2e8a <xTimerGenericCommand>
    317a:	9f cf       	rjmp	.-194    	; 0x30ba <prvTimerTask+0x110>
                    pxTimer->ucStatus &= ~tmrSTATUS_IS_ACTIVE;
                    break;

                case tmrCOMMAND_CHANGE_PERIOD :
                case tmrCOMMAND_CHANGE_PERIOD_FROM_ISR :
                    pxTimer->ucStatus |= tmrSTATUS_IS_ACTIVE;
    317c:	81 60       	ori	r24, 0x01	; 1
    317e:	f7 01       	movw	r30, r14
    3180:	82 8b       	std	Z+18, r24	; 0x12
                    pxTimer->xTimerPeriodInTicks = xMessage.u.xTimerParameters.xMessageValue;
    3182:	6a 81       	ldd	r22, Y+2	; 0x02
    3184:	7b 81       	ldd	r23, Y+3	; 0x03
    3186:	75 87       	std	Z+13, r23	; 0x0d
    3188:	64 87       	std	Z+12, r22	; 0x0c
                    be longer or shorter than the old one.  The command time is
                    therefore set to the current time, and as the period cannot
                    be zero the next expiry time can only be in the future,
                    meaning (unlike for the xTimerStart() case above) there is
                    no fail case that needs to be handled here. */
                    ( void ) prvInsertTimerInActiveList( pxTimer, ( xTimeNow + pxTimer->xTimerPeriodInTicks ), xTimeNow, xTimeNow );
    318a:	6c 0d       	add	r22, r12
    318c:	7d 1d       	adc	r23, r13
    318e:	96 01       	movw	r18, r12
    3190:	a6 01       	movw	r20, r12
    3192:	c7 01       	movw	r24, r14
    3194:	0e 94 fb 16 	call	0x2df6	; 0x2df6 <prvInsertTimerInActiveList>
    3198:	90 cf       	rjmp	.-224    	; 0x30ba <prvTimerTask+0x110>
                    #if ( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
                    {
                    /* The timer has already been removed from the active list,
                    just free up the memory if the memory was dynamically
                    allocated. */
                        if( ( pxTimer->ucStatus & tmrSTATUS_IS_STATICALLY_ALLOCATED ) == ( uint8_t ) 0 )
    319a:	81 fd       	sbrc	r24, 1
    319c:	04 c0       	rjmp	.+8      	; 0x31a6 <prvTimerTask+0x1fc>
                        {
                            vPortFree( pxTimer );
    319e:	c7 01       	movw	r24, r14
    31a0:	0e 94 8e 1a 	call	0x351c	; 0x351c <vPortFree>
    31a4:	8a cf       	rjmp	.-236    	; 0x30ba <prvTimerTask+0x110>
                        }
                        else
                        {
                            pxTimer->ucStatus &= ~tmrSTATUS_IS_ACTIVE;
    31a6:	8e 7f       	andi	r24, 0xFE	; 254
    31a8:	d7 01       	movw	r26, r14
    31aa:	52 96       	adiw	r26, 0x12	; 18
    31ac:	8c 93       	st	X, r24
    31ae:	85 cf       	rjmp	.-246    	; 0x30ba <prvTimerTask+0x110>

000031b0 <initVariant>:
{
#if defined(USBCON)
    USBDevice.attach();
#endif

    setup();        // the normal Arduino setup() function is run here.
    31b0:	0e 94 63 05 	call	0xac6	; 0xac6 <setup>
    vTaskStartScheduler(); // initialise and run the freeRTOS scheduler. Execution should never return here.
    31b4:	0e 94 c9 12 	call	0x2592	; 0x2592 <vTaskStartScheduler>
    31b8:	08 95       	ret

000031ba <vApplicationIdleHook>:
 */
void vApplicationIdleHook( void ) __attribute__((weak));

void vApplicationIdleHook( void )
{
    loop();        // the normal Arduino loop() function is run here.
    31ba:	0e 94 c5 05 	call	0xb8a	; 0xb8a <loop>
    if (serialEventRun) serialEventRun();
    31be:	8e e1       	ldi	r24, 0x1E	; 30
    31c0:	98 e0       	ldi	r25, 0x08	; 8
    31c2:	89 2b       	or	r24, r25
    31c4:	11 f0       	breq	.+4      	; 0x31ca <vApplicationIdleHook+0x10>
    31c6:	0c 94 1e 08 	jmp	0x103c	; 0x103c <_Z14serialEventRunv>
    31ca:	08 95       	ret

000031cc <vApplicationMallocFailedHook>:
#elif defined(__AVR_ATmega644P__) || defined(__AVR_ATmega644PA__) || defined(__AVR_ATmega1284P__) || defined(__AVR_ATmega1284PA__) // Seeed Goldilocks with 1284p
    DDRB  |= _BV(DDB7);
    PORTB |= _BV(PORTB7);       // Main (red PB7) LED on. Main LED on.

#elif defined(__AVR_ATmega328P__) || defined(__AVR_ATmega168__) || defined(__AVR_ATmega8__) // assume we're using an Arduino Uno with 328p
    DDRB  |= _BV(DDB5);
    31cc:	25 9a       	sbi	0x04, 5	; 4
    PORTB |= _BV(PORTB5);       // Main (red PB5) LED on. Main LED on.
    31ce:	2d 9a       	sbi	0x05, 5	; 5
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    31d0:	2f ef       	ldi	r18, 0xFF	; 255
    31d2:	80 e7       	ldi	r24, 0x70	; 112
    31d4:	92 e0       	ldi	r25, 0x02	; 2
    31d6:	21 50       	subi	r18, 0x01	; 1
    31d8:	80 40       	sbci	r24, 0x00	; 0
    31da:	90 40       	sbci	r25, 0x00	; 0
    31dc:	e1 f7       	brne	.-8      	; 0x31d6 <vApplicationMallocFailedHook+0xa>
    31de:	00 c0       	rjmp	.+0      	; 0x31e0 <vApplicationMallocFailedHook+0x14>
    31e0:	00 00       	nop

#elif defined(__AVR_ATmega644P__) || defined(__AVR_ATmega644PA__) || defined(__AVR_ATmega1284P__) || defined(__AVR_ATmega1284PA__) // Seeed Goldilocks with 1284p
        PINB  |= _BV(PINB7);       // Main (red PB7) LED toggle. Main LED fast blink.

#elif defined(__AVR_ATmega328P__) || defined(__AVR_ATmega168__) || defined(__AVR_ATmega8__) // assume we're using an Arduino Uno with 328p
        PINB  |= _BV(PINB5);       // Main (red PB5) LED toggle. Main LED fast blink.
    31e2:	1d 9a       	sbi	0x03, 5	; 3
    31e4:	f5 cf       	rjmp	.-22     	; 0x31d0 <vApplicationMallocFailedHook+0x4>

000031e6 <vApplicationStackOverflowHook>:
#elif defined(__AVR_ATmega644P__) || defined(__AVR_ATmega644PA__) || defined(__AVR_ATmega1284P__) || defined(__AVR_ATmega1284PA__) // Seeed Goldilocks with 1284p
    DDRB  |= _BV(DDB7);
    PORTB |= _BV(PORTB7);       // Main (red PB7) LED on. Main LED on.

#elif defined(__AVR_ATmega328P__) || defined(__AVR_ATmega168__) || defined(__AVR_ATmega8__) // assume we're using an Arduino Uno with 328p
    DDRB  |= _BV(DDB5);
    31e6:	25 9a       	sbi	0x04, 5	; 4
    PORTB |= _BV(PORTB5);       // Main (red PB5) LED on. Main LED on.
    31e8:	2d 9a       	sbi	0x05, 5	; 5
    31ea:	2f ef       	ldi	r18, 0xFF	; 255
    31ec:	87 ea       	ldi	r24, 0xA7	; 167
    31ee:	91 e6       	ldi	r25, 0x61	; 97
    31f0:	21 50       	subi	r18, 0x01	; 1
    31f2:	80 40       	sbci	r24, 0x00	; 0
    31f4:	90 40       	sbci	r25, 0x00	; 0
    31f6:	e1 f7       	brne	.-8      	; 0x31f0 <vApplicationStackOverflowHook+0xa>
    31f8:	00 c0       	rjmp	.+0      	; 0x31fa <vApplicationStackOverflowHook+0x14>
    31fa:	00 00       	nop

#elif defined(__AVR_ATmega644P__) || defined(__AVR_ATmega644PA__) || defined(__AVR_ATmega1284P__) || defined(__AVR_ATmega1284PA__) // Seeed Goldilocks with 1284p
        PINB  |= _BV(PINB7);       // Main (red PB7) LED toggle. Main LED slow blink.

#elif defined(__AVR_ATmega328P__) || defined(__AVR_ATmega168__) || defined(__AVR_ATmega8__) // assume we're using an Arduino Uno with 328p
        PINB  |= _BV(PINB5);       // Main (red PB5) LED toggle. Main LED slow blink.
    31fc:	1d 9a       	sbi	0x03, 5	; 3
    31fe:	f5 cf       	rjmp	.-22     	; 0x31ea <vApplicationStackOverflowHook+0x4>

00003200 <_ZN9MD_TCS23010initialiseEv>:
  }
  FreqCount.end();      // stop
  DUMP("VALUE ", FreqCount.read());

  return(FreqCount.read() * _readDiv);
}
    3200:	0f 93       	push	r16
    3202:	1f 93       	push	r17
    3204:	fc 01       	movw	r30, r24
    3206:	8f ef       	ldi	r24, 0xFF	; 255
    3208:	80 83       	st	Z, r24
    320a:	81 83       	std	Z+1, r24	; 0x01
    320c:	82 83       	std	Z+2, r24	; 0x02
    320e:	83 83       	std	Z+3, r24	; 0x03
    3210:	84 83       	std	Z+4, r24	; 0x04
    3212:	8a e0       	ldi	r24, 0x0A	; 10
    3214:	85 83       	std	Z+5, r24	; 0x05
    3216:	16 82       	std	Z+6, r1	; 0x06
    3218:	df 01       	movw	r26, r30
    321a:	17 96       	adiw	r26, 0x07	; 7
    321c:	73 96       	adiw	r30, 0x13	; 19
    321e:	00 e7       	ldi	r16, 0x70	; 112
    3220:	17 e1       	ldi	r17, 0x17	; 23
    3222:	20 e0       	ldi	r18, 0x00	; 0
    3224:	30 e0       	ldi	r19, 0x00	; 0
    3226:	48 ed       	ldi	r20, 0xD8	; 216
    3228:	56 ed       	ldi	r21, 0xD6	; 214
    322a:	60 e0       	ldi	r22, 0x00	; 0
    322c:	70 e0       	ldi	r23, 0x00	; 0
    322e:	0d 93       	st	X+, r16
    3230:	1d 93       	st	X+, r17
    3232:	2d 93       	st	X+, r18
    3234:	3d 93       	st	X+, r19
    3236:	18 96       	adiw	r26, 0x08	; 8
    3238:	4d 93       	st	X+, r20
    323a:	5d 93       	st	X+, r21
    323c:	6d 93       	st	X+, r22
    323e:	7c 93       	st	X, r23
    3240:	1b 97       	sbiw	r26, 0x0b	; 11
    3242:	ae 17       	cp	r26, r30
    3244:	bf 07       	cpc	r27, r31
    3246:	99 f7       	brne	.-26     	; 0x322e <_ZN9MD_TCS23010initialiseEv+0x2e>
    3248:	1f 91       	pop	r17
    324a:	0f 91       	pop	r16
    324c:	08 95       	ret

0000324e <_ZN9MD_TCS230C1Ehhh>:
    324e:	ff 92       	push	r15
    3250:	0f 93       	push	r16
    3252:	1f 93       	push	r17
    3254:	cf 93       	push	r28
    3256:	df 93       	push	r29
    3258:	ec 01       	movw	r28, r24
    325a:	f6 2e       	mov	r15, r22
    325c:	04 2f       	mov	r16, r20
    325e:	12 2f       	mov	r17, r18
    3260:	0e 94 00 19 	call	0x3200	; 0x3200 <_ZN9MD_TCS23010initialiseEv>
    3264:	fb 82       	std	Y+3, r15	; 0x03
    3266:	0c 83       	std	Y+4, r16	; 0x04
    3268:	18 83       	st	Y, r17
    326a:	df 91       	pop	r29
    326c:	cf 91       	pop	r28
    326e:	1f 91       	pop	r17
    3270:	0f 91       	pop	r16
    3272:	ff 90       	pop	r15
    3274:	08 95       	ret

00003276 <_ZN9MD_TCS230D1Ev>:
    3276:	08 95       	ret

00003278 <_ZN9MD_TCS2309setFilterEh>:
    3278:	cf 93       	push	r28
    327a:	df 93       	push	r29
    327c:	ec 01       	movw	r28, r24
    327e:	8b 81       	ldd	r24, Y+3	; 0x03
    3280:	8f 3f       	cpi	r24, 0xFF	; 255
    3282:	e9 f0       	breq	.+58     	; 0x32be <_ZN9MD_TCS2309setFilterEh+0x46>
    3284:	9c 81       	ldd	r25, Y+4	; 0x04
    3286:	9f 3f       	cpi	r25, 0xFF	; 255
    3288:	d1 f0       	breq	.+52     	; 0x32be <_ZN9MD_TCS2309setFilterEh+0x46>
    328a:	61 30       	cpi	r22, 0x01	; 1
    328c:	49 f0       	breq	.+18     	; 0x32a0 <_ZN9MD_TCS2309setFilterEh+0x28>
    328e:	30 f0       	brcs	.+12     	; 0x329c <_ZN9MD_TCS2309setFilterEh+0x24>
    3290:	62 30       	cpi	r22, 0x02	; 2
    3292:	41 f0       	breq	.+16     	; 0x32a4 <_ZN9MD_TCS2309setFilterEh+0x2c>
    3294:	63 30       	cpi	r22, 0x03	; 3
    3296:	99 f4       	brne	.+38     	; 0x32be <_ZN9MD_TCS2309setFilterEh+0x46>
    3298:	61 e0       	ldi	r22, 0x01	; 1
    329a:	09 c0       	rjmp	.+18     	; 0x32ae <_ZN9MD_TCS2309setFilterEh+0x36>
    329c:	60 e0       	ldi	r22, 0x00	; 0
    329e:	07 c0       	rjmp	.+14     	; 0x32ae <_ZN9MD_TCS2309setFilterEh+0x36>
    32a0:	61 e0       	ldi	r22, 0x01	; 1
    32a2:	01 c0       	rjmp	.+2      	; 0x32a6 <_ZN9MD_TCS2309setFilterEh+0x2e>
    32a4:	60 e0       	ldi	r22, 0x00	; 0
    32a6:	0e 94 4e 0d 	call	0x1a9c	; 0x1a9c <digitalWrite>
    32aa:	61 e0       	ldi	r22, 0x01	; 1
    32ac:	03 c0       	rjmp	.+6      	; 0x32b4 <_ZN9MD_TCS2309setFilterEh+0x3c>
    32ae:	0e 94 4e 0d 	call	0x1a9c	; 0x1a9c <digitalWrite>
    32b2:	60 e0       	ldi	r22, 0x00	; 0
    32b4:	8c 81       	ldd	r24, Y+4	; 0x04
    32b6:	df 91       	pop	r29
    32b8:	cf 91       	pop	r28
    32ba:	0c 94 4e 0d 	jmp	0x1a9c	; 0x1a9c <digitalWrite>
    32be:	df 91       	pop	r29
    32c0:	cf 91       	pop	r28
    32c2:	08 95       	ret

000032c4 <_ZN9MD_TCS23013setFrequency2Eh>:
    32c4:	cf 93       	push	r28
    32c6:	df 93       	push	r29
    32c8:	ec 01       	movw	r28, r24
    32ca:	89 81       	ldd	r24, Y+1	; 0x01
    32cc:	8f 3f       	cpi	r24, 0xFF	; 255
    32ce:	e9 f0       	breq	.+58     	; 0x330a <_ZN9MD_TCS23013setFrequency2Eh+0x46>
    32d0:	9a 81       	ldd	r25, Y+2	; 0x02
    32d2:	9f 3f       	cpi	r25, 0xFF	; 255
    32d4:	d1 f0       	breq	.+52     	; 0x330a <_ZN9MD_TCS23013setFrequency2Eh+0x46>
    32d6:	61 30       	cpi	r22, 0x01	; 1
    32d8:	49 f0       	breq	.+18     	; 0x32ec <_ZN9MD_TCS23013setFrequency2Eh+0x28>
    32da:	30 f0       	brcs	.+12     	; 0x32e8 <_ZN9MD_TCS23013setFrequency2Eh+0x24>
    32dc:	62 30       	cpi	r22, 0x02	; 2
    32de:	41 f0       	breq	.+16     	; 0x32f0 <_ZN9MD_TCS23013setFrequency2Eh+0x2c>
    32e0:	63 30       	cpi	r22, 0x03	; 3
    32e2:	99 f4       	brne	.+38     	; 0x330a <_ZN9MD_TCS23013setFrequency2Eh+0x46>
    32e4:	60 e0       	ldi	r22, 0x00	; 0
    32e6:	09 c0       	rjmp	.+18     	; 0x32fa <_ZN9MD_TCS23013setFrequency2Eh+0x36>
    32e8:	61 e0       	ldi	r22, 0x01	; 1
    32ea:	03 c0       	rjmp	.+6      	; 0x32f2 <_ZN9MD_TCS23013setFrequency2Eh+0x2e>
    32ec:	61 e0       	ldi	r22, 0x01	; 1
    32ee:	05 c0       	rjmp	.+10     	; 0x32fa <_ZN9MD_TCS23013setFrequency2Eh+0x36>
    32f0:	60 e0       	ldi	r22, 0x00	; 0
    32f2:	0e 94 4e 0d 	call	0x1a9c	; 0x1a9c <digitalWrite>
    32f6:	61 e0       	ldi	r22, 0x01	; 1
    32f8:	03 c0       	rjmp	.+6      	; 0x3300 <_ZN9MD_TCS23013setFrequency2Eh+0x3c>
    32fa:	0e 94 4e 0d 	call	0x1a9c	; 0x1a9c <digitalWrite>
    32fe:	60 e0       	ldi	r22, 0x00	; 0
    3300:	8a 81       	ldd	r24, Y+2	; 0x02
    3302:	df 91       	pop	r29
    3304:	cf 91       	pop	r28
    3306:	0c 94 4e 0d 	jmp	0x1a9c	; 0x1a9c <digitalWrite>
    330a:	df 91       	pop	r29
    330c:	cf 91       	pop	r28
    330e:	08 95       	ret

00003310 <_ZN9MD_TCS2309setEnableEb>:
    3310:	fc 01       	movw	r30, r24
    3312:	20 81       	ld	r18, Z
    3314:	2f 3f       	cpi	r18, 0xFF	; 255
    3316:	29 f0       	breq	.+10     	; 0x3322 <_ZN9MD_TCS2309setEnableEb+0x12>
    3318:	91 e0       	ldi	r25, 0x01	; 1
    331a:	69 27       	eor	r22, r25
    331c:	82 2f       	mov	r24, r18
    331e:	0c 94 4e 0d 	jmp	0x1a9c	; 0x1a9c <digitalWrite>
    3322:	66 23       	and	r22, r22
    3324:	19 f0       	breq	.+6      	; 0x332c <_ZN9MD_TCS2309setEnableEb+0x1c>
    3326:	fc 01       	movw	r30, r24
    3328:	66 81       	ldd	r22, Z+6	; 0x06
    332a:	01 c0       	rjmp	.+2      	; 0x332e <_ZN9MD_TCS2309setEnableEb+0x1e>
    332c:	63 e0       	ldi	r22, 0x03	; 3
    332e:	0c 94 62 19 	jmp	0x32c4	; 0x32c4 <_ZN9MD_TCS23013setFrequency2Eh>

00003332 <_ZN9MD_TCS2306getRGBEP9colorData>:
    3332:	dc 01       	movw	r26, r24
    3334:	fb 01       	movw	r30, r22
    3336:	30 97       	sbiw	r30, 0x00	; 0
    3338:	59 f0       	breq	.+22     	; 0x3350 <_ZN9MD_TCS2306getRGBEP9colorData+0x1e>
    333a:	9b 96       	adiw	r26, 0x2b	; 43
    333c:	8c 91       	ld	r24, X
    333e:	9b 97       	sbiw	r26, 0x2b	; 43
    3340:	80 83       	st	Z, r24
    3342:	9c 96       	adiw	r26, 0x2c	; 44
    3344:	8c 91       	ld	r24, X
    3346:	9c 97       	sbiw	r26, 0x2c	; 44
    3348:	81 83       	std	Z+1, r24	; 0x01
    334a:	9d 96       	adiw	r26, 0x2d	; 45
    334c:	8c 91       	ld	r24, X
    334e:	82 83       	std	Z+2, r24	; 0x02
    3350:	08 95       	ret

00003352 <_ZN9MD_TCS23017RGBTransformationEv>:
  return(s);
}

void MD_TCS230::RGBTransformation(void)
// Exploiting linear relationship to remap the range 
{
    3352:	4f 92       	push	r4
    3354:	5f 92       	push	r5
    3356:	6f 92       	push	r6
    3358:	7f 92       	push	r7
    335a:	8f 92       	push	r8
    335c:	9f 92       	push	r9
    335e:	af 92       	push	r10
    3360:	bf 92       	push	r11
    3362:	df 92       	push	r13
    3364:	ef 92       	push	r14
    3366:	ff 92       	push	r15
    3368:	0f 93       	push	r16
    336a:	1f 93       	push	r17
    336c:	cf 93       	push	r28
    336e:	df 93       	push	r29
    3370:	8c 01       	movw	r16, r24
    3372:	09 5f       	subi	r16, 0xF9	; 249
    3374:	1f 4f       	sbci	r17, 0xFF	; 255
    3376:	ec 01       	movw	r28, r24
    3378:	7c 01       	movw	r14, r24
    337a:	83 e1       	ldi	r24, 0x13	; 19
    337c:	e8 0e       	add	r14, r24
    337e:	f1 1c       	adc	r15, r1
    x = (_Fo.value[i] - _Fd.value[i]) * 255;
    x /= (_Fw.value[i] - _Fd.value[i]);

    // copy results back into the global structures
    if (x < 0) _rgb.value[i] = 0; 
    else if (x > 255) _rgb.value[i] = 255;
    3380:	dd 24       	eor	r13, r13
    3382:	da 94       	dec	r13
    3384:	f8 01       	movw	r30, r16
{
  int32_t x;

  for (uint8_t i=0; i<RGB_SIZE; i++)
  {
    x = (_Fo.value[i] - _Fd.value[i]) * 255;
    3386:	d8 01       	movw	r26, r16
    3388:	8d 90       	ld	r8, X+
    338a:	9d 90       	ld	r9, X+
    338c:	ad 90       	ld	r10, X+
    338e:	bd 90       	ld	r11, X+
    3390:	8d 01       	movw	r16, r26
    3392:	80 8d       	ldd	r24, Z+24	; 0x18
    3394:	91 8d       	ldd	r25, Z+25	; 0x19
    3396:	a2 8d       	ldd	r26, Z+26	; 0x1a
    3398:	b3 8d       	ldd	r27, Z+27	; 0x1b
    339a:	9c 01       	movw	r18, r24
    339c:	ad 01       	movw	r20, r26
    339e:	28 19       	sub	r18, r8
    33a0:	39 09       	sbc	r19, r9
    33a2:	4a 09       	sbc	r20, r10
    33a4:	5b 09       	sbc	r21, r11
    33a6:	af ef       	ldi	r26, 0xFF	; 255
    33a8:	b0 e0       	ldi	r27, 0x00	; 0
    33aa:	0e 94 30 1e 	call	0x3c60	; 0x3c60 <__muluhisi3>
    x /= (_Fw.value[i] - _Fd.value[i]);
    33ae:	f8 01       	movw	r30, r16
    33b0:	40 84       	ldd	r4, Z+8	; 0x08
    33b2:	51 84       	ldd	r5, Z+9	; 0x09
    33b4:	62 84       	ldd	r6, Z+10	; 0x0a
    33b6:	73 84       	ldd	r7, Z+11	; 0x0b
    33b8:	a3 01       	movw	r20, r6
    33ba:	92 01       	movw	r18, r4
    33bc:	28 19       	sub	r18, r8
    33be:	39 09       	sbc	r19, r9
    33c0:	4a 09       	sbc	r20, r10
    33c2:	5b 09       	sbc	r21, r11
    33c4:	0e 94 0b 1e 	call	0x3c16	; 0x3c16 <__divmodsi4>

    // copy results back into the global structures
    if (x < 0) _rgb.value[i] = 0; 
    33c8:	57 ff       	sbrs	r21, 7
    33ca:	02 c0       	rjmp	.+4      	; 0x33d0 <_ZN9MD_TCS23017RGBTransformationEv+0x7e>
    33cc:	1b a6       	std	Y+43, r1	; 0x2b
    33ce:	09 c0       	rjmp	.+18     	; 0x33e2 <_ZN9MD_TCS23017RGBTransformationEv+0x90>
    else if (x > 255) _rgb.value[i] = 255;
    33d0:	2f 3f       	cpi	r18, 0xFF	; 255
    33d2:	31 05       	cpc	r19, r1
    33d4:	41 05       	cpc	r20, r1
    33d6:	51 05       	cpc	r21, r1
    33d8:	19 f0       	breq	.+6      	; 0x33e0 <_ZN9MD_TCS23017RGBTransformationEv+0x8e>
    33da:	14 f0       	brlt	.+4      	; 0x33e0 <_ZN9MD_TCS23017RGBTransformationEv+0x8e>
    33dc:	db a6       	std	Y+43, r13	; 0x2b
    33de:	01 c0       	rjmp	.+2      	; 0x33e2 <_ZN9MD_TCS23017RGBTransformationEv+0x90>
    else _rgb.value[i] = x;
    33e0:	2b a7       	std	Y+43, r18	; 0x2b
    33e2:	21 96       	adiw	r28, 0x01	; 1
void MD_TCS230::RGBTransformation(void)
// Exploiting linear relationship to remap the range 
{
  int32_t x;

  for (uint8_t i=0; i<RGB_SIZE; i++)
    33e4:	0e 15       	cp	r16, r14
    33e6:	1f 05       	cpc	r17, r15
    33e8:	69 f6       	brne	.-102    	; 0x3384 <_ZN9MD_TCS23017RGBTransformationEv+0x32>
    // copy results back into the global structures
    if (x < 0) _rgb.value[i] = 0; 
    else if (x > 255) _rgb.value[i] = 255;
    else _rgb.value[i] = x;
  }
}
    33ea:	df 91       	pop	r29
    33ec:	cf 91       	pop	r28
    33ee:	1f 91       	pop	r17
    33f0:	0f 91       	pop	r16
    33f2:	ff 90       	pop	r15
    33f4:	ef 90       	pop	r14
    33f6:	df 90       	pop	r13
    33f8:	bf 90       	pop	r11
    33fa:	af 90       	pop	r10
    33fc:	9f 90       	pop	r9
    33fe:	8f 90       	pop	r8
    3400:	7f 90       	pop	r7
    3402:	6f 90       	pop	r6
    3404:	5f 90       	pop	r5
    3406:	4f 90       	pop	r4
    3408:	08 95       	ret

0000340a <_ZN9MD_TCS2307readFSMEh>:
  return(_readState == 0);
}

uint8_t MD_TCS230::readFSM(uint8_t s)
// Finite State Machine to read a value (internal function)
{
    340a:	0f 93       	push	r16
    340c:	1f 93       	push	r17
    340e:	cf 93       	push	r28
    3410:	df 93       	push	r29
    3412:	8c 01       	movw	r16, r24
    3414:	c6 2f       	mov	r28, r22
  static const uint8_t seq[] = { TCS230_RGB_R, TCS230_RGB_G, TCS230_RGB_B };
  static uint8_t       currCol;  // index for seq above

  switch(s)
    3416:	61 30       	cpi	r22, 0x01	; 1
    3418:	49 f0       	breq	.+18     	; 0x342c <_ZN9MD_TCS2307readFSMEh+0x22>
    341a:	18 f0       	brcs	.+6      	; 0x3422 <_ZN9MD_TCS2307readFSMEh+0x18>
    341c:	62 30       	cpi	r22, 0x02	; 2
    341e:	d9 f0       	breq	.+54     	; 0x3456 <_ZN9MD_TCS2307readFSMEh+0x4c>
    3420:	4c c0       	rjmp	.+152    	; 0x34ba <_ZN9MD_TCS2307readFSMEh+0xb0>
  {
  case 0: // enable the hardware for reading
    DUMPS("\n0");
    currCol = 0;  // RGB_R but we don't care
    3422:	10 92 d5 03 	sts	0x03D5, r1	; 0x8003d5 <_ZZN9MD_TCS2307readFSMEhE7currCol>
    setEnable(true);
    3426:	61 e0       	ldi	r22, 0x01	; 1
    3428:	0e 94 88 19 	call	0x3310	; 0x3310 <_ZN9MD_TCS2309setEnableEb>
    s++;
    // fall through to the next state

  case 1: // select a filter and start a reading
    DUMPS("\n1");
    setFilter(seq[currCol]);
    342c:	e0 91 d5 03 	lds	r30, 0x03D5	; 0x8003d5 <_ZZN9MD_TCS2307readFSMEhE7currCol>
    3430:	f0 e0       	ldi	r31, 0x00	; 0
    3432:	e6 55       	subi	r30, 0x56	; 86
    3434:	fe 4f       	sbci	r31, 0xFE	; 254
    3436:	60 81       	ld	r22, Z
    3438:	c8 01       	movw	r24, r16
    343a:	0e 94 3c 19 	call	0x3278	; 0x3278 <_ZN9MD_TCS2309setFilterEh>
    FreqCount.begin(1000/_readDiv);
    343e:	f8 01       	movw	r30, r16
    3440:	65 81       	ldd	r22, Z+5	; 0x05
    3442:	70 e0       	ldi	r23, 0x00	; 0
    3444:	88 ee       	ldi	r24, 0xE8	; 232
    3446:	93 e0       	ldi	r25, 0x03	; 3
    3448:	0e 94 d5 1d 	call	0x3baa	; 0x3baa <__divmodhi4>
    344c:	cb 01       	movw	r24, r22
    344e:	0e 94 8b 1c 	call	0x3916	; 0x3916 <_ZN14FreqCountClass5beginEj>
    s++;
    3452:	c2 e0       	ldi	r28, 0x02	; 2
    break;
    3454:	32 c0       	rjmp	.+100    	; 0x34ba <_ZN9MD_TCS2307readFSMEh+0xb0>

  case 2: // see if a value is available
    DUMPS("2");
    if (FreqCount.available())
    3456:	0e 94 03 1d 	call	0x3a06	; 0x3a06 <_ZN14FreqCountClass9availableEv>
    345a:	88 23       	and	r24, r24
    345c:	71 f1       	breq	.+92     	; 0x34ba <_ZN9MD_TCS2307readFSMEh+0xb0>
    {
      DUMP(" VALUE ", FreqCount.read());
      // read the value and save it 
      _Fo.value[seq[currCol++]] = FreqCount.read() * _readDiv;
    345e:	e0 91 d5 03 	lds	r30, 0x03D5	; 0x8003d5 <_ZZN9MD_TCS2307readFSMEhE7currCol>
    3462:	81 e0       	ldi	r24, 0x01	; 1
    3464:	8e 0f       	add	r24, r30
    3466:	80 93 d5 03 	sts	0x03D5, r24	; 0x8003d5 <_ZZN9MD_TCS2307readFSMEhE7currCol>
    346a:	f0 e0       	ldi	r31, 0x00	; 0
    346c:	e6 55       	subi	r30, 0x56	; 86
    346e:	fe 4f       	sbci	r31, 0xFE	; 254
    3470:	c0 81       	ld	r28, Z
    3472:	d0 e0       	ldi	r29, 0x00	; 0
    3474:	0e 94 06 1d 	call	0x3a0c	; 0x3a0c <_ZN14FreqCountClass4readEv>
    3478:	9b 01       	movw	r18, r22
    347a:	ac 01       	movw	r20, r24
    347c:	cc 0f       	add	r28, r28
    347e:	dd 1f       	adc	r29, r29
    3480:	cc 0f       	add	r28, r28
    3482:	dd 1f       	adc	r29, r29
    3484:	c0 0f       	add	r28, r16
    3486:	d1 1f       	adc	r29, r17
    3488:	f8 01       	movw	r30, r16
    348a:	a5 81       	ldd	r26, Z+5	; 0x05
    348c:	b0 e0       	ldi	r27, 0x00	; 0
    348e:	0e 94 30 1e 	call	0x3c60	; 0x3c60 <__muluhisi3>
    3492:	6f 8f       	std	Y+31, r22	; 0x1f
    3494:	78 a3       	std	Y+32, r23	; 0x20
    3496:	89 a3       	std	Y+33, r24	; 0x21
    3498:	9a a3       	std	Y+34, r25	; 0x22

      if (currCol < RGB_SIZE)
    349a:	80 91 d5 03 	lds	r24, 0x03D5	; 0x8003d5 <_ZZN9MD_TCS2307readFSMEhE7currCol>
    349e:	83 30       	cpi	r24, 0x03	; 3
    34a0:	58 f0       	brcs	.+22     	; 0x34b8 <_ZN9MD_TCS2307readFSMEh+0xae>
        s--;
      }
      else
      {
        // end this reading session
        FreqCount.end();
    34a2:	0e 94 14 1d 	call	0x3a28	; 0x3a28 <_ZN14FreqCountClass3endEv>
        setEnable(false);
    34a6:	60 e0       	ldi	r22, 0x00	; 0
    34a8:	c8 01       	movw	r24, r16
    34aa:	0e 94 88 19 	call	0x3310	; 0x3310 <_ZN9MD_TCS2309setEnableEb>
        RGBTransformation();
    34ae:	c8 01       	movw	r24, r16
    34b0:	0e 94 a9 19 	call	0x3352	; 0x3352 <_ZN9MD_TCS23017RGBTransformationEv>
        s = 0;
    34b4:	c0 e0       	ldi	r28, 0x00	; 0
    34b6:	01 c0       	rjmp	.+2      	; 0x34ba <_ZN9MD_TCS2307readFSMEh+0xb0>
      _Fo.value[seq[currCol++]] = FreqCount.read() * _readDiv;

      if (currCol < RGB_SIZE)
      {
        // loop around again on next call to available()
        s--;
    34b8:	c1 e0       	ldi	r28, 0x01	; 1
    }
    break;
  }

  return(s);
}
    34ba:	8c 2f       	mov	r24, r28
    34bc:	df 91       	pop	r29
    34be:	cf 91       	pop	r28
    34c0:	1f 91       	pop	r17
    34c2:	0f 91       	pop	r16
    34c4:	08 95       	ret

000034c6 <_ZN9MD_TCS2304readEv>:
  return(FreqCount.read() * _readDiv);
}

void MD_TCS230::read(void)
// initiate the finite state machine for reading a value
{
    34c6:	cf 93       	push	r28
    34c8:	df 93       	push	r29
    34ca:	ec 01       	movw	r28, r24
  _readState = readFSM(0);
    34cc:	60 e0       	ldi	r22, 0x00	; 0
    34ce:	0e 94 05 1a 	call	0x340a	; 0x340a <_ZN9MD_TCS2307readFSMEh>
    34d2:	8e a7       	std	Y+46, r24	; 0x2e
}
    34d4:	df 91       	pop	r29
    34d6:	cf 91       	pop	r28
    34d8:	08 95       	ret

000034da <_ZN9MD_TCS2309availableEv>:

bool MD_TCS230::available(void)
// check if a value is ready. Called repeatedly until it is!
{
    34da:	cf 93       	push	r28
    34dc:	df 93       	push	r29
    34de:	ec 01       	movw	r28, r24
  _readState = readFSM(_readState);
    34e0:	6e a5       	ldd	r22, Y+46	; 0x2e
    34e2:	0e 94 05 1a 	call	0x340a	; 0x340a <_ZN9MD_TCS2307readFSMEh>
    34e6:	98 2f       	mov	r25, r24
    34e8:	8e a7       	std	Y+46, r24	; 0x2e

  return(_readState == 0);
    34ea:	81 e0       	ldi	r24, 0x01	; 1
    34ec:	91 11       	cpse	r25, r1
    34ee:	80 e0       	ldi	r24, 0x00	; 0
}
    34f0:	df 91       	pop	r29
    34f2:	cf 91       	pop	r28
    34f4:	08 95       	ret

000034f6 <pvPortMalloc>:
#if( configSUPPORT_DYNAMIC_ALLOCATION > 0 )

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
    34f6:	cf 93       	push	r28
    34f8:	df 93       	push	r29
    34fa:	ec 01       	movw	r28, r24
void *pvReturn;

    vTaskSuspendAll();
    34fc:	0e 94 f7 12 	call	0x25ee	; 0x25ee <vTaskSuspendAll>
    {
        pvReturn = malloc( xWantedSize );
    3500:	ce 01       	movw	r24, r28
    3502:	0e 94 5e 1e 	call	0x3cbc	; 0x3cbc <malloc>
    3506:	ec 01       	movw	r28, r24
        traceMALLOC( pvReturn, xWantedSize );
    }
    ( void ) xTaskResumeAll();
    3508:	0e 94 b3 13 	call	0x2766	; 0x2766 <xTaskResumeAll>

    #if( configUSE_MALLOC_FAILED_HOOK == 1 )
    {
        if( pvReturn == NULL )
    350c:	20 97       	sbiw	r28, 0x00	; 0
    350e:	11 f4       	brne	.+4      	; 0x3514 <pvPortMalloc+0x1e>
        {
            extern void vApplicationMallocFailedHook( void );
            vApplicationMallocFailedHook();
    3510:	0e 94 e6 18 	call	0x31cc	; 0x31cc <vApplicationMallocFailedHook>
        }
    }
    #endif

    return pvReturn;
}
    3514:	ce 01       	movw	r24, r28
    3516:	df 91       	pop	r29
    3518:	cf 91       	pop	r28
    351a:	08 95       	ret

0000351c <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
    351c:	cf 93       	push	r28
    351e:	df 93       	push	r29
    if( pv )
    3520:	00 97       	sbiw	r24, 0x00	; 0
    3522:	51 f0       	breq	.+20     	; 0x3538 <vPortFree+0x1c>
    3524:	ec 01       	movw	r28, r24
    {
        vTaskSuspendAll();
    3526:	0e 94 f7 12 	call	0x25ee	; 0x25ee <vTaskSuspendAll>
        {
            free( pv );
    352a:	ce 01       	movw	r24, r28
    352c:	0e 94 f6 1e 	call	0x3dec	; 0x3dec <free>
            traceFREE( pv, 0 );
        }
        ( void ) xTaskResumeAll();
    }
}
    3530:	df 91       	pop	r29
    3532:	cf 91       	pop	r28
        vTaskSuspendAll();
        {
            free( pv );
            traceFREE( pv, 0 );
        }
        ( void ) xTaskResumeAll();
    3534:	0c 94 b3 13 	jmp	0x2766	; 0x2766 <xTaskResumeAll>
    }
}
    3538:	df 91       	pop	r29
    353a:	cf 91       	pop	r28
    353c:	08 95       	ret

0000353e <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
    353e:	fc 01       	movw	r30, r24
    /* The list structure contains a list item which is used to mark the
    end of the list.  To initialise the list the list end is inserted
    as the only list entry. */
    pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );            /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    3540:	03 96       	adiw	r24, 0x03	; 3
    3542:	92 83       	std	Z+2, r25	; 0x02
    3544:	81 83       	std	Z+1, r24	; 0x01

    /* The list end value is the highest possible value in the list to
    ensure it remains at the end of the list. */
    pxList->xListEnd.xItemValue = portMAX_DELAY;
    3546:	2f ef       	ldi	r18, 0xFF	; 255
    3548:	3f ef       	ldi	r19, 0xFF	; 255
    354a:	34 83       	std	Z+4, r19	; 0x04
    354c:	23 83       	std	Z+3, r18	; 0x03

    /* The list end next and previous pointers point to itself so we know
    when the list is empty. */
    pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );    /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    354e:	96 83       	std	Z+6, r25	; 0x06
    3550:	85 83       	std	Z+5, r24	; 0x05
    pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    3552:	90 87       	std	Z+8, r25	; 0x08
    3554:	87 83       	std	Z+7, r24	; 0x07

    pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
    3556:	10 82       	st	Z, r1
    3558:	08 95       	ret

0000355a <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
    /* Make sure the list item is not recorded as being on a list. */
    pxItem->pxContainer = NULL;
    355a:	fc 01       	movw	r30, r24
    355c:	11 86       	std	Z+9, r1	; 0x09
    355e:	10 86       	std	Z+8, r1	; 0x08
    3560:	08 95       	ret

00003562 <vListInsertEnd>:
    listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    3562:	cf 93       	push	r28
    3564:	df 93       	push	r29
    3566:	9c 01       	movw	r18, r24
    3568:	fb 01       	movw	r30, r22
ListItem_t * const pxIndex = pxList->pxIndex;
    356a:	dc 01       	movw	r26, r24
    356c:	11 96       	adiw	r26, 0x01	; 1
    356e:	cd 91       	ld	r28, X+
    3570:	dc 91       	ld	r29, X
    3572:	12 97       	sbiw	r26, 0x02	; 2
    listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

    /* Insert a new list item into pxList, but rather than sort the list,
    makes the new list item the last item to be removed by a call to
    listGET_OWNER_OF_NEXT_ENTRY(). */
    pxNewListItem->pxNext = pxIndex;
    3574:	d3 83       	std	Z+3, r29	; 0x03
    3576:	c2 83       	std	Z+2, r28	; 0x02
    pxNewListItem->pxPrevious = pxIndex->pxPrevious;
    3578:	8c 81       	ldd	r24, Y+4	; 0x04
    357a:	9d 81       	ldd	r25, Y+5	; 0x05
    357c:	95 83       	std	Z+5, r25	; 0x05
    357e:	84 83       	std	Z+4, r24	; 0x04

    /* Only used during decision coverage testing. */
    mtCOVERAGE_TEST_DELAY();

    pxIndex->pxPrevious->pxNext = pxNewListItem;
    3580:	8c 81       	ldd	r24, Y+4	; 0x04
    3582:	9d 81       	ldd	r25, Y+5	; 0x05
    3584:	dc 01       	movw	r26, r24
    3586:	13 96       	adiw	r26, 0x03	; 3
    3588:	7c 93       	st	X, r23
    358a:	6e 93       	st	-X, r22
    358c:	12 97       	sbiw	r26, 0x02	; 2
    pxIndex->pxPrevious = pxNewListItem;
    358e:	7d 83       	std	Y+5, r23	; 0x05
    3590:	6c 83       	std	Y+4, r22	; 0x04

    /* Remember which list the item is in. */
    pxNewListItem->pxContainer = pxList;
    3592:	31 87       	std	Z+9, r19	; 0x09
    3594:	20 87       	std	Z+8, r18	; 0x08

    ( pxList->uxNumberOfItems )++;
    3596:	f9 01       	movw	r30, r18
    3598:	80 81       	ld	r24, Z
    359a:	8f 5f       	subi	r24, 0xFF	; 255
    359c:	80 83       	st	Z, r24
}
    359e:	df 91       	pop	r29
    35a0:	cf 91       	pop	r28
    35a2:	08 95       	ret

000035a4 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    35a4:	0f 93       	push	r16
    35a6:	1f 93       	push	r17
    35a8:	cf 93       	push	r28
    35aa:	df 93       	push	r29
    35ac:	8c 01       	movw	r16, r24
    35ae:	fb 01       	movw	r30, r22
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
    35b0:	80 81       	ld	r24, Z
    35b2:	91 81       	ldd	r25, Z+1	; 0x01
    new list item should be placed after it.  This ensures that TCBs which are
    stored in ready lists (all of which have the same xItemValue value) get a
    share of the CPU.  However, if the xItemValue is the same as the back marker
    the iteration loop below will not end.  Therefore the value is checked
    first, and the algorithm slightly modified if necessary. */
    if( xValueOfInsertion == portMAX_DELAY )
    35b4:	8f 3f       	cpi	r24, 0xFF	; 255
    35b6:	2f ef       	ldi	r18, 0xFF	; 255
    35b8:	92 07       	cpc	r25, r18
    35ba:	21 f4       	brne	.+8      	; 0x35c4 <vListInsert+0x20>
    {
        pxIterator = pxList->xListEnd.pxPrevious;
    35bc:	e8 01       	movw	r28, r16
    35be:	af 81       	ldd	r26, Y+7	; 0x07
    35c0:	b8 85       	ldd	r27, Y+8	; 0x08
    35c2:	0e c0       	rjmp	.+28     	; 0x35e0 <vListInsert+0x3c>
            4) Using a queue or semaphore before it has been initialised or
               before the scheduler has been started (are interrupts firing
               before vTaskStartScheduler() has been called?).
        **********************************************************************/

        for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. *//*lint !e440 The iterator moves to a different value, not xValueOfInsertion. */
    35c4:	d8 01       	movw	r26, r16
    35c6:	13 96       	adiw	r26, 0x03	; 3
    35c8:	12 96       	adiw	r26, 0x02	; 2
    35ca:	2d 91       	ld	r18, X+
    35cc:	3c 91       	ld	r19, X
    35ce:	13 97       	sbiw	r26, 0x03	; 3
    35d0:	e9 01       	movw	r28, r18
    35d2:	48 81       	ld	r20, Y
    35d4:	59 81       	ldd	r21, Y+1	; 0x01
    35d6:	84 17       	cp	r24, r20
    35d8:	95 07       	cpc	r25, r21
    35da:	10 f0       	brcs	.+4      	; 0x35e0 <vListInsert+0x3c>
    35dc:	d9 01       	movw	r26, r18
    35de:	f4 cf       	rjmp	.-24     	; 0x35c8 <vListInsert+0x24>
            /* There is nothing to do here, just iterating to the wanted
            insertion position. */
        }
    }

    pxNewListItem->pxNext = pxIterator->pxNext;
    35e0:	12 96       	adiw	r26, 0x02	; 2
    35e2:	8d 91       	ld	r24, X+
    35e4:	9c 91       	ld	r25, X
    35e6:	13 97       	sbiw	r26, 0x03	; 3
    35e8:	93 83       	std	Z+3, r25	; 0x03
    35ea:	82 83       	std	Z+2, r24	; 0x02
    pxNewListItem->pxNext->pxPrevious = pxNewListItem;
    35ec:	ec 01       	movw	r28, r24
    35ee:	fd 83       	std	Y+5, r31	; 0x05
    35f0:	ec 83       	std	Y+4, r30	; 0x04
    pxNewListItem->pxPrevious = pxIterator;
    35f2:	b5 83       	std	Z+5, r27	; 0x05
    35f4:	a4 83       	std	Z+4, r26	; 0x04
    pxIterator->pxNext = pxNewListItem;
    35f6:	13 96       	adiw	r26, 0x03	; 3
    35f8:	fc 93       	st	X, r31
    35fa:	ee 93       	st	-X, r30
    35fc:	12 97       	sbiw	r26, 0x02	; 2

    /* Remember which list the item is in.  This allows fast removal of the
    item later. */
    pxNewListItem->pxContainer = pxList;
    35fe:	11 87       	std	Z+9, r17	; 0x09
    3600:	00 87       	std	Z+8, r16	; 0x08

    ( pxList->uxNumberOfItems )++;
    3602:	f8 01       	movw	r30, r16
    3604:	80 81       	ld	r24, Z
    3606:	8f 5f       	subi	r24, 0xFF	; 255
    3608:	80 83       	st	Z, r24
}
    360a:	df 91       	pop	r29
    360c:	cf 91       	pop	r28
    360e:	1f 91       	pop	r17
    3610:	0f 91       	pop	r16
    3612:	08 95       	ret

00003614 <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
    3614:	cf 93       	push	r28
    3616:	df 93       	push	r29
    3618:	fc 01       	movw	r30, r24
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = pxItemToRemove->pxContainer;
    361a:	a0 85       	ldd	r26, Z+8	; 0x08
    361c:	b1 85       	ldd	r27, Z+9	; 0x09

    pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    361e:	82 81       	ldd	r24, Z+2	; 0x02
    3620:	93 81       	ldd	r25, Z+3	; 0x03
    3622:	24 81       	ldd	r18, Z+4	; 0x04
    3624:	35 81       	ldd	r19, Z+5	; 0x05
    3626:	ec 01       	movw	r28, r24
    3628:	3d 83       	std	Y+5, r19	; 0x05
    362a:	2c 83       	std	Y+4, r18	; 0x04
    pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    362c:	c4 81       	ldd	r28, Z+4	; 0x04
    362e:	d5 81       	ldd	r29, Z+5	; 0x05
    3630:	9b 83       	std	Y+3, r25	; 0x03
    3632:	8a 83       	std	Y+2, r24	; 0x02

    /* Only used during decision coverage testing. */
    mtCOVERAGE_TEST_DELAY();

    /* Make sure the index is left pointing to a valid item. */
    if( pxList->pxIndex == pxItemToRemove )
    3634:	11 96       	adiw	r26, 0x01	; 1
    3636:	8d 91       	ld	r24, X+
    3638:	9c 91       	ld	r25, X
    363a:	12 97       	sbiw	r26, 0x02	; 2
    363c:	e8 17       	cp	r30, r24
    363e:	f9 07       	cpc	r31, r25
    3640:	21 f4       	brne	.+8      	; 0x364a <uxListRemove+0x36>
    {
        pxList->pxIndex = pxItemToRemove->pxPrevious;
    3642:	12 96       	adiw	r26, 0x02	; 2
    3644:	dc 93       	st	X, r29
    3646:	ce 93       	st	-X, r28
    3648:	11 97       	sbiw	r26, 0x01	; 1
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }

    pxItemToRemove->pxContainer = NULL;
    364a:	11 86       	std	Z+9, r1	; 0x09
    364c:	10 86       	std	Z+8, r1	; 0x08
    ( pxList->uxNumberOfItems )--;
    364e:	8c 91       	ld	r24, X
    3650:	81 50       	subi	r24, 0x01	; 1
    3652:	8c 93       	st	X, r24

    return pxList->uxNumberOfItems;
    3654:	8c 91       	ld	r24, X
}
    3656:	df 91       	pop	r29
    3658:	cf 91       	pop	r28
    365a:	08 95       	ret

0000365c <pxPortInitialiseStack>:
		);
	}
	else
	{
        uint8_t register temp_reg;
		__asm__ __volatile__ (
    365c:	31 e1       	ldi	r19, 0x11	; 17
    365e:	fc 01       	movw	r30, r24
    3660:	30 83       	st	Z, r19
    3662:	31 97       	sbiw	r30, 0x01	; 1
    3664:	22 e2       	ldi	r18, 0x22	; 34
    3666:	20 83       	st	Z, r18
    3668:	31 97       	sbiw	r30, 0x01	; 1
    366a:	a3 e3       	ldi	r26, 0x33	; 51
    366c:	a0 83       	st	Z, r26
    366e:	31 97       	sbiw	r30, 0x01	; 1
    3670:	60 83       	st	Z, r22
    3672:	31 97       	sbiw	r30, 0x01	; 1
    3674:	70 83       	st	Z, r23
    3676:	31 97       	sbiw	r30, 0x01	; 1
    3678:	10 82       	st	Z, r1
    367a:	31 97       	sbiw	r30, 0x01	; 1
    367c:	60 e8       	ldi	r22, 0x80	; 128
    367e:	60 83       	st	Z, r22
    3680:	31 97       	sbiw	r30, 0x01	; 1
    3682:	10 82       	st	Z, r1
    3684:	31 97       	sbiw	r30, 0x01	; 1
    3686:	62 e0       	ldi	r22, 0x02	; 2
    3688:	60 83       	st	Z, r22
    368a:	31 97       	sbiw	r30, 0x01	; 1
    368c:	63 e0       	ldi	r22, 0x03	; 3
    368e:	60 83       	st	Z, r22
    3690:	31 97       	sbiw	r30, 0x01	; 1
    3692:	64 e0       	ldi	r22, 0x04	; 4
    3694:	60 83       	st	Z, r22
    3696:	31 97       	sbiw	r30, 0x01	; 1
    3698:	65 e0       	ldi	r22, 0x05	; 5
    369a:	60 83       	st	Z, r22
    369c:	31 97       	sbiw	r30, 0x01	; 1
    369e:	66 e0       	ldi	r22, 0x06	; 6
    36a0:	60 83       	st	Z, r22
    36a2:	31 97       	sbiw	r30, 0x01	; 1
    36a4:	67 e0       	ldi	r22, 0x07	; 7
    36a6:	60 83       	st	Z, r22
    36a8:	31 97       	sbiw	r30, 0x01	; 1
    36aa:	68 e0       	ldi	r22, 0x08	; 8
    36ac:	60 83       	st	Z, r22
    36ae:	31 97       	sbiw	r30, 0x01	; 1
    36b0:	69 e0       	ldi	r22, 0x09	; 9
    36b2:	60 83       	st	Z, r22
    36b4:	31 97       	sbiw	r30, 0x01	; 1
    36b6:	60 e1       	ldi	r22, 0x10	; 16
    36b8:	60 83       	st	Z, r22
    36ba:	31 97       	sbiw	r30, 0x01	; 1
    36bc:	30 83       	st	Z, r19
    36be:	31 97       	sbiw	r30, 0x01	; 1
    36c0:	32 e1       	ldi	r19, 0x12	; 18
    36c2:	30 83       	st	Z, r19
    36c4:	31 97       	sbiw	r30, 0x01	; 1
    36c6:	33 e1       	ldi	r19, 0x13	; 19
    36c8:	30 83       	st	Z, r19
    36ca:	31 97       	sbiw	r30, 0x01	; 1
    36cc:	34 e1       	ldi	r19, 0x14	; 20
    36ce:	30 83       	st	Z, r19
    36d0:	31 97       	sbiw	r30, 0x01	; 1
    36d2:	35 e1       	ldi	r19, 0x15	; 21
    36d4:	30 83       	st	Z, r19
    36d6:	31 97       	sbiw	r30, 0x01	; 1
    36d8:	36 e1       	ldi	r19, 0x16	; 22
    36da:	30 83       	st	Z, r19
    36dc:	31 97       	sbiw	r30, 0x01	; 1
    36de:	37 e1       	ldi	r19, 0x17	; 23
    36e0:	30 83       	st	Z, r19
    36e2:	31 97       	sbiw	r30, 0x01	; 1
    36e4:	38 e1       	ldi	r19, 0x18	; 24
    36e6:	30 83       	st	Z, r19
    36e8:	31 97       	sbiw	r30, 0x01	; 1
    36ea:	39 e1       	ldi	r19, 0x19	; 25
    36ec:	30 83       	st	Z, r19
    36ee:	31 97       	sbiw	r30, 0x01	; 1
    36f0:	30 e2       	ldi	r19, 0x20	; 32
    36f2:	30 83       	st	Z, r19
    36f4:	31 97       	sbiw	r30, 0x01	; 1
    36f6:	31 e2       	ldi	r19, 0x21	; 33
    36f8:	30 83       	st	Z, r19
    36fa:	31 97       	sbiw	r30, 0x01	; 1
    36fc:	20 83       	st	Z, r18
    36fe:	31 97       	sbiw	r30, 0x01	; 1
    3700:	23 e2       	ldi	r18, 0x23	; 35
    3702:	20 83       	st	Z, r18
    3704:	31 97       	sbiw	r30, 0x01	; 1
    3706:	40 83       	st	Z, r20
    3708:	31 97       	sbiw	r30, 0x01	; 1
    370a:	50 83       	st	Z, r21
    370c:	31 97       	sbiw	r30, 0x01	; 1
    370e:	26 e2       	ldi	r18, 0x26	; 38
    3710:	20 83       	st	Z, r18
    3712:	31 97       	sbiw	r30, 0x01	; 1
    3714:	27 e2       	ldi	r18, 0x27	; 39
    3716:	20 83       	st	Z, r18
    3718:	31 97       	sbiw	r30, 0x01	; 1
    371a:	28 e2       	ldi	r18, 0x28	; 40
    371c:	20 83       	st	Z, r18
    371e:	31 97       	sbiw	r30, 0x01	; 1
    3720:	29 e2       	ldi	r18, 0x29	; 41
    3722:	20 83       	st	Z, r18
    3724:	31 97       	sbiw	r30, 0x01	; 1
    3726:	20 e3       	ldi	r18, 0x30	; 48
    3728:	20 83       	st	Z, r18
    372a:	31 97       	sbiw	r30, 0x01	; 1
    372c:	21 e3       	ldi	r18, 0x31	; 49
    372e:	20 83       	st	Z, r18
    3730:	86 97       	sbiw	r24, 0x26	; 38
    3732:	08 95       	ret

00003734 <xPortStartScheduler>:
    3734:	a8 95       	wdr
    3736:	90 ec       	ldi	r25, 0xC0	; 192
    3738:	88 e1       	ldi	r24, 0x18	; 24
    373a:	0f b6       	in	r0, 0x3f	; 63
    373c:	f8 94       	cli
    373e:	a8 95       	wdr
    3740:	80 93 60 00 	sts	0x0060, r24	; 0x800060 <__DATA_REGION_ORIGIN__>
    3744:	0f be       	out	0x3f, r0	; 63
    3746:	90 93 60 00 	sts	0x0060, r25	; 0x800060 <__DATA_REGION_ORIGIN__>
    374a:	a0 91 b7 03 	lds	r26, 0x03B7	; 0x8003b7 <pxCurrentTCB>
    374e:	b0 91 b8 03 	lds	r27, 0x03B8	; 0x8003b8 <pxCurrentTCB+0x1>
    3752:	cd 91       	ld	r28, X+
    3754:	cd bf       	out	0x3d, r28	; 61
    3756:	dd 91       	ld	r29, X+
    3758:	de bf       	out	0x3e, r29	; 62
    375a:	ff 91       	pop	r31
    375c:	ef 91       	pop	r30
    375e:	df 91       	pop	r29
    3760:	cf 91       	pop	r28
    3762:	bf 91       	pop	r27
    3764:	af 91       	pop	r26
    3766:	9f 91       	pop	r25
    3768:	8f 91       	pop	r24
    376a:	7f 91       	pop	r23
    376c:	6f 91       	pop	r22
    376e:	5f 91       	pop	r21
    3770:	4f 91       	pop	r20
    3772:	3f 91       	pop	r19
    3774:	2f 91       	pop	r18
    3776:	1f 91       	pop	r17
    3778:	0f 91       	pop	r16
    377a:	ff 90       	pop	r15
    377c:	ef 90       	pop	r14
    377e:	df 90       	pop	r13
    3780:	cf 90       	pop	r12
    3782:	bf 90       	pop	r11
    3784:	af 90       	pop	r10
    3786:	9f 90       	pop	r9
    3788:	8f 90       	pop	r8
    378a:	7f 90       	pop	r7
    378c:	6f 90       	pop	r6
    378e:	5f 90       	pop	r5
    3790:	4f 90       	pop	r4
    3792:	3f 90       	pop	r3
    3794:	2f 90       	pop	r2
    3796:	1f 90       	pop	r1
    3798:	0f 90       	pop	r0
    379a:	0f be       	out	0x3f, r0	; 63
    379c:	0f 90       	pop	r0
    379e:	08 95       	ret
    37a0:	81 e0       	ldi	r24, 0x01	; 1
    37a2:	08 95       	ret

000037a4 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( hot, flatten, naked ) );
void vPortYield( void )
{
    portSAVE_CONTEXT();
    37a4:	0f 92       	push	r0
    37a6:	0f b6       	in	r0, 0x3f	; 63
    37a8:	f8 94       	cli
    37aa:	0f 92       	push	r0
    37ac:	1f 92       	push	r1
    37ae:	11 24       	eor	r1, r1
    37b0:	2f 92       	push	r2
    37b2:	3f 92       	push	r3
    37b4:	4f 92       	push	r4
    37b6:	5f 92       	push	r5
    37b8:	6f 92       	push	r6
    37ba:	7f 92       	push	r7
    37bc:	8f 92       	push	r8
    37be:	9f 92       	push	r9
    37c0:	af 92       	push	r10
    37c2:	bf 92       	push	r11
    37c4:	cf 92       	push	r12
    37c6:	df 92       	push	r13
    37c8:	ef 92       	push	r14
    37ca:	ff 92       	push	r15
    37cc:	0f 93       	push	r16
    37ce:	1f 93       	push	r17
    37d0:	2f 93       	push	r18
    37d2:	3f 93       	push	r19
    37d4:	4f 93       	push	r20
    37d6:	5f 93       	push	r21
    37d8:	6f 93       	push	r22
    37da:	7f 93       	push	r23
    37dc:	8f 93       	push	r24
    37de:	9f 93       	push	r25
    37e0:	af 93       	push	r26
    37e2:	bf 93       	push	r27
    37e4:	cf 93       	push	r28
    37e6:	df 93       	push	r29
    37e8:	ef 93       	push	r30
    37ea:	ff 93       	push	r31
    37ec:	a0 91 b7 03 	lds	r26, 0x03B7	; 0x8003b7 <pxCurrentTCB>
    37f0:	b0 91 b8 03 	lds	r27, 0x03B8	; 0x8003b8 <pxCurrentTCB+0x1>
    37f4:	0d b6       	in	r0, 0x3d	; 61
    37f6:	0d 92       	st	X+, r0
    37f8:	0e b6       	in	r0, 0x3e	; 62
    37fa:	0d 92       	st	X+, r0
    vTaskSwitchContext();
    37fc:	0e 94 6f 14 	call	0x28de	; 0x28de <vTaskSwitchContext>
    portRESTORE_CONTEXT();
    3800:	a0 91 b7 03 	lds	r26, 0x03B7	; 0x8003b7 <pxCurrentTCB>
    3804:	b0 91 b8 03 	lds	r27, 0x03B8	; 0x8003b8 <pxCurrentTCB+0x1>
    3808:	cd 91       	ld	r28, X+
    380a:	cd bf       	out	0x3d, r28	; 61
    380c:	dd 91       	ld	r29, X+
    380e:	de bf       	out	0x3e, r29	; 62
    3810:	ff 91       	pop	r31
    3812:	ef 91       	pop	r30
    3814:	df 91       	pop	r29
    3816:	cf 91       	pop	r28
    3818:	bf 91       	pop	r27
    381a:	af 91       	pop	r26
    381c:	9f 91       	pop	r25
    381e:	8f 91       	pop	r24
    3820:	7f 91       	pop	r23
    3822:	6f 91       	pop	r22
    3824:	5f 91       	pop	r21
    3826:	4f 91       	pop	r20
    3828:	3f 91       	pop	r19
    382a:	2f 91       	pop	r18
    382c:	1f 91       	pop	r17
    382e:	0f 91       	pop	r16
    3830:	ff 90       	pop	r15
    3832:	ef 90       	pop	r14
    3834:	df 90       	pop	r13
    3836:	cf 90       	pop	r12
    3838:	bf 90       	pop	r11
    383a:	af 90       	pop	r10
    383c:	9f 90       	pop	r9
    383e:	8f 90       	pop	r8
    3840:	7f 90       	pop	r7
    3842:	6f 90       	pop	r6
    3844:	5f 90       	pop	r5
    3846:	4f 90       	pop	r4
    3848:	3f 90       	pop	r3
    384a:	2f 90       	pop	r2
    384c:	1f 90       	pop	r1
    384e:	0f 90       	pop	r0
    3850:	0f be       	out	0x3f, r0	; 63
    3852:	0f 90       	pop	r0

    __asm__ __volatile__ ( "ret" );
    3854:	08 95       	ret

00003856 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( hot, flatten, naked ) );
void vPortYieldFromTick( void )
{
    portSAVE_CONTEXT();
    3856:	0f 92       	push	r0
    3858:	0f b6       	in	r0, 0x3f	; 63
    385a:	f8 94       	cli
    385c:	0f 92       	push	r0
    385e:	1f 92       	push	r1
    3860:	11 24       	eor	r1, r1
    3862:	2f 92       	push	r2
    3864:	3f 92       	push	r3
    3866:	4f 92       	push	r4
    3868:	5f 92       	push	r5
    386a:	6f 92       	push	r6
    386c:	7f 92       	push	r7
    386e:	8f 92       	push	r8
    3870:	9f 92       	push	r9
    3872:	af 92       	push	r10
    3874:	bf 92       	push	r11
    3876:	cf 92       	push	r12
    3878:	df 92       	push	r13
    387a:	ef 92       	push	r14
    387c:	ff 92       	push	r15
    387e:	0f 93       	push	r16
    3880:	1f 93       	push	r17
    3882:	2f 93       	push	r18
    3884:	3f 93       	push	r19
    3886:	4f 93       	push	r20
    3888:	5f 93       	push	r21
    388a:	6f 93       	push	r22
    388c:	7f 93       	push	r23
    388e:	8f 93       	push	r24
    3890:	9f 93       	push	r25
    3892:	af 93       	push	r26
    3894:	bf 93       	push	r27
    3896:	cf 93       	push	r28
    3898:	df 93       	push	r29
    389a:	ef 93       	push	r30
    389c:	ff 93       	push	r31
    389e:	a0 91 b7 03 	lds	r26, 0x03B7	; 0x8003b7 <pxCurrentTCB>
    38a2:	b0 91 b8 03 	lds	r27, 0x03B8	; 0x8003b8 <pxCurrentTCB+0x1>
    38a6:	0d b6       	in	r0, 0x3d	; 61
    38a8:	0d 92       	st	X+, r0
    38aa:	0e b6       	in	r0, 0x3e	; 62
    38ac:	0d 92       	st	X+, r0

    sleep_reset();        //     reset the sleep_mode() faster than sleep_disable();
    38ae:	13 be       	out	0x33, r1	; 51

    if( xTaskIncrementTick() != pdFALSE )
    38b0:	0e 94 07 13 	call	0x260e	; 0x260e <xTaskIncrementTick>
    38b4:	81 11       	cpse	r24, r1
    {
        vTaskSwitchContext();
    38b6:	0e 94 6f 14 	call	0x28de	; 0x28de <vTaskSwitchContext>
    }

    portRESTORE_CONTEXT();
    38ba:	a0 91 b7 03 	lds	r26, 0x03B7	; 0x8003b7 <pxCurrentTCB>
    38be:	b0 91 b8 03 	lds	r27, 0x03B8	; 0x8003b8 <pxCurrentTCB+0x1>
    38c2:	cd 91       	ld	r28, X+
    38c4:	cd bf       	out	0x3d, r28	; 61
    38c6:	dd 91       	ld	r29, X+
    38c8:	de bf       	out	0x3e, r29	; 62
    38ca:	ff 91       	pop	r31
    38cc:	ef 91       	pop	r30
    38ce:	df 91       	pop	r29
    38d0:	cf 91       	pop	r28
    38d2:	bf 91       	pop	r27
    38d4:	af 91       	pop	r26
    38d6:	9f 91       	pop	r25
    38d8:	8f 91       	pop	r24
    38da:	7f 91       	pop	r23
    38dc:	6f 91       	pop	r22
    38de:	5f 91       	pop	r21
    38e0:	4f 91       	pop	r20
    38e2:	3f 91       	pop	r19
    38e4:	2f 91       	pop	r18
    38e6:	1f 91       	pop	r17
    38e8:	0f 91       	pop	r16
    38ea:	ff 90       	pop	r15
    38ec:	ef 90       	pop	r14
    38ee:	df 90       	pop	r13
    38f0:	cf 90       	pop	r12
    38f2:	bf 90       	pop	r11
    38f4:	af 90       	pop	r10
    38f6:	9f 90       	pop	r9
    38f8:	8f 90       	pop	r8
    38fa:	7f 90       	pop	r7
    38fc:	6f 90       	pop	r6
    38fe:	5f 90       	pop	r5
    3900:	4f 90       	pop	r4
    3902:	3f 90       	pop	r3
    3904:	2f 90       	pop	r2
    3906:	1f 90       	pop	r1
    3908:	0f 90       	pop	r0
    390a:	0f be       	out	0x3f, r0	; 63
    390c:	0f 90       	pop	r0

    __asm__ __volatile__ ( "ret" );
    390e:	08 95       	ret

00003910 <__vector_6>:
     */
    ISR(portSCHEDULER_ISR, ISR_NAKED) __attribute__ ((hot, flatten));
//  ISR(portSCHEDULER_ISR, ISR_NAKED ISR_NOBLOCK) __attribute__ ((hot, flatten));
    ISR(portSCHEDULER_ISR)
    {
        vPortYieldFromTick();
    3910:	0e 94 2b 1c 	call	0x3856	; 0x3856 <vPortYieldFromTick>
        __asm__ __volatile__ ( "reti" );
    3914:	18 95       	reti

00003916 <_ZN14FreqCountClass5beginEj>:
static uint16_t gate_index;


void FreqCountClass::begin(uint16_t msec)
{
	if (msec < 1) return;
    3916:	00 97       	sbiw	r24, 0x00	; 0
    3918:	09 f4       	brne	.+2      	; 0x391c <_ZN14FreqCountClass5beginEj+0x6>
    391a:	74 c0       	rjmp	.+232    	; 0x3a04 <L_130_loop+0xc>
	gate_index = 0;
    391c:	10 92 d7 03 	sts	0x03D7, r1	; 0x8003d7 <_ZL10gate_index+0x1>
    3920:	10 92 d6 03 	sts	0x03D6, r1	; 0x8003d6 <_ZL10gate_index>
	count_msw = 0;
    3924:	10 92 e4 03 	sts	0x03E4, r1	; 0x8003e4 <_ZL9count_msw+0x1>
    3928:	10 92 e3 03 	sts	0x03E3, r1	; 0x8003e3 <_ZL9count_msw>
	count_prev = 0;
    392c:	10 92 df 03 	sts	0x03DF, r1	; 0x8003df <_ZL10count_prev>
    3930:	10 92 e0 03 	sts	0x03E0, r1	; 0x8003e0 <_ZL10count_prev+0x1>
    3934:	10 92 e1 03 	sts	0x03E1, r1	; 0x8003e1 <_ZL10count_prev+0x2>
    3938:	10 92 e2 03 	sts	0x03E2, r1	; 0x8003e2 <_ZL10count_prev+0x3>
	count_ready = 0;
    393c:	10 92 da 03 	sts	0x03DA, r1	; 0x8003da <_ZL11count_ready>

static uint8_t saveTCCR1A, saveTCCR1B;

static inline void counter_init(void)
{
	saveTCCR1A = TCCR1A;
    3940:	20 91 80 00 	lds	r18, 0x0080	; 0x800080 <__DATA_REGION_ORIGIN__+0x20>
    3944:	20 93 e9 03 	sts	0x03E9, r18	; 0x8003e9 <_ZL10saveTCCR1A>
	saveTCCR1B = TCCR1B;
    3948:	20 91 81 00 	lds	r18, 0x0081	; 0x800081 <__DATA_REGION_ORIGIN__+0x21>
    394c:	20 93 e8 03 	sts	0x03E8, r18	; 0x8003e8 <_ZL10saveTCCR1B>
	TCCR1B = 0;
    3950:	10 92 81 00 	sts	0x0081, r1	; 0x800081 <__DATA_REGION_ORIGIN__+0x21>
	TCCR1A = 0;
    3954:	10 92 80 00 	sts	0x0080, r1	; 0x800080 <__DATA_REGION_ORIGIN__+0x20>
	TCNT1 = 0;
    3958:	10 92 85 00 	sts	0x0085, r1	; 0x800085 <__DATA_REGION_ORIGIN__+0x25>
    395c:	10 92 84 00 	sts	0x0084, r1	; 0x800084 <__DATA_REGION_ORIGIN__+0x24>
	TIFR1 = (1<<TOV1);
    3960:	21 e0       	ldi	r18, 0x01	; 1
    3962:	26 bb       	out	0x16, r18	; 22
	TIMSK1 = 0;
    3964:	10 92 6f 00 	sts	0x006F, r1	; 0x80006f <__DATA_REGION_ORIGIN__+0xf>

static inline uint16_t timer_init(uint16_t msec)
{
	uint16_t gate_len;

	saveTCCR2A = TCCR2A;
    3968:	20 91 b0 00 	lds	r18, 0x00B0	; 0x8000b0 <__DATA_REGION_ORIGIN__+0x50>
    396c:	20 93 e7 03 	sts	0x03E7, r18	; 0x8003e7 <_ZL10saveTCCR2A>
	saveTCCR2B = TCCR2B;
    3970:	20 91 b1 00 	lds	r18, 0x00B1	; 0x8000b1 <__DATA_REGION_ORIGIN__+0x51>
    3974:	20 93 e6 03 	sts	0x03E6, r18	; 0x8003e6 <_ZL10saveTCCR2B>
	TCCR2B = 0;
    3978:	10 92 b1 00 	sts	0x00B1, r1	; 0x8000b1 <__DATA_REGION_ORIGIN__+0x51>
	TCCR2A = (1<<WGM21);
    397c:	22 e0       	ldi	r18, 0x02	; 2
    397e:	20 93 b0 00 	sts	0x00B0, r18	; 0x8000b0 <__DATA_REGION_ORIGIN__+0x50>
	if ((msec & 7) == 0) {
    3982:	9c 01       	movw	r18, r24
    3984:	27 70       	andi	r18, 0x07	; 7
    3986:	33 27       	eor	r19, r19
    3988:	23 2b       	or	r18, r19
    398a:	51 f4       	brne	.+20     	; 0x39a0 <_ZN14FreqCountClass5beginEj+0x8a>
		gate_len = msec >> 3;
    398c:	43 e0       	ldi	r20, 0x03	; 3
    398e:	96 95       	lsr	r25
    3990:	87 95       	ror	r24
    3992:	4a 95       	dec	r20
    3994:	e1 f7       	brne	.-8      	; 0x398e <_ZN14FreqCountClass5beginEj+0x78>
		OCR2A = TIMER2_OCR2A_8MS_VAL;
    3996:	2c e7       	ldi	r18, 0x7C	; 124
    3998:	20 93 b3 00 	sts	0x00B3, r18	; 0x8000b3 <__DATA_REGION_ORIGIN__+0x53>
		startTCCR2B = TIMER2_TCCR2B_8MS_VAL;
    399c:	27 e0       	ldi	r18, 0x07	; 7
    399e:	18 c0       	rjmp	.+48     	; 0x39d0 <_ZN14FreqCountClass5beginEj+0xba>
	} else if ((msec & 3) == 0) {
    39a0:	9c 01       	movw	r18, r24
    39a2:	23 70       	andi	r18, 0x03	; 3
    39a4:	33 27       	eor	r19, r19
    39a6:	23 2b       	or	r18, r19
    39a8:	31 f4       	brne	.+12     	; 0x39b6 <_ZN14FreqCountClass5beginEj+0xa0>
		gate_len = msec >> 2;
    39aa:	96 95       	lsr	r25
    39ac:	87 95       	ror	r24
    39ae:	96 95       	lsr	r25
    39b0:	87 95       	ror	r24
		OCR2A = TIMER2_OCR2A_4MS_VAL;
    39b2:	29 ef       	ldi	r18, 0xF9	; 249
    39b4:	05 c0       	rjmp	.+10     	; 0x39c0 <_ZN14FreqCountClass5beginEj+0xaa>
		startTCCR2B = TIMER2_TCCR2B_4MS_VAL;
	} else if ((msec & 1) == 0) {
    39b6:	80 fd       	sbrc	r24, 0
    39b8:	07 c0       	rjmp	.+14     	; 0x39c8 <_ZN14FreqCountClass5beginEj+0xb2>
		gate_len = msec >> 1;
    39ba:	96 95       	lsr	r25
    39bc:	87 95       	ror	r24
		OCR2A = TIMER2_OCR2A_2MS_VAL;
    39be:	2c e7       	ldi	r18, 0x7C	; 124
    39c0:	20 93 b3 00 	sts	0x00B3, r18	; 0x8000b3 <__DATA_REGION_ORIGIN__+0x53>
		startTCCR2B = TIMER2_TCCR2B_2MS_VAL;
    39c4:	26 e0       	ldi	r18, 0x06	; 6
    39c6:	04 c0       	rjmp	.+8      	; 0x39d0 <_ZN14FreqCountClass5beginEj+0xba>
	} else {
		gate_len = msec;
		OCR2A = TIMER2_OCR2A_1MS_VAL;
    39c8:	2c e7       	ldi	r18, 0x7C	; 124
    39ca:	20 93 b3 00 	sts	0x00B3, r18	; 0x8000b3 <__DATA_REGION_ORIGIN__+0x53>
		startTCCR2B = TIMER2_TCCR2B_1MS_VAL;
    39ce:	25 e0       	ldi	r18, 0x05	; 5
    39d0:	20 93 e5 03 	sts	0x03E5, r18	; 0x8003e5 <_ZL11startTCCR2B>
	}
	TIFR2 = (1<<OCF2A);
    39d4:	22 e0       	ldi	r18, 0x02	; 2
    39d6:	27 bb       	out	0x17, r18	; 23
	TCNT2 = 0;
    39d8:	10 92 b2 00 	sts	0x00B2, r1	; 0x8000b2 <__DATA_REGION_ORIGIN__+0x52>
	counter_init();
	gate_length = timer_init(msec);
    39dc:	90 93 d9 03 	sts	0x03D9, r25	; 0x8003d9 <_ZL11gate_length+0x1>
    39e0:	80 93 d8 03 	sts	0x03D8, r24	; 0x8003d8 <_ZL11gate_length>
	uint8_t status = SREG;
    39e4:	9f b7       	in	r25, 0x3f	; 63
	cli();
    39e6:	f8 94       	cli
	return gate_len;
}

static inline void timer_start(void)
{
	GTCCR = (1<<PSRASY);
    39e8:	23 bd       	out	0x23, r18	; 35
	TCCR2B = startTCCR2B;
    39ea:	80 91 e5 03 	lds	r24, 0x03E5	; 0x8003e5 <_ZL11startTCCR2B>
    39ee:	80 93 b1 00 	sts	0x00B1, r24	; 0x8000b1 <__DATA_REGION_ORIGIN__+0x51>
	TIMSK2 = (1<<OCIE2A);
    39f2:	20 93 70 00 	sts	0x0070, r18	; 0x800070 <__DATA_REGION_ORIGIN__+0x10>
		"L_%=_loop:"
		"subi   %0, 1"		"\n\t"
		"brne   L_%=_loop"	"\n\t"
		: "+d" (cycles_times_3)
		: "0" (cycles_times_3)
	);
    39f6:	8b e0       	ldi	r24, 0x0B	; 11

000039f8 <L_130_loop>:
    39f8:	81 50       	subi	r24, 0x01	; 1
    39fa:	f1 f7       	brne	.-4      	; 0x39f8 <L_130_loop>
	TIMSK1 = 0;
}

static inline void counter_start(void)
{
	TCCR1B = (1<<CS12) | (1<<CS11) | (1<<CS10);
    39fc:	87 e0       	ldi	r24, 0x07	; 7
    39fe:	80 93 81 00 	sts	0x0081, r24	; 0x800081 <__DATA_REGION_ORIGIN__+0x21>
	timer_start();
	timer_isr_latency_delay();
	counter_start();
	SREG = status;
    3a02:	9f bf       	out	0x3f, r25	; 63
    3a04:	08 95       	ret

00003a06 <_ZN14FreqCountClass9availableEv>:
}

uint8_t FreqCountClass::available(void)
{
	return count_ready;
    3a06:	80 91 da 03 	lds	r24, 0x03DA	; 0x8003da <_ZL11count_ready>
}
    3a0a:	08 95       	ret

00003a0c <_ZN14FreqCountClass4readEv>:
uint32_t FreqCountClass::read(void)
{
	uint32_t count;
	uint8_t status;

	status = SREG;
    3a0c:	2f b7       	in	r18, 0x3f	; 63
	cli();
    3a0e:	f8 94       	cli
	count = count_output;
    3a10:	60 91 db 03 	lds	r22, 0x03DB	; 0x8003db <_ZL12count_output>
    3a14:	70 91 dc 03 	lds	r23, 0x03DC	; 0x8003dc <_ZL12count_output+0x1>
    3a18:	80 91 dd 03 	lds	r24, 0x03DD	; 0x8003dd <_ZL12count_output+0x2>
    3a1c:	90 91 de 03 	lds	r25, 0x03DE	; 0x8003de <_ZL12count_output+0x3>
	count_ready = 0;
    3a20:	10 92 da 03 	sts	0x03DA, r1	; 0x8003da <_ZL11count_ready>
	SREG = status;
    3a24:	2f bf       	out	0x3f, r18	; 63
	return count;
}
    3a26:	08 95       	ret

00003a28 <_ZN14FreqCountClass3endEv>:
	TIMSK2 = (1<<OCIE2A);
}

static inline void timer_shutdown(void)
{
	TCCR2B = 0;
    3a28:	e1 eb       	ldi	r30, 0xB1	; 177
    3a2a:	f0 e0       	ldi	r31, 0x00	; 0
    3a2c:	10 82       	st	Z, r1
	TIMSK2 = 0;
    3a2e:	10 92 70 00 	sts	0x0070, r1	; 0x800070 <__DATA_REGION_ORIGIN__+0x10>
	TCCR2A = saveTCCR2A;
    3a32:	80 91 e7 03 	lds	r24, 0x03E7	; 0x8003e7 <_ZL10saveTCCR2A>
    3a36:	80 93 b0 00 	sts	0x00B0, r24	; 0x8000b0 <__DATA_REGION_ORIGIN__+0x50>
	TCCR2B = saveTCCR2B;
    3a3a:	80 91 e6 03 	lds	r24, 0x03E6	; 0x8003e6 <_ZL10saveTCCR2B>
    3a3e:	80 83       	st	Z, r24
	TCCR1B = (1<<CS12) | (1<<CS11) | (1<<CS10);
}

static inline void counter_shutdown(void)
{
	TCCR1B = 0;
    3a40:	e1 e8       	ldi	r30, 0x81	; 129
    3a42:	f0 e0       	ldi	r31, 0x00	; 0
    3a44:	10 82       	st	Z, r1
	TCCR1A = saveTCCR1A;
    3a46:	80 91 e9 03 	lds	r24, 0x03E9	; 0x8003e9 <_ZL10saveTCCR1A>
    3a4a:	80 93 80 00 	sts	0x0080, r24	; 0x800080 <__DATA_REGION_ORIGIN__+0x20>
	TCCR1B = saveTCCR1B;
    3a4e:	80 91 e8 03 	lds	r24, 0x03E8	; 0x8003e8 <_ZL10saveTCCR1B>
    3a52:	80 83       	st	Z, r24
    3a54:	08 95       	ret

00003a56 <__vector_7>:
	counter_shutdown();
}


ISR(TIMER_ISR_VECTOR)
{
    3a56:	1f 92       	push	r1
    3a58:	0f 92       	push	r0
    3a5a:	0f b6       	in	r0, 0x3f	; 63
    3a5c:	0f 92       	push	r0
    3a5e:	11 24       	eor	r1, r1
    3a60:	0f 93       	push	r16
    3a62:	1f 93       	push	r17
    3a64:	2f 93       	push	r18
    3a66:	3f 93       	push	r19
    3a68:	4f 93       	push	r20
    3a6a:	5f 93       	push	r21
    3a6c:	6f 93       	push	r22
    3a6e:	7f 93       	push	r23
    3a70:	8f 93       	push	r24
    3a72:	9f 93       	push	r25
    3a74:	af 93       	push	r26
    3a76:	bf 93       	push	r27
}

static inline uint16_t counter_read(void)
{
	return TCNT1;
    3a78:	20 91 84 00 	lds	r18, 0x0084	; 0x800084 <__DATA_REGION_ORIGIN__+0x24>
    3a7c:	30 91 85 00 	lds	r19, 0x0085	; 0x800085 <__DATA_REGION_ORIGIN__+0x25>
	uint16_t count_lsw;
	uint32_t count;
	uint16_t index, length;

	count_lsw = counter_read();
	if (counter_overflow()) {
    3a80:	b0 9b       	sbis	0x16, 0	; 22
    3a82:	0b c0       	rjmp	.+22     	; 0x3a9a <__vector_7+0x44>
	return TIFR1 & (1<<TOV1);
}

static inline void counter_overflow_reset(void)
{
	TIFR1 = (1<<TOV1);
    3a84:	81 e0       	ldi	r24, 0x01	; 1
    3a86:	86 bb       	out	0x16, r24	; 22
		counter_overflow_reset();
		count_msw++;
    3a88:	80 91 e3 03 	lds	r24, 0x03E3	; 0x8003e3 <_ZL9count_msw>
    3a8c:	90 91 e4 03 	lds	r25, 0x03E4	; 0x8003e4 <_ZL9count_msw+0x1>
    3a90:	01 96       	adiw	r24, 0x01	; 1
    3a92:	90 93 e4 03 	sts	0x03E4, r25	; 0x8003e4 <_ZL9count_msw+0x1>
    3a96:	80 93 e3 03 	sts	0x03E3, r24	; 0x8003e3 <_ZL9count_msw>
	}
	index = gate_index + 1;
    3a9a:	80 91 d6 03 	lds	r24, 0x03D6	; 0x8003d6 <_ZL10gate_index>
    3a9e:	90 91 d7 03 	lds	r25, 0x03D7	; 0x8003d7 <_ZL10gate_index+0x1>
    3aa2:	01 96       	adiw	r24, 0x01	; 1
	length = gate_length;
	if (index >= length) {
    3aa4:	40 91 d8 03 	lds	r20, 0x03D8	; 0x8003d8 <_ZL11gate_length>
    3aa8:	50 91 d9 03 	lds	r21, 0x03D9	; 0x8003d9 <_ZL11gate_length+0x1>
    3aac:	84 17       	cp	r24, r20
    3aae:	95 07       	cpc	r25, r21
    3ab0:	98 f1       	brcs	.+102    	; 0x3b18 <__vector_7+0xc2>
		gate_index = 0;
    3ab2:	10 92 d7 03 	sts	0x03D7, r1	; 0x8003d7 <_ZL10gate_index+0x1>
    3ab6:	10 92 d6 03 	sts	0x03D6, r1	; 0x8003d6 <_ZL10gate_index>
		count = ((uint32_t)count_msw << 16) + count_lsw;
    3aba:	80 91 e3 03 	lds	r24, 0x03E3	; 0x8003e3 <_ZL9count_msw>
    3abe:	90 91 e4 03 	lds	r25, 0x03E4	; 0x8003e4 <_ZL9count_msw+0x1>
    3ac2:	a0 e0       	ldi	r26, 0x00	; 0
    3ac4:	b0 e0       	ldi	r27, 0x00	; 0
    3ac6:	dc 01       	movw	r26, r24
    3ac8:	99 27       	eor	r25, r25
    3aca:	88 27       	eor	r24, r24
    3acc:	82 0f       	add	r24, r18
    3ace:	93 1f       	adc	r25, r19
    3ad0:	a1 1d       	adc	r26, r1
    3ad2:	b1 1d       	adc	r27, r1
		count_output = count - count_prev;
    3ad4:	40 91 df 03 	lds	r20, 0x03DF	; 0x8003df <_ZL10count_prev>
    3ad8:	50 91 e0 03 	lds	r21, 0x03E0	; 0x8003e0 <_ZL10count_prev+0x1>
    3adc:	60 91 e1 03 	lds	r22, 0x03E1	; 0x8003e1 <_ZL10count_prev+0x2>
    3ae0:	70 91 e2 03 	lds	r23, 0x03E2	; 0x8003e2 <_ZL10count_prev+0x3>
    3ae4:	8c 01       	movw	r16, r24
    3ae6:	9d 01       	movw	r18, r26
    3ae8:	04 1b       	sub	r16, r20
    3aea:	15 0b       	sbc	r17, r21
    3aec:	26 0b       	sbc	r18, r22
    3aee:	37 0b       	sbc	r19, r23
    3af0:	00 93 db 03 	sts	0x03DB, r16	; 0x8003db <_ZL12count_output>
    3af4:	10 93 dc 03 	sts	0x03DC, r17	; 0x8003dc <_ZL12count_output+0x1>
    3af8:	20 93 dd 03 	sts	0x03DD, r18	; 0x8003dd <_ZL12count_output+0x2>
    3afc:	30 93 de 03 	sts	0x03DE, r19	; 0x8003de <_ZL12count_output+0x3>
		count_prev = count;
    3b00:	80 93 df 03 	sts	0x03DF, r24	; 0x8003df <_ZL10count_prev>
    3b04:	90 93 e0 03 	sts	0x03E0, r25	; 0x8003e0 <_ZL10count_prev+0x1>
    3b08:	a0 93 e1 03 	sts	0x03E1, r26	; 0x8003e1 <_ZL10count_prev+0x2>
    3b0c:	b0 93 e2 03 	sts	0x03E2, r27	; 0x8003e2 <_ZL10count_prev+0x3>
		count_ready = 1;
    3b10:	81 e0       	ldi	r24, 0x01	; 1
    3b12:	80 93 da 03 	sts	0x03DA, r24	; 0x8003da <_ZL11count_ready>
    3b16:	04 c0       	rjmp	.+8      	; 0x3b20 <__vector_7+0xca>
		restore_other_interrupts();
	} else {
		if (index == length - 1) disable_other_interrupts();
		gate_index = index;
    3b18:	90 93 d7 03 	sts	0x03D7, r25	; 0x8003d7 <_ZL10gate_index+0x1>
    3b1c:	80 93 d6 03 	sts	0x03D6, r24	; 0x8003d6 <_ZL10gate_index>
	}
}
    3b20:	bf 91       	pop	r27
    3b22:	af 91       	pop	r26
    3b24:	9f 91       	pop	r25
    3b26:	8f 91       	pop	r24
    3b28:	7f 91       	pop	r23
    3b2a:	6f 91       	pop	r22
    3b2c:	5f 91       	pop	r21
    3b2e:	4f 91       	pop	r20
    3b30:	3f 91       	pop	r19
    3b32:	2f 91       	pop	r18
    3b34:	1f 91       	pop	r17
    3b36:	0f 91       	pop	r16
    3b38:	0f 90       	pop	r0
    3b3a:	0f be       	out	0x3f, r0	; 63
    3b3c:	0f 90       	pop	r0
    3b3e:	1f 90       	pop	r1
    3b40:	18 95       	reti

00003b42 <__fixunssfsi>:
    3b42:	0e 94 4e 07 	call	0xe9c	; 0xe9c <__fp_splitA>
    3b46:	88 f0       	brcs	.+34     	; 0x3b6a <__fixunssfsi+0x28>
    3b48:	9f 57       	subi	r25, 0x7F	; 127
    3b4a:	98 f0       	brcs	.+38     	; 0x3b72 <__fixunssfsi+0x30>
    3b4c:	b9 2f       	mov	r27, r25
    3b4e:	99 27       	eor	r25, r25
    3b50:	b7 51       	subi	r27, 0x17	; 23
    3b52:	b0 f0       	brcs	.+44     	; 0x3b80 <__fixunssfsi+0x3e>
    3b54:	e1 f0       	breq	.+56     	; 0x3b8e <__fixunssfsi+0x4c>
    3b56:	66 0f       	add	r22, r22
    3b58:	77 1f       	adc	r23, r23
    3b5a:	88 1f       	adc	r24, r24
    3b5c:	99 1f       	adc	r25, r25
    3b5e:	1a f0       	brmi	.+6      	; 0x3b66 <__fixunssfsi+0x24>
    3b60:	ba 95       	dec	r27
    3b62:	c9 f7       	brne	.-14     	; 0x3b56 <__fixunssfsi+0x14>
    3b64:	14 c0       	rjmp	.+40     	; 0x3b8e <__fixunssfsi+0x4c>
    3b66:	b1 30       	cpi	r27, 0x01	; 1
    3b68:	91 f0       	breq	.+36     	; 0x3b8e <__fixunssfsi+0x4c>
    3b6a:	0e 94 68 07 	call	0xed0	; 0xed0 <__fp_zero>
    3b6e:	b1 e0       	ldi	r27, 0x01	; 1
    3b70:	08 95       	ret
    3b72:	0c 94 68 07 	jmp	0xed0	; 0xed0 <__fp_zero>
    3b76:	67 2f       	mov	r22, r23
    3b78:	78 2f       	mov	r23, r24
    3b7a:	88 27       	eor	r24, r24
    3b7c:	b8 5f       	subi	r27, 0xF8	; 248
    3b7e:	39 f0       	breq	.+14     	; 0x3b8e <__fixunssfsi+0x4c>
    3b80:	b9 3f       	cpi	r27, 0xF9	; 249
    3b82:	cc f3       	brlt	.-14     	; 0x3b76 <__fixunssfsi+0x34>
    3b84:	86 95       	lsr	r24
    3b86:	77 95       	ror	r23
    3b88:	67 95       	ror	r22
    3b8a:	b3 95       	inc	r27
    3b8c:	d9 f7       	brne	.-10     	; 0x3b84 <__fixunssfsi+0x42>
    3b8e:	3e f4       	brtc	.+14     	; 0x3b9e <__fixunssfsi+0x5c>
    3b90:	90 95       	com	r25
    3b92:	80 95       	com	r24
    3b94:	70 95       	com	r23
    3b96:	61 95       	neg	r22
    3b98:	7f 4f       	sbci	r23, 0xFF	; 255
    3b9a:	8f 4f       	sbci	r24, 0xFF	; 255
    3b9c:	9f 4f       	sbci	r25, 0xFF	; 255
    3b9e:	08 95       	ret

00003ba0 <__unordsf2>:
    3ba0:	0e 94 fa 06 	call	0xdf4	; 0xdf4 <__fp_cmp>
    3ba4:	88 0b       	sbc	r24, r24
    3ba6:	99 0b       	sbc	r25, r25
    3ba8:	08 95       	ret

00003baa <__divmodhi4>:
    3baa:	97 fb       	bst	r25, 7
    3bac:	07 2e       	mov	r0, r23
    3bae:	16 f4       	brtc	.+4      	; 0x3bb4 <__divmodhi4+0xa>
    3bb0:	00 94       	com	r0
    3bb2:	07 d0       	rcall	.+14     	; 0x3bc2 <__divmodhi4_neg1>
    3bb4:	77 fd       	sbrc	r23, 7
    3bb6:	09 d0       	rcall	.+18     	; 0x3bca <__divmodhi4_neg2>
    3bb8:	0e 94 3b 1e 	call	0x3c76	; 0x3c76 <__udivmodhi4>
    3bbc:	07 fc       	sbrc	r0, 7
    3bbe:	05 d0       	rcall	.+10     	; 0x3bca <__divmodhi4_neg2>
    3bc0:	3e f4       	brtc	.+14     	; 0x3bd0 <__divmodhi4_exit>

00003bc2 <__divmodhi4_neg1>:
    3bc2:	90 95       	com	r25
    3bc4:	81 95       	neg	r24
    3bc6:	9f 4f       	sbci	r25, 0xFF	; 255
    3bc8:	08 95       	ret

00003bca <__divmodhi4_neg2>:
    3bca:	70 95       	com	r23
    3bcc:	61 95       	neg	r22
    3bce:	7f 4f       	sbci	r23, 0xFF	; 255

00003bd0 <__divmodhi4_exit>:
    3bd0:	08 95       	ret

00003bd2 <__udivmodsi4>:
    3bd2:	a1 e2       	ldi	r26, 0x21	; 33
    3bd4:	1a 2e       	mov	r1, r26
    3bd6:	aa 1b       	sub	r26, r26
    3bd8:	bb 1b       	sub	r27, r27
    3bda:	fd 01       	movw	r30, r26
    3bdc:	0d c0       	rjmp	.+26     	; 0x3bf8 <__udivmodsi4_ep>

00003bde <__udivmodsi4_loop>:
    3bde:	aa 1f       	adc	r26, r26
    3be0:	bb 1f       	adc	r27, r27
    3be2:	ee 1f       	adc	r30, r30
    3be4:	ff 1f       	adc	r31, r31
    3be6:	a2 17       	cp	r26, r18
    3be8:	b3 07       	cpc	r27, r19
    3bea:	e4 07       	cpc	r30, r20
    3bec:	f5 07       	cpc	r31, r21
    3bee:	20 f0       	brcs	.+8      	; 0x3bf8 <__udivmodsi4_ep>
    3bf0:	a2 1b       	sub	r26, r18
    3bf2:	b3 0b       	sbc	r27, r19
    3bf4:	e4 0b       	sbc	r30, r20
    3bf6:	f5 0b       	sbc	r31, r21

00003bf8 <__udivmodsi4_ep>:
    3bf8:	66 1f       	adc	r22, r22
    3bfa:	77 1f       	adc	r23, r23
    3bfc:	88 1f       	adc	r24, r24
    3bfe:	99 1f       	adc	r25, r25
    3c00:	1a 94       	dec	r1
    3c02:	69 f7       	brne	.-38     	; 0x3bde <__udivmodsi4_loop>
    3c04:	60 95       	com	r22
    3c06:	70 95       	com	r23
    3c08:	80 95       	com	r24
    3c0a:	90 95       	com	r25
    3c0c:	9b 01       	movw	r18, r22
    3c0e:	ac 01       	movw	r20, r24
    3c10:	bd 01       	movw	r22, r26
    3c12:	cf 01       	movw	r24, r30
    3c14:	08 95       	ret

00003c16 <__divmodsi4>:
    3c16:	05 2e       	mov	r0, r21
    3c18:	97 fb       	bst	r25, 7
    3c1a:	1e f4       	brtc	.+6      	; 0x3c22 <__divmodsi4+0xc>
    3c1c:	00 94       	com	r0
    3c1e:	0e 94 22 1e 	call	0x3c44	; 0x3c44 <__negsi2>
    3c22:	57 fd       	sbrc	r21, 7
    3c24:	07 d0       	rcall	.+14     	; 0x3c34 <__divmodsi4_neg2>
    3c26:	0e 94 e9 1d 	call	0x3bd2	; 0x3bd2 <__udivmodsi4>
    3c2a:	07 fc       	sbrc	r0, 7
    3c2c:	03 d0       	rcall	.+6      	; 0x3c34 <__divmodsi4_neg2>
    3c2e:	4e f4       	brtc	.+18     	; 0x3c42 <__divmodsi4_exit>
    3c30:	0c 94 22 1e 	jmp	0x3c44	; 0x3c44 <__negsi2>

00003c34 <__divmodsi4_neg2>:
    3c34:	50 95       	com	r21
    3c36:	40 95       	com	r20
    3c38:	30 95       	com	r19
    3c3a:	21 95       	neg	r18
    3c3c:	3f 4f       	sbci	r19, 0xFF	; 255
    3c3e:	4f 4f       	sbci	r20, 0xFF	; 255
    3c40:	5f 4f       	sbci	r21, 0xFF	; 255

00003c42 <__divmodsi4_exit>:
    3c42:	08 95       	ret

00003c44 <__negsi2>:
    3c44:	90 95       	com	r25
    3c46:	80 95       	com	r24
    3c48:	70 95       	com	r23
    3c4a:	61 95       	neg	r22
    3c4c:	7f 4f       	sbci	r23, 0xFF	; 255
    3c4e:	8f 4f       	sbci	r24, 0xFF	; 255
    3c50:	9f 4f       	sbci	r25, 0xFF	; 255
    3c52:	08 95       	ret

00003c54 <__tablejump2__>:
    3c54:	ee 0f       	add	r30, r30
    3c56:	ff 1f       	adc	r31, r31
    3c58:	05 90       	lpm	r0, Z+
    3c5a:	f4 91       	lpm	r31, Z
    3c5c:	e0 2d       	mov	r30, r0
    3c5e:	09 94       	ijmp

00003c60 <__muluhisi3>:
    3c60:	0e 94 4f 1e 	call	0x3c9e	; 0x3c9e <__umulhisi3>
    3c64:	a5 9f       	mul	r26, r21
    3c66:	90 0d       	add	r25, r0
    3c68:	b4 9f       	mul	r27, r20
    3c6a:	90 0d       	add	r25, r0
    3c6c:	a4 9f       	mul	r26, r20
    3c6e:	80 0d       	add	r24, r0
    3c70:	91 1d       	adc	r25, r1
    3c72:	11 24       	eor	r1, r1
    3c74:	08 95       	ret

00003c76 <__udivmodhi4>:
    3c76:	aa 1b       	sub	r26, r26
    3c78:	bb 1b       	sub	r27, r27
    3c7a:	51 e1       	ldi	r21, 0x11	; 17
    3c7c:	07 c0       	rjmp	.+14     	; 0x3c8c <__udivmodhi4_ep>

00003c7e <__udivmodhi4_loop>:
    3c7e:	aa 1f       	adc	r26, r26
    3c80:	bb 1f       	adc	r27, r27
    3c82:	a6 17       	cp	r26, r22
    3c84:	b7 07       	cpc	r27, r23
    3c86:	10 f0       	brcs	.+4      	; 0x3c8c <__udivmodhi4_ep>
    3c88:	a6 1b       	sub	r26, r22
    3c8a:	b7 0b       	sbc	r27, r23

00003c8c <__udivmodhi4_ep>:
    3c8c:	88 1f       	adc	r24, r24
    3c8e:	99 1f       	adc	r25, r25
    3c90:	5a 95       	dec	r21
    3c92:	a9 f7       	brne	.-22     	; 0x3c7e <__udivmodhi4_loop>
    3c94:	80 95       	com	r24
    3c96:	90 95       	com	r25
    3c98:	bc 01       	movw	r22, r24
    3c9a:	cd 01       	movw	r24, r26
    3c9c:	08 95       	ret

00003c9e <__umulhisi3>:
    3c9e:	a2 9f       	mul	r26, r18
    3ca0:	b0 01       	movw	r22, r0
    3ca2:	b3 9f       	mul	r27, r19
    3ca4:	c0 01       	movw	r24, r0
    3ca6:	a3 9f       	mul	r26, r19
    3ca8:	70 0d       	add	r23, r0
    3caa:	81 1d       	adc	r24, r1
    3cac:	11 24       	eor	r1, r1
    3cae:	91 1d       	adc	r25, r1
    3cb0:	b2 9f       	mul	r27, r18
    3cb2:	70 0d       	add	r23, r0
    3cb4:	81 1d       	adc	r24, r1
    3cb6:	11 24       	eor	r1, r1
    3cb8:	91 1d       	adc	r25, r1
    3cba:	08 95       	ret

00003cbc <malloc>:
    3cbc:	0f 93       	push	r16
    3cbe:	1f 93       	push	r17
    3cc0:	cf 93       	push	r28
    3cc2:	df 93       	push	r29
    3cc4:	82 30       	cpi	r24, 0x02	; 2
    3cc6:	91 05       	cpc	r25, r1
    3cc8:	10 f4       	brcc	.+4      	; 0x3cce <malloc+0x12>
    3cca:	82 e0       	ldi	r24, 0x02	; 2
    3ccc:	90 e0       	ldi	r25, 0x00	; 0
    3cce:	e0 91 ec 03 	lds	r30, 0x03EC	; 0x8003ec <__flp>
    3cd2:	f0 91 ed 03 	lds	r31, 0x03ED	; 0x8003ed <__flp+0x1>
    3cd6:	20 e0       	ldi	r18, 0x00	; 0
    3cd8:	30 e0       	ldi	r19, 0x00	; 0
    3cda:	a0 e0       	ldi	r26, 0x00	; 0
    3cdc:	b0 e0       	ldi	r27, 0x00	; 0
    3cde:	30 97       	sbiw	r30, 0x00	; 0
    3ce0:	19 f1       	breq	.+70     	; 0x3d28 <malloc+0x6c>
    3ce2:	40 81       	ld	r20, Z
    3ce4:	51 81       	ldd	r21, Z+1	; 0x01
    3ce6:	02 81       	ldd	r16, Z+2	; 0x02
    3ce8:	13 81       	ldd	r17, Z+3	; 0x03
    3cea:	48 17       	cp	r20, r24
    3cec:	59 07       	cpc	r21, r25
    3cee:	c8 f0       	brcs	.+50     	; 0x3d22 <malloc+0x66>
    3cf0:	84 17       	cp	r24, r20
    3cf2:	95 07       	cpc	r25, r21
    3cf4:	69 f4       	brne	.+26     	; 0x3d10 <malloc+0x54>
    3cf6:	10 97       	sbiw	r26, 0x00	; 0
    3cf8:	31 f0       	breq	.+12     	; 0x3d06 <malloc+0x4a>
    3cfa:	12 96       	adiw	r26, 0x02	; 2
    3cfc:	0c 93       	st	X, r16
    3cfe:	12 97       	sbiw	r26, 0x02	; 2
    3d00:	13 96       	adiw	r26, 0x03	; 3
    3d02:	1c 93       	st	X, r17
    3d04:	27 c0       	rjmp	.+78     	; 0x3d54 <malloc+0x98>
    3d06:	00 93 ec 03 	sts	0x03EC, r16	; 0x8003ec <__flp>
    3d0a:	10 93 ed 03 	sts	0x03ED, r17	; 0x8003ed <__flp+0x1>
    3d0e:	22 c0       	rjmp	.+68     	; 0x3d54 <malloc+0x98>
    3d10:	21 15       	cp	r18, r1
    3d12:	31 05       	cpc	r19, r1
    3d14:	19 f0       	breq	.+6      	; 0x3d1c <malloc+0x60>
    3d16:	42 17       	cp	r20, r18
    3d18:	53 07       	cpc	r21, r19
    3d1a:	18 f4       	brcc	.+6      	; 0x3d22 <malloc+0x66>
    3d1c:	9a 01       	movw	r18, r20
    3d1e:	bd 01       	movw	r22, r26
    3d20:	ef 01       	movw	r28, r30
    3d22:	df 01       	movw	r26, r30
    3d24:	f8 01       	movw	r30, r16
    3d26:	db cf       	rjmp	.-74     	; 0x3cde <malloc+0x22>
    3d28:	21 15       	cp	r18, r1
    3d2a:	31 05       	cpc	r19, r1
    3d2c:	f9 f0       	breq	.+62     	; 0x3d6c <malloc+0xb0>
    3d2e:	28 1b       	sub	r18, r24
    3d30:	39 0b       	sbc	r19, r25
    3d32:	24 30       	cpi	r18, 0x04	; 4
    3d34:	31 05       	cpc	r19, r1
    3d36:	80 f4       	brcc	.+32     	; 0x3d58 <malloc+0x9c>
    3d38:	8a 81       	ldd	r24, Y+2	; 0x02
    3d3a:	9b 81       	ldd	r25, Y+3	; 0x03
    3d3c:	61 15       	cp	r22, r1
    3d3e:	71 05       	cpc	r23, r1
    3d40:	21 f0       	breq	.+8      	; 0x3d4a <malloc+0x8e>
    3d42:	fb 01       	movw	r30, r22
    3d44:	93 83       	std	Z+3, r25	; 0x03
    3d46:	82 83       	std	Z+2, r24	; 0x02
    3d48:	04 c0       	rjmp	.+8      	; 0x3d52 <malloc+0x96>
    3d4a:	90 93 ed 03 	sts	0x03ED, r25	; 0x8003ed <__flp+0x1>
    3d4e:	80 93 ec 03 	sts	0x03EC, r24	; 0x8003ec <__flp>
    3d52:	fe 01       	movw	r30, r28
    3d54:	32 96       	adiw	r30, 0x02	; 2
    3d56:	44 c0       	rjmp	.+136    	; 0x3de0 <malloc+0x124>
    3d58:	fe 01       	movw	r30, r28
    3d5a:	e2 0f       	add	r30, r18
    3d5c:	f3 1f       	adc	r31, r19
    3d5e:	81 93       	st	Z+, r24
    3d60:	91 93       	st	Z+, r25
    3d62:	22 50       	subi	r18, 0x02	; 2
    3d64:	31 09       	sbc	r19, r1
    3d66:	39 83       	std	Y+1, r19	; 0x01
    3d68:	28 83       	st	Y, r18
    3d6a:	3a c0       	rjmp	.+116    	; 0x3de0 <malloc+0x124>
    3d6c:	20 91 ea 03 	lds	r18, 0x03EA	; 0x8003ea <__brkval>
    3d70:	30 91 eb 03 	lds	r19, 0x03EB	; 0x8003eb <__brkval+0x1>
    3d74:	23 2b       	or	r18, r19
    3d76:	41 f4       	brne	.+16     	; 0x3d88 <malloc+0xcc>
    3d78:	20 91 02 01 	lds	r18, 0x0102	; 0x800102 <__malloc_heap_start>
    3d7c:	30 91 03 01 	lds	r19, 0x0103	; 0x800103 <__malloc_heap_start+0x1>
    3d80:	30 93 eb 03 	sts	0x03EB, r19	; 0x8003eb <__brkval+0x1>
    3d84:	20 93 ea 03 	sts	0x03EA, r18	; 0x8003ea <__brkval>
    3d88:	20 91 00 01 	lds	r18, 0x0100	; 0x800100 <__data_start>
    3d8c:	30 91 01 01 	lds	r19, 0x0101	; 0x800101 <__data_start+0x1>
    3d90:	21 15       	cp	r18, r1
    3d92:	31 05       	cpc	r19, r1
    3d94:	41 f4       	brne	.+16     	; 0x3da6 <malloc+0xea>
    3d96:	2d b7       	in	r18, 0x3d	; 61
    3d98:	3e b7       	in	r19, 0x3e	; 62
    3d9a:	40 91 04 01 	lds	r20, 0x0104	; 0x800104 <__malloc_margin>
    3d9e:	50 91 05 01 	lds	r21, 0x0105	; 0x800105 <__malloc_margin+0x1>
    3da2:	24 1b       	sub	r18, r20
    3da4:	35 0b       	sbc	r19, r21
    3da6:	e0 91 ea 03 	lds	r30, 0x03EA	; 0x8003ea <__brkval>
    3daa:	f0 91 eb 03 	lds	r31, 0x03EB	; 0x8003eb <__brkval+0x1>
    3dae:	e2 17       	cp	r30, r18
    3db0:	f3 07       	cpc	r31, r19
    3db2:	a0 f4       	brcc	.+40     	; 0x3ddc <malloc+0x120>
    3db4:	2e 1b       	sub	r18, r30
    3db6:	3f 0b       	sbc	r19, r31
    3db8:	28 17       	cp	r18, r24
    3dba:	39 07       	cpc	r19, r25
    3dbc:	78 f0       	brcs	.+30     	; 0x3ddc <malloc+0x120>
    3dbe:	ac 01       	movw	r20, r24
    3dc0:	4e 5f       	subi	r20, 0xFE	; 254
    3dc2:	5f 4f       	sbci	r21, 0xFF	; 255
    3dc4:	24 17       	cp	r18, r20
    3dc6:	35 07       	cpc	r19, r21
    3dc8:	48 f0       	brcs	.+18     	; 0x3ddc <malloc+0x120>
    3dca:	4e 0f       	add	r20, r30
    3dcc:	5f 1f       	adc	r21, r31
    3dce:	50 93 eb 03 	sts	0x03EB, r21	; 0x8003eb <__brkval+0x1>
    3dd2:	40 93 ea 03 	sts	0x03EA, r20	; 0x8003ea <__brkval>
    3dd6:	81 93       	st	Z+, r24
    3dd8:	91 93       	st	Z+, r25
    3dda:	02 c0       	rjmp	.+4      	; 0x3de0 <malloc+0x124>
    3ddc:	e0 e0       	ldi	r30, 0x00	; 0
    3dde:	f0 e0       	ldi	r31, 0x00	; 0
    3de0:	cf 01       	movw	r24, r30
    3de2:	df 91       	pop	r29
    3de4:	cf 91       	pop	r28
    3de6:	1f 91       	pop	r17
    3de8:	0f 91       	pop	r16
    3dea:	08 95       	ret

00003dec <free>:
    3dec:	cf 93       	push	r28
    3dee:	df 93       	push	r29
    3df0:	00 97       	sbiw	r24, 0x00	; 0
    3df2:	09 f4       	brne	.+2      	; 0x3df6 <free+0xa>
    3df4:	81 c0       	rjmp	.+258    	; 0x3ef8 <free+0x10c>
    3df6:	fc 01       	movw	r30, r24
    3df8:	32 97       	sbiw	r30, 0x02	; 2
    3dfa:	13 82       	std	Z+3, r1	; 0x03
    3dfc:	12 82       	std	Z+2, r1	; 0x02
    3dfe:	a0 91 ec 03 	lds	r26, 0x03EC	; 0x8003ec <__flp>
    3e02:	b0 91 ed 03 	lds	r27, 0x03ED	; 0x8003ed <__flp+0x1>
    3e06:	10 97       	sbiw	r26, 0x00	; 0
    3e08:	81 f4       	brne	.+32     	; 0x3e2a <free+0x3e>
    3e0a:	20 81       	ld	r18, Z
    3e0c:	31 81       	ldd	r19, Z+1	; 0x01
    3e0e:	82 0f       	add	r24, r18
    3e10:	93 1f       	adc	r25, r19
    3e12:	20 91 ea 03 	lds	r18, 0x03EA	; 0x8003ea <__brkval>
    3e16:	30 91 eb 03 	lds	r19, 0x03EB	; 0x8003eb <__brkval+0x1>
    3e1a:	28 17       	cp	r18, r24
    3e1c:	39 07       	cpc	r19, r25
    3e1e:	51 f5       	brne	.+84     	; 0x3e74 <free+0x88>
    3e20:	f0 93 eb 03 	sts	0x03EB, r31	; 0x8003eb <__brkval+0x1>
    3e24:	e0 93 ea 03 	sts	0x03EA, r30	; 0x8003ea <__brkval>
    3e28:	67 c0       	rjmp	.+206    	; 0x3ef8 <free+0x10c>
    3e2a:	ed 01       	movw	r28, r26
    3e2c:	20 e0       	ldi	r18, 0x00	; 0
    3e2e:	30 e0       	ldi	r19, 0x00	; 0
    3e30:	ce 17       	cp	r28, r30
    3e32:	df 07       	cpc	r29, r31
    3e34:	40 f4       	brcc	.+16     	; 0x3e46 <free+0x5a>
    3e36:	4a 81       	ldd	r20, Y+2	; 0x02
    3e38:	5b 81       	ldd	r21, Y+3	; 0x03
    3e3a:	9e 01       	movw	r18, r28
    3e3c:	41 15       	cp	r20, r1
    3e3e:	51 05       	cpc	r21, r1
    3e40:	f1 f0       	breq	.+60     	; 0x3e7e <free+0x92>
    3e42:	ea 01       	movw	r28, r20
    3e44:	f5 cf       	rjmp	.-22     	; 0x3e30 <free+0x44>
    3e46:	d3 83       	std	Z+3, r29	; 0x03
    3e48:	c2 83       	std	Z+2, r28	; 0x02
    3e4a:	40 81       	ld	r20, Z
    3e4c:	51 81       	ldd	r21, Z+1	; 0x01
    3e4e:	84 0f       	add	r24, r20
    3e50:	95 1f       	adc	r25, r21
    3e52:	c8 17       	cp	r28, r24
    3e54:	d9 07       	cpc	r29, r25
    3e56:	59 f4       	brne	.+22     	; 0x3e6e <free+0x82>
    3e58:	88 81       	ld	r24, Y
    3e5a:	99 81       	ldd	r25, Y+1	; 0x01
    3e5c:	84 0f       	add	r24, r20
    3e5e:	95 1f       	adc	r25, r21
    3e60:	02 96       	adiw	r24, 0x02	; 2
    3e62:	91 83       	std	Z+1, r25	; 0x01
    3e64:	80 83       	st	Z, r24
    3e66:	8a 81       	ldd	r24, Y+2	; 0x02
    3e68:	9b 81       	ldd	r25, Y+3	; 0x03
    3e6a:	93 83       	std	Z+3, r25	; 0x03
    3e6c:	82 83       	std	Z+2, r24	; 0x02
    3e6e:	21 15       	cp	r18, r1
    3e70:	31 05       	cpc	r19, r1
    3e72:	29 f4       	brne	.+10     	; 0x3e7e <free+0x92>
    3e74:	f0 93 ed 03 	sts	0x03ED, r31	; 0x8003ed <__flp+0x1>
    3e78:	e0 93 ec 03 	sts	0x03EC, r30	; 0x8003ec <__flp>
    3e7c:	3d c0       	rjmp	.+122    	; 0x3ef8 <free+0x10c>
    3e7e:	e9 01       	movw	r28, r18
    3e80:	fb 83       	std	Y+3, r31	; 0x03
    3e82:	ea 83       	std	Y+2, r30	; 0x02
    3e84:	49 91       	ld	r20, Y+
    3e86:	59 91       	ld	r21, Y+
    3e88:	c4 0f       	add	r28, r20
    3e8a:	d5 1f       	adc	r29, r21
    3e8c:	ec 17       	cp	r30, r28
    3e8e:	fd 07       	cpc	r31, r29
    3e90:	61 f4       	brne	.+24     	; 0x3eaa <free+0xbe>
    3e92:	80 81       	ld	r24, Z
    3e94:	91 81       	ldd	r25, Z+1	; 0x01
    3e96:	84 0f       	add	r24, r20
    3e98:	95 1f       	adc	r25, r21
    3e9a:	02 96       	adiw	r24, 0x02	; 2
    3e9c:	e9 01       	movw	r28, r18
    3e9e:	99 83       	std	Y+1, r25	; 0x01
    3ea0:	88 83       	st	Y, r24
    3ea2:	82 81       	ldd	r24, Z+2	; 0x02
    3ea4:	93 81       	ldd	r25, Z+3	; 0x03
    3ea6:	9b 83       	std	Y+3, r25	; 0x03
    3ea8:	8a 83       	std	Y+2, r24	; 0x02
    3eaa:	e0 e0       	ldi	r30, 0x00	; 0
    3eac:	f0 e0       	ldi	r31, 0x00	; 0
    3eae:	12 96       	adiw	r26, 0x02	; 2
    3eb0:	8d 91       	ld	r24, X+
    3eb2:	9c 91       	ld	r25, X
    3eb4:	13 97       	sbiw	r26, 0x03	; 3
    3eb6:	00 97       	sbiw	r24, 0x00	; 0
    3eb8:	19 f0       	breq	.+6      	; 0x3ec0 <free+0xd4>
    3eba:	fd 01       	movw	r30, r26
    3ebc:	dc 01       	movw	r26, r24
    3ebe:	f7 cf       	rjmp	.-18     	; 0x3eae <free+0xc2>
    3ec0:	8d 91       	ld	r24, X+
    3ec2:	9c 91       	ld	r25, X
    3ec4:	11 97       	sbiw	r26, 0x01	; 1
    3ec6:	9d 01       	movw	r18, r26
    3ec8:	2e 5f       	subi	r18, 0xFE	; 254
    3eca:	3f 4f       	sbci	r19, 0xFF	; 255
    3ecc:	82 0f       	add	r24, r18
    3ece:	93 1f       	adc	r25, r19
    3ed0:	20 91 ea 03 	lds	r18, 0x03EA	; 0x8003ea <__brkval>
    3ed4:	30 91 eb 03 	lds	r19, 0x03EB	; 0x8003eb <__brkval+0x1>
    3ed8:	28 17       	cp	r18, r24
    3eda:	39 07       	cpc	r19, r25
    3edc:	69 f4       	brne	.+26     	; 0x3ef8 <free+0x10c>
    3ede:	30 97       	sbiw	r30, 0x00	; 0
    3ee0:	29 f4       	brne	.+10     	; 0x3eec <free+0x100>
    3ee2:	10 92 ed 03 	sts	0x03ED, r1	; 0x8003ed <__flp+0x1>
    3ee6:	10 92 ec 03 	sts	0x03EC, r1	; 0x8003ec <__flp>
    3eea:	02 c0       	rjmp	.+4      	; 0x3ef0 <free+0x104>
    3eec:	13 82       	std	Z+3, r1	; 0x03
    3eee:	12 82       	std	Z+2, r1	; 0x02
    3ef0:	b0 93 eb 03 	sts	0x03EB, r27	; 0x8003eb <__brkval+0x1>
    3ef4:	a0 93 ea 03 	sts	0x03EA, r26	; 0x8003ea <__brkval>
    3ef8:	df 91       	pop	r29
    3efa:	cf 91       	pop	r28
    3efc:	08 95       	ret

00003efe <memcpy>:
    3efe:	fb 01       	movw	r30, r22
    3f00:	dc 01       	movw	r26, r24
    3f02:	02 c0       	rjmp	.+4      	; 0x3f08 <memcpy+0xa>
    3f04:	01 90       	ld	r0, Z+
    3f06:	0d 92       	st	X+, r0
    3f08:	41 50       	subi	r20, 0x01	; 1
    3f0a:	50 40       	sbci	r21, 0x00	; 0
    3f0c:	d8 f7       	brcc	.-10     	; 0x3f04 <memcpy+0x6>
    3f0e:	08 95       	ret

00003f10 <memset>:
    3f10:	dc 01       	movw	r26, r24
    3f12:	01 c0       	rjmp	.+2      	; 0x3f16 <memset+0x6>
    3f14:	6d 93       	st	X+, r22
    3f16:	41 50       	subi	r20, 0x01	; 1
    3f18:	50 40       	sbci	r21, 0x00	; 0
    3f1a:	e0 f7       	brcc	.-8      	; 0x3f14 <memset+0x4>
    3f1c:	08 95       	ret

00003f1e <eeprom_read_byte>:
    3f1e:	f9 99       	sbic	0x1f, 1	; 31
    3f20:	fe cf       	rjmp	.-4      	; 0x3f1e <eeprom_read_byte>
    3f22:	92 bd       	out	0x22, r25	; 34
    3f24:	81 bd       	out	0x21, r24	; 33
    3f26:	f8 9a       	sbi	0x1f, 0	; 31
    3f28:	99 27       	eor	r25, r25
    3f2a:	80 b5       	in	r24, 0x20	; 32
    3f2c:	08 95       	ret

00003f2e <eeprom_write_byte>:
    3f2e:	26 2f       	mov	r18, r22

00003f30 <eeprom_write_r18>:
    3f30:	f9 99       	sbic	0x1f, 1	; 31
    3f32:	fe cf       	rjmp	.-4      	; 0x3f30 <eeprom_write_r18>
    3f34:	1f ba       	out	0x1f, r1	; 31
    3f36:	92 bd       	out	0x22, r25	; 34
    3f38:	81 bd       	out	0x21, r24	; 33
    3f3a:	20 bd       	out	0x20, r18	; 32
    3f3c:	0f b6       	in	r0, 0x3f	; 63
    3f3e:	f8 94       	cli
    3f40:	fa 9a       	sbi	0x1f, 2	; 31
    3f42:	f9 9a       	sbi	0x1f, 1	; 31
    3f44:	0f be       	out	0x3f, r0	; 63
    3f46:	01 96       	adiw	r24, 0x01	; 1
    3f48:	08 95       	ret

00003f4a <__do_global_dtors>:
    3f4a:	10 e0       	ldi	r17, 0x00	; 0
    3f4c:	c3 e7       	ldi	r28, 0x73	; 115
    3f4e:	d0 e0       	ldi	r29, 0x00	; 0
    3f50:	04 c0       	rjmp	.+8      	; 0x3f5a <__do_global_dtors+0x10>
    3f52:	fe 01       	movw	r30, r28
    3f54:	0e 94 2a 1e 	call	0x3c54	; 0x3c54 <__tablejump2__>
    3f58:	21 96       	adiw	r28, 0x01	; 1
    3f5a:	c4 37       	cpi	r28, 0x74	; 116
    3f5c:	d1 07       	cpc	r29, r17
    3f5e:	c9 f7       	brne	.-14     	; 0x3f52 <__do_global_dtors+0x8>
    3f60:	f8 94       	cli

00003f62 <__stop_program>:
    3f62:	ff cf       	rjmp	.-2      	; 0x3f62 <__stop_program>
