
lil_fish_tanks_arduino.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000054  00800100  000031fe  00003292  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         000031fe  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          0000020c  00800154  00800154  000032e6  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  000032e6  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00003318  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000800  00000000  00000000  00003358  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   0000f1f7  00000000  00000000  00003b58  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00003021  00000000  00000000  00012d4f  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   0000520b  00000000  00000000  00015d70  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  000018b8  00000000  00000000  0001af7c  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00004016  00000000  00000000  0001c834  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    000093b6  00000000  00000000  0002084a  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000798  00000000  00000000  00029c00  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 74 00 	jmp	0xe8	; 0xe8 <__dtors_end>
       4:	0c 94 ad 05 	jmp	0xb5a	; 0xb5a <__vector_1>
       8:	0c 94 d4 05 	jmp	0xba8	; 0xba8 <__vector_2>
       c:	0c 94 9c 00 	jmp	0x138	; 0x138 <__bad_interrupt>
      10:	0c 94 9c 00 	jmp	0x138	; 0x138 <__bad_interrupt>
      14:	0c 94 9c 00 	jmp	0x138	; 0x138 <__bad_interrupt>
      18:	0c 94 1f 16 	jmp	0x2c3e	; 0x2c3e <__vector_6>
      1c:	0c 94 c2 16 	jmp	0x2d84	; 0x2d84 <__vector_7>
      20:	0c 94 9c 00 	jmp	0x138	; 0x138 <__bad_interrupt>
      24:	0c 94 9c 00 	jmp	0x138	; 0x138 <__bad_interrupt>
      28:	0c 94 9c 00 	jmp	0x138	; 0x138 <__bad_interrupt>
      2c:	0c 94 9c 00 	jmp	0x138	; 0x138 <__bad_interrupt>
      30:	0c 94 9c 00 	jmp	0x138	; 0x138 <__bad_interrupt>
      34:	0c 94 9c 00 	jmp	0x138	; 0x138 <__bad_interrupt>
      38:	0c 94 9c 00 	jmp	0x138	; 0x138 <__bad_interrupt>
      3c:	0c 94 9c 00 	jmp	0x138	; 0x138 <__bad_interrupt>
      40:	0c 94 fb 05 	jmp	0xbf6	; 0xbf6 <__vector_16>
      44:	0c 94 9c 00 	jmp	0x138	; 0x138 <__bad_interrupt>
      48:	0c 94 a0 04 	jmp	0x940	; 0x940 <__vector_18>
      4c:	0c 94 d2 04 	jmp	0x9a4	; 0x9a4 <__vector_19>
      50:	0c 94 9c 00 	jmp	0x138	; 0x138 <__bad_interrupt>
      54:	0c 94 9c 00 	jmp	0x138	; 0x138 <__bad_interrupt>
      58:	0c 94 9c 00 	jmp	0x138	; 0x138 <__bad_interrupt>
      5c:	0c 94 9c 00 	jmp	0x138	; 0x138 <__bad_interrupt>
      60:	0c 94 9c 00 	jmp	0x138	; 0x138 <__bad_interrupt>
      64:	0c 94 9c 00 	jmp	0x138	; 0x138 <__bad_interrupt>
      68:	2b 12       	cpse	r2, r27
      6a:	2b 12       	cpse	r2, r27
      6c:	2b 12       	cpse	r2, r27
      6e:	6a 12       	cpse	r6, r26
      70:	55 12       	cpse	r5, r21
      72:	64 12       	cpse	r6, r20
      74:	2b 12       	cpse	r2, r27
      76:	2b 12       	cpse	r2, r27
      78:	6a 12       	cpse	r6, r26
      7a:	55 12       	cpse	r5, r21

0000007c <__trampolines_end>:
      7c:	0a 46       	sbci	r16, 0x6A	; 106
      7e:	6f 75       	andi	r22, 0x5F	; 95
      80:	6e 64       	ori	r22, 0x4E	; 78
      82:	20 4d       	sbci	r18, 0xD0	; 208
      84:	61 74       	andi	r22, 0x41	; 65
      86:	63 68       	ori	r22, 0x83	; 131
      88:	69 6e       	ori	r22, 0xE9	; 233
      8a:	67 20       	and	r6, r7
      8c:	43 6f       	ori	r20, 0xF3	; 243
      8e:	6c 6f       	ori	r22, 0xFC	; 252
      90:	72 00       	.word	0x0072	; ????

00000092 <digital_pin_to_timer_PGM>:
      92:	00 00 00 08 00 02 01 00 00 03 04 07 00 00 00 00     ................
      a2:	00 00 00 00                                         ....

000000a6 <digital_pin_to_bit_mask_PGM>:
      a6:	01 02 04 08 10 20 40 80 01 02 04 08 10 20 01 02     ..... @...... ..
      b6:	04 08 10 20                                         ... 

000000ba <digital_pin_to_port_PGM>:
      ba:	04 04 04 04 04 04 04 04 02 02 02 02 02 02 03 03     ................
      ca:	03 03 03 03                                         ....

000000ce <port_to_output_PGM>:
      ce:	00 00 00 00 25 00 28 00 2b 00                       ....%.(.+.

000000d8 <port_to_mode_PGM>:
      d8:	00 00 00 00 24 00 27 00 2a 00                       ....$.'.*.

000000e2 <__ctors_start>:
      e2:	54 03       	mulsu	r21, r20
      e4:	02 05       	cpc	r16, r2

000000e6 <__ctors_end>:
      e6:	5b 03       	fmul	r21, r19

000000e8 <__dtors_end>:
      e8:	11 24       	eor	r1, r1
      ea:	1f be       	out	0x3f, r1	; 63
      ec:	cf ef       	ldi	r28, 0xFF	; 255
      ee:	d8 e0       	ldi	r29, 0x08	; 8
      f0:	de bf       	out	0x3e, r29	; 62
      f2:	cd bf       	out	0x3d, r28	; 61

000000f4 <__do_copy_data>:
      f4:	11 e0       	ldi	r17, 0x01	; 1
      f6:	a0 e0       	ldi	r26, 0x00	; 0
      f8:	b1 e0       	ldi	r27, 0x01	; 1
      fa:	ee ef       	ldi	r30, 0xFE	; 254
      fc:	f1 e3       	ldi	r31, 0x31	; 49
      fe:	02 c0       	rjmp	.+4      	; 0x104 <__do_copy_data+0x10>
     100:	05 90       	lpm	r0, Z+
     102:	0d 92       	st	X+, r0
     104:	a4 35       	cpi	r26, 0x54	; 84
     106:	b1 07       	cpc	r27, r17
     108:	d9 f7       	brne	.-10     	; 0x100 <__do_copy_data+0xc>

0000010a <__do_clear_bss>:
     10a:	23 e0       	ldi	r18, 0x03	; 3
     10c:	a4 e5       	ldi	r26, 0x54	; 84
     10e:	b1 e0       	ldi	r27, 0x01	; 1
     110:	01 c0       	rjmp	.+2      	; 0x114 <.do_clear_bss_start>

00000112 <.do_clear_bss_loop>:
     112:	1d 92       	st	X+, r1

00000114 <.do_clear_bss_start>:
     114:	a0 36       	cpi	r26, 0x60	; 96
     116:	b2 07       	cpc	r27, r18
     118:	e1 f7       	brne	.-8      	; 0x112 <.do_clear_bss_loop>

0000011a <__do_global_ctors>:
     11a:	10 e0       	ldi	r17, 0x00	; 0
     11c:	c3 e7       	ldi	r28, 0x73	; 115
     11e:	d0 e0       	ldi	r29, 0x00	; 0
     120:	04 c0       	rjmp	.+8      	; 0x12a <__do_global_ctors+0x10>
     122:	21 97       	sbiw	r28, 0x01	; 1
     124:	fe 01       	movw	r30, r28
     126:	0e 94 8d 17 	call	0x2f1a	; 0x2f1a <__tablejump2__>
     12a:	c1 37       	cpi	r28, 0x71	; 113
     12c:	d1 07       	cpc	r29, r17
     12e:	c9 f7       	brne	.-14     	; 0x122 <__do_global_ctors+0x8>
     130:	0e 94 2f 05 	call	0xa5e	; 0xa5e <main>
     134:	0c 94 f2 18 	jmp	0x31e4	; 0x31e4 <__do_global_dtors>

00000138 <__bad_interrupt>:
     138:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

0000013c <_Z19TaskTemperatureReadPv>:
  }
}

// get Temperature reading from sensor
void TaskTemperatureRead(void *pvParameters)
{
     13c:	cf 93       	push	r28
     13e:	df 93       	push	r29
     140:	00 d0       	rcall	.+0      	; 0x142 <_Z19TaskTemperatureReadPv+0x6>
     142:	cd b7       	in	r28, 0x3d	; 61
     144:	de b7       	in	r29, 0x3e	; 62
  (void) pvParameters;
  
  TickType_t xLastWakeTime = xTaskGetTickCount();
     146:	0e 94 94 0c 	call	0x1928	; 0x1928 <xTaskGetTickCount>
     14a:	9a 83       	std	Y+2, r25	; 0x02
     14c:	89 83       	std	Y+1, r24	; 0x01
  for (;;) // A Task shall never return or exit.
  {
    // TODO: get temperature value, transmit to Wifi
    digitalWrite(LED_BUILTIN, LOW);
     14e:	60 e0       	ldi	r22, 0x00	; 0
     150:	8d e0       	ldi	r24, 0x0D	; 13
     152:	0e 94 e5 06 	call	0xdca	; 0xdca <digitalWrite>
    // check temperature every 15 min
    vTaskDelayUntil( &xLastWakeTime, 900000 / portTICK_PERIOD_MS );
     156:	6a eb       	ldi	r22, 0xBA	; 186
     158:	7b ed       	ldi	r23, 0xDB	; 219
     15a:	ce 01       	movw	r24, r28
     15c:	01 96       	adiw	r24, 0x01	; 1
     15e:	0e 94 b9 0d 	call	0x1b72	; 0x1b72 <vTaskDelayUntil>
     162:	f5 cf       	rjmp	.-22     	; 0x14e <_Z19TaskTemperatureReadPv+0x12>

00000164 <_Z10TaskPHReadPv>:
     164:	0e 94 9e 00 	call	0x13c	; 0x13c <_Z19TaskTemperatureReadPv>

00000168 <_Z8fromWifiv>:
  char action = 'a';

  switch(action)
  {
    case 'a':
      vTaskResume(xAmmonia);
     168:	80 91 5c 01 	lds	r24, 0x015C	; 0x80015c <xAmmonia>
     16c:	90 91 5d 01 	lds	r25, 0x015D	; 0x80015d <xAmmonia+0x1>
     170:	0c 94 17 0c 	jmp	0x182e	; 0x182e <vTaskResume>

00000174 <_Z9addColorsv>:
MD_TCS230  CS(S2, S3, OE);


// add possible color strip values to specific arrays
void addColors()
{
     174:	0f 93       	push	r16
     176:	1f 93       	push	r17
     178:	cf 93       	push	r28
     17a:	df 93       	push	r29
	int index = 0;
	Color c;
	c.ppm = 0.0;
	c.p = {0, 0, 0};
	Ammonia[index] = c;
     17c:	cb ef       	ldi	r28, 0xFB	; 251
     17e:	d1 e0       	ldi	r29, 0x01	; 1
     180:	18 82       	st	Y, r1
     182:	19 82       	std	Y+1, r1	; 0x01
     184:	1a 82       	std	Y+2, r1	; 0x02
     186:	1b 82       	std	Y+3, r1	; 0x03
     188:	1c 82       	std	Y+4, r1	; 0x04
     18a:	1d 82       	std	Y+5, r1	; 0x05
     18c:	1e 82       	std	Y+6, r1	; 0x06

	c.ppm = 0.0;
	c.p = {0, 0, 0};
	Nitrite[index] = c;
     18e:	aa ec       	ldi	r26, 0xCA	; 202
     190:	b1 e0       	ldi	r27, 0x01	; 1
     192:	1d 92       	st	X+, r1
     194:	1d 92       	st	X+, r1
     196:	1d 92       	st	X+, r1
     198:	1c 92       	st	X, r1
     19a:	13 97       	sbiw	r26, 0x03	; 3
     19c:	14 96       	adiw	r26, 0x04	; 4
     19e:	1c 92       	st	X, r1
     1a0:	14 97       	sbiw	r26, 0x04	; 4
     1a2:	15 96       	adiw	r26, 0x05	; 5
     1a4:	1c 92       	st	X, r1
     1a6:	15 97       	sbiw	r26, 0x05	; 5
     1a8:	16 96       	adiw	r26, 0x06	; 6
     1aa:	1c 92       	st	X, r1
     1ac:	16 97       	sbiw	r26, 0x06	; 6

	c.ppm = 0.0;
	c.p = {0, 0, 0};
	Nitrate[index] = c;
     1ae:	e9 e9       	ldi	r30, 0x99	; 153
     1b0:	f1 e0       	ldi	r31, 0x01	; 1
     1b2:	10 82       	st	Z, r1
     1b4:	11 82       	std	Z+1, r1	; 0x01
     1b6:	12 82       	std	Z+2, r1	; 0x02
     1b8:	13 82       	std	Z+3, r1	; 0x03
     1ba:	14 82       	std	Z+4, r1	; 0x04
     1bc:	15 82       	std	Z+5, r1	; 0x05
     1be:	16 82       	std	Z+6, r1	; 0x06

	++index;

	c.ppm = 0.25;
	c.p = {0, 0, 0};
	Ammonia[index] = c;
     1c0:	40 e0       	ldi	r20, 0x00	; 0
     1c2:	50 e0       	ldi	r21, 0x00	; 0
     1c4:	60 e8       	ldi	r22, 0x80	; 128
     1c6:	7e e3       	ldi	r23, 0x3E	; 62
     1c8:	4f 83       	std	Y+7, r20	; 0x07
     1ca:	58 87       	std	Y+8, r21	; 0x08
     1cc:	69 87       	std	Y+9, r22	; 0x09
     1ce:	7a 87       	std	Y+10, r23	; 0x0a
     1d0:	1b 86       	std	Y+11, r1	; 0x0b
     1d2:	1c 86       	std	Y+12, r1	; 0x0c
     1d4:	1d 86       	std	Y+13, r1	; 0x0d

	c.ppm = 0.15;
	c.p = {0, 0, 0};
	Nitrite[index] = c;
     1d6:	4a e9       	ldi	r20, 0x9A	; 154
     1d8:	59 e9       	ldi	r21, 0x99	; 153
     1da:	69 e1       	ldi	r22, 0x19	; 25
     1dc:	7e e3       	ldi	r23, 0x3E	; 62
     1de:	17 96       	adiw	r26, 0x07	; 7
     1e0:	4d 93       	st	X+, r20
     1e2:	5d 93       	st	X+, r21
     1e4:	6d 93       	st	X+, r22
     1e6:	7c 93       	st	X, r23
     1e8:	1a 97       	sbiw	r26, 0x0a	; 10
     1ea:	1b 96       	adiw	r26, 0x0b	; 11
     1ec:	1c 92       	st	X, r1
     1ee:	1b 97       	sbiw	r26, 0x0b	; 11
     1f0:	1c 96       	adiw	r26, 0x0c	; 12
     1f2:	1c 92       	st	X, r1
     1f4:	1c 97       	sbiw	r26, 0x0c	; 12
     1f6:	1d 96       	adiw	r26, 0x0d	; 13
     1f8:	1c 92       	st	X, r1
     1fa:	1d 97       	sbiw	r26, 0x0d	; 13

	c.ppm = 0.5;
	c.p = {0, 0, 0};
	Nitrate[index] = c;
     1fc:	40 e0       	ldi	r20, 0x00	; 0
     1fe:	50 e0       	ldi	r21, 0x00	; 0
     200:	60 e0       	ldi	r22, 0x00	; 0
     202:	7f e3       	ldi	r23, 0x3F	; 63
     204:	47 83       	std	Z+7, r20	; 0x07
     206:	50 87       	std	Z+8, r21	; 0x08
     208:	61 87       	std	Z+9, r22	; 0x09
     20a:	72 87       	std	Z+10, r23	; 0x0a
     20c:	13 86       	std	Z+11, r1	; 0x0b
     20e:	14 86       	std	Z+12, r1	; 0x0c
     210:	15 86       	std	Z+13, r1	; 0x0d

	++index;

	c.ppm = 0.5;
	c.p = {0, 0, 0};
	Ammonia[index] = c;
     212:	4e 87       	std	Y+14, r20	; 0x0e
     214:	5f 87       	std	Y+15, r21	; 0x0f
     216:	68 8b       	std	Y+16, r22	; 0x10
     218:	79 8b       	std	Y+17, r23	; 0x11
     21a:	1a 8a       	std	Y+18, r1	; 0x12
     21c:	1b 8a       	std	Y+19, r1	; 0x13
     21e:	1c 8a       	std	Y+20, r1	; 0x14

	c.ppm = 0.3;
	c.p = {0, 0, 0};
	Nitrite[index] = c;
     220:	4a e9       	ldi	r20, 0x9A	; 154
     222:	59 e9       	ldi	r21, 0x99	; 153
     224:	69 e9       	ldi	r22, 0x99	; 153
     226:	7e e3       	ldi	r23, 0x3E	; 62
     228:	1e 96       	adiw	r26, 0x0e	; 14
     22a:	4d 93       	st	X+, r20
     22c:	5d 93       	st	X+, r21
     22e:	6d 93       	st	X+, r22
     230:	7c 93       	st	X, r23
     232:	51 97       	sbiw	r26, 0x11	; 17
     234:	52 96       	adiw	r26, 0x12	; 18
     236:	1c 92       	st	X, r1
     238:	52 97       	sbiw	r26, 0x12	; 18
     23a:	53 96       	adiw	r26, 0x13	; 19
     23c:	1c 92       	st	X, r1
     23e:	53 97       	sbiw	r26, 0x13	; 19
     240:	54 96       	adiw	r26, 0x14	; 20
     242:	1c 92       	st	X, r1
     244:	54 97       	sbiw	r26, 0x14	; 20

	c.ppm = 2.0;
	c.p = {0, 0, 0};
	Nitrate[index] = c;
     246:	40 e0       	ldi	r20, 0x00	; 0
     248:	50 e0       	ldi	r21, 0x00	; 0
     24a:	60 e0       	ldi	r22, 0x00	; 0
     24c:	70 e4       	ldi	r23, 0x40	; 64
     24e:	46 87       	std	Z+14, r20	; 0x0e
     250:	57 87       	std	Z+15, r21	; 0x0f
     252:	60 8b       	std	Z+16, r22	; 0x10
     254:	71 8b       	std	Z+17, r23	; 0x11
     256:	12 8a       	std	Z+18, r1	; 0x12
     258:	13 8a       	std	Z+19, r1	; 0x13
     25a:	14 8a       	std	Z+20, r1	; 0x14

	++index;

	c.ppm = 3.0;
	c.p = {0, 0, 0};
	Ammonia[index] = c;
     25c:	00 e0       	ldi	r16, 0x00	; 0
     25e:	10 e0       	ldi	r17, 0x00	; 0
     260:	20 e4       	ldi	r18, 0x40	; 64
     262:	30 e4       	ldi	r19, 0x40	; 64
     264:	0d 8b       	std	Y+21, r16	; 0x15
     266:	1e 8b       	std	Y+22, r17	; 0x16
     268:	2f 8b       	std	Y+23, r18	; 0x17
     26a:	38 8f       	std	Y+24, r19	; 0x18
     26c:	19 8e       	std	Y+25, r1	; 0x19
     26e:	1a 8e       	std	Y+26, r1	; 0x1a
     270:	1b 8e       	std	Y+27, r1	; 0x1b

	c.ppm = 1.0;
	c.p = {0, 0, 0};
	Nitrite[index] = c;
     272:	40 e0       	ldi	r20, 0x00	; 0
     274:	50 e0       	ldi	r21, 0x00	; 0
     276:	60 e8       	ldi	r22, 0x80	; 128
     278:	7f e3       	ldi	r23, 0x3F	; 63
     27a:	55 96       	adiw	r26, 0x15	; 21
     27c:	4d 93       	st	X+, r20
     27e:	5d 93       	st	X+, r21
     280:	6d 93       	st	X+, r22
     282:	7c 93       	st	X, r23
     284:	58 97       	sbiw	r26, 0x18	; 24
     286:	59 96       	adiw	r26, 0x19	; 25
     288:	1c 92       	st	X, r1
     28a:	59 97       	sbiw	r26, 0x19	; 25
     28c:	5a 96       	adiw	r26, 0x1a	; 26
     28e:	1c 92       	st	X, r1
     290:	5a 97       	sbiw	r26, 0x1a	; 26
     292:	5b 96       	adiw	r26, 0x1b	; 27
     294:	1c 92       	st	X, r1
     296:	5b 97       	sbiw	r26, 0x1b	; 27

	c.ppm = 5.0;
	c.p = {0, 0, 0};
	Nitrate[index] = c;
     298:	40 e0       	ldi	r20, 0x00	; 0
     29a:	50 e0       	ldi	r21, 0x00	; 0
     29c:	60 ea       	ldi	r22, 0xA0	; 160
     29e:	70 e4       	ldi	r23, 0x40	; 64
     2a0:	45 8b       	std	Z+21, r20	; 0x15
     2a2:	56 8b       	std	Z+22, r21	; 0x16
     2a4:	67 8b       	std	Z+23, r22	; 0x17
     2a6:	70 8f       	std	Z+24, r23	; 0x18
     2a8:	11 8e       	std	Z+25, r1	; 0x19
     2aa:	12 8e       	std	Z+26, r1	; 0x1a
     2ac:	13 8e       	std	Z+27, r1	; 0x1b

	++index;

	c.ppm = 6.0;
	c.p = {0, 0, 0};
	Ammonia[index] = c;
     2ae:	40 e0       	ldi	r20, 0x00	; 0
     2b0:	50 e0       	ldi	r21, 0x00	; 0
     2b2:	60 ec       	ldi	r22, 0xC0	; 192
     2b4:	70 e4       	ldi	r23, 0x40	; 64
     2b6:	4c 8f       	std	Y+28, r20	; 0x1c
     2b8:	5d 8f       	std	Y+29, r21	; 0x1d
     2ba:	6e 8f       	std	Y+30, r22	; 0x1e
     2bc:	7f 8f       	std	Y+31, r23	; 0x1f
     2be:	18 a2       	std	Y+32, r1	; 0x20
     2c0:	19 a2       	std	Y+33, r1	; 0x21
     2c2:	1a a2       	std	Y+34, r1	; 0x22

	c.ppm = 1.5;
	c.p = {0, 0, 0};
	Nitrite[index] = c;
     2c4:	40 e0       	ldi	r20, 0x00	; 0
     2c6:	50 e0       	ldi	r21, 0x00	; 0
     2c8:	60 ec       	ldi	r22, 0xC0	; 192
     2ca:	7f e3       	ldi	r23, 0x3F	; 63
     2cc:	5c 96       	adiw	r26, 0x1c	; 28
     2ce:	4d 93       	st	X+, r20
     2d0:	5d 93       	st	X+, r21
     2d2:	6d 93       	st	X+, r22
     2d4:	7c 93       	st	X, r23
     2d6:	5f 97       	sbiw	r26, 0x1f	; 31
     2d8:	90 96       	adiw	r26, 0x20	; 32
     2da:	1c 92       	st	X, r1
     2dc:	90 97       	sbiw	r26, 0x20	; 32
     2de:	91 96       	adiw	r26, 0x21	; 33
     2e0:	1c 92       	st	X, r1
     2e2:	91 97       	sbiw	r26, 0x21	; 33
     2e4:	92 96       	adiw	r26, 0x22	; 34
     2e6:	1c 92       	st	X, r1
     2e8:	92 97       	sbiw	r26, 0x22	; 34

	c.ppm = 10.0;
	c.p = {0, 0, 0};
	Nitrate[index] = c;
     2ea:	40 e0       	ldi	r20, 0x00	; 0
     2ec:	50 e0       	ldi	r21, 0x00	; 0
     2ee:	60 e2       	ldi	r22, 0x20	; 32
     2f0:	71 e4       	ldi	r23, 0x41	; 65
     2f2:	44 8f       	std	Z+28, r20	; 0x1c
     2f4:	55 8f       	std	Z+29, r21	; 0x1d
     2f6:	66 8f       	std	Z+30, r22	; 0x1e
     2f8:	77 8f       	std	Z+31, r23	; 0x1f
     2fa:	10 a2       	std	Z+32, r1	; 0x20
     2fc:	11 a2       	std	Z+33, r1	; 0x21
     2fe:	12 a2       	std	Z+34, r1	; 0x22

	++index;

	c.ppm = 3.0;
	c.p = {0, 0, 0};
	Nitrite[index] = c;
     300:	93 96       	adiw	r26, 0x23	; 35
     302:	0d 93       	st	X+, r16
     304:	1d 93       	st	X+, r17
     306:	2d 93       	st	X+, r18
     308:	3c 93       	st	X, r19
     30a:	96 97       	sbiw	r26, 0x26	; 38
     30c:	97 96       	adiw	r26, 0x27	; 39
     30e:	1c 92       	st	X, r1
     310:	97 97       	sbiw	r26, 0x27	; 39
     312:	98 96       	adiw	r26, 0x28	; 40
     314:	1c 92       	st	X, r1
     316:	98 97       	sbiw	r26, 0x28	; 40
     318:	99 96       	adiw	r26, 0x29	; 41
     31a:	1c 92       	st	X, r1
     31c:	99 97       	sbiw	r26, 0x29	; 41

	c.ppm = 20.0;
	c.p = {0, 0, 0};
	Nitrate[index] = c;
     31e:	00 e0       	ldi	r16, 0x00	; 0
     320:	10 e0       	ldi	r17, 0x00	; 0
     322:	20 ea       	ldi	r18, 0xA0	; 160
     324:	31 e4       	ldi	r19, 0x41	; 65
     326:	03 a3       	std	Z+35, r16	; 0x23
     328:	14 a3       	std	Z+36, r17	; 0x24
     32a:	25 a3       	std	Z+37, r18	; 0x25
     32c:	36 a3       	std	Z+38, r19	; 0x26
     32e:	17 a2       	std	Z+39, r1	; 0x27
     330:	10 a6       	std	Z+40, r1	; 0x28
     332:	11 a6       	std	Z+41, r1	; 0x29

	++index;

	c.ppm = 10.0;
	c.p = {0, 0, 0};
	Nitrite[index] = c;
     334:	9a 96       	adiw	r26, 0x2a	; 42
     336:	4d 93       	st	X+, r20
     338:	5d 93       	st	X+, r21
     33a:	6d 93       	st	X+, r22
     33c:	7c 93       	st	X, r23
     33e:	9d 97       	sbiw	r26, 0x2d	; 45
     340:	9e 96       	adiw	r26, 0x2e	; 46
     342:	1c 92       	st	X, r1
     344:	9e 97       	sbiw	r26, 0x2e	; 46
     346:	9f 96       	adiw	r26, 0x2f	; 47
     348:	1c 92       	st	X, r1
     34a:	9f 97       	sbiw	r26, 0x2f	; 47
     34c:	d0 96       	adiw	r26, 0x30	; 48
     34e:	1c 92       	st	X, r1

	c.ppm = 50.0;
	c.p = {0, 0, 0};
	Nitrate[index] = c;
     350:	80 e0       	ldi	r24, 0x00	; 0
     352:	90 e0       	ldi	r25, 0x00	; 0
     354:	a8 e4       	ldi	r26, 0x48	; 72
     356:	b2 e4       	ldi	r27, 0x42	; 66
     358:	82 a7       	std	Z+42, r24	; 0x2a
     35a:	93 a7       	std	Z+43, r25	; 0x2b
     35c:	a4 a7       	std	Z+44, r26	; 0x2c
     35e:	b5 a7       	std	Z+45, r27	; 0x2d
     360:	16 a6       	std	Z+46, r1	; 0x2e
     362:	17 a6       	std	Z+47, r1	; 0x2f
     364:	10 aa       	std	Z+48, r1	; 0x30
}
     366:	df 91       	pop	r29
     368:	cf 91       	pop	r28
     36a:	1f 91       	pop	r17
     36c:	0f 91       	pop	r16
     36e:	08 95       	ret

00000370 <_Z9SameColorv>:
	uint8_t redExpected = rgb.value[TCS230_RGB_R];
	uint8_t greenExpected = rgb.value[TCS230_RGB_R];
	uint8_t blueExpected = rgb.value[TCS230_RGB_R];

	// check if RGB values are within range specified by tolerance
	if (c.p.R < (redExpected - TOLERANCE) or c.p.R > (redExpected + TOLERANCE))
     370:	20 91 93 01 	lds	r18, 0x0193	; 0x800193 <c+0x4>
     374:	30 e0       	ldi	r19, 0x00	; 0
     376:	80 91 96 01 	lds	r24, 0x0196	; 0x800196 <rgb>
     37a:	90 e0       	ldi	r25, 0x00	; 0
     37c:	ac 01       	movw	r20, r24
     37e:	43 52       	subi	r20, 0x23	; 35
     380:	51 09       	sbc	r21, r1
     382:	24 17       	cp	r18, r20
     384:	35 07       	cpc	r19, r21
     386:	f4 f0       	brlt	.+60     	; 0x3c4 <_Z9SameColorv+0x54>
     388:	83 96       	adiw	r24, 0x23	; 35
     38a:	82 17       	cp	r24, r18
     38c:	93 07       	cpc	r25, r19
     38e:	d4 f0       	brlt	.+52     	; 0x3c4 <_Z9SameColorv+0x54>
	return false;
	if (c.p.G < (greenExpected - TOLERANCE) or c.p.G > (greenExpected + TOLERANCE))
     390:	20 91 94 01 	lds	r18, 0x0194	; 0x800194 <c+0x5>
     394:	30 e0       	ldi	r19, 0x00	; 0
     396:	24 17       	cp	r18, r20
     398:	35 07       	cpc	r19, r21
     39a:	a4 f0       	brlt	.+40     	; 0x3c4 <_Z9SameColorv+0x54>
     39c:	82 17       	cp	r24, r18
     39e:	93 07       	cpc	r25, r19
     3a0:	8c f0       	brlt	.+34     	; 0x3c4 <_Z9SameColorv+0x54>
	return false;
	if (c.p.B < (blueExpected - TOLERANCE) or c.p.B > (blueExpected + TOLERANCE))
     3a2:	20 91 95 01 	lds	r18, 0x0195	; 0x800195 <c+0x6>
     3a6:	30 e0       	ldi	r19, 0x00	; 0
     3a8:	24 17       	cp	r18, r20
     3aa:	35 07       	cpc	r19, r21
     3ac:	5c f0       	brlt	.+22     	; 0x3c4 <_Z9SameColorv+0x54>
     3ae:	82 17       	cp	r24, r18
     3b0:	93 07       	cpc	r25, r19
     3b2:	44 f0       	brlt	.+16     	; 0x3c4 <_Z9SameColorv+0x54>
	return false;
	Serial.print(F("\nFound Matching Color"));
     3b4:	6c e7       	ldi	r22, 0x7C	; 124
     3b6:	70 e0       	ldi	r23, 0x00	; 0
     3b8:	8f e1       	ldi	r24, 0x1F	; 31
     3ba:	92 e0       	ldi	r25, 0x02	; 2
     3bc:	0e 94 68 05 	call	0xad0	; 0xad0 <_ZN5Print5printEPK19__FlashStringHelper>
     3c0:	81 e0       	ldi	r24, 0x01	; 1
     3c2:	08 95       	ret
	uint8_t greenExpected = rgb.value[TCS230_RGB_R];
	uint8_t blueExpected = rgb.value[TCS230_RGB_R];

	// check if RGB values are within range specified by tolerance
	if (c.p.R < (redExpected - TOLERANCE) or c.p.R > (redExpected + TOLERANCE))
	return false;
     3c4:	80 e0       	ldi	r24, 0x00	; 0
	return false;
	if (c.p.B < (blueExpected - TOLERANCE) or c.p.B > (blueExpected + TOLERANCE))
	return false;
	Serial.print(F("\nFound Matching Color"));
	return true;
}
     3c6:	08 95       	ret

000003c8 <_Z9FindMatchv>:

double FindMatch()
{
     3c8:	0f 93       	push	r16
     3ca:	1f 93       	push	r17
     3cc:	cf 93       	push	r28
     3ce:	df 93       	push	r29
	switch(typeToRead)
     3d0:	80 91 1e 02 	lds	r24, 0x021E	; 0x80021e <typeToRead>
     3d4:	81 30       	cpi	r24, 0x01	; 1
     3d6:	09 f4       	brne	.+2      	; 0x3da <_Z9FindMatchv+0x12>
     3d8:	48 c0       	rjmp	.+144    	; 0x46a <__LOCK_REGION_LENGTH__+0x6a>
     3da:	40 f0       	brcs	.+16     	; 0x3ec <_Z9FindMatchv+0x24>
     3dc:	82 30       	cpi	r24, 0x02	; 2
     3de:	09 f0       	breq	.+2      	; 0x3e2 <_Z9FindMatchv+0x1a>
     3e0:	6e c0       	rjmp	.+220    	; 0x4be <__LOCK_REGION_LENGTH__+0xbe>
     3e2:	0a ec       	ldi	r16, 0xCA	; 202
     3e4:	11 e0       	ldi	r17, 0x01	; 1
     3e6:	c6 e0       	ldi	r28, 0x06	; 6
     3e8:	d0 e0       	ldi	r29, 0x00	; 0
     3ea:	29 c0       	rjmp	.+82     	; 0x43e <__LOCK_REGION_LENGTH__+0x3e>
     3ec:	0b ef       	ldi	r16, 0xFB	; 251
     3ee:	11 e0       	ldi	r17, 0x01	; 1
     3f0:	c4 e0       	ldi	r28, 0x04	; 4
     3f2:	d0 e0       	ldi	r29, 0x00	; 0
		case AMMONIA:
		{
			// start at highest ammonia level - false positive better than false negative
			for(int i = MAX_AMMONIA_COLORS - 1; i >= 0; --i)
			{
				c = Ammonia[i];
     3f4:	87 e0       	ldi	r24, 0x07	; 7
     3f6:	f8 01       	movw	r30, r16
     3f8:	7c 96       	adiw	r30, 0x1c	; 28
     3fa:	af e8       	ldi	r26, 0x8F	; 143
     3fc:	b1 e0       	ldi	r27, 0x01	; 1
     3fe:	01 90       	ld	r0, Z+
     400:	0d 92       	st	X+, r0
     402:	8a 95       	dec	r24
     404:	e1 f7       	brne	.-8      	; 0x3fe <_Z9FindMatchv+0x36>
				if(SameColor())
     406:	0e 94 b8 01 	call	0x370	; 0x370 <_Z9SameColorv>
     40a:	88 23       	and	r24, r24
     40c:	49 f0       	breq	.+18     	; 0x420 <__LOCK_REGION_LENGTH__+0x20>
				return Ammonia[i].ppm;
     40e:	87 e0       	ldi	r24, 0x07	; 7
     410:	8c 9f       	mul	r24, r28
     412:	f0 01       	movw	r30, r0
     414:	8d 9f       	mul	r24, r29
     416:	f0 0d       	add	r31, r0
     418:	11 24       	eor	r1, r1
     41a:	e5 50       	subi	r30, 0x05	; 5
     41c:	fe 4f       	sbci	r31, 0xFE	; 254
     41e:	3e c0       	rjmp	.+124    	; 0x49c <__LOCK_REGION_LENGTH__+0x9c>
	switch(typeToRead)
	{
		case AMMONIA:
		{
			// start at highest ammonia level - false positive better than false negative
			for(int i = MAX_AMMONIA_COLORS - 1; i >= 0; --i)
     420:	21 97       	sbiw	r28, 0x01	; 1
     422:	07 50       	subi	r16, 0x07	; 7
     424:	11 09       	sbc	r17, r1
     426:	cf 3f       	cpi	r28, 0xFF	; 255
     428:	8f ef       	ldi	r24, 0xFF	; 255
     42a:	d8 07       	cpc	r29, r24
     42c:	19 f7       	brne	.-58     	; 0x3f4 <_Z9FindMatchv+0x2c>
     42e:	42 c0       	rjmp	.+132    	; 0x4b4 <__LOCK_REGION_LENGTH__+0xb4>
			break;
		}
		case NITRITE:
		{
			// start at highest nitrite level - false positive better than false negative
			for(int i = MAX_NITRITE_NITRATE_COLORS - 1; i >= 0; --i)
     430:	21 97       	sbiw	r28, 0x01	; 1
     432:	07 50       	subi	r16, 0x07	; 7
     434:	11 09       	sbc	r17, r1
     436:	cf 3f       	cpi	r28, 0xFF	; 255
     438:	8f ef       	ldi	r24, 0xFF	; 255
     43a:	d8 07       	cpc	r29, r24
     43c:	d9 f1       	breq	.+118    	; 0x4b4 <__LOCK_REGION_LENGTH__+0xb4>
			{
				c = Nitrite[i];
     43e:	87 e0       	ldi	r24, 0x07	; 7
     440:	f8 01       	movw	r30, r16
     442:	ba 96       	adiw	r30, 0x2a	; 42
     444:	af e8       	ldi	r26, 0x8F	; 143
     446:	b1 e0       	ldi	r27, 0x01	; 1
     448:	01 90       	ld	r0, Z+
     44a:	0d 92       	st	X+, r0
     44c:	8a 95       	dec	r24
     44e:	e1 f7       	brne	.-8      	; 0x448 <__LOCK_REGION_LENGTH__+0x48>
				if(SameColor())
     450:	0e 94 b8 01 	call	0x370	; 0x370 <_Z9SameColorv>
     454:	88 23       	and	r24, r24
     456:	61 f3       	breq	.-40     	; 0x430 <__LOCK_REGION_LENGTH__+0x30>
				return Nitrite[i].ppm;
     458:	87 e0       	ldi	r24, 0x07	; 7
     45a:	8c 9f       	mul	r24, r28
     45c:	f0 01       	movw	r30, r0
     45e:	8d 9f       	mul	r24, r29
     460:	f0 0d       	add	r31, r0
     462:	11 24       	eor	r1, r1
     464:	e6 53       	subi	r30, 0x36	; 54
     466:	fe 4f       	sbci	r31, 0xFE	; 254
     468:	19 c0       	rjmp	.+50     	; 0x49c <__LOCK_REGION_LENGTH__+0x9c>
     46a:	09 e9       	ldi	r16, 0x99	; 153
     46c:	11 e0       	ldi	r17, 0x01	; 1
	return true;
}

double FindMatch()
{
	switch(typeToRead)
     46e:	c6 e0       	ldi	r28, 0x06	; 6
     470:	d0 e0       	ldi	r29, 0x00	; 0
		case NITRATE:
		{
			// start at highest nitrate level - false positive better than false negative
			for(int i = MAX_NITRITE_NITRATE_COLORS - 1; i >= 0; --i)
			{
				c = Nitrate[i];
     472:	87 e0       	ldi	r24, 0x07	; 7
     474:	f8 01       	movw	r30, r16
     476:	ba 96       	adiw	r30, 0x2a	; 42
     478:	af e8       	ldi	r26, 0x8F	; 143
     47a:	b1 e0       	ldi	r27, 0x01	; 1
     47c:	01 90       	ld	r0, Z+
     47e:	0d 92       	st	X+, r0
     480:	8a 95       	dec	r24
     482:	e1 f7       	brne	.-8      	; 0x47c <__LOCK_REGION_LENGTH__+0x7c>
				if(SameColor())
     484:	0e 94 b8 01 	call	0x370	; 0x370 <_Z9SameColorv>
     488:	88 23       	and	r24, r24
     48a:	69 f0       	breq	.+26     	; 0x4a6 <__LOCK_REGION_LENGTH__+0xa6>
				return Nitrate[i].ppm;
     48c:	87 e0       	ldi	r24, 0x07	; 7
     48e:	8c 9f       	mul	r24, r28
     490:	f0 01       	movw	r30, r0
     492:	8d 9f       	mul	r24, r29
     494:	f0 0d       	add	r31, r0
     496:	11 24       	eor	r1, r1
     498:	e7 56       	subi	r30, 0x67	; 103
     49a:	fe 4f       	sbci	r31, 0xFE	; 254
     49c:	30 81       	ld	r19, Z
     49e:	21 81       	ldd	r18, Z+1	; 0x01
     4a0:	92 81       	ldd	r25, Z+2	; 0x02
     4a2:	83 81       	ldd	r24, Z+3	; 0x03
     4a4:	0b c0       	rjmp	.+22     	; 0x4bc <__LOCK_REGION_LENGTH__+0xbc>
			break;
		}
		case NITRATE:
		{
			// start at highest nitrate level - false positive better than false negative
			for(int i = MAX_NITRITE_NITRATE_COLORS - 1; i >= 0; --i)
     4a6:	21 97       	sbiw	r28, 0x01	; 1
     4a8:	07 50       	subi	r16, 0x07	; 7
     4aa:	11 09       	sbc	r17, r1
     4ac:	cf 3f       	cpi	r28, 0xFF	; 255
     4ae:	8f ef       	ldi	r24, 0xFF	; 255
     4b0:	d8 07       	cpc	r29, r24
     4b2:	f9 f6       	brne	.-66     	; 0x472 <__LOCK_REGION_LENGTH__+0x72>
			{
				c = Ammonia[i];
				if(SameColor())
				return Ammonia[i].ppm;
			}
			return -1;
     4b4:	30 e0       	ldi	r19, 0x00	; 0
     4b6:	20 e0       	ldi	r18, 0x00	; 0
     4b8:	90 e8       	ldi	r25, 0x80	; 128
     4ba:	8f eb       	ldi	r24, 0xBF	; 191
     4bc:	ac 01       	movw	r20, r24
			}
			return -1;
			break;
		}
	}
}
     4be:	63 2f       	mov	r22, r19
     4c0:	72 2f       	mov	r23, r18
     4c2:	85 2f       	mov	r24, r21
     4c4:	94 2f       	mov	r25, r20
     4c6:	df 91       	pop	r29
     4c8:	cf 91       	pop	r28
     4ca:	1f 91       	pop	r17
     4cc:	0f 91       	pop	r16
     4ce:	08 95       	ret

000004d0 <_Z9ScanColorv>:

double ScanColor()
{
	// Scan for color
	CS.read();
     4d0:	80 e6       	ldi	r24, 0x60	; 96
     4d2:	91 e0       	ldi	r25, 0x01	; 1
     4d4:	0e 94 fa 13 	call	0x27f4	; 0x27f4 <_ZN9MD_TCS2304readEv>
	while(CS.available()==0);  // wait for read to complete
     4d8:	80 e6       	ldi	r24, 0x60	; 96
     4da:	91 e0       	ldi	r25, 0x01	; 1
     4dc:	0e 94 04 14 	call	0x2808	; 0x2808 <_ZN9MD_TCS2309availableEv>
     4e0:	88 23       	and	r24, r24
     4e2:	d1 f3       	breq	.-12     	; 0x4d8 <_Z9ScanColorv+0x8>
	CS.getRGB(&rgb);
     4e4:	66 e9       	ldi	r22, 0x96	; 150
     4e6:	71 e0       	ldi	r23, 0x01	; 1
     4e8:	80 e6       	ldi	r24, 0x60	; 96
     4ea:	91 e0       	ldi	r25, 0x01	; 1
     4ec:	0e 94 30 13 	call	0x2660	; 0x2660 <_ZN9MD_TCS2306getRGBEP9colorData>
	// look for match
	return FindMatch();
     4f0:	0c 94 e4 01 	jmp	0x3c8	; 0x3c8 <_Z9FindMatchv>

000004f4 <_Z15TaskAmmoniaReadPv>:
// get Ammonia reading from color sensor
void TaskAmmoniaRead(void *pvParameters)
{
  (void) pvParameters;
  
  TickType_t xLastWakeTime = xTaskGetTickCount();
     4f4:	0e 94 94 0c 	call	0x1928	; 0x1928 <xTaskGetTickCount>
  pinMode(LED_BUILTIN, OUTPUT);
     4f8:	61 e0       	ldi	r22, 0x01	; 1
     4fa:	8d e0       	ldi	r24, 0x0D	; 13
     4fc:	0e 94 a9 06 	call	0xd52	; 0xd52 <pinMode>
  for (;;) // A Task shall never return or exit.
  {
    if ( xSemaphoreTake( xSerialSemaphoreColorSensor, ( TickType_t ) 1 ) == pdTRUE )
     500:	61 e0       	ldi	r22, 0x01	; 1
     502:	70 e0       	ldi	r23, 0x00	; 0
     504:	80 91 5e 01 	lds	r24, 0x015E	; 0x80015e <xSerialSemaphoreColorSensor>
     508:	90 91 5f 01 	lds	r25, 0x015F	; 0x80015f <xSerialSemaphoreColorSensor+0x1>
     50c:	0e 94 88 09 	call	0x1310	; 0x1310 <xQueueSemaphoreTake>
     510:	81 30       	cpi	r24, 0x01	; 1
     512:	99 f4       	brne	.+38     	; 0x53a <_Z15TaskAmmoniaReadPv+0x46>
    {
      // TODO: set indicator LED, analyze color value, transmit to Wifi
      typeToRead = AMMONIA;
     514:	10 92 1e 02 	sts	0x021E, r1	; 0x80021e <typeToRead>
      double value = ScanColor();
     518:	0e 94 68 02 	call	0x4d0	; 0x4d0 <_Z9ScanColorv>
      xSemaphoreGive( xSerialSemaphoreColorSensor );
     51c:	20 e0       	ldi	r18, 0x00	; 0
     51e:	40 e0       	ldi	r20, 0x00	; 0
     520:	50 e0       	ldi	r21, 0x00	; 0
     522:	60 e0       	ldi	r22, 0x00	; 0
     524:	70 e0       	ldi	r23, 0x00	; 0
     526:	80 91 5e 01 	lds	r24, 0x015E	; 0x80015e <xSerialSemaphoreColorSensor>
     52a:	90 91 5f 01 	lds	r25, 0x015F	; 0x80015f <xSerialSemaphoreColorSensor+0x1>
     52e:	0e 94 31 08 	call	0x1062	; 0x1062 <xQueueGenericSend>
      //suspend until triggered by next interrupt from Wifi module
      vTaskSuspend(NULL);
     532:	80 e0       	ldi	r24, 0x00	; 0
     534:	90 e0       	ldi	r25, 0x00	; 0
     536:	0e 94 64 0e 	call	0x1cc8	; 0x1cc8 <vTaskSuspend>
    }

    vTaskDelay(1); // 1 tick delay between reads for stability
     53a:	81 e0       	ldi	r24, 0x01	; 1
     53c:	90 e0       	ldi	r25, 0x00	; 0
     53e:	0e 94 f1 0d 	call	0x1be2	; 0x1be2 <vTaskDelay>
{
  (void) pvParameters;
  
  TickType_t xLastWakeTime = xTaskGetTickCount();
  pinMode(LED_BUILTIN, OUTPUT);
  for (;;) // A Task shall never return or exit.
     542:	de cf       	rjmp	.-68     	; 0x500 <_Z15TaskAmmoniaReadPv+0xc>

00000544 <_Z15TaskNitriteReadPv>:
// get Nitrite reading from color sensor
void TaskNitriteRead(void *pvParameters)
{
  (void) pvParameters;
  
  TickType_t xLastWakeTime = xTaskGetTickCount();
     544:	0e 94 94 0c 	call	0x1928	; 0x1928 <xTaskGetTickCount>
  pinMode(LED_BUILTIN, OUTPUT);
     548:	61 e0       	ldi	r22, 0x01	; 1
     54a:	8d e0       	ldi	r24, 0x0D	; 13
     54c:	0e 94 a9 06 	call	0xd52	; 0xd52 <pinMode>
  for (;;) // A Task shall never return or exit.
  {
    if ( xSemaphoreTake( xSerialSemaphoreColorSensor, ( TickType_t ) 1 ) == pdTRUE )
    {
      // TODO: set indicator LED, analyze color value, transmit to Wifi
      typeToRead = NITRITE;
     550:	c2 e0       	ldi	r28, 0x02	; 2
  
  TickType_t xLastWakeTime = xTaskGetTickCount();
  pinMode(LED_BUILTIN, OUTPUT);
  for (;;) // A Task shall never return or exit.
  {
    if ( xSemaphoreTake( xSerialSemaphoreColorSensor, ( TickType_t ) 1 ) == pdTRUE )
     552:	61 e0       	ldi	r22, 0x01	; 1
     554:	70 e0       	ldi	r23, 0x00	; 0
     556:	80 91 5e 01 	lds	r24, 0x015E	; 0x80015e <xSerialSemaphoreColorSensor>
     55a:	90 91 5f 01 	lds	r25, 0x015F	; 0x80015f <xSerialSemaphoreColorSensor+0x1>
     55e:	0e 94 88 09 	call	0x1310	; 0x1310 <xQueueSemaphoreTake>
     562:	81 30       	cpi	r24, 0x01	; 1
     564:	99 f4       	brne	.+38     	; 0x58c <_Z15TaskNitriteReadPv+0x48>
    {
      // TODO: set indicator LED, analyze color value, transmit to Wifi
      typeToRead = NITRITE;
     566:	c0 93 1e 02 	sts	0x021E, r28	; 0x80021e <typeToRead>
      double value = ScanColor();
     56a:	0e 94 68 02 	call	0x4d0	; 0x4d0 <_Z9ScanColorv>
      xSemaphoreGive( xSerialSemaphoreColorSensor );
     56e:	20 e0       	ldi	r18, 0x00	; 0
     570:	40 e0       	ldi	r20, 0x00	; 0
     572:	50 e0       	ldi	r21, 0x00	; 0
     574:	60 e0       	ldi	r22, 0x00	; 0
     576:	70 e0       	ldi	r23, 0x00	; 0
     578:	80 91 5e 01 	lds	r24, 0x015E	; 0x80015e <xSerialSemaphoreColorSensor>
     57c:	90 91 5f 01 	lds	r25, 0x015F	; 0x80015f <xSerialSemaphoreColorSensor+0x1>
     580:	0e 94 31 08 	call	0x1062	; 0x1062 <xQueueGenericSend>
      //suspend until triggered by next interrupt from Wifi module
      vTaskSuspend(NULL);
     584:	80 e0       	ldi	r24, 0x00	; 0
     586:	90 e0       	ldi	r25, 0x00	; 0
     588:	0e 94 64 0e 	call	0x1cc8	; 0x1cc8 <vTaskSuspend>
    }

    vTaskDelay(1); // 1 tick delay between reads for stability
     58c:	81 e0       	ldi	r24, 0x01	; 1
     58e:	90 e0       	ldi	r25, 0x00	; 0
     590:	0e 94 f1 0d 	call	0x1be2	; 0x1be2 <vTaskDelay>
{
  (void) pvParameters;
  
  TickType_t xLastWakeTime = xTaskGetTickCount();
  pinMode(LED_BUILTIN, OUTPUT);
  for (;;) // A Task shall never return or exit.
     594:	de cf       	rjmp	.-68     	; 0x552 <_Z15TaskNitriteReadPv+0xe>

00000596 <_Z15TaskNitrateReadPv>:
// get Nitrate reading from color sensor
void TaskNitrateRead(void *pvParameters)
{
  (void) pvParameters;
  
  TickType_t xLastWakeTime = xTaskGetTickCount();
     596:	0e 94 94 0c 	call	0x1928	; 0x1928 <xTaskGetTickCount>
  pinMode(LED_BUILTIN, OUTPUT);
     59a:	61 e0       	ldi	r22, 0x01	; 1
     59c:	8d e0       	ldi	r24, 0x0D	; 13
     59e:	0e 94 a9 06 	call	0xd52	; 0xd52 <pinMode>
  for (;;) // A Task shall never return or exit.
  {
    if ( xSemaphoreTake( xSerialSemaphoreColorSensor, ( TickType_t ) 1 ) == pdTRUE )
     5a2:	61 e0       	ldi	r22, 0x01	; 1
     5a4:	70 e0       	ldi	r23, 0x00	; 0
     5a6:	80 91 5e 01 	lds	r24, 0x015E	; 0x80015e <xSerialSemaphoreColorSensor>
     5aa:	90 91 5f 01 	lds	r25, 0x015F	; 0x80015f <xSerialSemaphoreColorSensor+0x1>
     5ae:	0e 94 88 09 	call	0x1310	; 0x1310 <xQueueSemaphoreTake>
     5b2:	81 30       	cpi	r24, 0x01	; 1
     5b4:	99 f4       	brne	.+38     	; 0x5dc <_Z15TaskNitrateReadPv+0x46>
    {
      // TODO: set indicator LED, analyze color value, transmit to Wifi
      typeToRead = NITRATE;
     5b6:	80 93 1e 02 	sts	0x021E, r24	; 0x80021e <typeToRead>
      double value = ScanColor();
     5ba:	0e 94 68 02 	call	0x4d0	; 0x4d0 <_Z9ScanColorv>
      xSemaphoreGive( xSerialSemaphoreColorSensor );
     5be:	20 e0       	ldi	r18, 0x00	; 0
     5c0:	40 e0       	ldi	r20, 0x00	; 0
     5c2:	50 e0       	ldi	r21, 0x00	; 0
     5c4:	60 e0       	ldi	r22, 0x00	; 0
     5c6:	70 e0       	ldi	r23, 0x00	; 0
     5c8:	80 91 5e 01 	lds	r24, 0x015E	; 0x80015e <xSerialSemaphoreColorSensor>
     5cc:	90 91 5f 01 	lds	r25, 0x015F	; 0x80015f <xSerialSemaphoreColorSensor+0x1>
     5d0:	0e 94 31 08 	call	0x1062	; 0x1062 <xQueueGenericSend>
      //suspend until triggered by next interrupt from Wifi module
      vTaskSuspend(NULL);
     5d4:	80 e0       	ldi	r24, 0x00	; 0
     5d6:	90 e0       	ldi	r25, 0x00	; 0
     5d8:	0e 94 64 0e 	call	0x1cc8	; 0x1cc8 <vTaskSuspend>
    }

    vTaskDelay(1); // 1 tick delay between reads for stability
     5dc:	81 e0       	ldi	r24, 0x01	; 1
     5de:	90 e0       	ldi	r25, 0x00	; 0
     5e0:	0e 94 f1 0d 	call	0x1be2	; 0x1be2 <vTaskDelay>
{
  (void) pvParameters;
  
  TickType_t xLastWakeTime = xTaskGetTickCount();
  pinMode(LED_BUILTIN, OUTPUT);
  for (;;) // A Task shall never return or exit.
     5e4:	de cf       	rjmp	.-68     	; 0x5a2 <_Z15TaskNitrateReadPv+0xc>

000005e6 <setup>:
TaskHandle_t xNitrate;
TaskHandle_t xPH;
TaskHandle_t xTemperature;

// the setup function runs once when you press reset or power the board
void setup() {
     5e6:	ef 92       	push	r14
     5e8:	ff 92       	push	r15
     5ea:	0f 93       	push	r16
  public:
    inline HardwareSerial(
      volatile uint8_t *ubrrh, volatile uint8_t *ubrrl,
      volatile uint8_t *ucsra, volatile uint8_t *ucsrb,
      volatile uint8_t *ucsrc, volatile uint8_t *udr);
    void begin(unsigned long baud) { begin(baud, SERIAL_8N1); }
     5ec:	26 e0       	ldi	r18, 0x06	; 6
     5ee:	40 e8       	ldi	r20, 0x80	; 128
     5f0:	55 e2       	ldi	r21, 0x25	; 37
     5f2:	60 e0       	ldi	r22, 0x00	; 0
     5f4:	70 e0       	ldi	r23, 0x00	; 0
     5f6:	8f e1       	ldi	r24, 0x1F	; 31
     5f8:	92 e0       	ldi	r25, 0x02	; 2
     5fa:	0e 94 3b 04 	call	0x876	; 0x876 <_ZN14HardwareSerial5beginEmh>
  while (!Serial) {
    ; // wait for serial port to connect. Needed for native USB, on LEONARDO, MICRO, YUN, and other 32u4 based boards.
  }

  // load test strip color data
  addColors();
     5fe:	0e 94 ba 00 	call	0x174	; 0x174 <_Z9addColorsv>

  // TODO: Not sure how Wifi module indicates that it is getting data - replace that with the interrupt from pin2 
  attachInterrupt(digitalPinToInterrupt(2), fromWifi, RISING);
     602:	43 e0       	ldi	r20, 0x03	; 3
     604:	50 e0       	ldi	r21, 0x00	; 0
     606:	64 eb       	ldi	r22, 0xB4	; 180
     608:	70 e0       	ldi	r23, 0x00	; 0
     60a:	80 e0       	ldi	r24, 0x00	; 0
     60c:	0e 94 8d 05 	call	0xb1a	; 0xb1a <attachInterrupt>
    TaskAmmoniaRead
    ,  (const portCHAR *)"Ammonia"
    ,  128
    ,  NULL
    ,  2
    ,  &xAmmonia );
     610:	8c e5       	ldi	r24, 0x5C	; 92
     612:	e8 2e       	mov	r14, r24
     614:	81 e0       	ldi	r24, 0x01	; 1
     616:	f8 2e       	mov	r15, r24
     618:	02 e0       	ldi	r16, 0x02	; 2
     61a:	20 e0       	ldi	r18, 0x00	; 0
     61c:	30 e0       	ldi	r19, 0x00	; 0
     61e:	40 e8       	ldi	r20, 0x80	; 128
     620:	50 e0       	ldi	r21, 0x00	; 0
     622:	6a e0       	ldi	r22, 0x0A	; 10
     624:	71 e0       	ldi	r23, 0x01	; 1
     626:	8a e7       	ldi	r24, 0x7A	; 122
     628:	92 e0       	ldi	r25, 0x02	; 2
     62a:	0e 94 0b 0b 	call	0x1616	; 0x1616 <xTaskCreate>
    TaskNitriteRead
    ,  (const portCHAR *) "Nitrite"
    ,  128  // Stack size
    ,  NULL
    ,  2  // Priority
    ,  &xNitrite );
     62e:	9a e5       	ldi	r25, 0x5A	; 90
     630:	e9 2e       	mov	r14, r25
     632:	91 e0       	ldi	r25, 0x01	; 1
     634:	f9 2e       	mov	r15, r25
     636:	20 e0       	ldi	r18, 0x00	; 0
     638:	30 e0       	ldi	r19, 0x00	; 0
     63a:	40 e8       	ldi	r20, 0x80	; 128
     63c:	50 e0       	ldi	r21, 0x00	; 0
     63e:	62 e1       	ldi	r22, 0x12	; 18
     640:	71 e0       	ldi	r23, 0x01	; 1
     642:	82 ea       	ldi	r24, 0xA2	; 162
     644:	92 e0       	ldi	r25, 0x02	; 2
     646:	0e 94 0b 0b 	call	0x1616	; 0x1616 <xTaskCreate>
    TaskNitrateRead
    ,  (const portCHAR *) "Nitrate"
    ,  128  // Stack size
    ,  NULL
    ,  2  // Priority
    ,  &xNitrate );
     64a:	28 e5       	ldi	r18, 0x58	; 88
     64c:	e2 2e       	mov	r14, r18
     64e:	21 e0       	ldi	r18, 0x01	; 1
     650:	f2 2e       	mov	r15, r18
     652:	20 e0       	ldi	r18, 0x00	; 0
     654:	30 e0       	ldi	r19, 0x00	; 0
     656:	40 e8       	ldi	r20, 0x80	; 128
     658:	50 e0       	ldi	r21, 0x00	; 0
     65a:	6a e1       	ldi	r22, 0x1A	; 26
     65c:	71 e0       	ldi	r23, 0x01	; 1
     65e:	8b ec       	ldi	r24, 0xCB	; 203
     660:	92 e0       	ldi	r25, 0x02	; 2
     662:	0e 94 0b 0b 	call	0x1616	; 0x1616 <xTaskCreate>
    TaskPHRead
    ,  (const portCHAR *) "pH"
    ,  128  // Stack size
    ,  NULL
    ,  2  // Priority
    ,  &xPH );
     666:	36 e5       	ldi	r19, 0x56	; 86
     668:	e3 2e       	mov	r14, r19
     66a:	31 e0       	ldi	r19, 0x01	; 1
     66c:	f3 2e       	mov	r15, r19
     66e:	20 e0       	ldi	r18, 0x00	; 0
     670:	30 e0       	ldi	r19, 0x00	; 0
     672:	40 e8       	ldi	r20, 0x80	; 128
     674:	50 e0       	ldi	r21, 0x00	; 0
     676:	62 e2       	ldi	r22, 0x22	; 34
     678:	71 e0       	ldi	r23, 0x01	; 1
     67a:	82 eb       	ldi	r24, 0xB2	; 178
     67c:	90 e0       	ldi	r25, 0x00	; 0
     67e:	0e 94 0b 0b 	call	0x1616	; 0x1616 <xTaskCreate>
    TaskTemperatureRead
    ,  (const portCHAR *) "Temperature"
    ,  128  // Stack size
    ,  NULL
    ,  2  // Priority
    ,  &xTemperature );
     682:	44 e5       	ldi	r20, 0x54	; 84
     684:	e4 2e       	mov	r14, r20
     686:	41 e0       	ldi	r20, 0x01	; 1
     688:	f4 2e       	mov	r15, r20
     68a:	20 e0       	ldi	r18, 0x00	; 0
     68c:	30 e0       	ldi	r19, 0x00	; 0
     68e:	40 e8       	ldi	r20, 0x80	; 128
     690:	50 e0       	ldi	r21, 0x00	; 0
     692:	65 e2       	ldi	r22, 0x25	; 37
     694:	71 e0       	ldi	r23, 0x01	; 1
     696:	8e e9       	ldi	r24, 0x9E	; 158
     698:	90 e0       	ldi	r25, 0x00	; 0
     69a:	0e 94 0b 0b 	call	0x1616	; 0x1616 <xTaskCreate>

  // Now the task scheduler, which takes over control of scheduling individual tasks, is automatically started.
}
     69e:	0f 91       	pop	r16
     6a0:	ff 90       	pop	r15
     6a2:	ef 90       	pop	r14
     6a4:	08 95       	ret

000006a6 <loop>:

void loop()
{
     6a6:	08 95       	ret

000006a8 <_GLOBAL__sub_I_typeToRead>:


colorData rgb;
Color c;

MD_TCS230  CS(S2, S3, OE);
     6a8:	28 e0       	ldi	r18, 0x08	; 8
     6aa:	4d e0       	ldi	r20, 0x0D	; 13
     6ac:	6c e0       	ldi	r22, 0x0C	; 12
     6ae:	80 e6       	ldi	r24, 0x60	; 96
     6b0:	91 e0       	ldi	r25, 0x01	; 1
     6b2:	0c 94 be 12 	jmp	0x257c	; 0x257c <_ZN9MD_TCS230C1Ehhh>

000006b6 <_GLOBAL__sub_D_typeToRead>:
     6b6:	80 e6       	ldi	r24, 0x60	; 96
     6b8:	91 e0       	ldi	r25, 0x01	; 1
     6ba:	0c 94 d2 12 	jmp	0x25a4	; 0x25a4 <_ZN9MD_TCS230D1Ev>

000006be <_ZN14HardwareSerial9availableEv>:
  // clear any received data
  _rx_buffer_head = _rx_buffer_tail;
}

int HardwareSerial::available(void)
{
     6be:	fc 01       	movw	r30, r24
  return ((unsigned int)(SERIAL_RX_BUFFER_SIZE + _rx_buffer_head - _rx_buffer_tail)) % SERIAL_RX_BUFFER_SIZE;
     6c0:	91 8d       	ldd	r25, Z+25	; 0x19
     6c2:	22 8d       	ldd	r18, Z+26	; 0x1a
     6c4:	89 2f       	mov	r24, r25
     6c6:	90 e0       	ldi	r25, 0x00	; 0
     6c8:	80 5c       	subi	r24, 0xC0	; 192
     6ca:	9f 4f       	sbci	r25, 0xFF	; 255
     6cc:	82 1b       	sub	r24, r18
     6ce:	91 09       	sbc	r25, r1
}
     6d0:	8f 73       	andi	r24, 0x3F	; 63
     6d2:	99 27       	eor	r25, r25
     6d4:	08 95       	ret

000006d6 <_ZN14HardwareSerial4peekEv>:

int HardwareSerial::peek(void)
{
     6d6:	fc 01       	movw	r30, r24
  if (_rx_buffer_head == _rx_buffer_tail) {
     6d8:	91 8d       	ldd	r25, Z+25	; 0x19
     6da:	82 8d       	ldd	r24, Z+26	; 0x1a
     6dc:	98 17       	cp	r25, r24
     6de:	31 f0       	breq	.+12     	; 0x6ec <_ZN14HardwareSerial4peekEv+0x16>
    return -1;
  } else {
    return _rx_buffer[_rx_buffer_tail];
     6e0:	82 8d       	ldd	r24, Z+26	; 0x1a
     6e2:	e8 0f       	add	r30, r24
     6e4:	f1 1d       	adc	r31, r1
     6e6:	85 8d       	ldd	r24, Z+29	; 0x1d
     6e8:	90 e0       	ldi	r25, 0x00	; 0
     6ea:	08 95       	ret
}

int HardwareSerial::peek(void)
{
  if (_rx_buffer_head == _rx_buffer_tail) {
    return -1;
     6ec:	8f ef       	ldi	r24, 0xFF	; 255
     6ee:	9f ef       	ldi	r25, 0xFF	; 255
  } else {
    return _rx_buffer[_rx_buffer_tail];
  }
}
     6f0:	08 95       	ret

000006f2 <_ZN14HardwareSerial4readEv>:

int HardwareSerial::read(void)
{
     6f2:	fc 01       	movw	r30, r24
  // if the head isn't ahead of the tail, we don't have any characters
  if (_rx_buffer_head == _rx_buffer_tail) {
     6f4:	91 8d       	ldd	r25, Z+25	; 0x19
     6f6:	82 8d       	ldd	r24, Z+26	; 0x1a
     6f8:	98 17       	cp	r25, r24
     6fa:	61 f0       	breq	.+24     	; 0x714 <_ZN14HardwareSerial4readEv+0x22>
    return -1;
  } else {
    unsigned char c = _rx_buffer[_rx_buffer_tail];
     6fc:	82 8d       	ldd	r24, Z+26	; 0x1a
     6fe:	df 01       	movw	r26, r30
     700:	a8 0f       	add	r26, r24
     702:	b1 1d       	adc	r27, r1
     704:	5d 96       	adiw	r26, 0x1d	; 29
     706:	8c 91       	ld	r24, X
    _rx_buffer_tail = (rx_buffer_index_t)(_rx_buffer_tail + 1) % SERIAL_RX_BUFFER_SIZE;
     708:	92 8d       	ldd	r25, Z+26	; 0x1a
     70a:	9f 5f       	subi	r25, 0xFF	; 255
     70c:	9f 73       	andi	r25, 0x3F	; 63
     70e:	92 8f       	std	Z+26, r25	; 0x1a
    return c;
     710:	90 e0       	ldi	r25, 0x00	; 0
     712:	08 95       	ret

int HardwareSerial::read(void)
{
  // if the head isn't ahead of the tail, we don't have any characters
  if (_rx_buffer_head == _rx_buffer_tail) {
    return -1;
     714:	8f ef       	ldi	r24, 0xFF	; 255
     716:	9f ef       	ldi	r25, 0xFF	; 255
  } else {
    unsigned char c = _rx_buffer[_rx_buffer_tail];
    _rx_buffer_tail = (rx_buffer_index_t)(_rx_buffer_tail + 1) % SERIAL_RX_BUFFER_SIZE;
    return c;
  }
}
     718:	08 95       	ret

0000071a <_ZN14HardwareSerial17availableForWriteEv>:
{
  tx_buffer_index_t head;
  tx_buffer_index_t tail;

  TX_BUFFER_ATOMIC {
    head = _tx_buffer_head;
     71a:	fc 01       	movw	r30, r24
     71c:	53 8d       	ldd	r21, Z+27	; 0x1b
    tail = _tx_buffer_tail;
     71e:	44 8d       	ldd	r20, Z+28	; 0x1c
     720:	25 2f       	mov	r18, r21
     722:	30 e0       	ldi	r19, 0x00	; 0
     724:	84 2f       	mov	r24, r20
     726:	90 e0       	ldi	r25, 0x00	; 0
  }
  if (head >= tail) return SERIAL_TX_BUFFER_SIZE - 1 - head + tail;
     728:	82 1b       	sub	r24, r18
     72a:	93 0b       	sbc	r25, r19
     72c:	54 17       	cp	r21, r20
     72e:	10 f0       	brcs	.+4      	; 0x734 <_ZN14HardwareSerial17availableForWriteEv+0x1a>
     730:	cf 96       	adiw	r24, 0x3f	; 63
     732:	08 95       	ret
  return tail - head - 1;
     734:	01 97       	sbiw	r24, 0x01	; 1
}
     736:	08 95       	ret

00000738 <_Z14serialEventRunv>:
#endif

void serialEventRun(void)
{
#if defined(HAVE_HWSERIAL0)
  if (Serial0_available && serialEvent && Serial0_available()) serialEvent();
     738:	88 ef       	ldi	r24, 0xF8	; 248
     73a:	94 e0       	ldi	r25, 0x04	; 4
     73c:	89 2b       	or	r24, r25
     73e:	49 f0       	breq	.+18     	; 0x752 <_Z14serialEventRunv+0x1a>
     740:	80 e0       	ldi	r24, 0x00	; 0
     742:	90 e0       	ldi	r25, 0x00	; 0
     744:	89 2b       	or	r24, r25
     746:	29 f0       	breq	.+10     	; 0x752 <_Z14serialEventRunv+0x1a>
     748:	0e 94 f8 04 	call	0x9f0	; 0x9f0 <_Z17Serial0_availablev>
     74c:	81 11       	cpse	r24, r1
     74e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>
     752:	08 95       	ret

00000754 <_ZN14HardwareSerial17_tx_udr_empty_irqEv>:
#endif

// Actual interrupt handlers //////////////////////////////////////////////////////////////

void HardwareSerial::_tx_udr_empty_irq(void)
{
     754:	fc 01       	movw	r30, r24
  // If interrupts are enabled, there must be more data in the output
  // buffer. Send the next byte
  unsigned char c = _tx_buffer[_tx_buffer_tail];
     756:	84 8d       	ldd	r24, Z+28	; 0x1c
     758:	df 01       	movw	r26, r30
     75a:	a8 0f       	add	r26, r24
     75c:	b1 1d       	adc	r27, r1
     75e:	a3 5a       	subi	r26, 0xA3	; 163
     760:	bf 4f       	sbci	r27, 0xFF	; 255
     762:	2c 91       	ld	r18, X
  _tx_buffer_tail = (_tx_buffer_tail + 1) % SERIAL_TX_BUFFER_SIZE;
     764:	84 8d       	ldd	r24, Z+28	; 0x1c
     766:	90 e0       	ldi	r25, 0x00	; 0
     768:	01 96       	adiw	r24, 0x01	; 1
     76a:	8f 73       	andi	r24, 0x3F	; 63
     76c:	99 27       	eor	r25, r25
     76e:	84 8f       	std	Z+28, r24	; 0x1c

  *_udr = c;
     770:	a6 89       	ldd	r26, Z+22	; 0x16
     772:	b7 89       	ldd	r27, Z+23	; 0x17
     774:	2c 93       	st	X, r18
  // location". This makes sure flush() won't return until the bytes
  // actually got written. Other r/w bits are preserved, and zeroes
  // written to the rest.

#ifdef MPCM0
  *_ucsra = ((*_ucsra) & ((1 << U2X0) | (1 << MPCM0))) | (1 << TXC0);
     776:	a0 89       	ldd	r26, Z+16	; 0x10
     778:	b1 89       	ldd	r27, Z+17	; 0x11
     77a:	8c 91       	ld	r24, X
     77c:	83 70       	andi	r24, 0x03	; 3
     77e:	80 64       	ori	r24, 0x40	; 64
     780:	8c 93       	st	X, r24
#else
  *_ucsra = ((*_ucsra) & ((1 << U2X0) | (1 << TXC0)));
#endif

  if (_tx_buffer_head == _tx_buffer_tail) {
     782:	93 8d       	ldd	r25, Z+27	; 0x1b
     784:	84 8d       	ldd	r24, Z+28	; 0x1c
     786:	98 13       	cpse	r25, r24
     788:	06 c0       	rjmp	.+12     	; 0x796 <_ZN14HardwareSerial17_tx_udr_empty_irqEv+0x42>
    // Buffer empty, so disable interrupts
    cbi(*_ucsrb, UDRIE0);
     78a:	02 88       	ldd	r0, Z+18	; 0x12
     78c:	f3 89       	ldd	r31, Z+19	; 0x13
     78e:	e0 2d       	mov	r30, r0
     790:	80 81       	ld	r24, Z
     792:	8f 7d       	andi	r24, 0xDF	; 223
     794:	80 83       	st	Z, r24
     796:	08 95       	ret

00000798 <_ZN14HardwareSerial5writeEh>:
  // If we get here, nothing is queued anymore (DRIE is disabled) and
  // the hardware finished tranmission (TXC is set).
}

size_t HardwareSerial::write(uint8_t c)
{
     798:	ef 92       	push	r14
     79a:	ff 92       	push	r15
     79c:	0f 93       	push	r16
     79e:	1f 93       	push	r17
     7a0:	cf 93       	push	r28
     7a2:	df 93       	push	r29
     7a4:	ec 01       	movw	r28, r24
  _written = true;
     7a6:	81 e0       	ldi	r24, 0x01	; 1
     7a8:	88 8f       	std	Y+24, r24	; 0x18
  // If the buffer and the data register is empty, just write the byte
  // to the data register and be done. This shortcut helps
  // significantly improve the effective datarate at high (>
  // 500kbit/s) bitrates, where interrupt overhead becomes a slowdown.
  if (_tx_buffer_head == _tx_buffer_tail && bit_is_set(*_ucsra, UDRE0)) {
     7aa:	9b 8d       	ldd	r25, Y+27	; 0x1b
     7ac:	8c 8d       	ldd	r24, Y+28	; 0x1c
     7ae:	98 13       	cpse	r25, r24
     7b0:	05 c0       	rjmp	.+10     	; 0x7bc <_ZN14HardwareSerial5writeEh+0x24>
     7b2:	e8 89       	ldd	r30, Y+16	; 0x10
     7b4:	f9 89       	ldd	r31, Y+17	; 0x11
     7b6:	80 81       	ld	r24, Z
     7b8:	85 fd       	sbrc	r24, 5
     7ba:	26 c0       	rjmp	.+76     	; 0x808 <_ZN14HardwareSerial5writeEh+0x70>
     7bc:	f6 2e       	mov	r15, r22
      *_ucsra = ((*_ucsra) & ((1 << U2X0) | (1 << TXC0)));
#endif
    }
    return 1;
  }
  tx_buffer_index_t i = (_tx_buffer_head + 1) % SERIAL_TX_BUFFER_SIZE;
     7be:	0b 8d       	ldd	r16, Y+27	; 0x1b
     7c0:	10 e0       	ldi	r17, 0x00	; 0
     7c2:	0f 5f       	subi	r16, 0xFF	; 255
     7c4:	1f 4f       	sbci	r17, 0xFF	; 255
     7c6:	0f 73       	andi	r16, 0x3F	; 63
     7c8:	11 27       	eor	r17, r17
     7ca:	e0 2e       	mov	r14, r16
	
  // If the output buffer is full, there's nothing for it other than to 
  // wait for the interrupt handler to empty it a bit
  while (i == _tx_buffer_tail) {
     7cc:	8c 8d       	ldd	r24, Y+28	; 0x1c
     7ce:	e8 12       	cpse	r14, r24
     7d0:	0c c0       	rjmp	.+24     	; 0x7ea <_ZN14HardwareSerial5writeEh+0x52>
    if (bit_is_clear(SREG, SREG_I)) {
     7d2:	0f b6       	in	r0, 0x3f	; 63
     7d4:	07 fc       	sbrc	r0, 7
     7d6:	fa cf       	rjmp	.-12     	; 0x7cc <_ZN14HardwareSerial5writeEh+0x34>
      // Interrupts are disabled, so we'll have to poll the data
      // register empty flag ourselves. If it is set, pretend an
      // interrupt has happened and call the handler to free up
      // space for us.
      if(bit_is_set(*_ucsra, UDRE0))
     7d8:	e8 89       	ldd	r30, Y+16	; 0x10
     7da:	f9 89       	ldd	r31, Y+17	; 0x11
     7dc:	80 81       	ld	r24, Z
     7de:	85 ff       	sbrs	r24, 5
     7e0:	f5 cf       	rjmp	.-22     	; 0x7cc <_ZN14HardwareSerial5writeEh+0x34>
	_tx_udr_empty_irq();
     7e2:	ce 01       	movw	r24, r28
     7e4:	0e 94 aa 03 	call	0x754	; 0x754 <_ZN14HardwareSerial17_tx_udr_empty_irqEv>
     7e8:	f1 cf       	rjmp	.-30     	; 0x7cc <_ZN14HardwareSerial5writeEh+0x34>
    } else {
      // nop, the interrupt handler will free up space for us
    }
  }

  _tx_buffer[_tx_buffer_head] = c;
     7ea:	8b 8d       	ldd	r24, Y+27	; 0x1b
     7ec:	fe 01       	movw	r30, r28
     7ee:	e8 0f       	add	r30, r24
     7f0:	f1 1d       	adc	r31, r1
     7f2:	e3 5a       	subi	r30, 0xA3	; 163
     7f4:	ff 4f       	sbci	r31, 0xFF	; 255
     7f6:	f0 82       	st	Z, r15

  // make atomic to prevent execution of ISR between setting the
  // head pointer and setting the interrupt flag resulting in buffer
  // retransmission
  ATOMIC_BLOCK(ATOMIC_RESTORESTATE) {
     7f8:	9f b7       	in	r25, 0x3f	; 63
    return 1;
}

static __inline__ uint8_t __iCliRetVal(void)
{
    cli();
     7fa:	f8 94       	cli
    _tx_buffer_head = i;
     7fc:	0b 8f       	std	Y+27, r16	; 0x1b
    sbi(*_ucsrb, UDRIE0);
     7fe:	ea 89       	ldd	r30, Y+18	; 0x12
     800:	fb 89       	ldd	r31, Y+19	; 0x13
     802:	80 81       	ld	r24, Z
     804:	80 62       	ori	r24, 0x20	; 32
     806:	0a c0       	rjmp	.+20     	; 0x81c <_ZN14HardwareSerial5writeEh+0x84>
    // So writing UDR must happen first.
    // Writing UDR and clearing TC must be done atomically, otherwise
    // interrupts might delay the TXC clear so the byte written to UDR
    // is transmitted (setting TXC) before clearing TXC. Then TXC will
    // be cleared when no bytes are left, causing flush() to hang
    ATOMIC_BLOCK(ATOMIC_RESTORESTATE) {
     808:	9f b7       	in	r25, 0x3f	; 63
     80a:	f8 94       	cli
      *_udr = c;
     80c:	ee 89       	ldd	r30, Y+22	; 0x16
     80e:	ff 89       	ldd	r31, Y+23	; 0x17
     810:	60 83       	st	Z, r22
#ifdef MPCM0
      *_ucsra = ((*_ucsra) & ((1 << U2X0) | (1 << MPCM0))) | (1 << TXC0);
     812:	e8 89       	ldd	r30, Y+16	; 0x10
     814:	f9 89       	ldd	r31, Y+17	; 0x11
     816:	80 81       	ld	r24, Z
     818:	83 70       	andi	r24, 0x03	; 3
     81a:	80 64       	ori	r24, 0x40	; 64
     81c:	80 83       	st	Z, r24
    (void)__s;
}

static __inline__ void __iRestore(const  uint8_t *__s)
{
    SREG = *__s;
     81e:	9f bf       	out	0x3f, r25	; 63
    _tx_buffer_head = i;
    sbi(*_ucsrb, UDRIE0);
  }
  
  return 1;
}
     820:	81 e0       	ldi	r24, 0x01	; 1
     822:	90 e0       	ldi	r25, 0x00	; 0
     824:	df 91       	pop	r29
     826:	cf 91       	pop	r28
     828:	1f 91       	pop	r17
     82a:	0f 91       	pop	r16
     82c:	ff 90       	pop	r15
     82e:	ef 90       	pop	r14
     830:	08 95       	ret

00000832 <_ZN14HardwareSerial5flushEv>:
  if (head >= tail) return SERIAL_TX_BUFFER_SIZE - 1 - head + tail;
  return tail - head - 1;
}

void HardwareSerial::flush()
{
     832:	cf 93       	push	r28
     834:	df 93       	push	r29
     836:	ec 01       	movw	r28, r24
  // If we have never written a byte, no need to flush. This special
  // case is needed since there is no way to force the TXC (transmit
  // complete) bit to 1 during initialization
  if (!_written)
     838:	88 8d       	ldd	r24, Y+24	; 0x18
     83a:	88 23       	and	r24, r24
     83c:	c9 f0       	breq	.+50     	; 0x870 <_ZN14HardwareSerial5flushEv+0x3e>
    return;

  while (bit_is_set(*_ucsrb, UDRIE0) || bit_is_clear(*_ucsra, TXC0)) {
     83e:	ea 89       	ldd	r30, Y+18	; 0x12
     840:	fb 89       	ldd	r31, Y+19	; 0x13
     842:	80 81       	ld	r24, Z
     844:	85 fd       	sbrc	r24, 5
     846:	05 c0       	rjmp	.+10     	; 0x852 <_ZN14HardwareSerial5flushEv+0x20>
     848:	a8 89       	ldd	r26, Y+16	; 0x10
     84a:	b9 89       	ldd	r27, Y+17	; 0x11
     84c:	8c 91       	ld	r24, X
     84e:	86 fd       	sbrc	r24, 6
     850:	0f c0       	rjmp	.+30     	; 0x870 <_ZN14HardwareSerial5flushEv+0x3e>
    if (bit_is_clear(SREG, SREG_I) && bit_is_set(*_ucsrb, UDRIE0))
     852:	0f b6       	in	r0, 0x3f	; 63
     854:	07 fc       	sbrc	r0, 7
     856:	f5 cf       	rjmp	.-22     	; 0x842 <_ZN14HardwareSerial5flushEv+0x10>
     858:	80 81       	ld	r24, Z
     85a:	85 ff       	sbrs	r24, 5
     85c:	f2 cf       	rjmp	.-28     	; 0x842 <_ZN14HardwareSerial5flushEv+0x10>
	// Interrupts are globally disabled, but the DR empty
	// interrupt should be enabled, so poll the DR empty flag to
	// prevent deadlock
	if (bit_is_set(*_ucsra, UDRE0))
     85e:	a8 89       	ldd	r26, Y+16	; 0x10
     860:	b9 89       	ldd	r27, Y+17	; 0x11
     862:	8c 91       	ld	r24, X
     864:	85 ff       	sbrs	r24, 5
     866:	ed cf       	rjmp	.-38     	; 0x842 <_ZN14HardwareSerial5flushEv+0x10>
	  _tx_udr_empty_irq();
     868:	ce 01       	movw	r24, r28
     86a:	0e 94 aa 03 	call	0x754	; 0x754 <_ZN14HardwareSerial17_tx_udr_empty_irqEv>
     86e:	e7 cf       	rjmp	.-50     	; 0x83e <_ZN14HardwareSerial5flushEv+0xc>
  }
  // If we get here, nothing is queued anymore (DRIE is disabled) and
  // the hardware finished tranmission (TXC is set).
}
     870:	df 91       	pop	r29
     872:	cf 91       	pop	r28
     874:	08 95       	ret

00000876 <_ZN14HardwareSerial5beginEmh>:
}

// Public Methods //////////////////////////////////////////////////////////////

void HardwareSerial::begin(unsigned long baud, byte config)
{
     876:	cf 92       	push	r12
     878:	df 92       	push	r13
     87a:	ef 92       	push	r14
     87c:	ff 92       	push	r15
     87e:	1f 93       	push	r17
     880:	cf 93       	push	r28
     882:	df 93       	push	r29
     884:	ec 01       	movw	r28, r24
     886:	6a 01       	movw	r12, r20
     888:	7b 01       	movw	r14, r22
     88a:	12 2f       	mov	r17, r18
  // Try u2x mode first
  uint16_t baud_setting = (F_CPU / 4 / baud - 1) / 2;
  *_ucsra = 1 << U2X0;
     88c:	e8 89       	ldd	r30, Y+16	; 0x10
     88e:	f9 89       	ldd	r31, Y+17	; 0x11
     890:	82 e0       	ldi	r24, 0x02	; 2
     892:	80 83       	st	Z, r24
  // hardcoded exception for 57600 for compatibility with the bootloader
  // shipped with the Duemilanove and previous boards and the firmware
  // on the 8U2 on the Uno and Mega 2560. Also, The baud_setting cannot
  // be > 4095, so switch back to non-u2x mode if the baud rate is too
  // low.
  if (((F_CPU == 16000000UL) && (baud == 57600)) || (baud_setting >4095))
     894:	41 15       	cp	r20, r1
     896:	51 4e       	sbci	r21, 0xE1	; 225
     898:	61 05       	cpc	r22, r1
     89a:	71 05       	cpc	r23, r1
     89c:	b1 f0       	breq	.+44     	; 0x8ca <_ZN14HardwareSerial5beginEmh+0x54>
// Public Methods //////////////////////////////////////////////////////////////

void HardwareSerial::begin(unsigned long baud, byte config)
{
  // Try u2x mode first
  uint16_t baud_setting = (F_CPU / 4 / baud - 1) / 2;
     89e:	60 e0       	ldi	r22, 0x00	; 0
     8a0:	79 e0       	ldi	r23, 0x09	; 9
     8a2:	8d e3       	ldi	r24, 0x3D	; 61
     8a4:	90 e0       	ldi	r25, 0x00	; 0
     8a6:	a7 01       	movw	r20, r14
     8a8:	96 01       	movw	r18, r12
     8aa:	0e 94 4c 17 	call	0x2e98	; 0x2e98 <__udivmodsi4>
     8ae:	da 01       	movw	r26, r20
     8b0:	c9 01       	movw	r24, r18
     8b2:	01 97       	sbiw	r24, 0x01	; 1
     8b4:	a1 09       	sbc	r26, r1
     8b6:	b1 09       	sbc	r27, r1
     8b8:	b6 95       	lsr	r27
     8ba:	a7 95       	ror	r26
     8bc:	97 95       	ror	r25
     8be:	87 95       	ror	r24
     8c0:	9c 01       	movw	r18, r24
  // hardcoded exception for 57600 for compatibility with the bootloader
  // shipped with the Duemilanove and previous boards and the firmware
  // on the 8U2 on the Uno and Mega 2560. Also, The baud_setting cannot
  // be > 4095, so switch back to non-u2x mode if the baud rate is too
  // low.
  if (((F_CPU == 16000000UL) && (baud == 57600)) || (baud_setting >4095))
     8c2:	21 15       	cp	r18, r1
     8c4:	80 e1       	ldi	r24, 0x10	; 16
     8c6:	38 07       	cpc	r19, r24
     8c8:	a8 f0       	brcs	.+42     	; 0x8f4 <_ZN14HardwareSerial5beginEmh+0x7e>
  {
    *_ucsra = 0;
     8ca:	e8 89       	ldd	r30, Y+16	; 0x10
     8cc:	f9 89       	ldd	r31, Y+17	; 0x11
     8ce:	10 82       	st	Z, r1
    baud_setting = (F_CPU / 8 / baud - 1) / 2;
     8d0:	60 e8       	ldi	r22, 0x80	; 128
     8d2:	74 e8       	ldi	r23, 0x84	; 132
     8d4:	8e e1       	ldi	r24, 0x1E	; 30
     8d6:	90 e0       	ldi	r25, 0x00	; 0
     8d8:	a7 01       	movw	r20, r14
     8da:	96 01       	movw	r18, r12
     8dc:	0e 94 4c 17 	call	0x2e98	; 0x2e98 <__udivmodsi4>
     8e0:	da 01       	movw	r26, r20
     8e2:	c9 01       	movw	r24, r18
     8e4:	01 97       	sbiw	r24, 0x01	; 1
     8e6:	a1 09       	sbc	r26, r1
     8e8:	b1 09       	sbc	r27, r1
     8ea:	b6 95       	lsr	r27
     8ec:	a7 95       	ror	r26
     8ee:	97 95       	ror	r25
     8f0:	87 95       	ror	r24
     8f2:	9c 01       	movw	r18, r24
  }

  // assign the baud_setting, a.k.a. ubrr (USART Baud Rate Register)
  *_ubrrh = baud_setting >> 8;
     8f4:	ec 85       	ldd	r30, Y+12	; 0x0c
     8f6:	fd 85       	ldd	r31, Y+13	; 0x0d
     8f8:	30 83       	st	Z, r19
  *_ubrrl = baud_setting;
     8fa:	ee 85       	ldd	r30, Y+14	; 0x0e
     8fc:	ff 85       	ldd	r31, Y+15	; 0x0f
     8fe:	20 83       	st	Z, r18

  _written = false;
     900:	18 8e       	std	Y+24, r1	; 0x18

  //set the data bits, parity, and stop bits
#if defined(__AVR_ATmega8__)
  config |= 0x80; // select UCSRC register (shared with UBRRH)
#endif
  *_ucsrc = config;
     902:	ec 89       	ldd	r30, Y+20	; 0x14
     904:	fd 89       	ldd	r31, Y+21	; 0x15
     906:	10 83       	st	Z, r17
  
  sbi(*_ucsrb, RXEN0);
     908:	ea 89       	ldd	r30, Y+18	; 0x12
     90a:	fb 89       	ldd	r31, Y+19	; 0x13
     90c:	80 81       	ld	r24, Z
     90e:	80 61       	ori	r24, 0x10	; 16
     910:	80 83       	st	Z, r24
  sbi(*_ucsrb, TXEN0);
     912:	ea 89       	ldd	r30, Y+18	; 0x12
     914:	fb 89       	ldd	r31, Y+19	; 0x13
     916:	80 81       	ld	r24, Z
     918:	88 60       	ori	r24, 0x08	; 8
     91a:	80 83       	st	Z, r24
  sbi(*_ucsrb, RXCIE0);
     91c:	ea 89       	ldd	r30, Y+18	; 0x12
     91e:	fb 89       	ldd	r31, Y+19	; 0x13
     920:	80 81       	ld	r24, Z
     922:	80 68       	ori	r24, 0x80	; 128
     924:	80 83       	st	Z, r24
  cbi(*_ucsrb, UDRIE0);
     926:	ea 89       	ldd	r30, Y+18	; 0x12
     928:	fb 89       	ldd	r31, Y+19	; 0x13
     92a:	80 81       	ld	r24, Z
     92c:	8f 7d       	andi	r24, 0xDF	; 223
     92e:	80 83       	st	Z, r24
}
     930:	df 91       	pop	r29
     932:	cf 91       	pop	r28
     934:	1f 91       	pop	r17
     936:	ff 90       	pop	r15
     938:	ef 90       	pop	r14
     93a:	df 90       	pop	r13
     93c:	cf 90       	pop	r12
     93e:	08 95       	ret

00000940 <__vector_18>:
#elif defined(USART_RXC_vect)
  ISR(USART_RXC_vect) // ATmega8
#else
  #error "Don't know what the Data Received vector is called for Serial"
#endif
  {
     940:	1f 92       	push	r1
     942:	0f 92       	push	r0
     944:	0f b6       	in	r0, 0x3f	; 63
     946:	0f 92       	push	r0
     948:	11 24       	eor	r1, r1
     94a:	2f 93       	push	r18
     94c:	8f 93       	push	r24
     94e:	9f 93       	push	r25
     950:	ef 93       	push	r30
     952:	ff 93       	push	r31

// Actual interrupt handlers //////////////////////////////////////////////////////////////

void HardwareSerial::_rx_complete_irq(void)
{
  if (bit_is_clear(*_ucsra, UPE0)) {
     954:	e0 91 2f 02 	lds	r30, 0x022F	; 0x80022f <Serial+0x10>
     958:	f0 91 30 02 	lds	r31, 0x0230	; 0x800230 <Serial+0x11>
     95c:	80 81       	ld	r24, Z
     95e:	e0 91 35 02 	lds	r30, 0x0235	; 0x800235 <Serial+0x16>
     962:	f0 91 36 02 	lds	r31, 0x0236	; 0x800236 <Serial+0x17>
     966:	82 fd       	sbrc	r24, 2
     968:	12 c0       	rjmp	.+36     	; 0x98e <__vector_18+0x4e>
    // No Parity error, read byte and store it in the buffer if there is
    // room
    unsigned char c = *_udr;
     96a:	90 81       	ld	r25, Z
    rx_buffer_index_t i = (unsigned int)(_rx_buffer_head + 1) % SERIAL_RX_BUFFER_SIZE;
     96c:	80 91 38 02 	lds	r24, 0x0238	; 0x800238 <Serial+0x19>
     970:	8f 5f       	subi	r24, 0xFF	; 255
     972:	8f 73       	andi	r24, 0x3F	; 63

    // if we should be storing the received character into the location
    // just before the tail (meaning that the head would advance to the
    // current location of the tail), we're about to overflow the buffer
    // and so we don't write the character or advance the head.
    if (i != _rx_buffer_tail) {
     974:	20 91 39 02 	lds	r18, 0x0239	; 0x800239 <Serial+0x1a>
     978:	82 17       	cp	r24, r18
     97a:	51 f0       	breq	.+20     	; 0x990 <__vector_18+0x50>
      _rx_buffer[_rx_buffer_head] = c;
     97c:	e0 91 38 02 	lds	r30, 0x0238	; 0x800238 <Serial+0x19>
     980:	f0 e0       	ldi	r31, 0x00	; 0
     982:	e1 5e       	subi	r30, 0xE1	; 225
     984:	fd 4f       	sbci	r31, 0xFD	; 253
     986:	95 8f       	std	Z+29, r25	; 0x1d
      _rx_buffer_head = i;
     988:	80 93 38 02 	sts	0x0238, r24	; 0x800238 <Serial+0x19>
     98c:	01 c0       	rjmp	.+2      	; 0x990 <__vector_18+0x50>
    }
  } else {
    // Parity error, read byte but discard it
    *_udr;
     98e:	80 81       	ld	r24, Z
    Serial._rx_complete_irq();
  }
     990:	ff 91       	pop	r31
     992:	ef 91       	pop	r30
     994:	9f 91       	pop	r25
     996:	8f 91       	pop	r24
     998:	2f 91       	pop	r18
     99a:	0f 90       	pop	r0
     99c:	0f be       	out	0x3f, r0	; 63
     99e:	0f 90       	pop	r0
     9a0:	1f 90       	pop	r1
     9a2:	18 95       	reti

000009a4 <__vector_19>:
#elif defined(USART_UDRE_vect)
ISR(USART_UDRE_vect)
#else
  #error "Don't know what the Data Register Empty vector is called for Serial"
#endif
{
     9a4:	1f 92       	push	r1
     9a6:	0f 92       	push	r0
     9a8:	0f b6       	in	r0, 0x3f	; 63
     9aa:	0f 92       	push	r0
     9ac:	11 24       	eor	r1, r1
     9ae:	2f 93       	push	r18
     9b0:	3f 93       	push	r19
     9b2:	4f 93       	push	r20
     9b4:	5f 93       	push	r21
     9b6:	6f 93       	push	r22
     9b8:	7f 93       	push	r23
     9ba:	8f 93       	push	r24
     9bc:	9f 93       	push	r25
     9be:	af 93       	push	r26
     9c0:	bf 93       	push	r27
     9c2:	ef 93       	push	r30
     9c4:	ff 93       	push	r31
  Serial._tx_udr_empty_irq();
     9c6:	8f e1       	ldi	r24, 0x1F	; 31
     9c8:	92 e0       	ldi	r25, 0x02	; 2
     9ca:	0e 94 aa 03 	call	0x754	; 0x754 <_ZN14HardwareSerial17_tx_udr_empty_irqEv>
}
     9ce:	ff 91       	pop	r31
     9d0:	ef 91       	pop	r30
     9d2:	bf 91       	pop	r27
     9d4:	af 91       	pop	r26
     9d6:	9f 91       	pop	r25
     9d8:	8f 91       	pop	r24
     9da:	7f 91       	pop	r23
     9dc:	6f 91       	pop	r22
     9de:	5f 91       	pop	r21
     9e0:	4f 91       	pop	r20
     9e2:	3f 91       	pop	r19
     9e4:	2f 91       	pop	r18
     9e6:	0f 90       	pop	r0
     9e8:	0f be       	out	0x3f, r0	; 63
     9ea:	0f 90       	pop	r0
     9ec:	1f 90       	pop	r1
     9ee:	18 95       	reti

000009f0 <_Z17Serial0_availablev>:
#endif

// Function that can be weakly referenced by serialEventRun to prevent
// pulling in this file if it's not otherwise used.
bool Serial0_available() {
  return Serial.available();
     9f0:	8f e1       	ldi	r24, 0x1F	; 31
     9f2:	92 e0       	ldi	r25, 0x02	; 2
     9f4:	0e 94 5f 03 	call	0x6be	; 0x6be <_ZN14HardwareSerial9availableEv>
     9f8:	21 e0       	ldi	r18, 0x01	; 1
     9fa:	89 2b       	or	r24, r25
     9fc:	09 f4       	brne	.+2      	; 0xa00 <_Z17Serial0_availablev+0x10>
     9fe:	20 e0       	ldi	r18, 0x00	; 0
}
     a00:	82 2f       	mov	r24, r18
     a02:	08 95       	ret

00000a04 <_GLOBAL__sub_I___vector_18>:
    size_t printNumber(unsigned long, uint8_t);
    size_t printFloat(double, uint8_t);
  protected:
    void setWriteError(int err = 1) { write_error = err; }
  public:
    Print() : write_error(0) {}
     a04:	ef e1       	ldi	r30, 0x1F	; 31
     a06:	f2 e0       	ldi	r31, 0x02	; 2
     a08:	13 82       	std	Z+3, r1	; 0x03
     a0a:	12 82       	std	Z+2, r1	; 0x02
  public:
    virtual int available() = 0;
    virtual int read() = 0;
    virtual int peek() = 0;

    Stream() {_timeout=1000;}
     a0c:	88 ee       	ldi	r24, 0xE8	; 232
     a0e:	93 e0       	ldi	r25, 0x03	; 3
     a10:	a0 e0       	ldi	r26, 0x00	; 0
     a12:	b0 e0       	ldi	r27, 0x00	; 0
     a14:	84 83       	std	Z+4, r24	; 0x04
     a16:	95 83       	std	Z+5, r25	; 0x05
     a18:	a6 83       	std	Z+6, r26	; 0x06
     a1a:	b7 83       	std	Z+7, r27	; 0x07
  volatile uint8_t *ucsrc, volatile uint8_t *udr) :
    _ubrrh(ubrrh), _ubrrl(ubrrl),
    _ucsra(ucsra), _ucsrb(ucsrb), _ucsrc(ucsrc),
    _udr(udr),
    _rx_buffer_head(0), _rx_buffer_tail(0),
    _tx_buffer_head(0), _tx_buffer_tail(0)
     a1c:	85 e3       	ldi	r24, 0x35	; 53
     a1e:	91 e0       	ldi	r25, 0x01	; 1
     a20:	91 83       	std	Z+1, r25	; 0x01
     a22:	80 83       	st	Z, r24
     a24:	85 ec       	ldi	r24, 0xC5	; 197
     a26:	90 e0       	ldi	r25, 0x00	; 0
     a28:	95 87       	std	Z+13, r25	; 0x0d
     a2a:	84 87       	std	Z+12, r24	; 0x0c
     a2c:	84 ec       	ldi	r24, 0xC4	; 196
     a2e:	90 e0       	ldi	r25, 0x00	; 0
     a30:	97 87       	std	Z+15, r25	; 0x0f
     a32:	86 87       	std	Z+14, r24	; 0x0e
     a34:	80 ec       	ldi	r24, 0xC0	; 192
     a36:	90 e0       	ldi	r25, 0x00	; 0
     a38:	91 8b       	std	Z+17, r25	; 0x11
     a3a:	80 8b       	std	Z+16, r24	; 0x10
     a3c:	81 ec       	ldi	r24, 0xC1	; 193
     a3e:	90 e0       	ldi	r25, 0x00	; 0
     a40:	93 8b       	std	Z+19, r25	; 0x13
     a42:	82 8b       	std	Z+18, r24	; 0x12
     a44:	82 ec       	ldi	r24, 0xC2	; 194
     a46:	90 e0       	ldi	r25, 0x00	; 0
     a48:	95 8b       	std	Z+21, r25	; 0x15
     a4a:	84 8b       	std	Z+20, r24	; 0x14
     a4c:	86 ec       	ldi	r24, 0xC6	; 198
     a4e:	90 e0       	ldi	r25, 0x00	; 0
     a50:	97 8b       	std	Z+23, r25	; 0x17
     a52:	86 8b       	std	Z+22, r24	; 0x16
     a54:	11 8e       	std	Z+25, r1	; 0x19
     a56:	12 8e       	std	Z+26, r1	; 0x1a
     a58:	13 8e       	std	Z+27, r1	; 0x1b
     a5a:	14 8e       	std	Z+28, r1	; 0x1c
     a5c:	08 95       	ret

00000a5e <main>:
void setupUSB() __attribute__((weak));
void setupUSB() { }

int main(void)
{
	init();
     a5e:	0e 94 45 06 	call	0xc8a	; 0xc8a <init>

	initVariant();
     a62:	0e 94 6f 12 	call	0x24de	; 0x24de <initVariant>

#if defined(USBCON)
	USBDevice.attach();
#endif
	
	setup();
     a66:	0e 94 f3 02 	call	0x5e6	; 0x5e6 <setup>
    
	for (;;) {
		loop();
		if (serialEventRun) serialEventRun();
     a6a:	cc e9       	ldi	r28, 0x9C	; 156
     a6c:	d3 e0       	ldi	r29, 0x03	; 3
#endif
	
	setup();
    
	for (;;) {
		loop();
     a6e:	0e 94 53 03 	call	0x6a6	; 0x6a6 <loop>
		if (serialEventRun) serialEventRun();
     a72:	20 97       	sbiw	r28, 0x00	; 0
     a74:	e1 f3       	breq	.-8      	; 0xa6e <main+0x10>
     a76:	0e 94 9c 03 	call	0x738	; 0x738 <_Z14serialEventRunv>
     a7a:	f9 cf       	rjmp	.-14     	; 0xa6e <main+0x10>

00000a7c <_ZN5Print5writeEPKhj>:
  
    virtual size_t write(uint8_t) = 0;
    size_t write(const char *str) {
      if (str == NULL) return 0;
      return write((const uint8_t *)str, strlen(str));
    }
     a7c:	cf 92       	push	r12
     a7e:	df 92       	push	r13
     a80:	ef 92       	push	r14
     a82:	ff 92       	push	r15
     a84:	0f 93       	push	r16
     a86:	1f 93       	push	r17
     a88:	cf 93       	push	r28
     a8a:	df 93       	push	r29
     a8c:	6c 01       	movw	r12, r24
     a8e:	7a 01       	movw	r14, r20
     a90:	8b 01       	movw	r16, r22
     a92:	c0 e0       	ldi	r28, 0x00	; 0
     a94:	d0 e0       	ldi	r29, 0x00	; 0
     a96:	ce 15       	cp	r28, r14
     a98:	df 05       	cpc	r29, r15
     a9a:	81 f0       	breq	.+32     	; 0xabc <_ZN5Print5writeEPKhj+0x40>
     a9c:	d8 01       	movw	r26, r16
     a9e:	6d 91       	ld	r22, X+
     aa0:	8d 01       	movw	r16, r26
     aa2:	d6 01       	movw	r26, r12
     aa4:	ed 91       	ld	r30, X+
     aa6:	fc 91       	ld	r31, X
     aa8:	01 90       	ld	r0, Z+
     aaa:	f0 81       	ld	r31, Z
     aac:	e0 2d       	mov	r30, r0
     aae:	c6 01       	movw	r24, r12
     ab0:	09 95       	icall
     ab2:	89 2b       	or	r24, r25
     ab4:	11 f0       	breq	.+4      	; 0xaba <_ZN5Print5writeEPKhj+0x3e>
     ab6:	21 96       	adiw	r28, 0x01	; 1
     ab8:	ee cf       	rjmp	.-36     	; 0xa96 <_ZN5Print5writeEPKhj+0x1a>
     aba:	7e 01       	movw	r14, r28
     abc:	c7 01       	movw	r24, r14
     abe:	df 91       	pop	r29
     ac0:	cf 91       	pop	r28
     ac2:	1f 91       	pop	r17
     ac4:	0f 91       	pop	r16
     ac6:	ff 90       	pop	r15
     ac8:	ef 90       	pop	r14
     aca:	df 90       	pop	r13
     acc:	cf 90       	pop	r12
     ace:	08 95       	ret

00000ad0 <_ZN5Print5printEPK19__FlashStringHelper>:
  }
  return n;
}

size_t Print::print(const __FlashStringHelper *ifsh)
{
     ad0:	ef 92       	push	r14
     ad2:	ff 92       	push	r15
     ad4:	0f 93       	push	r16
     ad6:	1f 93       	push	r17
     ad8:	cf 93       	push	r28
     ada:	df 93       	push	r29
     adc:	8c 01       	movw	r16, r24
     ade:	7b 01       	movw	r14, r22
  PGM_P p = reinterpret_cast<PGM_P>(ifsh);
  size_t n = 0;
     ae0:	c0 e0       	ldi	r28, 0x00	; 0
     ae2:	d0 e0       	ldi	r29, 0x00	; 0
  while (1) {
    unsigned char c = pgm_read_byte(p++);
     ae4:	f7 01       	movw	r30, r14
     ae6:	ec 0f       	add	r30, r28
     ae8:	fd 1f       	adc	r31, r29
     aea:	64 91       	lpm	r22, Z
    if (c == 0) break;
     aec:	66 23       	and	r22, r22
     aee:	61 f0       	breq	.+24     	; 0xb08 <_ZN5Print5printEPK19__FlashStringHelper+0x38>
    if (write(c)) n++;
     af0:	d8 01       	movw	r26, r16
     af2:	ed 91       	ld	r30, X+
     af4:	fc 91       	ld	r31, X
     af6:	01 90       	ld	r0, Z+
     af8:	f0 81       	ld	r31, Z
     afa:	e0 2d       	mov	r30, r0
     afc:	c8 01       	movw	r24, r16
     afe:	09 95       	icall
     b00:	89 2b       	or	r24, r25
     b02:	11 f0       	breq	.+4      	; 0xb08 <_ZN5Print5printEPK19__FlashStringHelper+0x38>
     b04:	21 96       	adiw	r28, 0x01	; 1

size_t Print::print(const __FlashStringHelper *ifsh)
{
  PGM_P p = reinterpret_cast<PGM_P>(ifsh);
  size_t n = 0;
  while (1) {
     b06:	ee cf       	rjmp	.-36     	; 0xae4 <_ZN5Print5printEPK19__FlashStringHelper+0x14>
    if (c == 0) break;
    if (write(c)) n++;
    else break;
  }
  return n;
}
     b08:	ce 01       	movw	r24, r28
     b0a:	df 91       	pop	r29
     b0c:	cf 91       	pop	r28
     b0e:	1f 91       	pop	r17
     b10:	0f 91       	pop	r16
     b12:	ff 90       	pop	r15
     b14:	ef 90       	pop	r14
     b16:	08 95       	ret

00000b18 <nothing>:
    #endif
      break;       
#endif
    }
      
    intFunc[interruptNum] = nothing;
     b18:	08 95       	ret

00000b1a <attachInterrupt>:
     b1a:	82 30       	cpi	r24, 0x02	; 2
     b1c:	e8 f4       	brcc	.+58     	; 0xb58 <attachInterrupt+0x3e>
     b1e:	e8 2f       	mov	r30, r24
     b20:	f0 e0       	ldi	r31, 0x00	; 0
     b22:	ee 0f       	add	r30, r30
     b24:	ff 1f       	adc	r31, r31
     b26:	ea 5f       	subi	r30, 0xFA	; 250
     b28:	fe 4f       	sbci	r31, 0xFE	; 254
     b2a:	71 83       	std	Z+1, r23	; 0x01
     b2c:	60 83       	st	Z, r22
     b2e:	81 30       	cpi	r24, 0x01	; 1
     b30:	41 f0       	breq	.+16     	; 0xb42 <attachInterrupt+0x28>
     b32:	80 91 69 00 	lds	r24, 0x0069	; 0x800069 <__DATA_REGION_ORIGIN__+0x9>
     b36:	8c 7f       	andi	r24, 0xFC	; 252
     b38:	48 2b       	or	r20, r24
     b3a:	40 93 69 00 	sts	0x0069, r20	; 0x800069 <__DATA_REGION_ORIGIN__+0x9>
     b3e:	e8 9a       	sbi	0x1d, 0	; 29
     b40:	08 95       	ret
     b42:	80 91 69 00 	lds	r24, 0x0069	; 0x800069 <__DATA_REGION_ORIGIN__+0x9>
     b46:	83 7f       	andi	r24, 0xF3	; 243
     b48:	44 0f       	add	r20, r20
     b4a:	55 1f       	adc	r21, r21
     b4c:	44 0f       	add	r20, r20
     b4e:	55 1f       	adc	r21, r21
     b50:	48 2b       	or	r20, r24
     b52:	40 93 69 00 	sts	0x0069, r20	; 0x800069 <__DATA_REGION_ORIGIN__+0x9>
     b56:	e9 9a       	sbi	0x1d, 1	; 29
     b58:	08 95       	ret

00000b5a <__vector_1>:
IMPLEMENT_ISR(INT6_vect, EXTERNAL_INT_6)
IMPLEMENT_ISR(INT7_vect, EXTERNAL_INT_7)

#else

IMPLEMENT_ISR(INT0_vect, EXTERNAL_INT_0)
     b5a:	1f 92       	push	r1
     b5c:	0f 92       	push	r0
     b5e:	0f b6       	in	r0, 0x3f	; 63
     b60:	0f 92       	push	r0
     b62:	11 24       	eor	r1, r1
     b64:	2f 93       	push	r18
     b66:	3f 93       	push	r19
     b68:	4f 93       	push	r20
     b6a:	5f 93       	push	r21
     b6c:	6f 93       	push	r22
     b6e:	7f 93       	push	r23
     b70:	8f 93       	push	r24
     b72:	9f 93       	push	r25
     b74:	af 93       	push	r26
     b76:	bf 93       	push	r27
     b78:	ef 93       	push	r30
     b7a:	ff 93       	push	r31
     b7c:	e0 91 06 01 	lds	r30, 0x0106	; 0x800106 <intFunc>
     b80:	f0 91 07 01 	lds	r31, 0x0107	; 0x800107 <intFunc+0x1>
     b84:	09 95       	icall
     b86:	ff 91       	pop	r31
     b88:	ef 91       	pop	r30
     b8a:	bf 91       	pop	r27
     b8c:	af 91       	pop	r26
     b8e:	9f 91       	pop	r25
     b90:	8f 91       	pop	r24
     b92:	7f 91       	pop	r23
     b94:	6f 91       	pop	r22
     b96:	5f 91       	pop	r21
     b98:	4f 91       	pop	r20
     b9a:	3f 91       	pop	r19
     b9c:	2f 91       	pop	r18
     b9e:	0f 90       	pop	r0
     ba0:	0f be       	out	0x3f, r0	; 63
     ba2:	0f 90       	pop	r0
     ba4:	1f 90       	pop	r1
     ba6:	18 95       	reti

00000ba8 <__vector_2>:
IMPLEMENT_ISR(INT1_vect, EXTERNAL_INT_1)
     ba8:	1f 92       	push	r1
     baa:	0f 92       	push	r0
     bac:	0f b6       	in	r0, 0x3f	; 63
     bae:	0f 92       	push	r0
     bb0:	11 24       	eor	r1, r1
     bb2:	2f 93       	push	r18
     bb4:	3f 93       	push	r19
     bb6:	4f 93       	push	r20
     bb8:	5f 93       	push	r21
     bba:	6f 93       	push	r22
     bbc:	7f 93       	push	r23
     bbe:	8f 93       	push	r24
     bc0:	9f 93       	push	r25
     bc2:	af 93       	push	r26
     bc4:	bf 93       	push	r27
     bc6:	ef 93       	push	r30
     bc8:	ff 93       	push	r31
     bca:	e0 91 08 01 	lds	r30, 0x0108	; 0x800108 <intFunc+0x2>
     bce:	f0 91 09 01 	lds	r31, 0x0109	; 0x800109 <intFunc+0x3>
     bd2:	09 95       	icall
     bd4:	ff 91       	pop	r31
     bd6:	ef 91       	pop	r30
     bd8:	bf 91       	pop	r27
     bda:	af 91       	pop	r26
     bdc:	9f 91       	pop	r25
     bde:	8f 91       	pop	r24
     be0:	7f 91       	pop	r23
     be2:	6f 91       	pop	r22
     be4:	5f 91       	pop	r21
     be6:	4f 91       	pop	r20
     be8:	3f 91       	pop	r19
     bea:	2f 91       	pop	r18
     bec:	0f 90       	pop	r0
     bee:	0f be       	out	0x3f, r0	; 63
     bf0:	0f 90       	pop	r0
     bf2:	1f 90       	pop	r1
     bf4:	18 95       	reti

00000bf6 <__vector_16>:
	

#endif

	// busy wait
	__asm__ __volatile__ (
     bf6:	1f 92       	push	r1
     bf8:	0f 92       	push	r0
     bfa:	0f b6       	in	r0, 0x3f	; 63
     bfc:	0f 92       	push	r0
     bfe:	11 24       	eor	r1, r1
     c00:	2f 93       	push	r18
     c02:	3f 93       	push	r19
     c04:	8f 93       	push	r24
     c06:	9f 93       	push	r25
     c08:	af 93       	push	r26
     c0a:	bf 93       	push	r27
     c0c:	80 91 bd 02 	lds	r24, 0x02BD	; 0x8002bd <timer0_millis>
     c10:	90 91 be 02 	lds	r25, 0x02BE	; 0x8002be <timer0_millis+0x1>
     c14:	a0 91 bf 02 	lds	r26, 0x02BF	; 0x8002bf <timer0_millis+0x2>
     c18:	b0 91 c0 02 	lds	r27, 0x02C0	; 0x8002c0 <timer0_millis+0x3>
     c1c:	30 91 bc 02 	lds	r19, 0x02BC	; 0x8002bc <timer0_fract>
     c20:	23 e0       	ldi	r18, 0x03	; 3
     c22:	23 0f       	add	r18, r19
     c24:	2d 37       	cpi	r18, 0x7D	; 125
     c26:	20 f4       	brcc	.+8      	; 0xc30 <__vector_16+0x3a>
     c28:	01 96       	adiw	r24, 0x01	; 1
     c2a:	a1 1d       	adc	r26, r1
     c2c:	b1 1d       	adc	r27, r1
     c2e:	05 c0       	rjmp	.+10     	; 0xc3a <__vector_16+0x44>
     c30:	26 e8       	ldi	r18, 0x86	; 134
     c32:	23 0f       	add	r18, r19
     c34:	02 96       	adiw	r24, 0x02	; 2
     c36:	a1 1d       	adc	r26, r1
     c38:	b1 1d       	adc	r27, r1
     c3a:	20 93 bc 02 	sts	0x02BC, r18	; 0x8002bc <timer0_fract>
     c3e:	80 93 bd 02 	sts	0x02BD, r24	; 0x8002bd <timer0_millis>
     c42:	90 93 be 02 	sts	0x02BE, r25	; 0x8002be <timer0_millis+0x1>
     c46:	a0 93 bf 02 	sts	0x02BF, r26	; 0x8002bf <timer0_millis+0x2>
     c4a:	b0 93 c0 02 	sts	0x02C0, r27	; 0x8002c0 <timer0_millis+0x3>
     c4e:	80 91 c1 02 	lds	r24, 0x02C1	; 0x8002c1 <timer0_overflow_count>
     c52:	90 91 c2 02 	lds	r25, 0x02C2	; 0x8002c2 <timer0_overflow_count+0x1>
     c56:	a0 91 c3 02 	lds	r26, 0x02C3	; 0x8002c3 <timer0_overflow_count+0x2>
     c5a:	b0 91 c4 02 	lds	r27, 0x02C4	; 0x8002c4 <timer0_overflow_count+0x3>
     c5e:	01 96       	adiw	r24, 0x01	; 1
     c60:	a1 1d       	adc	r26, r1
     c62:	b1 1d       	adc	r27, r1
     c64:	80 93 c1 02 	sts	0x02C1, r24	; 0x8002c1 <timer0_overflow_count>
     c68:	90 93 c2 02 	sts	0x02C2, r25	; 0x8002c2 <timer0_overflow_count+0x1>
     c6c:	a0 93 c3 02 	sts	0x02C3, r26	; 0x8002c3 <timer0_overflow_count+0x2>
     c70:	b0 93 c4 02 	sts	0x02C4, r27	; 0x8002c4 <timer0_overflow_count+0x3>
     c74:	bf 91       	pop	r27
     c76:	af 91       	pop	r26
     c78:	9f 91       	pop	r25
     c7a:	8f 91       	pop	r24
     c7c:	3f 91       	pop	r19
     c7e:	2f 91       	pop	r18
     c80:	0f 90       	pop	r0
     c82:	0f be       	out	0x3f, r0	; 63
     c84:	0f 90       	pop	r0
     c86:	1f 90       	pop	r1
     c88:	18 95       	reti

00000c8a <init>:

void init()
{
	// this needs to be called before setup() or some functions won't
	// work there
	sei();
     c8a:	78 94       	sei
	
	// on the ATmega168, timer 0 is also used for fast hardware pwm
	// (using phase-correct PWM would mean that timer 0 overflowed half as often
	// resulting in different millis() behavior on the ATmega8 and ATmega168)
#if defined(TCCR0A) && defined(WGM01)
	sbi(TCCR0A, WGM01);
     c8c:	84 b5       	in	r24, 0x24	; 36
     c8e:	82 60       	ori	r24, 0x02	; 2
     c90:	84 bd       	out	0x24, r24	; 36
	sbi(TCCR0A, WGM00);
     c92:	84 b5       	in	r24, 0x24	; 36
     c94:	81 60       	ori	r24, 0x01	; 1
     c96:	84 bd       	out	0x24, r24	; 36
	// this combination is for the standard atmega8
	sbi(TCCR0, CS01);
	sbi(TCCR0, CS00);
#elif defined(TCCR0B) && defined(CS01) && defined(CS00)
	// this combination is for the standard 168/328/1280/2560
	sbi(TCCR0B, CS01);
     c98:	85 b5       	in	r24, 0x25	; 37
     c9a:	82 60       	ori	r24, 0x02	; 2
     c9c:	85 bd       	out	0x25, r24	; 37
	sbi(TCCR0B, CS00);
     c9e:	85 b5       	in	r24, 0x25	; 37
     ca0:	81 60       	ori	r24, 0x01	; 1
     ca2:	85 bd       	out	0x25, r24	; 37

	// enable timer 0 overflow interrupt
#if defined(TIMSK) && defined(TOIE0)
	sbi(TIMSK, TOIE0);
#elif defined(TIMSK0) && defined(TOIE0)
	sbi(TIMSK0, TOIE0);
     ca4:	ee e6       	ldi	r30, 0x6E	; 110
     ca6:	f0 e0       	ldi	r31, 0x00	; 0
     ca8:	80 81       	ld	r24, Z
     caa:	81 60       	ori	r24, 0x01	; 1
     cac:	80 83       	st	Z, r24
	// this is better for motors as it ensures an even waveform
	// note, however, that fast pwm mode can achieve a frequency of up
	// 8 MHz (with a 16 MHz clock) at 50% duty cycle

#if defined(TCCR1B) && defined(CS11) && defined(CS10)
	TCCR1B = 0;
     cae:	e1 e8       	ldi	r30, 0x81	; 129
     cb0:	f0 e0       	ldi	r31, 0x00	; 0
     cb2:	10 82       	st	Z, r1

	// set timer 1 prescale factor to 64
	sbi(TCCR1B, CS11);
     cb4:	80 81       	ld	r24, Z
     cb6:	82 60       	ori	r24, 0x02	; 2
     cb8:	80 83       	st	Z, r24
#if F_CPU >= 8000000L
	sbi(TCCR1B, CS10);
     cba:	80 81       	ld	r24, Z
     cbc:	81 60       	ori	r24, 0x01	; 1
     cbe:	80 83       	st	Z, r24
	sbi(TCCR1, CS10);
#endif
#endif
	// put timer 1 in 8-bit phase correct pwm mode
#if defined(TCCR1A) && defined(WGM10)
	sbi(TCCR1A, WGM10);
     cc0:	e0 e8       	ldi	r30, 0x80	; 128
     cc2:	f0 e0       	ldi	r31, 0x00	; 0
     cc4:	80 81       	ld	r24, Z
     cc6:	81 60       	ori	r24, 0x01	; 1
     cc8:	80 83       	st	Z, r24

	// set timer 2 prescale factor to 64
#if defined(TCCR2) && defined(CS22)
	sbi(TCCR2, CS22);
#elif defined(TCCR2B) && defined(CS22)
	sbi(TCCR2B, CS22);
     cca:	e1 eb       	ldi	r30, 0xB1	; 177
     ccc:	f0 e0       	ldi	r31, 0x00	; 0
     cce:	80 81       	ld	r24, Z
     cd0:	84 60       	ori	r24, 0x04	; 4
     cd2:	80 83       	st	Z, r24

	// configure timer 2 for phase correct pwm (8-bit)
#if defined(TCCR2) && defined(WGM20)
	sbi(TCCR2, WGM20);
#elif defined(TCCR2A) && defined(WGM20)
	sbi(TCCR2A, WGM20);
     cd4:	e0 eb       	ldi	r30, 0xB0	; 176
     cd6:	f0 e0       	ldi	r31, 0x00	; 0
     cd8:	80 81       	ld	r24, Z
     cda:	81 60       	ori	r24, 0x01	; 1
     cdc:	80 83       	st	Z, r24
#endif

#if defined(ADCSRA)
	// set a2d prescaler so we are inside the desired 50-200 KHz range.
	#if F_CPU >= 16000000 // 16 MHz / 128 = 125 KHz
		sbi(ADCSRA, ADPS2);
     cde:	ea e7       	ldi	r30, 0x7A	; 122
     ce0:	f0 e0       	ldi	r31, 0x00	; 0
     ce2:	80 81       	ld	r24, Z
     ce4:	84 60       	ori	r24, 0x04	; 4
     ce6:	80 83       	st	Z, r24
		sbi(ADCSRA, ADPS1);
     ce8:	80 81       	ld	r24, Z
     cea:	82 60       	ori	r24, 0x02	; 2
     cec:	80 83       	st	Z, r24
		sbi(ADCSRA, ADPS0);
     cee:	80 81       	ld	r24, Z
     cf0:	81 60       	ori	r24, 0x01	; 1
     cf2:	80 83       	st	Z, r24
		cbi(ADCSRA, ADPS2);
		cbi(ADCSRA, ADPS1);
		sbi(ADCSRA, ADPS0);
	#endif
	// enable a2d conversions
	sbi(ADCSRA, ADEN);
     cf4:	80 81       	ld	r24, Z
     cf6:	80 68       	ori	r24, 0x80	; 128
     cf8:	80 83       	st	Z, r24
	// here so they can be used as normal digital i/o; they will be
	// reconnected in Serial.begin()
#if defined(UCSRB)
	UCSRB = 0;
#elif defined(UCSR0B)
	UCSR0B = 0;
     cfa:	10 92 c1 00 	sts	0x00C1, r1	; 0x8000c1 <__DATA_REGION_ORIGIN__+0x61>
     cfe:	08 95       	ret

00000d00 <turnOffPWM>:
//
//static inline void turnOffPWM(uint8_t timer) __attribute__ ((always_inline));
//static inline void turnOffPWM(uint8_t timer)
static void turnOffPWM(uint8_t timer)
{
	switch (timer)
     d00:	83 30       	cpi	r24, 0x03	; 3
     d02:	81 f0       	breq	.+32     	; 0xd24 <turnOffPWM+0x24>
     d04:	28 f4       	brcc	.+10     	; 0xd10 <turnOffPWM+0x10>
     d06:	81 30       	cpi	r24, 0x01	; 1
     d08:	99 f0       	breq	.+38     	; 0xd30 <turnOffPWM+0x30>
     d0a:	82 30       	cpi	r24, 0x02	; 2
     d0c:	a1 f0       	breq	.+40     	; 0xd36 <turnOffPWM+0x36>
     d0e:	08 95       	ret
     d10:	87 30       	cpi	r24, 0x07	; 7
     d12:	a9 f0       	breq	.+42     	; 0xd3e <turnOffPWM+0x3e>
     d14:	88 30       	cpi	r24, 0x08	; 8
     d16:	b9 f0       	breq	.+46     	; 0xd46 <turnOffPWM+0x46>
     d18:	84 30       	cpi	r24, 0x04	; 4
     d1a:	d1 f4       	brne	.+52     	; 0xd50 <turnOffPWM+0x50>
	{
		#if defined(TCCR1A) && defined(COM1A1)
		case TIMER1A:   cbi(TCCR1A, COM1A1);    break;
		#endif
		#if defined(TCCR1A) && defined(COM1B1)
		case TIMER1B:   cbi(TCCR1A, COM1B1);    break;
     d1c:	80 91 80 00 	lds	r24, 0x0080	; 0x800080 <__DATA_REGION_ORIGIN__+0x20>
     d20:	8f 7d       	andi	r24, 0xDF	; 223
     d22:	03 c0       	rjmp	.+6      	; 0xd2a <turnOffPWM+0x2a>
static void turnOffPWM(uint8_t timer)
{
	switch (timer)
	{
		#if defined(TCCR1A) && defined(COM1A1)
		case TIMER1A:   cbi(TCCR1A, COM1A1);    break;
     d24:	80 91 80 00 	lds	r24, 0x0080	; 0x800080 <__DATA_REGION_ORIGIN__+0x20>
     d28:	8f 77       	andi	r24, 0x7F	; 127
		#endif
		#if defined(TCCR1A) && defined(COM1B1)
		case TIMER1B:   cbi(TCCR1A, COM1B1);    break;
     d2a:	80 93 80 00 	sts	0x0080, r24	; 0x800080 <__DATA_REGION_ORIGIN__+0x20>
     d2e:	08 95       	ret
		#if defined(TCCR2) && defined(COM21)
		case  TIMER2:   cbi(TCCR2, COM21);      break;
		#endif
		
		#if defined(TCCR0A) && defined(COM0A1)
		case  TIMER0A:  cbi(TCCR0A, COM0A1);    break;
     d30:	84 b5       	in	r24, 0x24	; 36
     d32:	8f 77       	andi	r24, 0x7F	; 127
     d34:	02 c0       	rjmp	.+4      	; 0xd3a <turnOffPWM+0x3a>
		#endif
		
		#if defined(TCCR0A) && defined(COM0B1)
		case  TIMER0B:  cbi(TCCR0A, COM0B1);    break;
     d36:	84 b5       	in	r24, 0x24	; 36
     d38:	8f 7d       	andi	r24, 0xDF	; 223
     d3a:	84 bd       	out	0x24, r24	; 36
     d3c:	08 95       	ret
		#endif
		#if defined(TCCR2A) && defined(COM2A1)
		case  TIMER2A:  cbi(TCCR2A, COM2A1);    break;
     d3e:	80 91 b0 00 	lds	r24, 0x00B0	; 0x8000b0 <__DATA_REGION_ORIGIN__+0x50>
     d42:	8f 77       	andi	r24, 0x7F	; 127
     d44:	03 c0       	rjmp	.+6      	; 0xd4c <turnOffPWM+0x4c>
		#endif
		#if defined(TCCR2A) && defined(COM2B1)
		case  TIMER2B:  cbi(TCCR2A, COM2B1);    break;
     d46:	80 91 b0 00 	lds	r24, 0x00B0	; 0x8000b0 <__DATA_REGION_ORIGIN__+0x50>
     d4a:	8f 7d       	andi	r24, 0xDF	; 223
     d4c:	80 93 b0 00 	sts	0x00B0, r24	; 0x8000b0 <__DATA_REGION_ORIGIN__+0x50>
     d50:	08 95       	ret

00000d52 <pinMode>:
#define ARDUINO_MAIN
#include "wiring_private.h"
#include "pins_arduino.h"

void pinMode(uint8_t pin, uint8_t mode)
{
     d52:	cf 93       	push	r28
     d54:	df 93       	push	r29
	uint8_t bit = digitalPinToBitMask(pin);
     d56:	90 e0       	ldi	r25, 0x00	; 0
     d58:	fc 01       	movw	r30, r24
     d5a:	ea 55       	subi	r30, 0x5A	; 90
     d5c:	ff 4f       	sbci	r31, 0xFF	; 255
     d5e:	24 91       	lpm	r18, Z
	uint8_t port = digitalPinToPort(pin);
     d60:	fc 01       	movw	r30, r24
     d62:	e6 54       	subi	r30, 0x46	; 70
     d64:	ff 4f       	sbci	r31, 0xFF	; 255
     d66:	84 91       	lpm	r24, Z
	volatile uint8_t *reg, *out;

	if (port == NOT_A_PIN) return;
     d68:	88 23       	and	r24, r24
     d6a:	61 f1       	breq	.+88     	; 0xdc4 <pinMode+0x72>

	// JWS: can I let the optimizer do this?
	reg = portModeRegister(port);
     d6c:	90 e0       	ldi	r25, 0x00	; 0
     d6e:	88 0f       	add	r24, r24
     d70:	99 1f       	adc	r25, r25
     d72:	fc 01       	movw	r30, r24
     d74:	e8 52       	subi	r30, 0x28	; 40
     d76:	ff 4f       	sbci	r31, 0xFF	; 255
     d78:	c5 91       	lpm	r28, Z+
     d7a:	d4 91       	lpm	r29, Z
	out = portOutputRegister(port);
     d7c:	fc 01       	movw	r30, r24
     d7e:	e2 53       	subi	r30, 0x32	; 50
     d80:	ff 4f       	sbci	r31, 0xFF	; 255
     d82:	a5 91       	lpm	r26, Z+
     d84:	b4 91       	lpm	r27, Z

	if (mode == INPUT) { 
     d86:	61 11       	cpse	r22, r1
     d88:	09 c0       	rjmp	.+18     	; 0xd9c <pinMode+0x4a>
		uint8_t oldSREG = SREG;
     d8a:	9f b7       	in	r25, 0x3f	; 63
                cli();
     d8c:	f8 94       	cli
		*reg &= ~bit;
     d8e:	88 81       	ld	r24, Y
     d90:	20 95       	com	r18
     d92:	82 23       	and	r24, r18
     d94:	88 83       	st	Y, r24
		*out &= ~bit;
     d96:	ec 91       	ld	r30, X
     d98:	2e 23       	and	r18, r30
     d9a:	0b c0       	rjmp	.+22     	; 0xdb2 <pinMode+0x60>
		SREG = oldSREG;
	} else if (mode == INPUT_PULLUP) {
     d9c:	62 30       	cpi	r22, 0x02	; 2
     d9e:	61 f4       	brne	.+24     	; 0xdb8 <pinMode+0x66>
		uint8_t oldSREG = SREG;
     da0:	9f b7       	in	r25, 0x3f	; 63
                cli();
     da2:	f8 94       	cli
		*reg &= ~bit;
     da4:	88 81       	ld	r24, Y
     da6:	32 2f       	mov	r19, r18
     da8:	30 95       	com	r19
     daa:	83 23       	and	r24, r19
     dac:	88 83       	st	Y, r24
		*out |= bit;
     dae:	ec 91       	ld	r30, X
     db0:	2e 2b       	or	r18, r30
     db2:	2c 93       	st	X, r18
		SREG = oldSREG;
     db4:	9f bf       	out	0x3f, r25	; 63
     db6:	06 c0       	rjmp	.+12     	; 0xdc4 <pinMode+0x72>
	} else {
		uint8_t oldSREG = SREG;
     db8:	8f b7       	in	r24, 0x3f	; 63
                cli();
     dba:	f8 94       	cli
		*reg |= bit;
     dbc:	e8 81       	ld	r30, Y
     dbe:	2e 2b       	or	r18, r30
     dc0:	28 83       	st	Y, r18
		SREG = oldSREG;
     dc2:	8f bf       	out	0x3f, r24	; 63
	}
}
     dc4:	df 91       	pop	r29
     dc6:	cf 91       	pop	r28
     dc8:	08 95       	ret

00000dca <digitalWrite>:
		#endif
	}
}

void digitalWrite(uint8_t pin, uint8_t val)
{
     dca:	1f 93       	push	r17
     dcc:	cf 93       	push	r28
     dce:	df 93       	push	r29
	uint8_t timer = digitalPinToTimer(pin);
     dd0:	28 2f       	mov	r18, r24
     dd2:	30 e0       	ldi	r19, 0x00	; 0
     dd4:	f9 01       	movw	r30, r18
     dd6:	ee 56       	subi	r30, 0x6E	; 110
     dd8:	ff 4f       	sbci	r31, 0xFF	; 255
     dda:	84 91       	lpm	r24, Z
	uint8_t bit = digitalPinToBitMask(pin);
     ddc:	f9 01       	movw	r30, r18
     dde:	ea 55       	subi	r30, 0x5A	; 90
     de0:	ff 4f       	sbci	r31, 0xFF	; 255
     de2:	d4 91       	lpm	r29, Z
	uint8_t port = digitalPinToPort(pin);
     de4:	f9 01       	movw	r30, r18
     de6:	e6 54       	subi	r30, 0x46	; 70
     de8:	ff 4f       	sbci	r31, 0xFF	; 255
     dea:	c4 91       	lpm	r28, Z
	volatile uint8_t *out;

	if (port == NOT_A_PIN) return;
     dec:	cc 23       	and	r28, r28
     dee:	c1 f0       	breq	.+48     	; 0xe20 <digitalWrite+0x56>
     df0:	16 2f       	mov	r17, r22

	// If the pin that support PWM output, we need to turn it off
	// before doing a digital write.
	if (timer != NOT_ON_TIMER) turnOffPWM(timer);
     df2:	81 11       	cpse	r24, r1
     df4:	0e 94 80 06 	call	0xd00	; 0xd00 <turnOffPWM>

	out = portOutputRegister(port);
     df8:	ec 2f       	mov	r30, r28
     dfa:	f0 e0       	ldi	r31, 0x00	; 0
     dfc:	ee 0f       	add	r30, r30
     dfe:	ff 1f       	adc	r31, r31
     e00:	e2 53       	subi	r30, 0x32	; 50
     e02:	ff 4f       	sbci	r31, 0xFF	; 255
     e04:	a5 91       	lpm	r26, Z+
     e06:	b4 91       	lpm	r27, Z

	uint8_t oldSREG = SREG;
     e08:	9f b7       	in	r25, 0x3f	; 63
	cli();
     e0a:	f8 94       	cli

	if (val == LOW) {
     e0c:	11 11       	cpse	r17, r1
     e0e:	04 c0       	rjmp	.+8      	; 0xe18 <digitalWrite+0x4e>
		*out &= ~bit;
     e10:	8c 91       	ld	r24, X
     e12:	d0 95       	com	r29
     e14:	d8 23       	and	r29, r24
     e16:	02 c0       	rjmp	.+4      	; 0xe1c <digitalWrite+0x52>
	} else {
		*out |= bit;
     e18:	ec 91       	ld	r30, X
     e1a:	de 2b       	or	r29, r30
     e1c:	dc 93       	st	X, r29
	}

	SREG = oldSREG;
     e1e:	9f bf       	out	0x3f, r25	; 63
}
     e20:	df 91       	pop	r29
     e22:	cf 91       	pop	r28
     e24:	1f 91       	pop	r17
     e26:	08 95       	ret

00000e28 <prvIsQueueEmpty>:
    {
        xReturn = pdFALSE;
    }

    return xReturn;
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
     e28:	0f b6       	in	r0, 0x3f	; 63
     e2a:	f8 94       	cli
     e2c:	0f 92       	push	r0
     e2e:	fc 01       	movw	r30, r24
     e30:	92 8d       	ldd	r25, Z+26	; 0x1a
     e32:	0f 90       	pop	r0
     e34:	0f be       	out	0x3f, r0	; 63
     e36:	81 e0       	ldi	r24, 0x01	; 1
     e38:	91 11       	cpse	r25, r1
     e3a:	80 e0       	ldi	r24, 0x00	; 0
     e3c:	08 95       	ret

00000e3e <prvCopyDataToQueue>:
     e3e:	0f 93       	push	r16
     e40:	1f 93       	push	r17
     e42:	cf 93       	push	r28
     e44:	df 93       	push	r29
     e46:	ec 01       	movw	r28, r24
     e48:	04 2f       	mov	r16, r20
     e4a:	1a 8d       	ldd	r17, Y+26	; 0x1a
     e4c:	4c 8d       	ldd	r20, Y+28	; 0x1c
     e4e:	41 11       	cpse	r20, r1
     e50:	0b c0       	rjmp	.+22     	; 0xe68 <prvCopyDataToQueue+0x2a>
     e52:	88 81       	ld	r24, Y
     e54:	99 81       	ldd	r25, Y+1	; 0x01
     e56:	89 2b       	or	r24, r25
     e58:	e9 f5       	brne	.+122    	; 0xed4 <prvCopyDataToQueue+0x96>
     e5a:	8c 81       	ldd	r24, Y+4	; 0x04
     e5c:	9d 81       	ldd	r25, Y+5	; 0x05
     e5e:	0e 94 d6 0f 	call	0x1fac	; 0x1fac <xTaskPriorityDisinherit>
     e62:	1d 82       	std	Y+5, r1	; 0x05
     e64:	1c 82       	std	Y+4, r1	; 0x04
     e66:	37 c0       	rjmp	.+110    	; 0xed6 <prvCopyDataToQueue+0x98>
     e68:	50 e0       	ldi	r21, 0x00	; 0
     e6a:	01 11       	cpse	r16, r1
     e6c:	15 c0       	rjmp	.+42     	; 0xe98 <prvCopyDataToQueue+0x5a>
     e6e:	8a 81       	ldd	r24, Y+2	; 0x02
     e70:	9b 81       	ldd	r25, Y+3	; 0x03
     e72:	0e 94 e2 18 	call	0x31c4	; 0x31c4 <memcpy>
     e76:	2c 8d       	ldd	r18, Y+28	; 0x1c
     e78:	8a 81       	ldd	r24, Y+2	; 0x02
     e7a:	9b 81       	ldd	r25, Y+3	; 0x03
     e7c:	82 0f       	add	r24, r18
     e7e:	91 1d       	adc	r25, r1
     e80:	9b 83       	std	Y+3, r25	; 0x03
     e82:	8a 83       	std	Y+2, r24	; 0x02
     e84:	2c 81       	ldd	r18, Y+4	; 0x04
     e86:	3d 81       	ldd	r19, Y+5	; 0x05
     e88:	82 17       	cp	r24, r18
     e8a:	93 07       	cpc	r25, r19
     e8c:	18 f1       	brcs	.+70     	; 0xed4 <prvCopyDataToQueue+0x96>
     e8e:	88 81       	ld	r24, Y
     e90:	99 81       	ldd	r25, Y+1	; 0x01
     e92:	9b 83       	std	Y+3, r25	; 0x03
     e94:	8a 83       	std	Y+2, r24	; 0x02
     e96:	1e c0       	rjmp	.+60     	; 0xed4 <prvCopyDataToQueue+0x96>
     e98:	8e 81       	ldd	r24, Y+6	; 0x06
     e9a:	9f 81       	ldd	r25, Y+7	; 0x07
     e9c:	0e 94 e2 18 	call	0x31c4	; 0x31c4 <memcpy>
     ea0:	8c 8d       	ldd	r24, Y+28	; 0x1c
     ea2:	90 e0       	ldi	r25, 0x00	; 0
     ea4:	91 95       	neg	r25
     ea6:	81 95       	neg	r24
     ea8:	91 09       	sbc	r25, r1
     eaa:	2e 81       	ldd	r18, Y+6	; 0x06
     eac:	3f 81       	ldd	r19, Y+7	; 0x07
     eae:	28 0f       	add	r18, r24
     eb0:	39 1f       	adc	r19, r25
     eb2:	3f 83       	std	Y+7, r19	; 0x07
     eb4:	2e 83       	std	Y+6, r18	; 0x06
     eb6:	48 81       	ld	r20, Y
     eb8:	59 81       	ldd	r21, Y+1	; 0x01
     eba:	24 17       	cp	r18, r20
     ebc:	35 07       	cpc	r19, r21
     ebe:	30 f4       	brcc	.+12     	; 0xecc <prvCopyDataToQueue+0x8e>
     ec0:	2c 81       	ldd	r18, Y+4	; 0x04
     ec2:	3d 81       	ldd	r19, Y+5	; 0x05
     ec4:	82 0f       	add	r24, r18
     ec6:	93 1f       	adc	r25, r19
     ec8:	9f 83       	std	Y+7, r25	; 0x07
     eca:	8e 83       	std	Y+6, r24	; 0x06
     ecc:	02 30       	cpi	r16, 0x02	; 2
     ece:	11 f4       	brne	.+4      	; 0xed4 <prvCopyDataToQueue+0x96>
     ed0:	11 11       	cpse	r17, r1
     ed2:	11 50       	subi	r17, 0x01	; 1
     ed4:	80 e0       	ldi	r24, 0x00	; 0
     ed6:	1f 5f       	subi	r17, 0xFF	; 255
     ed8:	1a 8f       	std	Y+26, r17	; 0x1a
     eda:	df 91       	pop	r29
     edc:	cf 91       	pop	r28
     ede:	1f 91       	pop	r17
     ee0:	0f 91       	pop	r16
     ee2:	08 95       	ret

00000ee4 <prvCopyDataFromQueue>:
     ee4:	fc 01       	movw	r30, r24
     ee6:	cb 01       	movw	r24, r22
     ee8:	44 8d       	ldd	r20, Z+28	; 0x1c
     eea:	44 23       	and	r20, r20
     eec:	a1 f0       	breq	.+40     	; 0xf16 <prvCopyDataFromQueue+0x32>
     eee:	50 e0       	ldi	r21, 0x00	; 0
     ef0:	26 81       	ldd	r18, Z+6	; 0x06
     ef2:	37 81       	ldd	r19, Z+7	; 0x07
     ef4:	24 0f       	add	r18, r20
     ef6:	35 1f       	adc	r19, r21
     ef8:	37 83       	std	Z+7, r19	; 0x07
     efa:	26 83       	std	Z+6, r18	; 0x06
     efc:	64 81       	ldd	r22, Z+4	; 0x04
     efe:	75 81       	ldd	r23, Z+5	; 0x05
     f00:	26 17       	cp	r18, r22
     f02:	37 07       	cpc	r19, r23
     f04:	20 f0       	brcs	.+8      	; 0xf0e <prvCopyDataFromQueue+0x2a>
     f06:	20 81       	ld	r18, Z
     f08:	31 81       	ldd	r19, Z+1	; 0x01
     f0a:	37 83       	std	Z+7, r19	; 0x07
     f0c:	26 83       	std	Z+6, r18	; 0x06
     f0e:	66 81       	ldd	r22, Z+6	; 0x06
     f10:	77 81       	ldd	r23, Z+7	; 0x07
     f12:	0c 94 e2 18 	jmp	0x31c4	; 0x31c4 <memcpy>
     f16:	08 95       	ret

00000f18 <prvUnlockQueue>:
     f18:	ef 92       	push	r14
     f1a:	ff 92       	push	r15
     f1c:	1f 93       	push	r17
     f1e:	cf 93       	push	r28
     f20:	df 93       	push	r29
     f22:	ec 01       	movw	r28, r24
     f24:	0f b6       	in	r0, 0x3f	; 63
     f26:	f8 94       	cli
     f28:	0f 92       	push	r0
     f2a:	1e 8d       	ldd	r17, Y+30	; 0x1e
     f2c:	7c 01       	movw	r14, r24
     f2e:	81 e1       	ldi	r24, 0x11	; 17
     f30:	e8 0e       	add	r14, r24
     f32:	f1 1c       	adc	r15, r1
     f34:	11 16       	cp	r1, r17
     f36:	5c f4       	brge	.+22     	; 0xf4e <prvUnlockQueue+0x36>
     f38:	89 89       	ldd	r24, Y+17	; 0x11
     f3a:	88 23       	and	r24, r24
     f3c:	41 f0       	breq	.+16     	; 0xf4e <prvUnlockQueue+0x36>
     f3e:	c7 01       	movw	r24, r14
     f40:	0e 94 e3 0e 	call	0x1dc6	; 0x1dc6 <xTaskRemoveFromEventList>
     f44:	81 11       	cpse	r24, r1
     f46:	0e 94 61 0f 	call	0x1ec2	; 0x1ec2 <vTaskMissedYield>
     f4a:	11 50       	subi	r17, 0x01	; 1
     f4c:	f3 cf       	rjmp	.-26     	; 0xf34 <prvUnlockQueue+0x1c>
     f4e:	8f ef       	ldi	r24, 0xFF	; 255
     f50:	8e 8f       	std	Y+30, r24	; 0x1e
     f52:	0f 90       	pop	r0
     f54:	0f be       	out	0x3f, r0	; 63
     f56:	0f b6       	in	r0, 0x3f	; 63
     f58:	f8 94       	cli
     f5a:	0f 92       	push	r0
     f5c:	1d 8d       	ldd	r17, Y+29	; 0x1d
     f5e:	7e 01       	movw	r14, r28
     f60:	88 e0       	ldi	r24, 0x08	; 8
     f62:	e8 0e       	add	r14, r24
     f64:	f1 1c       	adc	r15, r1
     f66:	11 16       	cp	r1, r17
     f68:	5c f4       	brge	.+22     	; 0xf80 <prvUnlockQueue+0x68>
     f6a:	88 85       	ldd	r24, Y+8	; 0x08
     f6c:	88 23       	and	r24, r24
     f6e:	41 f0       	breq	.+16     	; 0xf80 <prvUnlockQueue+0x68>
     f70:	c7 01       	movw	r24, r14
     f72:	0e 94 e3 0e 	call	0x1dc6	; 0x1dc6 <xTaskRemoveFromEventList>
     f76:	81 11       	cpse	r24, r1
     f78:	0e 94 61 0f 	call	0x1ec2	; 0x1ec2 <vTaskMissedYield>
     f7c:	11 50       	subi	r17, 0x01	; 1
     f7e:	f3 cf       	rjmp	.-26     	; 0xf66 <prvUnlockQueue+0x4e>
     f80:	8f ef       	ldi	r24, 0xFF	; 255
     f82:	8d 8f       	std	Y+29, r24	; 0x1d
     f84:	0f 90       	pop	r0
     f86:	0f be       	out	0x3f, r0	; 63
     f88:	df 91       	pop	r29
     f8a:	cf 91       	pop	r28
     f8c:	1f 91       	pop	r17
     f8e:	ff 90       	pop	r15
     f90:	ef 90       	pop	r14
     f92:	08 95       	ret

00000f94 <xQueueGenericReset>:
     f94:	cf 93       	push	r28
     f96:	df 93       	push	r29
     f98:	ec 01       	movw	r28, r24
     f9a:	0f b6       	in	r0, 0x3f	; 63
     f9c:	f8 94       	cli
     f9e:	0f 92       	push	r0
     fa0:	48 81       	ld	r20, Y
     fa2:	59 81       	ldd	r21, Y+1	; 0x01
     fa4:	8b 8d       	ldd	r24, Y+27	; 0x1b
     fa6:	7c 8d       	ldd	r23, Y+28	; 0x1c
     fa8:	9a 01       	movw	r18, r20
     faa:	87 9f       	mul	r24, r23
     fac:	20 0d       	add	r18, r0
     fae:	31 1d       	adc	r19, r1
     fb0:	11 24       	eor	r1, r1
     fb2:	3d 83       	std	Y+5, r19	; 0x05
     fb4:	2c 83       	std	Y+4, r18	; 0x04
     fb6:	1a 8e       	std	Y+26, r1	; 0x1a
     fb8:	5b 83       	std	Y+3, r21	; 0x03
     fba:	4a 83       	std	Y+2, r20	; 0x02
     fbc:	90 e0       	ldi	r25, 0x00	; 0
     fbe:	01 97       	sbiw	r24, 0x01	; 1
     fc0:	78 9f       	mul	r23, r24
     fc2:	90 01       	movw	r18, r0
     fc4:	79 9f       	mul	r23, r25
     fc6:	30 0d       	add	r19, r0
     fc8:	11 24       	eor	r1, r1
     fca:	ca 01       	movw	r24, r20
     fcc:	82 0f       	add	r24, r18
     fce:	93 1f       	adc	r25, r19
     fd0:	9f 83       	std	Y+7, r25	; 0x07
     fd2:	8e 83       	std	Y+6, r24	; 0x06
     fd4:	8f ef       	ldi	r24, 0xFF	; 255
     fd6:	8d 8f       	std	Y+29, r24	; 0x1d
     fd8:	8e 8f       	std	Y+30, r24	; 0x1e
     fda:	61 11       	cpse	r22, r1
     fdc:	0c c0       	rjmp	.+24     	; 0xff6 <xQueueGenericReset+0x62>
     fde:	88 85       	ldd	r24, Y+8	; 0x08
     fe0:	88 23       	and	r24, r24
     fe2:	89 f0       	breq	.+34     	; 0x1006 <xQueueGenericReset+0x72>
     fe4:	ce 01       	movw	r24, r28
     fe6:	08 96       	adiw	r24, 0x08	; 8
     fe8:	0e 94 e3 0e 	call	0x1dc6	; 0x1dc6 <xTaskRemoveFromEventList>
     fec:	88 23       	and	r24, r24
     fee:	59 f0       	breq	.+22     	; 0x1006 <xQueueGenericReset+0x72>
     ff0:	0e 94 69 15 	call	0x2ad2	; 0x2ad2 <vPortYield>
     ff4:	08 c0       	rjmp	.+16     	; 0x1006 <xQueueGenericReset+0x72>
     ff6:	ce 01       	movw	r24, r28
     ff8:	08 96       	adiw	r24, 0x08	; 8
     ffa:	0e 94 36 14 	call	0x286c	; 0x286c <vListInitialise>
     ffe:	ce 01       	movw	r24, r28
    1000:	41 96       	adiw	r24, 0x11	; 17
    1002:	0e 94 36 14 	call	0x286c	; 0x286c <vListInitialise>
    1006:	0f 90       	pop	r0
    1008:	0f be       	out	0x3f, r0	; 63
    100a:	81 e0       	ldi	r24, 0x01	; 1
    100c:	df 91       	pop	r29
    100e:	cf 91       	pop	r28
    1010:	08 95       	ret

00001012 <xQueueGenericCreate>:
    1012:	0f 93       	push	r16
    1014:	1f 93       	push	r17
    1016:	cf 93       	push	r28
    1018:	df 93       	push	r29
    101a:	08 2f       	mov	r16, r24
    101c:	16 2f       	mov	r17, r22
    101e:	66 23       	and	r22, r22
    1020:	21 f0       	breq	.+8      	; 0x102a <xQueueGenericCreate+0x18>
    1022:	86 9f       	mul	r24, r22
    1024:	c0 01       	movw	r24, r0
    1026:	11 24       	eor	r1, r1
    1028:	02 c0       	rjmp	.+4      	; 0x102e <xQueueGenericCreate+0x1c>
    102a:	80 e0       	ldi	r24, 0x00	; 0
    102c:	90 e0       	ldi	r25, 0x00	; 0
    102e:	4f 96       	adiw	r24, 0x1f	; 31
    1030:	0e 94 12 14 	call	0x2824	; 0x2824 <pvPortMalloc>
    1034:	ec 01       	movw	r28, r24
    1036:	00 97       	sbiw	r24, 0x00	; 0
    1038:	71 f0       	breq	.+28     	; 0x1056 <xQueueGenericCreate+0x44>
    103a:	11 11       	cpse	r17, r1
    103c:	03 c0       	rjmp	.+6      	; 0x1044 <xQueueGenericCreate+0x32>
    103e:	99 83       	std	Y+1, r25	; 0x01
    1040:	88 83       	st	Y, r24
    1042:	03 c0       	rjmp	.+6      	; 0x104a <xQueueGenericCreate+0x38>
    1044:	4f 96       	adiw	r24, 0x1f	; 31
    1046:	99 83       	std	Y+1, r25	; 0x01
    1048:	88 83       	st	Y, r24
    104a:	0b 8f       	std	Y+27, r16	; 0x1b
    104c:	1c 8f       	std	Y+28, r17	; 0x1c
    104e:	61 e0       	ldi	r22, 0x01	; 1
    1050:	ce 01       	movw	r24, r28
    1052:	0e 94 ca 07 	call	0xf94	; 0xf94 <xQueueGenericReset>
    1056:	ce 01       	movw	r24, r28
    1058:	df 91       	pop	r29
    105a:	cf 91       	pop	r28
    105c:	1f 91       	pop	r17
    105e:	0f 91       	pop	r16
    1060:	08 95       	ret

00001062 <xQueueGenericSend>:
    1062:	af 92       	push	r10
    1064:	bf 92       	push	r11
    1066:	cf 92       	push	r12
    1068:	df 92       	push	r13
    106a:	ff 92       	push	r15
    106c:	0f 93       	push	r16
    106e:	1f 93       	push	r17
    1070:	cf 93       	push	r28
    1072:	df 93       	push	r29
    1074:	00 d0       	rcall	.+0      	; 0x1076 <xQueueGenericSend+0x14>
    1076:	00 d0       	rcall	.+0      	; 0x1078 <xQueueGenericSend+0x16>
    1078:	1f 92       	push	r1
    107a:	cd b7       	in	r28, 0x3d	; 61
    107c:	de b7       	in	r29, 0x3e	; 62
    107e:	8c 01       	movw	r16, r24
    1080:	6b 01       	movw	r12, r22
    1082:	5d 83       	std	Y+5, r21	; 0x05
    1084:	4c 83       	std	Y+4, r20	; 0x04
    1086:	f2 2e       	mov	r15, r18
    1088:	80 e0       	ldi	r24, 0x00	; 0
    108a:	58 01       	movw	r10, r16
    108c:	98 e0       	ldi	r25, 0x08	; 8
    108e:	a9 0e       	add	r10, r25
    1090:	b1 1c       	adc	r11, r1
    1092:	0f b6       	in	r0, 0x3f	; 63
    1094:	f8 94       	cli
    1096:	0f 92       	push	r0
    1098:	f8 01       	movw	r30, r16
    109a:	22 8d       	ldd	r18, Z+26	; 0x1a
    109c:	93 8d       	ldd	r25, Z+27	; 0x1b
    109e:	29 17       	cp	r18, r25
    10a0:	18 f0       	brcs	.+6      	; 0x10a8 <xQueueGenericSend+0x46>
    10a2:	f2 e0       	ldi	r31, 0x02	; 2
    10a4:	ff 12       	cpse	r15, r31
    10a6:	14 c0       	rjmp	.+40     	; 0x10d0 <xQueueGenericSend+0x6e>
    10a8:	4f 2d       	mov	r20, r15
    10aa:	b6 01       	movw	r22, r12
    10ac:	c8 01       	movw	r24, r16
    10ae:	0e 94 1f 07 	call	0xe3e	; 0xe3e <prvCopyDataToQueue>
    10b2:	f8 01       	movw	r30, r16
    10b4:	91 89       	ldd	r25, Z+17	; 0x11
    10b6:	99 23       	and	r25, r25
    10b8:	21 f0       	breq	.+8      	; 0x10c2 <xQueueGenericSend+0x60>
    10ba:	c8 01       	movw	r24, r16
    10bc:	41 96       	adiw	r24, 0x11	; 17
    10be:	0e 94 e3 0e 	call	0x1dc6	; 0x1dc6 <xTaskRemoveFromEventList>
    10c2:	81 11       	cpse	r24, r1
    10c4:	0e 94 69 15 	call	0x2ad2	; 0x2ad2 <vPortYield>
    10c8:	0f 90       	pop	r0
    10ca:	0f be       	out	0x3f, r0	; 63
    10cc:	81 e0       	ldi	r24, 0x01	; 1
    10ce:	50 c0       	rjmp	.+160    	; 0x1170 <xQueueGenericSend+0x10e>
    10d0:	2c 81       	ldd	r18, Y+4	; 0x04
    10d2:	3d 81       	ldd	r19, Y+5	; 0x05
    10d4:	23 2b       	or	r18, r19
    10d6:	19 f4       	brne	.+6      	; 0x10de <xQueueGenericSend+0x7c>
    10d8:	0f 90       	pop	r0
    10da:	0f be       	out	0x3f, r0	; 63
    10dc:	48 c0       	rjmp	.+144    	; 0x116e <xQueueGenericSend+0x10c>
    10de:	81 11       	cpse	r24, r1
    10e0:	04 c0       	rjmp	.+8      	; 0x10ea <xQueueGenericSend+0x88>
    10e2:	ce 01       	movw	r24, r28
    10e4:	01 96       	adiw	r24, 0x01	; 1
    10e6:	0e 94 23 0f 	call	0x1e46	; 0x1e46 <vTaskInternalSetTimeOutState>
    10ea:	0f 90       	pop	r0
    10ec:	0f be       	out	0x3f, r0	; 63
    10ee:	0e 94 8e 0c 	call	0x191c	; 0x191c <vTaskSuspendAll>
    10f2:	0f b6       	in	r0, 0x3f	; 63
    10f4:	f8 94       	cli
    10f6:	0f 92       	push	r0
    10f8:	f8 01       	movw	r30, r16
    10fa:	85 8d       	ldd	r24, Z+29	; 0x1d
    10fc:	8f 3f       	cpi	r24, 0xFF	; 255
    10fe:	09 f4       	brne	.+2      	; 0x1102 <xQueueGenericSend+0xa0>
    1100:	15 8e       	std	Z+29, r1	; 0x1d
    1102:	f8 01       	movw	r30, r16
    1104:	86 8d       	ldd	r24, Z+30	; 0x1e
    1106:	8f 3f       	cpi	r24, 0xFF	; 255
    1108:	09 f4       	brne	.+2      	; 0x110c <xQueueGenericSend+0xaa>
    110a:	16 8e       	std	Z+30, r1	; 0x1e
    110c:	0f 90       	pop	r0
    110e:	0f be       	out	0x3f, r0	; 63
    1110:	be 01       	movw	r22, r28
    1112:	6c 5f       	subi	r22, 0xFC	; 252
    1114:	7f 4f       	sbci	r23, 0xFF	; 255
    1116:	ce 01       	movw	r24, r28
    1118:	01 96       	adiw	r24, 0x01	; 1
    111a:	0e 94 2e 0f 	call	0x1e5c	; 0x1e5c <xTaskCheckForTimeOut>
    111e:	81 11       	cpse	r24, r1
    1120:	21 c0       	rjmp	.+66     	; 0x1164 <xQueueGenericSend+0x102>
    1122:	0f b6       	in	r0, 0x3f	; 63
    1124:	f8 94       	cli
    1126:	0f 92       	push	r0
    1128:	f8 01       	movw	r30, r16
    112a:	92 8d       	ldd	r25, Z+26	; 0x1a
    112c:	83 8d       	ldd	r24, Z+27	; 0x1b
    112e:	0f 90       	pop	r0
    1130:	0f be       	out	0x3f, r0	; 63
    1132:	98 13       	cpse	r25, r24
    1134:	11 c0       	rjmp	.+34     	; 0x1158 <xQueueGenericSend+0xf6>
    1136:	6c 81       	ldd	r22, Y+4	; 0x04
    1138:	7d 81       	ldd	r23, Y+5	; 0x05
    113a:	c5 01       	movw	r24, r10
    113c:	0e 94 ba 0e 	call	0x1d74	; 0x1d74 <vTaskPlaceOnEventList>
    1140:	c8 01       	movw	r24, r16
    1142:	0e 94 8c 07 	call	0xf18	; 0xf18 <prvUnlockQueue>
    1146:	0e 94 4a 0d 	call	0x1a94	; 0x1a94 <xTaskResumeAll>
    114a:	88 23       	and	r24, r24
    114c:	11 f0       	breq	.+4      	; 0x1152 <xQueueGenericSend+0xf0>
    114e:	81 e0       	ldi	r24, 0x01	; 1
    1150:	a0 cf       	rjmp	.-192    	; 0x1092 <xQueueGenericSend+0x30>
    1152:	0e 94 69 15 	call	0x2ad2	; 0x2ad2 <vPortYield>
    1156:	fb cf       	rjmp	.-10     	; 0x114e <xQueueGenericSend+0xec>
    1158:	c8 01       	movw	r24, r16
    115a:	0e 94 8c 07 	call	0xf18	; 0xf18 <prvUnlockQueue>
    115e:	0e 94 4a 0d 	call	0x1a94	; 0x1a94 <xTaskResumeAll>
    1162:	f5 cf       	rjmp	.-22     	; 0x114e <xQueueGenericSend+0xec>
    1164:	c8 01       	movw	r24, r16
    1166:	0e 94 8c 07 	call	0xf18	; 0xf18 <prvUnlockQueue>
    116a:	0e 94 4a 0d 	call	0x1a94	; 0x1a94 <xTaskResumeAll>
    116e:	80 e0       	ldi	r24, 0x00	; 0
    1170:	0f 90       	pop	r0
    1172:	0f 90       	pop	r0
    1174:	0f 90       	pop	r0
    1176:	0f 90       	pop	r0
    1178:	0f 90       	pop	r0
    117a:	df 91       	pop	r29
    117c:	cf 91       	pop	r28
    117e:	1f 91       	pop	r17
    1180:	0f 91       	pop	r16
    1182:	ff 90       	pop	r15
    1184:	df 90       	pop	r13
    1186:	cf 90       	pop	r12
    1188:	bf 90       	pop	r11
    118a:	af 90       	pop	r10
    118c:	08 95       	ret

0000118e <xQueueGenericSendFromISR>:
    118e:	ef 92       	push	r14
    1190:	ff 92       	push	r15
    1192:	1f 93       	push	r17
    1194:	cf 93       	push	r28
    1196:	df 93       	push	r29
    1198:	ec 01       	movw	r28, r24
    119a:	9a 8d       	ldd	r25, Y+26	; 0x1a
    119c:	8b 8d       	ldd	r24, Y+27	; 0x1b
    119e:	98 17       	cp	r25, r24
    11a0:	10 f0       	brcs	.+4      	; 0x11a6 <xQueueGenericSendFromISR+0x18>
    11a2:	22 30       	cpi	r18, 0x02	; 2
    11a4:	e1 f4       	brne	.+56     	; 0x11de <xQueueGenericSendFromISR+0x50>
    11a6:	7a 01       	movw	r14, r20
    11a8:	1e 8d       	ldd	r17, Y+30	; 0x1e
    11aa:	42 2f       	mov	r20, r18
    11ac:	ce 01       	movw	r24, r28
    11ae:	0e 94 1f 07 	call	0xe3e	; 0xe3e <prvCopyDataToQueue>
    11b2:	1f 3f       	cpi	r17, 0xFF	; 255
    11b4:	81 f4       	brne	.+32     	; 0x11d6 <xQueueGenericSendFromISR+0x48>
    11b6:	89 89       	ldd	r24, Y+17	; 0x11
    11b8:	88 23       	and	r24, r24
    11ba:	79 f0       	breq	.+30     	; 0x11da <xQueueGenericSendFromISR+0x4c>
    11bc:	ce 01       	movw	r24, r28
    11be:	41 96       	adiw	r24, 0x11	; 17
    11c0:	0e 94 e3 0e 	call	0x1dc6	; 0x1dc6 <xTaskRemoveFromEventList>
    11c4:	88 23       	and	r24, r24
    11c6:	49 f0       	breq	.+18     	; 0x11da <xQueueGenericSendFromISR+0x4c>
    11c8:	e1 14       	cp	r14, r1
    11ca:	f1 04       	cpc	r15, r1
    11cc:	31 f0       	breq	.+12     	; 0x11da <xQueueGenericSendFromISR+0x4c>
    11ce:	81 e0       	ldi	r24, 0x01	; 1
    11d0:	f7 01       	movw	r30, r14
    11d2:	80 83       	st	Z, r24
    11d4:	05 c0       	rjmp	.+10     	; 0x11e0 <xQueueGenericSendFromISR+0x52>
    11d6:	1f 5f       	subi	r17, 0xFF	; 255
    11d8:	1e 8f       	std	Y+30, r17	; 0x1e
    11da:	81 e0       	ldi	r24, 0x01	; 1
    11dc:	01 c0       	rjmp	.+2      	; 0x11e0 <xQueueGenericSendFromISR+0x52>
    11de:	80 e0       	ldi	r24, 0x00	; 0
    11e0:	df 91       	pop	r29
    11e2:	cf 91       	pop	r28
    11e4:	1f 91       	pop	r17
    11e6:	ff 90       	pop	r15
    11e8:	ef 90       	pop	r14
    11ea:	08 95       	ret

000011ec <xQueueReceive>:
    11ec:	af 92       	push	r10
    11ee:	bf 92       	push	r11
    11f0:	cf 92       	push	r12
    11f2:	df 92       	push	r13
    11f4:	ff 92       	push	r15
    11f6:	0f 93       	push	r16
    11f8:	1f 93       	push	r17
    11fa:	cf 93       	push	r28
    11fc:	df 93       	push	r29
    11fe:	00 d0       	rcall	.+0      	; 0x1200 <xQueueReceive+0x14>
    1200:	00 d0       	rcall	.+0      	; 0x1202 <xQueueReceive+0x16>
    1202:	1f 92       	push	r1
    1204:	cd b7       	in	r28, 0x3d	; 61
    1206:	de b7       	in	r29, 0x3e	; 62
    1208:	8c 01       	movw	r16, r24
    120a:	6b 01       	movw	r12, r22
    120c:	5d 83       	std	Y+5, r21	; 0x05
    120e:	4c 83       	std	Y+4, r20	; 0x04
    1210:	80 e0       	ldi	r24, 0x00	; 0
    1212:	58 01       	movw	r10, r16
    1214:	91 e1       	ldi	r25, 0x11	; 17
    1216:	a9 0e       	add	r10, r25
    1218:	b1 1c       	adc	r11, r1
    121a:	0f b6       	in	r0, 0x3f	; 63
    121c:	f8 94       	cli
    121e:	0f 92       	push	r0
    1220:	f8 01       	movw	r30, r16
    1222:	f2 8c       	ldd	r15, Z+26	; 0x1a
    1224:	ff 20       	and	r15, r15
    1226:	a9 f0       	breq	.+42     	; 0x1252 <xQueueReceive+0x66>
    1228:	b6 01       	movw	r22, r12
    122a:	c8 01       	movw	r24, r16
    122c:	0e 94 72 07 	call	0xee4	; 0xee4 <prvCopyDataFromQueue>
    1230:	fa 94       	dec	r15
    1232:	f8 01       	movw	r30, r16
    1234:	f2 8e       	std	Z+26, r15	; 0x1a
    1236:	80 85       	ldd	r24, Z+8	; 0x08
    1238:	88 23       	and	r24, r24
    123a:	39 f0       	breq	.+14     	; 0x124a <xQueueReceive+0x5e>
    123c:	c8 01       	movw	r24, r16
    123e:	08 96       	adiw	r24, 0x08	; 8
    1240:	0e 94 e3 0e 	call	0x1dc6	; 0x1dc6 <xTaskRemoveFromEventList>
    1244:	81 11       	cpse	r24, r1
    1246:	0e 94 69 15 	call	0x2ad2	; 0x2ad2 <vPortYield>
    124a:	0f 90       	pop	r0
    124c:	0f be       	out	0x3f, r0	; 63
    124e:	81 e0       	ldi	r24, 0x01	; 1
    1250:	50 c0       	rjmp	.+160    	; 0x12f2 <xQueueReceive+0x106>
    1252:	2c 81       	ldd	r18, Y+4	; 0x04
    1254:	3d 81       	ldd	r19, Y+5	; 0x05
    1256:	23 2b       	or	r18, r19
    1258:	19 f4       	brne	.+6      	; 0x1260 <xQueueReceive+0x74>
    125a:	0f 90       	pop	r0
    125c:	0f be       	out	0x3f, r0	; 63
    125e:	48 c0       	rjmp	.+144    	; 0x12f0 <xQueueReceive+0x104>
    1260:	81 11       	cpse	r24, r1
    1262:	04 c0       	rjmp	.+8      	; 0x126c <xQueueReceive+0x80>
    1264:	ce 01       	movw	r24, r28
    1266:	01 96       	adiw	r24, 0x01	; 1
    1268:	0e 94 23 0f 	call	0x1e46	; 0x1e46 <vTaskInternalSetTimeOutState>
    126c:	0f 90       	pop	r0
    126e:	0f be       	out	0x3f, r0	; 63
    1270:	0e 94 8e 0c 	call	0x191c	; 0x191c <vTaskSuspendAll>
    1274:	0f b6       	in	r0, 0x3f	; 63
    1276:	f8 94       	cli
    1278:	0f 92       	push	r0
    127a:	f8 01       	movw	r30, r16
    127c:	85 8d       	ldd	r24, Z+29	; 0x1d
    127e:	8f 3f       	cpi	r24, 0xFF	; 255
    1280:	09 f4       	brne	.+2      	; 0x1284 <xQueueReceive+0x98>
    1282:	15 8e       	std	Z+29, r1	; 0x1d
    1284:	f8 01       	movw	r30, r16
    1286:	86 8d       	ldd	r24, Z+30	; 0x1e
    1288:	8f 3f       	cpi	r24, 0xFF	; 255
    128a:	09 f4       	brne	.+2      	; 0x128e <xQueueReceive+0xa2>
    128c:	16 8e       	std	Z+30, r1	; 0x1e
    128e:	0f 90       	pop	r0
    1290:	0f be       	out	0x3f, r0	; 63
    1292:	be 01       	movw	r22, r28
    1294:	6c 5f       	subi	r22, 0xFC	; 252
    1296:	7f 4f       	sbci	r23, 0xFF	; 255
    1298:	ce 01       	movw	r24, r28
    129a:	01 96       	adiw	r24, 0x01	; 1
    129c:	0e 94 2e 0f 	call	0x1e5c	; 0x1e5c <xTaskCheckForTimeOut>
    12a0:	81 11       	cpse	r24, r1
    12a2:	1c c0       	rjmp	.+56     	; 0x12dc <xQueueReceive+0xf0>
    12a4:	c8 01       	movw	r24, r16
    12a6:	0e 94 14 07 	call	0xe28	; 0xe28 <prvIsQueueEmpty>
    12aa:	88 23       	and	r24, r24
    12ac:	89 f0       	breq	.+34     	; 0x12d0 <xQueueReceive+0xe4>
    12ae:	6c 81       	ldd	r22, Y+4	; 0x04
    12b0:	7d 81       	ldd	r23, Y+5	; 0x05
    12b2:	c5 01       	movw	r24, r10
    12b4:	0e 94 ba 0e 	call	0x1d74	; 0x1d74 <vTaskPlaceOnEventList>
    12b8:	c8 01       	movw	r24, r16
    12ba:	0e 94 8c 07 	call	0xf18	; 0xf18 <prvUnlockQueue>
    12be:	0e 94 4a 0d 	call	0x1a94	; 0x1a94 <xTaskResumeAll>
    12c2:	88 23       	and	r24, r24
    12c4:	11 f0       	breq	.+4      	; 0x12ca <xQueueReceive+0xde>
    12c6:	81 e0       	ldi	r24, 0x01	; 1
    12c8:	a8 cf       	rjmp	.-176    	; 0x121a <xQueueReceive+0x2e>
    12ca:	0e 94 69 15 	call	0x2ad2	; 0x2ad2 <vPortYield>
    12ce:	fb cf       	rjmp	.-10     	; 0x12c6 <xQueueReceive+0xda>
    12d0:	c8 01       	movw	r24, r16
    12d2:	0e 94 8c 07 	call	0xf18	; 0xf18 <prvUnlockQueue>
    12d6:	0e 94 4a 0d 	call	0x1a94	; 0x1a94 <xTaskResumeAll>
    12da:	f5 cf       	rjmp	.-22     	; 0x12c6 <xQueueReceive+0xda>
    12dc:	c8 01       	movw	r24, r16
    12de:	0e 94 8c 07 	call	0xf18	; 0xf18 <prvUnlockQueue>
    12e2:	0e 94 4a 0d 	call	0x1a94	; 0x1a94 <xTaskResumeAll>
    12e6:	c8 01       	movw	r24, r16
    12e8:	0e 94 14 07 	call	0xe28	; 0xe28 <prvIsQueueEmpty>
    12ec:	88 23       	and	r24, r24
    12ee:	59 f3       	breq	.-42     	; 0x12c6 <xQueueReceive+0xda>
    12f0:	80 e0       	ldi	r24, 0x00	; 0
    12f2:	0f 90       	pop	r0
    12f4:	0f 90       	pop	r0
    12f6:	0f 90       	pop	r0
    12f8:	0f 90       	pop	r0
    12fa:	0f 90       	pop	r0
    12fc:	df 91       	pop	r29
    12fe:	cf 91       	pop	r28
    1300:	1f 91       	pop	r17
    1302:	0f 91       	pop	r16
    1304:	ff 90       	pop	r15
    1306:	df 90       	pop	r13
    1308:	cf 90       	pop	r12
    130a:	bf 90       	pop	r11
    130c:	af 90       	pop	r10
    130e:	08 95       	ret

00001310 <xQueueSemaphoreTake>:
    1310:	cf 92       	push	r12
    1312:	df 92       	push	r13
    1314:	ff 92       	push	r15
    1316:	0f 93       	push	r16
    1318:	1f 93       	push	r17
    131a:	cf 93       	push	r28
    131c:	df 93       	push	r29
    131e:	00 d0       	rcall	.+0      	; 0x1320 <xQueueSemaphoreTake+0x10>
    1320:	00 d0       	rcall	.+0      	; 0x1322 <xQueueSemaphoreTake+0x12>
    1322:	1f 92       	push	r1
    1324:	cd b7       	in	r28, 0x3d	; 61
    1326:	de b7       	in	r29, 0x3e	; 62
    1328:	8c 01       	movw	r16, r24
    132a:	7d 83       	std	Y+5, r23	; 0x05
    132c:	6c 83       	std	Y+4, r22	; 0x04
    132e:	f1 2c       	mov	r15, r1
    1330:	90 e0       	ldi	r25, 0x00	; 0
    1332:	68 01       	movw	r12, r16
    1334:	81 e1       	ldi	r24, 0x11	; 17
    1336:	c8 0e       	add	r12, r24
    1338:	d1 1c       	adc	r13, r1
    133a:	0f b6       	in	r0, 0x3f	; 63
    133c:	f8 94       	cli
    133e:	0f 92       	push	r0
    1340:	d8 01       	movw	r26, r16
    1342:	5a 96       	adiw	r26, 0x1a	; 26
    1344:	8c 91       	ld	r24, X
    1346:	5a 97       	sbiw	r26, 0x1a	; 26
    1348:	88 23       	and	r24, r24
    134a:	e9 f0       	breq	.+58     	; 0x1386 <xQueueSemaphoreTake+0x76>
    134c:	81 50       	subi	r24, 0x01	; 1
    134e:	5a 96       	adiw	r26, 0x1a	; 26
    1350:	8c 93       	st	X, r24
    1352:	5a 97       	sbiw	r26, 0x1a	; 26
    1354:	8d 91       	ld	r24, X+
    1356:	9c 91       	ld	r25, X
    1358:	89 2b       	or	r24, r25
    135a:	29 f4       	brne	.+10     	; 0x1366 <xQueueSemaphoreTake+0x56>
    135c:	0e 94 57 10 	call	0x20ae	; 0x20ae <pvTaskIncrementMutexHeldCount>
    1360:	f8 01       	movw	r30, r16
    1362:	95 83       	std	Z+5, r25	; 0x05
    1364:	84 83       	std	Z+4, r24	; 0x04
    1366:	d8 01       	movw	r26, r16
    1368:	18 96       	adiw	r26, 0x08	; 8
    136a:	8c 91       	ld	r24, X
    136c:	88 23       	and	r24, r24
    136e:	39 f0       	breq	.+14     	; 0x137e <xQueueSemaphoreTake+0x6e>
    1370:	c8 01       	movw	r24, r16
    1372:	08 96       	adiw	r24, 0x08	; 8
    1374:	0e 94 e3 0e 	call	0x1dc6	; 0x1dc6 <xTaskRemoveFromEventList>
    1378:	81 11       	cpse	r24, r1
    137a:	0e 94 69 15 	call	0x2ad2	; 0x2ad2 <vPortYield>
    137e:	0f 90       	pop	r0
    1380:	0f be       	out	0x3f, r0	; 63
    1382:	81 e0       	ldi	r24, 0x01	; 1
    1384:	7a c0       	rjmp	.+244    	; 0x147a <xQueueSemaphoreTake+0x16a>
    1386:	2c 81       	ldd	r18, Y+4	; 0x04
    1388:	3d 81       	ldd	r19, Y+5	; 0x05
    138a:	23 2b       	or	r18, r19
    138c:	09 f4       	brne	.+2      	; 0x1390 <xQueueSemaphoreTake+0x80>
    138e:	72 c0       	rjmp	.+228    	; 0x1474 <xQueueSemaphoreTake+0x164>
    1390:	91 11       	cpse	r25, r1
    1392:	04 c0       	rjmp	.+8      	; 0x139c <xQueueSemaphoreTake+0x8c>
    1394:	ce 01       	movw	r24, r28
    1396:	01 96       	adiw	r24, 0x01	; 1
    1398:	0e 94 23 0f 	call	0x1e46	; 0x1e46 <vTaskInternalSetTimeOutState>
    139c:	0f 90       	pop	r0
    139e:	0f be       	out	0x3f, r0	; 63
    13a0:	0e 94 8e 0c 	call	0x191c	; 0x191c <vTaskSuspendAll>
    13a4:	0f b6       	in	r0, 0x3f	; 63
    13a6:	f8 94       	cli
    13a8:	0f 92       	push	r0
    13aa:	f8 01       	movw	r30, r16
    13ac:	85 8d       	ldd	r24, Z+29	; 0x1d
    13ae:	8f 3f       	cpi	r24, 0xFF	; 255
    13b0:	09 f4       	brne	.+2      	; 0x13b4 <xQueueSemaphoreTake+0xa4>
    13b2:	15 8e       	std	Z+29, r1	; 0x1d
    13b4:	d8 01       	movw	r26, r16
    13b6:	5e 96       	adiw	r26, 0x1e	; 30
    13b8:	8c 91       	ld	r24, X
    13ba:	5e 97       	sbiw	r26, 0x1e	; 30
    13bc:	8f 3f       	cpi	r24, 0xFF	; 255
    13be:	11 f4       	brne	.+4      	; 0x13c4 <xQueueSemaphoreTake+0xb4>
    13c0:	5e 96       	adiw	r26, 0x1e	; 30
    13c2:	1c 92       	st	X, r1
    13c4:	0f 90       	pop	r0
    13c6:	0f be       	out	0x3f, r0	; 63
    13c8:	be 01       	movw	r22, r28
    13ca:	6c 5f       	subi	r22, 0xFC	; 252
    13cc:	7f 4f       	sbci	r23, 0xFF	; 255
    13ce:	ce 01       	movw	r24, r28
    13d0:	01 96       	adiw	r24, 0x01	; 1
    13d2:	0e 94 2e 0f 	call	0x1e5c	; 0x1e5c <xTaskCheckForTimeOut>
    13d6:	81 11       	cpse	r24, r1
    13d8:	2b c0       	rjmp	.+86     	; 0x1430 <xQueueSemaphoreTake+0x120>
    13da:	c8 01       	movw	r24, r16
    13dc:	0e 94 14 07 	call	0xe28	; 0xe28 <prvIsQueueEmpty>
    13e0:	88 23       	and	r24, r24
    13e2:	01 f1       	breq	.+64     	; 0x1424 <xQueueSemaphoreTake+0x114>
    13e4:	f8 01       	movw	r30, r16
    13e6:	80 81       	ld	r24, Z
    13e8:	91 81       	ldd	r25, Z+1	; 0x01
    13ea:	89 2b       	or	r24, r25
    13ec:	51 f4       	brne	.+20     	; 0x1402 <xQueueSemaphoreTake+0xf2>
    13ee:	0f b6       	in	r0, 0x3f	; 63
    13f0:	f8 94       	cli
    13f2:	0f 92       	push	r0
    13f4:	84 81       	ldd	r24, Z+4	; 0x04
    13f6:	95 81       	ldd	r25, Z+5	; 0x05
    13f8:	0e 94 73 0f 	call	0x1ee6	; 0x1ee6 <xTaskPriorityInherit>
    13fc:	f8 2e       	mov	r15, r24
    13fe:	0f 90       	pop	r0
    1400:	0f be       	out	0x3f, r0	; 63
    1402:	6c 81       	ldd	r22, Y+4	; 0x04
    1404:	7d 81       	ldd	r23, Y+5	; 0x05
    1406:	c6 01       	movw	r24, r12
    1408:	0e 94 ba 0e 	call	0x1d74	; 0x1d74 <vTaskPlaceOnEventList>
    140c:	c8 01       	movw	r24, r16
    140e:	0e 94 8c 07 	call	0xf18	; 0xf18 <prvUnlockQueue>
    1412:	0e 94 4a 0d 	call	0x1a94	; 0x1a94 <xTaskResumeAll>
    1416:	88 23       	and	r24, r24
    1418:	11 f0       	breq	.+4      	; 0x141e <xQueueSemaphoreTake+0x10e>
    141a:	91 e0       	ldi	r25, 0x01	; 1
    141c:	8e cf       	rjmp	.-228    	; 0x133a <xQueueSemaphoreTake+0x2a>
    141e:	0e 94 69 15 	call	0x2ad2	; 0x2ad2 <vPortYield>
    1422:	fb cf       	rjmp	.-10     	; 0x141a <xQueueSemaphoreTake+0x10a>
    1424:	c8 01       	movw	r24, r16
    1426:	0e 94 8c 07 	call	0xf18	; 0xf18 <prvUnlockQueue>
    142a:	0e 94 4a 0d 	call	0x1a94	; 0x1a94 <xTaskResumeAll>
    142e:	f5 cf       	rjmp	.-22     	; 0x141a <xQueueSemaphoreTake+0x10a>
    1430:	c8 01       	movw	r24, r16
    1432:	0e 94 8c 07 	call	0xf18	; 0xf18 <prvUnlockQueue>
    1436:	0e 94 4a 0d 	call	0x1a94	; 0x1a94 <xTaskResumeAll>
    143a:	c8 01       	movw	r24, r16
    143c:	0e 94 14 07 	call	0xe28	; 0xe28 <prvIsQueueEmpty>
    1440:	88 23       	and	r24, r24
    1442:	59 f3       	breq	.-42     	; 0x141a <xQueueSemaphoreTake+0x10a>
    1444:	ff 20       	and	r15, r15
    1446:	c1 f0       	breq	.+48     	; 0x1478 <xQueueSemaphoreTake+0x168>
    1448:	0f b6       	in	r0, 0x3f	; 63
    144a:	f8 94       	cli
    144c:	0f 92       	push	r0
    144e:	f8 01       	movw	r30, r16
    1450:	81 89       	ldd	r24, Z+17	; 0x11
    1452:	88 23       	and	r24, r24
    1454:	39 f0       	breq	.+14     	; 0x1464 <xQueueSemaphoreTake+0x154>
    1456:	06 88       	ldd	r0, Z+22	; 0x16
    1458:	f7 89       	ldd	r31, Z+23	; 0x17
    145a:	e0 2d       	mov	r30, r0
    145c:	80 81       	ld	r24, Z
    145e:	64 e0       	ldi	r22, 0x04	; 4
    1460:	68 1b       	sub	r22, r24
    1462:	01 c0       	rjmp	.+2      	; 0x1466 <xQueueSemaphoreTake+0x156>
    1464:	60 e0       	ldi	r22, 0x00	; 0
    1466:	d8 01       	movw	r26, r16
    1468:	14 96       	adiw	r26, 0x04	; 4
    146a:	8d 91       	ld	r24, X+
    146c:	9c 91       	ld	r25, X
    146e:	15 97       	sbiw	r26, 0x05	; 5
    1470:	0e 94 10 10 	call	0x2020	; 0x2020 <vTaskPriorityDisinheritAfterTimeout>
    1474:	0f 90       	pop	r0
    1476:	0f be       	out	0x3f, r0	; 63
    1478:	80 e0       	ldi	r24, 0x00	; 0
    147a:	0f 90       	pop	r0
    147c:	0f 90       	pop	r0
    147e:	0f 90       	pop	r0
    1480:	0f 90       	pop	r0
    1482:	0f 90       	pop	r0
    1484:	df 91       	pop	r29
    1486:	cf 91       	pop	r28
    1488:	1f 91       	pop	r17
    148a:	0f 91       	pop	r16
    148c:	ff 90       	pop	r15
    148e:	df 90       	pop	r13
    1490:	cf 90       	pop	r12
    1492:	08 95       	ret

00001494 <vQueueWaitForMessageRestricted>:
/*-----------------------------------------------------------*/

#if ( configUSE_TIMERS == 1 )

    void vQueueWaitForMessageRestricted( QueueHandle_t xQueue, TickType_t xTicksToWait, const BaseType_t xWaitIndefinitely )
    {
    1494:	cf 93       	push	r28
    1496:	df 93       	push	r29
    1498:	ec 01       	movw	r28, r24
        will not actually cause the task to block, just place it on a blocked
        list.  It will not block until the scheduler is unlocked - at which
        time a yield will be performed.  If an item is added to the queue while
        the queue is locked, and the calling task blocks on the queue, then the
        calling task will be immediately unblocked when the queue is unlocked. */
        prvLockQueue( pxQueue );
    149a:	0f b6       	in	r0, 0x3f	; 63
    149c:	f8 94       	cli
    149e:	0f 92       	push	r0
    14a0:	8d 8d       	ldd	r24, Y+29	; 0x1d
    14a2:	8f 3f       	cpi	r24, 0xFF	; 255
    14a4:	09 f4       	brne	.+2      	; 0x14a8 <vQueueWaitForMessageRestricted+0x14>
    14a6:	1d 8e       	std	Y+29, r1	; 0x1d
    14a8:	8e 8d       	ldd	r24, Y+30	; 0x1e
    14aa:	8f 3f       	cpi	r24, 0xFF	; 255
    14ac:	09 f4       	brne	.+2      	; 0x14b0 <vQueueWaitForMessageRestricted+0x1c>
    14ae:	1e 8e       	std	Y+30, r1	; 0x1e
    14b0:	0f 90       	pop	r0
    14b2:	0f be       	out	0x3f, r0	; 63
        if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0U )
    14b4:	8a 8d       	ldd	r24, Y+26	; 0x1a
    14b6:	81 11       	cpse	r24, r1
    14b8:	04 c0       	rjmp	.+8      	; 0x14c2 <vQueueWaitForMessageRestricted+0x2e>
        {
            /* There is nothing in the queue, block for the specified period. */
            vTaskPlaceOnEventListRestricted( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait, xWaitIndefinitely );
    14ba:	ce 01       	movw	r24, r28
    14bc:	41 96       	adiw	r24, 0x11	; 17
    14be:	0e 94 cb 0e 	call	0x1d96	; 0x1d96 <vTaskPlaceOnEventListRestricted>
        }
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }
        prvUnlockQueue( pxQueue );
    14c2:	ce 01       	movw	r24, r28
    }
    14c4:	df 91       	pop	r29
    14c6:	cf 91       	pop	r28
        }
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }
        prvUnlockQueue( pxQueue );
    14c8:	0c 94 8c 07 	jmp	0xf18	; 0xf18 <prvUnlockQueue>

000014cc <prvResetNextTaskUnblockTime>:
    /* Reset the event list item to its normal value - so it can be used with
    queues and semaphores. */
    listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */

    return uxReturn;
}
    14cc:	e0 91 f1 02 	lds	r30, 0x02F1	; 0x8002f1 <pxDelayedTaskList>
    14d0:	f0 91 f2 02 	lds	r31, 0x02F2	; 0x8002f2 <pxDelayedTaskList+0x1>
    14d4:	80 81       	ld	r24, Z
    14d6:	81 11       	cpse	r24, r1
    14d8:	03 c0       	rjmp	.+6      	; 0x14e0 <prvResetNextTaskUnblockTime+0x14>
    14da:	8f ef       	ldi	r24, 0xFF	; 255
    14dc:	9f ef       	ldi	r25, 0xFF	; 255
    14de:	0c c0       	rjmp	.+24     	; 0x14f8 <prvResetNextTaskUnblockTime+0x2c>
    14e0:	e0 91 f1 02 	lds	r30, 0x02F1	; 0x8002f1 <pxDelayedTaskList>
    14e4:	f0 91 f2 02 	lds	r31, 0x02F2	; 0x8002f2 <pxDelayedTaskList+0x1>
    14e8:	05 80       	ldd	r0, Z+5	; 0x05
    14ea:	f6 81       	ldd	r31, Z+6	; 0x06
    14ec:	e0 2d       	mov	r30, r0
    14ee:	06 80       	ldd	r0, Z+6	; 0x06
    14f0:	f7 81       	ldd	r31, Z+7	; 0x07
    14f2:	e0 2d       	mov	r30, r0
    14f4:	82 81       	ldd	r24, Z+2	; 0x02
    14f6:	93 81       	ldd	r25, Z+3	; 0x03
    14f8:	90 93 c9 02 	sts	0x02C9, r25	; 0x8002c9 <xNextTaskUnblockTime+0x1>
    14fc:	80 93 c8 02 	sts	0x02C8, r24	; 0x8002c8 <xNextTaskUnblockTime>
    1500:	08 95       	ret

00001502 <prvAddCurrentTaskToDelayedList>:
    1502:	ff 92       	push	r15
    1504:	0f 93       	push	r16
    1506:	1f 93       	push	r17
    1508:	cf 93       	push	r28
    150a:	df 93       	push	r29
    150c:	ec 01       	movw	r28, r24
    150e:	f6 2e       	mov	r15, r22
    1510:	00 91 d0 02 	lds	r16, 0x02D0	; 0x8002d0 <xTickCount>
    1514:	10 91 d1 02 	lds	r17, 0x02D1	; 0x8002d1 <xTickCount+0x1>
    1518:	80 91 29 03 	lds	r24, 0x0329	; 0x800329 <pxCurrentTCB>
    151c:	90 91 2a 03 	lds	r25, 0x032A	; 0x80032a <pxCurrentTCB+0x1>
    1520:	02 96       	adiw	r24, 0x02	; 2
    1522:	0e 94 a1 14 	call	0x2942	; 0x2942 <uxListRemove>
    1526:	cf 3f       	cpi	r28, 0xFF	; 255
    1528:	8f ef       	ldi	r24, 0xFF	; 255
    152a:	d8 07       	cpc	r29, r24
    152c:	89 f4       	brne	.+34     	; 0x1550 <prvAddCurrentTaskToDelayedList+0x4e>
    152e:	ff 20       	and	r15, r15
    1530:	79 f0       	breq	.+30     	; 0x1550 <prvAddCurrentTaskToDelayedList+0x4e>
    1532:	60 91 29 03 	lds	r22, 0x0329	; 0x800329 <pxCurrentTCB>
    1536:	70 91 2a 03 	lds	r23, 0x032A	; 0x80032a <pxCurrentTCB+0x1>
    153a:	6e 5f       	subi	r22, 0xFE	; 254
    153c:	7f 4f       	sbci	r23, 0xFF	; 255
    153e:	83 ed       	ldi	r24, 0xD3	; 211
    1540:	92 e0       	ldi	r25, 0x02	; 2
    1542:	df 91       	pop	r29
    1544:	cf 91       	pop	r28
    1546:	1f 91       	pop	r17
    1548:	0f 91       	pop	r16
    154a:	ff 90       	pop	r15
    154c:	0c 94 48 14 	jmp	0x2890	; 0x2890 <vListInsertEnd>
    1550:	c0 0f       	add	r28, r16
    1552:	d1 1f       	adc	r29, r17
    1554:	e0 91 29 03 	lds	r30, 0x0329	; 0x800329 <pxCurrentTCB>
    1558:	f0 91 2a 03 	lds	r31, 0x032A	; 0x80032a <pxCurrentTCB+0x1>
    155c:	d3 83       	std	Z+3, r29	; 0x03
    155e:	c2 83       	std	Z+2, r28	; 0x02
    1560:	60 91 29 03 	lds	r22, 0x0329	; 0x800329 <pxCurrentTCB>
    1564:	70 91 2a 03 	lds	r23, 0x032A	; 0x80032a <pxCurrentTCB+0x1>
    1568:	c0 17       	cp	r28, r16
    156a:	d1 07       	cpc	r29, r17
    156c:	68 f4       	brcc	.+26     	; 0x1588 <prvAddCurrentTaskToDelayedList+0x86>
    156e:	80 91 ef 02 	lds	r24, 0x02EF	; 0x8002ef <pxOverflowDelayedTaskList>
    1572:	90 91 f0 02 	lds	r25, 0x02F0	; 0x8002f0 <pxOverflowDelayedTaskList+0x1>
    1576:	6e 5f       	subi	r22, 0xFE	; 254
    1578:	7f 4f       	sbci	r23, 0xFF	; 255
    157a:	df 91       	pop	r29
    157c:	cf 91       	pop	r28
    157e:	1f 91       	pop	r17
    1580:	0f 91       	pop	r16
    1582:	ff 90       	pop	r15
    1584:	0c 94 69 14 	jmp	0x28d2	; 0x28d2 <vListInsert>
    1588:	80 91 f1 02 	lds	r24, 0x02F1	; 0x8002f1 <pxDelayedTaskList>
    158c:	90 91 f2 02 	lds	r25, 0x02F2	; 0x8002f2 <pxDelayedTaskList+0x1>
    1590:	6e 5f       	subi	r22, 0xFE	; 254
    1592:	7f 4f       	sbci	r23, 0xFF	; 255
    1594:	0e 94 69 14 	call	0x28d2	; 0x28d2 <vListInsert>
    1598:	80 91 c8 02 	lds	r24, 0x02C8	; 0x8002c8 <xNextTaskUnblockTime>
    159c:	90 91 c9 02 	lds	r25, 0x02C9	; 0x8002c9 <xNextTaskUnblockTime+0x1>
    15a0:	c8 17       	cp	r28, r24
    15a2:	d9 07       	cpc	r29, r25
    15a4:	20 f4       	brcc	.+8      	; 0x15ae <prvAddCurrentTaskToDelayedList+0xac>
    15a6:	d0 93 c9 02 	sts	0x02C9, r29	; 0x8002c9 <xNextTaskUnblockTime+0x1>
    15aa:	c0 93 c8 02 	sts	0x02C8, r28	; 0x8002c8 <xNextTaskUnblockTime>
    15ae:	df 91       	pop	r29
    15b0:	cf 91       	pop	r28
    15b2:	1f 91       	pop	r17
    15b4:	0f 91       	pop	r16
    15b6:	ff 90       	pop	r15
    15b8:	08 95       	ret

000015ba <prvIdleTask>:
    15ba:	80 91 dc 02 	lds	r24, 0x02DC	; 0x8002dc <uxDeletedTasksWaitingCleanUp>
    15be:	88 23       	and	r24, r24
    15c0:	09 f1       	breq	.+66     	; 0x1604 <prvIdleTask+0x4a>
    15c2:	0f b6       	in	r0, 0x3f	; 63
    15c4:	f8 94       	cli
    15c6:	0f 92       	push	r0
    15c8:	e0 91 e2 02 	lds	r30, 0x02E2	; 0x8002e2 <xTasksWaitingTermination+0x5>
    15cc:	f0 91 e3 02 	lds	r31, 0x02E3	; 0x8002e3 <xTasksWaitingTermination+0x6>
    15d0:	c6 81       	ldd	r28, Z+6	; 0x06
    15d2:	d7 81       	ldd	r29, Z+7	; 0x07
    15d4:	ce 01       	movw	r24, r28
    15d6:	02 96       	adiw	r24, 0x02	; 2
    15d8:	0e 94 a1 14 	call	0x2942	; 0x2942 <uxListRemove>
    15dc:	80 91 d2 02 	lds	r24, 0x02D2	; 0x8002d2 <uxCurrentNumberOfTasks>
    15e0:	81 50       	subi	r24, 0x01	; 1
    15e2:	80 93 d2 02 	sts	0x02D2, r24	; 0x8002d2 <uxCurrentNumberOfTasks>
    15e6:	80 91 dc 02 	lds	r24, 0x02DC	; 0x8002dc <uxDeletedTasksWaitingCleanUp>
    15ea:	81 50       	subi	r24, 0x01	; 1
    15ec:	80 93 dc 02 	sts	0x02DC, r24	; 0x8002dc <uxDeletedTasksWaitingCleanUp>
    15f0:	0f 90       	pop	r0
    15f2:	0f be       	out	0x3f, r0	; 63
    15f4:	8f 89       	ldd	r24, Y+23	; 0x17
    15f6:	98 8d       	ldd	r25, Y+24	; 0x18
    15f8:	0e 94 25 14 	call	0x284a	; 0x284a <vPortFree>
    15fc:	ce 01       	movw	r24, r28
    15fe:	0e 94 25 14 	call	0x284a	; 0x284a <vPortFree>
    1602:	db cf       	rjmp	.-74     	; 0x15ba <prvIdleTask>
    1604:	80 91 05 03 	lds	r24, 0x0305	; 0x800305 <pxReadyTasksLists>
    1608:	82 30       	cpi	r24, 0x02	; 2
    160a:	10 f0       	brcs	.+4      	; 0x1610 <prvIdleTask+0x56>
    160c:	0e 94 69 15 	call	0x2ad2	; 0x2ad2 <vPortYield>
    1610:	0e 94 74 12 	call	0x24e8	; 0x24e8 <vApplicationIdleHook>
    1614:	d2 cf       	rjmp	.-92     	; 0x15ba <prvIdleTask>

00001616 <xTaskCreate>:
    1616:	5f 92       	push	r5
    1618:	6f 92       	push	r6
    161a:	7f 92       	push	r7
    161c:	8f 92       	push	r8
    161e:	9f 92       	push	r9
    1620:	af 92       	push	r10
    1622:	bf 92       	push	r11
    1624:	cf 92       	push	r12
    1626:	df 92       	push	r13
    1628:	ef 92       	push	r14
    162a:	ff 92       	push	r15
    162c:	0f 93       	push	r16
    162e:	1f 93       	push	r17
    1630:	cf 93       	push	r28
    1632:	df 93       	push	r29
    1634:	3c 01       	movw	r6, r24
    1636:	6b 01       	movw	r12, r22
    1638:	5a 01       	movw	r10, r20
    163a:	49 01       	movw	r8, r18
    163c:	50 2e       	mov	r5, r16
    163e:	ca 01       	movw	r24, r20
    1640:	0e 94 12 14 	call	0x2824	; 0x2824 <pvPortMalloc>
    1644:	8c 01       	movw	r16, r24
    1646:	89 2b       	or	r24, r25
    1648:	09 f4       	brne	.+2      	; 0x164c <xTaskCreate+0x36>
    164a:	e0 c0       	rjmp	.+448    	; 0x180c <xTaskCreate+0x1f6>
    164c:	88 e2       	ldi	r24, 0x28	; 40
    164e:	90 e0       	ldi	r25, 0x00	; 0
    1650:	0e 94 12 14 	call	0x2824	; 0x2824 <pvPortMalloc>
    1654:	ec 01       	movw	r28, r24
    1656:	89 2b       	or	r24, r25
    1658:	c9 f0       	breq	.+50     	; 0x168c <xTaskCreate+0x76>
    165a:	18 8f       	std	Y+24, r17	; 0x18
    165c:	0f 8b       	std	Y+23, r16	; 0x17
    165e:	a5 01       	movw	r20, r10
    1660:	65 ea       	ldi	r22, 0xA5	; 165
    1662:	70 e0       	ldi	r23, 0x00	; 0
    1664:	c8 01       	movw	r24, r16
    1666:	0e 94 eb 18 	call	0x31d6	; 0x31d6 <memset>
    166a:	21 e0       	ldi	r18, 0x01	; 1
    166c:	a2 1a       	sub	r10, r18
    166e:	b1 08       	sbc	r11, r1
    1670:	8f 89       	ldd	r24, Y+23	; 0x17
    1672:	98 8d       	ldd	r25, Y+24	; 0x18
    1674:	a8 0e       	add	r10, r24
    1676:	b9 1e       	adc	r11, r25
    1678:	c1 14       	cp	r12, r1
    167a:	d1 04       	cpc	r13, r1
    167c:	c9 f0       	breq	.+50     	; 0x16b0 <xTaskCreate+0x9a>
    167e:	be 01       	movw	r22, r28
    1680:	67 5e       	subi	r22, 0xE7	; 231
    1682:	7f 4f       	sbci	r23, 0xFF	; 255
    1684:	f6 01       	movw	r30, r12
    1686:	c6 01       	movw	r24, r12
    1688:	08 96       	adiw	r24, 0x08	; 8
    168a:	07 c0       	rjmp	.+14     	; 0x169a <xTaskCreate+0x84>
    168c:	c8 01       	movw	r24, r16
    168e:	0e 94 25 14 	call	0x284a	; 0x284a <vPortFree>
    1692:	bc c0       	rjmp	.+376    	; 0x180c <xTaskCreate+0x1f6>
    1694:	e8 17       	cp	r30, r24
    1696:	f9 07       	cpc	r31, r25
    1698:	49 f0       	breq	.+18     	; 0x16ac <xTaskCreate+0x96>
    169a:	9f 01       	movw	r18, r30
    169c:	41 91       	ld	r20, Z+
    169e:	db 01       	movw	r26, r22
    16a0:	4d 93       	st	X+, r20
    16a2:	bd 01       	movw	r22, r26
    16a4:	d9 01       	movw	r26, r18
    16a6:	2c 91       	ld	r18, X
    16a8:	21 11       	cpse	r18, r1
    16aa:	f4 cf       	rjmp	.-24     	; 0x1694 <xTaskCreate+0x7e>
    16ac:	18 a2       	std	Y+32, r1	; 0x20
    16ae:	01 c0       	rjmp	.+2      	; 0x16b2 <xTaskCreate+0x9c>
    16b0:	19 8e       	std	Y+25, r1	; 0x19
    16b2:	05 2d       	mov	r16, r5
    16b4:	04 30       	cpi	r16, 0x04	; 4
    16b6:	08 f0       	brcs	.+2      	; 0x16ba <xTaskCreate+0xa4>
    16b8:	03 e0       	ldi	r16, 0x03	; 3
    16ba:	0e 8b       	std	Y+22, r16	; 0x16
    16bc:	09 a3       	std	Y+33, r16	; 0x21
    16be:	1a a2       	std	Y+34, r1	; 0x22
    16c0:	6e 01       	movw	r12, r28
    16c2:	b2 e0       	ldi	r27, 0x02	; 2
    16c4:	cb 0e       	add	r12, r27
    16c6:	d1 1c       	adc	r13, r1
    16c8:	c6 01       	movw	r24, r12
    16ca:	0e 94 44 14 	call	0x2888	; 0x2888 <vListInitialiseItem>
    16ce:	ce 01       	movw	r24, r28
    16d0:	0c 96       	adiw	r24, 0x0c	; 12
    16d2:	0e 94 44 14 	call	0x2888	; 0x2888 <vListInitialiseItem>
    16d6:	d9 87       	std	Y+9, r29	; 0x09
    16d8:	c8 87       	std	Y+8, r28	; 0x08
    16da:	84 e0       	ldi	r24, 0x04	; 4
    16dc:	90 e0       	ldi	r25, 0x00	; 0
    16de:	80 1b       	sub	r24, r16
    16e0:	91 09       	sbc	r25, r1
    16e2:	9d 87       	std	Y+13, r25	; 0x0d
    16e4:	8c 87       	std	Y+12, r24	; 0x0c
    16e6:	db 8b       	std	Y+19, r29	; 0x13
    16e8:	ca 8b       	std	Y+18, r28	; 0x12
    16ea:	1b a2       	std	Y+35, r1	; 0x23
    16ec:	1c a2       	std	Y+36, r1	; 0x24
    16ee:	1d a2       	std	Y+37, r1	; 0x25
    16f0:	1e a2       	std	Y+38, r1	; 0x26
    16f2:	1f a2       	std	Y+39, r1	; 0x27
    16f4:	a4 01       	movw	r20, r8
    16f6:	b3 01       	movw	r22, r6
    16f8:	c5 01       	movw	r24, r10
    16fa:	0e 94 c5 14 	call	0x298a	; 0x298a <pxPortInitialiseStack>
    16fe:	99 83       	std	Y+1, r25	; 0x01
    1700:	88 83       	st	Y, r24
    1702:	e1 14       	cp	r14, r1
    1704:	f1 04       	cpc	r15, r1
    1706:	19 f0       	breq	.+6      	; 0x170e <xTaskCreate+0xf8>
    1708:	f7 01       	movw	r30, r14
    170a:	d1 83       	std	Z+1, r29	; 0x01
    170c:	c0 83       	st	Z, r28
    170e:	0f b6       	in	r0, 0x3f	; 63
    1710:	f8 94       	cli
    1712:	0f 92       	push	r0
    1714:	80 91 d2 02 	lds	r24, 0x02D2	; 0x8002d2 <uxCurrentNumberOfTasks>
    1718:	8f 5f       	subi	r24, 0xFF	; 255
    171a:	80 93 d2 02 	sts	0x02D2, r24	; 0x8002d2 <uxCurrentNumberOfTasks>
    171e:	80 91 29 03 	lds	r24, 0x0329	; 0x800329 <pxCurrentTCB>
    1722:	90 91 2a 03 	lds	r25, 0x032A	; 0x80032a <pxCurrentTCB+0x1>
    1726:	89 2b       	or	r24, r25
    1728:	d1 f5       	brne	.+116    	; 0x179e <xTaskCreate+0x188>
    172a:	d0 93 2a 03 	sts	0x032A, r29	; 0x80032a <pxCurrentTCB+0x1>
    172e:	c0 93 29 03 	sts	0x0329, r28	; 0x800329 <pxCurrentTCB>
    1732:	80 91 d2 02 	lds	r24, 0x02D2	; 0x8002d2 <uxCurrentNumberOfTasks>
    1736:	81 30       	cpi	r24, 0x01	; 1
    1738:	09 f0       	breq	.+2      	; 0x173c <xTaskCreate+0x126>
    173a:	41 c0       	rjmp	.+130    	; 0x17be <xTaskCreate+0x1a8>
    173c:	85 e0       	ldi	r24, 0x05	; 5
    173e:	93 e0       	ldi	r25, 0x03	; 3
    1740:	0e 94 36 14 	call	0x286c	; 0x286c <vListInitialise>
    1744:	8e e0       	ldi	r24, 0x0E	; 14
    1746:	93 e0       	ldi	r25, 0x03	; 3
    1748:	0e 94 36 14 	call	0x286c	; 0x286c <vListInitialise>
    174c:	87 e1       	ldi	r24, 0x17	; 23
    174e:	93 e0       	ldi	r25, 0x03	; 3
    1750:	0e 94 36 14 	call	0x286c	; 0x286c <vListInitialise>
    1754:	80 e2       	ldi	r24, 0x20	; 32
    1756:	93 e0       	ldi	r25, 0x03	; 3
    1758:	0e 94 36 14 	call	0x286c	; 0x286c <vListInitialise>
    175c:	8c ef       	ldi	r24, 0xFC	; 252
    175e:	92 e0       	ldi	r25, 0x02	; 2
    1760:	0e 94 36 14 	call	0x286c	; 0x286c <vListInitialise>
    1764:	83 ef       	ldi	r24, 0xF3	; 243
    1766:	92 e0       	ldi	r25, 0x02	; 2
    1768:	0e 94 36 14 	call	0x286c	; 0x286c <vListInitialise>
    176c:	86 ee       	ldi	r24, 0xE6	; 230
    176e:	92 e0       	ldi	r25, 0x02	; 2
    1770:	0e 94 36 14 	call	0x286c	; 0x286c <vListInitialise>
    1774:	8d ed       	ldi	r24, 0xDD	; 221
    1776:	92 e0       	ldi	r25, 0x02	; 2
    1778:	0e 94 36 14 	call	0x286c	; 0x286c <vListInitialise>
    177c:	83 ed       	ldi	r24, 0xD3	; 211
    177e:	92 e0       	ldi	r25, 0x02	; 2
    1780:	0e 94 36 14 	call	0x286c	; 0x286c <vListInitialise>
    1784:	8c ef       	ldi	r24, 0xFC	; 252
    1786:	92 e0       	ldi	r25, 0x02	; 2
    1788:	90 93 f2 02 	sts	0x02F2, r25	; 0x8002f2 <pxDelayedTaskList+0x1>
    178c:	80 93 f1 02 	sts	0x02F1, r24	; 0x8002f1 <pxDelayedTaskList>
    1790:	83 ef       	ldi	r24, 0xF3	; 243
    1792:	92 e0       	ldi	r25, 0x02	; 2
    1794:	90 93 f0 02 	sts	0x02F0, r25	; 0x8002f0 <pxOverflowDelayedTaskList+0x1>
    1798:	80 93 ef 02 	sts	0x02EF, r24	; 0x8002ef <pxOverflowDelayedTaskList>
    179c:	10 c0       	rjmp	.+32     	; 0x17be <xTaskCreate+0x1a8>
    179e:	80 91 ce 02 	lds	r24, 0x02CE	; 0x8002ce <xSchedulerRunning>
    17a2:	81 11       	cpse	r24, r1
    17a4:	0c c0       	rjmp	.+24     	; 0x17be <xTaskCreate+0x1a8>
    17a6:	e0 91 29 03 	lds	r30, 0x0329	; 0x800329 <pxCurrentTCB>
    17aa:	f0 91 2a 03 	lds	r31, 0x032A	; 0x80032a <pxCurrentTCB+0x1>
    17ae:	96 89       	ldd	r25, Z+22	; 0x16
    17b0:	8e 89       	ldd	r24, Y+22	; 0x16
    17b2:	89 17       	cp	r24, r25
    17b4:	20 f0       	brcs	.+8      	; 0x17be <xTaskCreate+0x1a8>
    17b6:	d0 93 2a 03 	sts	0x032A, r29	; 0x80032a <pxCurrentTCB+0x1>
    17ba:	c0 93 29 03 	sts	0x0329, r28	; 0x800329 <pxCurrentTCB>
    17be:	80 91 ca 02 	lds	r24, 0x02CA	; 0x8002ca <uxTaskNumber>
    17c2:	8f 5f       	subi	r24, 0xFF	; 255
    17c4:	80 93 ca 02 	sts	0x02CA, r24	; 0x8002ca <uxTaskNumber>
    17c8:	8e 89       	ldd	r24, Y+22	; 0x16
    17ca:	90 91 cf 02 	lds	r25, 0x02CF	; 0x8002cf <uxTopReadyPriority>
    17ce:	98 17       	cp	r25, r24
    17d0:	10 f4       	brcc	.+4      	; 0x17d6 <xTaskCreate+0x1c0>
    17d2:	80 93 cf 02 	sts	0x02CF, r24	; 0x8002cf <uxTopReadyPriority>
    17d6:	f9 e0       	ldi	r31, 0x09	; 9
    17d8:	8f 9f       	mul	r24, r31
    17da:	c0 01       	movw	r24, r0
    17dc:	11 24       	eor	r1, r1
    17de:	b6 01       	movw	r22, r12
    17e0:	8b 5f       	subi	r24, 0xFB	; 251
    17e2:	9c 4f       	sbci	r25, 0xFC	; 252
    17e4:	0e 94 48 14 	call	0x2890	; 0x2890 <vListInsertEnd>
    17e8:	0f 90       	pop	r0
    17ea:	0f be       	out	0x3f, r0	; 63
    17ec:	80 91 ce 02 	lds	r24, 0x02CE	; 0x8002ce <xSchedulerRunning>
    17f0:	88 23       	and	r24, r24
    17f2:	51 f0       	breq	.+20     	; 0x1808 <xTaskCreate+0x1f2>
    17f4:	e0 91 29 03 	lds	r30, 0x0329	; 0x800329 <pxCurrentTCB>
    17f8:	f0 91 2a 03 	lds	r31, 0x032A	; 0x80032a <pxCurrentTCB+0x1>
    17fc:	96 89       	ldd	r25, Z+22	; 0x16
    17fe:	8e 89       	ldd	r24, Y+22	; 0x16
    1800:	98 17       	cp	r25, r24
    1802:	10 f4       	brcc	.+4      	; 0x1808 <xTaskCreate+0x1f2>
    1804:	0e 94 69 15 	call	0x2ad2	; 0x2ad2 <vPortYield>
    1808:	81 e0       	ldi	r24, 0x01	; 1
    180a:	01 c0       	rjmp	.+2      	; 0x180e <xTaskCreate+0x1f8>
    180c:	8f ef       	ldi	r24, 0xFF	; 255
    180e:	df 91       	pop	r29
    1810:	cf 91       	pop	r28
    1812:	1f 91       	pop	r17
    1814:	0f 91       	pop	r16
    1816:	ff 90       	pop	r15
    1818:	ef 90       	pop	r14
    181a:	df 90       	pop	r13
    181c:	cf 90       	pop	r12
    181e:	bf 90       	pop	r11
    1820:	af 90       	pop	r10
    1822:	9f 90       	pop	r9
    1824:	8f 90       	pop	r8
    1826:	7f 90       	pop	r7
    1828:	6f 90       	pop	r6
    182a:	5f 90       	pop	r5
    182c:	08 95       	ret

0000182e <vTaskResume>:
    182e:	0f 93       	push	r16
    1830:	1f 93       	push	r17
    1832:	cf 93       	push	r28
    1834:	df 93       	push	r29
    1836:	20 91 29 03 	lds	r18, 0x0329	; 0x800329 <pxCurrentTCB>
    183a:	30 91 2a 03 	lds	r19, 0x032A	; 0x80032a <pxCurrentTCB+0x1>
    183e:	82 17       	cp	r24, r18
    1840:	93 07       	cpc	r25, r19
    1842:	09 f4       	brne	.+2      	; 0x1846 <vTaskResume+0x18>
    1844:	38 c0       	rjmp	.+112    	; 0x18b6 <vTaskResume+0x88>
    1846:	00 97       	sbiw	r24, 0x00	; 0
    1848:	09 f4       	brne	.+2      	; 0x184c <vTaskResume+0x1e>
    184a:	35 c0       	rjmp	.+106    	; 0x18b6 <vTaskResume+0x88>
    184c:	0f b6       	in	r0, 0x3f	; 63
    184e:	f8 94       	cli
    1850:	0f 92       	push	r0
    1852:	fc 01       	movw	r30, r24
    1854:	22 85       	ldd	r18, Z+10	; 0x0a
    1856:	33 85       	ldd	r19, Z+11	; 0x0b
    1858:	23 5d       	subi	r18, 0xD3	; 211
    185a:	32 40       	sbci	r19, 0x02	; 2
    185c:	51 f5       	brne	.+84     	; 0x18b2 <vTaskResume+0x84>
    185e:	fc 01       	movw	r30, r24
    1860:	24 89       	ldd	r18, Z+20	; 0x14
    1862:	35 89       	ldd	r19, Z+21	; 0x15
    1864:	f2 e0       	ldi	r31, 0x02	; 2
    1866:	26 3e       	cpi	r18, 0xE6	; 230
    1868:	3f 07       	cpc	r19, r31
    186a:	19 f1       	breq	.+70     	; 0x18b2 <vTaskResume+0x84>
    186c:	23 2b       	or	r18, r19
    186e:	09 f5       	brne	.+66     	; 0x18b2 <vTaskResume+0x84>
    1870:	ec 01       	movw	r28, r24
    1872:	8c 01       	movw	r16, r24
    1874:	0e 5f       	subi	r16, 0xFE	; 254
    1876:	1f 4f       	sbci	r17, 0xFF	; 255
    1878:	c8 01       	movw	r24, r16
    187a:	0e 94 a1 14 	call	0x2942	; 0x2942 <uxListRemove>
    187e:	8e 89       	ldd	r24, Y+22	; 0x16
    1880:	90 91 cf 02 	lds	r25, 0x02CF	; 0x8002cf <uxTopReadyPriority>
    1884:	98 17       	cp	r25, r24
    1886:	10 f4       	brcc	.+4      	; 0x188c <vTaskResume+0x5e>
    1888:	80 93 cf 02 	sts	0x02CF, r24	; 0x8002cf <uxTopReadyPriority>
    188c:	29 e0       	ldi	r18, 0x09	; 9
    188e:	82 9f       	mul	r24, r18
    1890:	c0 01       	movw	r24, r0
    1892:	11 24       	eor	r1, r1
    1894:	b8 01       	movw	r22, r16
    1896:	8b 5f       	subi	r24, 0xFB	; 251
    1898:	9c 4f       	sbci	r25, 0xFC	; 252
    189a:	0e 94 48 14 	call	0x2890	; 0x2890 <vListInsertEnd>
    189e:	e0 91 29 03 	lds	r30, 0x0329	; 0x800329 <pxCurrentTCB>
    18a2:	f0 91 2a 03 	lds	r31, 0x032A	; 0x80032a <pxCurrentTCB+0x1>
    18a6:	9e 89       	ldd	r25, Y+22	; 0x16
    18a8:	86 89       	ldd	r24, Z+22	; 0x16
    18aa:	98 17       	cp	r25, r24
    18ac:	10 f0       	brcs	.+4      	; 0x18b2 <vTaskResume+0x84>
    18ae:	0e 94 69 15 	call	0x2ad2	; 0x2ad2 <vPortYield>
    18b2:	0f 90       	pop	r0
    18b4:	0f be       	out	0x3f, r0	; 63
    18b6:	df 91       	pop	r29
    18b8:	cf 91       	pop	r28
    18ba:	1f 91       	pop	r17
    18bc:	0f 91       	pop	r16
    18be:	08 95       	ret

000018c0 <vTaskStartScheduler>:
    18c0:	ef 92       	push	r14
    18c2:	ff 92       	push	r15
    18c4:	0f 93       	push	r16
    18c6:	86 ec       	ldi	r24, 0xC6	; 198
    18c8:	e8 2e       	mov	r14, r24
    18ca:	82 e0       	ldi	r24, 0x02	; 2
    18cc:	f8 2e       	mov	r15, r24
    18ce:	00 e0       	ldi	r16, 0x00	; 0
    18d0:	20 e0       	ldi	r18, 0x00	; 0
    18d2:	30 e0       	ldi	r19, 0x00	; 0
    18d4:	40 ec       	ldi	r20, 0xC0	; 192
    18d6:	50 e0       	ldi	r21, 0x00	; 0
    18d8:	63 e4       	ldi	r22, 0x43	; 67
    18da:	71 e0       	ldi	r23, 0x01	; 1
    18dc:	8d ed       	ldi	r24, 0xDD	; 221
    18de:	9a e0       	ldi	r25, 0x0A	; 10
    18e0:	0e 94 0b 0b 	call	0x1616	; 0x1616 <xTaskCreate>
    18e4:	81 30       	cpi	r24, 0x01	; 1
    18e6:	b1 f4       	brne	.+44     	; 0x1914 <vTaskStartScheduler+0x54>
    18e8:	0e 94 bc 10 	call	0x2178	; 0x2178 <xTimerCreateTimerTask>
    18ec:	81 30       	cpi	r24, 0x01	; 1
    18ee:	91 f4       	brne	.+36     	; 0x1914 <vTaskStartScheduler+0x54>
    18f0:	f8 94       	cli
    18f2:	2f ef       	ldi	r18, 0xFF	; 255
    18f4:	3f ef       	ldi	r19, 0xFF	; 255
    18f6:	30 93 c9 02 	sts	0x02C9, r19	; 0x8002c9 <xNextTaskUnblockTime+0x1>
    18fa:	20 93 c8 02 	sts	0x02C8, r18	; 0x8002c8 <xNextTaskUnblockTime>
    18fe:	80 93 ce 02 	sts	0x02CE, r24	; 0x8002ce <xSchedulerRunning>
    1902:	10 92 d1 02 	sts	0x02D1, r1	; 0x8002d1 <xTickCount+0x1>
    1906:	10 92 d0 02 	sts	0x02D0, r1	; 0x8002d0 <xTickCount>
    190a:	0f 91       	pop	r16
    190c:	ff 90       	pop	r15
    190e:	ef 90       	pop	r14
    1910:	0c 94 31 15 	jmp	0x2a62	; 0x2a62 <xPortStartScheduler>
    1914:	0f 91       	pop	r16
    1916:	ff 90       	pop	r15
    1918:	ef 90       	pop	r14
    191a:	08 95       	ret

0000191c <vTaskSuspendAll>:
    191c:	80 91 c5 02 	lds	r24, 0x02C5	; 0x8002c5 <uxSchedulerSuspended>
    1920:	8f 5f       	subi	r24, 0xFF	; 255
    1922:	80 93 c5 02 	sts	0x02C5, r24	; 0x8002c5 <uxSchedulerSuspended>
    1926:	08 95       	ret

00001928 <xTaskGetTickCount>:
    1928:	0f b6       	in	r0, 0x3f	; 63
    192a:	f8 94       	cli
    192c:	0f 92       	push	r0
    192e:	80 91 d0 02 	lds	r24, 0x02D0	; 0x8002d0 <xTickCount>
    1932:	90 91 d1 02 	lds	r25, 0x02D1	; 0x8002d1 <xTickCount+0x1>
    1936:	0f 90       	pop	r0
    1938:	0f be       	out	0x3f, r0	; 63
    193a:	08 95       	ret

0000193c <xTaskIncrementTick>:
    193c:	cf 92       	push	r12
    193e:	df 92       	push	r13
    1940:	ef 92       	push	r14
    1942:	ff 92       	push	r15
    1944:	0f 93       	push	r16
    1946:	1f 93       	push	r17
    1948:	cf 93       	push	r28
    194a:	df 93       	push	r29
    194c:	80 91 c5 02 	lds	r24, 0x02C5	; 0x8002c5 <uxSchedulerSuspended>
    1950:	81 11       	cpse	r24, r1
    1952:	8c c0       	rjmp	.+280    	; 0x1a6c <xTaskIncrementTick+0x130>
    1954:	00 91 d0 02 	lds	r16, 0x02D0	; 0x8002d0 <xTickCount>
    1958:	10 91 d1 02 	lds	r17, 0x02D1	; 0x8002d1 <xTickCount+0x1>
    195c:	0f 5f       	subi	r16, 0xFF	; 255
    195e:	1f 4f       	sbci	r17, 0xFF	; 255
    1960:	10 93 d1 02 	sts	0x02D1, r17	; 0x8002d1 <xTickCount+0x1>
    1964:	00 93 d0 02 	sts	0x02D0, r16	; 0x8002d0 <xTickCount>
    1968:	01 15       	cp	r16, r1
    196a:	11 05       	cpc	r17, r1
    196c:	b9 f4       	brne	.+46     	; 0x199c <xTaskIncrementTick+0x60>
    196e:	80 91 f1 02 	lds	r24, 0x02F1	; 0x8002f1 <pxDelayedTaskList>
    1972:	90 91 f2 02 	lds	r25, 0x02F2	; 0x8002f2 <pxDelayedTaskList+0x1>
    1976:	20 91 ef 02 	lds	r18, 0x02EF	; 0x8002ef <pxOverflowDelayedTaskList>
    197a:	30 91 f0 02 	lds	r19, 0x02F0	; 0x8002f0 <pxOverflowDelayedTaskList+0x1>
    197e:	30 93 f2 02 	sts	0x02F2, r19	; 0x8002f2 <pxDelayedTaskList+0x1>
    1982:	20 93 f1 02 	sts	0x02F1, r18	; 0x8002f1 <pxDelayedTaskList>
    1986:	90 93 f0 02 	sts	0x02F0, r25	; 0x8002f0 <pxOverflowDelayedTaskList+0x1>
    198a:	80 93 ef 02 	sts	0x02EF, r24	; 0x8002ef <pxOverflowDelayedTaskList>
    198e:	80 91 cb 02 	lds	r24, 0x02CB	; 0x8002cb <xNumOfOverflows>
    1992:	8f 5f       	subi	r24, 0xFF	; 255
    1994:	80 93 cb 02 	sts	0x02CB, r24	; 0x8002cb <xNumOfOverflows>
    1998:	0e 94 66 0a 	call	0x14cc	; 0x14cc <prvResetNextTaskUnblockTime>
    199c:	80 91 c8 02 	lds	r24, 0x02C8	; 0x8002c8 <xNextTaskUnblockTime>
    19a0:	90 91 c9 02 	lds	r25, 0x02C9	; 0x8002c9 <xNextTaskUnblockTime+0x1>
    19a4:	c0 e0       	ldi	r28, 0x00	; 0
    19a6:	08 17       	cp	r16, r24
    19a8:	19 07       	cpc	r17, r25
    19aa:	08 f4       	brcc	.+2      	; 0x19ae <xTaskIncrementTick+0x72>
    19ac:	4f c0       	rjmp	.+158    	; 0x1a4c <xTaskIncrementTick+0x110>
    19ae:	d9 e0       	ldi	r29, 0x09	; 9
    19b0:	e0 91 f1 02 	lds	r30, 0x02F1	; 0x8002f1 <pxDelayedTaskList>
    19b4:	f0 91 f2 02 	lds	r31, 0x02F2	; 0x8002f2 <pxDelayedTaskList+0x1>
    19b8:	80 81       	ld	r24, Z
    19ba:	81 11       	cpse	r24, r1
    19bc:	03 c0       	rjmp	.+6      	; 0x19c4 <xTaskIncrementTick+0x88>
    19be:	8f ef       	ldi	r24, 0xFF	; 255
    19c0:	9f ef       	ldi	r25, 0xFF	; 255
    19c2:	11 c0       	rjmp	.+34     	; 0x19e6 <xTaskIncrementTick+0xaa>
    19c4:	e0 91 f1 02 	lds	r30, 0x02F1	; 0x8002f1 <pxDelayedTaskList>
    19c8:	f0 91 f2 02 	lds	r31, 0x02F2	; 0x8002f2 <pxDelayedTaskList+0x1>
    19cc:	05 80       	ldd	r0, Z+5	; 0x05
    19ce:	f6 81       	ldd	r31, Z+6	; 0x06
    19d0:	e0 2d       	mov	r30, r0
    19d2:	e6 80       	ldd	r14, Z+6	; 0x06
    19d4:	f7 80       	ldd	r15, Z+7	; 0x07
    19d6:	d7 01       	movw	r26, r14
    19d8:	12 96       	adiw	r26, 0x02	; 2
    19da:	8d 91       	ld	r24, X+
    19dc:	9c 91       	ld	r25, X
    19de:	13 97       	sbiw	r26, 0x03	; 3
    19e0:	08 17       	cp	r16, r24
    19e2:	19 07       	cpc	r17, r25
    19e4:	28 f4       	brcc	.+10     	; 0x19f0 <xTaskIncrementTick+0xb4>
    19e6:	90 93 c9 02 	sts	0x02C9, r25	; 0x8002c9 <xNextTaskUnblockTime+0x1>
    19ea:	80 93 c8 02 	sts	0x02C8, r24	; 0x8002c8 <xNextTaskUnblockTime>
    19ee:	2e c0       	rjmp	.+92     	; 0x1a4c <xTaskIncrementTick+0x110>
    19f0:	67 01       	movw	r12, r14
    19f2:	b2 e0       	ldi	r27, 0x02	; 2
    19f4:	cb 0e       	add	r12, r27
    19f6:	d1 1c       	adc	r13, r1
    19f8:	c6 01       	movw	r24, r12
    19fa:	0e 94 a1 14 	call	0x2942	; 0x2942 <uxListRemove>
    19fe:	f7 01       	movw	r30, r14
    1a00:	84 89       	ldd	r24, Z+20	; 0x14
    1a02:	95 89       	ldd	r25, Z+21	; 0x15
    1a04:	89 2b       	or	r24, r25
    1a06:	21 f0       	breq	.+8      	; 0x1a10 <xTaskIncrementTick+0xd4>
    1a08:	c7 01       	movw	r24, r14
    1a0a:	0c 96       	adiw	r24, 0x0c	; 12
    1a0c:	0e 94 a1 14 	call	0x2942	; 0x2942 <uxListRemove>
    1a10:	d7 01       	movw	r26, r14
    1a12:	56 96       	adiw	r26, 0x16	; 22
    1a14:	8c 91       	ld	r24, X
    1a16:	90 91 cf 02 	lds	r25, 0x02CF	; 0x8002cf <uxTopReadyPriority>
    1a1a:	98 17       	cp	r25, r24
    1a1c:	10 f4       	brcc	.+4      	; 0x1a22 <xTaskIncrementTick+0xe6>
    1a1e:	80 93 cf 02 	sts	0x02CF, r24	; 0x8002cf <uxTopReadyPriority>
    1a22:	d8 9f       	mul	r29, r24
    1a24:	c0 01       	movw	r24, r0
    1a26:	11 24       	eor	r1, r1
    1a28:	b6 01       	movw	r22, r12
    1a2a:	8b 5f       	subi	r24, 0xFB	; 251
    1a2c:	9c 4f       	sbci	r25, 0xFC	; 252
    1a2e:	0e 94 48 14 	call	0x2890	; 0x2890 <vListInsertEnd>
    1a32:	e0 91 29 03 	lds	r30, 0x0329	; 0x800329 <pxCurrentTCB>
    1a36:	f0 91 2a 03 	lds	r31, 0x032A	; 0x80032a <pxCurrentTCB+0x1>
    1a3a:	d7 01       	movw	r26, r14
    1a3c:	56 96       	adiw	r26, 0x16	; 22
    1a3e:	9c 91       	ld	r25, X
    1a40:	86 89       	ldd	r24, Z+22	; 0x16
    1a42:	98 17       	cp	r25, r24
    1a44:	08 f4       	brcc	.+2      	; 0x1a48 <xTaskIncrementTick+0x10c>
    1a46:	b4 cf       	rjmp	.-152    	; 0x19b0 <xTaskIncrementTick+0x74>
    1a48:	c1 e0       	ldi	r28, 0x01	; 1
    1a4a:	b2 cf       	rjmp	.-156    	; 0x19b0 <xTaskIncrementTick+0x74>
    1a4c:	e0 91 29 03 	lds	r30, 0x0329	; 0x800329 <pxCurrentTCB>
    1a50:	f0 91 2a 03 	lds	r31, 0x032A	; 0x80032a <pxCurrentTCB+0x1>
    1a54:	e6 89       	ldd	r30, Z+22	; 0x16
    1a56:	b9 e0       	ldi	r27, 0x09	; 9
    1a58:	eb 9f       	mul	r30, r27
    1a5a:	f0 01       	movw	r30, r0
    1a5c:	11 24       	eor	r1, r1
    1a5e:	eb 5f       	subi	r30, 0xFB	; 251
    1a60:	fc 4f       	sbci	r31, 0xFC	; 252
    1a62:	80 81       	ld	r24, Z
    1a64:	82 30       	cpi	r24, 0x02	; 2
    1a66:	40 f0       	brcs	.+16     	; 0x1a78 <xTaskIncrementTick+0x13c>
    1a68:	c1 e0       	ldi	r28, 0x01	; 1
    1a6a:	06 c0       	rjmp	.+12     	; 0x1a78 <xTaskIncrementTick+0x13c>
    1a6c:	80 91 cd 02 	lds	r24, 0x02CD	; 0x8002cd <uxPendedTicks>
    1a70:	8f 5f       	subi	r24, 0xFF	; 255
    1a72:	80 93 cd 02 	sts	0x02CD, r24	; 0x8002cd <uxPendedTicks>
    1a76:	c0 e0       	ldi	r28, 0x00	; 0
    1a78:	80 91 cc 02 	lds	r24, 0x02CC	; 0x8002cc <xYieldPending>
    1a7c:	81 11       	cpse	r24, r1
    1a7e:	c1 e0       	ldi	r28, 0x01	; 1
    1a80:	8c 2f       	mov	r24, r28
    1a82:	df 91       	pop	r29
    1a84:	cf 91       	pop	r28
    1a86:	1f 91       	pop	r17
    1a88:	0f 91       	pop	r16
    1a8a:	ff 90       	pop	r15
    1a8c:	ef 90       	pop	r14
    1a8e:	df 90       	pop	r13
    1a90:	cf 90       	pop	r12
    1a92:	08 95       	ret

00001a94 <xTaskResumeAll>:
    1a94:	ef 92       	push	r14
    1a96:	ff 92       	push	r15
    1a98:	0f 93       	push	r16
    1a9a:	1f 93       	push	r17
    1a9c:	cf 93       	push	r28
    1a9e:	df 93       	push	r29
    1aa0:	0f b6       	in	r0, 0x3f	; 63
    1aa2:	f8 94       	cli
    1aa4:	0f 92       	push	r0
    1aa6:	80 91 c5 02 	lds	r24, 0x02C5	; 0x8002c5 <uxSchedulerSuspended>
    1aaa:	81 50       	subi	r24, 0x01	; 1
    1aac:	80 93 c5 02 	sts	0x02C5, r24	; 0x8002c5 <uxSchedulerSuspended>
    1ab0:	80 91 c5 02 	lds	r24, 0x02C5	; 0x8002c5 <uxSchedulerSuspended>
    1ab4:	88 23       	and	r24, r24
    1ab6:	11 f0       	breq	.+4      	; 0x1abc <xTaskResumeAll+0x28>
    1ab8:	80 e0       	ldi	r24, 0x00	; 0
    1aba:	52 c0       	rjmp	.+164    	; 0x1b60 <xTaskResumeAll+0xcc>
    1abc:	80 91 d2 02 	lds	r24, 0x02D2	; 0x8002d2 <uxCurrentNumberOfTasks>
    1ac0:	88 23       	and	r24, r24
    1ac2:	d1 f3       	breq	.-12     	; 0x1ab8 <xTaskResumeAll+0x24>
    1ac4:	c0 e0       	ldi	r28, 0x00	; 0
    1ac6:	d0 e0       	ldi	r29, 0x00	; 0
    1ac8:	89 e0       	ldi	r24, 0x09	; 9
    1aca:	f8 2e       	mov	r15, r24
    1acc:	ee 24       	eor	r14, r14
    1ace:	e3 94       	inc	r14
    1ad0:	80 91 e6 02 	lds	r24, 0x02E6	; 0x8002e6 <xPendingReadyList>
    1ad4:	88 23       	and	r24, r24
    1ad6:	51 f1       	breq	.+84     	; 0x1b2c <xTaskResumeAll+0x98>
    1ad8:	e0 91 eb 02 	lds	r30, 0x02EB	; 0x8002eb <xPendingReadyList+0x5>
    1adc:	f0 91 ec 02 	lds	r31, 0x02EC	; 0x8002ec <xPendingReadyList+0x6>
    1ae0:	c6 81       	ldd	r28, Z+6	; 0x06
    1ae2:	d7 81       	ldd	r29, Z+7	; 0x07
    1ae4:	ce 01       	movw	r24, r28
    1ae6:	0c 96       	adiw	r24, 0x0c	; 12
    1ae8:	0e 94 a1 14 	call	0x2942	; 0x2942 <uxListRemove>
    1aec:	8e 01       	movw	r16, r28
    1aee:	0e 5f       	subi	r16, 0xFE	; 254
    1af0:	1f 4f       	sbci	r17, 0xFF	; 255
    1af2:	c8 01       	movw	r24, r16
    1af4:	0e 94 a1 14 	call	0x2942	; 0x2942 <uxListRemove>
    1af8:	8e 89       	ldd	r24, Y+22	; 0x16
    1afa:	90 91 cf 02 	lds	r25, 0x02CF	; 0x8002cf <uxTopReadyPriority>
    1afe:	98 17       	cp	r25, r24
    1b00:	10 f4       	brcc	.+4      	; 0x1b06 <xTaskResumeAll+0x72>
    1b02:	80 93 cf 02 	sts	0x02CF, r24	; 0x8002cf <uxTopReadyPriority>
    1b06:	f8 9e       	mul	r15, r24
    1b08:	c0 01       	movw	r24, r0
    1b0a:	11 24       	eor	r1, r1
    1b0c:	b8 01       	movw	r22, r16
    1b0e:	8b 5f       	subi	r24, 0xFB	; 251
    1b10:	9c 4f       	sbci	r25, 0xFC	; 252
    1b12:	0e 94 48 14 	call	0x2890	; 0x2890 <vListInsertEnd>
    1b16:	e0 91 29 03 	lds	r30, 0x0329	; 0x800329 <pxCurrentTCB>
    1b1a:	f0 91 2a 03 	lds	r31, 0x032A	; 0x80032a <pxCurrentTCB+0x1>
    1b1e:	9e 89       	ldd	r25, Y+22	; 0x16
    1b20:	86 89       	ldd	r24, Z+22	; 0x16
    1b22:	98 17       	cp	r25, r24
    1b24:	a8 f2       	brcs	.-86     	; 0x1ad0 <xTaskResumeAll+0x3c>
    1b26:	e0 92 cc 02 	sts	0x02CC, r14	; 0x8002cc <xYieldPending>
    1b2a:	d2 cf       	rjmp	.-92     	; 0x1ad0 <xTaskResumeAll+0x3c>
    1b2c:	cd 2b       	or	r28, r29
    1b2e:	11 f0       	breq	.+4      	; 0x1b34 <xTaskResumeAll+0xa0>
    1b30:	0e 94 66 0a 	call	0x14cc	; 0x14cc <prvResetNextTaskUnblockTime>
    1b34:	c0 91 cd 02 	lds	r28, 0x02CD	; 0x8002cd <uxPendedTicks>
    1b38:	cc 23       	and	r28, r28
    1b3a:	51 f0       	breq	.+20     	; 0x1b50 <xTaskResumeAll+0xbc>
    1b3c:	d1 e0       	ldi	r29, 0x01	; 1
    1b3e:	0e 94 9e 0c 	call	0x193c	; 0x193c <xTaskIncrementTick>
    1b42:	81 11       	cpse	r24, r1
    1b44:	d0 93 cc 02 	sts	0x02CC, r29	; 0x8002cc <xYieldPending>
    1b48:	c1 50       	subi	r28, 0x01	; 1
    1b4a:	c9 f7       	brne	.-14     	; 0x1b3e <xTaskResumeAll+0xaa>
    1b4c:	10 92 cd 02 	sts	0x02CD, r1	; 0x8002cd <uxPendedTicks>
    1b50:	80 91 cc 02 	lds	r24, 0x02CC	; 0x8002cc <xYieldPending>
    1b54:	88 23       	and	r24, r24
    1b56:	09 f4       	brne	.+2      	; 0x1b5a <xTaskResumeAll+0xc6>
    1b58:	af cf       	rjmp	.-162    	; 0x1ab8 <xTaskResumeAll+0x24>
    1b5a:	0e 94 69 15 	call	0x2ad2	; 0x2ad2 <vPortYield>
    1b5e:	81 e0       	ldi	r24, 0x01	; 1
    1b60:	0f 90       	pop	r0
    1b62:	0f be       	out	0x3f, r0	; 63
    1b64:	df 91       	pop	r29
    1b66:	cf 91       	pop	r28
    1b68:	1f 91       	pop	r17
    1b6a:	0f 91       	pop	r16
    1b6c:	ff 90       	pop	r15
    1b6e:	ef 90       	pop	r14
    1b70:	08 95       	ret

00001b72 <vTaskDelayUntil>:
    1b72:	0f 93       	push	r16
    1b74:	1f 93       	push	r17
    1b76:	cf 93       	push	r28
    1b78:	df 93       	push	r29
    1b7a:	8c 01       	movw	r16, r24
    1b7c:	eb 01       	movw	r28, r22
    1b7e:	0e 94 8e 0c 	call	0x191c	; 0x191c <vTaskSuspendAll>
    1b82:	40 91 d0 02 	lds	r20, 0x02D0	; 0x8002d0 <xTickCount>
    1b86:	50 91 d1 02 	lds	r21, 0x02D1	; 0x8002d1 <xTickCount+0x1>
    1b8a:	f8 01       	movw	r30, r16
    1b8c:	20 81       	ld	r18, Z
    1b8e:	31 81       	ldd	r19, Z+1	; 0x01
    1b90:	c9 01       	movw	r24, r18
    1b92:	8c 0f       	add	r24, r28
    1b94:	9d 1f       	adc	r25, r29
    1b96:	42 17       	cp	r20, r18
    1b98:	53 07       	cpc	r21, r19
    1b9a:	20 f4       	brcc	.+8      	; 0x1ba4 <vTaskDelayUntil+0x32>
    1b9c:	82 17       	cp	r24, r18
    1b9e:	93 07       	cpc	r25, r19
    1ba0:	40 f4       	brcc	.+16     	; 0x1bb2 <vTaskDelayUntil+0x40>
    1ba2:	03 c0       	rjmp	.+6      	; 0x1baa <vTaskDelayUntil+0x38>
    1ba4:	82 17       	cp	r24, r18
    1ba6:	93 07       	cpc	r25, r19
    1ba8:	30 f0       	brcs	.+12     	; 0x1bb6 <vTaskDelayUntil+0x44>
    1baa:	21 e0       	ldi	r18, 0x01	; 1
    1bac:	48 17       	cp	r20, r24
    1bae:	59 07       	cpc	r21, r25
    1bb0:	18 f0       	brcs	.+6      	; 0x1bb8 <vTaskDelayUntil+0x46>
    1bb2:	20 e0       	ldi	r18, 0x00	; 0
    1bb4:	01 c0       	rjmp	.+2      	; 0x1bb8 <vTaskDelayUntil+0x46>
    1bb6:	21 e0       	ldi	r18, 0x01	; 1
    1bb8:	f8 01       	movw	r30, r16
    1bba:	91 83       	std	Z+1, r25	; 0x01
    1bbc:	80 83       	st	Z, r24
    1bbe:	22 23       	and	r18, r18
    1bc0:	29 f0       	breq	.+10     	; 0x1bcc <vTaskDelayUntil+0x5a>
    1bc2:	60 e0       	ldi	r22, 0x00	; 0
    1bc4:	84 1b       	sub	r24, r20
    1bc6:	95 0b       	sbc	r25, r21
    1bc8:	0e 94 81 0a 	call	0x1502	; 0x1502 <prvAddCurrentTaskToDelayedList>
    1bcc:	0e 94 4a 0d 	call	0x1a94	; 0x1a94 <xTaskResumeAll>
    1bd0:	81 11       	cpse	r24, r1
    1bd2:	02 c0       	rjmp	.+4      	; 0x1bd8 <vTaskDelayUntil+0x66>
    1bd4:	0e 94 69 15 	call	0x2ad2	; 0x2ad2 <vPortYield>
    1bd8:	df 91       	pop	r29
    1bda:	cf 91       	pop	r28
    1bdc:	1f 91       	pop	r17
    1bde:	0f 91       	pop	r16
    1be0:	08 95       	ret

00001be2 <vTaskDelay>:
    1be2:	cf 93       	push	r28
    1be4:	df 93       	push	r29
    1be6:	ec 01       	movw	r28, r24
    1be8:	89 2b       	or	r24, r25
    1bea:	19 f4       	brne	.+6      	; 0x1bf2 <vTaskDelay+0x10>
    1bec:	0e 94 69 15 	call	0x2ad2	; 0x2ad2 <vPortYield>
    1bf0:	0a c0       	rjmp	.+20     	; 0x1c06 <vTaskDelay+0x24>
    1bf2:	0e 94 8e 0c 	call	0x191c	; 0x191c <vTaskSuspendAll>
    1bf6:	60 e0       	ldi	r22, 0x00	; 0
    1bf8:	ce 01       	movw	r24, r28
    1bfa:	0e 94 81 0a 	call	0x1502	; 0x1502 <prvAddCurrentTaskToDelayedList>
    1bfe:	0e 94 4a 0d 	call	0x1a94	; 0x1a94 <xTaskResumeAll>
    1c02:	88 23       	and	r24, r24
    1c04:	99 f3       	breq	.-26     	; 0x1bec <vTaskDelay+0xa>
    1c06:	df 91       	pop	r29
    1c08:	cf 91       	pop	r28
    1c0a:	08 95       	ret

00001c0c <vTaskSwitchContext>:
    1c0c:	80 91 c5 02 	lds	r24, 0x02C5	; 0x8002c5 <uxSchedulerSuspended>
    1c10:	88 23       	and	r24, r24
    1c12:	21 f0       	breq	.+8      	; 0x1c1c <vTaskSwitchContext+0x10>
    1c14:	81 e0       	ldi	r24, 0x01	; 1
    1c16:	80 93 cc 02 	sts	0x02CC, r24	; 0x8002cc <xYieldPending>
    1c1a:	08 95       	ret
    1c1c:	10 92 cc 02 	sts	0x02CC, r1	; 0x8002cc <xYieldPending>
    1c20:	a0 91 29 03 	lds	r26, 0x0329	; 0x800329 <pxCurrentTCB>
    1c24:	b0 91 2a 03 	lds	r27, 0x032A	; 0x80032a <pxCurrentTCB+0x1>
    1c28:	e0 91 29 03 	lds	r30, 0x0329	; 0x800329 <pxCurrentTCB>
    1c2c:	f0 91 2a 03 	lds	r31, 0x032A	; 0x80032a <pxCurrentTCB+0x1>
    1c30:	2d 91       	ld	r18, X+
    1c32:	3c 91       	ld	r19, X
    1c34:	87 89       	ldd	r24, Z+23	; 0x17
    1c36:	90 8d       	ldd	r25, Z+24	; 0x18
    1c38:	82 17       	cp	r24, r18
    1c3a:	93 07       	cpc	r25, r19
    1c3c:	60 f0       	brcs	.+24     	; 0x1c56 <vTaskSwitchContext+0x4a>
    1c3e:	60 91 29 03 	lds	r22, 0x0329	; 0x800329 <pxCurrentTCB>
    1c42:	70 91 2a 03 	lds	r23, 0x032A	; 0x80032a <pxCurrentTCB+0x1>
    1c46:	80 91 29 03 	lds	r24, 0x0329	; 0x800329 <pxCurrentTCB>
    1c4a:	90 91 2a 03 	lds	r25, 0x032A	; 0x80032a <pxCurrentTCB+0x1>
    1c4e:	67 5e       	subi	r22, 0xE7	; 231
    1c50:	7f 4f       	sbci	r23, 0xFF	; 255
    1c52:	0e 94 8a 12 	call	0x2514	; 0x2514 <vApplicationStackOverflowHook>
    1c56:	80 91 cf 02 	lds	r24, 0x02CF	; 0x8002cf <uxTopReadyPriority>
    1c5a:	69 e0       	ldi	r22, 0x09	; 9
    1c5c:	48 2f       	mov	r20, r24
    1c5e:	50 e0       	ldi	r21, 0x00	; 0
    1c60:	64 9f       	mul	r22, r20
    1c62:	90 01       	movw	r18, r0
    1c64:	65 9f       	mul	r22, r21
    1c66:	30 0d       	add	r19, r0
    1c68:	11 24       	eor	r1, r1
    1c6a:	f9 01       	movw	r30, r18
    1c6c:	eb 5f       	subi	r30, 0xFB	; 251
    1c6e:	fc 4f       	sbci	r31, 0xFC	; 252
    1c70:	90 81       	ld	r25, Z
    1c72:	91 11       	cpse	r25, r1
    1c74:	02 c0       	rjmp	.+4      	; 0x1c7a <vTaskSwitchContext+0x6e>
    1c76:	81 50       	subi	r24, 0x01	; 1
    1c78:	f1 cf       	rjmp	.-30     	; 0x1c5c <vTaskSwitchContext+0x50>
    1c7a:	a1 81       	ldd	r26, Z+1	; 0x01
    1c7c:	b2 81       	ldd	r27, Z+2	; 0x02
    1c7e:	12 96       	adiw	r26, 0x02	; 2
    1c80:	0d 90       	ld	r0, X+
    1c82:	bc 91       	ld	r27, X
    1c84:	a0 2d       	mov	r26, r0
    1c86:	b2 83       	std	Z+2, r27	; 0x02
    1c88:	a1 83       	std	Z+1, r26	; 0x01
    1c8a:	28 5f       	subi	r18, 0xF8	; 248
    1c8c:	3c 4f       	sbci	r19, 0xFC	; 252
    1c8e:	a2 17       	cp	r26, r18
    1c90:	b3 07       	cpc	r27, r19
    1c92:	31 f4       	brne	.+12     	; 0x1ca0 <vTaskSwitchContext+0x94>
    1c94:	12 96       	adiw	r26, 0x02	; 2
    1c96:	2d 91       	ld	r18, X+
    1c98:	3c 91       	ld	r19, X
    1c9a:	13 97       	sbiw	r26, 0x03	; 3
    1c9c:	32 83       	std	Z+2, r19	; 0x02
    1c9e:	21 83       	std	Z+1, r18	; 0x01
    1ca0:	99 e0       	ldi	r25, 0x09	; 9
    1ca2:	94 9f       	mul	r25, r20
    1ca4:	f0 01       	movw	r30, r0
    1ca6:	95 9f       	mul	r25, r21
    1ca8:	f0 0d       	add	r31, r0
    1caa:	11 24       	eor	r1, r1
    1cac:	eb 5f       	subi	r30, 0xFB	; 251
    1cae:	fc 4f       	sbci	r31, 0xFC	; 252
    1cb0:	01 80       	ldd	r0, Z+1	; 0x01
    1cb2:	f2 81       	ldd	r31, Z+2	; 0x02
    1cb4:	e0 2d       	mov	r30, r0
    1cb6:	26 81       	ldd	r18, Z+6	; 0x06
    1cb8:	37 81       	ldd	r19, Z+7	; 0x07
    1cba:	30 93 2a 03 	sts	0x032A, r19	; 0x80032a <pxCurrentTCB+0x1>
    1cbe:	20 93 29 03 	sts	0x0329, r18	; 0x800329 <pxCurrentTCB>
    1cc2:	80 93 cf 02 	sts	0x02CF, r24	; 0x8002cf <uxTopReadyPriority>
    1cc6:	08 95       	ret

00001cc8 <vTaskSuspend>:
    1cc8:	0f 93       	push	r16
    1cca:	1f 93       	push	r17
    1ccc:	cf 93       	push	r28
    1cce:	df 93       	push	r29
    1cd0:	ec 01       	movw	r28, r24
    1cd2:	0f b6       	in	r0, 0x3f	; 63
    1cd4:	f8 94       	cli
    1cd6:	0f 92       	push	r0
    1cd8:	89 2b       	or	r24, r25
    1cda:	21 f4       	brne	.+8      	; 0x1ce4 <vTaskSuspend+0x1c>
    1cdc:	c0 91 29 03 	lds	r28, 0x0329	; 0x800329 <pxCurrentTCB>
    1ce0:	d0 91 2a 03 	lds	r29, 0x032A	; 0x80032a <pxCurrentTCB+0x1>
    1ce4:	8e 01       	movw	r16, r28
    1ce6:	0e 5f       	subi	r16, 0xFE	; 254
    1ce8:	1f 4f       	sbci	r17, 0xFF	; 255
    1cea:	c8 01       	movw	r24, r16
    1cec:	0e 94 a1 14 	call	0x2942	; 0x2942 <uxListRemove>
    1cf0:	8c 89       	ldd	r24, Y+20	; 0x14
    1cf2:	9d 89       	ldd	r25, Y+21	; 0x15
    1cf4:	89 2b       	or	r24, r25
    1cf6:	21 f0       	breq	.+8      	; 0x1d00 <vTaskSuspend+0x38>
    1cf8:	ce 01       	movw	r24, r28
    1cfa:	0c 96       	adiw	r24, 0x0c	; 12
    1cfc:	0e 94 a1 14 	call	0x2942	; 0x2942 <uxListRemove>
    1d00:	b8 01       	movw	r22, r16
    1d02:	83 ed       	ldi	r24, 0xD3	; 211
    1d04:	92 e0       	ldi	r25, 0x02	; 2
    1d06:	0e 94 48 14 	call	0x2890	; 0x2890 <vListInsertEnd>
    1d0a:	8f a1       	ldd	r24, Y+39	; 0x27
    1d0c:	81 30       	cpi	r24, 0x01	; 1
    1d0e:	09 f4       	brne	.+2      	; 0x1d12 <vTaskSuspend+0x4a>
    1d10:	1f a2       	std	Y+39, r1	; 0x27
    1d12:	0f 90       	pop	r0
    1d14:	0f be       	out	0x3f, r0	; 63
    1d16:	80 91 ce 02 	lds	r24, 0x02CE	; 0x8002ce <xSchedulerRunning>
    1d1a:	88 23       	and	r24, r24
    1d1c:	39 f0       	breq	.+14     	; 0x1d2c <vTaskSuspend+0x64>
    1d1e:	0f b6       	in	r0, 0x3f	; 63
    1d20:	f8 94       	cli
    1d22:	0f 92       	push	r0
    1d24:	0e 94 66 0a 	call	0x14cc	; 0x14cc <prvResetNextTaskUnblockTime>
    1d28:	0f 90       	pop	r0
    1d2a:	0f be       	out	0x3f, r0	; 63
    1d2c:	80 91 29 03 	lds	r24, 0x0329	; 0x800329 <pxCurrentTCB>
    1d30:	90 91 2a 03 	lds	r25, 0x032A	; 0x80032a <pxCurrentTCB+0x1>
    1d34:	c8 17       	cp	r28, r24
    1d36:	d9 07       	cpc	r29, r25
    1d38:	c1 f4       	brne	.+48     	; 0x1d6a <vTaskSuspend+0xa2>
    1d3a:	80 91 ce 02 	lds	r24, 0x02CE	; 0x8002ce <xSchedulerRunning>
    1d3e:	88 23       	and	r24, r24
    1d40:	19 f0       	breq	.+6      	; 0x1d48 <vTaskSuspend+0x80>
    1d42:	0e 94 69 15 	call	0x2ad2	; 0x2ad2 <vPortYield>
    1d46:	11 c0       	rjmp	.+34     	; 0x1d6a <vTaskSuspend+0xa2>
    1d48:	90 91 d3 02 	lds	r25, 0x02D3	; 0x8002d3 <xSuspendedTaskList>
    1d4c:	80 91 d2 02 	lds	r24, 0x02D2	; 0x8002d2 <uxCurrentNumberOfTasks>
    1d50:	98 13       	cpse	r25, r24
    1d52:	05 c0       	rjmp	.+10     	; 0x1d5e <vTaskSuspend+0x96>
    1d54:	10 92 2a 03 	sts	0x032A, r1	; 0x80032a <pxCurrentTCB+0x1>
    1d58:	10 92 29 03 	sts	0x0329, r1	; 0x800329 <pxCurrentTCB>
    1d5c:	06 c0       	rjmp	.+12     	; 0x1d6a <vTaskSuspend+0xa2>
    1d5e:	df 91       	pop	r29
    1d60:	cf 91       	pop	r28
    1d62:	1f 91       	pop	r17
    1d64:	0f 91       	pop	r16
    1d66:	0c 94 06 0e 	jmp	0x1c0c	; 0x1c0c <vTaskSwitchContext>
    1d6a:	df 91       	pop	r29
    1d6c:	cf 91       	pop	r28
    1d6e:	1f 91       	pop	r17
    1d70:	0f 91       	pop	r16
    1d72:	08 95       	ret

00001d74 <vTaskPlaceOnEventList>:
    1d74:	cf 93       	push	r28
    1d76:	df 93       	push	r29
    1d78:	eb 01       	movw	r28, r22
    1d7a:	60 91 29 03 	lds	r22, 0x0329	; 0x800329 <pxCurrentTCB>
    1d7e:	70 91 2a 03 	lds	r23, 0x032A	; 0x80032a <pxCurrentTCB+0x1>
    1d82:	64 5f       	subi	r22, 0xF4	; 244
    1d84:	7f 4f       	sbci	r23, 0xFF	; 255
    1d86:	0e 94 69 14 	call	0x28d2	; 0x28d2 <vListInsert>
    1d8a:	61 e0       	ldi	r22, 0x01	; 1
    1d8c:	ce 01       	movw	r24, r28
    1d8e:	df 91       	pop	r29
    1d90:	cf 91       	pop	r28
    1d92:	0c 94 81 0a 	jmp	0x1502	; 0x1502 <prvAddCurrentTaskToDelayedList>

00001d96 <vTaskPlaceOnEventListRestricted>:
    1d96:	1f 93       	push	r17
    1d98:	cf 93       	push	r28
    1d9a:	df 93       	push	r29
    1d9c:	eb 01       	movw	r28, r22
    1d9e:	14 2f       	mov	r17, r20
    1da0:	60 91 29 03 	lds	r22, 0x0329	; 0x800329 <pxCurrentTCB>
    1da4:	70 91 2a 03 	lds	r23, 0x032A	; 0x80032a <pxCurrentTCB+0x1>
    1da8:	64 5f       	subi	r22, 0xF4	; 244
    1daa:	7f 4f       	sbci	r23, 0xFF	; 255
    1dac:	0e 94 48 14 	call	0x2890	; 0x2890 <vListInsertEnd>
    1db0:	11 23       	and	r17, r17
    1db2:	11 f0       	breq	.+4      	; 0x1db8 <vTaskPlaceOnEventListRestricted+0x22>
    1db4:	cf ef       	ldi	r28, 0xFF	; 255
    1db6:	df ef       	ldi	r29, 0xFF	; 255
    1db8:	61 2f       	mov	r22, r17
    1dba:	ce 01       	movw	r24, r28
    1dbc:	df 91       	pop	r29
    1dbe:	cf 91       	pop	r28
    1dc0:	1f 91       	pop	r17
    1dc2:	0c 94 81 0a 	jmp	0x1502	; 0x1502 <prvAddCurrentTaskToDelayedList>

00001dc6 <xTaskRemoveFromEventList>:
    1dc6:	0f 93       	push	r16
    1dc8:	1f 93       	push	r17
    1dca:	cf 93       	push	r28
    1dcc:	df 93       	push	r29
    1dce:	dc 01       	movw	r26, r24
    1dd0:	15 96       	adiw	r26, 0x05	; 5
    1dd2:	ed 91       	ld	r30, X+
    1dd4:	fc 91       	ld	r31, X
    1dd6:	16 97       	sbiw	r26, 0x06	; 6
    1dd8:	c6 81       	ldd	r28, Z+6	; 0x06
    1dda:	d7 81       	ldd	r29, Z+7	; 0x07
    1ddc:	8e 01       	movw	r16, r28
    1dde:	04 5f       	subi	r16, 0xF4	; 244
    1de0:	1f 4f       	sbci	r17, 0xFF	; 255
    1de2:	c8 01       	movw	r24, r16
    1de4:	0e 94 a1 14 	call	0x2942	; 0x2942 <uxListRemove>
    1de8:	80 91 c5 02 	lds	r24, 0x02C5	; 0x8002c5 <uxSchedulerSuspended>
    1dec:	81 11       	cpse	r24, r1
    1dee:	14 c0       	rjmp	.+40     	; 0x1e18 <xTaskRemoveFromEventList+0x52>
    1df0:	0a 50       	subi	r16, 0x0A	; 10
    1df2:	11 09       	sbc	r17, r1
    1df4:	c8 01       	movw	r24, r16
    1df6:	0e 94 a1 14 	call	0x2942	; 0x2942 <uxListRemove>
    1dfa:	8e 89       	ldd	r24, Y+22	; 0x16
    1dfc:	90 91 cf 02 	lds	r25, 0x02CF	; 0x8002cf <uxTopReadyPriority>
    1e00:	98 17       	cp	r25, r24
    1e02:	10 f4       	brcc	.+4      	; 0x1e08 <xTaskRemoveFromEventList+0x42>
    1e04:	80 93 cf 02 	sts	0x02CF, r24	; 0x8002cf <uxTopReadyPriority>
    1e08:	b9 e0       	ldi	r27, 0x09	; 9
    1e0a:	8b 9f       	mul	r24, r27
    1e0c:	c0 01       	movw	r24, r0
    1e0e:	11 24       	eor	r1, r1
    1e10:	b8 01       	movw	r22, r16
    1e12:	8b 5f       	subi	r24, 0xFB	; 251
    1e14:	9c 4f       	sbci	r25, 0xFC	; 252
    1e16:	03 c0       	rjmp	.+6      	; 0x1e1e <xTaskRemoveFromEventList+0x58>
    1e18:	b8 01       	movw	r22, r16
    1e1a:	86 ee       	ldi	r24, 0xE6	; 230
    1e1c:	92 e0       	ldi	r25, 0x02	; 2
    1e1e:	0e 94 48 14 	call	0x2890	; 0x2890 <vListInsertEnd>
    1e22:	e0 91 29 03 	lds	r30, 0x0329	; 0x800329 <pxCurrentTCB>
    1e26:	f0 91 2a 03 	lds	r31, 0x032A	; 0x80032a <pxCurrentTCB+0x1>
    1e2a:	9e 89       	ldd	r25, Y+22	; 0x16
    1e2c:	86 89       	ldd	r24, Z+22	; 0x16
    1e2e:	89 17       	cp	r24, r25
    1e30:	20 f4       	brcc	.+8      	; 0x1e3a <xTaskRemoveFromEventList+0x74>
    1e32:	81 e0       	ldi	r24, 0x01	; 1
    1e34:	80 93 cc 02 	sts	0x02CC, r24	; 0x8002cc <xYieldPending>
    1e38:	01 c0       	rjmp	.+2      	; 0x1e3c <xTaskRemoveFromEventList+0x76>
    1e3a:	80 e0       	ldi	r24, 0x00	; 0
    1e3c:	df 91       	pop	r29
    1e3e:	cf 91       	pop	r28
    1e40:	1f 91       	pop	r17
    1e42:	0f 91       	pop	r16
    1e44:	08 95       	ret

00001e46 <vTaskInternalSetTimeOutState>:
    1e46:	20 91 cb 02 	lds	r18, 0x02CB	; 0x8002cb <xNumOfOverflows>
    1e4a:	fc 01       	movw	r30, r24
    1e4c:	20 83       	st	Z, r18
    1e4e:	20 91 d0 02 	lds	r18, 0x02D0	; 0x8002d0 <xTickCount>
    1e52:	30 91 d1 02 	lds	r19, 0x02D1	; 0x8002d1 <xTickCount+0x1>
    1e56:	32 83       	std	Z+2, r19	; 0x02
    1e58:	21 83       	std	Z+1, r18	; 0x01
    1e5a:	08 95       	ret

00001e5c <xTaskCheckForTimeOut>:
    1e5c:	cf 93       	push	r28
    1e5e:	df 93       	push	r29
    1e60:	0f b6       	in	r0, 0x3f	; 63
    1e62:	f8 94       	cli
    1e64:	0f 92       	push	r0
    1e66:	40 91 d0 02 	lds	r20, 0x02D0	; 0x8002d0 <xTickCount>
    1e6a:	50 91 d1 02 	lds	r21, 0x02D1	; 0x8002d1 <xTickCount+0x1>
    1e6e:	db 01       	movw	r26, r22
    1e70:	2d 91       	ld	r18, X+
    1e72:	3c 91       	ld	r19, X
    1e74:	2f 3f       	cpi	r18, 0xFF	; 255
    1e76:	bf ef       	ldi	r27, 0xFF	; 255
    1e78:	3b 07       	cpc	r19, r27
    1e7a:	d9 f0       	breq	.+54     	; 0x1eb2 <xTaskCheckForTimeOut+0x56>
    1e7c:	ec 01       	movw	r28, r24
    1e7e:	e9 81       	ldd	r30, Y+1	; 0x01
    1e80:	fa 81       	ldd	r31, Y+2	; 0x02
    1e82:	a0 91 cb 02 	lds	r26, 0x02CB	; 0x8002cb <xNumOfOverflows>
    1e86:	b8 81       	ld	r27, Y
    1e88:	ba 17       	cp	r27, r26
    1e8a:	19 f0       	breq	.+6      	; 0x1e92 <xTaskCheckForTimeOut+0x36>
    1e8c:	4e 17       	cp	r20, r30
    1e8e:	5f 07       	cpc	r21, r31
    1e90:	90 f4       	brcc	.+36     	; 0x1eb6 <xTaskCheckForTimeOut+0x5a>
    1e92:	4e 1b       	sub	r20, r30
    1e94:	5f 0b       	sbc	r21, r31
    1e96:	fb 01       	movw	r30, r22
    1e98:	42 17       	cp	r20, r18
    1e9a:	53 07       	cpc	r21, r19
    1e9c:	38 f4       	brcc	.+14     	; 0x1eac <xTaskCheckForTimeOut+0x50>
    1e9e:	24 1b       	sub	r18, r20
    1ea0:	35 0b       	sbc	r19, r21
    1ea2:	31 83       	std	Z+1, r19	; 0x01
    1ea4:	20 83       	st	Z, r18
    1ea6:	0e 94 23 0f 	call	0x1e46	; 0x1e46 <vTaskInternalSetTimeOutState>
    1eaa:	03 c0       	rjmp	.+6      	; 0x1eb2 <xTaskCheckForTimeOut+0x56>
    1eac:	11 82       	std	Z+1, r1	; 0x01
    1eae:	10 82       	st	Z, r1
    1eb0:	02 c0       	rjmp	.+4      	; 0x1eb6 <xTaskCheckForTimeOut+0x5a>
    1eb2:	80 e0       	ldi	r24, 0x00	; 0
    1eb4:	01 c0       	rjmp	.+2      	; 0x1eb8 <xTaskCheckForTimeOut+0x5c>
    1eb6:	81 e0       	ldi	r24, 0x01	; 1
    1eb8:	0f 90       	pop	r0
    1eba:	0f be       	out	0x3f, r0	; 63
    1ebc:	df 91       	pop	r29
    1ebe:	cf 91       	pop	r28
    1ec0:	08 95       	ret

00001ec2 <vTaskMissedYield>:
    1ec2:	81 e0       	ldi	r24, 0x01	; 1
    1ec4:	80 93 cc 02 	sts	0x02CC, r24	; 0x8002cc <xYieldPending>
    1ec8:	08 95       	ret

00001eca <xTaskGetSchedulerState>:
    1eca:	80 91 ce 02 	lds	r24, 0x02CE	; 0x8002ce <xSchedulerRunning>
    1ece:	88 23       	and	r24, r24
    1ed0:	31 f0       	breq	.+12     	; 0x1ede <xTaskGetSchedulerState+0x14>
    1ed2:	80 91 c5 02 	lds	r24, 0x02C5	; 0x8002c5 <uxSchedulerSuspended>
    1ed6:	88 23       	and	r24, r24
    1ed8:	21 f0       	breq	.+8      	; 0x1ee2 <xTaskGetSchedulerState+0x18>
    1eda:	80 e0       	ldi	r24, 0x00	; 0
    1edc:	08 95       	ret
    1ede:	81 e0       	ldi	r24, 0x01	; 1
    1ee0:	08 95       	ret
    1ee2:	82 e0       	ldi	r24, 0x02	; 2
    1ee4:	08 95       	ret

00001ee6 <xTaskPriorityInherit>:
    1ee6:	0f 93       	push	r16
    1ee8:	1f 93       	push	r17
    1eea:	cf 93       	push	r28
    1eec:	df 93       	push	r29
    1eee:	fc 01       	movw	r30, r24
    1ef0:	89 2b       	or	r24, r25
    1ef2:	09 f4       	brne	.+2      	; 0x1ef6 <xTaskPriorityInherit+0x10>
    1ef4:	55 c0       	rjmp	.+170    	; 0x1fa0 <xTaskPriorityInherit+0xba>
    1ef6:	86 89       	ldd	r24, Z+22	; 0x16
    1ef8:	a0 91 29 03 	lds	r26, 0x0329	; 0x800329 <pxCurrentTCB>
    1efc:	b0 91 2a 03 	lds	r27, 0x032A	; 0x80032a <pxCurrentTCB+0x1>
    1f00:	56 96       	adiw	r26, 0x16	; 22
    1f02:	9c 91       	ld	r25, X
    1f04:	89 17       	cp	r24, r25
    1f06:	08 f0       	brcs	.+2      	; 0x1f0a <xTaskPriorityInherit+0x24>
    1f08:	41 c0       	rjmp	.+130    	; 0x1f8c <xTaskPriorityInherit+0xa6>
    1f0a:	24 85       	ldd	r18, Z+12	; 0x0c
    1f0c:	35 85       	ldd	r19, Z+13	; 0x0d
    1f0e:	37 fd       	sbrc	r19, 7
    1f10:	0c c0       	rjmp	.+24     	; 0x1f2a <xTaskPriorityInherit+0x44>
    1f12:	a0 91 29 03 	lds	r26, 0x0329	; 0x800329 <pxCurrentTCB>
    1f16:	b0 91 2a 03 	lds	r27, 0x032A	; 0x80032a <pxCurrentTCB+0x1>
    1f1a:	56 96       	adiw	r26, 0x16	; 22
    1f1c:	9c 91       	ld	r25, X
    1f1e:	24 e0       	ldi	r18, 0x04	; 4
    1f20:	30 e0       	ldi	r19, 0x00	; 0
    1f22:	29 1b       	sub	r18, r25
    1f24:	31 09       	sbc	r19, r1
    1f26:	35 87       	std	Z+13, r19	; 0x0d
    1f28:	24 87       	std	Z+12, r18	; 0x0c
    1f2a:	29 e0       	ldi	r18, 0x09	; 9
    1f2c:	82 9f       	mul	r24, r18
    1f2e:	c0 01       	movw	r24, r0
    1f30:	11 24       	eor	r1, r1
    1f32:	8b 5f       	subi	r24, 0xFB	; 251
    1f34:	9c 4f       	sbci	r25, 0xFC	; 252
    1f36:	22 85       	ldd	r18, Z+10	; 0x0a
    1f38:	33 85       	ldd	r19, Z+11	; 0x0b
    1f3a:	28 17       	cp	r18, r24
    1f3c:	39 07       	cpc	r19, r25
    1f3e:	e9 f4       	brne	.+58     	; 0x1f7a <xTaskPriorityInherit+0x94>
    1f40:	8f 01       	movw	r16, r30
    1f42:	ef 01       	movw	r28, r30
    1f44:	22 96       	adiw	r28, 0x02	; 2
    1f46:	ce 01       	movw	r24, r28
    1f48:	0e 94 a1 14 	call	0x2942	; 0x2942 <uxListRemove>
    1f4c:	e0 91 29 03 	lds	r30, 0x0329	; 0x800329 <pxCurrentTCB>
    1f50:	f0 91 2a 03 	lds	r31, 0x032A	; 0x80032a <pxCurrentTCB+0x1>
    1f54:	86 89       	ldd	r24, Z+22	; 0x16
    1f56:	f8 01       	movw	r30, r16
    1f58:	86 8b       	std	Z+22, r24	; 0x16
    1f5a:	90 91 cf 02 	lds	r25, 0x02CF	; 0x8002cf <uxTopReadyPriority>
    1f5e:	98 17       	cp	r25, r24
    1f60:	10 f4       	brcc	.+4      	; 0x1f66 <xTaskPriorityInherit+0x80>
    1f62:	80 93 cf 02 	sts	0x02CF, r24	; 0x8002cf <uxTopReadyPriority>
    1f66:	f9 e0       	ldi	r31, 0x09	; 9
    1f68:	8f 9f       	mul	r24, r31
    1f6a:	c0 01       	movw	r24, r0
    1f6c:	11 24       	eor	r1, r1
    1f6e:	be 01       	movw	r22, r28
    1f70:	8b 5f       	subi	r24, 0xFB	; 251
    1f72:	9c 4f       	sbci	r25, 0xFC	; 252
    1f74:	0e 94 48 14 	call	0x2890	; 0x2890 <vListInsertEnd>
    1f78:	07 c0       	rjmp	.+14     	; 0x1f88 <xTaskPriorityInherit+0xa2>
    1f7a:	a0 91 29 03 	lds	r26, 0x0329	; 0x800329 <pxCurrentTCB>
    1f7e:	b0 91 2a 03 	lds	r27, 0x032A	; 0x80032a <pxCurrentTCB+0x1>
    1f82:	56 96       	adiw	r26, 0x16	; 22
    1f84:	8c 91       	ld	r24, X
    1f86:	86 8b       	std	Z+22, r24	; 0x16
    1f88:	81 e0       	ldi	r24, 0x01	; 1
    1f8a:	0b c0       	rjmp	.+22     	; 0x1fa2 <xTaskPriorityInherit+0xbc>
    1f8c:	a0 91 29 03 	lds	r26, 0x0329	; 0x800329 <pxCurrentTCB>
    1f90:	b0 91 2a 03 	lds	r27, 0x032A	; 0x80032a <pxCurrentTCB+0x1>
    1f94:	81 e0       	ldi	r24, 0x01	; 1
    1f96:	21 a1       	ldd	r18, Z+33	; 0x21
    1f98:	56 96       	adiw	r26, 0x16	; 22
    1f9a:	9c 91       	ld	r25, X
    1f9c:	29 17       	cp	r18, r25
    1f9e:	08 f0       	brcs	.+2      	; 0x1fa2 <xTaskPriorityInherit+0xbc>
    1fa0:	80 e0       	ldi	r24, 0x00	; 0
    1fa2:	df 91       	pop	r29
    1fa4:	cf 91       	pop	r28
    1fa6:	1f 91       	pop	r17
    1fa8:	0f 91       	pop	r16
    1faa:	08 95       	ret

00001fac <xTaskPriorityDisinherit>:
    1fac:	0f 93       	push	r16
    1fae:	1f 93       	push	r17
    1fb0:	cf 93       	push	r28
    1fb2:	df 93       	push	r29
    1fb4:	fc 01       	movw	r30, r24
    1fb6:	89 2b       	or	r24, r25
    1fb8:	11 f4       	brne	.+4      	; 0x1fbe <xTaskPriorityDisinherit+0x12>
    1fba:	80 e0       	ldi	r24, 0x00	; 0
    1fbc:	2c c0       	rjmp	.+88     	; 0x2016 <xTaskPriorityDisinherit+0x6a>
    1fbe:	82 a1       	ldd	r24, Z+34	; 0x22
    1fc0:	81 50       	subi	r24, 0x01	; 1
    1fc2:	82 a3       	std	Z+34, r24	; 0x22
    1fc4:	26 89       	ldd	r18, Z+22	; 0x16
    1fc6:	91 a1       	ldd	r25, Z+33	; 0x21
    1fc8:	29 17       	cp	r18, r25
    1fca:	b9 f3       	breq	.-18     	; 0x1fba <xTaskPriorityDisinherit+0xe>
    1fcc:	81 11       	cpse	r24, r1
    1fce:	f5 cf       	rjmp	.-22     	; 0x1fba <xTaskPriorityDisinherit+0xe>
    1fd0:	ef 01       	movw	r28, r30
    1fd2:	8f 01       	movw	r16, r30
    1fd4:	0e 5f       	subi	r16, 0xFE	; 254
    1fd6:	1f 4f       	sbci	r17, 0xFF	; 255
    1fd8:	c8 01       	movw	r24, r16
    1fda:	0e 94 a1 14 	call	0x2942	; 0x2942 <uxListRemove>
    1fde:	89 a1       	ldd	r24, Y+33	; 0x21
    1fe0:	8e 8b       	std	Y+22, r24	; 0x16
    1fe2:	48 2f       	mov	r20, r24
    1fe4:	50 e0       	ldi	r21, 0x00	; 0
    1fe6:	24 e0       	ldi	r18, 0x04	; 4
    1fe8:	30 e0       	ldi	r19, 0x00	; 0
    1fea:	24 1b       	sub	r18, r20
    1fec:	35 0b       	sbc	r19, r21
    1fee:	3d 87       	std	Y+13, r19	; 0x0d
    1ff0:	2c 87       	std	Y+12, r18	; 0x0c
    1ff2:	90 91 cf 02 	lds	r25, 0x02CF	; 0x8002cf <uxTopReadyPriority>
    1ff6:	98 17       	cp	r25, r24
    1ff8:	10 f4       	brcc	.+4      	; 0x1ffe <xTaskPriorityDisinherit+0x52>
    1ffa:	80 93 cf 02 	sts	0x02CF, r24	; 0x8002cf <uxTopReadyPriority>
    1ffe:	29 e0       	ldi	r18, 0x09	; 9
    2000:	24 9f       	mul	r18, r20
    2002:	c0 01       	movw	r24, r0
    2004:	25 9f       	mul	r18, r21
    2006:	90 0d       	add	r25, r0
    2008:	11 24       	eor	r1, r1
    200a:	b8 01       	movw	r22, r16
    200c:	8b 5f       	subi	r24, 0xFB	; 251
    200e:	9c 4f       	sbci	r25, 0xFC	; 252
    2010:	0e 94 48 14 	call	0x2890	; 0x2890 <vListInsertEnd>
    2014:	81 e0       	ldi	r24, 0x01	; 1
    2016:	df 91       	pop	r29
    2018:	cf 91       	pop	r28
    201a:	1f 91       	pop	r17
    201c:	0f 91       	pop	r16
    201e:	08 95       	ret

00002020 <vTaskPriorityDisinheritAfterTimeout>:
    2020:	0f 93       	push	r16
    2022:	1f 93       	push	r17
    2024:	cf 93       	push	r28
    2026:	df 93       	push	r29
    2028:	fc 01       	movw	r30, r24
    202a:	89 2b       	or	r24, r25
    202c:	d9 f1       	breq	.+118    	; 0x20a4 <vTaskPriorityDisinheritAfterTimeout+0x84>
    202e:	91 a1       	ldd	r25, Z+33	; 0x21
    2030:	96 17       	cp	r25, r22
    2032:	08 f4       	brcc	.+2      	; 0x2036 <vTaskPriorityDisinheritAfterTimeout+0x16>
    2034:	96 2f       	mov	r25, r22
    2036:	86 89       	ldd	r24, Z+22	; 0x16
    2038:	89 17       	cp	r24, r25
    203a:	a1 f1       	breq	.+104    	; 0x20a4 <vTaskPriorityDisinheritAfterTimeout+0x84>
    203c:	22 a1       	ldd	r18, Z+34	; 0x22
    203e:	21 30       	cpi	r18, 0x01	; 1
    2040:	89 f5       	brne	.+98     	; 0x20a4 <vTaskPriorityDisinheritAfterTimeout+0x84>
    2042:	96 8b       	std	Z+22, r25	; 0x16
    2044:	24 85       	ldd	r18, Z+12	; 0x0c
    2046:	35 85       	ldd	r19, Z+13	; 0x0d
    2048:	37 fd       	sbrc	r19, 7
    204a:	06 c0       	rjmp	.+12     	; 0x2058 <vTaskPriorityDisinheritAfterTimeout+0x38>
    204c:	24 e0       	ldi	r18, 0x04	; 4
    204e:	30 e0       	ldi	r19, 0x00	; 0
    2050:	29 1b       	sub	r18, r25
    2052:	31 09       	sbc	r19, r1
    2054:	35 87       	std	Z+13, r19	; 0x0d
    2056:	24 87       	std	Z+12, r18	; 0x0c
    2058:	29 e0       	ldi	r18, 0x09	; 9
    205a:	82 9f       	mul	r24, r18
    205c:	c0 01       	movw	r24, r0
    205e:	11 24       	eor	r1, r1
    2060:	8b 5f       	subi	r24, 0xFB	; 251
    2062:	9c 4f       	sbci	r25, 0xFC	; 252
    2064:	22 85       	ldd	r18, Z+10	; 0x0a
    2066:	33 85       	ldd	r19, Z+11	; 0x0b
    2068:	28 17       	cp	r18, r24
    206a:	39 07       	cpc	r19, r25
    206c:	d9 f4       	brne	.+54     	; 0x20a4 <vTaskPriorityDisinheritAfterTimeout+0x84>
    206e:	ef 01       	movw	r28, r30
    2070:	8f 01       	movw	r16, r30
    2072:	0e 5f       	subi	r16, 0xFE	; 254
    2074:	1f 4f       	sbci	r17, 0xFF	; 255
    2076:	c8 01       	movw	r24, r16
    2078:	0e 94 a1 14 	call	0x2942	; 0x2942 <uxListRemove>
    207c:	8e 89       	ldd	r24, Y+22	; 0x16
    207e:	90 91 cf 02 	lds	r25, 0x02CF	; 0x8002cf <uxTopReadyPriority>
    2082:	98 17       	cp	r25, r24
    2084:	10 f4       	brcc	.+4      	; 0x208a <vTaskPriorityDisinheritAfterTimeout+0x6a>
    2086:	80 93 cf 02 	sts	0x02CF, r24	; 0x8002cf <uxTopReadyPriority>
    208a:	29 e0       	ldi	r18, 0x09	; 9
    208c:	82 9f       	mul	r24, r18
    208e:	c0 01       	movw	r24, r0
    2090:	11 24       	eor	r1, r1
    2092:	b8 01       	movw	r22, r16
    2094:	8b 5f       	subi	r24, 0xFB	; 251
    2096:	9c 4f       	sbci	r25, 0xFC	; 252
    2098:	df 91       	pop	r29
    209a:	cf 91       	pop	r28
    209c:	1f 91       	pop	r17
    209e:	0f 91       	pop	r16
    20a0:	0c 94 48 14 	jmp	0x2890	; 0x2890 <vListInsertEnd>
    20a4:	df 91       	pop	r29
    20a6:	cf 91       	pop	r28
    20a8:	1f 91       	pop	r17
    20aa:	0f 91       	pop	r16
    20ac:	08 95       	ret

000020ae <pvTaskIncrementMutexHeldCount>:

    TaskHandle_t pvTaskIncrementMutexHeldCount( void )
    {
        /* If xSemaphoreCreateMutex() is called before any tasks have been created
        then pxCurrentTCB will be NULL. */
        if( pxCurrentTCB != NULL )
    20ae:	80 91 29 03 	lds	r24, 0x0329	; 0x800329 <pxCurrentTCB>
    20b2:	90 91 2a 03 	lds	r25, 0x032A	; 0x80032a <pxCurrentTCB+0x1>
    20b6:	89 2b       	or	r24, r25
    20b8:	39 f0       	breq	.+14     	; 0x20c8 <pvTaskIncrementMutexHeldCount+0x1a>
        {
            ( pxCurrentTCB->uxMutexesHeld )++;
    20ba:	e0 91 29 03 	lds	r30, 0x0329	; 0x800329 <pxCurrentTCB>
    20be:	f0 91 2a 03 	lds	r31, 0x032A	; 0x80032a <pxCurrentTCB+0x1>
    20c2:	82 a1       	ldd	r24, Z+34	; 0x22
    20c4:	8f 5f       	subi	r24, 0xFF	; 255
    20c6:	82 a3       	std	Z+34, r24	; 0x22
        }

        return pxCurrentTCB;
    20c8:	80 91 29 03 	lds	r24, 0x0329	; 0x800329 <pxCurrentTCB>
    20cc:	90 91 2a 03 	lds	r25, 0x032A	; 0x80032a <pxCurrentTCB+0x1>
    }
    20d0:	08 95       	ret

000020d2 <prvCheckForValidListAndQueue>:
            pxNewTimer->ucStatus = 0x00;
            prvInitialiseNewTimer( pcTimerName, xTimerPeriodInTicks, uxAutoReload, pvTimerID, pxCallbackFunction, pxNewTimer );
        }

        return pxNewTimer;
    }
    20d2:	0f b6       	in	r0, 0x3f	; 63
    20d4:	f8 94       	cli
    20d6:	0f 92       	push	r0
    20d8:	80 91 2f 03 	lds	r24, 0x032F	; 0x80032f <xTimerQueue>
    20dc:	90 91 30 03 	lds	r25, 0x0330	; 0x800330 <xTimerQueue+0x1>
    20e0:	89 2b       	or	r24, r25
    20e2:	e9 f4       	brne	.+58     	; 0x211e <prvCheckForValidListAndQueue+0x4c>
    20e4:	8e e3       	ldi	r24, 0x3E	; 62
    20e6:	93 e0       	ldi	r25, 0x03	; 3
    20e8:	0e 94 36 14 	call	0x286c	; 0x286c <vListInitialise>
    20ec:	85 e3       	ldi	r24, 0x35	; 53
    20ee:	93 e0       	ldi	r25, 0x03	; 3
    20f0:	0e 94 36 14 	call	0x286c	; 0x286c <vListInitialise>
    20f4:	8e e3       	ldi	r24, 0x3E	; 62
    20f6:	93 e0       	ldi	r25, 0x03	; 3
    20f8:	90 93 34 03 	sts	0x0334, r25	; 0x800334 <pxCurrentTimerList+0x1>
    20fc:	80 93 33 03 	sts	0x0333, r24	; 0x800333 <pxCurrentTimerList>
    2100:	85 e3       	ldi	r24, 0x35	; 53
    2102:	93 e0       	ldi	r25, 0x03	; 3
    2104:	90 93 32 03 	sts	0x0332, r25	; 0x800332 <pxOverflowTimerList+0x1>
    2108:	80 93 31 03 	sts	0x0331, r24	; 0x800331 <pxOverflowTimerList>
    210c:	40 e0       	ldi	r20, 0x00	; 0
    210e:	65 e0       	ldi	r22, 0x05	; 5
    2110:	8a e0       	ldi	r24, 0x0A	; 10
    2112:	0e 94 09 08 	call	0x1012	; 0x1012 <xQueueGenericCreate>
    2116:	90 93 30 03 	sts	0x0330, r25	; 0x800330 <xTimerQueue+0x1>
    211a:	80 93 2f 03 	sts	0x032F, r24	; 0x80032f <xTimerQueue>
    211e:	0f 90       	pop	r0
    2120:	0f be       	out	0x3f, r0	; 63
    2122:	08 95       	ret

00002124 <prvInsertTimerInActiveList>:
    2124:	fc 01       	movw	r30, r24
    2126:	73 83       	std	Z+3, r23	; 0x03
    2128:	62 83       	std	Z+2, r22	; 0x02
    212a:	91 87       	std	Z+9, r25	; 0x09
    212c:	80 87       	std	Z+8, r24	; 0x08
    212e:	46 17       	cp	r20, r22
    2130:	57 07       	cpc	r21, r23
    2132:	78 f0       	brcs	.+30     	; 0x2152 <prvInsertTimerInActiveList+0x2e>
    2134:	42 1b       	sub	r20, r18
    2136:	53 0b       	sbc	r21, r19
    2138:	84 85       	ldd	r24, Z+12	; 0x0c
    213a:	95 85       	ldd	r25, Z+13	; 0x0d
    213c:	48 17       	cp	r20, r24
    213e:	59 07       	cpc	r21, r25
    2140:	c8 f4       	brcc	.+50     	; 0x2174 <prvInsertTimerInActiveList+0x50>
    2142:	bf 01       	movw	r22, r30
    2144:	6e 5f       	subi	r22, 0xFE	; 254
    2146:	7f 4f       	sbci	r23, 0xFF	; 255
    2148:	80 91 31 03 	lds	r24, 0x0331	; 0x800331 <pxOverflowTimerList>
    214c:	90 91 32 03 	lds	r25, 0x0332	; 0x800332 <pxOverflowTimerList+0x1>
    2150:	0d c0       	rjmp	.+26     	; 0x216c <prvInsertTimerInActiveList+0x48>
    2152:	42 17       	cp	r20, r18
    2154:	53 07       	cpc	r21, r19
    2156:	18 f4       	brcc	.+6      	; 0x215e <prvInsertTimerInActiveList+0x3a>
    2158:	62 17       	cp	r22, r18
    215a:	73 07       	cpc	r23, r19
    215c:	58 f4       	brcc	.+22     	; 0x2174 <prvInsertTimerInActiveList+0x50>
    215e:	bf 01       	movw	r22, r30
    2160:	6e 5f       	subi	r22, 0xFE	; 254
    2162:	7f 4f       	sbci	r23, 0xFF	; 255
    2164:	80 91 33 03 	lds	r24, 0x0333	; 0x800333 <pxCurrentTimerList>
    2168:	90 91 34 03 	lds	r25, 0x0334	; 0x800334 <pxCurrentTimerList+0x1>
    216c:	0e 94 69 14 	call	0x28d2	; 0x28d2 <vListInsert>
    2170:	80 e0       	ldi	r24, 0x00	; 0
    2172:	08 95       	ret
    2174:	81 e0       	ldi	r24, 0x01	; 1
    2176:	08 95       	ret

00002178 <xTimerCreateTimerTask>:
    2178:	ef 92       	push	r14
    217a:	ff 92       	push	r15
    217c:	0f 93       	push	r16
    217e:	0e 94 69 10 	call	0x20d2	; 0x20d2 <prvCheckForValidListAndQueue>
    2182:	80 91 2f 03 	lds	r24, 0x032F	; 0x80032f <xTimerQueue>
    2186:	90 91 30 03 	lds	r25, 0x0330	; 0x800330 <xTimerQueue+0x1>
    218a:	89 2b       	or	r24, r25
    218c:	81 f0       	breq	.+32     	; 0x21ae <xTimerCreateTimerTask+0x36>
    218e:	8d e2       	ldi	r24, 0x2D	; 45
    2190:	e8 2e       	mov	r14, r24
    2192:	83 e0       	ldi	r24, 0x03	; 3
    2194:	f8 2e       	mov	r15, r24
    2196:	03 e0       	ldi	r16, 0x03	; 3
    2198:	20 e0       	ldi	r18, 0x00	; 0
    219a:	30 e0       	ldi	r19, 0x00	; 0
    219c:	45 e5       	ldi	r20, 0x55	; 85
    219e:	50 e0       	ldi	r21, 0x00	; 0
    21a0:	68 e4       	ldi	r22, 0x48	; 72
    21a2:	71 e0       	ldi	r23, 0x01	; 1
    21a4:	8c e6       	ldi	r24, 0x6C	; 108
    21a6:	91 e1       	ldi	r25, 0x11	; 17
    21a8:	0e 94 0b 0b 	call	0x1616	; 0x1616 <xTaskCreate>
    21ac:	01 c0       	rjmp	.+2      	; 0x21b0 <xTimerCreateTimerTask+0x38>
    21ae:	80 e0       	ldi	r24, 0x00	; 0
    21b0:	0f 91       	pop	r16
    21b2:	ff 90       	pop	r15
    21b4:	ef 90       	pop	r14
    21b6:	08 95       	ret

000021b8 <xTimerGenericCommand>:
    }
}
/*-----------------------------------------------------------*/

BaseType_t xTimerGenericCommand( TimerHandle_t xTimer, const BaseType_t xCommandID, const TickType_t xOptionalValue, BaseType_t * const pxHigherPriorityTaskWoken, const TickType_t xTicksToWait )
{
    21b8:	0f 93       	push	r16
    21ba:	1f 93       	push	r17
    21bc:	cf 93       	push	r28
    21be:	df 93       	push	r29
    21c0:	00 d0       	rcall	.+0      	; 0x21c2 <xTimerGenericCommand+0xa>
    21c2:	00 d0       	rcall	.+0      	; 0x21c4 <xTimerGenericCommand+0xc>
    21c4:	1f 92       	push	r1
    21c6:	cd b7       	in	r28, 0x3d	; 61
    21c8:	de b7       	in	r29, 0x3e	; 62

    configASSERT( xTimer );

    /* Send a message to the timer service task to perform a particular action
    on a particular timer definition. */
    if( xTimerQueue != NULL )
    21ca:	a0 91 2f 03 	lds	r26, 0x032F	; 0x80032f <xTimerQueue>
    21ce:	b0 91 30 03 	lds	r27, 0x0330	; 0x800330 <xTimerQueue+0x1>
    21d2:	10 97       	sbiw	r26, 0x00	; 0
    21d4:	29 f1       	breq	.+74     	; 0x2220 <xTimerGenericCommand+0x68>
    21d6:	f9 01       	movw	r30, r18
    {
        /* Send a command to the timer service task to start the xTimer timer. */
        xMessage.xMessageID = xCommandID;
    21d8:	69 83       	std	Y+1, r22	; 0x01
        xMessage.u.xTimerParameters.xMessageValue = xOptionalValue;
    21da:	5b 83       	std	Y+3, r21	; 0x03
    21dc:	4a 83       	std	Y+2, r20	; 0x02
        xMessage.u.xTimerParameters.pxTimer = xTimer;
    21de:	9d 83       	std	Y+5, r25	; 0x05
    21e0:	8c 83       	std	Y+4, r24	; 0x04

        if( xCommandID < tmrFIRST_FROM_ISR_COMMAND )
    21e2:	66 30       	cpi	r22, 0x06	; 6
    21e4:	a4 f4       	brge	.+40     	; 0x220e <xTimerGenericCommand+0x56>
        {
            if( xTaskGetSchedulerState() == taskSCHEDULER_RUNNING )
    21e6:	0e 94 65 0f 	call	0x1eca	; 0x1eca <xTaskGetSchedulerState>
    21ea:	e0 91 2f 03 	lds	r30, 0x032F	; 0x80032f <xTimerQueue>
    21ee:	f0 91 30 03 	lds	r31, 0x0330	; 0x800330 <xTimerQueue+0x1>
            {
                xReturn = xQueueSendToBack( xTimerQueue, &xMessage, xTicksToWait );
    21f2:	20 e0       	ldi	r18, 0x00	; 0
        xMessage.u.xTimerParameters.xMessageValue = xOptionalValue;
        xMessage.u.xTimerParameters.pxTimer = xTimer;

        if( xCommandID < tmrFIRST_FROM_ISR_COMMAND )
        {
            if( xTaskGetSchedulerState() == taskSCHEDULER_RUNNING )
    21f4:	82 30       	cpi	r24, 0x02	; 2
    21f6:	11 f4       	brne	.+4      	; 0x21fc <xTimerGenericCommand+0x44>
            {
                xReturn = xQueueSendToBack( xTimerQueue, &xMessage, xTicksToWait );
    21f8:	a8 01       	movw	r20, r16
    21fa:	02 c0       	rjmp	.+4      	; 0x2200 <xTimerGenericCommand+0x48>
            }
            else
            {
                xReturn = xQueueSendToBack( xTimerQueue, &xMessage, tmrNO_DELAY );
    21fc:	40 e0       	ldi	r20, 0x00	; 0
    21fe:	50 e0       	ldi	r21, 0x00	; 0
    2200:	be 01       	movw	r22, r28
    2202:	6f 5f       	subi	r22, 0xFF	; 255
    2204:	7f 4f       	sbci	r23, 0xFF	; 255
    2206:	cf 01       	movw	r24, r30
    2208:	0e 94 31 08 	call	0x1062	; 0x1062 <xQueueGenericSend>
    220c:	0a c0       	rjmp	.+20     	; 0x2222 <xTimerGenericCommand+0x6a>
            }
        }
        else
        {
            xReturn = xQueueSendToBackFromISR( xTimerQueue, &xMessage, pxHigherPriorityTaskWoken );
    220e:	20 e0       	ldi	r18, 0x00	; 0
    2210:	af 01       	movw	r20, r30
    2212:	be 01       	movw	r22, r28
    2214:	6f 5f       	subi	r22, 0xFF	; 255
    2216:	7f 4f       	sbci	r23, 0xFF	; 255
    2218:	cd 01       	movw	r24, r26
    221a:	0e 94 c7 08 	call	0x118e	; 0x118e <xQueueGenericSendFromISR>
    221e:	01 c0       	rjmp	.+2      	; 0x2222 <xTimerGenericCommand+0x6a>
}
/*-----------------------------------------------------------*/

BaseType_t xTimerGenericCommand( TimerHandle_t xTimer, const BaseType_t xCommandID, const TickType_t xOptionalValue, BaseType_t * const pxHigherPriorityTaskWoken, const TickType_t xTicksToWait )
{
BaseType_t xReturn = pdFAIL;
    2220:	80 e0       	ldi	r24, 0x00	; 0
    {
        mtCOVERAGE_TEST_MARKER();
    }

    return xReturn;
}
    2222:	0f 90       	pop	r0
    2224:	0f 90       	pop	r0
    2226:	0f 90       	pop	r0
    2228:	0f 90       	pop	r0
    222a:	0f 90       	pop	r0
    222c:	df 91       	pop	r29
    222e:	cf 91       	pop	r28
    2230:	1f 91       	pop	r17
    2232:	0f 91       	pop	r16
    2234:	08 95       	ret

00002236 <prvSwitchTimerLists>:
    }
}
/*-----------------------------------------------------------*/

static void prvSwitchTimerLists( void )
{
    2236:	ef 92       	push	r14
    2238:	ff 92       	push	r15
    223a:	0f 93       	push	r16
    223c:	1f 93       	push	r17
    223e:	cf 93       	push	r28
    2240:	df 93       	push	r29

    /* The tick count has overflowed.  The timer lists must be switched.
    If there are any timers still referenced from the current timer list
    then they must have expired and should be processed before the lists
    are switched. */
    while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
    2242:	e0 91 33 03 	lds	r30, 0x0333	; 0x800333 <pxCurrentTimerList>
    2246:	f0 91 34 03 	lds	r31, 0x0334	; 0x800334 <pxCurrentTimerList+0x1>
    224a:	80 81       	ld	r24, Z
    224c:	88 23       	and	r24, r24
    224e:	89 f1       	breq	.+98     	; 0x22b2 <prvSwitchTimerLists+0x7c>
    {
        xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
    2250:	05 80       	ldd	r0, Z+5	; 0x05
    2252:	f6 81       	ldd	r31, Z+6	; 0x06
    2254:	e0 2d       	mov	r30, r0
    2256:	e0 80       	ld	r14, Z
    2258:	f1 80       	ldd	r15, Z+1	; 0x01

        /* Remove the timer from the list. */
        pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList ); /*lint !e9087 !e9079 void * is used as this macro is used with tasks and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    225a:	c6 81       	ldd	r28, Z+6	; 0x06
    225c:	d7 81       	ldd	r29, Z+7	; 0x07
        ( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
    225e:	8e 01       	movw	r16, r28
    2260:	0e 5f       	subi	r16, 0xFE	; 254
    2262:	1f 4f       	sbci	r17, 0xFF	; 255
    2264:	c8 01       	movw	r24, r16
    2266:	0e 94 a1 14 	call	0x2942	; 0x2942 <uxListRemove>
        traceTIMER_EXPIRED( pxTimer );

        /* Execute its callback, then send a command to restart the timer if
        it is an auto-reload timer.  It cannot be restarted here as the lists
        have not yet been switched. */
        pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
    226a:	e8 89       	ldd	r30, Y+16	; 0x10
    226c:	f9 89       	ldd	r31, Y+17	; 0x11
    226e:	ce 01       	movw	r24, r28
    2270:	09 95       	icall

        if( ( pxTimer->ucStatus & tmrSTATUS_IS_AUTORELOAD ) != 0 )
    2272:	8a 89       	ldd	r24, Y+18	; 0x12
    2274:	82 ff       	sbrs	r24, 2
    2276:	e5 cf       	rjmp	.-54     	; 0x2242 <prvSwitchTimerLists+0xc>
            the timer going into the same timer list then it has already expired
            and the timer should be re-inserted into the current list so it is
            processed again within this loop.  Otherwise a command should be sent
            to restart the timer to ensure it is only inserted into a list after
            the lists have been swapped. */
            xReloadTime = ( xNextExpireTime + pxTimer->xTimerPeriodInTicks );
    2278:	8c 85       	ldd	r24, Y+12	; 0x0c
    227a:	9d 85       	ldd	r25, Y+13	; 0x0d
    227c:	8e 0d       	add	r24, r14
    227e:	9f 1d       	adc	r25, r15
            if( xReloadTime > xNextExpireTime )
    2280:	e8 16       	cp	r14, r24
    2282:	f9 06       	cpc	r15, r25
    2284:	60 f4       	brcc	.+24     	; 0x229e <prvSwitchTimerLists+0x68>
            {
                listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xReloadTime );
    2286:	9b 83       	std	Y+3, r25	; 0x03
    2288:	8a 83       	std	Y+2, r24	; 0x02
                listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
    228a:	d9 87       	std	Y+9, r29	; 0x09
    228c:	c8 87       	std	Y+8, r28	; 0x08
                vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
    228e:	b8 01       	movw	r22, r16
    2290:	80 91 33 03 	lds	r24, 0x0333	; 0x800333 <pxCurrentTimerList>
    2294:	90 91 34 03 	lds	r25, 0x0334	; 0x800334 <pxCurrentTimerList+0x1>
    2298:	0e 94 69 14 	call	0x28d2	; 0x28d2 <vListInsert>
    229c:	d2 cf       	rjmp	.-92     	; 0x2242 <prvSwitchTimerLists+0xc>
            }
            else
            {
                xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY );
    229e:	00 e0       	ldi	r16, 0x00	; 0
    22a0:	10 e0       	ldi	r17, 0x00	; 0
    22a2:	20 e0       	ldi	r18, 0x00	; 0
    22a4:	30 e0       	ldi	r19, 0x00	; 0
    22a6:	a7 01       	movw	r20, r14
    22a8:	60 e0       	ldi	r22, 0x00	; 0
    22aa:	ce 01       	movw	r24, r28
    22ac:	0e 94 dc 10 	call	0x21b8	; 0x21b8 <xTimerGenericCommand>
    22b0:	c8 cf       	rjmp	.-112    	; 0x2242 <prvSwitchTimerLists+0xc>
            mtCOVERAGE_TEST_MARKER();
        }
    }

    pxTemp = pxCurrentTimerList;
    pxCurrentTimerList = pxOverflowTimerList;
    22b2:	80 91 31 03 	lds	r24, 0x0331	; 0x800331 <pxOverflowTimerList>
    22b6:	90 91 32 03 	lds	r25, 0x0332	; 0x800332 <pxOverflowTimerList+0x1>
    22ba:	90 93 34 03 	sts	0x0334, r25	; 0x800334 <pxCurrentTimerList+0x1>
    22be:	80 93 33 03 	sts	0x0333, r24	; 0x800333 <pxCurrentTimerList>
    pxOverflowTimerList = pxTemp;
    22c2:	f0 93 32 03 	sts	0x0332, r31	; 0x800332 <pxOverflowTimerList+0x1>
    22c6:	e0 93 31 03 	sts	0x0331, r30	; 0x800331 <pxOverflowTimerList>
}
    22ca:	df 91       	pop	r29
    22cc:	cf 91       	pop	r28
    22ce:	1f 91       	pop	r17
    22d0:	0f 91       	pop	r16
    22d2:	ff 90       	pop	r15
    22d4:	ef 90       	pop	r14
    22d6:	08 95       	ret

000022d8 <prvTimerTask>:
    pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
}
/*-----------------------------------------------------------*/

static portTASK_FUNCTION( prvTimerTask, pvParameters )
{
    22d8:	cf 93       	push	r28
    22da:	df 93       	push	r29
    22dc:	00 d0       	rcall	.+0      	; 0x22de <prvTimerTask+0x6>
    22de:	00 d0       	rcall	.+0      	; 0x22e0 <prvTimerTask+0x8>
    22e0:	1f 92       	push	r1
    22e2:	cd b7       	in	r28, 0x3d	; 61
    22e4:	de b7       	in	r29, 0x3e	; 62
    the timer with the nearest expiry time will expire.  If there are no
    active timers then just set the next expire time to 0.  That will cause
    this task to unblock when the tick count overflows, at which point the
    timer lists will be switched and the next expiry time can be
    re-assessed.  */
    *pxListWasEmpty = listLIST_IS_EMPTY( pxCurrentTimerList );
    22e6:	e0 91 33 03 	lds	r30, 0x0333	; 0x800333 <pxCurrentTimerList>
    22ea:	f0 91 34 03 	lds	r31, 0x0334	; 0x800334 <pxCurrentTimerList+0x1>
    22ee:	d0 80       	ld	r13, Z
    if( *pxListWasEmpty == pdFALSE )
    22f0:	dd 20       	and	r13, r13
    22f2:	31 f0       	breq	.+12     	; 0x2300 <prvTimerTask+0x28>
    {
        xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
    22f4:	05 80       	ldd	r0, Z+5	; 0x05
    22f6:	f6 81       	ldd	r31, Z+6	; 0x06
    22f8:	e0 2d       	mov	r30, r0
    22fa:	e0 80       	ld	r14, Z
    22fc:	f1 80       	ldd	r15, Z+1	; 0x01
    22fe:	02 c0       	rjmp	.+4      	; 0x2304 <prvTimerTask+0x2c>
    }
    else
    {
        /* Ensure the task unblocks when the tick count rolls over. */
        xNextExpireTime = ( TickType_t ) 0U;
    2300:	e1 2c       	mov	r14, r1
    2302:	f1 2c       	mov	r15, r1
static void prvProcessTimerOrBlockTask( const TickType_t xNextExpireTime, BaseType_t xListWasEmpty )
{
TickType_t xTimeNow;
BaseType_t xTimerListsWereSwitched;

    vTaskSuspendAll();
    2304:	0e 94 8e 0c 	call	0x191c	; 0x191c <vTaskSuspendAll>
static TickType_t prvSampleTimeNow( BaseType_t * const pxTimerListsWereSwitched )
{
TickType_t xTimeNow;
PRIVILEGED_DATA static TickType_t xLastTime = ( TickType_t ) 0U; /*lint !e956 Variable is only accessible to one task. */

    xTimeNow = xTaskGetTickCount();
    2308:	0e 94 94 0c 	call	0x1928	; 0x1928 <xTaskGetTickCount>
    230c:	8c 01       	movw	r16, r24

    if( xTimeNow < xLastTime )
    230e:	80 91 2b 03 	lds	r24, 0x032B	; 0x80032b <xLastTime.2412>
    2312:	90 91 2c 03 	lds	r25, 0x032C	; 0x80032c <xLastTime.2412+0x1>
    2316:	08 17       	cp	r16, r24
    2318:	19 07       	cpc	r17, r25
    231a:	20 f4       	brcc	.+8      	; 0x2324 <prvTimerTask+0x4c>
    {
        prvSwitchTimerLists();
    231c:	0e 94 1b 11 	call	0x2236	; 0x2236 <prvSwitchTimerLists>
        *pxTimerListsWereSwitched = pdTRUE;
    2320:	81 e0       	ldi	r24, 0x01	; 1
    2322:	01 c0       	rjmp	.+2      	; 0x2326 <prvTimerTask+0x4e>
    }
    else
    {
        *pxTimerListsWereSwitched = pdFALSE;
    2324:	80 e0       	ldi	r24, 0x00	; 0
    }

    xLastTime = xTimeNow;
    2326:	10 93 2c 03 	sts	0x032C, r17	; 0x80032c <xLastTime.2412+0x1>
    232a:	00 93 2b 03 	sts	0x032B, r16	; 0x80032b <xLastTime.2412>
        has expired or not.  If obtaining the time causes the lists to switch
        then don't process this timer as any timers that remained in the list
        when the lists were switched will have been processed within the
        prvSampleTimeNow() function. */
        xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
        if( xTimerListsWereSwitched == pdFALSE )
    232e:	81 11       	cpse	r24, r1
    2330:	55 c0       	rjmp	.+170    	; 0x23dc <prvTimerTask+0x104>
        {
            /* The tick count has not overflowed, has the timer expired? */
            if( ( xListWasEmpty == pdFALSE ) && ( xNextExpireTime <= xTimeNow ) )
    2332:	dd 20       	and	r13, r13
    2334:	d9 f1       	breq	.+118    	; 0x23ac <prvTimerTask+0xd4>
    2336:	0e 15       	cp	r16, r14
    2338:	1f 05       	cpc	r17, r15
    233a:	08 f4       	brcc	.+2      	; 0x233e <prvTimerTask+0x66>
    233c:	3e c0       	rjmp	.+124    	; 0x23ba <prvTimerTask+0xe2>
            {
                ( void ) xTaskResumeAll();
    233e:	0e 94 4a 0d 	call	0x1a94	; 0x1a94 <xTaskResumeAll>
/*-----------------------------------------------------------*/

static void prvProcessExpiredTimer( const TickType_t xNextExpireTime, const TickType_t xTimeNow )
{
BaseType_t xResult;
Timer_t * const pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList ); /*lint !e9087 !e9079 void * is used as this macro is used with tasks and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    2342:	e0 91 33 03 	lds	r30, 0x0333	; 0x800333 <pxCurrentTimerList>
    2346:	f0 91 34 03 	lds	r31, 0x0334	; 0x800334 <pxCurrentTimerList+0x1>
    234a:	05 80       	ldd	r0, Z+5	; 0x05
    234c:	f6 81       	ldd	r31, Z+6	; 0x06
    234e:	e0 2d       	mov	r30, r0
    2350:	c6 80       	ldd	r12, Z+6	; 0x06
    2352:	d7 80       	ldd	r13, Z+7	; 0x07

    /* Remove the timer from the list of active timers.  A check has already
    been performed to ensure the list is not empty. */
    ( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
    2354:	c6 01       	movw	r24, r12
    2356:	02 96       	adiw	r24, 0x02	; 2
    2358:	0e 94 a1 14 	call	0x2942	; 0x2942 <uxListRemove>
    traceTIMER_EXPIRED( pxTimer );

    /* If the timer is an auto reload timer then calculate the next
    expiry time and re-insert the timer in the list of active timers. */
    if( ( pxTimer->ucStatus & tmrSTATUS_IS_AUTORELOAD ) != 0 )
    235c:	d6 01       	movw	r26, r12
    235e:	52 96       	adiw	r26, 0x12	; 18
    2360:	8c 91       	ld	r24, X
    2362:	52 97       	sbiw	r26, 0x12	; 18
    2364:	82 ff       	sbrs	r24, 2
    2366:	17 c0       	rjmp	.+46     	; 0x2396 <prvTimerTask+0xbe>
    {
        /* The timer is inserted into a list using a time relative to anything
        other than the current time.  It will therefore be inserted into the
        correct list relative to the time this task thinks it is now. */
        if( prvInsertTimerInActiveList( pxTimer, ( xNextExpireTime + pxTimer->xTimerPeriodInTicks ), xTimeNow, xNextExpireTime ) != pdFALSE )
    2368:	1c 96       	adiw	r26, 0x0c	; 12
    236a:	6d 91       	ld	r22, X+
    236c:	7c 91       	ld	r23, X
    236e:	1d 97       	sbiw	r26, 0x0d	; 13
    2370:	6e 0d       	add	r22, r14
    2372:	7f 1d       	adc	r23, r15
    2374:	97 01       	movw	r18, r14
    2376:	a8 01       	movw	r20, r16
    2378:	c6 01       	movw	r24, r12
    237a:	0e 94 92 10 	call	0x2124	; 0x2124 <prvInsertTimerInActiveList>
    237e:	88 23       	and	r24, r24
    2380:	69 f0       	breq	.+26     	; 0x239c <prvTimerTask+0xc4>
        {
            /* The timer expired before it was added to the active timer
            list.  Reload it now.  */
            xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY );
    2382:	00 e0       	ldi	r16, 0x00	; 0
    2384:	10 e0       	ldi	r17, 0x00	; 0
    2386:	20 e0       	ldi	r18, 0x00	; 0
    2388:	30 e0       	ldi	r19, 0x00	; 0
    238a:	a7 01       	movw	r20, r14
    238c:	60 e0       	ldi	r22, 0x00	; 0
    238e:	c6 01       	movw	r24, r12
    2390:	0e 94 dc 10 	call	0x21b8	; 0x21b8 <xTimerGenericCommand>
    2394:	03 c0       	rjmp	.+6      	; 0x239c <prvTimerTask+0xc4>
            mtCOVERAGE_TEST_MARKER();
        }
    }
    else
    {
        pxTimer->ucStatus &= ~tmrSTATUS_IS_ACTIVE;
    2396:	8e 7f       	andi	r24, 0xFE	; 254
    2398:	f6 01       	movw	r30, r12
    239a:	82 8b       	std	Z+18, r24	; 0x12
        mtCOVERAGE_TEST_MARKER();
    }

    /* Call the timer callback. */
    pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
    239c:	d6 01       	movw	r26, r12
    239e:	50 96       	adiw	r26, 0x10	; 16
    23a0:	ed 91       	ld	r30, X+
    23a2:	fc 91       	ld	r31, X
    23a4:	51 97       	sbiw	r26, 0x11	; 17
    23a6:	c6 01       	movw	r24, r12
    23a8:	09 95       	icall
    23aa:	1e c0       	rjmp	.+60     	; 0x23e8 <prvTimerTask+0x110>
                case when the current timer list is empty. */
                if( xListWasEmpty != pdFALSE )
                {
                    /* The current timer list is empty - is the overflow list
                    also empty? */
                    xListWasEmpty = listLIST_IS_EMPTY( pxOverflowTimerList );
    23ac:	e0 91 31 03 	lds	r30, 0x0331	; 0x800331 <pxOverflowTimerList>
    23b0:	f0 91 32 03 	lds	r31, 0x0332	; 0x800332 <pxOverflowTimerList+0x1>
    23b4:	80 81       	ld	r24, Z
    23b6:	41 e0       	ldi	r20, 0x01	; 1
    23b8:	81 11       	cpse	r24, r1
        prvSampleTimeNow() function. */
        xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
        if( xTimerListsWereSwitched == pdFALSE )
        {
            /* The tick count has not overflowed, has the timer expired? */
            if( ( xListWasEmpty == pdFALSE ) && ( xNextExpireTime <= xTimeNow ) )
    23ba:	40 e0       	ldi	r20, 0x00	; 0
                    /* The current timer list is empty - is the overflow list
                    also empty? */
                    xListWasEmpty = listLIST_IS_EMPTY( pxOverflowTimerList );
                }

                vQueueWaitForMessageRestricted( xTimerQueue, ( xNextExpireTime - xTimeNow ), xListWasEmpty );
    23bc:	b7 01       	movw	r22, r14
    23be:	60 1b       	sub	r22, r16
    23c0:	71 0b       	sbc	r23, r17
    23c2:	80 91 2f 03 	lds	r24, 0x032F	; 0x80032f <xTimerQueue>
    23c6:	90 91 30 03 	lds	r25, 0x0330	; 0x800330 <xTimerQueue+0x1>
    23ca:	0e 94 4a 0a 	call	0x1494	; 0x1494 <vQueueWaitForMessageRestricted>

                if( xTaskResumeAll() == pdFALSE )
    23ce:	0e 94 4a 0d 	call	0x1a94	; 0x1a94 <xTaskResumeAll>
    23d2:	81 11       	cpse	r24, r1
    23d4:	09 c0       	rjmp	.+18     	; 0x23e8 <prvTimerTask+0x110>
                {
                    /* Yield to wait for either a command to arrive, or the
                    block time to expire.  If a command arrived between the
                    critical section being exited and this yield then the yield
                    will not cause the task to block. */
                    portYIELD_WITHIN_API();
    23d6:	0e 94 69 15 	call	0x2ad2	; 0x2ad2 <vPortYield>
    23da:	06 c0       	rjmp	.+12     	; 0x23e8 <prvTimerTask+0x110>
                }
            }
        }
        else
        {
            ( void ) xTaskResumeAll();
    23dc:	0e 94 4a 0d 	call	0x1a94	; 0x1a94 <xTaskResumeAll>
    23e0:	03 c0       	rjmp	.+6      	; 0x23e8 <prvTimerTask+0x110>
        }
        #endif /* INCLUDE_xTimerPendFunctionCall */

        /* Commands that are positive are timer commands rather than pended
        function calls. */
        if( xMessage.xMessageID >= ( BaseType_t ) 0 )
    23e2:	89 81       	ldd	r24, Y+1	; 0x01
    23e4:	87 ff       	sbrs	r24, 7
    23e6:	0e c0       	rjmp	.+28     	; 0x2404 <prvTimerTask+0x12c>
DaemonTaskMessage_t xMessage;
Timer_t *pxTimer;
BaseType_t xTimerListsWereSwitched, xResult;
TickType_t xTimeNow;

    while( xQueueReceive( xTimerQueue, &xMessage, tmrNO_DELAY ) != pdFAIL ) /*lint !e603 xMessage does not have to be initialised as it is passed out, not in, and it is not used unless xQueueReceive() returns pdTRUE. */
    23e8:	40 e0       	ldi	r20, 0x00	; 0
    23ea:	50 e0       	ldi	r21, 0x00	; 0
    23ec:	be 01       	movw	r22, r28
    23ee:	6f 5f       	subi	r22, 0xFF	; 255
    23f0:	7f 4f       	sbci	r23, 0xFF	; 255
    23f2:	80 91 2f 03 	lds	r24, 0x032F	; 0x80032f <xTimerQueue>
    23f6:	90 91 30 03 	lds	r25, 0x0330	; 0x800330 <xTimerQueue+0x1>
    23fa:	0e 94 f6 08 	call	0x11ec	; 0x11ec <xQueueReceive>
    23fe:	81 11       	cpse	r24, r1
    2400:	f0 cf       	rjmp	.-32     	; 0x23e2 <prvTimerTask+0x10a>
    2402:	71 cf       	rjmp	.-286    	; 0x22e6 <prvTimerTask+0xe>
        function calls. */
        if( xMessage.xMessageID >= ( BaseType_t ) 0 )
        {
            /* The messages uses the xTimerParameters member to work on a
            software timer. */
            pxTimer = xMessage.u.xTimerParameters.pxTimer;
    2404:	ec 80       	ldd	r14, Y+4	; 0x04
    2406:	fd 80       	ldd	r15, Y+5	; 0x05

        if( listIS_CONTAINED_WITHIN( NULL, &( pxTimer->xTimerListItem ) ) == pdFALSE ) /*lint !e961. The cast is only redundant when NULL is passed into the macro. */
    2408:	f7 01       	movw	r30, r14
    240a:	82 85       	ldd	r24, Z+10	; 0x0a
    240c:	93 85       	ldd	r25, Z+11	; 0x0b
    240e:	89 2b       	or	r24, r25
    2410:	21 f0       	breq	.+8      	; 0x241a <prvTimerTask+0x142>
            {
                /* The timer is in a list, remove it. */
                ( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
    2412:	c7 01       	movw	r24, r14
    2414:	02 96       	adiw	r24, 0x02	; 2
    2416:	0e 94 a1 14 	call	0x2942	; 0x2942 <uxListRemove>
static TickType_t prvSampleTimeNow( BaseType_t * const pxTimerListsWereSwitched )
{
TickType_t xTimeNow;
PRIVILEGED_DATA static TickType_t xLastTime = ( TickType_t ) 0U; /*lint !e956 Variable is only accessible to one task. */

    xTimeNow = xTaskGetTickCount();
    241a:	0e 94 94 0c 	call	0x1928	; 0x1928 <xTaskGetTickCount>
    241e:	6c 01       	movw	r12, r24

    if( xTimeNow < xLastTime )
    2420:	80 91 2b 03 	lds	r24, 0x032B	; 0x80032b <xLastTime.2412>
    2424:	90 91 2c 03 	lds	r25, 0x032C	; 0x80032c <xLastTime.2412+0x1>
    2428:	c8 16       	cp	r12, r24
    242a:	d9 06       	cpc	r13, r25
    242c:	10 f4       	brcc	.+4      	; 0x2432 <prvTimerTask+0x15a>
    {
        prvSwitchTimerLists();
    242e:	0e 94 1b 11 	call	0x2236	; 0x2236 <prvSwitchTimerLists>
    else
    {
        *pxTimerListsWereSwitched = pdFALSE;
    }

    xLastTime = xTimeNow;
    2432:	d0 92 2c 03 	sts	0x032C, r13	; 0x80032c <xLastTime.2412+0x1>
    2436:	c0 92 2b 03 	sts	0x032B, r12	; 0x80032b <xLastTime.2412>
            possibility of a higher priority task adding a message to the message
            queue with a time that is ahead of the timer daemon task (because it
            pre-empted the timer daemon task after the xTimeNow value was set). */
            xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );

            switch( xMessage.xMessageID )
    243a:	e9 81       	ldd	r30, Y+1	; 0x01
    243c:	0e 2e       	mov	r0, r30
    243e:	00 0c       	add	r0, r0
    2440:	ff 0b       	sbc	r31, r31
    2442:	ea 30       	cpi	r30, 0x0A	; 10
    2444:	f1 05       	cpc	r31, r1
    2446:	80 f6       	brcc	.-96     	; 0x23e8 <prvTimerTask+0x110>
    2448:	ec 5c       	subi	r30, 0xCC	; 204
    244a:	ff 4f       	sbci	r31, 0xFF	; 255
    244c:	d7 01       	movw	r26, r14
    244e:	52 96       	adiw	r26, 0x12	; 18
    2450:	8c 91       	ld	r24, X
    2452:	0c 94 8d 17 	jmp	0x2f1a	; 0x2f1a <__tablejump2__>
                case tmrCOMMAND_START_FROM_ISR :
                case tmrCOMMAND_RESET :
                case tmrCOMMAND_RESET_FROM_ISR :
                case tmrCOMMAND_START_DONT_TRACE :
                    /* Start or restart a timer. */
                    pxTimer->ucStatus |= tmrSTATUS_IS_ACTIVE;
    2456:	81 60       	ori	r24, 0x01	; 1
    2458:	f7 01       	movw	r30, r14
    245a:	82 8b       	std	Z+18, r24	; 0x12
                    if( prvInsertTimerInActiveList( pxTimer,  xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, xTimeNow, xMessage.u.xTimerParameters.xMessageValue ) != pdFALSE )
    245c:	2a 81       	ldd	r18, Y+2	; 0x02
    245e:	3b 81       	ldd	r19, Y+3	; 0x03
    2460:	64 85       	ldd	r22, Z+12	; 0x0c
    2462:	75 85       	ldd	r23, Z+13	; 0x0d
    2464:	62 0f       	add	r22, r18
    2466:	73 1f       	adc	r23, r19
    2468:	a6 01       	movw	r20, r12
    246a:	c7 01       	movw	r24, r14
    246c:	0e 94 92 10 	call	0x2124	; 0x2124 <prvInsertTimerInActiveList>
    2470:	88 23       	and	r24, r24
    2472:	09 f4       	brne	.+2      	; 0x2476 <prvTimerTask+0x19e>
    2474:	b9 cf       	rjmp	.-142    	; 0x23e8 <prvTimerTask+0x110>
                    {
                        /* The timer expired before it was added to the active
                        timer list.  Process it now. */
                        pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
    2476:	d7 01       	movw	r26, r14
    2478:	50 96       	adiw	r26, 0x10	; 16
    247a:	ed 91       	ld	r30, X+
    247c:	fc 91       	ld	r31, X
    247e:	51 97       	sbiw	r26, 0x11	; 17
    2480:	c7 01       	movw	r24, r14
    2482:	09 95       	icall
                        traceTIMER_EXPIRED( pxTimer );

                        if( ( pxTimer->ucStatus & tmrSTATUS_IS_AUTORELOAD ) != 0 )
    2484:	f7 01       	movw	r30, r14
    2486:	82 89       	ldd	r24, Z+18	; 0x12
    2488:	82 ff       	sbrs	r24, 2
    248a:	ae cf       	rjmp	.-164    	; 0x23e8 <prvTimerTask+0x110>
                        {
                            xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, NULL, tmrNO_DELAY );
    248c:	4a 81       	ldd	r20, Y+2	; 0x02
    248e:	5b 81       	ldd	r21, Y+3	; 0x03
    2490:	84 85       	ldd	r24, Z+12	; 0x0c
    2492:	95 85       	ldd	r25, Z+13	; 0x0d
    2494:	48 0f       	add	r20, r24
    2496:	59 1f       	adc	r21, r25
    2498:	00 e0       	ldi	r16, 0x00	; 0
    249a:	10 e0       	ldi	r17, 0x00	; 0
    249c:	20 e0       	ldi	r18, 0x00	; 0
    249e:	30 e0       	ldi	r19, 0x00	; 0
    24a0:	60 e0       	ldi	r22, 0x00	; 0
    24a2:	c7 01       	movw	r24, r14
    24a4:	0e 94 dc 10 	call	0x21b8	; 0x21b8 <xTimerGenericCommand>
    24a8:	9f cf       	rjmp	.-194    	; 0x23e8 <prvTimerTask+0x110>
                    pxTimer->ucStatus &= ~tmrSTATUS_IS_ACTIVE;
                    break;

                case tmrCOMMAND_CHANGE_PERIOD :
                case tmrCOMMAND_CHANGE_PERIOD_FROM_ISR :
                    pxTimer->ucStatus |= tmrSTATUS_IS_ACTIVE;
    24aa:	81 60       	ori	r24, 0x01	; 1
    24ac:	f7 01       	movw	r30, r14
    24ae:	82 8b       	std	Z+18, r24	; 0x12
                    pxTimer->xTimerPeriodInTicks = xMessage.u.xTimerParameters.xMessageValue;
    24b0:	6a 81       	ldd	r22, Y+2	; 0x02
    24b2:	7b 81       	ldd	r23, Y+3	; 0x03
    24b4:	75 87       	std	Z+13, r23	; 0x0d
    24b6:	64 87       	std	Z+12, r22	; 0x0c
                    be longer or shorter than the old one.  The command time is
                    therefore set to the current time, and as the period cannot
                    be zero the next expiry time can only be in the future,
                    meaning (unlike for the xTimerStart() case above) there is
                    no fail case that needs to be handled here. */
                    ( void ) prvInsertTimerInActiveList( pxTimer, ( xTimeNow + pxTimer->xTimerPeriodInTicks ), xTimeNow, xTimeNow );
    24b8:	6c 0d       	add	r22, r12
    24ba:	7d 1d       	adc	r23, r13
    24bc:	96 01       	movw	r18, r12
    24be:	a6 01       	movw	r20, r12
    24c0:	c7 01       	movw	r24, r14
    24c2:	0e 94 92 10 	call	0x2124	; 0x2124 <prvInsertTimerInActiveList>
    24c6:	90 cf       	rjmp	.-224    	; 0x23e8 <prvTimerTask+0x110>
                    #if ( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
                    {
                    /* The timer has already been removed from the active list,
                    just free up the memory if the memory was dynamically
                    allocated. */
                        if( ( pxTimer->ucStatus & tmrSTATUS_IS_STATICALLY_ALLOCATED ) == ( uint8_t ) 0 )
    24c8:	81 fd       	sbrc	r24, 1
    24ca:	04 c0       	rjmp	.+8      	; 0x24d4 <prvTimerTask+0x1fc>
                        {
                            vPortFree( pxTimer );
    24cc:	c7 01       	movw	r24, r14
    24ce:	0e 94 25 14 	call	0x284a	; 0x284a <vPortFree>
    24d2:	8a cf       	rjmp	.-236    	; 0x23e8 <prvTimerTask+0x110>
                        }
                        else
                        {
                            pxTimer->ucStatus &= ~tmrSTATUS_IS_ACTIVE;
    24d4:	8e 7f       	andi	r24, 0xFE	; 254
    24d6:	d7 01       	movw	r26, r14
    24d8:	52 96       	adiw	r26, 0x12	; 18
    24da:	8c 93       	st	X, r24
    24dc:	85 cf       	rjmp	.-246    	; 0x23e8 <prvTimerTask+0x110>

000024de <initVariant>:
{
#if defined(USBCON)
    USBDevice.attach();
#endif

    setup();        // the normal Arduino setup() function is run here.
    24de:	0e 94 f3 02 	call	0x5e6	; 0x5e6 <setup>
    vTaskStartScheduler(); // initialise and run the freeRTOS scheduler. Execution should never return here.
    24e2:	0e 94 60 0c 	call	0x18c0	; 0x18c0 <vTaskStartScheduler>
    24e6:	08 95       	ret

000024e8 <vApplicationIdleHook>:
 */
void vApplicationIdleHook( void ) __attribute__((weak));

void vApplicationIdleHook( void )
{
    loop();        // the normal Arduino loop() function is run here.
    24e8:	0e 94 53 03 	call	0x6a6	; 0x6a6 <loop>
    if (serialEventRun) serialEventRun();
    24ec:	8c e9       	ldi	r24, 0x9C	; 156
    24ee:	93 e0       	ldi	r25, 0x03	; 3
    24f0:	89 2b       	or	r24, r25
    24f2:	11 f0       	breq	.+4      	; 0x24f8 <vApplicationIdleHook+0x10>
    24f4:	0c 94 9c 03 	jmp	0x738	; 0x738 <_Z14serialEventRunv>
    24f8:	08 95       	ret

000024fa <vApplicationMallocFailedHook>:
#elif defined(__AVR_ATmega644P__) || defined(__AVR_ATmega644PA__) || defined(__AVR_ATmega1284P__) || defined(__AVR_ATmega1284PA__) // Seeed Goldilocks with 1284p
    DDRB  |= _BV(DDB7);
    PORTB |= _BV(PORTB7);       // Main (red PB7) LED on. Main LED on.

#elif defined(__AVR_ATmega328P__) || defined(__AVR_ATmega168__) || defined(__AVR_ATmega8__) // assume we're using an Arduino Uno with 328p
    DDRB  |= _BV(DDB5);
    24fa:	25 9a       	sbi	0x04, 5	; 4
    PORTB |= _BV(PORTB5);       // Main (red PB5) LED on. Main LED on.
    24fc:	2d 9a       	sbi	0x05, 5	; 5
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    24fe:	2f ef       	ldi	r18, 0xFF	; 255
    2500:	80 e7       	ldi	r24, 0x70	; 112
    2502:	92 e0       	ldi	r25, 0x02	; 2
    2504:	21 50       	subi	r18, 0x01	; 1
    2506:	80 40       	sbci	r24, 0x00	; 0
    2508:	90 40       	sbci	r25, 0x00	; 0
    250a:	e1 f7       	brne	.-8      	; 0x2504 <vApplicationMallocFailedHook+0xa>
    250c:	00 c0       	rjmp	.+0      	; 0x250e <vApplicationMallocFailedHook+0x14>
    250e:	00 00       	nop

#elif defined(__AVR_ATmega644P__) || defined(__AVR_ATmega644PA__) || defined(__AVR_ATmega1284P__) || defined(__AVR_ATmega1284PA__) // Seeed Goldilocks with 1284p
        PINB  |= _BV(PINB7);       // Main (red PB7) LED toggle. Main LED fast blink.

#elif defined(__AVR_ATmega328P__) || defined(__AVR_ATmega168__) || defined(__AVR_ATmega8__) // assume we're using an Arduino Uno with 328p
        PINB  |= _BV(PINB5);       // Main (red PB5) LED toggle. Main LED fast blink.
    2510:	1d 9a       	sbi	0x03, 5	; 3
    2512:	f5 cf       	rjmp	.-22     	; 0x24fe <vApplicationMallocFailedHook+0x4>

00002514 <vApplicationStackOverflowHook>:
#elif defined(__AVR_ATmega644P__) || defined(__AVR_ATmega644PA__) || defined(__AVR_ATmega1284P__) || defined(__AVR_ATmega1284PA__) // Seeed Goldilocks with 1284p
    DDRB  |= _BV(DDB7);
    PORTB |= _BV(PORTB7);       // Main (red PB7) LED on. Main LED on.

#elif defined(__AVR_ATmega328P__) || defined(__AVR_ATmega168__) || defined(__AVR_ATmega8__) // assume we're using an Arduino Uno with 328p
    DDRB  |= _BV(DDB5);
    2514:	25 9a       	sbi	0x04, 5	; 4
    PORTB |= _BV(PORTB5);       // Main (red PB5) LED on. Main LED on.
    2516:	2d 9a       	sbi	0x05, 5	; 5
    2518:	2f ef       	ldi	r18, 0xFF	; 255
    251a:	87 ea       	ldi	r24, 0xA7	; 167
    251c:	91 e6       	ldi	r25, 0x61	; 97
    251e:	21 50       	subi	r18, 0x01	; 1
    2520:	80 40       	sbci	r24, 0x00	; 0
    2522:	90 40       	sbci	r25, 0x00	; 0
    2524:	e1 f7       	brne	.-8      	; 0x251e <vApplicationStackOverflowHook+0xa>
    2526:	00 c0       	rjmp	.+0      	; 0x2528 <vApplicationStackOverflowHook+0x14>
    2528:	00 00       	nop

#elif defined(__AVR_ATmega644P__) || defined(__AVR_ATmega644PA__) || defined(__AVR_ATmega1284P__) || defined(__AVR_ATmega1284PA__) // Seeed Goldilocks with 1284p
        PINB  |= _BV(PINB7);       // Main (red PB7) LED toggle. Main LED slow blink.

#elif defined(__AVR_ATmega328P__) || defined(__AVR_ATmega168__) || defined(__AVR_ATmega8__) // assume we're using an Arduino Uno with 328p
        PINB  |= _BV(PINB5);       // Main (red PB5) LED toggle. Main LED slow blink.
    252a:	1d 9a       	sbi	0x03, 5	; 3
    252c:	f5 cf       	rjmp	.-22     	; 0x2518 <vApplicationStackOverflowHook+0x4>

0000252e <_ZN9MD_TCS23010initialiseEv>:
  }
  FreqCount.end();      // stop
  DUMP("VALUE ", FreqCount.read());

  return(FreqCount.read() * _readDiv);
}
    252e:	0f 93       	push	r16
    2530:	1f 93       	push	r17
    2532:	fc 01       	movw	r30, r24
    2534:	8f ef       	ldi	r24, 0xFF	; 255
    2536:	80 83       	st	Z, r24
    2538:	81 83       	std	Z+1, r24	; 0x01
    253a:	82 83       	std	Z+2, r24	; 0x02
    253c:	83 83       	std	Z+3, r24	; 0x03
    253e:	84 83       	std	Z+4, r24	; 0x04
    2540:	8a e0       	ldi	r24, 0x0A	; 10
    2542:	85 83       	std	Z+5, r24	; 0x05
    2544:	16 82       	std	Z+6, r1	; 0x06
    2546:	df 01       	movw	r26, r30
    2548:	17 96       	adiw	r26, 0x07	; 7
    254a:	73 96       	adiw	r30, 0x13	; 19
    254c:	00 e7       	ldi	r16, 0x70	; 112
    254e:	17 e1       	ldi	r17, 0x17	; 23
    2550:	20 e0       	ldi	r18, 0x00	; 0
    2552:	30 e0       	ldi	r19, 0x00	; 0
    2554:	48 ed       	ldi	r20, 0xD8	; 216
    2556:	56 ed       	ldi	r21, 0xD6	; 214
    2558:	60 e0       	ldi	r22, 0x00	; 0
    255a:	70 e0       	ldi	r23, 0x00	; 0
    255c:	0d 93       	st	X+, r16
    255e:	1d 93       	st	X+, r17
    2560:	2d 93       	st	X+, r18
    2562:	3d 93       	st	X+, r19
    2564:	18 96       	adiw	r26, 0x08	; 8
    2566:	4d 93       	st	X+, r20
    2568:	5d 93       	st	X+, r21
    256a:	6d 93       	st	X+, r22
    256c:	7c 93       	st	X, r23
    256e:	1b 97       	sbiw	r26, 0x0b	; 11
    2570:	ae 17       	cp	r26, r30
    2572:	bf 07       	cpc	r27, r31
    2574:	99 f7       	brne	.-26     	; 0x255c <_ZN9MD_TCS23010initialiseEv+0x2e>
    2576:	1f 91       	pop	r17
    2578:	0f 91       	pop	r16
    257a:	08 95       	ret

0000257c <_ZN9MD_TCS230C1Ehhh>:
    257c:	ff 92       	push	r15
    257e:	0f 93       	push	r16
    2580:	1f 93       	push	r17
    2582:	cf 93       	push	r28
    2584:	df 93       	push	r29
    2586:	ec 01       	movw	r28, r24
    2588:	f6 2e       	mov	r15, r22
    258a:	04 2f       	mov	r16, r20
    258c:	12 2f       	mov	r17, r18
    258e:	0e 94 97 12 	call	0x252e	; 0x252e <_ZN9MD_TCS23010initialiseEv>
    2592:	fb 82       	std	Y+3, r15	; 0x03
    2594:	0c 83       	std	Y+4, r16	; 0x04
    2596:	18 83       	st	Y, r17
    2598:	df 91       	pop	r29
    259a:	cf 91       	pop	r28
    259c:	1f 91       	pop	r17
    259e:	0f 91       	pop	r16
    25a0:	ff 90       	pop	r15
    25a2:	08 95       	ret

000025a4 <_ZN9MD_TCS230D1Ev>:
    25a4:	08 95       	ret

000025a6 <_ZN9MD_TCS2309setFilterEh>:
    25a6:	cf 93       	push	r28
    25a8:	df 93       	push	r29
    25aa:	ec 01       	movw	r28, r24
    25ac:	8b 81       	ldd	r24, Y+3	; 0x03
    25ae:	8f 3f       	cpi	r24, 0xFF	; 255
    25b0:	e9 f0       	breq	.+58     	; 0x25ec <_ZN9MD_TCS2309setFilterEh+0x46>
    25b2:	9c 81       	ldd	r25, Y+4	; 0x04
    25b4:	9f 3f       	cpi	r25, 0xFF	; 255
    25b6:	d1 f0       	breq	.+52     	; 0x25ec <_ZN9MD_TCS2309setFilterEh+0x46>
    25b8:	61 30       	cpi	r22, 0x01	; 1
    25ba:	49 f0       	breq	.+18     	; 0x25ce <_ZN9MD_TCS2309setFilterEh+0x28>
    25bc:	30 f0       	brcs	.+12     	; 0x25ca <_ZN9MD_TCS2309setFilterEh+0x24>
    25be:	62 30       	cpi	r22, 0x02	; 2
    25c0:	41 f0       	breq	.+16     	; 0x25d2 <_ZN9MD_TCS2309setFilterEh+0x2c>
    25c2:	63 30       	cpi	r22, 0x03	; 3
    25c4:	99 f4       	brne	.+38     	; 0x25ec <_ZN9MD_TCS2309setFilterEh+0x46>
    25c6:	61 e0       	ldi	r22, 0x01	; 1
    25c8:	09 c0       	rjmp	.+18     	; 0x25dc <_ZN9MD_TCS2309setFilterEh+0x36>
    25ca:	60 e0       	ldi	r22, 0x00	; 0
    25cc:	07 c0       	rjmp	.+14     	; 0x25dc <_ZN9MD_TCS2309setFilterEh+0x36>
    25ce:	61 e0       	ldi	r22, 0x01	; 1
    25d0:	01 c0       	rjmp	.+2      	; 0x25d4 <_ZN9MD_TCS2309setFilterEh+0x2e>
    25d2:	60 e0       	ldi	r22, 0x00	; 0
    25d4:	0e 94 e5 06 	call	0xdca	; 0xdca <digitalWrite>
    25d8:	61 e0       	ldi	r22, 0x01	; 1
    25da:	03 c0       	rjmp	.+6      	; 0x25e2 <_ZN9MD_TCS2309setFilterEh+0x3c>
    25dc:	0e 94 e5 06 	call	0xdca	; 0xdca <digitalWrite>
    25e0:	60 e0       	ldi	r22, 0x00	; 0
    25e2:	8c 81       	ldd	r24, Y+4	; 0x04
    25e4:	df 91       	pop	r29
    25e6:	cf 91       	pop	r28
    25e8:	0c 94 e5 06 	jmp	0xdca	; 0xdca <digitalWrite>
    25ec:	df 91       	pop	r29
    25ee:	cf 91       	pop	r28
    25f0:	08 95       	ret

000025f2 <_ZN9MD_TCS23013setFrequency2Eh>:
    25f2:	cf 93       	push	r28
    25f4:	df 93       	push	r29
    25f6:	ec 01       	movw	r28, r24
    25f8:	89 81       	ldd	r24, Y+1	; 0x01
    25fa:	8f 3f       	cpi	r24, 0xFF	; 255
    25fc:	e9 f0       	breq	.+58     	; 0x2638 <_ZN9MD_TCS23013setFrequency2Eh+0x46>
    25fe:	9a 81       	ldd	r25, Y+2	; 0x02
    2600:	9f 3f       	cpi	r25, 0xFF	; 255
    2602:	d1 f0       	breq	.+52     	; 0x2638 <_ZN9MD_TCS23013setFrequency2Eh+0x46>
    2604:	61 30       	cpi	r22, 0x01	; 1
    2606:	49 f0       	breq	.+18     	; 0x261a <_ZN9MD_TCS23013setFrequency2Eh+0x28>
    2608:	30 f0       	brcs	.+12     	; 0x2616 <_ZN9MD_TCS23013setFrequency2Eh+0x24>
    260a:	62 30       	cpi	r22, 0x02	; 2
    260c:	41 f0       	breq	.+16     	; 0x261e <_ZN9MD_TCS23013setFrequency2Eh+0x2c>
    260e:	63 30       	cpi	r22, 0x03	; 3
    2610:	99 f4       	brne	.+38     	; 0x2638 <_ZN9MD_TCS23013setFrequency2Eh+0x46>
    2612:	60 e0       	ldi	r22, 0x00	; 0
    2614:	09 c0       	rjmp	.+18     	; 0x2628 <_ZN9MD_TCS23013setFrequency2Eh+0x36>
    2616:	61 e0       	ldi	r22, 0x01	; 1
    2618:	03 c0       	rjmp	.+6      	; 0x2620 <_ZN9MD_TCS23013setFrequency2Eh+0x2e>
    261a:	61 e0       	ldi	r22, 0x01	; 1
    261c:	05 c0       	rjmp	.+10     	; 0x2628 <_ZN9MD_TCS23013setFrequency2Eh+0x36>
    261e:	60 e0       	ldi	r22, 0x00	; 0
    2620:	0e 94 e5 06 	call	0xdca	; 0xdca <digitalWrite>
    2624:	61 e0       	ldi	r22, 0x01	; 1
    2626:	03 c0       	rjmp	.+6      	; 0x262e <_ZN9MD_TCS23013setFrequency2Eh+0x3c>
    2628:	0e 94 e5 06 	call	0xdca	; 0xdca <digitalWrite>
    262c:	60 e0       	ldi	r22, 0x00	; 0
    262e:	8a 81       	ldd	r24, Y+2	; 0x02
    2630:	df 91       	pop	r29
    2632:	cf 91       	pop	r28
    2634:	0c 94 e5 06 	jmp	0xdca	; 0xdca <digitalWrite>
    2638:	df 91       	pop	r29
    263a:	cf 91       	pop	r28
    263c:	08 95       	ret

0000263e <_ZN9MD_TCS2309setEnableEb>:
    263e:	fc 01       	movw	r30, r24
    2640:	20 81       	ld	r18, Z
    2642:	2f 3f       	cpi	r18, 0xFF	; 255
    2644:	29 f0       	breq	.+10     	; 0x2650 <_ZN9MD_TCS2309setEnableEb+0x12>
    2646:	91 e0       	ldi	r25, 0x01	; 1
    2648:	69 27       	eor	r22, r25
    264a:	82 2f       	mov	r24, r18
    264c:	0c 94 e5 06 	jmp	0xdca	; 0xdca <digitalWrite>
    2650:	66 23       	and	r22, r22
    2652:	19 f0       	breq	.+6      	; 0x265a <_ZN9MD_TCS2309setEnableEb+0x1c>
    2654:	fc 01       	movw	r30, r24
    2656:	66 81       	ldd	r22, Z+6	; 0x06
    2658:	01 c0       	rjmp	.+2      	; 0x265c <_ZN9MD_TCS2309setEnableEb+0x1e>
    265a:	63 e0       	ldi	r22, 0x03	; 3
    265c:	0c 94 f9 12 	jmp	0x25f2	; 0x25f2 <_ZN9MD_TCS23013setFrequency2Eh>

00002660 <_ZN9MD_TCS2306getRGBEP9colorData>:
    2660:	dc 01       	movw	r26, r24
    2662:	fb 01       	movw	r30, r22
    2664:	30 97       	sbiw	r30, 0x00	; 0
    2666:	59 f0       	breq	.+22     	; 0x267e <_ZN9MD_TCS2306getRGBEP9colorData+0x1e>
    2668:	9b 96       	adiw	r26, 0x2b	; 43
    266a:	8c 91       	ld	r24, X
    266c:	9b 97       	sbiw	r26, 0x2b	; 43
    266e:	80 83       	st	Z, r24
    2670:	9c 96       	adiw	r26, 0x2c	; 44
    2672:	8c 91       	ld	r24, X
    2674:	9c 97       	sbiw	r26, 0x2c	; 44
    2676:	81 83       	std	Z+1, r24	; 0x01
    2678:	9d 96       	adiw	r26, 0x2d	; 45
    267a:	8c 91       	ld	r24, X
    267c:	82 83       	std	Z+2, r24	; 0x02
    267e:	08 95       	ret

00002680 <_ZN9MD_TCS23017RGBTransformationEv>:
  return(s);
}

void MD_TCS230::RGBTransformation(void)
// Exploiting linear relationship to remap the range 
{
    2680:	4f 92       	push	r4
    2682:	5f 92       	push	r5
    2684:	6f 92       	push	r6
    2686:	7f 92       	push	r7
    2688:	8f 92       	push	r8
    268a:	9f 92       	push	r9
    268c:	af 92       	push	r10
    268e:	bf 92       	push	r11
    2690:	df 92       	push	r13
    2692:	ef 92       	push	r14
    2694:	ff 92       	push	r15
    2696:	0f 93       	push	r16
    2698:	1f 93       	push	r17
    269a:	cf 93       	push	r28
    269c:	df 93       	push	r29
    269e:	8c 01       	movw	r16, r24
    26a0:	09 5f       	subi	r16, 0xF9	; 249
    26a2:	1f 4f       	sbci	r17, 0xFF	; 255
    26a4:	ec 01       	movw	r28, r24
    26a6:	7c 01       	movw	r14, r24
    26a8:	83 e1       	ldi	r24, 0x13	; 19
    26aa:	e8 0e       	add	r14, r24
    26ac:	f1 1c       	adc	r15, r1
    x = (_Fo.value[i] - _Fd.value[i]) * 255;
    x /= (_Fw.value[i] - _Fd.value[i]);

    // copy results back into the global structures
    if (x < 0) _rgb.value[i] = 0; 
    else if (x > 255) _rgb.value[i] = 255;
    26ae:	dd 24       	eor	r13, r13
    26b0:	da 94       	dec	r13
    26b2:	f8 01       	movw	r30, r16
{
  int32_t x;

  for (uint8_t i=0; i<RGB_SIZE; i++)
  {
    x = (_Fo.value[i] - _Fd.value[i]) * 255;
    26b4:	d8 01       	movw	r26, r16
    26b6:	8d 90       	ld	r8, X+
    26b8:	9d 90       	ld	r9, X+
    26ba:	ad 90       	ld	r10, X+
    26bc:	bd 90       	ld	r11, X+
    26be:	8d 01       	movw	r16, r26
    26c0:	80 8d       	ldd	r24, Z+24	; 0x18
    26c2:	91 8d       	ldd	r25, Z+25	; 0x19
    26c4:	a2 8d       	ldd	r26, Z+26	; 0x1a
    26c6:	b3 8d       	ldd	r27, Z+27	; 0x1b
    26c8:	9c 01       	movw	r18, r24
    26ca:	ad 01       	movw	r20, r26
    26cc:	28 19       	sub	r18, r8
    26ce:	39 09       	sbc	r19, r9
    26d0:	4a 09       	sbc	r20, r10
    26d2:	5b 09       	sbc	r21, r11
    26d4:	af ef       	ldi	r26, 0xFF	; 255
    26d6:	b0 e0       	ldi	r27, 0x00	; 0
    26d8:	0e 94 93 17 	call	0x2f26	; 0x2f26 <__muluhisi3>
    x /= (_Fw.value[i] - _Fd.value[i]);
    26dc:	f8 01       	movw	r30, r16
    26de:	40 84       	ldd	r4, Z+8	; 0x08
    26e0:	51 84       	ldd	r5, Z+9	; 0x09
    26e2:	62 84       	ldd	r6, Z+10	; 0x0a
    26e4:	73 84       	ldd	r7, Z+11	; 0x0b
    26e6:	a3 01       	movw	r20, r6
    26e8:	92 01       	movw	r18, r4
    26ea:	28 19       	sub	r18, r8
    26ec:	39 09       	sbc	r19, r9
    26ee:	4a 09       	sbc	r20, r10
    26f0:	5b 09       	sbc	r21, r11
    26f2:	0e 94 6e 17 	call	0x2edc	; 0x2edc <__divmodsi4>

    // copy results back into the global structures
    if (x < 0) _rgb.value[i] = 0; 
    26f6:	57 ff       	sbrs	r21, 7
    26f8:	02 c0       	rjmp	.+4      	; 0x26fe <_ZN9MD_TCS23017RGBTransformationEv+0x7e>
    26fa:	1b a6       	std	Y+43, r1	; 0x2b
    26fc:	09 c0       	rjmp	.+18     	; 0x2710 <_ZN9MD_TCS23017RGBTransformationEv+0x90>
    else if (x > 255) _rgb.value[i] = 255;
    26fe:	2f 3f       	cpi	r18, 0xFF	; 255
    2700:	31 05       	cpc	r19, r1
    2702:	41 05       	cpc	r20, r1
    2704:	51 05       	cpc	r21, r1
    2706:	19 f0       	breq	.+6      	; 0x270e <_ZN9MD_TCS23017RGBTransformationEv+0x8e>
    2708:	14 f0       	brlt	.+4      	; 0x270e <_ZN9MD_TCS23017RGBTransformationEv+0x8e>
    270a:	db a6       	std	Y+43, r13	; 0x2b
    270c:	01 c0       	rjmp	.+2      	; 0x2710 <_ZN9MD_TCS23017RGBTransformationEv+0x90>
    else _rgb.value[i] = x;
    270e:	2b a7       	std	Y+43, r18	; 0x2b
    2710:	21 96       	adiw	r28, 0x01	; 1
void MD_TCS230::RGBTransformation(void)
// Exploiting linear relationship to remap the range 
{
  int32_t x;

  for (uint8_t i=0; i<RGB_SIZE; i++)
    2712:	0e 15       	cp	r16, r14
    2714:	1f 05       	cpc	r17, r15
    2716:	69 f6       	brne	.-102    	; 0x26b2 <_ZN9MD_TCS23017RGBTransformationEv+0x32>
    // copy results back into the global structures
    if (x < 0) _rgb.value[i] = 0; 
    else if (x > 255) _rgb.value[i] = 255;
    else _rgb.value[i] = x;
  }
}
    2718:	df 91       	pop	r29
    271a:	cf 91       	pop	r28
    271c:	1f 91       	pop	r17
    271e:	0f 91       	pop	r16
    2720:	ff 90       	pop	r15
    2722:	ef 90       	pop	r14
    2724:	df 90       	pop	r13
    2726:	bf 90       	pop	r11
    2728:	af 90       	pop	r10
    272a:	9f 90       	pop	r9
    272c:	8f 90       	pop	r8
    272e:	7f 90       	pop	r7
    2730:	6f 90       	pop	r6
    2732:	5f 90       	pop	r5
    2734:	4f 90       	pop	r4
    2736:	08 95       	ret

00002738 <_ZN9MD_TCS2307readFSMEh>:
  return(_readState == 0);
}

uint8_t MD_TCS230::readFSM(uint8_t s)
// Finite State Machine to read a value (internal function)
{
    2738:	0f 93       	push	r16
    273a:	1f 93       	push	r17
    273c:	cf 93       	push	r28
    273e:	df 93       	push	r29
    2740:	8c 01       	movw	r16, r24
    2742:	c6 2f       	mov	r28, r22
  static const uint8_t seq[] = { TCS230_RGB_R, TCS230_RGB_G, TCS230_RGB_B };
  static uint8_t       currCol;  // index for seq above

  switch(s)
    2744:	61 30       	cpi	r22, 0x01	; 1
    2746:	49 f0       	breq	.+18     	; 0x275a <_ZN9MD_TCS2307readFSMEh+0x22>
    2748:	18 f0       	brcs	.+6      	; 0x2750 <_ZN9MD_TCS2307readFSMEh+0x18>
    274a:	62 30       	cpi	r22, 0x02	; 2
    274c:	d9 f0       	breq	.+54     	; 0x2784 <_ZN9MD_TCS2307readFSMEh+0x4c>
    274e:	4c c0       	rjmp	.+152    	; 0x27e8 <_ZN9MD_TCS2307readFSMEh+0xb0>
  {
  case 0: // enable the hardware for reading
    DUMPS("\n0");
    currCol = 0;  // RGB_R but we don't care
    2750:	10 92 47 03 	sts	0x0347, r1	; 0x800347 <_ZZN9MD_TCS2307readFSMEhE7currCol>
    setEnable(true);
    2754:	61 e0       	ldi	r22, 0x01	; 1
    2756:	0e 94 1f 13 	call	0x263e	; 0x263e <_ZN9MD_TCS2309setEnableEb>
    s++;
    // fall through to the next state

  case 1: // select a filter and start a reading
    DUMPS("\n1");
    setFilter(seq[currCol]);
    275a:	e0 91 47 03 	lds	r30, 0x0347	; 0x800347 <_ZZN9MD_TCS2307readFSMEhE7currCol>
    275e:	f0 e0       	ldi	r31, 0x00	; 0
    2760:	e0 5b       	subi	r30, 0xB0	; 176
    2762:	fe 4f       	sbci	r31, 0xFE	; 254
    2764:	60 81       	ld	r22, Z
    2766:	c8 01       	movw	r24, r16
    2768:	0e 94 d3 12 	call	0x25a6	; 0x25a6 <_ZN9MD_TCS2309setFilterEh>
    FreqCount.begin(1000/_readDiv);
    276c:	f8 01       	movw	r30, r16
    276e:	65 81       	ldd	r22, Z+5	; 0x05
    2770:	70 e0       	ldi	r23, 0x00	; 0
    2772:	88 ee       	ldi	r24, 0xE8	; 232
    2774:	93 e0       	ldi	r25, 0x03	; 3
    2776:	0e 94 38 17 	call	0x2e70	; 0x2e70 <__divmodhi4>
    277a:	cb 01       	movw	r24, r22
    277c:	0e 94 22 16 	call	0x2c44	; 0x2c44 <_ZN14FreqCountClass5beginEj>
    s++;
    2780:	c2 e0       	ldi	r28, 0x02	; 2
    break;
    2782:	32 c0       	rjmp	.+100    	; 0x27e8 <_ZN9MD_TCS2307readFSMEh+0xb0>

  case 2: // see if a value is available
    DUMPS("2");
    if (FreqCount.available())
    2784:	0e 94 9a 16 	call	0x2d34	; 0x2d34 <_ZN14FreqCountClass9availableEv>
    2788:	88 23       	and	r24, r24
    278a:	71 f1       	breq	.+92     	; 0x27e8 <_ZN9MD_TCS2307readFSMEh+0xb0>
    {
      DUMP(" VALUE ", FreqCount.read());
      // read the value and save it 
      _Fo.value[seq[currCol++]] = FreqCount.read() * _readDiv;
    278c:	e0 91 47 03 	lds	r30, 0x0347	; 0x800347 <_ZZN9MD_TCS2307readFSMEhE7currCol>
    2790:	81 e0       	ldi	r24, 0x01	; 1
    2792:	8e 0f       	add	r24, r30
    2794:	80 93 47 03 	sts	0x0347, r24	; 0x800347 <_ZZN9MD_TCS2307readFSMEhE7currCol>
    2798:	f0 e0       	ldi	r31, 0x00	; 0
    279a:	e0 5b       	subi	r30, 0xB0	; 176
    279c:	fe 4f       	sbci	r31, 0xFE	; 254
    279e:	c0 81       	ld	r28, Z
    27a0:	d0 e0       	ldi	r29, 0x00	; 0
    27a2:	0e 94 9d 16 	call	0x2d3a	; 0x2d3a <_ZN14FreqCountClass4readEv>
    27a6:	9b 01       	movw	r18, r22
    27a8:	ac 01       	movw	r20, r24
    27aa:	cc 0f       	add	r28, r28
    27ac:	dd 1f       	adc	r29, r29
    27ae:	cc 0f       	add	r28, r28
    27b0:	dd 1f       	adc	r29, r29
    27b2:	c0 0f       	add	r28, r16
    27b4:	d1 1f       	adc	r29, r17
    27b6:	f8 01       	movw	r30, r16
    27b8:	a5 81       	ldd	r26, Z+5	; 0x05
    27ba:	b0 e0       	ldi	r27, 0x00	; 0
    27bc:	0e 94 93 17 	call	0x2f26	; 0x2f26 <__muluhisi3>
    27c0:	6f 8f       	std	Y+31, r22	; 0x1f
    27c2:	78 a3       	std	Y+32, r23	; 0x20
    27c4:	89 a3       	std	Y+33, r24	; 0x21
    27c6:	9a a3       	std	Y+34, r25	; 0x22

      if (currCol < RGB_SIZE)
    27c8:	80 91 47 03 	lds	r24, 0x0347	; 0x800347 <_ZZN9MD_TCS2307readFSMEhE7currCol>
    27cc:	83 30       	cpi	r24, 0x03	; 3
    27ce:	58 f0       	brcs	.+22     	; 0x27e6 <_ZN9MD_TCS2307readFSMEh+0xae>
        s--;
      }
      else
      {
        // end this reading session
        FreqCount.end();
    27d0:	0e 94 ab 16 	call	0x2d56	; 0x2d56 <_ZN14FreqCountClass3endEv>
        setEnable(false);
    27d4:	60 e0       	ldi	r22, 0x00	; 0
    27d6:	c8 01       	movw	r24, r16
    27d8:	0e 94 1f 13 	call	0x263e	; 0x263e <_ZN9MD_TCS2309setEnableEb>
        RGBTransformation();
    27dc:	c8 01       	movw	r24, r16
    27de:	0e 94 40 13 	call	0x2680	; 0x2680 <_ZN9MD_TCS23017RGBTransformationEv>
        s = 0;
    27e2:	c0 e0       	ldi	r28, 0x00	; 0
    27e4:	01 c0       	rjmp	.+2      	; 0x27e8 <_ZN9MD_TCS2307readFSMEh+0xb0>
      _Fo.value[seq[currCol++]] = FreqCount.read() * _readDiv;

      if (currCol < RGB_SIZE)
      {
        // loop around again on next call to available()
        s--;
    27e6:	c1 e0       	ldi	r28, 0x01	; 1
    }
    break;
  }

  return(s);
}
    27e8:	8c 2f       	mov	r24, r28
    27ea:	df 91       	pop	r29
    27ec:	cf 91       	pop	r28
    27ee:	1f 91       	pop	r17
    27f0:	0f 91       	pop	r16
    27f2:	08 95       	ret

000027f4 <_ZN9MD_TCS2304readEv>:
  return(FreqCount.read() * _readDiv);
}

void MD_TCS230::read(void)
// initiate the finite state machine for reading a value
{
    27f4:	cf 93       	push	r28
    27f6:	df 93       	push	r29
    27f8:	ec 01       	movw	r28, r24
  _readState = readFSM(0);
    27fa:	60 e0       	ldi	r22, 0x00	; 0
    27fc:	0e 94 9c 13 	call	0x2738	; 0x2738 <_ZN9MD_TCS2307readFSMEh>
    2800:	8e a7       	std	Y+46, r24	; 0x2e
}
    2802:	df 91       	pop	r29
    2804:	cf 91       	pop	r28
    2806:	08 95       	ret

00002808 <_ZN9MD_TCS2309availableEv>:

bool MD_TCS230::available(void)
// check if a value is ready. Called repeatedly until it is!
{
    2808:	cf 93       	push	r28
    280a:	df 93       	push	r29
    280c:	ec 01       	movw	r28, r24
  _readState = readFSM(_readState);
    280e:	6e a5       	ldd	r22, Y+46	; 0x2e
    2810:	0e 94 9c 13 	call	0x2738	; 0x2738 <_ZN9MD_TCS2307readFSMEh>
    2814:	98 2f       	mov	r25, r24
    2816:	8e a7       	std	Y+46, r24	; 0x2e

  return(_readState == 0);
    2818:	81 e0       	ldi	r24, 0x01	; 1
    281a:	91 11       	cpse	r25, r1
    281c:	80 e0       	ldi	r24, 0x00	; 0
}
    281e:	df 91       	pop	r29
    2820:	cf 91       	pop	r28
    2822:	08 95       	ret

00002824 <pvPortMalloc>:
#if( configSUPPORT_DYNAMIC_ALLOCATION > 0 )

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
    2824:	cf 93       	push	r28
    2826:	df 93       	push	r29
    2828:	ec 01       	movw	r28, r24
void *pvReturn;

    vTaskSuspendAll();
    282a:	0e 94 8e 0c 	call	0x191c	; 0x191c <vTaskSuspendAll>
    {
        pvReturn = malloc( xWantedSize );
    282e:	ce 01       	movw	r24, r28
    2830:	0e 94 c1 17 	call	0x2f82	; 0x2f82 <malloc>
    2834:	ec 01       	movw	r28, r24
        traceMALLOC( pvReturn, xWantedSize );
    }
    ( void ) xTaskResumeAll();
    2836:	0e 94 4a 0d 	call	0x1a94	; 0x1a94 <xTaskResumeAll>

    #if( configUSE_MALLOC_FAILED_HOOK == 1 )
    {
        if( pvReturn == NULL )
    283a:	20 97       	sbiw	r28, 0x00	; 0
    283c:	11 f4       	brne	.+4      	; 0x2842 <pvPortMalloc+0x1e>
        {
            extern void vApplicationMallocFailedHook( void );
            vApplicationMallocFailedHook();
    283e:	0e 94 7d 12 	call	0x24fa	; 0x24fa <vApplicationMallocFailedHook>
        }
    }
    #endif

    return pvReturn;
}
    2842:	ce 01       	movw	r24, r28
    2844:	df 91       	pop	r29
    2846:	cf 91       	pop	r28
    2848:	08 95       	ret

0000284a <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
    284a:	cf 93       	push	r28
    284c:	df 93       	push	r29
    if( pv )
    284e:	00 97       	sbiw	r24, 0x00	; 0
    2850:	51 f0       	breq	.+20     	; 0x2866 <vPortFree+0x1c>
    2852:	ec 01       	movw	r28, r24
    {
        vTaskSuspendAll();
    2854:	0e 94 8e 0c 	call	0x191c	; 0x191c <vTaskSuspendAll>
        {
            free( pv );
    2858:	ce 01       	movw	r24, r28
    285a:	0e 94 59 18 	call	0x30b2	; 0x30b2 <free>
            traceFREE( pv, 0 );
        }
        ( void ) xTaskResumeAll();
    }
}
    285e:	df 91       	pop	r29
    2860:	cf 91       	pop	r28
        vTaskSuspendAll();
        {
            free( pv );
            traceFREE( pv, 0 );
        }
        ( void ) xTaskResumeAll();
    2862:	0c 94 4a 0d 	jmp	0x1a94	; 0x1a94 <xTaskResumeAll>
    }
}
    2866:	df 91       	pop	r29
    2868:	cf 91       	pop	r28
    286a:	08 95       	ret

0000286c <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
    286c:	fc 01       	movw	r30, r24
    /* The list structure contains a list item which is used to mark the
    end of the list.  To initialise the list the list end is inserted
    as the only list entry. */
    pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );            /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    286e:	03 96       	adiw	r24, 0x03	; 3
    2870:	92 83       	std	Z+2, r25	; 0x02
    2872:	81 83       	std	Z+1, r24	; 0x01

    /* The list end value is the highest possible value in the list to
    ensure it remains at the end of the list. */
    pxList->xListEnd.xItemValue = portMAX_DELAY;
    2874:	2f ef       	ldi	r18, 0xFF	; 255
    2876:	3f ef       	ldi	r19, 0xFF	; 255
    2878:	34 83       	std	Z+4, r19	; 0x04
    287a:	23 83       	std	Z+3, r18	; 0x03

    /* The list end next and previous pointers point to itself so we know
    when the list is empty. */
    pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );    /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    287c:	96 83       	std	Z+6, r25	; 0x06
    287e:	85 83       	std	Z+5, r24	; 0x05
    pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    2880:	90 87       	std	Z+8, r25	; 0x08
    2882:	87 83       	std	Z+7, r24	; 0x07

    pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
    2884:	10 82       	st	Z, r1
    2886:	08 95       	ret

00002888 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
    /* Make sure the list item is not recorded as being on a list. */
    pxItem->pxContainer = NULL;
    2888:	fc 01       	movw	r30, r24
    288a:	11 86       	std	Z+9, r1	; 0x09
    288c:	10 86       	std	Z+8, r1	; 0x08
    288e:	08 95       	ret

00002890 <vListInsertEnd>:
    listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    2890:	cf 93       	push	r28
    2892:	df 93       	push	r29
    2894:	9c 01       	movw	r18, r24
    2896:	fb 01       	movw	r30, r22
ListItem_t * const pxIndex = pxList->pxIndex;
    2898:	dc 01       	movw	r26, r24
    289a:	11 96       	adiw	r26, 0x01	; 1
    289c:	cd 91       	ld	r28, X+
    289e:	dc 91       	ld	r29, X
    28a0:	12 97       	sbiw	r26, 0x02	; 2
    listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

    /* Insert a new list item into pxList, but rather than sort the list,
    makes the new list item the last item to be removed by a call to
    listGET_OWNER_OF_NEXT_ENTRY(). */
    pxNewListItem->pxNext = pxIndex;
    28a2:	d3 83       	std	Z+3, r29	; 0x03
    28a4:	c2 83       	std	Z+2, r28	; 0x02
    pxNewListItem->pxPrevious = pxIndex->pxPrevious;
    28a6:	8c 81       	ldd	r24, Y+4	; 0x04
    28a8:	9d 81       	ldd	r25, Y+5	; 0x05
    28aa:	95 83       	std	Z+5, r25	; 0x05
    28ac:	84 83       	std	Z+4, r24	; 0x04

    /* Only used during decision coverage testing. */
    mtCOVERAGE_TEST_DELAY();

    pxIndex->pxPrevious->pxNext = pxNewListItem;
    28ae:	8c 81       	ldd	r24, Y+4	; 0x04
    28b0:	9d 81       	ldd	r25, Y+5	; 0x05
    28b2:	dc 01       	movw	r26, r24
    28b4:	13 96       	adiw	r26, 0x03	; 3
    28b6:	7c 93       	st	X, r23
    28b8:	6e 93       	st	-X, r22
    28ba:	12 97       	sbiw	r26, 0x02	; 2
    pxIndex->pxPrevious = pxNewListItem;
    28bc:	7d 83       	std	Y+5, r23	; 0x05
    28be:	6c 83       	std	Y+4, r22	; 0x04

    /* Remember which list the item is in. */
    pxNewListItem->pxContainer = pxList;
    28c0:	31 87       	std	Z+9, r19	; 0x09
    28c2:	20 87       	std	Z+8, r18	; 0x08

    ( pxList->uxNumberOfItems )++;
    28c4:	f9 01       	movw	r30, r18
    28c6:	80 81       	ld	r24, Z
    28c8:	8f 5f       	subi	r24, 0xFF	; 255
    28ca:	80 83       	st	Z, r24
}
    28cc:	df 91       	pop	r29
    28ce:	cf 91       	pop	r28
    28d0:	08 95       	ret

000028d2 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    28d2:	0f 93       	push	r16
    28d4:	1f 93       	push	r17
    28d6:	cf 93       	push	r28
    28d8:	df 93       	push	r29
    28da:	8c 01       	movw	r16, r24
    28dc:	fb 01       	movw	r30, r22
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
    28de:	80 81       	ld	r24, Z
    28e0:	91 81       	ldd	r25, Z+1	; 0x01
    new list item should be placed after it.  This ensures that TCBs which are
    stored in ready lists (all of which have the same xItemValue value) get a
    share of the CPU.  However, if the xItemValue is the same as the back marker
    the iteration loop below will not end.  Therefore the value is checked
    first, and the algorithm slightly modified if necessary. */
    if( xValueOfInsertion == portMAX_DELAY )
    28e2:	8f 3f       	cpi	r24, 0xFF	; 255
    28e4:	2f ef       	ldi	r18, 0xFF	; 255
    28e6:	92 07       	cpc	r25, r18
    28e8:	21 f4       	brne	.+8      	; 0x28f2 <vListInsert+0x20>
    {
        pxIterator = pxList->xListEnd.pxPrevious;
    28ea:	e8 01       	movw	r28, r16
    28ec:	af 81       	ldd	r26, Y+7	; 0x07
    28ee:	b8 85       	ldd	r27, Y+8	; 0x08
    28f0:	0e c0       	rjmp	.+28     	; 0x290e <vListInsert+0x3c>
            4) Using a queue or semaphore before it has been initialised or
               before the scheduler has been started (are interrupts firing
               before vTaskStartScheduler() has been called?).
        **********************************************************************/

        for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. *//*lint !e440 The iterator moves to a different value, not xValueOfInsertion. */
    28f2:	d8 01       	movw	r26, r16
    28f4:	13 96       	adiw	r26, 0x03	; 3
    28f6:	12 96       	adiw	r26, 0x02	; 2
    28f8:	2d 91       	ld	r18, X+
    28fa:	3c 91       	ld	r19, X
    28fc:	13 97       	sbiw	r26, 0x03	; 3
    28fe:	e9 01       	movw	r28, r18
    2900:	48 81       	ld	r20, Y
    2902:	59 81       	ldd	r21, Y+1	; 0x01
    2904:	84 17       	cp	r24, r20
    2906:	95 07       	cpc	r25, r21
    2908:	10 f0       	brcs	.+4      	; 0x290e <vListInsert+0x3c>
    290a:	d9 01       	movw	r26, r18
    290c:	f4 cf       	rjmp	.-24     	; 0x28f6 <vListInsert+0x24>
            /* There is nothing to do here, just iterating to the wanted
            insertion position. */
        }
    }

    pxNewListItem->pxNext = pxIterator->pxNext;
    290e:	12 96       	adiw	r26, 0x02	; 2
    2910:	8d 91       	ld	r24, X+
    2912:	9c 91       	ld	r25, X
    2914:	13 97       	sbiw	r26, 0x03	; 3
    2916:	93 83       	std	Z+3, r25	; 0x03
    2918:	82 83       	std	Z+2, r24	; 0x02
    pxNewListItem->pxNext->pxPrevious = pxNewListItem;
    291a:	ec 01       	movw	r28, r24
    291c:	fd 83       	std	Y+5, r31	; 0x05
    291e:	ec 83       	std	Y+4, r30	; 0x04
    pxNewListItem->pxPrevious = pxIterator;
    2920:	b5 83       	std	Z+5, r27	; 0x05
    2922:	a4 83       	std	Z+4, r26	; 0x04
    pxIterator->pxNext = pxNewListItem;
    2924:	13 96       	adiw	r26, 0x03	; 3
    2926:	fc 93       	st	X, r31
    2928:	ee 93       	st	-X, r30
    292a:	12 97       	sbiw	r26, 0x02	; 2

    /* Remember which list the item is in.  This allows fast removal of the
    item later. */
    pxNewListItem->pxContainer = pxList;
    292c:	11 87       	std	Z+9, r17	; 0x09
    292e:	00 87       	std	Z+8, r16	; 0x08

    ( pxList->uxNumberOfItems )++;
    2930:	f8 01       	movw	r30, r16
    2932:	80 81       	ld	r24, Z
    2934:	8f 5f       	subi	r24, 0xFF	; 255
    2936:	80 83       	st	Z, r24
}
    2938:	df 91       	pop	r29
    293a:	cf 91       	pop	r28
    293c:	1f 91       	pop	r17
    293e:	0f 91       	pop	r16
    2940:	08 95       	ret

00002942 <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
    2942:	cf 93       	push	r28
    2944:	df 93       	push	r29
    2946:	fc 01       	movw	r30, r24
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = pxItemToRemove->pxContainer;
    2948:	a0 85       	ldd	r26, Z+8	; 0x08
    294a:	b1 85       	ldd	r27, Z+9	; 0x09

    pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    294c:	82 81       	ldd	r24, Z+2	; 0x02
    294e:	93 81       	ldd	r25, Z+3	; 0x03
    2950:	24 81       	ldd	r18, Z+4	; 0x04
    2952:	35 81       	ldd	r19, Z+5	; 0x05
    2954:	ec 01       	movw	r28, r24
    2956:	3d 83       	std	Y+5, r19	; 0x05
    2958:	2c 83       	std	Y+4, r18	; 0x04
    pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    295a:	c4 81       	ldd	r28, Z+4	; 0x04
    295c:	d5 81       	ldd	r29, Z+5	; 0x05
    295e:	9b 83       	std	Y+3, r25	; 0x03
    2960:	8a 83       	std	Y+2, r24	; 0x02

    /* Only used during decision coverage testing. */
    mtCOVERAGE_TEST_DELAY();

    /* Make sure the index is left pointing to a valid item. */
    if( pxList->pxIndex == pxItemToRemove )
    2962:	11 96       	adiw	r26, 0x01	; 1
    2964:	8d 91       	ld	r24, X+
    2966:	9c 91       	ld	r25, X
    2968:	12 97       	sbiw	r26, 0x02	; 2
    296a:	e8 17       	cp	r30, r24
    296c:	f9 07       	cpc	r31, r25
    296e:	21 f4       	brne	.+8      	; 0x2978 <uxListRemove+0x36>
    {
        pxList->pxIndex = pxItemToRemove->pxPrevious;
    2970:	12 96       	adiw	r26, 0x02	; 2
    2972:	dc 93       	st	X, r29
    2974:	ce 93       	st	-X, r28
    2976:	11 97       	sbiw	r26, 0x01	; 1
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }

    pxItemToRemove->pxContainer = NULL;
    2978:	11 86       	std	Z+9, r1	; 0x09
    297a:	10 86       	std	Z+8, r1	; 0x08
    ( pxList->uxNumberOfItems )--;
    297c:	8c 91       	ld	r24, X
    297e:	81 50       	subi	r24, 0x01	; 1
    2980:	8c 93       	st	X, r24

    return pxList->uxNumberOfItems;
    2982:	8c 91       	ld	r24, X
}
    2984:	df 91       	pop	r29
    2986:	cf 91       	pop	r28
    2988:	08 95       	ret

0000298a <pxPortInitialiseStack>:
		);
	}
	else
	{
        uint8_t register temp_reg;
		__asm__ __volatile__ (
    298a:	31 e1       	ldi	r19, 0x11	; 17
    298c:	fc 01       	movw	r30, r24
    298e:	30 83       	st	Z, r19
    2990:	31 97       	sbiw	r30, 0x01	; 1
    2992:	22 e2       	ldi	r18, 0x22	; 34
    2994:	20 83       	st	Z, r18
    2996:	31 97       	sbiw	r30, 0x01	; 1
    2998:	a3 e3       	ldi	r26, 0x33	; 51
    299a:	a0 83       	st	Z, r26
    299c:	31 97       	sbiw	r30, 0x01	; 1
    299e:	60 83       	st	Z, r22
    29a0:	31 97       	sbiw	r30, 0x01	; 1
    29a2:	70 83       	st	Z, r23
    29a4:	31 97       	sbiw	r30, 0x01	; 1
    29a6:	10 82       	st	Z, r1
    29a8:	31 97       	sbiw	r30, 0x01	; 1
    29aa:	60 e8       	ldi	r22, 0x80	; 128
    29ac:	60 83       	st	Z, r22
    29ae:	31 97       	sbiw	r30, 0x01	; 1
    29b0:	10 82       	st	Z, r1
    29b2:	31 97       	sbiw	r30, 0x01	; 1
    29b4:	62 e0       	ldi	r22, 0x02	; 2
    29b6:	60 83       	st	Z, r22
    29b8:	31 97       	sbiw	r30, 0x01	; 1
    29ba:	63 e0       	ldi	r22, 0x03	; 3
    29bc:	60 83       	st	Z, r22
    29be:	31 97       	sbiw	r30, 0x01	; 1
    29c0:	64 e0       	ldi	r22, 0x04	; 4
    29c2:	60 83       	st	Z, r22
    29c4:	31 97       	sbiw	r30, 0x01	; 1
    29c6:	65 e0       	ldi	r22, 0x05	; 5
    29c8:	60 83       	st	Z, r22
    29ca:	31 97       	sbiw	r30, 0x01	; 1
    29cc:	66 e0       	ldi	r22, 0x06	; 6
    29ce:	60 83       	st	Z, r22
    29d0:	31 97       	sbiw	r30, 0x01	; 1
    29d2:	67 e0       	ldi	r22, 0x07	; 7
    29d4:	60 83       	st	Z, r22
    29d6:	31 97       	sbiw	r30, 0x01	; 1
    29d8:	68 e0       	ldi	r22, 0x08	; 8
    29da:	60 83       	st	Z, r22
    29dc:	31 97       	sbiw	r30, 0x01	; 1
    29de:	69 e0       	ldi	r22, 0x09	; 9
    29e0:	60 83       	st	Z, r22
    29e2:	31 97       	sbiw	r30, 0x01	; 1
    29e4:	60 e1       	ldi	r22, 0x10	; 16
    29e6:	60 83       	st	Z, r22
    29e8:	31 97       	sbiw	r30, 0x01	; 1
    29ea:	30 83       	st	Z, r19
    29ec:	31 97       	sbiw	r30, 0x01	; 1
    29ee:	32 e1       	ldi	r19, 0x12	; 18
    29f0:	30 83       	st	Z, r19
    29f2:	31 97       	sbiw	r30, 0x01	; 1
    29f4:	33 e1       	ldi	r19, 0x13	; 19
    29f6:	30 83       	st	Z, r19
    29f8:	31 97       	sbiw	r30, 0x01	; 1
    29fa:	34 e1       	ldi	r19, 0x14	; 20
    29fc:	30 83       	st	Z, r19
    29fe:	31 97       	sbiw	r30, 0x01	; 1
    2a00:	35 e1       	ldi	r19, 0x15	; 21
    2a02:	30 83       	st	Z, r19
    2a04:	31 97       	sbiw	r30, 0x01	; 1
    2a06:	36 e1       	ldi	r19, 0x16	; 22
    2a08:	30 83       	st	Z, r19
    2a0a:	31 97       	sbiw	r30, 0x01	; 1
    2a0c:	37 e1       	ldi	r19, 0x17	; 23
    2a0e:	30 83       	st	Z, r19
    2a10:	31 97       	sbiw	r30, 0x01	; 1
    2a12:	38 e1       	ldi	r19, 0x18	; 24
    2a14:	30 83       	st	Z, r19
    2a16:	31 97       	sbiw	r30, 0x01	; 1
    2a18:	39 e1       	ldi	r19, 0x19	; 25
    2a1a:	30 83       	st	Z, r19
    2a1c:	31 97       	sbiw	r30, 0x01	; 1
    2a1e:	30 e2       	ldi	r19, 0x20	; 32
    2a20:	30 83       	st	Z, r19
    2a22:	31 97       	sbiw	r30, 0x01	; 1
    2a24:	31 e2       	ldi	r19, 0x21	; 33
    2a26:	30 83       	st	Z, r19
    2a28:	31 97       	sbiw	r30, 0x01	; 1
    2a2a:	20 83       	st	Z, r18
    2a2c:	31 97       	sbiw	r30, 0x01	; 1
    2a2e:	23 e2       	ldi	r18, 0x23	; 35
    2a30:	20 83       	st	Z, r18
    2a32:	31 97       	sbiw	r30, 0x01	; 1
    2a34:	40 83       	st	Z, r20
    2a36:	31 97       	sbiw	r30, 0x01	; 1
    2a38:	50 83       	st	Z, r21
    2a3a:	31 97       	sbiw	r30, 0x01	; 1
    2a3c:	26 e2       	ldi	r18, 0x26	; 38
    2a3e:	20 83       	st	Z, r18
    2a40:	31 97       	sbiw	r30, 0x01	; 1
    2a42:	27 e2       	ldi	r18, 0x27	; 39
    2a44:	20 83       	st	Z, r18
    2a46:	31 97       	sbiw	r30, 0x01	; 1
    2a48:	28 e2       	ldi	r18, 0x28	; 40
    2a4a:	20 83       	st	Z, r18
    2a4c:	31 97       	sbiw	r30, 0x01	; 1
    2a4e:	29 e2       	ldi	r18, 0x29	; 41
    2a50:	20 83       	st	Z, r18
    2a52:	31 97       	sbiw	r30, 0x01	; 1
    2a54:	20 e3       	ldi	r18, 0x30	; 48
    2a56:	20 83       	st	Z, r18
    2a58:	31 97       	sbiw	r30, 0x01	; 1
    2a5a:	21 e3       	ldi	r18, 0x31	; 49
    2a5c:	20 83       	st	Z, r18
    2a5e:	86 97       	sbiw	r24, 0x26	; 38
    2a60:	08 95       	ret

00002a62 <xPortStartScheduler>:
    2a62:	a8 95       	wdr
    2a64:	90 ec       	ldi	r25, 0xC0	; 192
    2a66:	88 e1       	ldi	r24, 0x18	; 24
    2a68:	0f b6       	in	r0, 0x3f	; 63
    2a6a:	f8 94       	cli
    2a6c:	a8 95       	wdr
    2a6e:	80 93 60 00 	sts	0x0060, r24	; 0x800060 <__DATA_REGION_ORIGIN__>
    2a72:	0f be       	out	0x3f, r0	; 63
    2a74:	90 93 60 00 	sts	0x0060, r25	; 0x800060 <__DATA_REGION_ORIGIN__>
    2a78:	a0 91 29 03 	lds	r26, 0x0329	; 0x800329 <pxCurrentTCB>
    2a7c:	b0 91 2a 03 	lds	r27, 0x032A	; 0x80032a <pxCurrentTCB+0x1>
    2a80:	cd 91       	ld	r28, X+
    2a82:	cd bf       	out	0x3d, r28	; 61
    2a84:	dd 91       	ld	r29, X+
    2a86:	de bf       	out	0x3e, r29	; 62
    2a88:	ff 91       	pop	r31
    2a8a:	ef 91       	pop	r30
    2a8c:	df 91       	pop	r29
    2a8e:	cf 91       	pop	r28
    2a90:	bf 91       	pop	r27
    2a92:	af 91       	pop	r26
    2a94:	9f 91       	pop	r25
    2a96:	8f 91       	pop	r24
    2a98:	7f 91       	pop	r23
    2a9a:	6f 91       	pop	r22
    2a9c:	5f 91       	pop	r21
    2a9e:	4f 91       	pop	r20
    2aa0:	3f 91       	pop	r19
    2aa2:	2f 91       	pop	r18
    2aa4:	1f 91       	pop	r17
    2aa6:	0f 91       	pop	r16
    2aa8:	ff 90       	pop	r15
    2aaa:	ef 90       	pop	r14
    2aac:	df 90       	pop	r13
    2aae:	cf 90       	pop	r12
    2ab0:	bf 90       	pop	r11
    2ab2:	af 90       	pop	r10
    2ab4:	9f 90       	pop	r9
    2ab6:	8f 90       	pop	r8
    2ab8:	7f 90       	pop	r7
    2aba:	6f 90       	pop	r6
    2abc:	5f 90       	pop	r5
    2abe:	4f 90       	pop	r4
    2ac0:	3f 90       	pop	r3
    2ac2:	2f 90       	pop	r2
    2ac4:	1f 90       	pop	r1
    2ac6:	0f 90       	pop	r0
    2ac8:	0f be       	out	0x3f, r0	; 63
    2aca:	0f 90       	pop	r0
    2acc:	08 95       	ret
    2ace:	81 e0       	ldi	r24, 0x01	; 1
    2ad0:	08 95       	ret

00002ad2 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( hot, flatten, naked ) );
void vPortYield( void )
{
    portSAVE_CONTEXT();
    2ad2:	0f 92       	push	r0
    2ad4:	0f b6       	in	r0, 0x3f	; 63
    2ad6:	f8 94       	cli
    2ad8:	0f 92       	push	r0
    2ada:	1f 92       	push	r1
    2adc:	11 24       	eor	r1, r1
    2ade:	2f 92       	push	r2
    2ae0:	3f 92       	push	r3
    2ae2:	4f 92       	push	r4
    2ae4:	5f 92       	push	r5
    2ae6:	6f 92       	push	r6
    2ae8:	7f 92       	push	r7
    2aea:	8f 92       	push	r8
    2aec:	9f 92       	push	r9
    2aee:	af 92       	push	r10
    2af0:	bf 92       	push	r11
    2af2:	cf 92       	push	r12
    2af4:	df 92       	push	r13
    2af6:	ef 92       	push	r14
    2af8:	ff 92       	push	r15
    2afa:	0f 93       	push	r16
    2afc:	1f 93       	push	r17
    2afe:	2f 93       	push	r18
    2b00:	3f 93       	push	r19
    2b02:	4f 93       	push	r20
    2b04:	5f 93       	push	r21
    2b06:	6f 93       	push	r22
    2b08:	7f 93       	push	r23
    2b0a:	8f 93       	push	r24
    2b0c:	9f 93       	push	r25
    2b0e:	af 93       	push	r26
    2b10:	bf 93       	push	r27
    2b12:	cf 93       	push	r28
    2b14:	df 93       	push	r29
    2b16:	ef 93       	push	r30
    2b18:	ff 93       	push	r31
    2b1a:	a0 91 29 03 	lds	r26, 0x0329	; 0x800329 <pxCurrentTCB>
    2b1e:	b0 91 2a 03 	lds	r27, 0x032A	; 0x80032a <pxCurrentTCB+0x1>
    2b22:	0d b6       	in	r0, 0x3d	; 61
    2b24:	0d 92       	st	X+, r0
    2b26:	0e b6       	in	r0, 0x3e	; 62
    2b28:	0d 92       	st	X+, r0
    vTaskSwitchContext();
    2b2a:	0e 94 06 0e 	call	0x1c0c	; 0x1c0c <vTaskSwitchContext>
    portRESTORE_CONTEXT();
    2b2e:	a0 91 29 03 	lds	r26, 0x0329	; 0x800329 <pxCurrentTCB>
    2b32:	b0 91 2a 03 	lds	r27, 0x032A	; 0x80032a <pxCurrentTCB+0x1>
    2b36:	cd 91       	ld	r28, X+
    2b38:	cd bf       	out	0x3d, r28	; 61
    2b3a:	dd 91       	ld	r29, X+
    2b3c:	de bf       	out	0x3e, r29	; 62
    2b3e:	ff 91       	pop	r31
    2b40:	ef 91       	pop	r30
    2b42:	df 91       	pop	r29
    2b44:	cf 91       	pop	r28
    2b46:	bf 91       	pop	r27
    2b48:	af 91       	pop	r26
    2b4a:	9f 91       	pop	r25
    2b4c:	8f 91       	pop	r24
    2b4e:	7f 91       	pop	r23
    2b50:	6f 91       	pop	r22
    2b52:	5f 91       	pop	r21
    2b54:	4f 91       	pop	r20
    2b56:	3f 91       	pop	r19
    2b58:	2f 91       	pop	r18
    2b5a:	1f 91       	pop	r17
    2b5c:	0f 91       	pop	r16
    2b5e:	ff 90       	pop	r15
    2b60:	ef 90       	pop	r14
    2b62:	df 90       	pop	r13
    2b64:	cf 90       	pop	r12
    2b66:	bf 90       	pop	r11
    2b68:	af 90       	pop	r10
    2b6a:	9f 90       	pop	r9
    2b6c:	8f 90       	pop	r8
    2b6e:	7f 90       	pop	r7
    2b70:	6f 90       	pop	r6
    2b72:	5f 90       	pop	r5
    2b74:	4f 90       	pop	r4
    2b76:	3f 90       	pop	r3
    2b78:	2f 90       	pop	r2
    2b7a:	1f 90       	pop	r1
    2b7c:	0f 90       	pop	r0
    2b7e:	0f be       	out	0x3f, r0	; 63
    2b80:	0f 90       	pop	r0

    __asm__ __volatile__ ( "ret" );
    2b82:	08 95       	ret

00002b84 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( hot, flatten, naked ) );
void vPortYieldFromTick( void )
{
    portSAVE_CONTEXT();
    2b84:	0f 92       	push	r0
    2b86:	0f b6       	in	r0, 0x3f	; 63
    2b88:	f8 94       	cli
    2b8a:	0f 92       	push	r0
    2b8c:	1f 92       	push	r1
    2b8e:	11 24       	eor	r1, r1
    2b90:	2f 92       	push	r2
    2b92:	3f 92       	push	r3
    2b94:	4f 92       	push	r4
    2b96:	5f 92       	push	r5
    2b98:	6f 92       	push	r6
    2b9a:	7f 92       	push	r7
    2b9c:	8f 92       	push	r8
    2b9e:	9f 92       	push	r9
    2ba0:	af 92       	push	r10
    2ba2:	bf 92       	push	r11
    2ba4:	cf 92       	push	r12
    2ba6:	df 92       	push	r13
    2ba8:	ef 92       	push	r14
    2baa:	ff 92       	push	r15
    2bac:	0f 93       	push	r16
    2bae:	1f 93       	push	r17
    2bb0:	2f 93       	push	r18
    2bb2:	3f 93       	push	r19
    2bb4:	4f 93       	push	r20
    2bb6:	5f 93       	push	r21
    2bb8:	6f 93       	push	r22
    2bba:	7f 93       	push	r23
    2bbc:	8f 93       	push	r24
    2bbe:	9f 93       	push	r25
    2bc0:	af 93       	push	r26
    2bc2:	bf 93       	push	r27
    2bc4:	cf 93       	push	r28
    2bc6:	df 93       	push	r29
    2bc8:	ef 93       	push	r30
    2bca:	ff 93       	push	r31
    2bcc:	a0 91 29 03 	lds	r26, 0x0329	; 0x800329 <pxCurrentTCB>
    2bd0:	b0 91 2a 03 	lds	r27, 0x032A	; 0x80032a <pxCurrentTCB+0x1>
    2bd4:	0d b6       	in	r0, 0x3d	; 61
    2bd6:	0d 92       	st	X+, r0
    2bd8:	0e b6       	in	r0, 0x3e	; 62
    2bda:	0d 92       	st	X+, r0

    sleep_reset();        //     reset the sleep_mode() faster than sleep_disable();
    2bdc:	13 be       	out	0x33, r1	; 51

    if( xTaskIncrementTick() != pdFALSE )
    2bde:	0e 94 9e 0c 	call	0x193c	; 0x193c <xTaskIncrementTick>
    2be2:	81 11       	cpse	r24, r1
    {
        vTaskSwitchContext();
    2be4:	0e 94 06 0e 	call	0x1c0c	; 0x1c0c <vTaskSwitchContext>
    }

    portRESTORE_CONTEXT();
    2be8:	a0 91 29 03 	lds	r26, 0x0329	; 0x800329 <pxCurrentTCB>
    2bec:	b0 91 2a 03 	lds	r27, 0x032A	; 0x80032a <pxCurrentTCB+0x1>
    2bf0:	cd 91       	ld	r28, X+
    2bf2:	cd bf       	out	0x3d, r28	; 61
    2bf4:	dd 91       	ld	r29, X+
    2bf6:	de bf       	out	0x3e, r29	; 62
    2bf8:	ff 91       	pop	r31
    2bfa:	ef 91       	pop	r30
    2bfc:	df 91       	pop	r29
    2bfe:	cf 91       	pop	r28
    2c00:	bf 91       	pop	r27
    2c02:	af 91       	pop	r26
    2c04:	9f 91       	pop	r25
    2c06:	8f 91       	pop	r24
    2c08:	7f 91       	pop	r23
    2c0a:	6f 91       	pop	r22
    2c0c:	5f 91       	pop	r21
    2c0e:	4f 91       	pop	r20
    2c10:	3f 91       	pop	r19
    2c12:	2f 91       	pop	r18
    2c14:	1f 91       	pop	r17
    2c16:	0f 91       	pop	r16
    2c18:	ff 90       	pop	r15
    2c1a:	ef 90       	pop	r14
    2c1c:	df 90       	pop	r13
    2c1e:	cf 90       	pop	r12
    2c20:	bf 90       	pop	r11
    2c22:	af 90       	pop	r10
    2c24:	9f 90       	pop	r9
    2c26:	8f 90       	pop	r8
    2c28:	7f 90       	pop	r7
    2c2a:	6f 90       	pop	r6
    2c2c:	5f 90       	pop	r5
    2c2e:	4f 90       	pop	r4
    2c30:	3f 90       	pop	r3
    2c32:	2f 90       	pop	r2
    2c34:	1f 90       	pop	r1
    2c36:	0f 90       	pop	r0
    2c38:	0f be       	out	0x3f, r0	; 63
    2c3a:	0f 90       	pop	r0

    __asm__ __volatile__ ( "ret" );
    2c3c:	08 95       	ret

00002c3e <__vector_6>:
     */
    ISR(portSCHEDULER_ISR, ISR_NAKED) __attribute__ ((hot, flatten));
//  ISR(portSCHEDULER_ISR, ISR_NAKED ISR_NOBLOCK) __attribute__ ((hot, flatten));
    ISR(portSCHEDULER_ISR)
    {
        vPortYieldFromTick();
    2c3e:	0e 94 c2 15 	call	0x2b84	; 0x2b84 <vPortYieldFromTick>
        __asm__ __volatile__ ( "reti" );
    2c42:	18 95       	reti

00002c44 <_ZN14FreqCountClass5beginEj>:
static uint16_t gate_index;


void FreqCountClass::begin(uint16_t msec)
{
	if (msec < 1) return;
    2c44:	00 97       	sbiw	r24, 0x00	; 0
    2c46:	09 f4       	brne	.+2      	; 0x2c4a <_ZN14FreqCountClass5beginEj+0x6>
    2c48:	74 c0       	rjmp	.+232    	; 0x2d32 <L_130_loop+0xc>
	gate_index = 0;
    2c4a:	10 92 49 03 	sts	0x0349, r1	; 0x800349 <_ZL10gate_index+0x1>
    2c4e:	10 92 48 03 	sts	0x0348, r1	; 0x800348 <_ZL10gate_index>
	count_msw = 0;
    2c52:	10 92 56 03 	sts	0x0356, r1	; 0x800356 <_ZL9count_msw+0x1>
    2c56:	10 92 55 03 	sts	0x0355, r1	; 0x800355 <_ZL9count_msw>
	count_prev = 0;
    2c5a:	10 92 51 03 	sts	0x0351, r1	; 0x800351 <_ZL10count_prev>
    2c5e:	10 92 52 03 	sts	0x0352, r1	; 0x800352 <_ZL10count_prev+0x1>
    2c62:	10 92 53 03 	sts	0x0353, r1	; 0x800353 <_ZL10count_prev+0x2>
    2c66:	10 92 54 03 	sts	0x0354, r1	; 0x800354 <_ZL10count_prev+0x3>
	count_ready = 0;
    2c6a:	10 92 4c 03 	sts	0x034C, r1	; 0x80034c <_ZL11count_ready>

static uint8_t saveTCCR1A, saveTCCR1B;

static inline void counter_init(void)
{
	saveTCCR1A = TCCR1A;
    2c6e:	20 91 80 00 	lds	r18, 0x0080	; 0x800080 <__DATA_REGION_ORIGIN__+0x20>
    2c72:	20 93 5b 03 	sts	0x035B, r18	; 0x80035b <_ZL10saveTCCR1A>
	saveTCCR1B = TCCR1B;
    2c76:	20 91 81 00 	lds	r18, 0x0081	; 0x800081 <__DATA_REGION_ORIGIN__+0x21>
    2c7a:	20 93 5a 03 	sts	0x035A, r18	; 0x80035a <_ZL10saveTCCR1B>
	TCCR1B = 0;
    2c7e:	10 92 81 00 	sts	0x0081, r1	; 0x800081 <__DATA_REGION_ORIGIN__+0x21>
	TCCR1A = 0;
    2c82:	10 92 80 00 	sts	0x0080, r1	; 0x800080 <__DATA_REGION_ORIGIN__+0x20>
	TCNT1 = 0;
    2c86:	10 92 85 00 	sts	0x0085, r1	; 0x800085 <__DATA_REGION_ORIGIN__+0x25>
    2c8a:	10 92 84 00 	sts	0x0084, r1	; 0x800084 <__DATA_REGION_ORIGIN__+0x24>
	TIFR1 = (1<<TOV1);
    2c8e:	21 e0       	ldi	r18, 0x01	; 1
    2c90:	26 bb       	out	0x16, r18	; 22
	TIMSK1 = 0;
    2c92:	10 92 6f 00 	sts	0x006F, r1	; 0x80006f <__DATA_REGION_ORIGIN__+0xf>

static inline uint16_t timer_init(uint16_t msec)
{
	uint16_t gate_len;

	saveTCCR2A = TCCR2A;
    2c96:	20 91 b0 00 	lds	r18, 0x00B0	; 0x8000b0 <__DATA_REGION_ORIGIN__+0x50>
    2c9a:	20 93 59 03 	sts	0x0359, r18	; 0x800359 <_ZL10saveTCCR2A>
	saveTCCR2B = TCCR2B;
    2c9e:	20 91 b1 00 	lds	r18, 0x00B1	; 0x8000b1 <__DATA_REGION_ORIGIN__+0x51>
    2ca2:	20 93 58 03 	sts	0x0358, r18	; 0x800358 <_ZL10saveTCCR2B>
	TCCR2B = 0;
    2ca6:	10 92 b1 00 	sts	0x00B1, r1	; 0x8000b1 <__DATA_REGION_ORIGIN__+0x51>
	TCCR2A = (1<<WGM21);
    2caa:	22 e0       	ldi	r18, 0x02	; 2
    2cac:	20 93 b0 00 	sts	0x00B0, r18	; 0x8000b0 <__DATA_REGION_ORIGIN__+0x50>
	if ((msec & 7) == 0) {
    2cb0:	9c 01       	movw	r18, r24
    2cb2:	27 70       	andi	r18, 0x07	; 7
    2cb4:	33 27       	eor	r19, r19
    2cb6:	23 2b       	or	r18, r19
    2cb8:	51 f4       	brne	.+20     	; 0x2cce <_ZN14FreqCountClass5beginEj+0x8a>
		gate_len = msec >> 3;
    2cba:	43 e0       	ldi	r20, 0x03	; 3
    2cbc:	96 95       	lsr	r25
    2cbe:	87 95       	ror	r24
    2cc0:	4a 95       	dec	r20
    2cc2:	e1 f7       	brne	.-8      	; 0x2cbc <_ZN14FreqCountClass5beginEj+0x78>
		OCR2A = TIMER2_OCR2A_8MS_VAL;
    2cc4:	2c e7       	ldi	r18, 0x7C	; 124
    2cc6:	20 93 b3 00 	sts	0x00B3, r18	; 0x8000b3 <__DATA_REGION_ORIGIN__+0x53>
		startTCCR2B = TIMER2_TCCR2B_8MS_VAL;
    2cca:	27 e0       	ldi	r18, 0x07	; 7
    2ccc:	18 c0       	rjmp	.+48     	; 0x2cfe <_ZN14FreqCountClass5beginEj+0xba>
	} else if ((msec & 3) == 0) {
    2cce:	9c 01       	movw	r18, r24
    2cd0:	23 70       	andi	r18, 0x03	; 3
    2cd2:	33 27       	eor	r19, r19
    2cd4:	23 2b       	or	r18, r19
    2cd6:	31 f4       	brne	.+12     	; 0x2ce4 <_ZN14FreqCountClass5beginEj+0xa0>
		gate_len = msec >> 2;
    2cd8:	96 95       	lsr	r25
    2cda:	87 95       	ror	r24
    2cdc:	96 95       	lsr	r25
    2cde:	87 95       	ror	r24
		OCR2A = TIMER2_OCR2A_4MS_VAL;
    2ce0:	29 ef       	ldi	r18, 0xF9	; 249
    2ce2:	05 c0       	rjmp	.+10     	; 0x2cee <_ZN14FreqCountClass5beginEj+0xaa>
		startTCCR2B = TIMER2_TCCR2B_4MS_VAL;
	} else if ((msec & 1) == 0) {
    2ce4:	80 fd       	sbrc	r24, 0
    2ce6:	07 c0       	rjmp	.+14     	; 0x2cf6 <_ZN14FreqCountClass5beginEj+0xb2>
		gate_len = msec >> 1;
    2ce8:	96 95       	lsr	r25
    2cea:	87 95       	ror	r24
		OCR2A = TIMER2_OCR2A_2MS_VAL;
    2cec:	2c e7       	ldi	r18, 0x7C	; 124
    2cee:	20 93 b3 00 	sts	0x00B3, r18	; 0x8000b3 <__DATA_REGION_ORIGIN__+0x53>
		startTCCR2B = TIMER2_TCCR2B_2MS_VAL;
    2cf2:	26 e0       	ldi	r18, 0x06	; 6
    2cf4:	04 c0       	rjmp	.+8      	; 0x2cfe <_ZN14FreqCountClass5beginEj+0xba>
	} else {
		gate_len = msec;
		OCR2A = TIMER2_OCR2A_1MS_VAL;
    2cf6:	2c e7       	ldi	r18, 0x7C	; 124
    2cf8:	20 93 b3 00 	sts	0x00B3, r18	; 0x8000b3 <__DATA_REGION_ORIGIN__+0x53>
		startTCCR2B = TIMER2_TCCR2B_1MS_VAL;
    2cfc:	25 e0       	ldi	r18, 0x05	; 5
    2cfe:	20 93 57 03 	sts	0x0357, r18	; 0x800357 <_ZL11startTCCR2B>
	}
	TIFR2 = (1<<OCF2A);
    2d02:	22 e0       	ldi	r18, 0x02	; 2
    2d04:	27 bb       	out	0x17, r18	; 23
	TCNT2 = 0;
    2d06:	10 92 b2 00 	sts	0x00B2, r1	; 0x8000b2 <__DATA_REGION_ORIGIN__+0x52>
	counter_init();
	gate_length = timer_init(msec);
    2d0a:	90 93 4b 03 	sts	0x034B, r25	; 0x80034b <_ZL11gate_length+0x1>
    2d0e:	80 93 4a 03 	sts	0x034A, r24	; 0x80034a <_ZL11gate_length>
	uint8_t status = SREG;
    2d12:	9f b7       	in	r25, 0x3f	; 63
	cli();
    2d14:	f8 94       	cli
	return gate_len;
}

static inline void timer_start(void)
{
	GTCCR = (1<<PSRASY);
    2d16:	23 bd       	out	0x23, r18	; 35
	TCCR2B = startTCCR2B;
    2d18:	80 91 57 03 	lds	r24, 0x0357	; 0x800357 <_ZL11startTCCR2B>
    2d1c:	80 93 b1 00 	sts	0x00B1, r24	; 0x8000b1 <__DATA_REGION_ORIGIN__+0x51>
	TIMSK2 = (1<<OCIE2A);
    2d20:	20 93 70 00 	sts	0x0070, r18	; 0x800070 <__DATA_REGION_ORIGIN__+0x10>
		"L_%=_loop:"
		"subi   %0, 1"		"\n\t"
		"brne   L_%=_loop"	"\n\t"
		: "+d" (cycles_times_3)
		: "0" (cycles_times_3)
	);
    2d24:	8b e0       	ldi	r24, 0x0B	; 11

00002d26 <L_130_loop>:
    2d26:	81 50       	subi	r24, 0x01	; 1
    2d28:	f1 f7       	brne	.-4      	; 0x2d26 <L_130_loop>
	TIMSK1 = 0;
}

static inline void counter_start(void)
{
	TCCR1B = (1<<CS12) | (1<<CS11) | (1<<CS10);
    2d2a:	87 e0       	ldi	r24, 0x07	; 7
    2d2c:	80 93 81 00 	sts	0x0081, r24	; 0x800081 <__DATA_REGION_ORIGIN__+0x21>
	timer_start();
	timer_isr_latency_delay();
	counter_start();
	SREG = status;
    2d30:	9f bf       	out	0x3f, r25	; 63
    2d32:	08 95       	ret

00002d34 <_ZN14FreqCountClass9availableEv>:
}

uint8_t FreqCountClass::available(void)
{
	return count_ready;
    2d34:	80 91 4c 03 	lds	r24, 0x034C	; 0x80034c <_ZL11count_ready>
}
    2d38:	08 95       	ret

00002d3a <_ZN14FreqCountClass4readEv>:
uint32_t FreqCountClass::read(void)
{
	uint32_t count;
	uint8_t status;

	status = SREG;
    2d3a:	2f b7       	in	r18, 0x3f	; 63
	cli();
    2d3c:	f8 94       	cli
	count = count_output;
    2d3e:	60 91 4d 03 	lds	r22, 0x034D	; 0x80034d <_ZL12count_output>
    2d42:	70 91 4e 03 	lds	r23, 0x034E	; 0x80034e <_ZL12count_output+0x1>
    2d46:	80 91 4f 03 	lds	r24, 0x034F	; 0x80034f <_ZL12count_output+0x2>
    2d4a:	90 91 50 03 	lds	r25, 0x0350	; 0x800350 <_ZL12count_output+0x3>
	count_ready = 0;
    2d4e:	10 92 4c 03 	sts	0x034C, r1	; 0x80034c <_ZL11count_ready>
	SREG = status;
    2d52:	2f bf       	out	0x3f, r18	; 63
	return count;
}
    2d54:	08 95       	ret

00002d56 <_ZN14FreqCountClass3endEv>:
	TIMSK2 = (1<<OCIE2A);
}

static inline void timer_shutdown(void)
{
	TCCR2B = 0;
    2d56:	e1 eb       	ldi	r30, 0xB1	; 177
    2d58:	f0 e0       	ldi	r31, 0x00	; 0
    2d5a:	10 82       	st	Z, r1
	TIMSK2 = 0;
    2d5c:	10 92 70 00 	sts	0x0070, r1	; 0x800070 <__DATA_REGION_ORIGIN__+0x10>
	TCCR2A = saveTCCR2A;
    2d60:	80 91 59 03 	lds	r24, 0x0359	; 0x800359 <_ZL10saveTCCR2A>
    2d64:	80 93 b0 00 	sts	0x00B0, r24	; 0x8000b0 <__DATA_REGION_ORIGIN__+0x50>
	TCCR2B = saveTCCR2B;
    2d68:	80 91 58 03 	lds	r24, 0x0358	; 0x800358 <_ZL10saveTCCR2B>
    2d6c:	80 83       	st	Z, r24
	TCCR1B = (1<<CS12) | (1<<CS11) | (1<<CS10);
}

static inline void counter_shutdown(void)
{
	TCCR1B = 0;
    2d6e:	e1 e8       	ldi	r30, 0x81	; 129
    2d70:	f0 e0       	ldi	r31, 0x00	; 0
    2d72:	10 82       	st	Z, r1
	TCCR1A = saveTCCR1A;
    2d74:	80 91 5b 03 	lds	r24, 0x035B	; 0x80035b <_ZL10saveTCCR1A>
    2d78:	80 93 80 00 	sts	0x0080, r24	; 0x800080 <__DATA_REGION_ORIGIN__+0x20>
	TCCR1B = saveTCCR1B;
    2d7c:	80 91 5a 03 	lds	r24, 0x035A	; 0x80035a <_ZL10saveTCCR1B>
    2d80:	80 83       	st	Z, r24
    2d82:	08 95       	ret

00002d84 <__vector_7>:
	counter_shutdown();
}


ISR(TIMER_ISR_VECTOR)
{
    2d84:	1f 92       	push	r1
    2d86:	0f 92       	push	r0
    2d88:	0f b6       	in	r0, 0x3f	; 63
    2d8a:	0f 92       	push	r0
    2d8c:	11 24       	eor	r1, r1
    2d8e:	0f 93       	push	r16
    2d90:	1f 93       	push	r17
    2d92:	2f 93       	push	r18
    2d94:	3f 93       	push	r19
    2d96:	4f 93       	push	r20
    2d98:	5f 93       	push	r21
    2d9a:	6f 93       	push	r22
    2d9c:	7f 93       	push	r23
    2d9e:	8f 93       	push	r24
    2da0:	9f 93       	push	r25
    2da2:	af 93       	push	r26
    2da4:	bf 93       	push	r27
}

static inline uint16_t counter_read(void)
{
	return TCNT1;
    2da6:	20 91 84 00 	lds	r18, 0x0084	; 0x800084 <__DATA_REGION_ORIGIN__+0x24>
    2daa:	30 91 85 00 	lds	r19, 0x0085	; 0x800085 <__DATA_REGION_ORIGIN__+0x25>
	uint16_t count_lsw;
	uint32_t count;
	uint16_t index, length;

	count_lsw = counter_read();
	if (counter_overflow()) {
    2dae:	b0 9b       	sbis	0x16, 0	; 22
    2db0:	0b c0       	rjmp	.+22     	; 0x2dc8 <__vector_7+0x44>
	return TIFR1 & (1<<TOV1);
}

static inline void counter_overflow_reset(void)
{
	TIFR1 = (1<<TOV1);
    2db2:	81 e0       	ldi	r24, 0x01	; 1
    2db4:	86 bb       	out	0x16, r24	; 22
		counter_overflow_reset();
		count_msw++;
    2db6:	80 91 55 03 	lds	r24, 0x0355	; 0x800355 <_ZL9count_msw>
    2dba:	90 91 56 03 	lds	r25, 0x0356	; 0x800356 <_ZL9count_msw+0x1>
    2dbe:	01 96       	adiw	r24, 0x01	; 1
    2dc0:	90 93 56 03 	sts	0x0356, r25	; 0x800356 <_ZL9count_msw+0x1>
    2dc4:	80 93 55 03 	sts	0x0355, r24	; 0x800355 <_ZL9count_msw>
	}
	index = gate_index + 1;
    2dc8:	80 91 48 03 	lds	r24, 0x0348	; 0x800348 <_ZL10gate_index>
    2dcc:	90 91 49 03 	lds	r25, 0x0349	; 0x800349 <_ZL10gate_index+0x1>
    2dd0:	01 96       	adiw	r24, 0x01	; 1
	length = gate_length;
	if (index >= length) {
    2dd2:	40 91 4a 03 	lds	r20, 0x034A	; 0x80034a <_ZL11gate_length>
    2dd6:	50 91 4b 03 	lds	r21, 0x034B	; 0x80034b <_ZL11gate_length+0x1>
    2dda:	84 17       	cp	r24, r20
    2ddc:	95 07       	cpc	r25, r21
    2dde:	98 f1       	brcs	.+102    	; 0x2e46 <__vector_7+0xc2>
		gate_index = 0;
    2de0:	10 92 49 03 	sts	0x0349, r1	; 0x800349 <_ZL10gate_index+0x1>
    2de4:	10 92 48 03 	sts	0x0348, r1	; 0x800348 <_ZL10gate_index>
		count = ((uint32_t)count_msw << 16) + count_lsw;
    2de8:	80 91 55 03 	lds	r24, 0x0355	; 0x800355 <_ZL9count_msw>
    2dec:	90 91 56 03 	lds	r25, 0x0356	; 0x800356 <_ZL9count_msw+0x1>
    2df0:	a0 e0       	ldi	r26, 0x00	; 0
    2df2:	b0 e0       	ldi	r27, 0x00	; 0
    2df4:	dc 01       	movw	r26, r24
    2df6:	99 27       	eor	r25, r25
    2df8:	88 27       	eor	r24, r24
    2dfa:	82 0f       	add	r24, r18
    2dfc:	93 1f       	adc	r25, r19
    2dfe:	a1 1d       	adc	r26, r1
    2e00:	b1 1d       	adc	r27, r1
		count_output = count - count_prev;
    2e02:	40 91 51 03 	lds	r20, 0x0351	; 0x800351 <_ZL10count_prev>
    2e06:	50 91 52 03 	lds	r21, 0x0352	; 0x800352 <_ZL10count_prev+0x1>
    2e0a:	60 91 53 03 	lds	r22, 0x0353	; 0x800353 <_ZL10count_prev+0x2>
    2e0e:	70 91 54 03 	lds	r23, 0x0354	; 0x800354 <_ZL10count_prev+0x3>
    2e12:	8c 01       	movw	r16, r24
    2e14:	9d 01       	movw	r18, r26
    2e16:	04 1b       	sub	r16, r20
    2e18:	15 0b       	sbc	r17, r21
    2e1a:	26 0b       	sbc	r18, r22
    2e1c:	37 0b       	sbc	r19, r23
    2e1e:	00 93 4d 03 	sts	0x034D, r16	; 0x80034d <_ZL12count_output>
    2e22:	10 93 4e 03 	sts	0x034E, r17	; 0x80034e <_ZL12count_output+0x1>
    2e26:	20 93 4f 03 	sts	0x034F, r18	; 0x80034f <_ZL12count_output+0x2>
    2e2a:	30 93 50 03 	sts	0x0350, r19	; 0x800350 <_ZL12count_output+0x3>
		count_prev = count;
    2e2e:	80 93 51 03 	sts	0x0351, r24	; 0x800351 <_ZL10count_prev>
    2e32:	90 93 52 03 	sts	0x0352, r25	; 0x800352 <_ZL10count_prev+0x1>
    2e36:	a0 93 53 03 	sts	0x0353, r26	; 0x800353 <_ZL10count_prev+0x2>
    2e3a:	b0 93 54 03 	sts	0x0354, r27	; 0x800354 <_ZL10count_prev+0x3>
		count_ready = 1;
    2e3e:	81 e0       	ldi	r24, 0x01	; 1
    2e40:	80 93 4c 03 	sts	0x034C, r24	; 0x80034c <_ZL11count_ready>
    2e44:	04 c0       	rjmp	.+8      	; 0x2e4e <__vector_7+0xca>
		restore_other_interrupts();
	} else {
		if (index == length - 1) disable_other_interrupts();
		gate_index = index;
    2e46:	90 93 49 03 	sts	0x0349, r25	; 0x800349 <_ZL10gate_index+0x1>
    2e4a:	80 93 48 03 	sts	0x0348, r24	; 0x800348 <_ZL10gate_index>
	}
}
    2e4e:	bf 91       	pop	r27
    2e50:	af 91       	pop	r26
    2e52:	9f 91       	pop	r25
    2e54:	8f 91       	pop	r24
    2e56:	7f 91       	pop	r23
    2e58:	6f 91       	pop	r22
    2e5a:	5f 91       	pop	r21
    2e5c:	4f 91       	pop	r20
    2e5e:	3f 91       	pop	r19
    2e60:	2f 91       	pop	r18
    2e62:	1f 91       	pop	r17
    2e64:	0f 91       	pop	r16
    2e66:	0f 90       	pop	r0
    2e68:	0f be       	out	0x3f, r0	; 63
    2e6a:	0f 90       	pop	r0
    2e6c:	1f 90       	pop	r1
    2e6e:	18 95       	reti

00002e70 <__divmodhi4>:
    2e70:	97 fb       	bst	r25, 7
    2e72:	07 2e       	mov	r0, r23
    2e74:	16 f4       	brtc	.+4      	; 0x2e7a <__divmodhi4+0xa>
    2e76:	00 94       	com	r0
    2e78:	07 d0       	rcall	.+14     	; 0x2e88 <__divmodhi4_neg1>
    2e7a:	77 fd       	sbrc	r23, 7
    2e7c:	09 d0       	rcall	.+18     	; 0x2e90 <__divmodhi4_neg2>
    2e7e:	0e 94 9e 17 	call	0x2f3c	; 0x2f3c <__udivmodhi4>
    2e82:	07 fc       	sbrc	r0, 7
    2e84:	05 d0       	rcall	.+10     	; 0x2e90 <__divmodhi4_neg2>
    2e86:	3e f4       	brtc	.+14     	; 0x2e96 <__divmodhi4_exit>

00002e88 <__divmodhi4_neg1>:
    2e88:	90 95       	com	r25
    2e8a:	81 95       	neg	r24
    2e8c:	9f 4f       	sbci	r25, 0xFF	; 255
    2e8e:	08 95       	ret

00002e90 <__divmodhi4_neg2>:
    2e90:	70 95       	com	r23
    2e92:	61 95       	neg	r22
    2e94:	7f 4f       	sbci	r23, 0xFF	; 255

00002e96 <__divmodhi4_exit>:
    2e96:	08 95       	ret

00002e98 <__udivmodsi4>:
    2e98:	a1 e2       	ldi	r26, 0x21	; 33
    2e9a:	1a 2e       	mov	r1, r26
    2e9c:	aa 1b       	sub	r26, r26
    2e9e:	bb 1b       	sub	r27, r27
    2ea0:	fd 01       	movw	r30, r26
    2ea2:	0d c0       	rjmp	.+26     	; 0x2ebe <__udivmodsi4_ep>

00002ea4 <__udivmodsi4_loop>:
    2ea4:	aa 1f       	adc	r26, r26
    2ea6:	bb 1f       	adc	r27, r27
    2ea8:	ee 1f       	adc	r30, r30
    2eaa:	ff 1f       	adc	r31, r31
    2eac:	a2 17       	cp	r26, r18
    2eae:	b3 07       	cpc	r27, r19
    2eb0:	e4 07       	cpc	r30, r20
    2eb2:	f5 07       	cpc	r31, r21
    2eb4:	20 f0       	brcs	.+8      	; 0x2ebe <__udivmodsi4_ep>
    2eb6:	a2 1b       	sub	r26, r18
    2eb8:	b3 0b       	sbc	r27, r19
    2eba:	e4 0b       	sbc	r30, r20
    2ebc:	f5 0b       	sbc	r31, r21

00002ebe <__udivmodsi4_ep>:
    2ebe:	66 1f       	adc	r22, r22
    2ec0:	77 1f       	adc	r23, r23
    2ec2:	88 1f       	adc	r24, r24
    2ec4:	99 1f       	adc	r25, r25
    2ec6:	1a 94       	dec	r1
    2ec8:	69 f7       	brne	.-38     	; 0x2ea4 <__udivmodsi4_loop>
    2eca:	60 95       	com	r22
    2ecc:	70 95       	com	r23
    2ece:	80 95       	com	r24
    2ed0:	90 95       	com	r25
    2ed2:	9b 01       	movw	r18, r22
    2ed4:	ac 01       	movw	r20, r24
    2ed6:	bd 01       	movw	r22, r26
    2ed8:	cf 01       	movw	r24, r30
    2eda:	08 95       	ret

00002edc <__divmodsi4>:
    2edc:	05 2e       	mov	r0, r21
    2ede:	97 fb       	bst	r25, 7
    2ee0:	1e f4       	brtc	.+6      	; 0x2ee8 <__divmodsi4+0xc>
    2ee2:	00 94       	com	r0
    2ee4:	0e 94 85 17 	call	0x2f0a	; 0x2f0a <__negsi2>
    2ee8:	57 fd       	sbrc	r21, 7
    2eea:	07 d0       	rcall	.+14     	; 0x2efa <__divmodsi4_neg2>
    2eec:	0e 94 4c 17 	call	0x2e98	; 0x2e98 <__udivmodsi4>
    2ef0:	07 fc       	sbrc	r0, 7
    2ef2:	03 d0       	rcall	.+6      	; 0x2efa <__divmodsi4_neg2>
    2ef4:	4e f4       	brtc	.+18     	; 0x2f08 <__divmodsi4_exit>
    2ef6:	0c 94 85 17 	jmp	0x2f0a	; 0x2f0a <__negsi2>

00002efa <__divmodsi4_neg2>:
    2efa:	50 95       	com	r21
    2efc:	40 95       	com	r20
    2efe:	30 95       	com	r19
    2f00:	21 95       	neg	r18
    2f02:	3f 4f       	sbci	r19, 0xFF	; 255
    2f04:	4f 4f       	sbci	r20, 0xFF	; 255
    2f06:	5f 4f       	sbci	r21, 0xFF	; 255

00002f08 <__divmodsi4_exit>:
    2f08:	08 95       	ret

00002f0a <__negsi2>:
    2f0a:	90 95       	com	r25
    2f0c:	80 95       	com	r24
    2f0e:	70 95       	com	r23
    2f10:	61 95       	neg	r22
    2f12:	7f 4f       	sbci	r23, 0xFF	; 255
    2f14:	8f 4f       	sbci	r24, 0xFF	; 255
    2f16:	9f 4f       	sbci	r25, 0xFF	; 255
    2f18:	08 95       	ret

00002f1a <__tablejump2__>:
    2f1a:	ee 0f       	add	r30, r30
    2f1c:	ff 1f       	adc	r31, r31
    2f1e:	05 90       	lpm	r0, Z+
    2f20:	f4 91       	lpm	r31, Z
    2f22:	e0 2d       	mov	r30, r0
    2f24:	09 94       	ijmp

00002f26 <__muluhisi3>:
    2f26:	0e 94 b2 17 	call	0x2f64	; 0x2f64 <__umulhisi3>
    2f2a:	a5 9f       	mul	r26, r21
    2f2c:	90 0d       	add	r25, r0
    2f2e:	b4 9f       	mul	r27, r20
    2f30:	90 0d       	add	r25, r0
    2f32:	a4 9f       	mul	r26, r20
    2f34:	80 0d       	add	r24, r0
    2f36:	91 1d       	adc	r25, r1
    2f38:	11 24       	eor	r1, r1
    2f3a:	08 95       	ret

00002f3c <__udivmodhi4>:
    2f3c:	aa 1b       	sub	r26, r26
    2f3e:	bb 1b       	sub	r27, r27
    2f40:	51 e1       	ldi	r21, 0x11	; 17
    2f42:	07 c0       	rjmp	.+14     	; 0x2f52 <__udivmodhi4_ep>

00002f44 <__udivmodhi4_loop>:
    2f44:	aa 1f       	adc	r26, r26
    2f46:	bb 1f       	adc	r27, r27
    2f48:	a6 17       	cp	r26, r22
    2f4a:	b7 07       	cpc	r27, r23
    2f4c:	10 f0       	brcs	.+4      	; 0x2f52 <__udivmodhi4_ep>
    2f4e:	a6 1b       	sub	r26, r22
    2f50:	b7 0b       	sbc	r27, r23

00002f52 <__udivmodhi4_ep>:
    2f52:	88 1f       	adc	r24, r24
    2f54:	99 1f       	adc	r25, r25
    2f56:	5a 95       	dec	r21
    2f58:	a9 f7       	brne	.-22     	; 0x2f44 <__udivmodhi4_loop>
    2f5a:	80 95       	com	r24
    2f5c:	90 95       	com	r25
    2f5e:	bc 01       	movw	r22, r24
    2f60:	cd 01       	movw	r24, r26
    2f62:	08 95       	ret

00002f64 <__umulhisi3>:
    2f64:	a2 9f       	mul	r26, r18
    2f66:	b0 01       	movw	r22, r0
    2f68:	b3 9f       	mul	r27, r19
    2f6a:	c0 01       	movw	r24, r0
    2f6c:	a3 9f       	mul	r26, r19
    2f6e:	70 0d       	add	r23, r0
    2f70:	81 1d       	adc	r24, r1
    2f72:	11 24       	eor	r1, r1
    2f74:	91 1d       	adc	r25, r1
    2f76:	b2 9f       	mul	r27, r18
    2f78:	70 0d       	add	r23, r0
    2f7a:	81 1d       	adc	r24, r1
    2f7c:	11 24       	eor	r1, r1
    2f7e:	91 1d       	adc	r25, r1
    2f80:	08 95       	ret

00002f82 <malloc>:
    2f82:	0f 93       	push	r16
    2f84:	1f 93       	push	r17
    2f86:	cf 93       	push	r28
    2f88:	df 93       	push	r29
    2f8a:	82 30       	cpi	r24, 0x02	; 2
    2f8c:	91 05       	cpc	r25, r1
    2f8e:	10 f4       	brcc	.+4      	; 0x2f94 <malloc+0x12>
    2f90:	82 e0       	ldi	r24, 0x02	; 2
    2f92:	90 e0       	ldi	r25, 0x00	; 0
    2f94:	e0 91 5e 03 	lds	r30, 0x035E	; 0x80035e <__flp>
    2f98:	f0 91 5f 03 	lds	r31, 0x035F	; 0x80035f <__flp+0x1>
    2f9c:	20 e0       	ldi	r18, 0x00	; 0
    2f9e:	30 e0       	ldi	r19, 0x00	; 0
    2fa0:	a0 e0       	ldi	r26, 0x00	; 0
    2fa2:	b0 e0       	ldi	r27, 0x00	; 0
    2fa4:	30 97       	sbiw	r30, 0x00	; 0
    2fa6:	19 f1       	breq	.+70     	; 0x2fee <malloc+0x6c>
    2fa8:	40 81       	ld	r20, Z
    2faa:	51 81       	ldd	r21, Z+1	; 0x01
    2fac:	02 81       	ldd	r16, Z+2	; 0x02
    2fae:	13 81       	ldd	r17, Z+3	; 0x03
    2fb0:	48 17       	cp	r20, r24
    2fb2:	59 07       	cpc	r21, r25
    2fb4:	c8 f0       	brcs	.+50     	; 0x2fe8 <malloc+0x66>
    2fb6:	84 17       	cp	r24, r20
    2fb8:	95 07       	cpc	r25, r21
    2fba:	69 f4       	brne	.+26     	; 0x2fd6 <malloc+0x54>
    2fbc:	10 97       	sbiw	r26, 0x00	; 0
    2fbe:	31 f0       	breq	.+12     	; 0x2fcc <malloc+0x4a>
    2fc0:	12 96       	adiw	r26, 0x02	; 2
    2fc2:	0c 93       	st	X, r16
    2fc4:	12 97       	sbiw	r26, 0x02	; 2
    2fc6:	13 96       	adiw	r26, 0x03	; 3
    2fc8:	1c 93       	st	X, r17
    2fca:	27 c0       	rjmp	.+78     	; 0x301a <malloc+0x98>
    2fcc:	00 93 5e 03 	sts	0x035E, r16	; 0x80035e <__flp>
    2fd0:	10 93 5f 03 	sts	0x035F, r17	; 0x80035f <__flp+0x1>
    2fd4:	22 c0       	rjmp	.+68     	; 0x301a <malloc+0x98>
    2fd6:	21 15       	cp	r18, r1
    2fd8:	31 05       	cpc	r19, r1
    2fda:	19 f0       	breq	.+6      	; 0x2fe2 <malloc+0x60>
    2fdc:	42 17       	cp	r20, r18
    2fde:	53 07       	cpc	r21, r19
    2fe0:	18 f4       	brcc	.+6      	; 0x2fe8 <malloc+0x66>
    2fe2:	9a 01       	movw	r18, r20
    2fe4:	bd 01       	movw	r22, r26
    2fe6:	ef 01       	movw	r28, r30
    2fe8:	df 01       	movw	r26, r30
    2fea:	f8 01       	movw	r30, r16
    2fec:	db cf       	rjmp	.-74     	; 0x2fa4 <malloc+0x22>
    2fee:	21 15       	cp	r18, r1
    2ff0:	31 05       	cpc	r19, r1
    2ff2:	f9 f0       	breq	.+62     	; 0x3032 <malloc+0xb0>
    2ff4:	28 1b       	sub	r18, r24
    2ff6:	39 0b       	sbc	r19, r25
    2ff8:	24 30       	cpi	r18, 0x04	; 4
    2ffa:	31 05       	cpc	r19, r1
    2ffc:	80 f4       	brcc	.+32     	; 0x301e <malloc+0x9c>
    2ffe:	8a 81       	ldd	r24, Y+2	; 0x02
    3000:	9b 81       	ldd	r25, Y+3	; 0x03
    3002:	61 15       	cp	r22, r1
    3004:	71 05       	cpc	r23, r1
    3006:	21 f0       	breq	.+8      	; 0x3010 <malloc+0x8e>
    3008:	fb 01       	movw	r30, r22
    300a:	93 83       	std	Z+3, r25	; 0x03
    300c:	82 83       	std	Z+2, r24	; 0x02
    300e:	04 c0       	rjmp	.+8      	; 0x3018 <malloc+0x96>
    3010:	90 93 5f 03 	sts	0x035F, r25	; 0x80035f <__flp+0x1>
    3014:	80 93 5e 03 	sts	0x035E, r24	; 0x80035e <__flp>
    3018:	fe 01       	movw	r30, r28
    301a:	32 96       	adiw	r30, 0x02	; 2
    301c:	44 c0       	rjmp	.+136    	; 0x30a6 <malloc+0x124>
    301e:	fe 01       	movw	r30, r28
    3020:	e2 0f       	add	r30, r18
    3022:	f3 1f       	adc	r31, r19
    3024:	81 93       	st	Z+, r24
    3026:	91 93       	st	Z+, r25
    3028:	22 50       	subi	r18, 0x02	; 2
    302a:	31 09       	sbc	r19, r1
    302c:	39 83       	std	Y+1, r19	; 0x01
    302e:	28 83       	st	Y, r18
    3030:	3a c0       	rjmp	.+116    	; 0x30a6 <malloc+0x124>
    3032:	20 91 5c 03 	lds	r18, 0x035C	; 0x80035c <__brkval>
    3036:	30 91 5d 03 	lds	r19, 0x035D	; 0x80035d <__brkval+0x1>
    303a:	23 2b       	or	r18, r19
    303c:	41 f4       	brne	.+16     	; 0x304e <malloc+0xcc>
    303e:	20 91 02 01 	lds	r18, 0x0102	; 0x800102 <__malloc_heap_start>
    3042:	30 91 03 01 	lds	r19, 0x0103	; 0x800103 <__malloc_heap_start+0x1>
    3046:	30 93 5d 03 	sts	0x035D, r19	; 0x80035d <__brkval+0x1>
    304a:	20 93 5c 03 	sts	0x035C, r18	; 0x80035c <__brkval>
    304e:	20 91 00 01 	lds	r18, 0x0100	; 0x800100 <__data_start>
    3052:	30 91 01 01 	lds	r19, 0x0101	; 0x800101 <__data_start+0x1>
    3056:	21 15       	cp	r18, r1
    3058:	31 05       	cpc	r19, r1
    305a:	41 f4       	brne	.+16     	; 0x306c <malloc+0xea>
    305c:	2d b7       	in	r18, 0x3d	; 61
    305e:	3e b7       	in	r19, 0x3e	; 62
    3060:	40 91 04 01 	lds	r20, 0x0104	; 0x800104 <__malloc_margin>
    3064:	50 91 05 01 	lds	r21, 0x0105	; 0x800105 <__malloc_margin+0x1>
    3068:	24 1b       	sub	r18, r20
    306a:	35 0b       	sbc	r19, r21
    306c:	e0 91 5c 03 	lds	r30, 0x035C	; 0x80035c <__brkval>
    3070:	f0 91 5d 03 	lds	r31, 0x035D	; 0x80035d <__brkval+0x1>
    3074:	e2 17       	cp	r30, r18
    3076:	f3 07       	cpc	r31, r19
    3078:	a0 f4       	brcc	.+40     	; 0x30a2 <malloc+0x120>
    307a:	2e 1b       	sub	r18, r30
    307c:	3f 0b       	sbc	r19, r31
    307e:	28 17       	cp	r18, r24
    3080:	39 07       	cpc	r19, r25
    3082:	78 f0       	brcs	.+30     	; 0x30a2 <malloc+0x120>
    3084:	ac 01       	movw	r20, r24
    3086:	4e 5f       	subi	r20, 0xFE	; 254
    3088:	5f 4f       	sbci	r21, 0xFF	; 255
    308a:	24 17       	cp	r18, r20
    308c:	35 07       	cpc	r19, r21
    308e:	48 f0       	brcs	.+18     	; 0x30a2 <malloc+0x120>
    3090:	4e 0f       	add	r20, r30
    3092:	5f 1f       	adc	r21, r31
    3094:	50 93 5d 03 	sts	0x035D, r21	; 0x80035d <__brkval+0x1>
    3098:	40 93 5c 03 	sts	0x035C, r20	; 0x80035c <__brkval>
    309c:	81 93       	st	Z+, r24
    309e:	91 93       	st	Z+, r25
    30a0:	02 c0       	rjmp	.+4      	; 0x30a6 <malloc+0x124>
    30a2:	e0 e0       	ldi	r30, 0x00	; 0
    30a4:	f0 e0       	ldi	r31, 0x00	; 0
    30a6:	cf 01       	movw	r24, r30
    30a8:	df 91       	pop	r29
    30aa:	cf 91       	pop	r28
    30ac:	1f 91       	pop	r17
    30ae:	0f 91       	pop	r16
    30b0:	08 95       	ret

000030b2 <free>:
    30b2:	cf 93       	push	r28
    30b4:	df 93       	push	r29
    30b6:	00 97       	sbiw	r24, 0x00	; 0
    30b8:	09 f4       	brne	.+2      	; 0x30bc <free+0xa>
    30ba:	81 c0       	rjmp	.+258    	; 0x31be <free+0x10c>
    30bc:	fc 01       	movw	r30, r24
    30be:	32 97       	sbiw	r30, 0x02	; 2
    30c0:	13 82       	std	Z+3, r1	; 0x03
    30c2:	12 82       	std	Z+2, r1	; 0x02
    30c4:	a0 91 5e 03 	lds	r26, 0x035E	; 0x80035e <__flp>
    30c8:	b0 91 5f 03 	lds	r27, 0x035F	; 0x80035f <__flp+0x1>
    30cc:	10 97       	sbiw	r26, 0x00	; 0
    30ce:	81 f4       	brne	.+32     	; 0x30f0 <free+0x3e>
    30d0:	20 81       	ld	r18, Z
    30d2:	31 81       	ldd	r19, Z+1	; 0x01
    30d4:	82 0f       	add	r24, r18
    30d6:	93 1f       	adc	r25, r19
    30d8:	20 91 5c 03 	lds	r18, 0x035C	; 0x80035c <__brkval>
    30dc:	30 91 5d 03 	lds	r19, 0x035D	; 0x80035d <__brkval+0x1>
    30e0:	28 17       	cp	r18, r24
    30e2:	39 07       	cpc	r19, r25
    30e4:	51 f5       	brne	.+84     	; 0x313a <free+0x88>
    30e6:	f0 93 5d 03 	sts	0x035D, r31	; 0x80035d <__brkval+0x1>
    30ea:	e0 93 5c 03 	sts	0x035C, r30	; 0x80035c <__brkval>
    30ee:	67 c0       	rjmp	.+206    	; 0x31be <free+0x10c>
    30f0:	ed 01       	movw	r28, r26
    30f2:	20 e0       	ldi	r18, 0x00	; 0
    30f4:	30 e0       	ldi	r19, 0x00	; 0
    30f6:	ce 17       	cp	r28, r30
    30f8:	df 07       	cpc	r29, r31
    30fa:	40 f4       	brcc	.+16     	; 0x310c <free+0x5a>
    30fc:	4a 81       	ldd	r20, Y+2	; 0x02
    30fe:	5b 81       	ldd	r21, Y+3	; 0x03
    3100:	9e 01       	movw	r18, r28
    3102:	41 15       	cp	r20, r1
    3104:	51 05       	cpc	r21, r1
    3106:	f1 f0       	breq	.+60     	; 0x3144 <free+0x92>
    3108:	ea 01       	movw	r28, r20
    310a:	f5 cf       	rjmp	.-22     	; 0x30f6 <free+0x44>
    310c:	d3 83       	std	Z+3, r29	; 0x03
    310e:	c2 83       	std	Z+2, r28	; 0x02
    3110:	40 81       	ld	r20, Z
    3112:	51 81       	ldd	r21, Z+1	; 0x01
    3114:	84 0f       	add	r24, r20
    3116:	95 1f       	adc	r25, r21
    3118:	c8 17       	cp	r28, r24
    311a:	d9 07       	cpc	r29, r25
    311c:	59 f4       	brne	.+22     	; 0x3134 <free+0x82>
    311e:	88 81       	ld	r24, Y
    3120:	99 81       	ldd	r25, Y+1	; 0x01
    3122:	84 0f       	add	r24, r20
    3124:	95 1f       	adc	r25, r21
    3126:	02 96       	adiw	r24, 0x02	; 2
    3128:	91 83       	std	Z+1, r25	; 0x01
    312a:	80 83       	st	Z, r24
    312c:	8a 81       	ldd	r24, Y+2	; 0x02
    312e:	9b 81       	ldd	r25, Y+3	; 0x03
    3130:	93 83       	std	Z+3, r25	; 0x03
    3132:	82 83       	std	Z+2, r24	; 0x02
    3134:	21 15       	cp	r18, r1
    3136:	31 05       	cpc	r19, r1
    3138:	29 f4       	brne	.+10     	; 0x3144 <free+0x92>
    313a:	f0 93 5f 03 	sts	0x035F, r31	; 0x80035f <__flp+0x1>
    313e:	e0 93 5e 03 	sts	0x035E, r30	; 0x80035e <__flp>
    3142:	3d c0       	rjmp	.+122    	; 0x31be <free+0x10c>
    3144:	e9 01       	movw	r28, r18
    3146:	fb 83       	std	Y+3, r31	; 0x03
    3148:	ea 83       	std	Y+2, r30	; 0x02
    314a:	49 91       	ld	r20, Y+
    314c:	59 91       	ld	r21, Y+
    314e:	c4 0f       	add	r28, r20
    3150:	d5 1f       	adc	r29, r21
    3152:	ec 17       	cp	r30, r28
    3154:	fd 07       	cpc	r31, r29
    3156:	61 f4       	brne	.+24     	; 0x3170 <free+0xbe>
    3158:	80 81       	ld	r24, Z
    315a:	91 81       	ldd	r25, Z+1	; 0x01
    315c:	84 0f       	add	r24, r20
    315e:	95 1f       	adc	r25, r21
    3160:	02 96       	adiw	r24, 0x02	; 2
    3162:	e9 01       	movw	r28, r18
    3164:	99 83       	std	Y+1, r25	; 0x01
    3166:	88 83       	st	Y, r24
    3168:	82 81       	ldd	r24, Z+2	; 0x02
    316a:	93 81       	ldd	r25, Z+3	; 0x03
    316c:	9b 83       	std	Y+3, r25	; 0x03
    316e:	8a 83       	std	Y+2, r24	; 0x02
    3170:	e0 e0       	ldi	r30, 0x00	; 0
    3172:	f0 e0       	ldi	r31, 0x00	; 0
    3174:	12 96       	adiw	r26, 0x02	; 2
    3176:	8d 91       	ld	r24, X+
    3178:	9c 91       	ld	r25, X
    317a:	13 97       	sbiw	r26, 0x03	; 3
    317c:	00 97       	sbiw	r24, 0x00	; 0
    317e:	19 f0       	breq	.+6      	; 0x3186 <free+0xd4>
    3180:	fd 01       	movw	r30, r26
    3182:	dc 01       	movw	r26, r24
    3184:	f7 cf       	rjmp	.-18     	; 0x3174 <free+0xc2>
    3186:	8d 91       	ld	r24, X+
    3188:	9c 91       	ld	r25, X
    318a:	11 97       	sbiw	r26, 0x01	; 1
    318c:	9d 01       	movw	r18, r26
    318e:	2e 5f       	subi	r18, 0xFE	; 254
    3190:	3f 4f       	sbci	r19, 0xFF	; 255
    3192:	82 0f       	add	r24, r18
    3194:	93 1f       	adc	r25, r19
    3196:	20 91 5c 03 	lds	r18, 0x035C	; 0x80035c <__brkval>
    319a:	30 91 5d 03 	lds	r19, 0x035D	; 0x80035d <__brkval+0x1>
    319e:	28 17       	cp	r18, r24
    31a0:	39 07       	cpc	r19, r25
    31a2:	69 f4       	brne	.+26     	; 0x31be <free+0x10c>
    31a4:	30 97       	sbiw	r30, 0x00	; 0
    31a6:	29 f4       	brne	.+10     	; 0x31b2 <free+0x100>
    31a8:	10 92 5f 03 	sts	0x035F, r1	; 0x80035f <__flp+0x1>
    31ac:	10 92 5e 03 	sts	0x035E, r1	; 0x80035e <__flp>
    31b0:	02 c0       	rjmp	.+4      	; 0x31b6 <free+0x104>
    31b2:	13 82       	std	Z+3, r1	; 0x03
    31b4:	12 82       	std	Z+2, r1	; 0x02
    31b6:	b0 93 5d 03 	sts	0x035D, r27	; 0x80035d <__brkval+0x1>
    31ba:	a0 93 5c 03 	sts	0x035C, r26	; 0x80035c <__brkval>
    31be:	df 91       	pop	r29
    31c0:	cf 91       	pop	r28
    31c2:	08 95       	ret

000031c4 <memcpy>:
    31c4:	fb 01       	movw	r30, r22
    31c6:	dc 01       	movw	r26, r24
    31c8:	02 c0       	rjmp	.+4      	; 0x31ce <memcpy+0xa>
    31ca:	01 90       	ld	r0, Z+
    31cc:	0d 92       	st	X+, r0
    31ce:	41 50       	subi	r20, 0x01	; 1
    31d0:	50 40       	sbci	r21, 0x00	; 0
    31d2:	d8 f7       	brcc	.-10     	; 0x31ca <memcpy+0x6>
    31d4:	08 95       	ret

000031d6 <memset>:
    31d6:	dc 01       	movw	r26, r24
    31d8:	01 c0       	rjmp	.+2      	; 0x31dc <memset+0x6>
    31da:	6d 93       	st	X+, r22
    31dc:	41 50       	subi	r20, 0x01	; 1
    31de:	50 40       	sbci	r21, 0x00	; 0
    31e0:	e0 f7       	brcc	.-8      	; 0x31da <memset+0x4>
    31e2:	08 95       	ret

000031e4 <__do_global_dtors>:
    31e4:	10 e0       	ldi	r17, 0x00	; 0
    31e6:	c3 e7       	ldi	r28, 0x73	; 115
    31e8:	d0 e0       	ldi	r29, 0x00	; 0
    31ea:	04 c0       	rjmp	.+8      	; 0x31f4 <__do_global_dtors+0x10>
    31ec:	fe 01       	movw	r30, r28
    31ee:	0e 94 8d 17 	call	0x2f1a	; 0x2f1a <__tablejump2__>
    31f2:	21 96       	adiw	r28, 0x01	; 1
    31f4:	c4 37       	cpi	r28, 0x74	; 116
    31f6:	d1 07       	cpc	r29, r17
    31f8:	c9 f7       	brne	.-14     	; 0x31ec <__do_global_dtors+0x8>
    31fa:	f8 94       	cli

000031fc <__stop_program>:
    31fc:	ff cf       	rjmp	.-2      	; 0x31fc <__stop_program>
