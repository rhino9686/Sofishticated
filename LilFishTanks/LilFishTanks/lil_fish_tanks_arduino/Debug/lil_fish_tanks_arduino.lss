
lil_fish_tanks_arduino.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000126  00800100  00004aaa  00004b3e  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00004aaa  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          000002cb  00800226  00800226  00004c64  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00004c64  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00004c94  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 000009c0  00000000  00000000  00004cd4  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00013afe  00000000  00000000  00005694  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00003c68  00000000  00000000  00019192  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00006839  00000000  00000000  0001cdfa  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00001dec  00000000  00000000  00023634  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00004a42  00000000  00000000  00025420  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    0000b3df  00000000  00000000  00029e62  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000938  00000000  00000000  00035241  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 89 00 	jmp	0x112	; 0x112 <__dtors_end>
       4:	0c 94 28 20 	jmp	0x4050	; 0x4050 <__vector_1>
       8:	0c 94 4f 20 	jmp	0x409e	; 0x409e <__vector_2>
       c:	0c 94 26 19 	jmp	0x324c	; 0x324c <__vector_3>
      10:	0c 94 26 19 	jmp	0x324c	; 0x324c <__vector_3>
      14:	0c 94 26 19 	jmp	0x324c	; 0x324c <__vector_3>
      18:	0c 94 49 0b 	jmp	0x1692	; 0x1692 <__vector_6>
      1c:	0c 94 17 23 	jmp	0x462e	; 0x462e <__vector_7>
      20:	0c 94 b1 00 	jmp	0x162	; 0x162 <__bad_interrupt>
      24:	0c 94 b1 00 	jmp	0x162	; 0x162 <__bad_interrupt>
      28:	0c 94 b1 00 	jmp	0x162	; 0x162 <__bad_interrupt>
      2c:	0c 94 b1 00 	jmp	0x162	; 0x162 <__bad_interrupt>
      30:	0c 94 b1 00 	jmp	0x162	; 0x162 <__bad_interrupt>
      34:	0c 94 b1 00 	jmp	0x162	; 0x162 <__bad_interrupt>
      38:	0c 94 b1 00 	jmp	0x162	; 0x162 <__bad_interrupt>
      3c:	0c 94 b1 00 	jmp	0x162	; 0x162 <__bad_interrupt>
      40:	0c 94 76 20 	jmp	0x40ec	; 0x40ec <__vector_16>
      44:	0c 94 b1 00 	jmp	0x162	; 0x162 <__bad_interrupt>
      48:	0c 94 2c 1e 	jmp	0x3c58	; 0x3c58 <__vector_18>
      4c:	0c 94 5e 1e 	jmp	0x3cbc	; 0x3cbc <__vector_19>
      50:	0c 94 b1 00 	jmp	0x162	; 0x162 <__bad_interrupt>
      54:	0c 94 b1 00 	jmp	0x162	; 0x162 <__bad_interrupt>
      58:	0c 94 b1 00 	jmp	0x162	; 0x162 <__bad_interrupt>
      5c:	0c 94 b1 00 	jmp	0x162	; 0x162 <__bad_interrupt>
      60:	0c 94 b1 00 	jmp	0x162	; 0x162 <__bad_interrupt>
      64:	0c 94 b1 00 	jmp	0x162	; 0x162 <__bad_interrupt>
      68:	30 16       	cp	r3, r16
      6a:	30 16       	cp	r3, r16
      6c:	30 16       	cp	r3, r16
      6e:	6f 16       	cp	r6, r31
      70:	5a 16       	cp	r5, r26
      72:	69 16       	cp	r6, r25
      74:	30 16       	cp	r3, r16
      76:	30 16       	cp	r3, r16
      78:	6f 16       	cp	r6, r31
      7a:	5a 16       	cp	r5, r26

0000007c <__trampolines_end>:
      7c:	0a 46       	sbci	r16, 0x6A	; 106
      7e:	6f 75       	andi	r22, 0x5F	; 95
      80:	6e 64       	ori	r22, 0x4E	; 78
      82:	20 4d       	sbci	r18, 0xD0	; 208
      84:	61 74       	andi	r22, 0x41	; 65
      86:	63 68       	ori	r22, 0x83	; 131
      88:	69 6e       	ori	r22, 0xE9	; 233
      8a:	67 20       	and	r6, r7
      8c:	43 6f       	ori	r20, 0xF3	; 243
      8e:	6c 6f       	ori	r22, 0xFC	; 252
      90:	72 00       	.word	0x0072	; ????

00000092 <_ZL15dscrc2x16_table>:
      92:	00 5e bc e2 61 3f dd 83 c2 9c 7e 20 a3 fd 1f 41     .^..a?....~ ...A
      a2:	00 9d 23 be 46 db 65 f8 8c 11 af 32 ca 57 e9 74     ..#.F.e....2.W.t

000000b2 <digital_pin_to_timer_PGM>:
      b2:	00 00 00 08 00 02 01 00 00 03 04 07 00 00 00 00     ................
      c2:	00 00 00 00                                         ....

000000c6 <digital_pin_to_bit_mask_PGM>:
      c6:	01 02 04 08 10 20 40 80 01 02 04 08 10 20 01 02     ..... @...... ..
      d6:	04 08 10 20                                         ... 

000000da <digital_pin_to_port_PGM>:
      da:	04 04 04 04 04 04 04 04 02 02 02 02 02 02 03 03     ................
      ea:	03 03 03 03                                         ....

000000ee <port_to_input_PGM>:
      ee:	00 00 00 00 23 00 26 00 29 00                       ....#.&.).

000000f8 <port_to_output_PGM>:
      f8:	00 00 00 00 25 00 28 00 2b 00                       ....%.(.+.

00000102 <port_to_mode_PGM>:
     102:	00 00 00 00 24 00 27 00 2a 00                       ....$.'.*.

0000010c <__ctors_start>:
     10c:	39 06       	cpc	r3, r25
     10e:	8e 1e       	adc	r8, r30

00000110 <__ctors_end>:
     110:	4c 06       	cpc	r4, r28

00000112 <__dtors_end>:
     112:	11 24       	eor	r1, r1
     114:	1f be       	out	0x3f, r1	; 63
     116:	cf ef       	ldi	r28, 0xFF	; 255
     118:	d8 e0       	ldi	r29, 0x08	; 8
     11a:	de bf       	out	0x3e, r29	; 62
     11c:	cd bf       	out	0x3d, r28	; 61

0000011e <__do_copy_data>:
     11e:	12 e0       	ldi	r17, 0x02	; 2
     120:	a0 e0       	ldi	r26, 0x00	; 0
     122:	b1 e0       	ldi	r27, 0x01	; 1
     124:	ea ea       	ldi	r30, 0xAA	; 170
     126:	fa e4       	ldi	r31, 0x4A	; 74
     128:	02 c0       	rjmp	.+4      	; 0x12e <__do_copy_data+0x10>
     12a:	05 90       	lpm	r0, Z+
     12c:	0d 92       	st	X+, r0
     12e:	a6 32       	cpi	r26, 0x26	; 38
     130:	b1 07       	cpc	r27, r17
     132:	d9 f7       	brne	.-10     	; 0x12a <__do_copy_data+0xc>

00000134 <__do_clear_bss>:
     134:	24 e0       	ldi	r18, 0x04	; 4
     136:	a6 e2       	ldi	r26, 0x26	; 38
     138:	b2 e0       	ldi	r27, 0x02	; 2
     13a:	01 c0       	rjmp	.+2      	; 0x13e <.do_clear_bss_start>

0000013c <.do_clear_bss_loop>:
     13c:	1d 92       	st	X+, r1

0000013e <.do_clear_bss_start>:
     13e:	a1 3f       	cpi	r26, 0xF1	; 241
     140:	b2 07       	cpc	r27, r18
     142:	e1 f7       	brne	.-8      	; 0x13c <.do_clear_bss_loop>

00000144 <__do_global_ctors>:
     144:	10 e0       	ldi	r17, 0x00	; 0
     146:	c8 e8       	ldi	r28, 0x88	; 136
     148:	d0 e0       	ldi	r29, 0x00	; 0
     14a:	04 c0       	rjmp	.+8      	; 0x154 <__do_global_ctors+0x10>
     14c:	21 97       	sbiw	r28, 0x01	; 1
     14e:	fe 01       	movw	r30, r28
     150:	0e 94 e3 23 	call	0x47c6	; 0x47c6 <__tablejump2__>
     154:	c6 38       	cpi	r28, 0x86	; 134
     156:	d1 07       	cpc	r29, r17
     158:	c9 f7       	brne	.-14     	; 0x14c <__do_global_ctors+0x8>
     15a:	0e 94 bb 1e 	call	0x3d76	; 0x3d76 <main>
     15e:	0c 94 48 25 	jmp	0x4a90	; 0x4a90 <__do_global_dtors>

00000162 <__bad_interrupt>:
     162:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000166 <_ZN5Print5writeEPKc>:
    int getWriteError() { return write_error; }
    void clearWriteError() { setWriteError(0); }
  
    virtual size_t write(uint8_t) = 0;
    size_t write(const char *str) {
      if (str == NULL) return 0;
     166:	61 15       	cp	r22, r1
     168:	71 05       	cpc	r23, r1
     16a:	79 f0       	breq	.+30     	; 0x18a <_ZN5Print5writeEPKc+0x24>
      return write((const uint8_t *)str, strlen(str));
     16c:	fb 01       	movw	r30, r22
     16e:	01 90       	ld	r0, Z+
     170:	00 20       	and	r0, r0
     172:	e9 f7       	brne	.-6      	; 0x16e <_ZN5Print5writeEPKc+0x8>
     174:	31 97       	sbiw	r30, 0x01	; 1
     176:	af 01       	movw	r20, r30
     178:	46 1b       	sub	r20, r22
     17a:	57 0b       	sbc	r21, r23
     17c:	dc 01       	movw	r26, r24
     17e:	ed 91       	ld	r30, X+
     180:	fc 91       	ld	r31, X
     182:	02 80       	ldd	r0, Z+2	; 0x02
     184:	f3 81       	ldd	r31, Z+3	; 0x03
     186:	e0 2d       	mov	r30, r0
     188:	09 94       	ijmp
    }
     18a:	80 e0       	ldi	r24, 0x00	; 0
     18c:	90 e0       	ldi	r25, 0x00	; 0
     18e:	08 95       	ret

00000190 <_Z11measureTempv>:

OneWire ds(TEMP_PIN); // Temp sensor on pin 7


/* measureTemp() returns the measured temperature in degrees Celsius */
float measureTemp() {
     190:	ef 92       	push	r14
     192:	ff 92       	push	r15
     194:	0f 93       	push	r16
     196:	1f 93       	push	r17
     198:	cf 93       	push	r28
     19a:	df 93       	push	r29
     19c:	cd b7       	in	r28, 0x3d	; 61
     19e:	de b7       	in	r29, 0x3e	; 62
     1a0:	64 97       	sbiw	r28, 0x14	; 20
     1a2:	0f b6       	in	r0, 0x3f	; 63
     1a4:	f8 94       	cli
     1a6:	de bf       	out	0x3e, r29	; 62
     1a8:	0f be       	out	0x3f, r0	; 63
     1aa:	cd bf       	out	0x3d, r28	; 61
	//byte type_s;
	byte data[12];
	byte addr[8];
	float celsius; //, fahrenheit;
	
	ds.reset_search();
     1ac:	8e e5       	ldi	r24, 0x5E	; 94
     1ae:	93 e0       	ldi	r25, 0x03	; 3
     1b0:	0e 94 17 08 	call	0x102e	; 0x102e <_ZN7OneWire12reset_searchEv>
	delay(250);
     1b4:	6a ef       	ldi	r22, 0xFA	; 250
     1b6:	70 e0       	ldi	r23, 0x00	; 0
     1b8:	80 e0       	ldi	r24, 0x00	; 0
     1ba:	90 e0       	ldi	r25, 0x00	; 0
     1bc:	0e 94 e5 20 	call	0x41ca	; 0x41ca <delay>
	ds.search(addr);
     1c0:	41 e0       	ldi	r20, 0x01	; 1
     1c2:	be 01       	movw	r22, r28
     1c4:	63 5f       	subi	r22, 0xF3	; 243
     1c6:	7f 4f       	sbci	r23, 0xFF	; 255
     1c8:	8e e5       	ldi	r24, 0x5E	; 94
     1ca:	93 e0       	ldi	r25, 0x03	; 3
     1cc:	0e 94 46 08 	call	0x108c	; 0x108c <_ZN7OneWire6searchEPhb>

	if (OneWire::crc8(addr, 7) != addr[7]) {
     1d0:	67 e0       	ldi	r22, 0x07	; 7
     1d2:	ce 01       	movw	r24, r28
     1d4:	0d 96       	adiw	r24, 0x0d	; 13
     1d6:	0e 94 cd 08 	call	0x119a	; 0x119a <_ZN7OneWire4crc8EPKhh>
     1da:	9c 89       	ldd	r25, Y+20	; 0x14
     1dc:	89 17       	cp	r24, r25
     1de:	59 f0       	breq	.+22     	; 0x1f6 <_Z11measureTempv+0x66>
		Serial.println("CRC is not valid!");
     1e0:	60 e4       	ldi	r22, 0x40	; 64
     1e2:	71 e0       	ldi	r23, 0x01	; 1
     1e4:	83 e3       	ldi	r24, 0x33	; 51
     1e6:	94 e0       	ldi	r25, 0x04	; 4
     1e8:	0e 94 25 1f 	call	0x3e4a	; 0x3e4a <_ZN5Print7printlnEPKc>
		return -1;
     1ec:	60 e0       	ldi	r22, 0x00	; 0
     1ee:	70 e0       	ldi	r23, 0x00	; 0
     1f0:	80 e8       	ldi	r24, 0x80	; 128
     1f2:	9f eb       	ldi	r25, 0xBF	; 191
     1f4:	43 c0       	rjmp	.+134    	; 0x27c <_Z11measureTempv+0xec>
		default:
		Serial.println("Device is not a DS18x20 family device.");
		return -1;
	} */

	ds.reset();
     1f6:	8e e5       	ldi	r24, 0x5E	; 94
     1f8:	93 e0       	ldi	r25, 0x03	; 3
     1fa:	0e 94 0b 07 	call	0xe16	; 0xe16 <_ZN7OneWire5resetEv>
	ds.select(addr);
     1fe:	be 01       	movw	r22, r28
     200:	63 5f       	subi	r22, 0xF3	; 243
     202:	7f 4f       	sbci	r23, 0xFF	; 255
     204:	8e e5       	ldi	r24, 0x5E	; 94
     206:	93 e0       	ldi	r25, 0x03	; 3
     208:	0e 94 f8 07 	call	0xff0	; 0xff0 <_ZN7OneWire6selectEPKh>
	ds.write(0x44, 1);        // start conversion, with parasite power on at the end
     20c:	41 e0       	ldi	r20, 0x01	; 1
     20e:	64 e4       	ldi	r22, 0x44	; 68
     210:	8e e5       	ldi	r24, 0x5E	; 94
     212:	93 e0       	ldi	r25, 0x03	; 3
     214:	0e 94 a8 07 	call	0xf50	; 0xf50 <_ZN7OneWire5writeEhh>
	
	delay(1000);     // maybe 750ms is enough, maybe not
     218:	68 ee       	ldi	r22, 0xE8	; 232
     21a:	73 e0       	ldi	r23, 0x03	; 3
     21c:	80 e0       	ldi	r24, 0x00	; 0
     21e:	90 e0       	ldi	r25, 0x00	; 0
     220:	0e 94 e5 20 	call	0x41ca	; 0x41ca <delay>
	// we might do a ds.depower() here, but the reset will take care of it.
	
	//present = ds.reset();
	ds.select(addr);
     224:	be 01       	movw	r22, r28
     226:	63 5f       	subi	r22, 0xF3	; 243
     228:	7f 4f       	sbci	r23, 0xFF	; 255
     22a:	8e e5       	ldi	r24, 0x5E	; 94
     22c:	93 e0       	ldi	r25, 0x03	; 3
     22e:	0e 94 f8 07 	call	0xff0	; 0xff0 <_ZN7OneWire6selectEPKh>
	ds.write(0xBE);         // Read Scratchpad
     232:	40 e0       	ldi	r20, 0x00	; 0
     234:	6e eb       	ldi	r22, 0xBE	; 190
     236:	8e e5       	ldi	r24, 0x5E	; 94
     238:	93 e0       	ldi	r25, 0x03	; 3
     23a:	0e 94 a8 07 	call	0xf50	; 0xf50 <_ZN7OneWire5writeEhh>
     23e:	8e 01       	movw	r16, r28
     240:	0f 5f       	subi	r16, 0xFF	; 255
     242:	1f 4f       	sbci	r17, 0xFF	; 255
     244:	7e 01       	movw	r14, r28
     246:	8a e0       	ldi	r24, 0x0A	; 10
     248:	e8 0e       	add	r14, r24
     24a:	f1 1c       	adc	r15, r1

	//Serial.print("  Data = ");
	//Serial.print(present, HEX);
	//Serial.print(" ");
	for ( i = 0; i < 9; i++) {           // we need 9 bytes
		data[i] = ds.read();
     24c:	8e e5       	ldi	r24, 0x5E	; 94
     24e:	93 e0       	ldi	r25, 0x03	; 3
     250:	0e 94 dc 07 	call	0xfb8	; 0xfb8 <_ZN7OneWire4readEv>
     254:	f8 01       	movw	r30, r16
     256:	81 93       	st	Z+, r24
     258:	8f 01       	movw	r16, r30
	ds.write(0xBE);         // Read Scratchpad

	//Serial.print("  Data = ");
	//Serial.print(present, HEX);
	//Serial.print(" ");
	for ( i = 0; i < 9; i++) {           // we need 9 bytes
     25a:	ee 16       	cp	r14, r30
     25c:	ff 06       	cpc	r15, r31
     25e:	b1 f7       	brne	.-20     	; 0x24c <_Z11measureTempv+0xbc>
		else if (cfg == 0x40) raw = raw & ~1; // 11 bit res, 375 ms
		//// default is 12 bit resolution, 750 ms conversion time
	}
	*/
	
	celsius = (float)((data[1] << 8) | data[0]) / 16.0;
     260:	69 81       	ldd	r22, Y+1	; 0x01
     262:	7a 81       	ldd	r23, Y+2	; 0x02
     264:	07 2e       	mov	r0, r23
     266:	00 0c       	add	r0, r0
     268:	88 0b       	sbc	r24, r24
     26a:	99 0b       	sbc	r25, r25
     26c:	0e 94 ce 1b 	call	0x379c	; 0x379c <__floatsisf>
     270:	20 e0       	ldi	r18, 0x00	; 0
     272:	30 e0       	ldi	r19, 0x00	; 0
     274:	40 e8       	ldi	r20, 0x80	; 128
     276:	5d e3       	ldi	r21, 0x3D	; 61
     278:	0e 94 7e 1c 	call	0x38fc	; 0x38fc <__mulsf3>
	//Serial.print(celsius);
	//Serial.print(" Celsius, ");
	//Serial.print(fahrenheit);
	//Serial.println(" Fahrenheit");
	return celsius;
     27c:	64 96       	adiw	r28, 0x14	; 20
     27e:	0f b6       	in	r0, 0x3f	; 63
     280:	f8 94       	cli
     282:	de bf       	out	0x3e, r29	; 62
     284:	0f be       	out	0x3f, r0	; 63
     286:	cd bf       	out	0x3d, r28	; 61
     288:	df 91       	pop	r29
     28a:	cf 91       	pop	r28
     28c:	1f 91       	pop	r17
     28e:	0f 91       	pop	r16
     290:	ff 90       	pop	r15
     292:	ef 90       	pop	r14
     294:	08 95       	ret

00000296 <_Z9addColorsv>:
MD_TCS230  CS(S2, S3, OE);


// add possible color strip values to specific arrays
void addColors()
{
     296:	0f 93       	push	r16
     298:	1f 93       	push	r17
     29a:	cf 93       	push	r28
     29c:	df 93       	push	r29
	int index = 0;
	Color c;
	c.ppm = 0.0;
	c.p = {55, 55, 80};
	Ammonia[index] = c;
     29e:	cb e2       	ldi	r28, 0x2B	; 43
     2a0:	d3 e0       	ldi	r29, 0x03	; 3
     2a2:	18 82       	st	Y, r1
     2a4:	19 82       	std	Y+1, r1	; 0x01
     2a6:	1a 82       	std	Y+2, r1	; 0x02
     2a8:	1b 82       	std	Y+3, r1	; 0x03
     2aa:	87 e3       	ldi	r24, 0x37	; 55
     2ac:	90 e0       	ldi	r25, 0x00	; 0
     2ae:	9d 83       	std	Y+5, r25	; 0x05
     2b0:	8c 83       	std	Y+4, r24	; 0x04
     2b2:	9f 83       	std	Y+7, r25	; 0x07
     2b4:	8e 83       	std	Y+6, r24	; 0x06
     2b6:	80 e5       	ldi	r24, 0x50	; 80
     2b8:	90 e0       	ldi	r25, 0x00	; 0
     2ba:	99 87       	std	Y+9, r25	; 0x09
     2bc:	88 87       	std	Y+8, r24	; 0x08

	c.ppm = 0.0;
	c.p = {65, 65, 110};
	Nitrite[index] = c;
     2be:	a5 ee       	ldi	r26, 0xE5	; 229
     2c0:	b2 e0       	ldi	r27, 0x02	; 2
     2c2:	1d 92       	st	X+, r1
     2c4:	1d 92       	st	X+, r1
     2c6:	1d 92       	st	X+, r1
     2c8:	1c 92       	st	X, r1
     2ca:	13 97       	sbiw	r26, 0x03	; 3
     2cc:	81 e4       	ldi	r24, 0x41	; 65
     2ce:	90 e0       	ldi	r25, 0x00	; 0
     2d0:	15 96       	adiw	r26, 0x05	; 5
     2d2:	9c 93       	st	X, r25
     2d4:	8e 93       	st	-X, r24
     2d6:	14 97       	sbiw	r26, 0x04	; 4
     2d8:	17 96       	adiw	r26, 0x07	; 7
     2da:	9c 93       	st	X, r25
     2dc:	8e 93       	st	-X, r24
     2de:	16 97       	sbiw	r26, 0x06	; 6
     2e0:	8e e6       	ldi	r24, 0x6E	; 110
     2e2:	90 e0       	ldi	r25, 0x00	; 0
     2e4:	19 96       	adiw	r26, 0x09	; 9
     2e6:	9c 93       	st	X, r25
     2e8:	8e 93       	st	-X, r24
     2ea:	18 97       	sbiw	r26, 0x08	; 8

	c.ppm = 0.0;
	c.p = {49, 50, 90};
	Nitrate[index] = c;
     2ec:	ef e9       	ldi	r30, 0x9F	; 159
     2ee:	f2 e0       	ldi	r31, 0x02	; 2
     2f0:	10 82       	st	Z, r1
     2f2:	11 82       	std	Z+1, r1	; 0x01
     2f4:	12 82       	std	Z+2, r1	; 0x02
     2f6:	13 82       	std	Z+3, r1	; 0x03
     2f8:	81 e3       	ldi	r24, 0x31	; 49
     2fa:	90 e0       	ldi	r25, 0x00	; 0
     2fc:	95 83       	std	Z+5, r25	; 0x05
     2fe:	84 83       	std	Z+4, r24	; 0x04
     300:	82 e3       	ldi	r24, 0x32	; 50
     302:	90 e0       	ldi	r25, 0x00	; 0
     304:	97 83       	std	Z+7, r25	; 0x07
     306:	86 83       	std	Z+6, r24	; 0x06
     308:	8a e5       	ldi	r24, 0x5A	; 90
     30a:	90 e0       	ldi	r25, 0x00	; 0
     30c:	91 87       	std	Z+9, r25	; 0x09
     30e:	80 87       	std	Z+8, r24	; 0x08

	++index;

	c.ppm = 0.5;
	c.p = {0, 0, 0};
	Ammonia[index] = c;
     310:	40 e0       	ldi	r20, 0x00	; 0
     312:	50 e0       	ldi	r21, 0x00	; 0
     314:	60 e0       	ldi	r22, 0x00	; 0
     316:	7f e3       	ldi	r23, 0x3F	; 63
     318:	4a 87       	std	Y+10, r20	; 0x0a
     31a:	5b 87       	std	Y+11, r21	; 0x0b
     31c:	6c 87       	std	Y+12, r22	; 0x0c
     31e:	7d 87       	std	Y+13, r23	; 0x0d
     320:	1f 86       	std	Y+15, r1	; 0x0f
     322:	1e 86       	std	Y+14, r1	; 0x0e
     324:	19 8a       	std	Y+17, r1	; 0x11
     326:	18 8a       	std	Y+16, r1	; 0x10
     328:	1b 8a       	std	Y+19, r1	; 0x13
     32a:	1a 8a       	std	Y+18, r1	; 0x12

	c.ppm = 0.15;
	c.p = {0, 0, 0};
	Nitrite[index] = c;
     32c:	0a e9       	ldi	r16, 0x9A	; 154
     32e:	19 e9       	ldi	r17, 0x99	; 153
     330:	29 e1       	ldi	r18, 0x19	; 25
     332:	3e e3       	ldi	r19, 0x3E	; 62
     334:	1a 96       	adiw	r26, 0x0a	; 10
     336:	0d 93       	st	X+, r16
     338:	1d 93       	st	X+, r17
     33a:	2d 93       	st	X+, r18
     33c:	3c 93       	st	X, r19
     33e:	1d 97       	sbiw	r26, 0x0d	; 13
     340:	1f 96       	adiw	r26, 0x0f	; 15
     342:	1c 92       	st	X, r1
     344:	1e 92       	st	-X, r1
     346:	1e 97       	sbiw	r26, 0x0e	; 14
     348:	51 96       	adiw	r26, 0x11	; 17
     34a:	1c 92       	st	X, r1
     34c:	1e 92       	st	-X, r1
     34e:	50 97       	sbiw	r26, 0x10	; 16
     350:	53 96       	adiw	r26, 0x13	; 19
     352:	1c 92       	st	X, r1
     354:	1e 92       	st	-X, r1
     356:	52 97       	sbiw	r26, 0x12	; 18

	c.ppm = 0.5;
	c.p = {0, 0, 0};
	Nitrate[index] = c;
     358:	42 87       	std	Z+10, r20	; 0x0a
     35a:	53 87       	std	Z+11, r21	; 0x0b
     35c:	64 87       	std	Z+12, r22	; 0x0c
     35e:	75 87       	std	Z+13, r23	; 0x0d
     360:	17 86       	std	Z+15, r1	; 0x0f
     362:	16 86       	std	Z+14, r1	; 0x0e
     364:	11 8a       	std	Z+17, r1	; 0x11
     366:	10 8a       	std	Z+16, r1	; 0x10
     368:	13 8a       	std	Z+19, r1	; 0x13
     36a:	12 8a       	std	Z+18, r1	; 0x12

	++index;

	c.ppm = 1.0;
	c.p = {57, 58, 85};
	Ammonia[index] = c;
     36c:	40 e0       	ldi	r20, 0x00	; 0
     36e:	50 e0       	ldi	r21, 0x00	; 0
     370:	60 e8       	ldi	r22, 0x80	; 128
     372:	7f e3       	ldi	r23, 0x3F	; 63
     374:	4c 8b       	std	Y+20, r20	; 0x14
     376:	5d 8b       	std	Y+21, r21	; 0x15
     378:	6e 8b       	std	Y+22, r22	; 0x16
     37a:	7f 8b       	std	Y+23, r23	; 0x17
     37c:	89 e3       	ldi	r24, 0x39	; 57
     37e:	90 e0       	ldi	r25, 0x00	; 0
     380:	99 8f       	std	Y+25, r25	; 0x19
     382:	88 8f       	std	Y+24, r24	; 0x18
     384:	8a e3       	ldi	r24, 0x3A	; 58
     386:	90 e0       	ldi	r25, 0x00	; 0
     388:	9b 8f       	std	Y+27, r25	; 0x1b
     38a:	8a 8f       	std	Y+26, r24	; 0x1a
     38c:	85 e5       	ldi	r24, 0x55	; 85
     38e:	90 e0       	ldi	r25, 0x00	; 0
     390:	9d 8f       	std	Y+29, r25	; 0x1d
     392:	8c 8f       	std	Y+28, r24	; 0x1c

	c.ppm = 0.3;
	c.p = {0, 0, 0};
	Nitrite[index] = c;
     394:	0a e9       	ldi	r16, 0x9A	; 154
     396:	19 e9       	ldi	r17, 0x99	; 153
     398:	29 e9       	ldi	r18, 0x99	; 153
     39a:	3e e3       	ldi	r19, 0x3E	; 62
     39c:	54 96       	adiw	r26, 0x14	; 20
     39e:	0d 93       	st	X+, r16
     3a0:	1d 93       	st	X+, r17
     3a2:	2d 93       	st	X+, r18
     3a4:	3c 93       	st	X, r19
     3a6:	57 97       	sbiw	r26, 0x17	; 23
     3a8:	59 96       	adiw	r26, 0x19	; 25
     3aa:	1c 92       	st	X, r1
     3ac:	1e 92       	st	-X, r1
     3ae:	58 97       	sbiw	r26, 0x18	; 24
     3b0:	5b 96       	adiw	r26, 0x1b	; 27
     3b2:	1c 92       	st	X, r1
     3b4:	1e 92       	st	-X, r1
     3b6:	5a 97       	sbiw	r26, 0x1a	; 26
     3b8:	5d 96       	adiw	r26, 0x1d	; 29
     3ba:	1c 92       	st	X, r1
     3bc:	1e 92       	st	-X, r1
     3be:	5c 97       	sbiw	r26, 0x1c	; 28

	c.ppm = 2.0;
	c.p = {0, 0, 0};
	Nitrate[index] = c;
     3c0:	00 e0       	ldi	r16, 0x00	; 0
     3c2:	10 e0       	ldi	r17, 0x00	; 0
     3c4:	20 e0       	ldi	r18, 0x00	; 0
     3c6:	30 e4       	ldi	r19, 0x40	; 64
     3c8:	04 8b       	std	Z+20, r16	; 0x14
     3ca:	15 8b       	std	Z+21, r17	; 0x15
     3cc:	26 8b       	std	Z+22, r18	; 0x16
     3ce:	37 8b       	std	Z+23, r19	; 0x17
     3d0:	11 8e       	std	Z+25, r1	; 0x19
     3d2:	10 8e       	std	Z+24, r1	; 0x18
     3d4:	13 8e       	std	Z+27, r1	; 0x1b
     3d6:	12 8e       	std	Z+26, r1	; 0x1a
     3d8:	15 8e       	std	Z+29, r1	; 0x1d
     3da:	14 8e       	std	Z+28, r1	; 0x1c

	++index;

	c.ppm = 3.0;
	c.p = {0, 0, 0};
	Ammonia[index] = c;
     3dc:	00 e0       	ldi	r16, 0x00	; 0
     3de:	10 e0       	ldi	r17, 0x00	; 0
     3e0:	20 e4       	ldi	r18, 0x40	; 64
     3e2:	30 e4       	ldi	r19, 0x40	; 64
     3e4:	0e 8f       	std	Y+30, r16	; 0x1e
     3e6:	1f 8f       	std	Y+31, r17	; 0x1f
     3e8:	28 a3       	std	Y+32, r18	; 0x20
     3ea:	39 a3       	std	Y+33, r19	; 0x21
     3ec:	1b a2       	std	Y+35, r1	; 0x23
     3ee:	1a a2       	std	Y+34, r1	; 0x22
     3f0:	1d a2       	std	Y+37, r1	; 0x25
     3f2:	1c a2       	std	Y+36, r1	; 0x24
     3f4:	1f a2       	std	Y+39, r1	; 0x27
     3f6:	1e a2       	std	Y+38, r1	; 0x26

	c.ppm = 1.0;
	c.p = {0, 0, 0};
	Nitrite[index] = c;
     3f8:	5e 96       	adiw	r26, 0x1e	; 30
     3fa:	4d 93       	st	X+, r20
     3fc:	5d 93       	st	X+, r21
     3fe:	6d 93       	st	X+, r22
     400:	7c 93       	st	X, r23
     402:	91 97       	sbiw	r26, 0x21	; 33
     404:	93 96       	adiw	r26, 0x23	; 35
     406:	1c 92       	st	X, r1
     408:	1e 92       	st	-X, r1
     40a:	92 97       	sbiw	r26, 0x22	; 34
     40c:	95 96       	adiw	r26, 0x25	; 37
     40e:	1c 92       	st	X, r1
     410:	1e 92       	st	-X, r1
     412:	94 97       	sbiw	r26, 0x24	; 36
     414:	97 96       	adiw	r26, 0x27	; 39
     416:	1c 92       	st	X, r1
     418:	1e 92       	st	-X, r1
     41a:	96 97       	sbiw	r26, 0x26	; 38

	c.ppm = 5.0;
	c.p = {0, 0, 0};
	Nitrate[index] = c;
     41c:	40 e0       	ldi	r20, 0x00	; 0
     41e:	50 e0       	ldi	r21, 0x00	; 0
     420:	60 ea       	ldi	r22, 0xA0	; 160
     422:	70 e4       	ldi	r23, 0x40	; 64
     424:	46 8f       	std	Z+30, r20	; 0x1e
     426:	57 8f       	std	Z+31, r21	; 0x1f
     428:	60 a3       	std	Z+32, r22	; 0x20
     42a:	71 a3       	std	Z+33, r23	; 0x21
     42c:	13 a2       	std	Z+35, r1	; 0x23
     42e:	12 a2       	std	Z+34, r1	; 0x22
     430:	15 a2       	std	Z+37, r1	; 0x25
     432:	14 a2       	std	Z+36, r1	; 0x24
     434:	17 a2       	std	Z+39, r1	; 0x27
     436:	16 a2       	std	Z+38, r1	; 0x26

	++index;

	c.ppm = 6.0;
	c.p = {0, 0, 0};
	Ammonia[index] = c;
     438:	40 e0       	ldi	r20, 0x00	; 0
     43a:	50 e0       	ldi	r21, 0x00	; 0
     43c:	60 ec       	ldi	r22, 0xC0	; 192
     43e:	70 e4       	ldi	r23, 0x40	; 64
     440:	48 a7       	std	Y+40, r20	; 0x28
     442:	59 a7       	std	Y+41, r21	; 0x29
     444:	6a a7       	std	Y+42, r22	; 0x2a
     446:	7b a7       	std	Y+43, r23	; 0x2b
     448:	1d a6       	std	Y+45, r1	; 0x2d
     44a:	1c a6       	std	Y+44, r1	; 0x2c
     44c:	1f a6       	std	Y+47, r1	; 0x2f
     44e:	1e a6       	std	Y+46, r1	; 0x2e
     450:	19 aa       	std	Y+49, r1	; 0x31
     452:	18 aa       	std	Y+48, r1	; 0x30

	c.ppm = 1.5;
	c.p = {0, 0, 0};
	Nitrite[index] = c;
     454:	40 e0       	ldi	r20, 0x00	; 0
     456:	50 e0       	ldi	r21, 0x00	; 0
     458:	60 ec       	ldi	r22, 0xC0	; 192
     45a:	7f e3       	ldi	r23, 0x3F	; 63
     45c:	98 96       	adiw	r26, 0x28	; 40
     45e:	4d 93       	st	X+, r20
     460:	5d 93       	st	X+, r21
     462:	6d 93       	st	X+, r22
     464:	7c 93       	st	X, r23
     466:	9b 97       	sbiw	r26, 0x2b	; 43
     468:	9d 96       	adiw	r26, 0x2d	; 45
     46a:	1c 92       	st	X, r1
     46c:	1e 92       	st	-X, r1
     46e:	9c 97       	sbiw	r26, 0x2c	; 44
     470:	9f 96       	adiw	r26, 0x2f	; 47
     472:	1c 92       	st	X, r1
     474:	1e 92       	st	-X, r1
     476:	9e 97       	sbiw	r26, 0x2e	; 46
     478:	d1 96       	adiw	r26, 0x31	; 49
     47a:	1c 92       	st	X, r1
     47c:	1e 92       	st	-X, r1
     47e:	d0 97       	sbiw	r26, 0x30	; 48

	c.ppm = 10.0;
	c.p = {0, 0, 0};
	Nitrate[index] = c;
     480:	40 e0       	ldi	r20, 0x00	; 0
     482:	50 e0       	ldi	r21, 0x00	; 0
     484:	60 e2       	ldi	r22, 0x20	; 32
     486:	71 e4       	ldi	r23, 0x41	; 65
     488:	40 a7       	std	Z+40, r20	; 0x28
     48a:	51 a7       	std	Z+41, r21	; 0x29
     48c:	62 a7       	std	Z+42, r22	; 0x2a
     48e:	73 a7       	std	Z+43, r23	; 0x2b
     490:	15 a6       	std	Z+45, r1	; 0x2d
     492:	14 a6       	std	Z+44, r1	; 0x2c
     494:	17 a6       	std	Z+47, r1	; 0x2f
     496:	16 a6       	std	Z+46, r1	; 0x2e
     498:	11 aa       	std	Z+49, r1	; 0x31
     49a:	10 aa       	std	Z+48, r1	; 0x30

	++index;

	c.ppm = 3.0;
	c.p = {0, 0, 0};
	Nitrite[index] = c;
     49c:	d2 96       	adiw	r26, 0x32	; 50
     49e:	0d 93       	st	X+, r16
     4a0:	1d 93       	st	X+, r17
     4a2:	2d 93       	st	X+, r18
     4a4:	3c 93       	st	X, r19
     4a6:	d5 97       	sbiw	r26, 0x35	; 53
     4a8:	d7 96       	adiw	r26, 0x37	; 55
     4aa:	1c 92       	st	X, r1
     4ac:	1e 92       	st	-X, r1
     4ae:	d6 97       	sbiw	r26, 0x36	; 54
     4b0:	d9 96       	adiw	r26, 0x39	; 57
     4b2:	1c 92       	st	X, r1
     4b4:	1e 92       	st	-X, r1
     4b6:	d8 97       	sbiw	r26, 0x38	; 56
     4b8:	db 96       	adiw	r26, 0x3b	; 59
     4ba:	1c 92       	st	X, r1
     4bc:	1e 92       	st	-X, r1
     4be:	da 97       	sbiw	r26, 0x3a	; 58

	c.ppm = 20.0;
	c.p = {0, 0, 0};
	Nitrate[index] = c;
     4c0:	00 e0       	ldi	r16, 0x00	; 0
     4c2:	10 e0       	ldi	r17, 0x00	; 0
     4c4:	20 ea       	ldi	r18, 0xA0	; 160
     4c6:	31 e4       	ldi	r19, 0x41	; 65
     4c8:	02 ab       	std	Z+50, r16	; 0x32
     4ca:	13 ab       	std	Z+51, r17	; 0x33
     4cc:	24 ab       	std	Z+52, r18	; 0x34
     4ce:	35 ab       	std	Z+53, r19	; 0x35
     4d0:	17 aa       	std	Z+55, r1	; 0x37
     4d2:	16 aa       	std	Z+54, r1	; 0x36
     4d4:	11 ae       	std	Z+57, r1	; 0x39
     4d6:	10 ae       	std	Z+56, r1	; 0x38
     4d8:	13 ae       	std	Z+59, r1	; 0x3b
     4da:	12 ae       	std	Z+58, r1	; 0x3a

	++index;

	c.ppm = 10.0;
	c.p = {0, 0, 0};
	Nitrite[index] = c;
     4dc:	dc 96       	adiw	r26, 0x3c	; 60
     4de:	4d 93       	st	X+, r20
     4e0:	5d 93       	st	X+, r21
     4e2:	6d 93       	st	X+, r22
     4e4:	7c 93       	st	X, r23
     4e6:	df 97       	sbiw	r26, 0x3f	; 63
     4e8:	10 92 26 03 	sts	0x0326, r1	; 0x800326 <Nitrite+0x41>
     4ec:	10 92 25 03 	sts	0x0325, r1	; 0x800325 <Nitrite+0x40>
     4f0:	10 92 28 03 	sts	0x0328, r1	; 0x800328 <Nitrite+0x43>
     4f4:	10 92 27 03 	sts	0x0327, r1	; 0x800327 <Nitrite+0x42>
     4f8:	10 92 2a 03 	sts	0x032A, r1	; 0x80032a <Nitrite+0x45>
     4fc:	10 92 29 03 	sts	0x0329, r1	; 0x800329 <Nitrite+0x44>

	c.ppm = 50.0;
	c.p = {0, 0, 0};
	Nitrate[index] = c;
     500:	80 e0       	ldi	r24, 0x00	; 0
     502:	90 e0       	ldi	r25, 0x00	; 0
     504:	a8 e4       	ldi	r26, 0x48	; 72
     506:	b2 e4       	ldi	r27, 0x42	; 66
     508:	84 af       	std	Z+60, r24	; 0x3c
     50a:	95 af       	std	Z+61, r25	; 0x3d
     50c:	a6 af       	std	Z+62, r26	; 0x3e
     50e:	b7 af       	std	Z+63, r27	; 0x3f
     510:	10 92 e0 02 	sts	0x02E0, r1	; 0x8002e0 <Nitrate+0x41>
     514:	10 92 df 02 	sts	0x02DF, r1	; 0x8002df <Nitrate+0x40>
     518:	10 92 e2 02 	sts	0x02E2, r1	; 0x8002e2 <Nitrate+0x43>
     51c:	10 92 e1 02 	sts	0x02E1, r1	; 0x8002e1 <Nitrate+0x42>
     520:	10 92 e4 02 	sts	0x02E4, r1	; 0x8002e4 <Nitrate+0x45>
     524:	10 92 e3 02 	sts	0x02E3, r1	; 0x8002e3 <Nitrate+0x44>
}
     528:	df 91       	pop	r29
     52a:	cf 91       	pop	r28
     52c:	1f 91       	pop	r17
     52e:	0f 91       	pop	r16
     530:	08 95       	ret

00000532 <_Z9SameColorv>:


bool SameColor()
{
	Serial.print("c: ");
     532:	62 e5       	ldi	r22, 0x52	; 82
     534:	71 e0       	ldi	r23, 0x01	; 1
     536:	83 e3       	ldi	r24, 0x33	; 51
     538:	94 e0       	ldi	r25, 0x04	; 4
     53a:	0e 94 18 1f 	call	0x3e30	; 0x3e30 <_ZN5Print5printEPKc>
	Serial.print(c.p.R);
     53e:	60 91 96 02 	lds	r22, 0x0296	; 0x800296 <c+0x4>
     542:	70 91 97 02 	lds	r23, 0x0297	; 0x800297 <c+0x5>
     546:	4a e0       	ldi	r20, 0x0A	; 10
     548:	50 e0       	ldi	r21, 0x00	; 0
     54a:	83 e3       	ldi	r24, 0x33	; 51
     54c:	94 e0       	ldi	r25, 0x04	; 4
     54e:	0e 94 ee 1f 	call	0x3fdc	; 0x3fdc <_ZN5Print5printEii>
	Serial.print(" ");
     552:	64 e5       	ldi	r22, 0x54	; 84
     554:	71 e0       	ldi	r23, 0x01	; 1
     556:	83 e3       	ldi	r24, 0x33	; 51
     558:	94 e0       	ldi	r25, 0x04	; 4
     55a:	0e 94 18 1f 	call	0x3e30	; 0x3e30 <_ZN5Print5printEPKc>
	Serial.print(c.p.G);
     55e:	60 91 98 02 	lds	r22, 0x0298	; 0x800298 <c+0x6>
     562:	70 91 99 02 	lds	r23, 0x0299	; 0x800299 <c+0x7>
     566:	4a e0       	ldi	r20, 0x0A	; 10
     568:	50 e0       	ldi	r21, 0x00	; 0
     56a:	83 e3       	ldi	r24, 0x33	; 51
     56c:	94 e0       	ldi	r25, 0x04	; 4
     56e:	0e 94 ee 1f 	call	0x3fdc	; 0x3fdc <_ZN5Print5printEii>
	Serial.print(" ");
     572:	64 e5       	ldi	r22, 0x54	; 84
     574:	71 e0       	ldi	r23, 0x01	; 1
     576:	83 e3       	ldi	r24, 0x33	; 51
     578:	94 e0       	ldi	r25, 0x04	; 4
     57a:	0e 94 18 1f 	call	0x3e30	; 0x3e30 <_ZN5Print5printEPKc>
	Serial.print(c.p.B);
     57e:	60 91 9a 02 	lds	r22, 0x029A	; 0x80029a <c+0x8>
     582:	70 91 9b 02 	lds	r23, 0x029B	; 0x80029b <c+0x9>
     586:	4a e0       	ldi	r20, 0x0A	; 10
     588:	50 e0       	ldi	r21, 0x00	; 0
     58a:	83 e3       	ldi	r24, 0x33	; 51
     58c:	94 e0       	ldi	r25, 0x04	; 4
     58e:	0e 94 ee 1f 	call	0x3fdc	; 0x3fdc <_ZN5Print5printEii>
	Serial.print("read_in: ");
     592:	66 e5       	ldi	r22, 0x56	; 86
     594:	71 e0       	ldi	r23, 0x01	; 1
     596:	83 e3       	ldi	r24, 0x33	; 51
     598:	94 e0       	ldi	r25, 0x04	; 4
     59a:	0e 94 18 1f 	call	0x3e30	; 0x3e30 <_ZN5Print5printEPKc>
	Serial.print(redScanned);
     59e:	4a e0       	ldi	r20, 0x0A	; 10
     5a0:	50 e0       	ldi	r21, 0x00	; 0
     5a2:	60 91 90 02 	lds	r22, 0x0290	; 0x800290 <redScanned>
     5a6:	83 e3       	ldi	r24, 0x33	; 51
     5a8:	94 e0       	ldi	r25, 0x04	; 4
     5aa:	0e 94 8d 1f 	call	0x3f1a	; 0x3f1a <_ZN5Print5printEhi>
	Serial.print(" ");
     5ae:	64 e5       	ldi	r22, 0x54	; 84
     5b0:	71 e0       	ldi	r23, 0x01	; 1
     5b2:	83 e3       	ldi	r24, 0x33	; 51
     5b4:	94 e0       	ldi	r25, 0x04	; 4
     5b6:	0e 94 18 1f 	call	0x3e30	; 0x3e30 <_ZN5Print5printEPKc>
	Serial.print(greenScanned);
     5ba:	4a e0       	ldi	r20, 0x0A	; 10
     5bc:	50 e0       	ldi	r21, 0x00	; 0
     5be:	60 91 91 02 	lds	r22, 0x0291	; 0x800291 <greenScanned>
     5c2:	83 e3       	ldi	r24, 0x33	; 51
     5c4:	94 e0       	ldi	r25, 0x04	; 4
     5c6:	0e 94 8d 1f 	call	0x3f1a	; 0x3f1a <_ZN5Print5printEhi>
	Serial.print(" ");
     5ca:	64 e5       	ldi	r22, 0x54	; 84
     5cc:	71 e0       	ldi	r23, 0x01	; 1
     5ce:	83 e3       	ldi	r24, 0x33	; 51
     5d0:	94 e0       	ldi	r25, 0x04	; 4
     5d2:	0e 94 18 1f 	call	0x3e30	; 0x3e30 <_ZN5Print5printEPKc>
	Serial.print(blueScanned);
     5d6:	4a e0       	ldi	r20, 0x0A	; 10
     5d8:	50 e0       	ldi	r21, 0x00	; 0
     5da:	60 91 8f 02 	lds	r22, 0x028F	; 0x80028f <blueScanned>
     5de:	83 e3       	ldi	r24, 0x33	; 51
     5e0:	94 e0       	ldi	r25, 0x04	; 4
     5e2:	0e 94 8d 1f 	call	0x3f1a	; 0x3f1a <_ZN5Print5printEhi>
	// check if RGB values are within range specified by tolerance
	if (redScanned < (c.p.R - TOLERANCE) || redScanned > (c.p.R + TOLERANCE))
     5e6:	20 91 90 02 	lds	r18, 0x0290	; 0x800290 <redScanned>
     5ea:	30 e0       	ldi	r19, 0x00	; 0
     5ec:	80 91 96 02 	lds	r24, 0x0296	; 0x800296 <c+0x4>
     5f0:	90 91 97 02 	lds	r25, 0x0297	; 0x800297 <c+0x5>
     5f4:	ac 01       	movw	r20, r24
     5f6:	45 50       	subi	r20, 0x05	; 5
     5f8:	51 09       	sbc	r21, r1
     5fa:	24 17       	cp	r18, r20
     5fc:	35 07       	cpc	r19, r21
     5fe:	74 f1       	brlt	.+92     	; 0x65c <_Z9SameColorv+0x12a>
     600:	05 96       	adiw	r24, 0x05	; 5
     602:	82 17       	cp	r24, r18
     604:	93 07       	cpc	r25, r19
     606:	54 f1       	brlt	.+84     	; 0x65c <_Z9SameColorv+0x12a>
		return false;
	if (greenScanned < (c.p.G - TOLERANCE) || greenScanned > (c.p.G + TOLERANCE))
     608:	20 91 91 02 	lds	r18, 0x0291	; 0x800291 <greenScanned>
     60c:	30 e0       	ldi	r19, 0x00	; 0
     60e:	80 91 98 02 	lds	r24, 0x0298	; 0x800298 <c+0x6>
     612:	90 91 99 02 	lds	r25, 0x0299	; 0x800299 <c+0x7>
     616:	ac 01       	movw	r20, r24
     618:	45 50       	subi	r20, 0x05	; 5
     61a:	51 09       	sbc	r21, r1
     61c:	24 17       	cp	r18, r20
     61e:	35 07       	cpc	r19, r21
     620:	ec f0       	brlt	.+58     	; 0x65c <_Z9SameColorv+0x12a>
     622:	05 96       	adiw	r24, 0x05	; 5
     624:	82 17       	cp	r24, r18
     626:	93 07       	cpc	r25, r19
     628:	cc f0       	brlt	.+50     	; 0x65c <_Z9SameColorv+0x12a>
		return false;
	if (blueScanned < (c.p.B - TOLERANCE) || blueScanned > (c.p.B + TOLERANCE))
     62a:	20 91 8f 02 	lds	r18, 0x028F	; 0x80028f <blueScanned>
     62e:	30 e0       	ldi	r19, 0x00	; 0
     630:	80 91 9a 02 	lds	r24, 0x029A	; 0x80029a <c+0x8>
     634:	90 91 9b 02 	lds	r25, 0x029B	; 0x80029b <c+0x9>
     638:	ac 01       	movw	r20, r24
     63a:	45 50       	subi	r20, 0x05	; 5
     63c:	51 09       	sbc	r21, r1
     63e:	24 17       	cp	r18, r20
     640:	35 07       	cpc	r19, r21
     642:	64 f0       	brlt	.+24     	; 0x65c <_Z9SameColorv+0x12a>
     644:	05 96       	adiw	r24, 0x05	; 5
     646:	82 17       	cp	r24, r18
     648:	93 07       	cpc	r25, r19
     64a:	44 f0       	brlt	.+16     	; 0x65c <_Z9SameColorv+0x12a>
		return false;
	
	Serial.print(F("\nFound Matching Color"));
     64c:	6c e7       	ldi	r22, 0x7C	; 124
     64e:	70 e0       	ldi	r23, 0x00	; 0
     650:	83 e3       	ldi	r24, 0x33	; 51
     652:	94 e0       	ldi	r25, 0x04	; 4
     654:	0e 94 f4 1e 	call	0x3de8	; 0x3de8 <_ZN5Print5printEPK19__FlashStringHelper>
	return true;
     658:	81 e0       	ldi	r24, 0x01	; 1
     65a:	08 95       	ret
	Serial.print(greenScanned);
	Serial.print(" ");
	Serial.print(blueScanned);
	// check if RGB values are within range specified by tolerance
	if (redScanned < (c.p.R - TOLERANCE) || redScanned > (c.p.R + TOLERANCE))
		return false;
     65c:	80 e0       	ldi	r24, 0x00	; 0
	if (blueScanned < (c.p.B - TOLERANCE) || blueScanned > (c.p.B + TOLERANCE))
		return false;
	
	Serial.print(F("\nFound Matching Color"));
	return true;
}
     65e:	08 95       	ret

00000660 <_Z9FindMatchv>:

double FindMatch()
{
     660:	0f 93       	push	r16
     662:	1f 93       	push	r17
     664:	cf 93       	push	r28
     666:	df 93       	push	r29
	switch(typeToRead)
     668:	80 91 5d 03 	lds	r24, 0x035D	; 0x80035d <typeToRead>
     66c:	81 30       	cpi	r24, 0x01	; 1
     66e:	09 f4       	brne	.+2      	; 0x672 <_Z9FindMatchv+0x12>
     670:	48 c0       	rjmp	.+144    	; 0x702 <_Z9FindMatchv+0xa2>
     672:	40 f0       	brcs	.+16     	; 0x684 <_Z9FindMatchv+0x24>
     674:	82 30       	cpi	r24, 0x02	; 2
     676:	09 f0       	breq	.+2      	; 0x67a <_Z9FindMatchv+0x1a>
     678:	6e c0       	rjmp	.+220    	; 0x756 <_Z9FindMatchv+0xf6>
     67a:	05 ee       	ldi	r16, 0xE5	; 229
     67c:	12 e0       	ldi	r17, 0x02	; 2
     67e:	c6 e0       	ldi	r28, 0x06	; 6
     680:	d0 e0       	ldi	r29, 0x00	; 0
     682:	29 c0       	rjmp	.+82     	; 0x6d6 <_Z9FindMatchv+0x76>
     684:	0b e2       	ldi	r16, 0x2B	; 43
     686:	13 e0       	ldi	r17, 0x03	; 3
     688:	c4 e0       	ldi	r28, 0x04	; 4
     68a:	d0 e0       	ldi	r29, 0x00	; 0
		case AMMONIA:
		{
			// start at highest ammonia level - false positive better than false negative
			for(int i = MAX_AMMONIA_COLORS - 1; i >= 0; --i)
			{
				c = Ammonia[i];
     68c:	8a e0       	ldi	r24, 0x0A	; 10
     68e:	f8 01       	movw	r30, r16
     690:	b8 96       	adiw	r30, 0x28	; 40
     692:	a2 e9       	ldi	r26, 0x92	; 146
     694:	b2 e0       	ldi	r27, 0x02	; 2
     696:	01 90       	ld	r0, Z+
     698:	0d 92       	st	X+, r0
     69a:	8a 95       	dec	r24
     69c:	e1 f7       	brne	.-8      	; 0x696 <_Z9FindMatchv+0x36>
				if(SameColor())
     69e:	0e 94 99 02 	call	0x532	; 0x532 <_Z9SameColorv>
     6a2:	88 23       	and	r24, r24
     6a4:	49 f0       	breq	.+18     	; 0x6b8 <_Z9FindMatchv+0x58>
				return Ammonia[i].ppm;
     6a6:	8a e0       	ldi	r24, 0x0A	; 10
     6a8:	8c 9f       	mul	r24, r28
     6aa:	f0 01       	movw	r30, r0
     6ac:	8d 9f       	mul	r24, r29
     6ae:	f0 0d       	add	r31, r0
     6b0:	11 24       	eor	r1, r1
     6b2:	e5 5d       	subi	r30, 0xD5	; 213
     6b4:	fc 4f       	sbci	r31, 0xFC	; 252
     6b6:	3e c0       	rjmp	.+124    	; 0x734 <_Z9FindMatchv+0xd4>
	switch(typeToRead)
	{
		case AMMONIA:
		{
			// start at highest ammonia level - false positive better than false negative
			for(int i = MAX_AMMONIA_COLORS - 1; i >= 0; --i)
     6b8:	21 97       	sbiw	r28, 0x01	; 1
     6ba:	0a 50       	subi	r16, 0x0A	; 10
     6bc:	11 09       	sbc	r17, r1
     6be:	cf 3f       	cpi	r28, 0xFF	; 255
     6c0:	8f ef       	ldi	r24, 0xFF	; 255
     6c2:	d8 07       	cpc	r29, r24
     6c4:	19 f7       	brne	.-58     	; 0x68c <_Z9FindMatchv+0x2c>
     6c6:	42 c0       	rjmp	.+132    	; 0x74c <_Z9FindMatchv+0xec>
			break;
		}
		case NITRITE:
		{
			// start at highest nitrite level - false positive better than false negative
			for(int i = MAX_NITRITE_NITRATE_COLORS - 1; i >= 0; --i)
     6c8:	21 97       	sbiw	r28, 0x01	; 1
     6ca:	0a 50       	subi	r16, 0x0A	; 10
     6cc:	11 09       	sbc	r17, r1
     6ce:	cf 3f       	cpi	r28, 0xFF	; 255
     6d0:	8f ef       	ldi	r24, 0xFF	; 255
     6d2:	d8 07       	cpc	r29, r24
     6d4:	d9 f1       	breq	.+118    	; 0x74c <_Z9FindMatchv+0xec>
			{
				c = Nitrite[i];
     6d6:	8a e0       	ldi	r24, 0x0A	; 10
     6d8:	f8 01       	movw	r30, r16
     6da:	fc 96       	adiw	r30, 0x3c	; 60
     6dc:	a2 e9       	ldi	r26, 0x92	; 146
     6de:	b2 e0       	ldi	r27, 0x02	; 2
     6e0:	01 90       	ld	r0, Z+
     6e2:	0d 92       	st	X+, r0
     6e4:	8a 95       	dec	r24
     6e6:	e1 f7       	brne	.-8      	; 0x6e0 <_Z9FindMatchv+0x80>
				if(SameColor())
     6e8:	0e 94 99 02 	call	0x532	; 0x532 <_Z9SameColorv>
     6ec:	88 23       	and	r24, r24
     6ee:	61 f3       	breq	.-40     	; 0x6c8 <_Z9FindMatchv+0x68>
				return Nitrite[i].ppm;
     6f0:	8a e0       	ldi	r24, 0x0A	; 10
     6f2:	8c 9f       	mul	r24, r28
     6f4:	f0 01       	movw	r30, r0
     6f6:	8d 9f       	mul	r24, r29
     6f8:	f0 0d       	add	r31, r0
     6fa:	11 24       	eor	r1, r1
     6fc:	eb 51       	subi	r30, 0x1B	; 27
     6fe:	fd 4f       	sbci	r31, 0xFD	; 253
     700:	19 c0       	rjmp	.+50     	; 0x734 <_Z9FindMatchv+0xd4>
     702:	0f e9       	ldi	r16, 0x9F	; 159
     704:	12 e0       	ldi	r17, 0x02	; 2
	return true;
}

double FindMatch()
{
	switch(typeToRead)
     706:	c6 e0       	ldi	r28, 0x06	; 6
     708:	d0 e0       	ldi	r29, 0x00	; 0
		case NITRATE:
		{
			// start at highest nitrate level - false positive better than false negative
			for(int i = MAX_NITRITE_NITRATE_COLORS - 1; i >= 0; --i)
			{
				c = Nitrate[i];
     70a:	8a e0       	ldi	r24, 0x0A	; 10
     70c:	f8 01       	movw	r30, r16
     70e:	fc 96       	adiw	r30, 0x3c	; 60
     710:	a2 e9       	ldi	r26, 0x92	; 146
     712:	b2 e0       	ldi	r27, 0x02	; 2
     714:	01 90       	ld	r0, Z+
     716:	0d 92       	st	X+, r0
     718:	8a 95       	dec	r24
     71a:	e1 f7       	brne	.-8      	; 0x714 <_Z9FindMatchv+0xb4>
				if(SameColor())
     71c:	0e 94 99 02 	call	0x532	; 0x532 <_Z9SameColorv>
     720:	88 23       	and	r24, r24
     722:	69 f0       	breq	.+26     	; 0x73e <_Z9FindMatchv+0xde>
				return Nitrate[i].ppm;
     724:	8a e0       	ldi	r24, 0x0A	; 10
     726:	8c 9f       	mul	r24, r28
     728:	f0 01       	movw	r30, r0
     72a:	8d 9f       	mul	r24, r29
     72c:	f0 0d       	add	r31, r0
     72e:	11 24       	eor	r1, r1
     730:	e1 56       	subi	r30, 0x61	; 97
     732:	fd 4f       	sbci	r31, 0xFD	; 253
     734:	30 81       	ld	r19, Z
     736:	21 81       	ldd	r18, Z+1	; 0x01
     738:	92 81       	ldd	r25, Z+2	; 0x02
     73a:	83 81       	ldd	r24, Z+3	; 0x03
     73c:	0b c0       	rjmp	.+22     	; 0x754 <_Z9FindMatchv+0xf4>
			break;
		}
		case NITRATE:
		{
			// start at highest nitrate level - false positive better than false negative
			for(int i = MAX_NITRITE_NITRATE_COLORS - 1; i >= 0; --i)
     73e:	21 97       	sbiw	r28, 0x01	; 1
     740:	0a 50       	subi	r16, 0x0A	; 10
     742:	11 09       	sbc	r17, r1
     744:	cf 3f       	cpi	r28, 0xFF	; 255
     746:	8f ef       	ldi	r24, 0xFF	; 255
     748:	d8 07       	cpc	r29, r24
     74a:	f9 f6       	brne	.-66     	; 0x70a <_Z9FindMatchv+0xaa>
			{
				c = Ammonia[i];
				if(SameColor())
				return Ammonia[i].ppm;
			}
			return -1;
     74c:	30 e0       	ldi	r19, 0x00	; 0
     74e:	20 e0       	ldi	r18, 0x00	; 0
     750:	90 e8       	ldi	r25, 0x80	; 128
     752:	8f eb       	ldi	r24, 0xBF	; 191
     754:	ac 01       	movw	r20, r24
			}
			return -1;
			break;
		}
	}
}
     756:	63 2f       	mov	r22, r19
     758:	72 2f       	mov	r23, r18
     75a:	85 2f       	mov	r24, r21
     75c:	94 2f       	mov	r25, r20
     75e:	df 91       	pop	r29
     760:	cf 91       	pop	r28
     762:	1f 91       	pop	r17
     764:	0f 91       	pop	r16
     766:	08 95       	ret

00000768 <_Z9ScanColorv>:

long ScanColor()
{
	CS.read();
     768:	80 e6       	ldi	r24, 0x60	; 96
     76a:	92 e0       	ldi	r25, 0x02	; 2
     76c:	0e 94 2a 18 	call	0x3054	; 0x3054 <_ZN9MD_TCS2304readEv>
	while(CS.available() == 0);  // wait for read to complete
     770:	80 e6       	ldi	r24, 0x60	; 96
     772:	92 e0       	ldi	r25, 0x02	; 2
     774:	0e 94 34 18 	call	0x3068	; 0x3068 <_ZN9MD_TCS2309availableEv>
     778:	88 23       	and	r24, r24
     77a:	d1 f3       	breq	.-12     	; 0x770 <_Z9ScanColorv+0x8>
	CS.getRGB(&rgb);
     77c:	6c e9       	ldi	r22, 0x9C	; 156
     77e:	72 e0       	ldi	r23, 0x02	; 2
     780:	80 e6       	ldi	r24, 0x60	; 96
     782:	92 e0       	ldi	r25, 0x02	; 2
     784:	0e 94 60 17 	call	0x2ec0	; 0x2ec0 <_ZN9MD_TCS2306getRGBEP9colorData>
	greenScanned = rgb.value[TCS230_RGB_G];
     788:	80 91 9d 02 	lds	r24, 0x029D	; 0x80029d <rgb+0x1>
     78c:	80 93 91 02 	sts	0x0291, r24	; 0x800291 <greenScanned>
	redScanned = rgb.value[TCS230_RGB_R];
     790:	80 91 9c 02 	lds	r24, 0x029C	; 0x80029c <rgb>
     794:	80 93 90 02 	sts	0x0290, r24	; 0x800290 <redScanned>
	blueScanned = rgb.value[TCS230_RGB_B];
     798:	80 91 9e 02 	lds	r24, 0x029E	; 0x80029e <rgb+0x2>
     79c:	80 93 8f 02 	sts	0x028F, r24	; 0x80028f <blueScanned>
	// look for match
	Serial.println("RGB");
     7a0:	60 e6       	ldi	r22, 0x60	; 96
     7a2:	71 e0       	ldi	r23, 0x01	; 1
     7a4:	83 e3       	ldi	r24, 0x33	; 51
     7a6:	94 e0       	ldi	r25, 0x04	; 4
     7a8:	0e 94 25 1f 	call	0x3e4a	; 0x3e4a <_ZN5Print7printlnEPKc>
	Serial.println(redScanned);
     7ac:	4a e0       	ldi	r20, 0x0A	; 10
     7ae:	50 e0       	ldi	r21, 0x00	; 0
     7b0:	60 91 90 02 	lds	r22, 0x0290	; 0x800290 <redScanned>
     7b4:	83 e3       	ldi	r24, 0x33	; 51
     7b6:	94 e0       	ldi	r25, 0x04	; 4
     7b8:	0e 94 94 1f 	call	0x3f28	; 0x3f28 <_ZN5Print7printlnEhi>
	Serial.println(greenScanned);
     7bc:	4a e0       	ldi	r20, 0x0A	; 10
     7be:	50 e0       	ldi	r21, 0x00	; 0
     7c0:	60 91 91 02 	lds	r22, 0x0291	; 0x800291 <greenScanned>
     7c4:	83 e3       	ldi	r24, 0x33	; 51
     7c6:	94 e0       	ldi	r25, 0x04	; 4
     7c8:	0e 94 94 1f 	call	0x3f28	; 0x3f28 <_ZN5Print7printlnEhi>
	Serial.println(blueScanned);
     7cc:	4a e0       	ldi	r20, 0x0A	; 10
     7ce:	50 e0       	ldi	r21, 0x00	; 0
     7d0:	60 91 8f 02 	lds	r22, 0x028F	; 0x80028f <blueScanned>
     7d4:	83 e3       	ldi	r24, 0x33	; 51
     7d6:	94 e0       	ldi	r25, 0x04	; 4
     7d8:	0e 94 94 1f 	call	0x3f28	; 0x3f28 <_ZN5Print7printlnEhi>
	//return FindMatch();
}
     7dc:	08 95       	ret

000007de <_Z13findTestStripv>:

bool findTestStrip()
{
     7de:	cf 93       	push	r28
	// Scan for color
	CS.read();
     7e0:	80 e6       	ldi	r24, 0x60	; 96
     7e2:	92 e0       	ldi	r25, 0x02	; 2
     7e4:	0e 94 2a 18 	call	0x3054	; 0x3054 <_ZN9MD_TCS2304readEv>
	while (CS.available() == 0);
     7e8:	80 e6       	ldi	r24, 0x60	; 96
     7ea:	92 e0       	ldi	r25, 0x02	; 2
     7ec:	0e 94 34 18 	call	0x3068	; 0x3068 <_ZN9MD_TCS2309availableEv>
     7f0:	88 23       	and	r24, r24
     7f2:	d1 f3       	breq	.-12     	; 0x7e8 <_Z13findTestStripv+0xa>
	CS.getRGB(&rgb);
     7f4:	6c e9       	ldi	r22, 0x9C	; 156
     7f6:	72 e0       	ldi	r23, 0x02	; 2
     7f8:	80 e6       	ldi	r24, 0x60	; 96
     7fa:	92 e0       	ldi	r25, 0x02	; 2
     7fc:	0e 94 60 17 	call	0x2ec0	; 0x2ec0 <_ZN9MD_TCS2306getRGBEP9colorData>
	greenScanned = rgb.value[TCS230_RGB_G];
     800:	80 91 9d 02 	lds	r24, 0x029D	; 0x80029d <rgb+0x1>
     804:	80 93 91 02 	sts	0x0291, r24	; 0x800291 <greenScanned>
	redScanned = rgb.value[TCS230_RGB_R];
     808:	80 91 9c 02 	lds	r24, 0x029C	; 0x80029c <rgb>
     80c:	80 93 90 02 	sts	0x0290, r24	; 0x800290 <redScanned>
	blueScanned = rgb.value[TCS230_RGB_B];
     810:	80 91 9e 02 	lds	r24, 0x029E	; 0x80029e <rgb+0x2>
     814:	80 93 8f 02 	sts	0x028F, r24	; 0x80028f <blueScanned>
	// look for match against black
	c = EmptyTestBox;
     818:	8a e0       	ldi	r24, 0x0A	; 10
     81a:	e9 e2       	ldi	r30, 0x29	; 41
     81c:	f1 e0       	ldi	r31, 0x01	; 1
     81e:	a2 e9       	ldi	r26, 0x92	; 146
     820:	b2 e0       	ldi	r27, 0x02	; 2
     822:	01 90       	ld	r0, Z+
     824:	0d 92       	st	X+, r0
     826:	8a 95       	dec	r24
     828:	e1 f7       	brne	.-8      	; 0x822 <_Z13findTestStripv+0x44>
	bool foundEmptyBox = SameColor();
     82a:	0e 94 99 02 	call	0x532	; 0x532 <_Z9SameColorv>
     82e:	c8 2f       	mov	r28, r24
	Serial.print(" foundEmptyBox ");
     830:	64 e6       	ldi	r22, 0x64	; 100
     832:	71 e0       	ldi	r23, 0x01	; 1
     834:	83 e3       	ldi	r24, 0x33	; 51
     836:	94 e0       	ldi	r25, 0x04	; 4
     838:	0e 94 18 1f 	call	0x3e30	; 0x3e30 <_ZN5Print5printEPKc>
	Serial.println(foundEmptyBox);
     83c:	6c 2f       	mov	r22, r28
     83e:	70 e0       	ldi	r23, 0x00	; 0
     840:	4a e0       	ldi	r20, 0x0A	; 10
     842:	50 e0       	ldi	r21, 0x00	; 0
     844:	83 e3       	ldi	r24, 0x33	; 51
     846:	94 e0       	ldi	r25, 0x04	; 4
     848:	0e 94 f5 1f 	call	0x3fea	; 0x3fea <_ZN5Print7printlnEii>
	Serial.print("\n");
     84c:	68 e1       	ldi	r22, 0x18	; 24
     84e:	72 e0       	ldi	r23, 0x02	; 2
     850:	83 e3       	ldi	r24, 0x33	; 51
     852:	94 e0       	ldi	r25, 0x04	; 4
     854:	0e 94 18 1f 	call	0x3e30	; 0x3e30 <_ZN5Print5printEPKc>
	c = WhiteTestStrip;
     858:	8a e0       	ldi	r24, 0x0A	; 10
     85a:	ef e1       	ldi	r30, 0x1F	; 31
     85c:	f1 e0       	ldi	r31, 0x01	; 1
     85e:	a2 e9       	ldi	r26, 0x92	; 146
     860:	b2 e0       	ldi	r27, 0x02	; 2
     862:	01 90       	ld	r0, Z+
     864:	0d 92       	st	X+, r0
     866:	8a 95       	dec	r24
     868:	e1 f7       	brne	.-8      	; 0x862 <_Z13findTestStripv+0x84>
	foundEmptyBox =  foundEmptyBox || SameColor();
     86a:	c1 11       	cpse	r28, r1
     86c:	03 c0       	rjmp	.+6      	; 0x874 <_Z13findTestStripv+0x96>
     86e:	0e 94 99 02 	call	0x532	; 0x532 <_Z9SameColorv>
     872:	c8 2f       	mov	r28, r24
	Serial.print(" foundEmptyBoxOrTestStrip ");
     874:	64 e7       	ldi	r22, 0x74	; 116
     876:	71 e0       	ldi	r23, 0x01	; 1
     878:	83 e3       	ldi	r24, 0x33	; 51
     87a:	94 e0       	ldi	r25, 0x04	; 4
     87c:	0e 94 18 1f 	call	0x3e30	; 0x3e30 <_ZN5Print5printEPKc>
	Serial.println(foundEmptyBox);
     880:	6c 2f       	mov	r22, r28
     882:	70 e0       	ldi	r23, 0x00	; 0
     884:	4a e0       	ldi	r20, 0x0A	; 10
     886:	50 e0       	ldi	r21, 0x00	; 0
     888:	83 e3       	ldi	r24, 0x33	; 51
     88a:	94 e0       	ldi	r25, 0x04	; 4
     88c:	0e 94 f5 1f 	call	0x3fea	; 0x3fea <_ZN5Print7printlnEii>
	Serial.print("\n");
     890:	68 e1       	ldi	r22, 0x18	; 24
     892:	72 e0       	ldi	r23, 0x02	; 2
     894:	83 e3       	ldi	r24, 0x33	; 51
     896:	94 e0       	ldi	r25, 0x04	; 4
     898:	0e 94 18 1f 	call	0x3e30	; 0x3e30 <_ZN5Print5printEPKc>
	return foundEmptyBox && (FindMatch() == -1);
     89c:	cc 23       	and	r28, r28
     89e:	51 f0       	breq	.+20     	; 0x8b4 <_Z13findTestStripv+0xd6>
     8a0:	0e 94 30 03 	call	0x660	; 0x660 <_Z9FindMatchv>
     8a4:	c1 e0       	ldi	r28, 0x01	; 1
     8a6:	20 e0       	ldi	r18, 0x00	; 0
     8a8:	30 e0       	ldi	r19, 0x00	; 0
     8aa:	40 e8       	ldi	r20, 0x80	; 128
     8ac:	5f eb       	ldi	r21, 0xBF	; 191
     8ae:	0e 94 1f 1b 	call	0x363e	; 0x363e <__cmpsf2>
     8b2:	81 11       	cpse	r24, r1
     8b4:	c0 e0       	ldi	r28, 0x00	; 0
     8b6:	8c 2f       	mov	r24, r28
     8b8:	cf 91       	pop	r28
     8ba:	08 95       	ret

000008bc <_Z6setLED8LEDColor>:
LEDColor White = {255, 255, 255};
LEDColor Off = {0, 0, 0};


void setLED(LEDColor c)
{
     8bc:	cf 93       	push	r28
     8be:	df 93       	push	r29
     8c0:	00 d0       	rcall	.+0      	; 0x8c2 <_Z6setLED8LEDColor+0x6>
     8c2:	00 d0       	rcall	.+0      	; 0x8c4 <_Z6setLED8LEDColor+0x8>
     8c4:	00 d0       	rcall	.+0      	; 0x8c6 <_Z6setLED8LEDColor+0xa>
     8c6:	cd b7       	in	r28, 0x3d	; 61
     8c8:	de b7       	in	r29, 0x3e	; 62
     8ca:	49 83       	std	Y+1, r20	; 0x01
     8cc:	5a 83       	std	Y+2, r21	; 0x02
     8ce:	6b 83       	std	Y+3, r22	; 0x03
     8d0:	7c 83       	std	Y+4, r23	; 0x04
     8d2:	8d 83       	std	Y+5, r24	; 0x05
     8d4:	9e 83       	std	Y+6, r25	; 0x06
	analogWrite(R_LED, c.r);
     8d6:	69 81       	ldd	r22, Y+1	; 0x01
     8d8:	7a 81       	ldd	r23, Y+2	; 0x02
     8da:	8f e0       	ldi	r24, 0x0F	; 15
     8dc:	0e 94 84 21 	call	0x4308	; 0x4308 <analogWrite>
	analogWrite(G_LED, c.g);
     8e0:	6b 81       	ldd	r22, Y+3	; 0x03
     8e2:	7c 81       	ldd	r23, Y+4	; 0x04
     8e4:	80 e1       	ldi	r24, 0x10	; 16
     8e6:	0e 94 84 21 	call	0x4308	; 0x4308 <analogWrite>
	analogWrite(B_LED, c.b);
     8ea:	6d 81       	ldd	r22, Y+5	; 0x05
     8ec:	7e 81       	ldd	r23, Y+6	; 0x06
     8ee:	81 e1       	ldi	r24, 0x11	; 17
}
     8f0:	26 96       	adiw	r28, 0x06	; 6
     8f2:	0f b6       	in	r0, 0x3f	; 63
     8f4:	f8 94       	cli
     8f6:	de bf       	out	0x3e, r29	; 62
     8f8:	0f be       	out	0x3f, r0	; 63
     8fa:	cd bf       	out	0x3d, r28	; 61
     8fc:	df 91       	pop	r29
     8fe:	cf 91       	pop	r28

void setLED(LEDColor c)
{
	analogWrite(R_LED, c.r);
	analogWrite(G_LED, c.g);
	analogWrite(B_LED, c.b);
     900:	0c 94 84 21 	jmp	0x4308	; 0x4308 <analogWrite>

00000904 <_Z15TaskColorSensorPv>:
// get Ammonia, Nitrite, and Nitrate reading from color sensor
void TaskColorSensor(void *pvParameters)
{
	(void) pvParameters;
  
	TickType_t xLastWakeTime = xTaskGetTickCount();
     904:	0e 94 ef 10 	call	0x21de	; 0x21de <xTaskGetTickCount>
				typeToRead = NITRATE;
				while (findTestStrip());
				setLED(Green);
				delay(250); // allow user to see LED and stop moving test strip

				nitrateValue = ScanColor() * 100;
     908:	c4 e6       	ldi	r28, 0x64	; 100
				
				setLED(Off);
				
				typeToRead = NITRITE;
     90a:	12 e0       	ldi	r17, 0x02	; 2
	TickType_t xLastWakeTime = xTaskGetTickCount();
	for (;;) // A Task shall never return or exit.
	{
		//Serial.println("Inside dead task");
		//vTaskDelayUntil( &xLastWakeTime, 500 / portTICK_PERIOD_MS );
		if ( xSemaphoreTake( xSerialSemaphoreColorSensor, ( TickType_t ) 100 ) == pdTRUE )
     90c:	64 e6       	ldi	r22, 0x64	; 100
     90e:	70 e0       	ldi	r23, 0x00	; 0
     910:	80 91 49 02 	lds	r24, 0x0249	; 0x800249 <xSerialSemaphoreColorSensor>
     914:	90 91 4a 02 	lds	r25, 0x024A	; 0x80024a <xSerialSemaphoreColorSensor+0x1>
     918:	0e 94 e3 0d 	call	0x1bc6	; 0x1bc6 <xQueueSemaphoreTake>
     91c:	d8 2f       	mov	r29, r24
     91e:	81 30       	cpi	r24, 0x01	; 1
     920:	09 f0       	breq	.+2      	; 0x924 <_Z15TaskColorSensorPv+0x20>
     922:	8c c0       	rjmp	.+280    	; 0xa3c <_Z15TaskColorSensorPv+0x138>
		{
			setLED(White);
     924:	40 91 07 01 	lds	r20, 0x0107	; 0x800107 <White>
     928:	50 91 08 01 	lds	r21, 0x0108	; 0x800108 <White+0x1>
     92c:	60 91 09 01 	lds	r22, 0x0109	; 0x800109 <White+0x2>
     930:	70 91 0a 01 	lds	r23, 0x010A	; 0x80010a <White+0x3>
     934:	80 91 0b 01 	lds	r24, 0x010B	; 0x80010b <White+0x4>
     938:	90 91 0c 01 	lds	r25, 0x010C	; 0x80010c <White+0x5>
     93c:	0e 94 5e 04 	call	0x8bc	; 0x8bc <_Z6setLED8LEDColor>
			//Serial.println("checking color");
			if (colorToRead == 'a')
     940:	80 91 06 01 	lds	r24, 0x0106	; 0x800106 <colorToRead>
     944:	81 36       	cpi	r24, 0x61	; 97
     946:	a1 f4       	brne	.+40     	; 0x970 <_Z15TaskColorSensorPv+0x6c>
			{
				
				
				//while (findTestStrip());
				//setLED(Green);
				delay(1000); // let user see LED and stop moving before measuring
     948:	68 ee       	ldi	r22, 0xE8	; 232
     94a:	73 e0       	ldi	r23, 0x03	; 3
     94c:	80 e0       	ldi	r24, 0x00	; 0
     94e:	90 e0       	ldi	r25, 0x00	; 0
     950:	0e 94 e5 20 	call	0x41ca	; 0x41ca <delay>
				
				typeToRead = AMMONIA;
     954:	10 92 5d 03 	sts	0x035D, r1	; 0x80035d <typeToRead>
				ammoniaValue = ScanColor() * 100;
     958:	0e 94 b4 03 	call	0x768	; 0x768 <_Z9ScanColorv>
     95c:	c6 9f       	mul	r28, r22
     95e:	90 01       	movw	r18, r0
     960:	c7 9f       	mul	r28, r23
     962:	30 0d       	add	r19, r0
     964:	11 24       	eor	r1, r1
     966:	30 93 53 02 	sts	0x0253, r19	; 0x800253 <ammoniaValue+0x1>
     96a:	20 93 52 02 	sts	0x0252, r18	; 0x800252 <ammoniaValue>
     96e:	58 c0       	rjmp	.+176    	; 0xa20 <_Z15TaskColorSensorPv+0x11c>
			}
			else
			{
				setLED(Red);
     970:	40 91 19 01 	lds	r20, 0x0119	; 0x800119 <Red>
     974:	50 91 1a 01 	lds	r21, 0x011A	; 0x80011a <Red+0x1>
     978:	60 91 1b 01 	lds	r22, 0x011B	; 0x80011b <Red+0x2>
     97c:	70 91 1c 01 	lds	r23, 0x011C	; 0x80011c <Red+0x3>
     980:	80 91 1d 01 	lds	r24, 0x011D	; 0x80011d <Red+0x4>
     984:	90 91 1e 01 	lds	r25, 0x011E	; 0x80011e <Red+0x5>
     988:	0e 94 5e 04 	call	0x8bc	; 0x8bc <_Z6setLED8LEDColor>
				typeToRead = NITRATE;
     98c:	d0 93 5d 03 	sts	0x035D, r29	; 0x80035d <typeToRead>
				while (findTestStrip());
     990:	0e 94 ef 03 	call	0x7de	; 0x7de <_Z13findTestStripv>
     994:	81 11       	cpse	r24, r1
     996:	fc cf       	rjmp	.-8      	; 0x990 <_Z15TaskColorSensorPv+0x8c>
				setLED(Green);
     998:	40 91 13 01 	lds	r20, 0x0113	; 0x800113 <Green>
     99c:	50 91 14 01 	lds	r21, 0x0114	; 0x800114 <Green+0x1>
     9a0:	60 91 15 01 	lds	r22, 0x0115	; 0x800115 <Green+0x2>
     9a4:	70 91 16 01 	lds	r23, 0x0116	; 0x800116 <Green+0x3>
     9a8:	80 91 17 01 	lds	r24, 0x0117	; 0x800117 <Green+0x4>
     9ac:	90 91 18 01 	lds	r25, 0x0118	; 0x800118 <Green+0x5>
     9b0:	0e 94 5e 04 	call	0x8bc	; 0x8bc <_Z6setLED8LEDColor>
				delay(250); // allow user to see LED and stop moving test strip
     9b4:	6a ef       	ldi	r22, 0xFA	; 250
     9b6:	70 e0       	ldi	r23, 0x00	; 0
     9b8:	80 e0       	ldi	r24, 0x00	; 0
     9ba:	90 e0       	ldi	r25, 0x00	; 0
     9bc:	0e 94 e5 20 	call	0x41ca	; 0x41ca <delay>

				nitrateValue = ScanColor() * 100;
     9c0:	0e 94 b4 03 	call	0x768	; 0x768 <_Z9ScanColorv>
     9c4:	c6 9f       	mul	r28, r22
     9c6:	90 01       	movw	r18, r0
     9c8:	c7 9f       	mul	r28, r23
     9ca:	30 0d       	add	r19, r0
     9cc:	11 24       	eor	r1, r1
     9ce:	30 93 51 02 	sts	0x0251, r19	; 0x800251 <nitrateValue+0x1>
     9d2:	20 93 50 02 	sts	0x0250, r18	; 0x800250 <nitrateValue>
				
				setLED(Off);
     9d6:	40 91 5a 02 	lds	r20, 0x025A	; 0x80025a <Off>
     9da:	50 91 5b 02 	lds	r21, 0x025B	; 0x80025b <Off+0x1>
     9de:	60 91 5c 02 	lds	r22, 0x025C	; 0x80025c <Off+0x2>
     9e2:	70 91 5d 02 	lds	r23, 0x025D	; 0x80025d <Off+0x3>
     9e6:	80 91 5e 02 	lds	r24, 0x025E	; 0x80025e <Off+0x4>
     9ea:	90 91 5f 02 	lds	r25, 0x025F	; 0x80025f <Off+0x5>
     9ee:	0e 94 5e 04 	call	0x8bc	; 0x8bc <_Z6setLED8LEDColor>
				
				typeToRead = NITRITE;
     9f2:	10 93 5d 03 	sts	0x035D, r17	; 0x80035d <typeToRead>
				while (findTestStrip());
     9f6:	0e 94 ef 03 	call	0x7de	; 0x7de <_Z13findTestStripv>
     9fa:	81 11       	cpse	r24, r1
     9fc:	fc cf       	rjmp	.-8      	; 0x9f6 <_Z15TaskColorSensorPv+0xf2>
				//setLED(Blue);
				delay(250);
     9fe:	6a ef       	ldi	r22, 0xFA	; 250
     a00:	70 e0       	ldi	r23, 0x00	; 0
     a02:	80 e0       	ldi	r24, 0x00	; 0
     a04:	90 e0       	ldi	r25, 0x00	; 0
     a06:	0e 94 e5 20 	call	0x41ca	; 0x41ca <delay>
				
				nitriteValue = ScanColor() * 100;
     a0a:	0e 94 b4 03 	call	0x768	; 0x768 <_Z9ScanColorv>
     a0e:	c6 9f       	mul	r28, r22
     a10:	90 01       	movw	r18, r0
     a12:	c7 9f       	mul	r28, r23
     a14:	30 0d       	add	r19, r0
     a16:	11 24       	eor	r1, r1
     a18:	30 93 4f 02 	sts	0x024F, r19	; 0x80024f <nitriteValue+0x1>
     a1c:	20 93 4e 02 	sts	0x024E, r18	; 0x80024e <nitriteValue>
			}
			setLED(Off);	  
     a20:	40 91 5a 02 	lds	r20, 0x025A	; 0x80025a <Off>
     a24:	50 91 5b 02 	lds	r21, 0x025B	; 0x80025b <Off+0x1>
     a28:	60 91 5c 02 	lds	r22, 0x025C	; 0x80025c <Off+0x2>
     a2c:	70 91 5d 02 	lds	r23, 0x025D	; 0x80025d <Off+0x3>
     a30:	80 91 5e 02 	lds	r24, 0x025E	; 0x80025e <Off+0x4>
     a34:	90 91 5f 02 	lds	r25, 0x025F	; 0x80025f <Off+0x5>
     a38:	0e 94 5e 04 	call	0x8bc	; 0x8bc <_Z6setLED8LEDColor>
			//xSemaphoreGive( xSerialSemaphoreColorSensor );
		}
		vTaskDelay(1); // 1 tick delay between reads for stability*/
     a3c:	81 e0       	ldi	r24, 0x01	; 1
     a3e:	90 e0       	ldi	r25, 0x00	; 0
     a40:	0e 94 4c 12 	call	0x2498	; 0x2498 <vTaskDelay>
void TaskColorSensor(void *pvParameters)
{
	(void) pvParameters;
  
	TickType_t xLastWakeTime = xTaskGetTickCount();
	for (;;) // A Task shall never return or exit.
     a44:	63 cf       	rjmp	.-314    	; 0x90c <_Z15TaskColorSensorPv+0x8>

00000a46 <_Z20TaskPHandTemperaturePv>:
}


// get pH and temp reading from sensors
void TaskPHandTemperature(void *pvParameters)
{
     a46:	cf 93       	push	r28
     a48:	df 93       	push	r29
     a4a:	00 d0       	rcall	.+0      	; 0xa4c <_Z20TaskPHandTemperaturePv+0x6>
     a4c:	cd b7       	in	r28, 0x3d	; 61
     a4e:	de b7       	in	r29, 0x3e	; 62
  (void) pvParameters;
  
  TickType_t xLastWakeTime = xTaskGetTickCount();
     a50:	0e 94 ef 10 	call	0x21de	; 0x21de <xTaskGetTickCount>
     a54:	9a 83       	std	Y+2, r25	; 0x02
     a56:	89 83       	std	Y+1, r24	; 0x01
  for (;;) // A Task shall never return or exit.
  {
	// Gets pH value
	//delay(500);
	setLED(Green);
     a58:	40 91 13 01 	lds	r20, 0x0113	; 0x800113 <Green>
     a5c:	50 91 14 01 	lds	r21, 0x0114	; 0x800114 <Green+0x1>
     a60:	60 91 15 01 	lds	r22, 0x0115	; 0x800115 <Green+0x2>
     a64:	70 91 16 01 	lds	r23, 0x0116	; 0x800116 <Green+0x3>
     a68:	80 91 17 01 	lds	r24, 0x0117	; 0x800117 <Green+0x4>
     a6c:	90 91 18 01 	lds	r25, 0x0118	; 0x800118 <Green+0x5>
     a70:	0e 94 5e 04 	call	0x8bc	; 0x8bc <_Z6setLED8LEDColor>
	//Serial.print("p\n");
	phValue = calcPH() * 100;
     a74:	0e 94 e5 08 	call	0x11ca	; 0x11ca <_Z6calcPHv>
     a78:	20 e0       	ldi	r18, 0x00	; 0
     a7a:	30 e0       	ldi	r19, 0x00	; 0
     a7c:	48 ec       	ldi	r20, 0xC8	; 200
     a7e:	52 e4       	ldi	r21, 0x42	; 66
     a80:	0e 94 7e 1c 	call	0x38fc	; 0x38fc <__mulsf3>
     a84:	0e 94 96 1b 	call	0x372c	; 0x372c <__fixsfsi>
     a88:	60 93 56 02 	sts	0x0256, r22	; 0x800256 <phValue>
     a8c:	70 93 57 02 	sts	0x0257, r23	; 0x800257 <phValue+0x1>
     a90:	80 93 58 02 	sts	0x0258, r24	; 0x800258 <phValue+0x2>
     a94:	90 93 59 02 	sts	0x0259, r25	; 0x800259 <phValue+0x3>
	//Serial.print("\npH Value:");
	//Serial.print(phValue);
	delay(250);
     a98:	6a ef       	ldi	r22, 0xFA	; 250
     a9a:	70 e0       	ldi	r23, 0x00	; 0
     a9c:	80 e0       	ldi	r24, 0x00	; 0
     a9e:	90 e0       	ldi	r25, 0x00	; 0
     aa0:	0e 94 e5 20 	call	0x41ca	; 0x41ca <delay>
	setLED(Off);
     aa4:	40 91 5a 02 	lds	r20, 0x025A	; 0x80025a <Off>
     aa8:	50 91 5b 02 	lds	r21, 0x025B	; 0x80025b <Off+0x1>
     aac:	60 91 5c 02 	lds	r22, 0x025C	; 0x80025c <Off+0x2>
     ab0:	70 91 5d 02 	lds	r23, 0x025D	; 0x80025d <Off+0x3>
     ab4:	80 91 5e 02 	lds	r24, 0x025E	; 0x80025e <Off+0x4>
     ab8:	90 91 5f 02 	lds	r25, 0x025F	; 0x80025f <Off+0x5>
     abc:	0e 94 5e 04 	call	0x8bc	; 0x8bc <_Z6setLED8LEDColor>
	
	setLED(Red);
     ac0:	40 91 19 01 	lds	r20, 0x0119	; 0x800119 <Red>
     ac4:	50 91 1a 01 	lds	r21, 0x011A	; 0x80011a <Red+0x1>
     ac8:	60 91 1b 01 	lds	r22, 0x011B	; 0x80011b <Red+0x2>
     acc:	70 91 1c 01 	lds	r23, 0x011C	; 0x80011c <Red+0x3>
     ad0:	80 91 1d 01 	lds	r24, 0x011D	; 0x80011d <Red+0x4>
     ad4:	90 91 1e 01 	lds	r25, 0x011E	; 0x80011e <Red+0x5>
     ad8:	0e 94 5e 04 	call	0x8bc	; 0x8bc <_Z6setLED8LEDColor>
	// Gets temperature value in Celsius
	tempValue = measureTemp() * 100;
     adc:	0e 94 c8 00 	call	0x190	; 0x190 <_Z11measureTempv>
     ae0:	20 e0       	ldi	r18, 0x00	; 0
     ae2:	30 e0       	ldi	r19, 0x00	; 0
     ae4:	48 ec       	ldi	r20, 0xC8	; 200
     ae6:	52 e4       	ldi	r21, 0x42	; 66
     ae8:	0e 94 7e 1c 	call	0x38fc	; 0x38fc <__mulsf3>
     aec:	0e 94 96 1b 	call	0x372c	; 0x372c <__fixsfsi>
     af0:	70 93 55 02 	sts	0x0255, r23	; 0x800255 <tempValue+0x1>
     af4:	60 93 54 02 	sts	0x0254, r22	; 0x800254 <tempValue>
	//Serial.print("t\n");
	//Serial.print(tempValue);
	
	delay(100);
     af8:	64 e6       	ldi	r22, 0x64	; 100
     afa:	70 e0       	ldi	r23, 0x00	; 0
     afc:	80 e0       	ldi	r24, 0x00	; 0
     afe:	90 e0       	ldi	r25, 0x00	; 0
     b00:	0e 94 e5 20 	call	0x41ca	; 0x41ca <delay>
	setLED(Off);
     b04:	40 91 5a 02 	lds	r20, 0x025A	; 0x80025a <Off>
     b08:	50 91 5b 02 	lds	r21, 0x025B	; 0x80025b <Off+0x1>
     b0c:	60 91 5c 02 	lds	r22, 0x025C	; 0x80025c <Off+0x2>
     b10:	70 91 5d 02 	lds	r23, 0x025D	; 0x80025d <Off+0x3>
     b14:	80 91 5e 02 	lds	r24, 0x025E	; 0x80025e <Off+0x4>
     b18:	90 91 5f 02 	lds	r25, 0x025F	; 0x80025f <Off+0x5>
     b1c:	0e 94 5e 04 	call	0x8bc	; 0x8bc <_Z6setLED8LEDColor>
    // check pH and temp every 15 min
    vTaskDelayUntil( &xLastWakeTime, 10000 / portTICK_PERIOD_MS );
     b20:	61 e7       	ldi	r22, 0x71	; 113
     b22:	72 e0       	ldi	r23, 0x02	; 2
     b24:	ce 01       	movw	r24, r28
     b26:	01 96       	adiw	r24, 0x01	; 1
     b28:	0e 94 14 12 	call	0x2428	; 0x2428 <vTaskDelayUntil>
     b2c:	95 cf       	rjmp	.-214    	; 0xa58 <_Z20TaskPHandTemperaturePv+0x12>

00000b2e <_Z8setupLEDv>:
}

void setupLED()
{
	pinMode(R_LED, OUTPUT);
     b2e:	61 e0       	ldi	r22, 0x01	; 1
     b30:	8f e0       	ldi	r24, 0x0F	; 15
     b32:	0e 94 0c 22 	call	0x4418	; 0x4418 <pinMode>
	pinMode(G_LED, OUTPUT);
     b36:	61 e0       	ldi	r22, 0x01	; 1
     b38:	80 e1       	ldi	r24, 0x10	; 16
     b3a:	0e 94 0c 22 	call	0x4418	; 0x4418 <pinMode>
	pinMode(B_LED, OUTPUT);
     b3e:	61 e0       	ldi	r22, 0x01	; 1
     b40:	81 e1       	ldi	r24, 0x11	; 17
     b42:	0e 94 0c 22 	call	0x4418	; 0x4418 <pinMode>
	setLED(Off);
     b46:	40 91 5a 02 	lds	r20, 0x025A	; 0x80025a <Off>
     b4a:	50 91 5b 02 	lds	r21, 0x025B	; 0x80025b <Off+0x1>
     b4e:	60 91 5c 02 	lds	r22, 0x025C	; 0x80025c <Off+0x2>
     b52:	70 91 5d 02 	lds	r23, 0x025D	; 0x80025d <Off+0x3>
     b56:	80 91 5e 02 	lds	r24, 0x025E	; 0x80025e <Off+0x4>
     b5a:	90 91 5f 02 	lds	r25, 0x025F	; 0x80025f <Off+0x5>
     b5e:	0c 94 5e 04 	jmp	0x8bc	; 0x8bc <_Z6setLED8LEDColor>

00000b62 <setup>:
TaskHandle_t xPHandTemperature;

SoftwareSerial serial(rxPin, txPin);

// the setup function runs once when you press reset or power the board
void setup() {  
     b62:	ef 92       	push	r14
     b64:	ff 92       	push	r15
     b66:	0f 93       	push	r16
	// initialize serial communication at 115200 bits per second:
	serial.begin(115200);
     b68:	40 e0       	ldi	r20, 0x00	; 0
     b6a:	52 ec       	ldi	r21, 0xC2	; 194
     b6c:	61 e0       	ldi	r22, 0x01	; 1
     b6e:	70 e0       	ldi	r23, 0x00	; 0
     b70:	86 e2       	ldi	r24, 0x26	; 38
     b72:	92 e0       	ldi	r25, 0x02	; 2
     b74:	0e 94 24 1a 	call	0x3448	; 0x3448 <_ZN14SoftwareSerial5beginEl>
	pinMode(wifiRst, OUTPUT);
     b78:	61 e0       	ldi	r22, 0x01	; 1
     b7a:	8a e0       	ldi	r24, 0x0A	; 10
     b7c:	0e 94 0c 22 	call	0x4418	; 0x4418 <pinMode>
  public:
    inline HardwareSerial(
      volatile uint8_t *ubrrh, volatile uint8_t *ubrrl,
      volatile uint8_t *ucsra, volatile uint8_t *ucsrb,
      volatile uint8_t *ucsrc, volatile uint8_t *udr);
    void begin(unsigned long baud) { begin(baud, SERIAL_8N1); }
     b80:	26 e0       	ldi	r18, 0x06	; 6
     b82:	40 e0       	ldi	r20, 0x00	; 0
     b84:	52 ec       	ldi	r21, 0xC2	; 194
     b86:	61 e0       	ldi	r22, 0x01	; 1
     b88:	70 e0       	ldi	r23, 0x00	; 0
     b8a:	83 e3       	ldi	r24, 0x33	; 51
     b8c:	94 e0       	ldi	r25, 0x04	; 4
     b8e:	0e 94 c7 1d 	call	0x3b8e	; 0x3b8e <_ZN14HardwareSerial5beginEmh>
		; // wait for serial port to connect. Needed for native USB, on LEONARDO, MICRO, YUN, and other 32u4 based boards.
	}
  
	// initialize Wifi module (Maybe?)
	// drive Wifi Enable pin High
	digitalWrite(wifiRst, HIGH);
     b92:	61 e0       	ldi	r22, 0x01	; 1
     b94:	8a e0       	ldi	r24, 0x0A	; 10
     b96:	0e 94 48 22 	call	0x4490	; 0x4490 <digitalWrite>
	// load test strip color data and initialize indicator LED
	CS.begin();
     b9a:	80 e6       	ldi	r24, 0x60	; 96
     b9c:	92 e0       	ldi	r25, 0x02	; 2
     b9e:	0e 94 35 17 	call	0x2e6a	; 0x2e6a <_ZN9MD_TCS2305beginEv>
	addColors();
     ba2:	0e 94 4b 01 	call	0x296	; 0x296 <_Z9addColorsv>
	setupLED();
     ba6:	0e 94 97 05 	call	0xb2e	; 0xb2e <_Z8setupLEDv>
	//Serial.println("Starting setup");
	
	setLED(Blue);
     baa:	40 91 0d 01 	lds	r20, 0x010D	; 0x80010d <Blue>
     bae:	50 91 0e 01 	lds	r21, 0x010E	; 0x80010e <Blue+0x1>
     bb2:	60 91 0f 01 	lds	r22, 0x010F	; 0x80010f <Blue+0x2>
     bb6:	70 91 10 01 	lds	r23, 0x0110	; 0x800110 <Blue+0x3>
     bba:	80 91 11 01 	lds	r24, 0x0111	; 0x800111 <Blue+0x4>
     bbe:	90 91 12 01 	lds	r25, 0x0112	; 0x800112 <Blue+0x5>
     bc2:	0e 94 5e 04 	call	0x8bc	; 0x8bc <_Z6setLED8LEDColor>
  
	// initialize pH sensor
	//phInit();
 
	// TODO: Not sure how Wifi module indicates that it is getting data - replace that with the interrupt from pin2 
	attachInterrupt(digitalPinToInterrupt(2), fromWifi, RISING);
     bc6:	43 e0       	ldi	r20, 0x03	; 3
     bc8:	50 e0       	ldi	r21, 0x00	; 0
     bca:	64 e5       	ldi	r22, 0x54	; 84
     bcc:	76 e0       	ldi	r23, 0x06	; 6
     bce:	80 e0       	ldi	r24, 0x00	; 0
     bd0:	0e 94 08 20 	call	0x4010	; 0x4010 <attachInterrupt>
	
	if (xSerialSemaphoreColorSensor == NULL)
     bd4:	80 91 49 02 	lds	r24, 0x0249	; 0x800249 <xSerialSemaphoreColorSensor>
     bd8:	90 91 4a 02 	lds	r25, 0x024A	; 0x80024a <xSerialSemaphoreColorSensor+0x1>
     bdc:	89 2b       	or	r24, r25
     bde:	91 f4       	brne	.+36     	; 0xc04 <setup+0xa2>
	{
		//xSerialSemaphoreColorSensor = xSemaphoreCreateBinary();
		vSemaphoreCreateBinary(xSerialSemaphoreColorSensor);
     be0:	43 e0       	ldi	r20, 0x03	; 3
     be2:	60 e0       	ldi	r22, 0x00	; 0
     be4:	81 e0       	ldi	r24, 0x01	; 1
     be6:	0e 94 41 0c 	call	0x1882	; 0x1882 <xQueueGenericCreate>
     bea:	90 93 4a 02 	sts	0x024A, r25	; 0x80024a <xSerialSemaphoreColorSensor+0x1>
     bee:	80 93 49 02 	sts	0x0249, r24	; 0x800249 <xSerialSemaphoreColorSensor>
     bf2:	00 97       	sbiw	r24, 0x00	; 0
     bf4:	39 f0       	breq	.+14     	; 0xc04 <setup+0xa2>
     bf6:	20 e0       	ldi	r18, 0x00	; 0
     bf8:	40 e0       	ldi	r20, 0x00	; 0
     bfa:	50 e0       	ldi	r21, 0x00	; 0
     bfc:	60 e0       	ldi	r22, 0x00	; 0
     bfe:	70 e0       	ldi	r23, 0x00	; 0
     c00:	0e 94 69 0c 	call	0x18d2	; 0x18d2 <xQueueGenericSend>
	TaskColorSensor
	,  (const portCHAR *)"ColorSensor"
	,  128
	,  NULL
	,  2
	,  &xColorSensor );
     c04:	87 e4       	ldi	r24, 0x47	; 71
     c06:	e8 2e       	mov	r14, r24
     c08:	82 e0       	ldi	r24, 0x02	; 2
     c0a:	f8 2e       	mov	r15, r24
     c0c:	02 e0       	ldi	r16, 0x02	; 2
     c0e:	20 e0       	ldi	r18, 0x00	; 0
     c10:	30 e0       	ldi	r19, 0x00	; 0
     c12:	40 e8       	ldi	r20, 0x80	; 128
     c14:	50 e0       	ldi	r21, 0x00	; 0
     c16:	6f e8       	ldi	r22, 0x8F	; 143
     c18:	71 e0       	ldi	r23, 0x01	; 1
     c1a:	82 e8       	ldi	r24, 0x82	; 130
     c1c:	94 e0       	ldi	r25, 0x04	; 4
     c1e:	0e 94 66 0f 	call	0x1ecc	; 0x1ecc <xTaskCreate>
	TaskPHandTemperature
	,  (const portCHAR *) "PHandTemperature"
	,  128
	,  NULL
	,  2
	,  &xPHandTemperature );
     c22:	95 e4       	ldi	r25, 0x45	; 69
     c24:	e9 2e       	mov	r14, r25
     c26:	92 e0       	ldi	r25, 0x02	; 2
     c28:	f9 2e       	mov	r15, r25
     c2a:	20 e0       	ldi	r18, 0x00	; 0
     c2c:	30 e0       	ldi	r19, 0x00	; 0
     c2e:	40 e8       	ldi	r20, 0x80	; 128
     c30:	50 e0       	ldi	r21, 0x00	; 0
     c32:	6b e9       	ldi	r22, 0x9B	; 155
     c34:	71 e0       	ldi	r23, 0x01	; 1
     c36:	83 e2       	ldi	r24, 0x23	; 35
     c38:	95 e0       	ldi	r25, 0x05	; 5
     c3a:	0e 94 66 0f 	call	0x1ecc	; 0x1ecc <xTaskCreate>
	
	
	delay(1000);
     c3e:	68 ee       	ldi	r22, 0xE8	; 232
     c40:	73 e0       	ldi	r23, 0x03	; 3
     c42:	80 e0       	ldi	r24, 0x00	; 0
     c44:	90 e0       	ldi	r25, 0x00	; 0
     c46:	0e 94 e5 20 	call	0x41ca	; 0x41ca <delay>
	setLED(Off);
     c4a:	40 91 5a 02 	lds	r20, 0x025A	; 0x80025a <Off>
     c4e:	50 91 5b 02 	lds	r21, 0x025B	; 0x80025b <Off+0x1>
     c52:	60 91 5c 02 	lds	r22, 0x025C	; 0x80025c <Off+0x2>
     c56:	70 91 5d 02 	lds	r23, 0x025D	; 0x80025d <Off+0x3>
     c5a:	80 91 5e 02 	lds	r24, 0x025E	; 0x80025e <Off+0x4>
     c5e:	90 91 5f 02 	lds	r25, 0x025F	; 0x80025f <Off+0x5>
     c62:	0e 94 5e 04 	call	0x8bc	; 0x8bc <_Z6setLED8LEDColor>
	//Serial.print("Inside setup");

	// Now the task scheduler, which takes over control of scheduling individual tasks, is automatically started.
	vTaskStartScheduler();
}
     c66:	0f 91       	pop	r16
     c68:	ff 90       	pop	r15
     c6a:	ef 90       	pop	r14
	delay(1000);
	setLED(Off);
	//Serial.print("Inside setup");

	// Now the task scheduler, which takes over control of scheduling individual tasks, is automatically started.
	vTaskStartScheduler();
     c6c:	0c 94 bb 10 	jmp	0x2176	; 0x2176 <vTaskStartScheduler>

00000c70 <loop>:
}

void loop()
{
     c70:	08 95       	ret

00000c72 <_GLOBAL__sub_I_ds>:
    bool LastDeviceFlag;
#endif

  public:
    OneWire() { }
    OneWire(uint8_t pin) { begin(pin); }
     c72:	66 e0       	ldi	r22, 0x06	; 6
     c74:	8e e5       	ldi	r24, 0x5E	; 94
     c76:	93 e0       	ldi	r25, 0x03	; 3
     c78:	0e 94 23 08 	call	0x1046	; 0x1046 <_ZN7OneWire5beginEh>

uint8_t greenScanned;
uint8_t redScanned;
uint8_t blueScanned;

MD_TCS230  CS(S2, S3, OE);
     c7c:	28 e0       	ldi	r18, 0x08	; 8
     c7e:	4d e0       	ldi	r20, 0x0D	; 13
     c80:	6c e0       	ldi	r22, 0x0C	; 12
     c82:	80 e6       	ldi	r24, 0x60	; 96
     c84:	92 e0       	ldi	r25, 0x02	; 2
     c86:	0e 94 c3 16 	call	0x2d86	; 0x2d86 <_ZN9MD_TCS230C1Ehhh>
SemaphoreHandle_t xSerialSemaphoreColorSensor;

TaskHandle_t xColorSensor;
TaskHandle_t xPHandTemperature;

SoftwareSerial serial(rxPin, txPin);
     c8a:	20 e0       	ldi	r18, 0x00	; 0
     c8c:	43 e0       	ldi	r20, 0x03	; 3
     c8e:	62 e0       	ldi	r22, 0x02	; 2
     c90:	86 e2       	ldi	r24, 0x26	; 38
     c92:	92 e0       	ldi	r25, 0x02	; 2
     c94:	0c 94 f9 19 	jmp	0x33f2	; 0x33f2 <_ZN14SoftwareSerialC1Ehhb>

00000c98 <_GLOBAL__sub_D_ds>:
     c98:	86 e2       	ldi	r24, 0x26	; 38
     c9a:	92 e0       	ldi	r25, 0x02	; 2
     c9c:	0e 94 a0 19 	call	0x3340	; 0x3340 <_ZN14SoftwareSerialD1Ev>
     ca0:	80 e6       	ldi	r24, 0x60	; 96
     ca2:	92 e0       	ldi	r25, 0x02	; 2
     ca4:	0c 94 d7 16 	jmp	0x2dae	; 0x2dae <_ZN9MD_TCS230D1Ev>

00000ca8 <_Z8fromWifiv>:
  }
}


void fromWifi()
{
     ca8:	cf 93       	push	r28
	int i = 0;
	char action = '\0';
	// check for data from Wifi
	if (serial.available())
     caa:	86 e2       	ldi	r24, 0x26	; 38
     cac:	92 e0       	ldi	r25, 0x02	; 2
     cae:	0e 94 cf 18 	call	0x319e	; 0x319e <_ZN14SoftwareSerial9availableEv>
     cb2:	89 2b       	or	r24, r25
     cb4:	99 f0       	breq	.+38     	; 0xcdc <_Z8fromWifiv+0x34>
	{
		delay(100); // allows all serial sent to be received together
     cb6:	64 e6       	ldi	r22, 0x64	; 100
     cb8:	70 e0       	ldi	r23, 0x00	; 0
     cba:	80 e0       	ldi	r24, 0x00	; 0
     cbc:	90 e0       	ldi	r25, 0x00	; 0
     cbe:	0e 94 e5 20 	call	0x41ca	; 0x41ca <delay>


void fromWifi()
{
	int i = 0;
	char action = '\0';
     cc2:	c0 e0       	ldi	r28, 0x00	; 0
	// check for data from Wifi
	if (serial.available())
	{
		delay(100); // allows all serial sent to be received together
		while (serial.available())
     cc4:	86 e2       	ldi	r24, 0x26	; 38
     cc6:	92 e0       	ldi	r25, 0x02	; 2
     cc8:	0e 94 cf 18 	call	0x319e	; 0x319e <_ZN14SoftwareSerial9availableEv>
     ccc:	89 2b       	or	r24, r25
     cce:	39 f0       	breq	.+14     	; 0xcde <_Z8fromWifiv+0x36>
		{
			action = serial.read();
     cd0:	86 e2       	ldi	r24, 0x26	; 38
     cd2:	92 e0       	ldi	r25, 0x02	; 2
     cd4:	0e 94 45 18 	call	0x308a	; 0x308a <_ZN14SoftwareSerial4readEv>
     cd8:	c8 2f       	mov	r28, r24
	char action = '\0';
	// check for data from Wifi
	if (serial.available())
	{
		delay(100); // allows all serial sent to be received together
		while (serial.available())
     cda:	f4 cf       	rjmp	.-24     	; 0xcc4 <_Z8fromWifiv+0x1c>


void fromWifi()
{
	int i = 0;
	char action = '\0';
     cdc:	c0 e0       	ldi	r28, 0x00	; 0
		while (serial.available())
		{
			action = serial.read();
		}
	}
	if (alreadyStarted){
     cde:	80 91 4d 02 	lds	r24, 0x024D	; 0x80024d <alreadyStarted>
     ce2:	88 23       	and	r24, r24
     ce4:	69 f0       	breq	.+26     	; 0xd00 <_Z8fromWifiv+0x58>
		action = 'a';
		//Serial.println("already started");
		++count;
     ce6:	80 91 4b 02 	lds	r24, 0x024B	; 0x80024b <count>
     cea:	90 91 4c 02 	lds	r25, 0x024C	; 0x80024c <count+0x1>
     cee:	01 96       	adiw	r24, 0x01	; 1
		//Serial.println(count);
		if (count == 10)
     cf0:	8a 30       	cpi	r24, 0x0A	; 10
     cf2:	91 05       	cpc	r25, r1
     cf4:	29 f5       	brne	.+74     	; 0xd40 <_Z8fromWifiv+0x98>
		{
			count = 0;
     cf6:	10 92 4c 02 	sts	0x024C, r1	; 0x80024c <count+0x1>
     cfa:	10 92 4b 02 	sts	0x024B, r1	; 0x80024b <count>
     cfe:	08 c0       	rjmp	.+16     	; 0xd10 <_Z8fromWifiv+0x68>
			action = 'p';
		}
	}

	switch(action)
     d00:	ce 36       	cpi	r28, 0x6E	; 110
     d02:	a9 f0       	breq	.+42     	; 0xd2e <_Z8fromWifiv+0x86>
     d04:	c0 37       	cpi	r28, 0x70	; 112
     d06:	21 f0       	breq	.+8      	; 0xd10 <_Z8fromWifiv+0x68>
     d08:	c1 36       	cpi	r28, 0x61	; 97
     d0a:	09 f0       	breq	.+2      	; 0xd0e <_Z8fromWifiv+0x66>
     d0c:	82 c0       	rjmp	.+260    	; 0xe12 <_Z8fromWifiv+0x16a>
     d0e:	1c c0       	rjmp	.+56     	; 0xd48 <_Z8fromWifiv+0xa0>
	{
	case 'p':
	{
		//Serial.println("inside case color");
		colorToRead = 'a';
     d10:	81 e6       	ldi	r24, 0x61	; 97
     d12:	80 93 06 01 	sts	0x0106, r24	; 0x800106 <colorToRead>
		alreadyStarted = true;
     d16:	81 e0       	ldi	r24, 0x01	; 1
     d18:	80 93 4d 02 	sts	0x024D, r24	; 0x80024d <alreadyStarted>
		//static BaseType_t xHigherPriorityTaskWoken;
		//xHigherPriorityTaskWoken = pdFALSE;

		xSemaphoreGiveFromISR(xSerialSemaphoreColorSensor, pdFALSE);
     d1c:	60 e0       	ldi	r22, 0x00	; 0
     d1e:	70 e0       	ldi	r23, 0x00	; 0
     d20:	80 91 49 02 	lds	r24, 0x0249	; 0x800249 <xSerialSemaphoreColorSensor>
     d24:	90 91 4a 02 	lds	r25, 0x024A	; 0x80024a <xSerialSemaphoreColorSensor+0x1>
		break;
	}
	default:
		break;
	}
}
     d28:	cf 91       	pop	r28
		colorToRead = 'a';
		alreadyStarted = true;
		//static BaseType_t xHigherPriorityTaskWoken;
		//xHigherPriorityTaskWoken = pdFALSE;

		xSemaphoreGiveFromISR(xSerialSemaphoreColorSensor, pdFALSE);
     d2a:	0c 94 2e 0d 	jmp	0x1a5c	; 0x1a5c <xQueueGiveFromISR>
		setLED(Off);*/
		break;
	}
	case 'n':
	{
		colorToRead = 'n';
     d2e:	c0 93 06 01 	sts	0x0106, r28	; 0x800106 <colorToRead>
		vTaskResume(xColorSensor);
     d32:	80 91 47 02 	lds	r24, 0x0247	; 0x800247 <xColorSensor>
     d36:	90 91 48 02 	lds	r25, 0x0248	; 0x800248 <xColorSensor+0x1>
		break;
	}
	default:
		break;
	}
}
     d3a:	cf 91       	pop	r28
		break;
	}
	case 'n':
	{
		colorToRead = 'n';
		vTaskResume(xColorSensor);
     d3c:	0c 94 72 10 	jmp	0x20e4	; 0x20e4 <vTaskResume>
		}
	}
	if (alreadyStarted){
		action = 'a';
		//Serial.println("already started");
		++count;
     d40:	90 93 4c 02 	sts	0x024C, r25	; 0x80024c <count+0x1>
     d44:	80 93 4b 02 	sts	0x024B, r24	; 0x80024b <count>
		vTaskResume(xColorSensor);
		break;
	}
	case 'a':
	{
		serial.println("inside case print");
     d48:	6c ea       	ldi	r22, 0xAC	; 172
     d4a:	71 e0       	ldi	r23, 0x01	; 1
     d4c:	86 e2       	ldi	r24, 0x26	; 38
     d4e:	92 e0       	ldi	r25, 0x02	; 2
     d50:	0e 94 25 1f 	call	0x3e4a	; 0x3e4a <_ZN5Print7printlnEPKc>
		setLED(Blue);
     d54:	40 91 0d 01 	lds	r20, 0x010D	; 0x80010d <Blue>
     d58:	50 91 0e 01 	lds	r21, 0x010E	; 0x80010e <Blue+0x1>
     d5c:	60 91 0f 01 	lds	r22, 0x010F	; 0x80010f <Blue+0x2>
     d60:	70 91 10 01 	lds	r23, 0x0110	; 0x800110 <Blue+0x3>
     d64:	80 91 11 01 	lds	r24, 0x0111	; 0x800111 <Blue+0x4>
     d68:	90 91 12 01 	lds	r25, 0x0112	; 0x800112 <Blue+0x5>
     d6c:	0e 94 5e 04 	call	0x8bc	; 0x8bc <_Z6setLED8LEDColor>
		serial.write("ph:");
     d70:	6e eb       	ldi	r22, 0xBE	; 190
     d72:	71 e0       	ldi	r23, 0x01	; 1
     d74:	86 e2       	ldi	r24, 0x26	; 38
     d76:	92 e0       	ldi	r25, 0x02	; 2
     d78:	0e 94 b3 00 	call	0x166	; 0x166 <_ZN5Print5writeEPKc>
		serial.write(phValue);
     d7c:	60 91 56 02 	lds	r22, 0x0256	; 0x800256 <phValue>
     d80:	86 e2       	ldi	r24, 0x26	; 38
     d82:	92 e0       	ldi	r25, 0x02	; 2
     d84:	0e 94 66 18 	call	0x30cc	; 0x30cc <_ZN14SoftwareSerial5writeEh>
		serial.write("temp:");
     d88:	62 ec       	ldi	r22, 0xC2	; 194
     d8a:	71 e0       	ldi	r23, 0x01	; 1
     d8c:	86 e2       	ldi	r24, 0x26	; 38
     d8e:	92 e0       	ldi	r25, 0x02	; 2
     d90:	0e 94 b3 00 	call	0x166	; 0x166 <_ZN5Print5writeEPKc>
		serial.write(tempValue);
     d94:	60 91 54 02 	lds	r22, 0x0254	; 0x800254 <tempValue>
     d98:	86 e2       	ldi	r24, 0x26	; 38
     d9a:	92 e0       	ldi	r25, 0x02	; 2
     d9c:	0e 94 66 18 	call	0x30cc	; 0x30cc <_ZN14SoftwareSerial5writeEh>
		serial.write("ammonia:");
     da0:	68 ec       	ldi	r22, 0xC8	; 200
     da2:	71 e0       	ldi	r23, 0x01	; 1
     da4:	86 e2       	ldi	r24, 0x26	; 38
     da6:	92 e0       	ldi	r25, 0x02	; 2
     da8:	0e 94 b3 00 	call	0x166	; 0x166 <_ZN5Print5writeEPKc>
		serial.write(ammoniaValue);
     dac:	60 91 52 02 	lds	r22, 0x0252	; 0x800252 <ammoniaValue>
     db0:	86 e2       	ldi	r24, 0x26	; 38
     db2:	92 e0       	ldi	r25, 0x02	; 2
     db4:	0e 94 66 18 	call	0x30cc	; 0x30cc <_ZN14SoftwareSerial5writeEh>
		serial.write("nitrite:");
     db8:	61 ed       	ldi	r22, 0xD1	; 209
     dba:	71 e0       	ldi	r23, 0x01	; 1
     dbc:	86 e2       	ldi	r24, 0x26	; 38
     dbe:	92 e0       	ldi	r25, 0x02	; 2
     dc0:	0e 94 b3 00 	call	0x166	; 0x166 <_ZN5Print5writeEPKc>
		serial.write(nitriteValue);
     dc4:	60 91 4e 02 	lds	r22, 0x024E	; 0x80024e <nitriteValue>
     dc8:	86 e2       	ldi	r24, 0x26	; 38
     dca:	92 e0       	ldi	r25, 0x02	; 2
     dcc:	0e 94 66 18 	call	0x30cc	; 0x30cc <_ZN14SoftwareSerial5writeEh>
		serial.write("nitrate:");
     dd0:	6a ed       	ldi	r22, 0xDA	; 218
     dd2:	71 e0       	ldi	r23, 0x01	; 1
     dd4:	86 e2       	ldi	r24, 0x26	; 38
     dd6:	92 e0       	ldi	r25, 0x02	; 2
     dd8:	0e 94 b3 00 	call	0x166	; 0x166 <_ZN5Print5writeEPKc>
		serial.write(nitrateValue);
     ddc:	60 91 50 02 	lds	r22, 0x0250	; 0x800250 <nitrateValue>
     de0:	86 e2       	ldi	r24, 0x26	; 38
     de2:	92 e0       	ldi	r25, 0x02	; 2
     de4:	0e 94 66 18 	call	0x30cc	; 0x30cc <_ZN14SoftwareSerial5writeEh>
		delay(200);
     de8:	68 ec       	ldi	r22, 0xC8	; 200
     dea:	70 e0       	ldi	r23, 0x00	; 0
     dec:	80 e0       	ldi	r24, 0x00	; 0
     dee:	90 e0       	ldi	r25, 0x00	; 0
     df0:	0e 94 e5 20 	call	0x41ca	; 0x41ca <delay>
		setLED(Off);
     df4:	40 91 5a 02 	lds	r20, 0x025A	; 0x80025a <Off>
     df8:	50 91 5b 02 	lds	r21, 0x025B	; 0x80025b <Off+0x1>
     dfc:	60 91 5c 02 	lds	r22, 0x025C	; 0x80025c <Off+0x2>
     e00:	70 91 5d 02 	lds	r23, 0x025D	; 0x80025d <Off+0x3>
     e04:	80 91 5e 02 	lds	r24, 0x025E	; 0x80025e <Off+0x4>
     e08:	90 91 5f 02 	lds	r25, 0x025F	; 0x80025f <Off+0x5>
		break;
	}
	default:
		break;
	}
}
     e0c:	cf 91       	pop	r28
		serial.write("nitrite:");
		serial.write(nitriteValue);
		serial.write("nitrate:");
		serial.write(nitrateValue);
		delay(200);
		setLED(Off);
     e0e:	0c 94 5e 04 	jmp	0x8bc	; 0x8bc <_Z6setLED8LEDColor>
		break;
	}
	default:
		break;
	}
}
     e12:	cf 91       	pop	r28
     e14:	08 95       	ret

00000e16 <_ZN7OneWire5resetEv>:
   ROM_NO[0] = family_code;
   for (uint8_t i = 1; i < 8; i++)
      ROM_NO[i] = 0;
   LastDiscrepancy = 64;
   LastFamilyDiscrepancy = 0;
   LastDeviceFlag = false;
     e16:	ff 92       	push	r15
     e18:	0f 93       	push	r16
     e1a:	1f 93       	push	r17
     e1c:	cf 93       	push	r28
     e1e:	df 93       	push	r29
     e20:	fc 01       	movw	r30, r24
     e22:	f0 80       	ld	r15, Z
     e24:	c1 81       	ldd	r28, Z+1	; 0x01
     e26:	d2 81       	ldd	r29, Z+2	; 0x02
     e28:	f8 94       	cli
     e2a:	89 81       	ldd	r24, Y+1	; 0x01
     e2c:	0f 2d       	mov	r16, r15
     e2e:	00 95       	com	r16
     e30:	80 23       	and	r24, r16
     e32:	89 83       	std	Y+1, r24	; 0x01
     e34:	78 94       	sei
     e36:	1d e7       	ldi	r17, 0x7D	; 125
     e38:	11 50       	subi	r17, 0x01	; 1
     e3a:	29 f1       	breq	.+74     	; 0xe86 <_ZN7OneWire5resetEv+0x70>
     e3c:	82 e0       	ldi	r24, 0x02	; 2
     e3e:	90 e0       	ldi	r25, 0x00	; 0
     e40:	0e 94 21 21 	call	0x4242	; 0x4242 <delayMicroseconds>
     e44:	88 81       	ld	r24, Y
     e46:	8f 21       	and	r24, r15
     e48:	b9 f3       	breq	.-18     	; 0xe38 <_ZN7OneWire5resetEv+0x22>
     e4a:	f8 94       	cli
     e4c:	8a 81       	ldd	r24, Y+2	; 0x02
     e4e:	80 23       	and	r24, r16
     e50:	8a 83       	std	Y+2, r24	; 0x02
     e52:	89 81       	ldd	r24, Y+1	; 0x01
     e54:	8f 29       	or	r24, r15
     e56:	89 83       	std	Y+1, r24	; 0x01
     e58:	78 94       	sei
     e5a:	80 ee       	ldi	r24, 0xE0	; 224
     e5c:	91 e0       	ldi	r25, 0x01	; 1
     e5e:	0e 94 21 21 	call	0x4242	; 0x4242 <delayMicroseconds>
     e62:	f8 94       	cli
     e64:	89 81       	ldd	r24, Y+1	; 0x01
     e66:	08 23       	and	r16, r24
     e68:	09 83       	std	Y+1, r16	; 0x01
     e6a:	86 e4       	ldi	r24, 0x46	; 70
     e6c:	90 e0       	ldi	r25, 0x00	; 0
     e6e:	0e 94 21 21 	call	0x4242	; 0x4242 <delayMicroseconds>
     e72:	88 81       	ld	r24, Y
     e74:	f8 22       	and	r15, r24
     e76:	11 e0       	ldi	r17, 0x01	; 1
     e78:	09 f0       	breq	.+2      	; 0xe7c <_ZN7OneWire5resetEv+0x66>
     e7a:	10 e0       	ldi	r17, 0x00	; 0
     e7c:	78 94       	sei
     e7e:	8a e9       	ldi	r24, 0x9A	; 154
     e80:	91 e0       	ldi	r25, 0x01	; 1
     e82:	0e 94 21 21 	call	0x4242	; 0x4242 <delayMicroseconds>
     e86:	81 2f       	mov	r24, r17
     e88:	df 91       	pop	r29
     e8a:	cf 91       	pop	r28
     e8c:	1f 91       	pop	r17
     e8e:	0f 91       	pop	r16
     e90:	ff 90       	pop	r15
     e92:	08 95       	ret

00000e94 <_ZN7OneWire9write_bitEh>:
     e94:	1f 93       	push	r17
     e96:	cf 93       	push	r28
     e98:	df 93       	push	r29
     e9a:	fc 01       	movw	r30, r24
     e9c:	10 81       	ld	r17, Z
     e9e:	c1 81       	ldd	r28, Z+1	; 0x01
     ea0:	d2 81       	ldd	r29, Z+2	; 0x02
     ea2:	81 2f       	mov	r24, r17
     ea4:	80 95       	com	r24
     ea6:	60 ff       	sbrs	r22, 0
     ea8:	12 c0       	rjmp	.+36     	; 0xece <_ZN7OneWire9write_bitEh+0x3a>
     eaa:	f8 94       	cli
     eac:	9a 81       	ldd	r25, Y+2	; 0x02
     eae:	89 23       	and	r24, r25
     eb0:	8a 83       	std	Y+2, r24	; 0x02
     eb2:	89 81       	ldd	r24, Y+1	; 0x01
     eb4:	81 2b       	or	r24, r17
     eb6:	89 83       	std	Y+1, r24	; 0x01
     eb8:	8a e0       	ldi	r24, 0x0A	; 10
     eba:	90 e0       	ldi	r25, 0x00	; 0
     ebc:	0e 94 21 21 	call	0x4242	; 0x4242 <delayMicroseconds>
     ec0:	8a 81       	ldd	r24, Y+2	; 0x02
     ec2:	18 2b       	or	r17, r24
     ec4:	1a 83       	std	Y+2, r17	; 0x02
     ec6:	78 94       	sei
     ec8:	87 e3       	ldi	r24, 0x37	; 55
     eca:	90 e0       	ldi	r25, 0x00	; 0
     ecc:	11 c0       	rjmp	.+34     	; 0xef0 <_ZN7OneWire9write_bitEh+0x5c>
     ece:	f8 94       	cli
     ed0:	9a 81       	ldd	r25, Y+2	; 0x02
     ed2:	89 23       	and	r24, r25
     ed4:	8a 83       	std	Y+2, r24	; 0x02
     ed6:	89 81       	ldd	r24, Y+1	; 0x01
     ed8:	81 2b       	or	r24, r17
     eda:	89 83       	std	Y+1, r24	; 0x01
     edc:	81 e4       	ldi	r24, 0x41	; 65
     ede:	90 e0       	ldi	r25, 0x00	; 0
     ee0:	0e 94 21 21 	call	0x4242	; 0x4242 <delayMicroseconds>
     ee4:	8a 81       	ldd	r24, Y+2	; 0x02
     ee6:	18 2b       	or	r17, r24
     ee8:	1a 83       	std	Y+2, r17	; 0x02
     eea:	78 94       	sei
     eec:	85 e0       	ldi	r24, 0x05	; 5
     eee:	90 e0       	ldi	r25, 0x00	; 0
     ef0:	df 91       	pop	r29
     ef2:	cf 91       	pop	r28
     ef4:	1f 91       	pop	r17
     ef6:	0c 94 21 21 	jmp	0x4242	; 0x4242 <delayMicroseconds>

00000efa <_ZN7OneWire8read_bitEv>:
     efa:	0f 93       	push	r16
     efc:	1f 93       	push	r17
     efe:	cf 93       	push	r28
     f00:	df 93       	push	r29
     f02:	fc 01       	movw	r30, r24
     f04:	00 81       	ld	r16, Z
     f06:	c1 81       	ldd	r28, Z+1	; 0x01
     f08:	d2 81       	ldd	r29, Z+2	; 0x02
     f0a:	f8 94       	cli
     f0c:	89 81       	ldd	r24, Y+1	; 0x01
     f0e:	80 2b       	or	r24, r16
     f10:	89 83       	std	Y+1, r24	; 0x01
     f12:	8a 81       	ldd	r24, Y+2	; 0x02
     f14:	10 2f       	mov	r17, r16
     f16:	10 95       	com	r17
     f18:	81 23       	and	r24, r17
     f1a:	8a 83       	std	Y+2, r24	; 0x02
     f1c:	83 e0       	ldi	r24, 0x03	; 3
     f1e:	90 e0       	ldi	r25, 0x00	; 0
     f20:	0e 94 21 21 	call	0x4242	; 0x4242 <delayMicroseconds>
     f24:	89 81       	ldd	r24, Y+1	; 0x01
     f26:	18 23       	and	r17, r24
     f28:	19 83       	std	Y+1, r17	; 0x01
     f2a:	8a e0       	ldi	r24, 0x0A	; 10
     f2c:	90 e0       	ldi	r25, 0x00	; 0
     f2e:	0e 94 21 21 	call	0x4242	; 0x4242 <delayMicroseconds>
     f32:	c8 81       	ld	r28, Y
     f34:	78 94       	sei
     f36:	85 e3       	ldi	r24, 0x35	; 53
     f38:	90 e0       	ldi	r25, 0x00	; 0
     f3a:	0e 94 21 21 	call	0x4242	; 0x4242 <delayMicroseconds>
     f3e:	c0 23       	and	r28, r16
     f40:	81 e0       	ldi	r24, 0x01	; 1
     f42:	09 f4       	brne	.+2      	; 0xf46 <_ZN7OneWire8read_bitEv+0x4c>
     f44:	80 e0       	ldi	r24, 0x00	; 0
     f46:	df 91       	pop	r29
     f48:	cf 91       	pop	r28
     f4a:	1f 91       	pop	r17
     f4c:	0f 91       	pop	r16
     f4e:	08 95       	ret

00000f50 <_ZN7OneWire5writeEhh>:
     f50:	df 92       	push	r13
     f52:	ef 92       	push	r14
     f54:	ff 92       	push	r15
     f56:	0f 93       	push	r16
     f58:	1f 93       	push	r17
     f5a:	cf 93       	push	r28
     f5c:	df 93       	push	r29
     f5e:	ec 01       	movw	r28, r24
     f60:	d6 2e       	mov	r13, r22
     f62:	e4 2e       	mov	r14, r20
     f64:	08 e0       	ldi	r16, 0x08	; 8
     f66:	10 e0       	ldi	r17, 0x00	; 0
     f68:	ff 24       	eor	r15, r15
     f6a:	f3 94       	inc	r15
     f6c:	61 e0       	ldi	r22, 0x01	; 1
     f6e:	8d 2d       	mov	r24, r13
     f70:	8f 21       	and	r24, r15
     f72:	09 f4       	brne	.+2      	; 0xf76 <_ZN7OneWire5writeEhh+0x26>
     f74:	60 e0       	ldi	r22, 0x00	; 0
     f76:	ce 01       	movw	r24, r28
     f78:	0e 94 4a 07 	call	0xe94	; 0xe94 <_ZN7OneWire9write_bitEh>
     f7c:	ff 0c       	add	r15, r15
     f7e:	01 50       	subi	r16, 0x01	; 1
     f80:	11 09       	sbc	r17, r1
     f82:	a1 f7       	brne	.-24     	; 0xf6c <_ZN7OneWire5writeEhh+0x1c>
     f84:	e1 10       	cpse	r14, r1
     f86:	10 c0       	rjmp	.+32     	; 0xfa8 <_ZN7OneWire5writeEhh+0x58>
     f88:	f8 94       	cli
     f8a:	e9 81       	ldd	r30, Y+1	; 0x01
     f8c:	fa 81       	ldd	r31, Y+2	; 0x02
     f8e:	91 81       	ldd	r25, Z+1	; 0x01
     f90:	88 81       	ld	r24, Y
     f92:	80 95       	com	r24
     f94:	89 23       	and	r24, r25
     f96:	81 83       	std	Z+1, r24	; 0x01
     f98:	e9 81       	ldd	r30, Y+1	; 0x01
     f9a:	fa 81       	ldd	r31, Y+2	; 0x02
     f9c:	92 81       	ldd	r25, Z+2	; 0x02
     f9e:	88 81       	ld	r24, Y
     fa0:	80 95       	com	r24
     fa2:	89 23       	and	r24, r25
     fa4:	82 83       	std	Z+2, r24	; 0x02
     fa6:	78 94       	sei
     fa8:	df 91       	pop	r29
     faa:	cf 91       	pop	r28
     fac:	1f 91       	pop	r17
     fae:	0f 91       	pop	r16
     fb0:	ff 90       	pop	r15
     fb2:	ef 90       	pop	r14
     fb4:	df 90       	pop	r13
     fb6:	08 95       	ret

00000fb8 <_ZN7OneWire4readEv>:
     fb8:	ef 92       	push	r14
     fba:	ff 92       	push	r15
     fbc:	0f 93       	push	r16
     fbe:	1f 93       	push	r17
     fc0:	cf 93       	push	r28
     fc2:	df 93       	push	r29
     fc4:	7c 01       	movw	r14, r24
     fc6:	08 e0       	ldi	r16, 0x08	; 8
     fc8:	10 e0       	ldi	r17, 0x00	; 0
     fca:	c0 e0       	ldi	r28, 0x00	; 0
     fcc:	d1 e0       	ldi	r29, 0x01	; 1
     fce:	c7 01       	movw	r24, r14
     fd0:	0e 94 7d 07 	call	0xefa	; 0xefa <_ZN7OneWire8read_bitEv>
     fd4:	81 11       	cpse	r24, r1
     fd6:	cd 2b       	or	r28, r29
     fd8:	dd 0f       	add	r29, r29
     fda:	01 50       	subi	r16, 0x01	; 1
     fdc:	11 09       	sbc	r17, r1
     fde:	b9 f7       	brne	.-18     	; 0xfce <_ZN7OneWire4readEv+0x16>
     fe0:	8c 2f       	mov	r24, r28
     fe2:	df 91       	pop	r29
     fe4:	cf 91       	pop	r28
     fe6:	1f 91       	pop	r17
     fe8:	0f 91       	pop	r16
     fea:	ff 90       	pop	r15
     fec:	ef 90       	pop	r14
     fee:	08 95       	ret

00000ff0 <_ZN7OneWire6selectEPKh>:
     ff0:	ef 92       	push	r14
     ff2:	ff 92       	push	r15
     ff4:	0f 93       	push	r16
     ff6:	1f 93       	push	r17
     ff8:	cf 93       	push	r28
     ffa:	df 93       	push	r29
     ffc:	8c 01       	movw	r16, r24
     ffe:	7b 01       	movw	r14, r22
    1000:	40 e0       	ldi	r20, 0x00	; 0
    1002:	65 e5       	ldi	r22, 0x55	; 85
    1004:	0e 94 a8 07 	call	0xf50	; 0xf50 <_ZN7OneWire5writeEhh>
    1008:	e7 01       	movw	r28, r14
    100a:	88 e0       	ldi	r24, 0x08	; 8
    100c:	e8 0e       	add	r14, r24
    100e:	f1 1c       	adc	r15, r1
    1010:	69 91       	ld	r22, Y+
    1012:	40 e0       	ldi	r20, 0x00	; 0
    1014:	c8 01       	movw	r24, r16
    1016:	0e 94 a8 07 	call	0xf50	; 0xf50 <_ZN7OneWire5writeEhh>
    101a:	ce 15       	cp	r28, r14
    101c:	df 05       	cpc	r29, r15
    101e:	c1 f7       	brne	.-16     	; 0x1010 <_ZN7OneWire6selectEPKh+0x20>
    1020:	df 91       	pop	r29
    1022:	cf 91       	pop	r28
    1024:	1f 91       	pop	r17
    1026:	0f 91       	pop	r16
    1028:	ff 90       	pop	r15
    102a:	ef 90       	pop	r14
    102c:	08 95       	ret

0000102e <_ZN7OneWire12reset_searchEv>:
    102e:	fc 01       	movw	r30, r24
    1030:	13 86       	std	Z+11, r1	; 0x0b
    1032:	15 86       	std	Z+13, r1	; 0x0d
    1034:	14 86       	std	Z+12, r1	; 0x0c
    1036:	dc 01       	movw	r26, r24
    1038:	1b 96       	adiw	r26, 0x0b	; 11
    103a:	33 96       	adiw	r30, 0x03	; 3
    103c:	1e 92       	st	-X, r1
    103e:	ae 17       	cp	r26, r30
    1040:	bf 07       	cpc	r27, r31
    1042:	e1 f7       	brne	.-8      	; 0x103c <_ZN7OneWire12reset_searchEv+0xe>
    1044:	08 95       	ret

00001046 <_ZN7OneWire5beginEh>:
    1046:	1f 93       	push	r17
    1048:	cf 93       	push	r28
    104a:	df 93       	push	r29
    104c:	ec 01       	movw	r28, r24
    104e:	16 2f       	mov	r17, r22
    1050:	60 e0       	ldi	r22, 0x00	; 0
    1052:	81 2f       	mov	r24, r17
    1054:	0e 94 0c 22 	call	0x4418	; 0x4418 <pinMode>
    1058:	61 2f       	mov	r22, r17
    105a:	70 e0       	ldi	r23, 0x00	; 0
    105c:	fb 01       	movw	r30, r22
    105e:	ea 53       	subi	r30, 0x3A	; 58
    1060:	ff 4f       	sbci	r31, 0xFF	; 255
    1062:	e4 91       	lpm	r30, Z
    1064:	e8 83       	st	Y, r30
    1066:	fb 01       	movw	r30, r22
    1068:	e6 52       	subi	r30, 0x26	; 38
    106a:	ff 4f       	sbci	r31, 0xFF	; 255
    106c:	e4 91       	lpm	r30, Z
    106e:	f0 e0       	ldi	r31, 0x00	; 0
    1070:	ee 0f       	add	r30, r30
    1072:	ff 1f       	adc	r31, r31
    1074:	e2 51       	subi	r30, 0x12	; 18
    1076:	ff 4f       	sbci	r31, 0xFF	; 255
    1078:	85 91       	lpm	r24, Z+
    107a:	94 91       	lpm	r25, Z
    107c:	9a 83       	std	Y+2, r25	; 0x02
    107e:	89 83       	std	Y+1, r24	; 0x01
    1080:	ce 01       	movw	r24, r28
    1082:	df 91       	pop	r29
    1084:	cf 91       	pop	r28
    1086:	1f 91       	pop	r17
    1088:	0c 94 17 08 	jmp	0x102e	; 0x102e <_ZN7OneWire12reset_searchEv>

0000108c <_ZN7OneWire6searchEPhb>:
// search state.
// Return TRUE  : device found, ROM number in ROM_NO buffer
//        FALSE : device not found, end of search
//
bool OneWire::search(uint8_t *newAddr, bool search_mode /* = true */)
{
    108c:	bf 92       	push	r11
    108e:	cf 92       	push	r12
    1090:	df 92       	push	r13
    1092:	ef 92       	push	r14
    1094:	ff 92       	push	r15
    1096:	0f 93       	push	r16
    1098:	1f 93       	push	r17
    109a:	cf 93       	push	r28
    109c:	df 93       	push	r29
    109e:	ec 01       	movw	r28, r24
    10a0:	6b 01       	movw	r12, r22
    10a2:	14 2f       	mov	r17, r20
   rom_byte_number = 0;
   rom_byte_mask = 1;
   search_result = false;

   // if the last call was not the last one
   if (!LastDeviceFlag) {
    10a4:	8d 85       	ldd	r24, Y+13	; 0x0d
    10a6:	81 11       	cpse	r24, r1
    10a8:	05 c0       	rjmp	.+10     	; 0x10b4 <_ZN7OneWire6searchEPhb+0x28>
      // 1-Wire reset
      if (!reset()) {
    10aa:	ce 01       	movw	r24, r28
    10ac:	0e 94 0b 07 	call	0xe16	; 0xe16 <_ZN7OneWire5resetEv>
    10b0:	81 11       	cpse	r24, r1
    10b2:	05 c0       	rjmp	.+10     	; 0x10be <_ZN7OneWire6searchEPhb+0x32>
         // reset the search
         LastDiscrepancy = 0;
    10b4:	1b 86       	std	Y+11, r1	; 0x0b
         LastDeviceFlag = false;
    10b6:	1d 86       	std	Y+13, r1	; 0x0d
         LastFamilyDiscrepancy = 0;
    10b8:	1c 86       	std	Y+12, r1	; 0x0c
         return false;
    10ba:	80 e0       	ldi	r24, 0x00	; 0
    10bc:	64 c0       	rjmp	.+200    	; 0x1186 <_ZN7OneWire6searchEPhb+0xfa>
      }

      // issue the search command
      if (search_mode == true) {
        write(0xF0);   // NORMAL SEARCH
    10be:	40 e0       	ldi	r20, 0x00	; 0
         LastFamilyDiscrepancy = 0;
         return false;
      }

      // issue the search command
      if (search_mode == true) {
    10c0:	11 23       	and	r17, r17
    10c2:	11 f0       	breq	.+4      	; 0x10c8 <_ZN7OneWire6searchEPhb+0x3c>
        write(0xF0);   // NORMAL SEARCH
    10c4:	60 ef       	ldi	r22, 0xF0	; 240
    10c6:	01 c0       	rjmp	.+2      	; 0x10ca <_ZN7OneWire6searchEPhb+0x3e>
      } else {
        write(0xEC);   // CONDITIONAL SEARCH
    10c8:	6c ee       	ldi	r22, 0xEC	; 236
    10ca:	ce 01       	movw	r24, r28
    10cc:	0e 94 a8 07 	call	0xf50	; 0xf50 <_ZN7OneWire5writeEhh>
// search state.
// Return TRUE  : device found, ROM number in ROM_NO buffer
//        FALSE : device not found, end of search
//
bool OneWire::search(uint8_t *newAddr, bool search_mode /* = true */)
{
    10d0:	01 e0       	ldi	r16, 0x01	; 1
    10d2:	e1 2c       	mov	r14, r1
    10d4:	b1 2c       	mov	r11, r1
    10d6:	11 e0       	ldi	r17, 0x01	; 1

      // loop to do the search
      do
      {
         // read a bit and its complement
         id_bit = read_bit();
    10d8:	ce 01       	movw	r24, r28
    10da:	0e 94 7d 07 	call	0xefa	; 0xefa <_ZN7OneWire8read_bitEv>
    10de:	f8 2e       	mov	r15, r24
         cmp_id_bit = read_bit();
    10e0:	ce 01       	movw	r24, r28
    10e2:	0e 94 7d 07 	call	0xefa	; 0xefa <_ZN7OneWire8read_bitEv>

         // check for no devices on 1-wire
         if ((id_bit == 1) && (cmp_id_bit == 1)) {
    10e6:	91 e0       	ldi	r25, 0x01	; 1
    10e8:	f9 12       	cpse	r15, r25
    10ea:	03 c0       	rjmp	.+6      	; 0x10f2 <_ZN7OneWire6searchEPhb+0x66>
    10ec:	81 30       	cpi	r24, 0x01	; 1
    10ee:	b1 f4       	brne	.+44     	; 0x111c <_ZN7OneWire6searchEPhb+0x90>
    10f0:	34 c0       	rjmp	.+104    	; 0x115a <_ZN7OneWire6searchEPhb+0xce>
    10f2:	2e 2d       	mov	r18, r14
    10f4:	30 e0       	ldi	r19, 0x00	; 0
            break;
         } else {
            // all devices coupled have 0 or 1
            if (id_bit != cmp_id_bit) {
    10f6:	f8 12       	cpse	r15, r24
    10f8:	1b c0       	rjmp	.+54     	; 0x1130 <_ZN7OneWire6searchEPhb+0xa4>
               search_direction = id_bit;  // bit write value for search
            } else {
               // if this discrepancy if before the Last Discrepancy
               // on a previous next then pick the same as last time
               if (id_bit_number < LastDiscrepancy) {
    10fa:	8b 85       	ldd	r24, Y+11	; 0x0b
    10fc:	18 17       	cp	r17, r24
    10fe:	38 f4       	brcc	.+14     	; 0x110e <_ZN7OneWire6searchEPhb+0x82>
                  search_direction = ((ROM_NO[rom_byte_number] & rom_byte_mask) > 0);
    1100:	fe 01       	movw	r30, r28
    1102:	e2 0f       	add	r30, r18
    1104:	f3 1f       	adc	r31, r19
    1106:	83 81       	ldd	r24, Z+3	; 0x03
    1108:	80 23       	and	r24, r16
    110a:	41 f4       	brne	.+16     	; 0x111c <_ZN7OneWire6searchEPhb+0x90>
    110c:	02 c0       	rjmp	.+4      	; 0x1112 <_ZN7OneWire6searchEPhb+0x86>
               } else {
                  // if equal to last pick 1, if not then pick 0
                  search_direction = (id_bit_number == LastDiscrepancy);
    110e:	18 17       	cp	r17, r24
    1110:	29 f0       	breq	.+10     	; 0x111c <_ZN7OneWire6searchEPhb+0x90>
    1112:	f1 2c       	mov	r15, r1
               // if 0 was picked then record its position in LastZero
               if (search_direction == 0) {
                  last_zero = id_bit_number;

                  // check for Last discrepancy in family
                  if (last_zero < 9)
    1114:	19 30       	cpi	r17, 0x09	; 9
    1116:	58 f4       	brcc	.+22     	; 0x112e <_ZN7OneWire6searchEPhb+0xa2>
                     LastFamilyDiscrepancy = last_zero;
    1118:	1c 87       	std	Y+12, r17	; 0x0c
    111a:	09 c0       	rjmp	.+18     	; 0x112e <_ZN7OneWire6searchEPhb+0xa2>
            }

            // set or clear the bit in the ROM byte rom_byte_number
            // with mask rom_byte_mask
            if (search_direction == 1)
              ROM_NO[rom_byte_number] |= rom_byte_mask;
    111c:	fe 01       	movw	r30, r28
    111e:	ee 0d       	add	r30, r14
    1120:	f1 1d       	adc	r31, r1
    1122:	83 81       	ldd	r24, Z+3	; 0x03
    1124:	80 2b       	or	r24, r16
    1126:	83 83       	std	Z+3, r24	; 0x03
    1128:	ff 24       	eor	r15, r15
    112a:	f3 94       	inc	r15
    112c:	09 c0       	rjmp	.+18     	; 0x1140 <_ZN7OneWire6searchEPhb+0xb4>
// search state.
// Return TRUE  : device found, ROM number in ROM_NO buffer
//        FALSE : device not found, end of search
//
bool OneWire::search(uint8_t *newAddr, bool search_mode /* = true */)
{
    112e:	b1 2e       	mov	r11, r17
            // set or clear the bit in the ROM byte rom_byte_number
            // with mask rom_byte_mask
            if (search_direction == 1)
              ROM_NO[rom_byte_number] |= rom_byte_mask;
            else
              ROM_NO[rom_byte_number] &= ~rom_byte_mask;
    1130:	fe 01       	movw	r30, r28
    1132:	e2 0f       	add	r30, r18
    1134:	f3 1f       	adc	r31, r19
    1136:	93 81       	ldd	r25, Z+3	; 0x03
    1138:	80 2f       	mov	r24, r16
    113a:	80 95       	com	r24
    113c:	89 23       	and	r24, r25
    113e:	83 83       	std	Z+3, r24	; 0x03

            // serial number search direction write bit
            write_bit(search_direction);
    1140:	6f 2d       	mov	r22, r15
    1142:	ce 01       	movw	r24, r28
    1144:	0e 94 4a 07 	call	0xe94	; 0xe94 <_ZN7OneWire9write_bitEh>

            // increment the byte counter id_bit_number
            // and shift the mask rom_byte_mask
            id_bit_number++;
    1148:	1f 5f       	subi	r17, 0xFF	; 255
            rom_byte_mask <<= 1;
    114a:	00 0f       	add	r16, r16

            // if the mask is 0 then go to new SerialNum byte rom_byte_number and reset mask
            if (rom_byte_mask == 0) {
    114c:	11 f4       	brne	.+4      	; 0x1152 <_ZN7OneWire6searchEPhb+0xc6>
                rom_byte_number++;
    114e:	e3 94       	inc	r14
                rom_byte_mask = 1;
    1150:	01 e0       	ldi	r16, 0x01	; 1
            }
         }
      }
      while(rom_byte_number < 8);  // loop until through all ROM bytes 0-7
    1152:	87 e0       	ldi	r24, 0x07	; 7
    1154:	8e 15       	cp	r24, r14
    1156:	08 f0       	brcs	.+2      	; 0x115a <_ZN7OneWire6searchEPhb+0xce>
    1158:	bf cf       	rjmp	.-130    	; 0x10d8 <_ZN7OneWire6searchEPhb+0x4c>

      // if the search was successful then
      if (!(id_bit_number < 65)) {
    115a:	11 34       	cpi	r17, 0x41	; 65
    115c:	08 f4       	brcc	.+2      	; 0x1160 <_ZN7OneWire6searchEPhb+0xd4>
    115e:	aa cf       	rjmp	.-172    	; 0x10b4 <_ZN7OneWire6searchEPhb+0x28>
         // search successful so set LastDiscrepancy,LastDeviceFlag,search_result
         LastDiscrepancy = last_zero;
    1160:	bb 86       	std	Y+11, r11	; 0x0b

         // check for last device
         if (LastDiscrepancy == 0) {
    1162:	b1 10       	cpse	r11, r1
    1164:	02 c0       	rjmp	.+4      	; 0x116a <_ZN7OneWire6searchEPhb+0xde>
            LastDeviceFlag = true;
    1166:	81 e0       	ldi	r24, 0x01	; 1
    1168:	8d 87       	std	Y+13, r24	; 0x0d
         search_result = true;
      }
   }

   // if no device found then reset counters so next 'search' will be like a first
   if (!search_result || !ROM_NO[0]) {
    116a:	8b 81       	ldd	r24, Y+3	; 0x03
    116c:	88 23       	and	r24, r24
    116e:	09 f4       	brne	.+2      	; 0x1172 <_ZN7OneWire6searchEPhb+0xe6>
    1170:	a1 cf       	rjmp	.-190    	; 0x10b4 <_ZN7OneWire6searchEPhb+0x28>
    1172:	de 01       	movw	r26, r28
    1174:	13 96       	adiw	r26, 0x03	; 3
    1176:	f6 01       	movw	r30, r12
    1178:	2b 96       	adiw	r28, 0x0b	; 11
      LastDiscrepancy = 0;
      LastDeviceFlag = false;
      LastFamilyDiscrepancy = 0;
      search_result = false;
   } else {
      for (int i = 0; i < 8; i++) newAddr[i] = ROM_NO[i];
    117a:	8d 91       	ld	r24, X+
    117c:	81 93       	st	Z+, r24
    117e:	ca 17       	cp	r28, r26
    1180:	db 07       	cpc	r29, r27
    1182:	d9 f7       	brne	.-10     	; 0x117a <_ZN7OneWire6searchEPhb+0xee>
    1184:	81 e0       	ldi	r24, 0x01	; 1
   }
   return search_result;
  }
    1186:	df 91       	pop	r29
    1188:	cf 91       	pop	r28
    118a:	1f 91       	pop	r17
    118c:	0f 91       	pop	r16
    118e:	ff 90       	pop	r15
    1190:	ef 90       	pop	r14
    1192:	df 90       	pop	r13
    1194:	cf 90       	pop	r12
    1196:	bf 90       	pop	r11
    1198:	08 95       	ret

0000119a <_ZN7OneWire4crc8EPKhh>:
};

// Compute a Dallas Semiconductor 8 bit CRC. These show up in the ROM
// and the registers.  (Use tiny 2x16 entry CRC table)
uint8_t OneWire::crc8(const uint8_t *addr, uint8_t len)
{
    119a:	dc 01       	movw	r26, r24
	uint8_t crc = 0;
    119c:	80 e0       	ldi	r24, 0x00	; 0

	while (len--) {
    119e:	61 50       	subi	r22, 0x01	; 1
    11a0:	98 f0       	brcs	.+38     	; 0x11c8 <_ZN7OneWire4crc8EPKhh+0x2e>
		crc = *addr++ ^ crc;  // just re-using crc as intermediate
    11a2:	2d 91       	ld	r18, X+
    11a4:	98 2f       	mov	r25, r24
    11a6:	92 27       	eor	r25, r18
		crc = pgm_read_byte(dscrc2x16_table + (crc & 0x0f)) ^
    11a8:	e9 2f       	mov	r30, r25
    11aa:	ef 70       	andi	r30, 0x0F	; 15
    11ac:	f0 e0       	ldi	r31, 0x00	; 0
    11ae:	ee 56       	subi	r30, 0x6E	; 110
    11b0:	ff 4f       	sbci	r31, 0xFF	; 255
    11b2:	24 91       	lpm	r18, Z
		pgm_read_byte(dscrc2x16_table + 16 + ((crc >> 4) & 0x0f));
    11b4:	92 95       	swap	r25
    11b6:	9f 70       	andi	r25, 0x0F	; 15
    11b8:	e9 2f       	mov	r30, r25
    11ba:	f0 e0       	ldi	r31, 0x00	; 0
    11bc:	ee 55       	subi	r30, 0x5E	; 94
    11be:	ff 4f       	sbci	r31, 0xFF	; 255
    11c0:	e4 91       	lpm	r30, Z
    11c2:	82 2f       	mov	r24, r18
    11c4:	8e 27       	eor	r24, r30
// and the registers.  (Use tiny 2x16 entry CRC table)
uint8_t OneWire::crc8(const uint8_t *addr, uint8_t len)
{
	uint8_t crc = 0;

	while (len--) {
    11c6:	eb cf       	rjmp	.-42     	; 0x119e <_ZN7OneWire4crc8EPKhh+0x4>
		crc = pgm_read_byte(dscrc2x16_table + (crc & 0x0f)) ^
		pgm_read_byte(dscrc2x16_table + 16 + ((crc >> 4) & 0x0f));
	}

	return crc;
}
    11c8:	08 95       	ret

000011ca <_Z6calcPHv>:
	float voltage = analogRead(PH_PIN)/1024.0*5000;
	ph.calibration(voltage, temperaturePH);
}*/

float calcPH()
{
    11ca:	8f 92       	push	r8
    11cc:	9f 92       	push	r9
    11ce:	af 92       	push	r10
    11d0:	bf 92       	push	r11
    11d2:	cf 92       	push	r12
    11d4:	df 92       	push	r13
    11d6:	ef 92       	push	r14
    11d8:	ff 92       	push	r15
    11da:	cf 93       	push	r28
    11dc:	df 93       	push	r29
	float voltage = analogRead(PH_PIN);
    11de:	8e e0       	ldi	r24, 0x0E	; 14
    11e0:	0e 94 67 21 	call	0x42ce	; 0x42ce <analogRead>
    11e4:	ec 01       	movw	r28, r24
	float slope = (7.0 - 4.0)/(neutralVoltage - acidVoltage);
    11e6:	80 90 37 01 	lds	r8, 0x0137	; 0x800137 <neutralVoltage>
    11ea:	90 90 38 01 	lds	r9, 0x0138	; 0x800138 <neutralVoltage+0x1>
    11ee:	a0 90 39 01 	lds	r10, 0x0139	; 0x800139 <neutralVoltage+0x2>
    11f2:	b0 90 3a 01 	lds	r11, 0x013A	; 0x80013a <neutralVoltage+0x3>
    11f6:	20 91 33 01 	lds	r18, 0x0133	; 0x800133 <acidVoltage>
    11fa:	30 91 34 01 	lds	r19, 0x0134	; 0x800134 <acidVoltage+0x1>
    11fe:	40 91 35 01 	lds	r20, 0x0135	; 0x800135 <acidVoltage+0x2>
    1202:	50 91 36 01 	lds	r21, 0x0136	; 0x800136 <acidVoltage+0x3>
    1206:	c5 01       	movw	r24, r10
    1208:	b4 01       	movw	r22, r8
    120a:	0e 94 b2 1a 	call	0x3564	; 0x3564 <__subsf3>
    120e:	9b 01       	movw	r18, r22
    1210:	ac 01       	movw	r20, r24
    1212:	60 e0       	ldi	r22, 0x00	; 0
    1214:	70 e0       	ldi	r23, 0x00	; 0
    1216:	80 e4       	ldi	r24, 0x40	; 64
    1218:	90 e4       	ldi	r25, 0x40	; 64
    121a:	0e 94 24 1b 	call	0x3648	; 0x3648 <__divsf3>
    121e:	6b 01       	movw	r12, r22
    1220:	7c 01       	movw	r14, r24
	Serial.print(neutralVoltage);
	Serial.write("\nAcid Voltage:");
	Serial.print(acidVoltage);
	Serial.write("\nVoltage Measured:");
	Serial.print(voltage);*/
	return (slope * voltage) + intercept;
    1222:	9b 01       	movw	r18, r22
    1224:	ac 01       	movw	r20, r24
    1226:	c5 01       	movw	r24, r10
    1228:	b4 01       	movw	r22, r8
    122a:	0e 94 7e 1c 	call	0x38fc	; 0x38fc <__mulsf3>
    122e:	9b 01       	movw	r18, r22
    1230:	ac 01       	movw	r20, r24
    1232:	60 e0       	ldi	r22, 0x00	; 0
    1234:	70 e0       	ldi	r23, 0x00	; 0
    1236:	80 ee       	ldi	r24, 0xE0	; 224
    1238:	90 e4       	ldi	r25, 0x40	; 64
    123a:	0e 94 b2 1a 	call	0x3564	; 0x3564 <__subsf3>
    123e:	4b 01       	movw	r8, r22
    1240:	5c 01       	movw	r10, r24
    1242:	be 01       	movw	r22, r28
    1244:	dd 0f       	add	r29, r29
    1246:	88 0b       	sbc	r24, r24
    1248:	99 0b       	sbc	r25, r25
    124a:	0e 94 ce 1b 	call	0x379c	; 0x379c <__floatsisf>
    124e:	a7 01       	movw	r20, r14
    1250:	96 01       	movw	r18, r12
    1252:	0e 94 7e 1c 	call	0x38fc	; 0x38fc <__mulsf3>
    1256:	9b 01       	movw	r18, r22
    1258:	ac 01       	movw	r20, r24
    125a:	c5 01       	movw	r24, r10
    125c:	b4 01       	movw	r22, r8
    125e:	0e 94 b3 1a 	call	0x3566	; 0x3566 <__addsf3>
    1262:	df 91       	pop	r29
    1264:	cf 91       	pop	r28
    1266:	ff 90       	pop	r15
    1268:	ef 90       	pop	r14
    126a:	df 90       	pop	r13
    126c:	cf 90       	pop	r12
    126e:	bf 90       	pop	r11
    1270:	af 90       	pop	r10
    1272:	9f 90       	pop	r9
    1274:	8f 90       	pop	r8
    1276:	08 95       	ret

00001278 <pvPortMalloc>:
#if( configSUPPORT_DYNAMIC_ALLOCATION > 0 )

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
    1278:	cf 93       	push	r28
    127a:	df 93       	push	r29
    127c:	ec 01       	movw	r28, r24
void *pvReturn;

    vTaskSuspendAll();
    127e:	0e 94 e9 10 	call	0x21d2	; 0x21d2 <vTaskSuspendAll>
    {
        pvReturn = malloc( xWantedSize );
    1282:	ce 01       	movw	r24, r28
    1284:	0e 94 17 24 	call	0x482e	; 0x482e <malloc>
    1288:	ec 01       	movw	r28, r24
        traceMALLOC( pvReturn, xWantedSize );
    }
    ( void ) xTaskResumeAll();
    128a:	0e 94 a5 11 	call	0x234a	; 0x234a <xTaskResumeAll>

    #if( configUSE_MALLOC_FAILED_HOOK == 1 )
    {
        if( pvReturn == NULL )
    128e:	20 97       	sbiw	r28, 0x00	; 0
    1290:	11 f4       	brne	.+4      	; 0x1296 <pvPortMalloc+0x1e>
        {
            extern void vApplicationMallocFailedHook( void );
            vApplicationMallocFailedHook();
    1292:	0e 94 82 16 	call	0x2d04	; 0x2d04 <vApplicationMallocFailedHook>
        }
    }
    #endif

    return pvReturn;
}
    1296:	ce 01       	movw	r24, r28
    1298:	df 91       	pop	r29
    129a:	cf 91       	pop	r28
    129c:	08 95       	ret

0000129e <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
    129e:	cf 93       	push	r28
    12a0:	df 93       	push	r29
    if( pv )
    12a2:	00 97       	sbiw	r24, 0x00	; 0
    12a4:	51 f0       	breq	.+20     	; 0x12ba <vPortFree+0x1c>
    12a6:	ec 01       	movw	r28, r24
    {
        vTaskSuspendAll();
    12a8:	0e 94 e9 10 	call	0x21d2	; 0x21d2 <vTaskSuspendAll>
        {
            free( pv );
    12ac:	ce 01       	movw	r24, r28
    12ae:	0e 94 af 24 	call	0x495e	; 0x495e <free>
            traceFREE( pv, 0 );
        }
        ( void ) xTaskResumeAll();
    }
}
    12b2:	df 91       	pop	r29
    12b4:	cf 91       	pop	r28
        vTaskSuspendAll();
        {
            free( pv );
            traceFREE( pv, 0 );
        }
        ( void ) xTaskResumeAll();
    12b6:	0c 94 a5 11 	jmp	0x234a	; 0x234a <xTaskResumeAll>
    }
}
    12ba:	df 91       	pop	r29
    12bc:	cf 91       	pop	r28
    12be:	08 95       	ret

000012c0 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
    12c0:	fc 01       	movw	r30, r24
    /* The list structure contains a list item which is used to mark the
    end of the list.  To initialise the list the list end is inserted
    as the only list entry. */
    pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );            /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    12c2:	03 96       	adiw	r24, 0x03	; 3
    12c4:	92 83       	std	Z+2, r25	; 0x02
    12c6:	81 83       	std	Z+1, r24	; 0x01

    /* The list end value is the highest possible value in the list to
    ensure it remains at the end of the list. */
    pxList->xListEnd.xItemValue = portMAX_DELAY;
    12c8:	2f ef       	ldi	r18, 0xFF	; 255
    12ca:	3f ef       	ldi	r19, 0xFF	; 255
    12cc:	34 83       	std	Z+4, r19	; 0x04
    12ce:	23 83       	std	Z+3, r18	; 0x03

    /* The list end next and previous pointers point to itself so we know
    when the list is empty. */
    pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );    /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    12d0:	96 83       	std	Z+6, r25	; 0x06
    12d2:	85 83       	std	Z+5, r24	; 0x05
    pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    12d4:	90 87       	std	Z+8, r25	; 0x08
    12d6:	87 83       	std	Z+7, r24	; 0x07

    pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
    12d8:	10 82       	st	Z, r1
    12da:	08 95       	ret

000012dc <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
    /* Make sure the list item is not recorded as being on a list. */
    pxItem->pxContainer = NULL;
    12dc:	fc 01       	movw	r30, r24
    12de:	11 86       	std	Z+9, r1	; 0x09
    12e0:	10 86       	std	Z+8, r1	; 0x08
    12e2:	08 95       	ret

000012e4 <vListInsertEnd>:
    listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    12e4:	cf 93       	push	r28
    12e6:	df 93       	push	r29
    12e8:	9c 01       	movw	r18, r24
    12ea:	fb 01       	movw	r30, r22
ListItem_t * const pxIndex = pxList->pxIndex;
    12ec:	dc 01       	movw	r26, r24
    12ee:	11 96       	adiw	r26, 0x01	; 1
    12f0:	cd 91       	ld	r28, X+
    12f2:	dc 91       	ld	r29, X
    12f4:	12 97       	sbiw	r26, 0x02	; 2
    listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

    /* Insert a new list item into pxList, but rather than sort the list,
    makes the new list item the last item to be removed by a call to
    listGET_OWNER_OF_NEXT_ENTRY(). */
    pxNewListItem->pxNext = pxIndex;
    12f6:	d3 83       	std	Z+3, r29	; 0x03
    12f8:	c2 83       	std	Z+2, r28	; 0x02
    pxNewListItem->pxPrevious = pxIndex->pxPrevious;
    12fa:	8c 81       	ldd	r24, Y+4	; 0x04
    12fc:	9d 81       	ldd	r25, Y+5	; 0x05
    12fe:	95 83       	std	Z+5, r25	; 0x05
    1300:	84 83       	std	Z+4, r24	; 0x04

    /* Only used during decision coverage testing. */
    mtCOVERAGE_TEST_DELAY();

    pxIndex->pxPrevious->pxNext = pxNewListItem;
    1302:	8c 81       	ldd	r24, Y+4	; 0x04
    1304:	9d 81       	ldd	r25, Y+5	; 0x05
    1306:	dc 01       	movw	r26, r24
    1308:	13 96       	adiw	r26, 0x03	; 3
    130a:	7c 93       	st	X, r23
    130c:	6e 93       	st	-X, r22
    130e:	12 97       	sbiw	r26, 0x02	; 2
    pxIndex->pxPrevious = pxNewListItem;
    1310:	7d 83       	std	Y+5, r23	; 0x05
    1312:	6c 83       	std	Y+4, r22	; 0x04

    /* Remember which list the item is in. */
    pxNewListItem->pxContainer = pxList;
    1314:	31 87       	std	Z+9, r19	; 0x09
    1316:	20 87       	std	Z+8, r18	; 0x08

    ( pxList->uxNumberOfItems )++;
    1318:	f9 01       	movw	r30, r18
    131a:	80 81       	ld	r24, Z
    131c:	8f 5f       	subi	r24, 0xFF	; 255
    131e:	80 83       	st	Z, r24
}
    1320:	df 91       	pop	r29
    1322:	cf 91       	pop	r28
    1324:	08 95       	ret

00001326 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    1326:	0f 93       	push	r16
    1328:	1f 93       	push	r17
    132a:	cf 93       	push	r28
    132c:	df 93       	push	r29
    132e:	8c 01       	movw	r16, r24
    1330:	fb 01       	movw	r30, r22
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
    1332:	80 81       	ld	r24, Z
    1334:	91 81       	ldd	r25, Z+1	; 0x01
    new list item should be placed after it.  This ensures that TCBs which are
    stored in ready lists (all of which have the same xItemValue value) get a
    share of the CPU.  However, if the xItemValue is the same as the back marker
    the iteration loop below will not end.  Therefore the value is checked
    first, and the algorithm slightly modified if necessary. */
    if( xValueOfInsertion == portMAX_DELAY )
    1336:	8f 3f       	cpi	r24, 0xFF	; 255
    1338:	2f ef       	ldi	r18, 0xFF	; 255
    133a:	92 07       	cpc	r25, r18
    133c:	21 f4       	brne	.+8      	; 0x1346 <vListInsert+0x20>
    {
        pxIterator = pxList->xListEnd.pxPrevious;
    133e:	e8 01       	movw	r28, r16
    1340:	af 81       	ldd	r26, Y+7	; 0x07
    1342:	b8 85       	ldd	r27, Y+8	; 0x08
    1344:	0e c0       	rjmp	.+28     	; 0x1362 <vListInsert+0x3c>
            4) Using a queue or semaphore before it has been initialised or
               before the scheduler has been started (are interrupts firing
               before vTaskStartScheduler() has been called?).
        **********************************************************************/

        for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. *//*lint !e440 The iterator moves to a different value, not xValueOfInsertion. */
    1346:	d8 01       	movw	r26, r16
    1348:	13 96       	adiw	r26, 0x03	; 3
    134a:	12 96       	adiw	r26, 0x02	; 2
    134c:	2d 91       	ld	r18, X+
    134e:	3c 91       	ld	r19, X
    1350:	13 97       	sbiw	r26, 0x03	; 3
    1352:	e9 01       	movw	r28, r18
    1354:	48 81       	ld	r20, Y
    1356:	59 81       	ldd	r21, Y+1	; 0x01
    1358:	84 17       	cp	r24, r20
    135a:	95 07       	cpc	r25, r21
    135c:	10 f0       	brcs	.+4      	; 0x1362 <vListInsert+0x3c>
    135e:	d9 01       	movw	r26, r18
    1360:	f4 cf       	rjmp	.-24     	; 0x134a <vListInsert+0x24>
            /* There is nothing to do here, just iterating to the wanted
            insertion position. */
        }
    }

    pxNewListItem->pxNext = pxIterator->pxNext;
    1362:	12 96       	adiw	r26, 0x02	; 2
    1364:	8d 91       	ld	r24, X+
    1366:	9c 91       	ld	r25, X
    1368:	13 97       	sbiw	r26, 0x03	; 3
    136a:	93 83       	std	Z+3, r25	; 0x03
    136c:	82 83       	std	Z+2, r24	; 0x02
    pxNewListItem->pxNext->pxPrevious = pxNewListItem;
    136e:	ec 01       	movw	r28, r24
    1370:	fd 83       	std	Y+5, r31	; 0x05
    1372:	ec 83       	std	Y+4, r30	; 0x04
    pxNewListItem->pxPrevious = pxIterator;
    1374:	b5 83       	std	Z+5, r27	; 0x05
    1376:	a4 83       	std	Z+4, r26	; 0x04
    pxIterator->pxNext = pxNewListItem;
    1378:	13 96       	adiw	r26, 0x03	; 3
    137a:	fc 93       	st	X, r31
    137c:	ee 93       	st	-X, r30
    137e:	12 97       	sbiw	r26, 0x02	; 2

    /* Remember which list the item is in.  This allows fast removal of the
    item later. */
    pxNewListItem->pxContainer = pxList;
    1380:	11 87       	std	Z+9, r17	; 0x09
    1382:	00 87       	std	Z+8, r16	; 0x08

    ( pxList->uxNumberOfItems )++;
    1384:	f8 01       	movw	r30, r16
    1386:	80 81       	ld	r24, Z
    1388:	8f 5f       	subi	r24, 0xFF	; 255
    138a:	80 83       	st	Z, r24
}
    138c:	df 91       	pop	r29
    138e:	cf 91       	pop	r28
    1390:	1f 91       	pop	r17
    1392:	0f 91       	pop	r16
    1394:	08 95       	ret

00001396 <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
    1396:	cf 93       	push	r28
    1398:	df 93       	push	r29
    139a:	fc 01       	movw	r30, r24
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = pxItemToRemove->pxContainer;
    139c:	a0 85       	ldd	r26, Z+8	; 0x08
    139e:	b1 85       	ldd	r27, Z+9	; 0x09

    pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    13a0:	82 81       	ldd	r24, Z+2	; 0x02
    13a2:	93 81       	ldd	r25, Z+3	; 0x03
    13a4:	24 81       	ldd	r18, Z+4	; 0x04
    13a6:	35 81       	ldd	r19, Z+5	; 0x05
    13a8:	ec 01       	movw	r28, r24
    13aa:	3d 83       	std	Y+5, r19	; 0x05
    13ac:	2c 83       	std	Y+4, r18	; 0x04
    pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    13ae:	c4 81       	ldd	r28, Z+4	; 0x04
    13b0:	d5 81       	ldd	r29, Z+5	; 0x05
    13b2:	9b 83       	std	Y+3, r25	; 0x03
    13b4:	8a 83       	std	Y+2, r24	; 0x02

    /* Only used during decision coverage testing. */
    mtCOVERAGE_TEST_DELAY();

    /* Make sure the index is left pointing to a valid item. */
    if( pxList->pxIndex == pxItemToRemove )
    13b6:	11 96       	adiw	r26, 0x01	; 1
    13b8:	8d 91       	ld	r24, X+
    13ba:	9c 91       	ld	r25, X
    13bc:	12 97       	sbiw	r26, 0x02	; 2
    13be:	e8 17       	cp	r30, r24
    13c0:	f9 07       	cpc	r31, r25
    13c2:	21 f4       	brne	.+8      	; 0x13cc <uxListRemove+0x36>
    {
        pxList->pxIndex = pxItemToRemove->pxPrevious;
    13c4:	12 96       	adiw	r26, 0x02	; 2
    13c6:	dc 93       	st	X, r29
    13c8:	ce 93       	st	-X, r28
    13ca:	11 97       	sbiw	r26, 0x01	; 1
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }

    pxItemToRemove->pxContainer = NULL;
    13cc:	11 86       	std	Z+9, r1	; 0x09
    13ce:	10 86       	std	Z+8, r1	; 0x08
    ( pxList->uxNumberOfItems )--;
    13d0:	8c 91       	ld	r24, X
    13d2:	81 50       	subi	r24, 0x01	; 1
    13d4:	8c 93       	st	X, r24

    return pxList->uxNumberOfItems;
    13d6:	8c 91       	ld	r24, X
}
    13d8:	df 91       	pop	r29
    13da:	cf 91       	pop	r28
    13dc:	08 95       	ret

000013de <pxPortInitialiseStack>:
		);
	}
	else
	{
        uint8_t register temp_reg;
		__asm__ __volatile__ (
    13de:	31 e1       	ldi	r19, 0x11	; 17
    13e0:	fc 01       	movw	r30, r24
    13e2:	30 83       	st	Z, r19
    13e4:	31 97       	sbiw	r30, 0x01	; 1
    13e6:	22 e2       	ldi	r18, 0x22	; 34
    13e8:	20 83       	st	Z, r18
    13ea:	31 97       	sbiw	r30, 0x01	; 1
    13ec:	a3 e3       	ldi	r26, 0x33	; 51
    13ee:	a0 83       	st	Z, r26
    13f0:	31 97       	sbiw	r30, 0x01	; 1
    13f2:	60 83       	st	Z, r22
    13f4:	31 97       	sbiw	r30, 0x01	; 1
    13f6:	70 83       	st	Z, r23
    13f8:	31 97       	sbiw	r30, 0x01	; 1
    13fa:	10 82       	st	Z, r1
    13fc:	31 97       	sbiw	r30, 0x01	; 1
    13fe:	60 e8       	ldi	r22, 0x80	; 128
    1400:	60 83       	st	Z, r22
    1402:	31 97       	sbiw	r30, 0x01	; 1
    1404:	10 82       	st	Z, r1
    1406:	31 97       	sbiw	r30, 0x01	; 1
    1408:	62 e0       	ldi	r22, 0x02	; 2
    140a:	60 83       	st	Z, r22
    140c:	31 97       	sbiw	r30, 0x01	; 1
    140e:	63 e0       	ldi	r22, 0x03	; 3
    1410:	60 83       	st	Z, r22
    1412:	31 97       	sbiw	r30, 0x01	; 1
    1414:	64 e0       	ldi	r22, 0x04	; 4
    1416:	60 83       	st	Z, r22
    1418:	31 97       	sbiw	r30, 0x01	; 1
    141a:	65 e0       	ldi	r22, 0x05	; 5
    141c:	60 83       	st	Z, r22
    141e:	31 97       	sbiw	r30, 0x01	; 1
    1420:	66 e0       	ldi	r22, 0x06	; 6
    1422:	60 83       	st	Z, r22
    1424:	31 97       	sbiw	r30, 0x01	; 1
    1426:	67 e0       	ldi	r22, 0x07	; 7
    1428:	60 83       	st	Z, r22
    142a:	31 97       	sbiw	r30, 0x01	; 1
    142c:	68 e0       	ldi	r22, 0x08	; 8
    142e:	60 83       	st	Z, r22
    1430:	31 97       	sbiw	r30, 0x01	; 1
    1432:	69 e0       	ldi	r22, 0x09	; 9
    1434:	60 83       	st	Z, r22
    1436:	31 97       	sbiw	r30, 0x01	; 1
    1438:	60 e1       	ldi	r22, 0x10	; 16
    143a:	60 83       	st	Z, r22
    143c:	31 97       	sbiw	r30, 0x01	; 1
    143e:	30 83       	st	Z, r19
    1440:	31 97       	sbiw	r30, 0x01	; 1
    1442:	32 e1       	ldi	r19, 0x12	; 18
    1444:	30 83       	st	Z, r19
    1446:	31 97       	sbiw	r30, 0x01	; 1
    1448:	33 e1       	ldi	r19, 0x13	; 19
    144a:	30 83       	st	Z, r19
    144c:	31 97       	sbiw	r30, 0x01	; 1
    144e:	34 e1       	ldi	r19, 0x14	; 20
    1450:	30 83       	st	Z, r19
    1452:	31 97       	sbiw	r30, 0x01	; 1
    1454:	35 e1       	ldi	r19, 0x15	; 21
    1456:	30 83       	st	Z, r19
    1458:	31 97       	sbiw	r30, 0x01	; 1
    145a:	36 e1       	ldi	r19, 0x16	; 22
    145c:	30 83       	st	Z, r19
    145e:	31 97       	sbiw	r30, 0x01	; 1
    1460:	37 e1       	ldi	r19, 0x17	; 23
    1462:	30 83       	st	Z, r19
    1464:	31 97       	sbiw	r30, 0x01	; 1
    1466:	38 e1       	ldi	r19, 0x18	; 24
    1468:	30 83       	st	Z, r19
    146a:	31 97       	sbiw	r30, 0x01	; 1
    146c:	39 e1       	ldi	r19, 0x19	; 25
    146e:	30 83       	st	Z, r19
    1470:	31 97       	sbiw	r30, 0x01	; 1
    1472:	30 e2       	ldi	r19, 0x20	; 32
    1474:	30 83       	st	Z, r19
    1476:	31 97       	sbiw	r30, 0x01	; 1
    1478:	31 e2       	ldi	r19, 0x21	; 33
    147a:	30 83       	st	Z, r19
    147c:	31 97       	sbiw	r30, 0x01	; 1
    147e:	20 83       	st	Z, r18
    1480:	31 97       	sbiw	r30, 0x01	; 1
    1482:	23 e2       	ldi	r18, 0x23	; 35
    1484:	20 83       	st	Z, r18
    1486:	31 97       	sbiw	r30, 0x01	; 1
    1488:	40 83       	st	Z, r20
    148a:	31 97       	sbiw	r30, 0x01	; 1
    148c:	50 83       	st	Z, r21
    148e:	31 97       	sbiw	r30, 0x01	; 1
    1490:	26 e2       	ldi	r18, 0x26	; 38
    1492:	20 83       	st	Z, r18
    1494:	31 97       	sbiw	r30, 0x01	; 1
    1496:	27 e2       	ldi	r18, 0x27	; 39
    1498:	20 83       	st	Z, r18
    149a:	31 97       	sbiw	r30, 0x01	; 1
    149c:	28 e2       	ldi	r18, 0x28	; 40
    149e:	20 83       	st	Z, r18
    14a0:	31 97       	sbiw	r30, 0x01	; 1
    14a2:	29 e2       	ldi	r18, 0x29	; 41
    14a4:	20 83       	st	Z, r18
    14a6:	31 97       	sbiw	r30, 0x01	; 1
    14a8:	20 e3       	ldi	r18, 0x30	; 48
    14aa:	20 83       	st	Z, r18
    14ac:	31 97       	sbiw	r30, 0x01	; 1
    14ae:	21 e3       	ldi	r18, 0x31	; 49
    14b0:	20 83       	st	Z, r18
    14b2:	86 97       	sbiw	r24, 0x26	; 38
    14b4:	08 95       	ret

000014b6 <xPortStartScheduler>:
    14b6:	a8 95       	wdr
    14b8:	90 ec       	ldi	r25, 0xC0	; 192
    14ba:	88 e1       	ldi	r24, 0x18	; 24
    14bc:	0f b6       	in	r0, 0x3f	; 63
    14be:	f8 94       	cli
    14c0:	a8 95       	wdr
    14c2:	80 93 60 00 	sts	0x0060, r24	; 0x800060 <__DATA_REGION_ORIGIN__>
    14c6:	0f be       	out	0x3f, r0	; 63
    14c8:	90 93 60 00 	sts	0x0060, r25	; 0x800060 <__DATA_REGION_ORIGIN__>
    14cc:	a0 91 d0 03 	lds	r26, 0x03D0	; 0x8003d0 <pxCurrentTCB>
    14d0:	b0 91 d1 03 	lds	r27, 0x03D1	; 0x8003d1 <pxCurrentTCB+0x1>
    14d4:	cd 91       	ld	r28, X+
    14d6:	cd bf       	out	0x3d, r28	; 61
    14d8:	dd 91       	ld	r29, X+
    14da:	de bf       	out	0x3e, r29	; 62
    14dc:	ff 91       	pop	r31
    14de:	ef 91       	pop	r30
    14e0:	df 91       	pop	r29
    14e2:	cf 91       	pop	r28
    14e4:	bf 91       	pop	r27
    14e6:	af 91       	pop	r26
    14e8:	9f 91       	pop	r25
    14ea:	8f 91       	pop	r24
    14ec:	7f 91       	pop	r23
    14ee:	6f 91       	pop	r22
    14f0:	5f 91       	pop	r21
    14f2:	4f 91       	pop	r20
    14f4:	3f 91       	pop	r19
    14f6:	2f 91       	pop	r18
    14f8:	1f 91       	pop	r17
    14fa:	0f 91       	pop	r16
    14fc:	ff 90       	pop	r15
    14fe:	ef 90       	pop	r14
    1500:	df 90       	pop	r13
    1502:	cf 90       	pop	r12
    1504:	bf 90       	pop	r11
    1506:	af 90       	pop	r10
    1508:	9f 90       	pop	r9
    150a:	8f 90       	pop	r8
    150c:	7f 90       	pop	r7
    150e:	6f 90       	pop	r6
    1510:	5f 90       	pop	r5
    1512:	4f 90       	pop	r4
    1514:	3f 90       	pop	r3
    1516:	2f 90       	pop	r2
    1518:	1f 90       	pop	r1
    151a:	0f 90       	pop	r0
    151c:	0f be       	out	0x3f, r0	; 63
    151e:	0f 90       	pop	r0
    1520:	08 95       	ret
    1522:	81 e0       	ldi	r24, 0x01	; 1
    1524:	08 95       	ret

00001526 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( hot, flatten, naked ) );
void vPortYield( void )
{
    portSAVE_CONTEXT();
    1526:	0f 92       	push	r0
    1528:	0f b6       	in	r0, 0x3f	; 63
    152a:	f8 94       	cli
    152c:	0f 92       	push	r0
    152e:	1f 92       	push	r1
    1530:	11 24       	eor	r1, r1
    1532:	2f 92       	push	r2
    1534:	3f 92       	push	r3
    1536:	4f 92       	push	r4
    1538:	5f 92       	push	r5
    153a:	6f 92       	push	r6
    153c:	7f 92       	push	r7
    153e:	8f 92       	push	r8
    1540:	9f 92       	push	r9
    1542:	af 92       	push	r10
    1544:	bf 92       	push	r11
    1546:	cf 92       	push	r12
    1548:	df 92       	push	r13
    154a:	ef 92       	push	r14
    154c:	ff 92       	push	r15
    154e:	0f 93       	push	r16
    1550:	1f 93       	push	r17
    1552:	2f 93       	push	r18
    1554:	3f 93       	push	r19
    1556:	4f 93       	push	r20
    1558:	5f 93       	push	r21
    155a:	6f 93       	push	r22
    155c:	7f 93       	push	r23
    155e:	8f 93       	push	r24
    1560:	9f 93       	push	r25
    1562:	af 93       	push	r26
    1564:	bf 93       	push	r27
    1566:	cf 93       	push	r28
    1568:	df 93       	push	r29
    156a:	ef 93       	push	r30
    156c:	ff 93       	push	r31
    156e:	a0 91 d0 03 	lds	r26, 0x03D0	; 0x8003d0 <pxCurrentTCB>
    1572:	b0 91 d1 03 	lds	r27, 0x03D1	; 0x8003d1 <pxCurrentTCB+0x1>
    1576:	0d b6       	in	r0, 0x3d	; 61
    1578:	0d 92       	st	X+, r0
    157a:	0e b6       	in	r0, 0x3e	; 62
    157c:	0d 92       	st	X+, r0
    vTaskSwitchContext();
    157e:	0e 94 61 12 	call	0x24c2	; 0x24c2 <vTaskSwitchContext>
    portRESTORE_CONTEXT();
    1582:	a0 91 d0 03 	lds	r26, 0x03D0	; 0x8003d0 <pxCurrentTCB>
    1586:	b0 91 d1 03 	lds	r27, 0x03D1	; 0x8003d1 <pxCurrentTCB+0x1>
    158a:	cd 91       	ld	r28, X+
    158c:	cd bf       	out	0x3d, r28	; 61
    158e:	dd 91       	ld	r29, X+
    1590:	de bf       	out	0x3e, r29	; 62
    1592:	ff 91       	pop	r31
    1594:	ef 91       	pop	r30
    1596:	df 91       	pop	r29
    1598:	cf 91       	pop	r28
    159a:	bf 91       	pop	r27
    159c:	af 91       	pop	r26
    159e:	9f 91       	pop	r25
    15a0:	8f 91       	pop	r24
    15a2:	7f 91       	pop	r23
    15a4:	6f 91       	pop	r22
    15a6:	5f 91       	pop	r21
    15a8:	4f 91       	pop	r20
    15aa:	3f 91       	pop	r19
    15ac:	2f 91       	pop	r18
    15ae:	1f 91       	pop	r17
    15b0:	0f 91       	pop	r16
    15b2:	ff 90       	pop	r15
    15b4:	ef 90       	pop	r14
    15b6:	df 90       	pop	r13
    15b8:	cf 90       	pop	r12
    15ba:	bf 90       	pop	r11
    15bc:	af 90       	pop	r10
    15be:	9f 90       	pop	r9
    15c0:	8f 90       	pop	r8
    15c2:	7f 90       	pop	r7
    15c4:	6f 90       	pop	r6
    15c6:	5f 90       	pop	r5
    15c8:	4f 90       	pop	r4
    15ca:	3f 90       	pop	r3
    15cc:	2f 90       	pop	r2
    15ce:	1f 90       	pop	r1
    15d0:	0f 90       	pop	r0
    15d2:	0f be       	out	0x3f, r0	; 63
    15d4:	0f 90       	pop	r0

    __asm__ __volatile__ ( "ret" );
    15d6:	08 95       	ret

000015d8 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( hot, flatten, naked ) );
void vPortYieldFromTick( void )
{
    portSAVE_CONTEXT();
    15d8:	0f 92       	push	r0
    15da:	0f b6       	in	r0, 0x3f	; 63
    15dc:	f8 94       	cli
    15de:	0f 92       	push	r0
    15e0:	1f 92       	push	r1
    15e2:	11 24       	eor	r1, r1
    15e4:	2f 92       	push	r2
    15e6:	3f 92       	push	r3
    15e8:	4f 92       	push	r4
    15ea:	5f 92       	push	r5
    15ec:	6f 92       	push	r6
    15ee:	7f 92       	push	r7
    15f0:	8f 92       	push	r8
    15f2:	9f 92       	push	r9
    15f4:	af 92       	push	r10
    15f6:	bf 92       	push	r11
    15f8:	cf 92       	push	r12
    15fa:	df 92       	push	r13
    15fc:	ef 92       	push	r14
    15fe:	ff 92       	push	r15
    1600:	0f 93       	push	r16
    1602:	1f 93       	push	r17
    1604:	2f 93       	push	r18
    1606:	3f 93       	push	r19
    1608:	4f 93       	push	r20
    160a:	5f 93       	push	r21
    160c:	6f 93       	push	r22
    160e:	7f 93       	push	r23
    1610:	8f 93       	push	r24
    1612:	9f 93       	push	r25
    1614:	af 93       	push	r26
    1616:	bf 93       	push	r27
    1618:	cf 93       	push	r28
    161a:	df 93       	push	r29
    161c:	ef 93       	push	r30
    161e:	ff 93       	push	r31
    1620:	a0 91 d0 03 	lds	r26, 0x03D0	; 0x8003d0 <pxCurrentTCB>
    1624:	b0 91 d1 03 	lds	r27, 0x03D1	; 0x8003d1 <pxCurrentTCB+0x1>
    1628:	0d b6       	in	r0, 0x3d	; 61
    162a:	0d 92       	st	X+, r0
    162c:	0e b6       	in	r0, 0x3e	; 62
    162e:	0d 92       	st	X+, r0

    sleep_reset();        //     reset the sleep_mode() faster than sleep_disable();
    1630:	13 be       	out	0x33, r1	; 51

    if( xTaskIncrementTick() != pdFALSE )
    1632:	0e 94 f9 10 	call	0x21f2	; 0x21f2 <xTaskIncrementTick>
    1636:	81 11       	cpse	r24, r1
    {
        vTaskSwitchContext();
    1638:	0e 94 61 12 	call	0x24c2	; 0x24c2 <vTaskSwitchContext>
    }

    portRESTORE_CONTEXT();
    163c:	a0 91 d0 03 	lds	r26, 0x03D0	; 0x8003d0 <pxCurrentTCB>
    1640:	b0 91 d1 03 	lds	r27, 0x03D1	; 0x8003d1 <pxCurrentTCB+0x1>
    1644:	cd 91       	ld	r28, X+
    1646:	cd bf       	out	0x3d, r28	; 61
    1648:	dd 91       	ld	r29, X+
    164a:	de bf       	out	0x3e, r29	; 62
    164c:	ff 91       	pop	r31
    164e:	ef 91       	pop	r30
    1650:	df 91       	pop	r29
    1652:	cf 91       	pop	r28
    1654:	bf 91       	pop	r27
    1656:	af 91       	pop	r26
    1658:	9f 91       	pop	r25
    165a:	8f 91       	pop	r24
    165c:	7f 91       	pop	r23
    165e:	6f 91       	pop	r22
    1660:	5f 91       	pop	r21
    1662:	4f 91       	pop	r20
    1664:	3f 91       	pop	r19
    1666:	2f 91       	pop	r18
    1668:	1f 91       	pop	r17
    166a:	0f 91       	pop	r16
    166c:	ff 90       	pop	r15
    166e:	ef 90       	pop	r14
    1670:	df 90       	pop	r13
    1672:	cf 90       	pop	r12
    1674:	bf 90       	pop	r11
    1676:	af 90       	pop	r10
    1678:	9f 90       	pop	r9
    167a:	8f 90       	pop	r8
    167c:	7f 90       	pop	r7
    167e:	6f 90       	pop	r6
    1680:	5f 90       	pop	r5
    1682:	4f 90       	pop	r4
    1684:	3f 90       	pop	r3
    1686:	2f 90       	pop	r2
    1688:	1f 90       	pop	r1
    168a:	0f 90       	pop	r0
    168c:	0f be       	out	0x3f, r0	; 63
    168e:	0f 90       	pop	r0

    __asm__ __volatile__ ( "ret" );
    1690:	08 95       	ret

00001692 <__vector_6>:
     */
    ISR(portSCHEDULER_ISR, ISR_NAKED) __attribute__ ((hot, flatten));
//  ISR(portSCHEDULER_ISR, ISR_NAKED ISR_NOBLOCK) __attribute__ ((hot, flatten));
    ISR(portSCHEDULER_ISR)
    {
        vPortYieldFromTick();
    1692:	0e 94 ec 0a 	call	0x15d8	; 0x15d8 <vPortYieldFromTick>
        __asm__ __volatile__ ( "reti" );
    1696:	18 95       	reti

00001698 <prvIsQueueEmpty>:
    {
        xReturn = pdFALSE;
    }

    return xReturn;
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
    1698:	0f b6       	in	r0, 0x3f	; 63
    169a:	f8 94       	cli
    169c:	0f 92       	push	r0
    169e:	fc 01       	movw	r30, r24
    16a0:	92 8d       	ldd	r25, Z+26	; 0x1a
    16a2:	0f 90       	pop	r0
    16a4:	0f be       	out	0x3f, r0	; 63
    16a6:	81 e0       	ldi	r24, 0x01	; 1
    16a8:	91 11       	cpse	r25, r1
    16aa:	80 e0       	ldi	r24, 0x00	; 0
    16ac:	08 95       	ret

000016ae <prvCopyDataToQueue>:
    16ae:	0f 93       	push	r16
    16b0:	1f 93       	push	r17
    16b2:	cf 93       	push	r28
    16b4:	df 93       	push	r29
    16b6:	ec 01       	movw	r28, r24
    16b8:	04 2f       	mov	r16, r20
    16ba:	1a 8d       	ldd	r17, Y+26	; 0x1a
    16bc:	4c 8d       	ldd	r20, Y+28	; 0x1c
    16be:	41 11       	cpse	r20, r1
    16c0:	0b c0       	rjmp	.+22     	; 0x16d8 <prvCopyDataToQueue+0x2a>
    16c2:	88 81       	ld	r24, Y
    16c4:	99 81       	ldd	r25, Y+1	; 0x01
    16c6:	89 2b       	or	r24, r25
    16c8:	e9 f5       	brne	.+122    	; 0x1744 <prvCopyDataToQueue+0x96>
    16ca:	8c 81       	ldd	r24, Y+4	; 0x04
    16cc:	9d 81       	ldd	r25, Y+5	; 0x05
    16ce:	0e 94 db 13 	call	0x27b6	; 0x27b6 <xTaskPriorityDisinherit>
    16d2:	1d 82       	std	Y+5, r1	; 0x05
    16d4:	1c 82       	std	Y+4, r1	; 0x04
    16d6:	37 c0       	rjmp	.+110    	; 0x1746 <prvCopyDataToQueue+0x98>
    16d8:	50 e0       	ldi	r21, 0x00	; 0
    16da:	01 11       	cpse	r16, r1
    16dc:	15 c0       	rjmp	.+42     	; 0x1708 <prvCopyDataToQueue+0x5a>
    16de:	8a 81       	ldd	r24, Y+2	; 0x02
    16e0:	9b 81       	ldd	r25, Y+3	; 0x03
    16e2:	0e 94 38 25 	call	0x4a70	; 0x4a70 <memcpy>
    16e6:	2c 8d       	ldd	r18, Y+28	; 0x1c
    16e8:	8a 81       	ldd	r24, Y+2	; 0x02
    16ea:	9b 81       	ldd	r25, Y+3	; 0x03
    16ec:	82 0f       	add	r24, r18
    16ee:	91 1d       	adc	r25, r1
    16f0:	9b 83       	std	Y+3, r25	; 0x03
    16f2:	8a 83       	std	Y+2, r24	; 0x02
    16f4:	2c 81       	ldd	r18, Y+4	; 0x04
    16f6:	3d 81       	ldd	r19, Y+5	; 0x05
    16f8:	82 17       	cp	r24, r18
    16fa:	93 07       	cpc	r25, r19
    16fc:	18 f1       	brcs	.+70     	; 0x1744 <prvCopyDataToQueue+0x96>
    16fe:	88 81       	ld	r24, Y
    1700:	99 81       	ldd	r25, Y+1	; 0x01
    1702:	9b 83       	std	Y+3, r25	; 0x03
    1704:	8a 83       	std	Y+2, r24	; 0x02
    1706:	1e c0       	rjmp	.+60     	; 0x1744 <prvCopyDataToQueue+0x96>
    1708:	8e 81       	ldd	r24, Y+6	; 0x06
    170a:	9f 81       	ldd	r25, Y+7	; 0x07
    170c:	0e 94 38 25 	call	0x4a70	; 0x4a70 <memcpy>
    1710:	8c 8d       	ldd	r24, Y+28	; 0x1c
    1712:	90 e0       	ldi	r25, 0x00	; 0
    1714:	91 95       	neg	r25
    1716:	81 95       	neg	r24
    1718:	91 09       	sbc	r25, r1
    171a:	2e 81       	ldd	r18, Y+6	; 0x06
    171c:	3f 81       	ldd	r19, Y+7	; 0x07
    171e:	28 0f       	add	r18, r24
    1720:	39 1f       	adc	r19, r25
    1722:	3f 83       	std	Y+7, r19	; 0x07
    1724:	2e 83       	std	Y+6, r18	; 0x06
    1726:	48 81       	ld	r20, Y
    1728:	59 81       	ldd	r21, Y+1	; 0x01
    172a:	24 17       	cp	r18, r20
    172c:	35 07       	cpc	r19, r21
    172e:	30 f4       	brcc	.+12     	; 0x173c <prvCopyDataToQueue+0x8e>
    1730:	2c 81       	ldd	r18, Y+4	; 0x04
    1732:	3d 81       	ldd	r19, Y+5	; 0x05
    1734:	82 0f       	add	r24, r18
    1736:	93 1f       	adc	r25, r19
    1738:	9f 83       	std	Y+7, r25	; 0x07
    173a:	8e 83       	std	Y+6, r24	; 0x06
    173c:	02 30       	cpi	r16, 0x02	; 2
    173e:	11 f4       	brne	.+4      	; 0x1744 <prvCopyDataToQueue+0x96>
    1740:	11 11       	cpse	r17, r1
    1742:	11 50       	subi	r17, 0x01	; 1
    1744:	80 e0       	ldi	r24, 0x00	; 0
    1746:	1f 5f       	subi	r17, 0xFF	; 255
    1748:	1a 8f       	std	Y+26, r17	; 0x1a
    174a:	df 91       	pop	r29
    174c:	cf 91       	pop	r28
    174e:	1f 91       	pop	r17
    1750:	0f 91       	pop	r16
    1752:	08 95       	ret

00001754 <prvCopyDataFromQueue>:
    1754:	fc 01       	movw	r30, r24
    1756:	cb 01       	movw	r24, r22
    1758:	44 8d       	ldd	r20, Z+28	; 0x1c
    175a:	44 23       	and	r20, r20
    175c:	a1 f0       	breq	.+40     	; 0x1786 <prvCopyDataFromQueue+0x32>
    175e:	50 e0       	ldi	r21, 0x00	; 0
    1760:	26 81       	ldd	r18, Z+6	; 0x06
    1762:	37 81       	ldd	r19, Z+7	; 0x07
    1764:	24 0f       	add	r18, r20
    1766:	35 1f       	adc	r19, r21
    1768:	37 83       	std	Z+7, r19	; 0x07
    176a:	26 83       	std	Z+6, r18	; 0x06
    176c:	64 81       	ldd	r22, Z+4	; 0x04
    176e:	75 81       	ldd	r23, Z+5	; 0x05
    1770:	26 17       	cp	r18, r22
    1772:	37 07       	cpc	r19, r23
    1774:	20 f0       	brcs	.+8      	; 0x177e <prvCopyDataFromQueue+0x2a>
    1776:	20 81       	ld	r18, Z
    1778:	31 81       	ldd	r19, Z+1	; 0x01
    177a:	37 83       	std	Z+7, r19	; 0x07
    177c:	26 83       	std	Z+6, r18	; 0x06
    177e:	66 81       	ldd	r22, Z+6	; 0x06
    1780:	77 81       	ldd	r23, Z+7	; 0x07
    1782:	0c 94 38 25 	jmp	0x4a70	; 0x4a70 <memcpy>
    1786:	08 95       	ret

00001788 <prvUnlockQueue>:
    1788:	ef 92       	push	r14
    178a:	ff 92       	push	r15
    178c:	1f 93       	push	r17
    178e:	cf 93       	push	r28
    1790:	df 93       	push	r29
    1792:	ec 01       	movw	r28, r24
    1794:	0f b6       	in	r0, 0x3f	; 63
    1796:	f8 94       	cli
    1798:	0f 92       	push	r0
    179a:	1e 8d       	ldd	r17, Y+30	; 0x1e
    179c:	7c 01       	movw	r14, r24
    179e:	81 e1       	ldi	r24, 0x11	; 17
    17a0:	e8 0e       	add	r14, r24
    17a2:	f1 1c       	adc	r15, r1
    17a4:	11 16       	cp	r1, r17
    17a6:	5c f4       	brge	.+22     	; 0x17be <prvUnlockQueue+0x36>
    17a8:	89 89       	ldd	r24, Y+17	; 0x11
    17aa:	88 23       	and	r24, r24
    17ac:	41 f0       	breq	.+16     	; 0x17be <prvUnlockQueue+0x36>
    17ae:	c7 01       	movw	r24, r14
    17b0:	0e 94 e8 12 	call	0x25d0	; 0x25d0 <xTaskRemoveFromEventList>
    17b4:	81 11       	cpse	r24, r1
    17b6:	0e 94 66 13 	call	0x26cc	; 0x26cc <vTaskMissedYield>
    17ba:	11 50       	subi	r17, 0x01	; 1
    17bc:	f3 cf       	rjmp	.-26     	; 0x17a4 <prvUnlockQueue+0x1c>
    17be:	8f ef       	ldi	r24, 0xFF	; 255
    17c0:	8e 8f       	std	Y+30, r24	; 0x1e
    17c2:	0f 90       	pop	r0
    17c4:	0f be       	out	0x3f, r0	; 63
    17c6:	0f b6       	in	r0, 0x3f	; 63
    17c8:	f8 94       	cli
    17ca:	0f 92       	push	r0
    17cc:	1d 8d       	ldd	r17, Y+29	; 0x1d
    17ce:	7e 01       	movw	r14, r28
    17d0:	88 e0       	ldi	r24, 0x08	; 8
    17d2:	e8 0e       	add	r14, r24
    17d4:	f1 1c       	adc	r15, r1
    17d6:	11 16       	cp	r1, r17
    17d8:	5c f4       	brge	.+22     	; 0x17f0 <prvUnlockQueue+0x68>
    17da:	88 85       	ldd	r24, Y+8	; 0x08
    17dc:	88 23       	and	r24, r24
    17de:	41 f0       	breq	.+16     	; 0x17f0 <prvUnlockQueue+0x68>
    17e0:	c7 01       	movw	r24, r14
    17e2:	0e 94 e8 12 	call	0x25d0	; 0x25d0 <xTaskRemoveFromEventList>
    17e6:	81 11       	cpse	r24, r1
    17e8:	0e 94 66 13 	call	0x26cc	; 0x26cc <vTaskMissedYield>
    17ec:	11 50       	subi	r17, 0x01	; 1
    17ee:	f3 cf       	rjmp	.-26     	; 0x17d6 <prvUnlockQueue+0x4e>
    17f0:	8f ef       	ldi	r24, 0xFF	; 255
    17f2:	8d 8f       	std	Y+29, r24	; 0x1d
    17f4:	0f 90       	pop	r0
    17f6:	0f be       	out	0x3f, r0	; 63
    17f8:	df 91       	pop	r29
    17fa:	cf 91       	pop	r28
    17fc:	1f 91       	pop	r17
    17fe:	ff 90       	pop	r15
    1800:	ef 90       	pop	r14
    1802:	08 95       	ret

00001804 <xQueueGenericReset>:
    1804:	cf 93       	push	r28
    1806:	df 93       	push	r29
    1808:	ec 01       	movw	r28, r24
    180a:	0f b6       	in	r0, 0x3f	; 63
    180c:	f8 94       	cli
    180e:	0f 92       	push	r0
    1810:	48 81       	ld	r20, Y
    1812:	59 81       	ldd	r21, Y+1	; 0x01
    1814:	8b 8d       	ldd	r24, Y+27	; 0x1b
    1816:	7c 8d       	ldd	r23, Y+28	; 0x1c
    1818:	9a 01       	movw	r18, r20
    181a:	87 9f       	mul	r24, r23
    181c:	20 0d       	add	r18, r0
    181e:	31 1d       	adc	r19, r1
    1820:	11 24       	eor	r1, r1
    1822:	3d 83       	std	Y+5, r19	; 0x05
    1824:	2c 83       	std	Y+4, r18	; 0x04
    1826:	1a 8e       	std	Y+26, r1	; 0x1a
    1828:	5b 83       	std	Y+3, r21	; 0x03
    182a:	4a 83       	std	Y+2, r20	; 0x02
    182c:	90 e0       	ldi	r25, 0x00	; 0
    182e:	01 97       	sbiw	r24, 0x01	; 1
    1830:	78 9f       	mul	r23, r24
    1832:	90 01       	movw	r18, r0
    1834:	79 9f       	mul	r23, r25
    1836:	30 0d       	add	r19, r0
    1838:	11 24       	eor	r1, r1
    183a:	ca 01       	movw	r24, r20
    183c:	82 0f       	add	r24, r18
    183e:	93 1f       	adc	r25, r19
    1840:	9f 83       	std	Y+7, r25	; 0x07
    1842:	8e 83       	std	Y+6, r24	; 0x06
    1844:	8f ef       	ldi	r24, 0xFF	; 255
    1846:	8d 8f       	std	Y+29, r24	; 0x1d
    1848:	8e 8f       	std	Y+30, r24	; 0x1e
    184a:	61 11       	cpse	r22, r1
    184c:	0c c0       	rjmp	.+24     	; 0x1866 <xQueueGenericReset+0x62>
    184e:	88 85       	ldd	r24, Y+8	; 0x08
    1850:	88 23       	and	r24, r24
    1852:	89 f0       	breq	.+34     	; 0x1876 <xQueueGenericReset+0x72>
    1854:	ce 01       	movw	r24, r28
    1856:	08 96       	adiw	r24, 0x08	; 8
    1858:	0e 94 e8 12 	call	0x25d0	; 0x25d0 <xTaskRemoveFromEventList>
    185c:	88 23       	and	r24, r24
    185e:	59 f0       	breq	.+22     	; 0x1876 <xQueueGenericReset+0x72>
    1860:	0e 94 93 0a 	call	0x1526	; 0x1526 <vPortYield>
    1864:	08 c0       	rjmp	.+16     	; 0x1876 <xQueueGenericReset+0x72>
    1866:	ce 01       	movw	r24, r28
    1868:	08 96       	adiw	r24, 0x08	; 8
    186a:	0e 94 60 09 	call	0x12c0	; 0x12c0 <vListInitialise>
    186e:	ce 01       	movw	r24, r28
    1870:	41 96       	adiw	r24, 0x11	; 17
    1872:	0e 94 60 09 	call	0x12c0	; 0x12c0 <vListInitialise>
    1876:	0f 90       	pop	r0
    1878:	0f be       	out	0x3f, r0	; 63
    187a:	81 e0       	ldi	r24, 0x01	; 1
    187c:	df 91       	pop	r29
    187e:	cf 91       	pop	r28
    1880:	08 95       	ret

00001882 <xQueueGenericCreate>:
    1882:	0f 93       	push	r16
    1884:	1f 93       	push	r17
    1886:	cf 93       	push	r28
    1888:	df 93       	push	r29
    188a:	08 2f       	mov	r16, r24
    188c:	16 2f       	mov	r17, r22
    188e:	66 23       	and	r22, r22
    1890:	21 f0       	breq	.+8      	; 0x189a <xQueueGenericCreate+0x18>
    1892:	86 9f       	mul	r24, r22
    1894:	c0 01       	movw	r24, r0
    1896:	11 24       	eor	r1, r1
    1898:	02 c0       	rjmp	.+4      	; 0x189e <xQueueGenericCreate+0x1c>
    189a:	80 e0       	ldi	r24, 0x00	; 0
    189c:	90 e0       	ldi	r25, 0x00	; 0
    189e:	4f 96       	adiw	r24, 0x1f	; 31
    18a0:	0e 94 3c 09 	call	0x1278	; 0x1278 <pvPortMalloc>
    18a4:	ec 01       	movw	r28, r24
    18a6:	00 97       	sbiw	r24, 0x00	; 0
    18a8:	71 f0       	breq	.+28     	; 0x18c6 <xQueueGenericCreate+0x44>
    18aa:	11 11       	cpse	r17, r1
    18ac:	03 c0       	rjmp	.+6      	; 0x18b4 <xQueueGenericCreate+0x32>
    18ae:	99 83       	std	Y+1, r25	; 0x01
    18b0:	88 83       	st	Y, r24
    18b2:	03 c0       	rjmp	.+6      	; 0x18ba <xQueueGenericCreate+0x38>
    18b4:	4f 96       	adiw	r24, 0x1f	; 31
    18b6:	99 83       	std	Y+1, r25	; 0x01
    18b8:	88 83       	st	Y, r24
    18ba:	0b 8f       	std	Y+27, r16	; 0x1b
    18bc:	1c 8f       	std	Y+28, r17	; 0x1c
    18be:	61 e0       	ldi	r22, 0x01	; 1
    18c0:	ce 01       	movw	r24, r28
    18c2:	0e 94 02 0c 	call	0x1804	; 0x1804 <xQueueGenericReset>
    18c6:	ce 01       	movw	r24, r28
    18c8:	df 91       	pop	r29
    18ca:	cf 91       	pop	r28
    18cc:	1f 91       	pop	r17
    18ce:	0f 91       	pop	r16
    18d0:	08 95       	ret

000018d2 <xQueueGenericSend>:
    18d2:	af 92       	push	r10
    18d4:	bf 92       	push	r11
    18d6:	cf 92       	push	r12
    18d8:	df 92       	push	r13
    18da:	ff 92       	push	r15
    18dc:	0f 93       	push	r16
    18de:	1f 93       	push	r17
    18e0:	cf 93       	push	r28
    18e2:	df 93       	push	r29
    18e4:	00 d0       	rcall	.+0      	; 0x18e6 <xQueueGenericSend+0x14>
    18e6:	00 d0       	rcall	.+0      	; 0x18e8 <xQueueGenericSend+0x16>
    18e8:	1f 92       	push	r1
    18ea:	cd b7       	in	r28, 0x3d	; 61
    18ec:	de b7       	in	r29, 0x3e	; 62
    18ee:	8c 01       	movw	r16, r24
    18f0:	6b 01       	movw	r12, r22
    18f2:	5d 83       	std	Y+5, r21	; 0x05
    18f4:	4c 83       	std	Y+4, r20	; 0x04
    18f6:	f2 2e       	mov	r15, r18
    18f8:	80 e0       	ldi	r24, 0x00	; 0
    18fa:	58 01       	movw	r10, r16
    18fc:	98 e0       	ldi	r25, 0x08	; 8
    18fe:	a9 0e       	add	r10, r25
    1900:	b1 1c       	adc	r11, r1
    1902:	0f b6       	in	r0, 0x3f	; 63
    1904:	f8 94       	cli
    1906:	0f 92       	push	r0
    1908:	f8 01       	movw	r30, r16
    190a:	22 8d       	ldd	r18, Z+26	; 0x1a
    190c:	93 8d       	ldd	r25, Z+27	; 0x1b
    190e:	29 17       	cp	r18, r25
    1910:	18 f0       	brcs	.+6      	; 0x1918 <xQueueGenericSend+0x46>
    1912:	f2 e0       	ldi	r31, 0x02	; 2
    1914:	ff 12       	cpse	r15, r31
    1916:	14 c0       	rjmp	.+40     	; 0x1940 <xQueueGenericSend+0x6e>
    1918:	4f 2d       	mov	r20, r15
    191a:	b6 01       	movw	r22, r12
    191c:	c8 01       	movw	r24, r16
    191e:	0e 94 57 0b 	call	0x16ae	; 0x16ae <prvCopyDataToQueue>
    1922:	f8 01       	movw	r30, r16
    1924:	91 89       	ldd	r25, Z+17	; 0x11
    1926:	99 23       	and	r25, r25
    1928:	21 f0       	breq	.+8      	; 0x1932 <xQueueGenericSend+0x60>
    192a:	c8 01       	movw	r24, r16
    192c:	41 96       	adiw	r24, 0x11	; 17
    192e:	0e 94 e8 12 	call	0x25d0	; 0x25d0 <xTaskRemoveFromEventList>
    1932:	81 11       	cpse	r24, r1
    1934:	0e 94 93 0a 	call	0x1526	; 0x1526 <vPortYield>
    1938:	0f 90       	pop	r0
    193a:	0f be       	out	0x3f, r0	; 63
    193c:	81 e0       	ldi	r24, 0x01	; 1
    193e:	50 c0       	rjmp	.+160    	; 0x19e0 <xQueueGenericSend+0x10e>
    1940:	2c 81       	ldd	r18, Y+4	; 0x04
    1942:	3d 81       	ldd	r19, Y+5	; 0x05
    1944:	23 2b       	or	r18, r19
    1946:	19 f4       	brne	.+6      	; 0x194e <xQueueGenericSend+0x7c>
    1948:	0f 90       	pop	r0
    194a:	0f be       	out	0x3f, r0	; 63
    194c:	48 c0       	rjmp	.+144    	; 0x19de <xQueueGenericSend+0x10c>
    194e:	81 11       	cpse	r24, r1
    1950:	04 c0       	rjmp	.+8      	; 0x195a <xQueueGenericSend+0x88>
    1952:	ce 01       	movw	r24, r28
    1954:	01 96       	adiw	r24, 0x01	; 1
    1956:	0e 94 28 13 	call	0x2650	; 0x2650 <vTaskInternalSetTimeOutState>
    195a:	0f 90       	pop	r0
    195c:	0f be       	out	0x3f, r0	; 63
    195e:	0e 94 e9 10 	call	0x21d2	; 0x21d2 <vTaskSuspendAll>
    1962:	0f b6       	in	r0, 0x3f	; 63
    1964:	f8 94       	cli
    1966:	0f 92       	push	r0
    1968:	f8 01       	movw	r30, r16
    196a:	85 8d       	ldd	r24, Z+29	; 0x1d
    196c:	8f 3f       	cpi	r24, 0xFF	; 255
    196e:	09 f4       	brne	.+2      	; 0x1972 <xQueueGenericSend+0xa0>
    1970:	15 8e       	std	Z+29, r1	; 0x1d
    1972:	f8 01       	movw	r30, r16
    1974:	86 8d       	ldd	r24, Z+30	; 0x1e
    1976:	8f 3f       	cpi	r24, 0xFF	; 255
    1978:	09 f4       	brne	.+2      	; 0x197c <xQueueGenericSend+0xaa>
    197a:	16 8e       	std	Z+30, r1	; 0x1e
    197c:	0f 90       	pop	r0
    197e:	0f be       	out	0x3f, r0	; 63
    1980:	be 01       	movw	r22, r28
    1982:	6c 5f       	subi	r22, 0xFC	; 252
    1984:	7f 4f       	sbci	r23, 0xFF	; 255
    1986:	ce 01       	movw	r24, r28
    1988:	01 96       	adiw	r24, 0x01	; 1
    198a:	0e 94 33 13 	call	0x2666	; 0x2666 <xTaskCheckForTimeOut>
    198e:	81 11       	cpse	r24, r1
    1990:	21 c0       	rjmp	.+66     	; 0x19d4 <xQueueGenericSend+0x102>
    1992:	0f b6       	in	r0, 0x3f	; 63
    1994:	f8 94       	cli
    1996:	0f 92       	push	r0
    1998:	f8 01       	movw	r30, r16
    199a:	92 8d       	ldd	r25, Z+26	; 0x1a
    199c:	83 8d       	ldd	r24, Z+27	; 0x1b
    199e:	0f 90       	pop	r0
    19a0:	0f be       	out	0x3f, r0	; 63
    19a2:	98 13       	cpse	r25, r24
    19a4:	11 c0       	rjmp	.+34     	; 0x19c8 <xQueueGenericSend+0xf6>
    19a6:	6c 81       	ldd	r22, Y+4	; 0x04
    19a8:	7d 81       	ldd	r23, Y+5	; 0x05
    19aa:	c5 01       	movw	r24, r10
    19ac:	0e 94 bf 12 	call	0x257e	; 0x257e <vTaskPlaceOnEventList>
    19b0:	c8 01       	movw	r24, r16
    19b2:	0e 94 c4 0b 	call	0x1788	; 0x1788 <prvUnlockQueue>
    19b6:	0e 94 a5 11 	call	0x234a	; 0x234a <xTaskResumeAll>
    19ba:	88 23       	and	r24, r24
    19bc:	11 f0       	breq	.+4      	; 0x19c2 <xQueueGenericSend+0xf0>
    19be:	81 e0       	ldi	r24, 0x01	; 1
    19c0:	a0 cf       	rjmp	.-192    	; 0x1902 <xQueueGenericSend+0x30>
    19c2:	0e 94 93 0a 	call	0x1526	; 0x1526 <vPortYield>
    19c6:	fb cf       	rjmp	.-10     	; 0x19be <xQueueGenericSend+0xec>
    19c8:	c8 01       	movw	r24, r16
    19ca:	0e 94 c4 0b 	call	0x1788	; 0x1788 <prvUnlockQueue>
    19ce:	0e 94 a5 11 	call	0x234a	; 0x234a <xTaskResumeAll>
    19d2:	f5 cf       	rjmp	.-22     	; 0x19be <xQueueGenericSend+0xec>
    19d4:	c8 01       	movw	r24, r16
    19d6:	0e 94 c4 0b 	call	0x1788	; 0x1788 <prvUnlockQueue>
    19da:	0e 94 a5 11 	call	0x234a	; 0x234a <xTaskResumeAll>
    19de:	80 e0       	ldi	r24, 0x00	; 0
    19e0:	0f 90       	pop	r0
    19e2:	0f 90       	pop	r0
    19e4:	0f 90       	pop	r0
    19e6:	0f 90       	pop	r0
    19e8:	0f 90       	pop	r0
    19ea:	df 91       	pop	r29
    19ec:	cf 91       	pop	r28
    19ee:	1f 91       	pop	r17
    19f0:	0f 91       	pop	r16
    19f2:	ff 90       	pop	r15
    19f4:	df 90       	pop	r13
    19f6:	cf 90       	pop	r12
    19f8:	bf 90       	pop	r11
    19fa:	af 90       	pop	r10
    19fc:	08 95       	ret

000019fe <xQueueGenericSendFromISR>:
    19fe:	ef 92       	push	r14
    1a00:	ff 92       	push	r15
    1a02:	1f 93       	push	r17
    1a04:	cf 93       	push	r28
    1a06:	df 93       	push	r29
    1a08:	ec 01       	movw	r28, r24
    1a0a:	9a 8d       	ldd	r25, Y+26	; 0x1a
    1a0c:	8b 8d       	ldd	r24, Y+27	; 0x1b
    1a0e:	98 17       	cp	r25, r24
    1a10:	10 f0       	brcs	.+4      	; 0x1a16 <xQueueGenericSendFromISR+0x18>
    1a12:	22 30       	cpi	r18, 0x02	; 2
    1a14:	e1 f4       	brne	.+56     	; 0x1a4e <xQueueGenericSendFromISR+0x50>
    1a16:	7a 01       	movw	r14, r20
    1a18:	1e 8d       	ldd	r17, Y+30	; 0x1e
    1a1a:	42 2f       	mov	r20, r18
    1a1c:	ce 01       	movw	r24, r28
    1a1e:	0e 94 57 0b 	call	0x16ae	; 0x16ae <prvCopyDataToQueue>
    1a22:	1f 3f       	cpi	r17, 0xFF	; 255
    1a24:	81 f4       	brne	.+32     	; 0x1a46 <xQueueGenericSendFromISR+0x48>
    1a26:	89 89       	ldd	r24, Y+17	; 0x11
    1a28:	88 23       	and	r24, r24
    1a2a:	79 f0       	breq	.+30     	; 0x1a4a <xQueueGenericSendFromISR+0x4c>
    1a2c:	ce 01       	movw	r24, r28
    1a2e:	41 96       	adiw	r24, 0x11	; 17
    1a30:	0e 94 e8 12 	call	0x25d0	; 0x25d0 <xTaskRemoveFromEventList>
    1a34:	88 23       	and	r24, r24
    1a36:	49 f0       	breq	.+18     	; 0x1a4a <xQueueGenericSendFromISR+0x4c>
    1a38:	e1 14       	cp	r14, r1
    1a3a:	f1 04       	cpc	r15, r1
    1a3c:	31 f0       	breq	.+12     	; 0x1a4a <xQueueGenericSendFromISR+0x4c>
    1a3e:	81 e0       	ldi	r24, 0x01	; 1
    1a40:	f7 01       	movw	r30, r14
    1a42:	80 83       	st	Z, r24
    1a44:	05 c0       	rjmp	.+10     	; 0x1a50 <xQueueGenericSendFromISR+0x52>
    1a46:	1f 5f       	subi	r17, 0xFF	; 255
    1a48:	1e 8f       	std	Y+30, r17	; 0x1e
    1a4a:	81 e0       	ldi	r24, 0x01	; 1
    1a4c:	01 c0       	rjmp	.+2      	; 0x1a50 <xQueueGenericSendFromISR+0x52>
    1a4e:	80 e0       	ldi	r24, 0x00	; 0
    1a50:	df 91       	pop	r29
    1a52:	cf 91       	pop	r28
    1a54:	1f 91       	pop	r17
    1a56:	ff 90       	pop	r15
    1a58:	ef 90       	pop	r14
    1a5a:	08 95       	ret

00001a5c <xQueueGiveFromISR>:
    1a5c:	cf 93       	push	r28
    1a5e:	df 93       	push	r29
    1a60:	fc 01       	movw	r30, r24
    1a62:	92 8d       	ldd	r25, Z+26	; 0x1a
    1a64:	83 8d       	ldd	r24, Z+27	; 0x1b
    1a66:	98 17       	cp	r25, r24
    1a68:	c0 f4       	brcc	.+48     	; 0x1a9a <xQueueGiveFromISR+0x3e>
    1a6a:	86 8d       	ldd	r24, Z+30	; 0x1e
    1a6c:	9f 5f       	subi	r25, 0xFF	; 255
    1a6e:	92 8f       	std	Z+26, r25	; 0x1a
    1a70:	8f 3f       	cpi	r24, 0xFF	; 255
    1a72:	79 f4       	brne	.+30     	; 0x1a92 <xQueueGiveFromISR+0x36>
    1a74:	81 89       	ldd	r24, Z+17	; 0x11
    1a76:	88 23       	and	r24, r24
    1a78:	71 f0       	breq	.+28     	; 0x1a96 <xQueueGiveFromISR+0x3a>
    1a7a:	eb 01       	movw	r28, r22
    1a7c:	cf 01       	movw	r24, r30
    1a7e:	41 96       	adiw	r24, 0x11	; 17
    1a80:	0e 94 e8 12 	call	0x25d0	; 0x25d0 <xTaskRemoveFromEventList>
    1a84:	88 23       	and	r24, r24
    1a86:	39 f0       	breq	.+14     	; 0x1a96 <xQueueGiveFromISR+0x3a>
    1a88:	20 97       	sbiw	r28, 0x00	; 0
    1a8a:	29 f0       	breq	.+10     	; 0x1a96 <xQueueGiveFromISR+0x3a>
    1a8c:	81 e0       	ldi	r24, 0x01	; 1
    1a8e:	88 83       	st	Y, r24
    1a90:	05 c0       	rjmp	.+10     	; 0x1a9c <xQueueGiveFromISR+0x40>
    1a92:	8f 5f       	subi	r24, 0xFF	; 255
    1a94:	86 8f       	std	Z+30, r24	; 0x1e
    1a96:	81 e0       	ldi	r24, 0x01	; 1
    1a98:	01 c0       	rjmp	.+2      	; 0x1a9c <xQueueGiveFromISR+0x40>
    1a9a:	80 e0       	ldi	r24, 0x00	; 0
    1a9c:	df 91       	pop	r29
    1a9e:	cf 91       	pop	r28
    1aa0:	08 95       	ret

00001aa2 <xQueueReceive>:
    1aa2:	af 92       	push	r10
    1aa4:	bf 92       	push	r11
    1aa6:	cf 92       	push	r12
    1aa8:	df 92       	push	r13
    1aaa:	ff 92       	push	r15
    1aac:	0f 93       	push	r16
    1aae:	1f 93       	push	r17
    1ab0:	cf 93       	push	r28
    1ab2:	df 93       	push	r29
    1ab4:	00 d0       	rcall	.+0      	; 0x1ab6 <xQueueReceive+0x14>
    1ab6:	00 d0       	rcall	.+0      	; 0x1ab8 <xQueueReceive+0x16>
    1ab8:	1f 92       	push	r1
    1aba:	cd b7       	in	r28, 0x3d	; 61
    1abc:	de b7       	in	r29, 0x3e	; 62
    1abe:	8c 01       	movw	r16, r24
    1ac0:	6b 01       	movw	r12, r22
    1ac2:	5d 83       	std	Y+5, r21	; 0x05
    1ac4:	4c 83       	std	Y+4, r20	; 0x04
    1ac6:	80 e0       	ldi	r24, 0x00	; 0
    1ac8:	58 01       	movw	r10, r16
    1aca:	91 e1       	ldi	r25, 0x11	; 17
    1acc:	a9 0e       	add	r10, r25
    1ace:	b1 1c       	adc	r11, r1
    1ad0:	0f b6       	in	r0, 0x3f	; 63
    1ad2:	f8 94       	cli
    1ad4:	0f 92       	push	r0
    1ad6:	f8 01       	movw	r30, r16
    1ad8:	f2 8c       	ldd	r15, Z+26	; 0x1a
    1ada:	ff 20       	and	r15, r15
    1adc:	a9 f0       	breq	.+42     	; 0x1b08 <xQueueReceive+0x66>
    1ade:	b6 01       	movw	r22, r12
    1ae0:	c8 01       	movw	r24, r16
    1ae2:	0e 94 aa 0b 	call	0x1754	; 0x1754 <prvCopyDataFromQueue>
    1ae6:	fa 94       	dec	r15
    1ae8:	f8 01       	movw	r30, r16
    1aea:	f2 8e       	std	Z+26, r15	; 0x1a
    1aec:	80 85       	ldd	r24, Z+8	; 0x08
    1aee:	88 23       	and	r24, r24
    1af0:	39 f0       	breq	.+14     	; 0x1b00 <xQueueReceive+0x5e>
    1af2:	c8 01       	movw	r24, r16
    1af4:	08 96       	adiw	r24, 0x08	; 8
    1af6:	0e 94 e8 12 	call	0x25d0	; 0x25d0 <xTaskRemoveFromEventList>
    1afa:	81 11       	cpse	r24, r1
    1afc:	0e 94 93 0a 	call	0x1526	; 0x1526 <vPortYield>
    1b00:	0f 90       	pop	r0
    1b02:	0f be       	out	0x3f, r0	; 63
    1b04:	81 e0       	ldi	r24, 0x01	; 1
    1b06:	50 c0       	rjmp	.+160    	; 0x1ba8 <xQueueReceive+0x106>
    1b08:	2c 81       	ldd	r18, Y+4	; 0x04
    1b0a:	3d 81       	ldd	r19, Y+5	; 0x05
    1b0c:	23 2b       	or	r18, r19
    1b0e:	19 f4       	brne	.+6      	; 0x1b16 <xQueueReceive+0x74>
    1b10:	0f 90       	pop	r0
    1b12:	0f be       	out	0x3f, r0	; 63
    1b14:	48 c0       	rjmp	.+144    	; 0x1ba6 <xQueueReceive+0x104>
    1b16:	81 11       	cpse	r24, r1
    1b18:	04 c0       	rjmp	.+8      	; 0x1b22 <xQueueReceive+0x80>
    1b1a:	ce 01       	movw	r24, r28
    1b1c:	01 96       	adiw	r24, 0x01	; 1
    1b1e:	0e 94 28 13 	call	0x2650	; 0x2650 <vTaskInternalSetTimeOutState>
    1b22:	0f 90       	pop	r0
    1b24:	0f be       	out	0x3f, r0	; 63
    1b26:	0e 94 e9 10 	call	0x21d2	; 0x21d2 <vTaskSuspendAll>
    1b2a:	0f b6       	in	r0, 0x3f	; 63
    1b2c:	f8 94       	cli
    1b2e:	0f 92       	push	r0
    1b30:	f8 01       	movw	r30, r16
    1b32:	85 8d       	ldd	r24, Z+29	; 0x1d
    1b34:	8f 3f       	cpi	r24, 0xFF	; 255
    1b36:	09 f4       	brne	.+2      	; 0x1b3a <xQueueReceive+0x98>
    1b38:	15 8e       	std	Z+29, r1	; 0x1d
    1b3a:	f8 01       	movw	r30, r16
    1b3c:	86 8d       	ldd	r24, Z+30	; 0x1e
    1b3e:	8f 3f       	cpi	r24, 0xFF	; 255
    1b40:	09 f4       	brne	.+2      	; 0x1b44 <xQueueReceive+0xa2>
    1b42:	16 8e       	std	Z+30, r1	; 0x1e
    1b44:	0f 90       	pop	r0
    1b46:	0f be       	out	0x3f, r0	; 63
    1b48:	be 01       	movw	r22, r28
    1b4a:	6c 5f       	subi	r22, 0xFC	; 252
    1b4c:	7f 4f       	sbci	r23, 0xFF	; 255
    1b4e:	ce 01       	movw	r24, r28
    1b50:	01 96       	adiw	r24, 0x01	; 1
    1b52:	0e 94 33 13 	call	0x2666	; 0x2666 <xTaskCheckForTimeOut>
    1b56:	81 11       	cpse	r24, r1
    1b58:	1c c0       	rjmp	.+56     	; 0x1b92 <xQueueReceive+0xf0>
    1b5a:	c8 01       	movw	r24, r16
    1b5c:	0e 94 4c 0b 	call	0x1698	; 0x1698 <prvIsQueueEmpty>
    1b60:	88 23       	and	r24, r24
    1b62:	89 f0       	breq	.+34     	; 0x1b86 <xQueueReceive+0xe4>
    1b64:	6c 81       	ldd	r22, Y+4	; 0x04
    1b66:	7d 81       	ldd	r23, Y+5	; 0x05
    1b68:	c5 01       	movw	r24, r10
    1b6a:	0e 94 bf 12 	call	0x257e	; 0x257e <vTaskPlaceOnEventList>
    1b6e:	c8 01       	movw	r24, r16
    1b70:	0e 94 c4 0b 	call	0x1788	; 0x1788 <prvUnlockQueue>
    1b74:	0e 94 a5 11 	call	0x234a	; 0x234a <xTaskResumeAll>
    1b78:	88 23       	and	r24, r24
    1b7a:	11 f0       	breq	.+4      	; 0x1b80 <xQueueReceive+0xde>
    1b7c:	81 e0       	ldi	r24, 0x01	; 1
    1b7e:	a8 cf       	rjmp	.-176    	; 0x1ad0 <xQueueReceive+0x2e>
    1b80:	0e 94 93 0a 	call	0x1526	; 0x1526 <vPortYield>
    1b84:	fb cf       	rjmp	.-10     	; 0x1b7c <xQueueReceive+0xda>
    1b86:	c8 01       	movw	r24, r16
    1b88:	0e 94 c4 0b 	call	0x1788	; 0x1788 <prvUnlockQueue>
    1b8c:	0e 94 a5 11 	call	0x234a	; 0x234a <xTaskResumeAll>
    1b90:	f5 cf       	rjmp	.-22     	; 0x1b7c <xQueueReceive+0xda>
    1b92:	c8 01       	movw	r24, r16
    1b94:	0e 94 c4 0b 	call	0x1788	; 0x1788 <prvUnlockQueue>
    1b98:	0e 94 a5 11 	call	0x234a	; 0x234a <xTaskResumeAll>
    1b9c:	c8 01       	movw	r24, r16
    1b9e:	0e 94 4c 0b 	call	0x1698	; 0x1698 <prvIsQueueEmpty>
    1ba2:	88 23       	and	r24, r24
    1ba4:	59 f3       	breq	.-42     	; 0x1b7c <xQueueReceive+0xda>
    1ba6:	80 e0       	ldi	r24, 0x00	; 0
    1ba8:	0f 90       	pop	r0
    1baa:	0f 90       	pop	r0
    1bac:	0f 90       	pop	r0
    1bae:	0f 90       	pop	r0
    1bb0:	0f 90       	pop	r0
    1bb2:	df 91       	pop	r29
    1bb4:	cf 91       	pop	r28
    1bb6:	1f 91       	pop	r17
    1bb8:	0f 91       	pop	r16
    1bba:	ff 90       	pop	r15
    1bbc:	df 90       	pop	r13
    1bbe:	cf 90       	pop	r12
    1bc0:	bf 90       	pop	r11
    1bc2:	af 90       	pop	r10
    1bc4:	08 95       	ret

00001bc6 <xQueueSemaphoreTake>:
    1bc6:	cf 92       	push	r12
    1bc8:	df 92       	push	r13
    1bca:	ff 92       	push	r15
    1bcc:	0f 93       	push	r16
    1bce:	1f 93       	push	r17
    1bd0:	cf 93       	push	r28
    1bd2:	df 93       	push	r29
    1bd4:	00 d0       	rcall	.+0      	; 0x1bd6 <xQueueSemaphoreTake+0x10>
    1bd6:	00 d0       	rcall	.+0      	; 0x1bd8 <xQueueSemaphoreTake+0x12>
    1bd8:	1f 92       	push	r1
    1bda:	cd b7       	in	r28, 0x3d	; 61
    1bdc:	de b7       	in	r29, 0x3e	; 62
    1bde:	8c 01       	movw	r16, r24
    1be0:	7d 83       	std	Y+5, r23	; 0x05
    1be2:	6c 83       	std	Y+4, r22	; 0x04
    1be4:	f1 2c       	mov	r15, r1
    1be6:	90 e0       	ldi	r25, 0x00	; 0
    1be8:	68 01       	movw	r12, r16
    1bea:	81 e1       	ldi	r24, 0x11	; 17
    1bec:	c8 0e       	add	r12, r24
    1bee:	d1 1c       	adc	r13, r1
    1bf0:	0f b6       	in	r0, 0x3f	; 63
    1bf2:	f8 94       	cli
    1bf4:	0f 92       	push	r0
    1bf6:	d8 01       	movw	r26, r16
    1bf8:	5a 96       	adiw	r26, 0x1a	; 26
    1bfa:	8c 91       	ld	r24, X
    1bfc:	5a 97       	sbiw	r26, 0x1a	; 26
    1bfe:	88 23       	and	r24, r24
    1c00:	e9 f0       	breq	.+58     	; 0x1c3c <xQueueSemaphoreTake+0x76>
    1c02:	81 50       	subi	r24, 0x01	; 1
    1c04:	5a 96       	adiw	r26, 0x1a	; 26
    1c06:	8c 93       	st	X, r24
    1c08:	5a 97       	sbiw	r26, 0x1a	; 26
    1c0a:	8d 91       	ld	r24, X+
    1c0c:	9c 91       	ld	r25, X
    1c0e:	89 2b       	or	r24, r25
    1c10:	29 f4       	brne	.+10     	; 0x1c1c <xQueueSemaphoreTake+0x56>
    1c12:	0e 94 5c 14 	call	0x28b8	; 0x28b8 <pvTaskIncrementMutexHeldCount>
    1c16:	f8 01       	movw	r30, r16
    1c18:	95 83       	std	Z+5, r25	; 0x05
    1c1a:	84 83       	std	Z+4, r24	; 0x04
    1c1c:	d8 01       	movw	r26, r16
    1c1e:	18 96       	adiw	r26, 0x08	; 8
    1c20:	8c 91       	ld	r24, X
    1c22:	88 23       	and	r24, r24
    1c24:	39 f0       	breq	.+14     	; 0x1c34 <xQueueSemaphoreTake+0x6e>
    1c26:	c8 01       	movw	r24, r16
    1c28:	08 96       	adiw	r24, 0x08	; 8
    1c2a:	0e 94 e8 12 	call	0x25d0	; 0x25d0 <xTaskRemoveFromEventList>
    1c2e:	81 11       	cpse	r24, r1
    1c30:	0e 94 93 0a 	call	0x1526	; 0x1526 <vPortYield>
    1c34:	0f 90       	pop	r0
    1c36:	0f be       	out	0x3f, r0	; 63
    1c38:	81 e0       	ldi	r24, 0x01	; 1
    1c3a:	7a c0       	rjmp	.+244    	; 0x1d30 <xQueueSemaphoreTake+0x16a>
    1c3c:	2c 81       	ldd	r18, Y+4	; 0x04
    1c3e:	3d 81       	ldd	r19, Y+5	; 0x05
    1c40:	23 2b       	or	r18, r19
    1c42:	09 f4       	brne	.+2      	; 0x1c46 <xQueueSemaphoreTake+0x80>
    1c44:	72 c0       	rjmp	.+228    	; 0x1d2a <xQueueSemaphoreTake+0x164>
    1c46:	91 11       	cpse	r25, r1
    1c48:	04 c0       	rjmp	.+8      	; 0x1c52 <xQueueSemaphoreTake+0x8c>
    1c4a:	ce 01       	movw	r24, r28
    1c4c:	01 96       	adiw	r24, 0x01	; 1
    1c4e:	0e 94 28 13 	call	0x2650	; 0x2650 <vTaskInternalSetTimeOutState>
    1c52:	0f 90       	pop	r0
    1c54:	0f be       	out	0x3f, r0	; 63
    1c56:	0e 94 e9 10 	call	0x21d2	; 0x21d2 <vTaskSuspendAll>
    1c5a:	0f b6       	in	r0, 0x3f	; 63
    1c5c:	f8 94       	cli
    1c5e:	0f 92       	push	r0
    1c60:	f8 01       	movw	r30, r16
    1c62:	85 8d       	ldd	r24, Z+29	; 0x1d
    1c64:	8f 3f       	cpi	r24, 0xFF	; 255
    1c66:	09 f4       	brne	.+2      	; 0x1c6a <xQueueSemaphoreTake+0xa4>
    1c68:	15 8e       	std	Z+29, r1	; 0x1d
    1c6a:	d8 01       	movw	r26, r16
    1c6c:	5e 96       	adiw	r26, 0x1e	; 30
    1c6e:	8c 91       	ld	r24, X
    1c70:	5e 97       	sbiw	r26, 0x1e	; 30
    1c72:	8f 3f       	cpi	r24, 0xFF	; 255
    1c74:	11 f4       	brne	.+4      	; 0x1c7a <xQueueSemaphoreTake+0xb4>
    1c76:	5e 96       	adiw	r26, 0x1e	; 30
    1c78:	1c 92       	st	X, r1
    1c7a:	0f 90       	pop	r0
    1c7c:	0f be       	out	0x3f, r0	; 63
    1c7e:	be 01       	movw	r22, r28
    1c80:	6c 5f       	subi	r22, 0xFC	; 252
    1c82:	7f 4f       	sbci	r23, 0xFF	; 255
    1c84:	ce 01       	movw	r24, r28
    1c86:	01 96       	adiw	r24, 0x01	; 1
    1c88:	0e 94 33 13 	call	0x2666	; 0x2666 <xTaskCheckForTimeOut>
    1c8c:	81 11       	cpse	r24, r1
    1c8e:	2b c0       	rjmp	.+86     	; 0x1ce6 <xQueueSemaphoreTake+0x120>
    1c90:	c8 01       	movw	r24, r16
    1c92:	0e 94 4c 0b 	call	0x1698	; 0x1698 <prvIsQueueEmpty>
    1c96:	88 23       	and	r24, r24
    1c98:	01 f1       	breq	.+64     	; 0x1cda <xQueueSemaphoreTake+0x114>
    1c9a:	f8 01       	movw	r30, r16
    1c9c:	80 81       	ld	r24, Z
    1c9e:	91 81       	ldd	r25, Z+1	; 0x01
    1ca0:	89 2b       	or	r24, r25
    1ca2:	51 f4       	brne	.+20     	; 0x1cb8 <xQueueSemaphoreTake+0xf2>
    1ca4:	0f b6       	in	r0, 0x3f	; 63
    1ca6:	f8 94       	cli
    1ca8:	0f 92       	push	r0
    1caa:	84 81       	ldd	r24, Z+4	; 0x04
    1cac:	95 81       	ldd	r25, Z+5	; 0x05
    1cae:	0e 94 78 13 	call	0x26f0	; 0x26f0 <xTaskPriorityInherit>
    1cb2:	f8 2e       	mov	r15, r24
    1cb4:	0f 90       	pop	r0
    1cb6:	0f be       	out	0x3f, r0	; 63
    1cb8:	6c 81       	ldd	r22, Y+4	; 0x04
    1cba:	7d 81       	ldd	r23, Y+5	; 0x05
    1cbc:	c6 01       	movw	r24, r12
    1cbe:	0e 94 bf 12 	call	0x257e	; 0x257e <vTaskPlaceOnEventList>
    1cc2:	c8 01       	movw	r24, r16
    1cc4:	0e 94 c4 0b 	call	0x1788	; 0x1788 <prvUnlockQueue>
    1cc8:	0e 94 a5 11 	call	0x234a	; 0x234a <xTaskResumeAll>
    1ccc:	88 23       	and	r24, r24
    1cce:	11 f0       	breq	.+4      	; 0x1cd4 <xQueueSemaphoreTake+0x10e>
    1cd0:	91 e0       	ldi	r25, 0x01	; 1
    1cd2:	8e cf       	rjmp	.-228    	; 0x1bf0 <xQueueSemaphoreTake+0x2a>
    1cd4:	0e 94 93 0a 	call	0x1526	; 0x1526 <vPortYield>
    1cd8:	fb cf       	rjmp	.-10     	; 0x1cd0 <xQueueSemaphoreTake+0x10a>
    1cda:	c8 01       	movw	r24, r16
    1cdc:	0e 94 c4 0b 	call	0x1788	; 0x1788 <prvUnlockQueue>
    1ce0:	0e 94 a5 11 	call	0x234a	; 0x234a <xTaskResumeAll>
    1ce4:	f5 cf       	rjmp	.-22     	; 0x1cd0 <xQueueSemaphoreTake+0x10a>
    1ce6:	c8 01       	movw	r24, r16
    1ce8:	0e 94 c4 0b 	call	0x1788	; 0x1788 <prvUnlockQueue>
    1cec:	0e 94 a5 11 	call	0x234a	; 0x234a <xTaskResumeAll>
    1cf0:	c8 01       	movw	r24, r16
    1cf2:	0e 94 4c 0b 	call	0x1698	; 0x1698 <prvIsQueueEmpty>
    1cf6:	88 23       	and	r24, r24
    1cf8:	59 f3       	breq	.-42     	; 0x1cd0 <xQueueSemaphoreTake+0x10a>
    1cfa:	ff 20       	and	r15, r15
    1cfc:	c1 f0       	breq	.+48     	; 0x1d2e <xQueueSemaphoreTake+0x168>
    1cfe:	0f b6       	in	r0, 0x3f	; 63
    1d00:	f8 94       	cli
    1d02:	0f 92       	push	r0
    1d04:	f8 01       	movw	r30, r16
    1d06:	81 89       	ldd	r24, Z+17	; 0x11
    1d08:	88 23       	and	r24, r24
    1d0a:	39 f0       	breq	.+14     	; 0x1d1a <xQueueSemaphoreTake+0x154>
    1d0c:	06 88       	ldd	r0, Z+22	; 0x16
    1d0e:	f7 89       	ldd	r31, Z+23	; 0x17
    1d10:	e0 2d       	mov	r30, r0
    1d12:	80 81       	ld	r24, Z
    1d14:	64 e0       	ldi	r22, 0x04	; 4
    1d16:	68 1b       	sub	r22, r24
    1d18:	01 c0       	rjmp	.+2      	; 0x1d1c <xQueueSemaphoreTake+0x156>
    1d1a:	60 e0       	ldi	r22, 0x00	; 0
    1d1c:	d8 01       	movw	r26, r16
    1d1e:	14 96       	adiw	r26, 0x04	; 4
    1d20:	8d 91       	ld	r24, X+
    1d22:	9c 91       	ld	r25, X
    1d24:	15 97       	sbiw	r26, 0x05	; 5
    1d26:	0e 94 15 14 	call	0x282a	; 0x282a <vTaskPriorityDisinheritAfterTimeout>
    1d2a:	0f 90       	pop	r0
    1d2c:	0f be       	out	0x3f, r0	; 63
    1d2e:	80 e0       	ldi	r24, 0x00	; 0
    1d30:	0f 90       	pop	r0
    1d32:	0f 90       	pop	r0
    1d34:	0f 90       	pop	r0
    1d36:	0f 90       	pop	r0
    1d38:	0f 90       	pop	r0
    1d3a:	df 91       	pop	r29
    1d3c:	cf 91       	pop	r28
    1d3e:	1f 91       	pop	r17
    1d40:	0f 91       	pop	r16
    1d42:	ff 90       	pop	r15
    1d44:	df 90       	pop	r13
    1d46:	cf 90       	pop	r12
    1d48:	08 95       	ret

00001d4a <vQueueWaitForMessageRestricted>:
/*-----------------------------------------------------------*/

#if ( configUSE_TIMERS == 1 )

    void vQueueWaitForMessageRestricted( QueueHandle_t xQueue, TickType_t xTicksToWait, const BaseType_t xWaitIndefinitely )
    {
    1d4a:	cf 93       	push	r28
    1d4c:	df 93       	push	r29
    1d4e:	ec 01       	movw	r28, r24
        will not actually cause the task to block, just place it on a blocked
        list.  It will not block until the scheduler is unlocked - at which
        time a yield will be performed.  If an item is added to the queue while
        the queue is locked, and the calling task blocks on the queue, then the
        calling task will be immediately unblocked when the queue is unlocked. */
        prvLockQueue( pxQueue );
    1d50:	0f b6       	in	r0, 0x3f	; 63
    1d52:	f8 94       	cli
    1d54:	0f 92       	push	r0
    1d56:	8d 8d       	ldd	r24, Y+29	; 0x1d
    1d58:	8f 3f       	cpi	r24, 0xFF	; 255
    1d5a:	09 f4       	brne	.+2      	; 0x1d5e <vQueueWaitForMessageRestricted+0x14>
    1d5c:	1d 8e       	std	Y+29, r1	; 0x1d
    1d5e:	8e 8d       	ldd	r24, Y+30	; 0x1e
    1d60:	8f 3f       	cpi	r24, 0xFF	; 255
    1d62:	09 f4       	brne	.+2      	; 0x1d66 <vQueueWaitForMessageRestricted+0x1c>
    1d64:	1e 8e       	std	Y+30, r1	; 0x1e
    1d66:	0f 90       	pop	r0
    1d68:	0f be       	out	0x3f, r0	; 63
        if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0U )
    1d6a:	8a 8d       	ldd	r24, Y+26	; 0x1a
    1d6c:	81 11       	cpse	r24, r1
    1d6e:	04 c0       	rjmp	.+8      	; 0x1d78 <vQueueWaitForMessageRestricted+0x2e>
        {
            /* There is nothing in the queue, block for the specified period. */
            vTaskPlaceOnEventListRestricted( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait, xWaitIndefinitely );
    1d70:	ce 01       	movw	r24, r28
    1d72:	41 96       	adiw	r24, 0x11	; 17
    1d74:	0e 94 d0 12 	call	0x25a0	; 0x25a0 <vTaskPlaceOnEventListRestricted>
        }
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }
        prvUnlockQueue( pxQueue );
    1d78:	ce 01       	movw	r24, r28
    }
    1d7a:	df 91       	pop	r29
    1d7c:	cf 91       	pop	r28
        }
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }
        prvUnlockQueue( pxQueue );
    1d7e:	0c 94 c4 0b 	jmp	0x1788	; 0x1788 <prvUnlockQueue>

00001d82 <prvResetNextTaskUnblockTime>:
    /* Reset the event list item to its normal value - so it can be used with
    queues and semaphores. */
    listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */

    return uxReturn;
}
    1d82:	e0 91 98 03 	lds	r30, 0x0398	; 0x800398 <pxDelayedTaskList>
    1d86:	f0 91 99 03 	lds	r31, 0x0399	; 0x800399 <pxDelayedTaskList+0x1>
    1d8a:	80 81       	ld	r24, Z
    1d8c:	81 11       	cpse	r24, r1
    1d8e:	03 c0       	rjmp	.+6      	; 0x1d96 <prvResetNextTaskUnblockTime+0x14>
    1d90:	8f ef       	ldi	r24, 0xFF	; 255
    1d92:	9f ef       	ldi	r25, 0xFF	; 255
    1d94:	0c c0       	rjmp	.+24     	; 0x1dae <prvResetNextTaskUnblockTime+0x2c>
    1d96:	e0 91 98 03 	lds	r30, 0x0398	; 0x800398 <pxDelayedTaskList>
    1d9a:	f0 91 99 03 	lds	r31, 0x0399	; 0x800399 <pxDelayedTaskList+0x1>
    1d9e:	05 80       	ldd	r0, Z+5	; 0x05
    1da0:	f6 81       	ldd	r31, Z+6	; 0x06
    1da2:	e0 2d       	mov	r30, r0
    1da4:	06 80       	ldd	r0, Z+6	; 0x06
    1da6:	f7 81       	ldd	r31, Z+7	; 0x07
    1da8:	e0 2d       	mov	r30, r0
    1daa:	82 81       	ldd	r24, Z+2	; 0x02
    1dac:	93 81       	ldd	r25, Z+3	; 0x03
    1dae:	90 93 70 03 	sts	0x0370, r25	; 0x800370 <xNextTaskUnblockTime+0x1>
    1db2:	80 93 6f 03 	sts	0x036F, r24	; 0x80036f <xNextTaskUnblockTime>
    1db6:	08 95       	ret

00001db8 <prvAddCurrentTaskToDelayedList>:
    1db8:	ff 92       	push	r15
    1dba:	0f 93       	push	r16
    1dbc:	1f 93       	push	r17
    1dbe:	cf 93       	push	r28
    1dc0:	df 93       	push	r29
    1dc2:	ec 01       	movw	r28, r24
    1dc4:	f6 2e       	mov	r15, r22
    1dc6:	00 91 77 03 	lds	r16, 0x0377	; 0x800377 <xTickCount>
    1dca:	10 91 78 03 	lds	r17, 0x0378	; 0x800378 <xTickCount+0x1>
    1dce:	80 91 d0 03 	lds	r24, 0x03D0	; 0x8003d0 <pxCurrentTCB>
    1dd2:	90 91 d1 03 	lds	r25, 0x03D1	; 0x8003d1 <pxCurrentTCB+0x1>
    1dd6:	02 96       	adiw	r24, 0x02	; 2
    1dd8:	0e 94 cb 09 	call	0x1396	; 0x1396 <uxListRemove>
    1ddc:	cf 3f       	cpi	r28, 0xFF	; 255
    1dde:	8f ef       	ldi	r24, 0xFF	; 255
    1de0:	d8 07       	cpc	r29, r24
    1de2:	89 f4       	brne	.+34     	; 0x1e06 <prvAddCurrentTaskToDelayedList+0x4e>
    1de4:	ff 20       	and	r15, r15
    1de6:	79 f0       	breq	.+30     	; 0x1e06 <prvAddCurrentTaskToDelayedList+0x4e>
    1de8:	60 91 d0 03 	lds	r22, 0x03D0	; 0x8003d0 <pxCurrentTCB>
    1dec:	70 91 d1 03 	lds	r23, 0x03D1	; 0x8003d1 <pxCurrentTCB+0x1>
    1df0:	6e 5f       	subi	r22, 0xFE	; 254
    1df2:	7f 4f       	sbci	r23, 0xFF	; 255
    1df4:	8a e7       	ldi	r24, 0x7A	; 122
    1df6:	93 e0       	ldi	r25, 0x03	; 3
    1df8:	df 91       	pop	r29
    1dfa:	cf 91       	pop	r28
    1dfc:	1f 91       	pop	r17
    1dfe:	0f 91       	pop	r16
    1e00:	ff 90       	pop	r15
    1e02:	0c 94 72 09 	jmp	0x12e4	; 0x12e4 <vListInsertEnd>
    1e06:	c0 0f       	add	r28, r16
    1e08:	d1 1f       	adc	r29, r17
    1e0a:	e0 91 d0 03 	lds	r30, 0x03D0	; 0x8003d0 <pxCurrentTCB>
    1e0e:	f0 91 d1 03 	lds	r31, 0x03D1	; 0x8003d1 <pxCurrentTCB+0x1>
    1e12:	d3 83       	std	Z+3, r29	; 0x03
    1e14:	c2 83       	std	Z+2, r28	; 0x02
    1e16:	60 91 d0 03 	lds	r22, 0x03D0	; 0x8003d0 <pxCurrentTCB>
    1e1a:	70 91 d1 03 	lds	r23, 0x03D1	; 0x8003d1 <pxCurrentTCB+0x1>
    1e1e:	c0 17       	cp	r28, r16
    1e20:	d1 07       	cpc	r29, r17
    1e22:	68 f4       	brcc	.+26     	; 0x1e3e <prvAddCurrentTaskToDelayedList+0x86>
    1e24:	80 91 96 03 	lds	r24, 0x0396	; 0x800396 <pxOverflowDelayedTaskList>
    1e28:	90 91 97 03 	lds	r25, 0x0397	; 0x800397 <pxOverflowDelayedTaskList+0x1>
    1e2c:	6e 5f       	subi	r22, 0xFE	; 254
    1e2e:	7f 4f       	sbci	r23, 0xFF	; 255
    1e30:	df 91       	pop	r29
    1e32:	cf 91       	pop	r28
    1e34:	1f 91       	pop	r17
    1e36:	0f 91       	pop	r16
    1e38:	ff 90       	pop	r15
    1e3a:	0c 94 93 09 	jmp	0x1326	; 0x1326 <vListInsert>
    1e3e:	80 91 98 03 	lds	r24, 0x0398	; 0x800398 <pxDelayedTaskList>
    1e42:	90 91 99 03 	lds	r25, 0x0399	; 0x800399 <pxDelayedTaskList+0x1>
    1e46:	6e 5f       	subi	r22, 0xFE	; 254
    1e48:	7f 4f       	sbci	r23, 0xFF	; 255
    1e4a:	0e 94 93 09 	call	0x1326	; 0x1326 <vListInsert>
    1e4e:	80 91 6f 03 	lds	r24, 0x036F	; 0x80036f <xNextTaskUnblockTime>
    1e52:	90 91 70 03 	lds	r25, 0x0370	; 0x800370 <xNextTaskUnblockTime+0x1>
    1e56:	c8 17       	cp	r28, r24
    1e58:	d9 07       	cpc	r29, r25
    1e5a:	20 f4       	brcc	.+8      	; 0x1e64 <prvAddCurrentTaskToDelayedList+0xac>
    1e5c:	d0 93 70 03 	sts	0x0370, r29	; 0x800370 <xNextTaskUnblockTime+0x1>
    1e60:	c0 93 6f 03 	sts	0x036F, r28	; 0x80036f <xNextTaskUnblockTime>
    1e64:	df 91       	pop	r29
    1e66:	cf 91       	pop	r28
    1e68:	1f 91       	pop	r17
    1e6a:	0f 91       	pop	r16
    1e6c:	ff 90       	pop	r15
    1e6e:	08 95       	ret

00001e70 <prvIdleTask>:
    1e70:	80 91 83 03 	lds	r24, 0x0383	; 0x800383 <uxDeletedTasksWaitingCleanUp>
    1e74:	88 23       	and	r24, r24
    1e76:	09 f1       	breq	.+66     	; 0x1eba <prvIdleTask+0x4a>
    1e78:	0f b6       	in	r0, 0x3f	; 63
    1e7a:	f8 94       	cli
    1e7c:	0f 92       	push	r0
    1e7e:	e0 91 89 03 	lds	r30, 0x0389	; 0x800389 <xTasksWaitingTermination+0x5>
    1e82:	f0 91 8a 03 	lds	r31, 0x038A	; 0x80038a <xTasksWaitingTermination+0x6>
    1e86:	c6 81       	ldd	r28, Z+6	; 0x06
    1e88:	d7 81       	ldd	r29, Z+7	; 0x07
    1e8a:	ce 01       	movw	r24, r28
    1e8c:	02 96       	adiw	r24, 0x02	; 2
    1e8e:	0e 94 cb 09 	call	0x1396	; 0x1396 <uxListRemove>
    1e92:	80 91 79 03 	lds	r24, 0x0379	; 0x800379 <uxCurrentNumberOfTasks>
    1e96:	81 50       	subi	r24, 0x01	; 1
    1e98:	80 93 79 03 	sts	0x0379, r24	; 0x800379 <uxCurrentNumberOfTasks>
    1e9c:	80 91 83 03 	lds	r24, 0x0383	; 0x800383 <uxDeletedTasksWaitingCleanUp>
    1ea0:	81 50       	subi	r24, 0x01	; 1
    1ea2:	80 93 83 03 	sts	0x0383, r24	; 0x800383 <uxDeletedTasksWaitingCleanUp>
    1ea6:	0f 90       	pop	r0
    1ea8:	0f be       	out	0x3f, r0	; 63
    1eaa:	8f 89       	ldd	r24, Y+23	; 0x17
    1eac:	98 8d       	ldd	r25, Y+24	; 0x18
    1eae:	0e 94 4f 09 	call	0x129e	; 0x129e <vPortFree>
    1eb2:	ce 01       	movw	r24, r28
    1eb4:	0e 94 4f 09 	call	0x129e	; 0x129e <vPortFree>
    1eb8:	db cf       	rjmp	.-74     	; 0x1e70 <prvIdleTask>
    1eba:	80 91 ac 03 	lds	r24, 0x03AC	; 0x8003ac <pxReadyTasksLists>
    1ebe:	82 30       	cpi	r24, 0x02	; 2
    1ec0:	10 f0       	brcs	.+4      	; 0x1ec6 <prvIdleTask+0x56>
    1ec2:	0e 94 93 0a 	call	0x1526	; 0x1526 <vPortYield>
    1ec6:	0e 94 79 16 	call	0x2cf2	; 0x2cf2 <vApplicationIdleHook>
    1eca:	d2 cf       	rjmp	.-92     	; 0x1e70 <prvIdleTask>

00001ecc <xTaskCreate>:
    1ecc:	5f 92       	push	r5
    1ece:	6f 92       	push	r6
    1ed0:	7f 92       	push	r7
    1ed2:	8f 92       	push	r8
    1ed4:	9f 92       	push	r9
    1ed6:	af 92       	push	r10
    1ed8:	bf 92       	push	r11
    1eda:	cf 92       	push	r12
    1edc:	df 92       	push	r13
    1ede:	ef 92       	push	r14
    1ee0:	ff 92       	push	r15
    1ee2:	0f 93       	push	r16
    1ee4:	1f 93       	push	r17
    1ee6:	cf 93       	push	r28
    1ee8:	df 93       	push	r29
    1eea:	3c 01       	movw	r6, r24
    1eec:	6b 01       	movw	r12, r22
    1eee:	5a 01       	movw	r10, r20
    1ef0:	49 01       	movw	r8, r18
    1ef2:	50 2e       	mov	r5, r16
    1ef4:	ca 01       	movw	r24, r20
    1ef6:	0e 94 3c 09 	call	0x1278	; 0x1278 <pvPortMalloc>
    1efa:	8c 01       	movw	r16, r24
    1efc:	89 2b       	or	r24, r25
    1efe:	09 f4       	brne	.+2      	; 0x1f02 <xTaskCreate+0x36>
    1f00:	e0 c0       	rjmp	.+448    	; 0x20c2 <xTaskCreate+0x1f6>
    1f02:	88 e2       	ldi	r24, 0x28	; 40
    1f04:	90 e0       	ldi	r25, 0x00	; 0
    1f06:	0e 94 3c 09 	call	0x1278	; 0x1278 <pvPortMalloc>
    1f0a:	ec 01       	movw	r28, r24
    1f0c:	89 2b       	or	r24, r25
    1f0e:	c9 f0       	breq	.+50     	; 0x1f42 <xTaskCreate+0x76>
    1f10:	18 8f       	std	Y+24, r17	; 0x18
    1f12:	0f 8b       	std	Y+23, r16	; 0x17
    1f14:	a5 01       	movw	r20, r10
    1f16:	65 ea       	ldi	r22, 0xA5	; 165
    1f18:	70 e0       	ldi	r23, 0x00	; 0
    1f1a:	c8 01       	movw	r24, r16
    1f1c:	0e 94 41 25 	call	0x4a82	; 0x4a82 <memset>
    1f20:	21 e0       	ldi	r18, 0x01	; 1
    1f22:	a2 1a       	sub	r10, r18
    1f24:	b1 08       	sbc	r11, r1
    1f26:	8f 89       	ldd	r24, Y+23	; 0x17
    1f28:	98 8d       	ldd	r25, Y+24	; 0x18
    1f2a:	a8 0e       	add	r10, r24
    1f2c:	b9 1e       	adc	r11, r25
    1f2e:	c1 14       	cp	r12, r1
    1f30:	d1 04       	cpc	r13, r1
    1f32:	c9 f0       	breq	.+50     	; 0x1f66 <xTaskCreate+0x9a>
    1f34:	be 01       	movw	r22, r28
    1f36:	67 5e       	subi	r22, 0xE7	; 231
    1f38:	7f 4f       	sbci	r23, 0xFF	; 255
    1f3a:	f6 01       	movw	r30, r12
    1f3c:	c6 01       	movw	r24, r12
    1f3e:	08 96       	adiw	r24, 0x08	; 8
    1f40:	07 c0       	rjmp	.+14     	; 0x1f50 <xTaskCreate+0x84>
    1f42:	c8 01       	movw	r24, r16
    1f44:	0e 94 4f 09 	call	0x129e	; 0x129e <vPortFree>
    1f48:	bc c0       	rjmp	.+376    	; 0x20c2 <xTaskCreate+0x1f6>
    1f4a:	e8 17       	cp	r30, r24
    1f4c:	f9 07       	cpc	r31, r25
    1f4e:	49 f0       	breq	.+18     	; 0x1f62 <xTaskCreate+0x96>
    1f50:	9f 01       	movw	r18, r30
    1f52:	41 91       	ld	r20, Z+
    1f54:	db 01       	movw	r26, r22
    1f56:	4d 93       	st	X+, r20
    1f58:	bd 01       	movw	r22, r26
    1f5a:	d9 01       	movw	r26, r18
    1f5c:	2c 91       	ld	r18, X
    1f5e:	21 11       	cpse	r18, r1
    1f60:	f4 cf       	rjmp	.-24     	; 0x1f4a <xTaskCreate+0x7e>
    1f62:	18 a2       	std	Y+32, r1	; 0x20
    1f64:	01 c0       	rjmp	.+2      	; 0x1f68 <xTaskCreate+0x9c>
    1f66:	19 8e       	std	Y+25, r1	; 0x19
    1f68:	05 2d       	mov	r16, r5
    1f6a:	04 30       	cpi	r16, 0x04	; 4
    1f6c:	08 f0       	brcs	.+2      	; 0x1f70 <xTaskCreate+0xa4>
    1f6e:	03 e0       	ldi	r16, 0x03	; 3
    1f70:	0e 8b       	std	Y+22, r16	; 0x16
    1f72:	09 a3       	std	Y+33, r16	; 0x21
    1f74:	1a a2       	std	Y+34, r1	; 0x22
    1f76:	6e 01       	movw	r12, r28
    1f78:	b2 e0       	ldi	r27, 0x02	; 2
    1f7a:	cb 0e       	add	r12, r27
    1f7c:	d1 1c       	adc	r13, r1
    1f7e:	c6 01       	movw	r24, r12
    1f80:	0e 94 6e 09 	call	0x12dc	; 0x12dc <vListInitialiseItem>
    1f84:	ce 01       	movw	r24, r28
    1f86:	0c 96       	adiw	r24, 0x0c	; 12
    1f88:	0e 94 6e 09 	call	0x12dc	; 0x12dc <vListInitialiseItem>
    1f8c:	d9 87       	std	Y+9, r29	; 0x09
    1f8e:	c8 87       	std	Y+8, r28	; 0x08
    1f90:	84 e0       	ldi	r24, 0x04	; 4
    1f92:	90 e0       	ldi	r25, 0x00	; 0
    1f94:	80 1b       	sub	r24, r16
    1f96:	91 09       	sbc	r25, r1
    1f98:	9d 87       	std	Y+13, r25	; 0x0d
    1f9a:	8c 87       	std	Y+12, r24	; 0x0c
    1f9c:	db 8b       	std	Y+19, r29	; 0x13
    1f9e:	ca 8b       	std	Y+18, r28	; 0x12
    1fa0:	1b a2       	std	Y+35, r1	; 0x23
    1fa2:	1c a2       	std	Y+36, r1	; 0x24
    1fa4:	1d a2       	std	Y+37, r1	; 0x25
    1fa6:	1e a2       	std	Y+38, r1	; 0x26
    1fa8:	1f a2       	std	Y+39, r1	; 0x27
    1faa:	a4 01       	movw	r20, r8
    1fac:	b3 01       	movw	r22, r6
    1fae:	c5 01       	movw	r24, r10
    1fb0:	0e 94 ef 09 	call	0x13de	; 0x13de <pxPortInitialiseStack>
    1fb4:	99 83       	std	Y+1, r25	; 0x01
    1fb6:	88 83       	st	Y, r24
    1fb8:	e1 14       	cp	r14, r1
    1fba:	f1 04       	cpc	r15, r1
    1fbc:	19 f0       	breq	.+6      	; 0x1fc4 <xTaskCreate+0xf8>
    1fbe:	f7 01       	movw	r30, r14
    1fc0:	d1 83       	std	Z+1, r29	; 0x01
    1fc2:	c0 83       	st	Z, r28
    1fc4:	0f b6       	in	r0, 0x3f	; 63
    1fc6:	f8 94       	cli
    1fc8:	0f 92       	push	r0
    1fca:	80 91 79 03 	lds	r24, 0x0379	; 0x800379 <uxCurrentNumberOfTasks>
    1fce:	8f 5f       	subi	r24, 0xFF	; 255
    1fd0:	80 93 79 03 	sts	0x0379, r24	; 0x800379 <uxCurrentNumberOfTasks>
    1fd4:	80 91 d0 03 	lds	r24, 0x03D0	; 0x8003d0 <pxCurrentTCB>
    1fd8:	90 91 d1 03 	lds	r25, 0x03D1	; 0x8003d1 <pxCurrentTCB+0x1>
    1fdc:	89 2b       	or	r24, r25
    1fde:	d1 f5       	brne	.+116    	; 0x2054 <xTaskCreate+0x188>
    1fe0:	d0 93 d1 03 	sts	0x03D1, r29	; 0x8003d1 <pxCurrentTCB+0x1>
    1fe4:	c0 93 d0 03 	sts	0x03D0, r28	; 0x8003d0 <pxCurrentTCB>
    1fe8:	80 91 79 03 	lds	r24, 0x0379	; 0x800379 <uxCurrentNumberOfTasks>
    1fec:	81 30       	cpi	r24, 0x01	; 1
    1fee:	09 f0       	breq	.+2      	; 0x1ff2 <xTaskCreate+0x126>
    1ff0:	41 c0       	rjmp	.+130    	; 0x2074 <xTaskCreate+0x1a8>
    1ff2:	8c ea       	ldi	r24, 0xAC	; 172
    1ff4:	93 e0       	ldi	r25, 0x03	; 3
    1ff6:	0e 94 60 09 	call	0x12c0	; 0x12c0 <vListInitialise>
    1ffa:	85 eb       	ldi	r24, 0xB5	; 181
    1ffc:	93 e0       	ldi	r25, 0x03	; 3
    1ffe:	0e 94 60 09 	call	0x12c0	; 0x12c0 <vListInitialise>
    2002:	8e eb       	ldi	r24, 0xBE	; 190
    2004:	93 e0       	ldi	r25, 0x03	; 3
    2006:	0e 94 60 09 	call	0x12c0	; 0x12c0 <vListInitialise>
    200a:	87 ec       	ldi	r24, 0xC7	; 199
    200c:	93 e0       	ldi	r25, 0x03	; 3
    200e:	0e 94 60 09 	call	0x12c0	; 0x12c0 <vListInitialise>
    2012:	83 ea       	ldi	r24, 0xA3	; 163
    2014:	93 e0       	ldi	r25, 0x03	; 3
    2016:	0e 94 60 09 	call	0x12c0	; 0x12c0 <vListInitialise>
    201a:	8a e9       	ldi	r24, 0x9A	; 154
    201c:	93 e0       	ldi	r25, 0x03	; 3
    201e:	0e 94 60 09 	call	0x12c0	; 0x12c0 <vListInitialise>
    2022:	8d e8       	ldi	r24, 0x8D	; 141
    2024:	93 e0       	ldi	r25, 0x03	; 3
    2026:	0e 94 60 09 	call	0x12c0	; 0x12c0 <vListInitialise>
    202a:	84 e8       	ldi	r24, 0x84	; 132
    202c:	93 e0       	ldi	r25, 0x03	; 3
    202e:	0e 94 60 09 	call	0x12c0	; 0x12c0 <vListInitialise>
    2032:	8a e7       	ldi	r24, 0x7A	; 122
    2034:	93 e0       	ldi	r25, 0x03	; 3
    2036:	0e 94 60 09 	call	0x12c0	; 0x12c0 <vListInitialise>
    203a:	83 ea       	ldi	r24, 0xA3	; 163
    203c:	93 e0       	ldi	r25, 0x03	; 3
    203e:	90 93 99 03 	sts	0x0399, r25	; 0x800399 <pxDelayedTaskList+0x1>
    2042:	80 93 98 03 	sts	0x0398, r24	; 0x800398 <pxDelayedTaskList>
    2046:	8a e9       	ldi	r24, 0x9A	; 154
    2048:	93 e0       	ldi	r25, 0x03	; 3
    204a:	90 93 97 03 	sts	0x0397, r25	; 0x800397 <pxOverflowDelayedTaskList+0x1>
    204e:	80 93 96 03 	sts	0x0396, r24	; 0x800396 <pxOverflowDelayedTaskList>
    2052:	10 c0       	rjmp	.+32     	; 0x2074 <xTaskCreate+0x1a8>
    2054:	80 91 75 03 	lds	r24, 0x0375	; 0x800375 <xSchedulerRunning>
    2058:	81 11       	cpse	r24, r1
    205a:	0c c0       	rjmp	.+24     	; 0x2074 <xTaskCreate+0x1a8>
    205c:	e0 91 d0 03 	lds	r30, 0x03D0	; 0x8003d0 <pxCurrentTCB>
    2060:	f0 91 d1 03 	lds	r31, 0x03D1	; 0x8003d1 <pxCurrentTCB+0x1>
    2064:	96 89       	ldd	r25, Z+22	; 0x16
    2066:	8e 89       	ldd	r24, Y+22	; 0x16
    2068:	89 17       	cp	r24, r25
    206a:	20 f0       	brcs	.+8      	; 0x2074 <xTaskCreate+0x1a8>
    206c:	d0 93 d1 03 	sts	0x03D1, r29	; 0x8003d1 <pxCurrentTCB+0x1>
    2070:	c0 93 d0 03 	sts	0x03D0, r28	; 0x8003d0 <pxCurrentTCB>
    2074:	80 91 71 03 	lds	r24, 0x0371	; 0x800371 <uxTaskNumber>
    2078:	8f 5f       	subi	r24, 0xFF	; 255
    207a:	80 93 71 03 	sts	0x0371, r24	; 0x800371 <uxTaskNumber>
    207e:	8e 89       	ldd	r24, Y+22	; 0x16
    2080:	90 91 76 03 	lds	r25, 0x0376	; 0x800376 <uxTopReadyPriority>
    2084:	98 17       	cp	r25, r24
    2086:	10 f4       	brcc	.+4      	; 0x208c <xTaskCreate+0x1c0>
    2088:	80 93 76 03 	sts	0x0376, r24	; 0x800376 <uxTopReadyPriority>
    208c:	f9 e0       	ldi	r31, 0x09	; 9
    208e:	8f 9f       	mul	r24, r31
    2090:	c0 01       	movw	r24, r0
    2092:	11 24       	eor	r1, r1
    2094:	b6 01       	movw	r22, r12
    2096:	84 55       	subi	r24, 0x54	; 84
    2098:	9c 4f       	sbci	r25, 0xFC	; 252
    209a:	0e 94 72 09 	call	0x12e4	; 0x12e4 <vListInsertEnd>
    209e:	0f 90       	pop	r0
    20a0:	0f be       	out	0x3f, r0	; 63
    20a2:	80 91 75 03 	lds	r24, 0x0375	; 0x800375 <xSchedulerRunning>
    20a6:	88 23       	and	r24, r24
    20a8:	51 f0       	breq	.+20     	; 0x20be <xTaskCreate+0x1f2>
    20aa:	e0 91 d0 03 	lds	r30, 0x03D0	; 0x8003d0 <pxCurrentTCB>
    20ae:	f0 91 d1 03 	lds	r31, 0x03D1	; 0x8003d1 <pxCurrentTCB+0x1>
    20b2:	96 89       	ldd	r25, Z+22	; 0x16
    20b4:	8e 89       	ldd	r24, Y+22	; 0x16
    20b6:	98 17       	cp	r25, r24
    20b8:	10 f4       	brcc	.+4      	; 0x20be <xTaskCreate+0x1f2>
    20ba:	0e 94 93 0a 	call	0x1526	; 0x1526 <vPortYield>
    20be:	81 e0       	ldi	r24, 0x01	; 1
    20c0:	01 c0       	rjmp	.+2      	; 0x20c4 <xTaskCreate+0x1f8>
    20c2:	8f ef       	ldi	r24, 0xFF	; 255
    20c4:	df 91       	pop	r29
    20c6:	cf 91       	pop	r28
    20c8:	1f 91       	pop	r17
    20ca:	0f 91       	pop	r16
    20cc:	ff 90       	pop	r15
    20ce:	ef 90       	pop	r14
    20d0:	df 90       	pop	r13
    20d2:	cf 90       	pop	r12
    20d4:	bf 90       	pop	r11
    20d6:	af 90       	pop	r10
    20d8:	9f 90       	pop	r9
    20da:	8f 90       	pop	r8
    20dc:	7f 90       	pop	r7
    20de:	6f 90       	pop	r6
    20e0:	5f 90       	pop	r5
    20e2:	08 95       	ret

000020e4 <vTaskResume>:
    20e4:	0f 93       	push	r16
    20e6:	1f 93       	push	r17
    20e8:	cf 93       	push	r28
    20ea:	df 93       	push	r29
    20ec:	20 91 d0 03 	lds	r18, 0x03D0	; 0x8003d0 <pxCurrentTCB>
    20f0:	30 91 d1 03 	lds	r19, 0x03D1	; 0x8003d1 <pxCurrentTCB+0x1>
    20f4:	82 17       	cp	r24, r18
    20f6:	93 07       	cpc	r25, r19
    20f8:	09 f4       	brne	.+2      	; 0x20fc <vTaskResume+0x18>
    20fa:	38 c0       	rjmp	.+112    	; 0x216c <vTaskResume+0x88>
    20fc:	00 97       	sbiw	r24, 0x00	; 0
    20fe:	09 f4       	brne	.+2      	; 0x2102 <vTaskResume+0x1e>
    2100:	35 c0       	rjmp	.+106    	; 0x216c <vTaskResume+0x88>
    2102:	0f b6       	in	r0, 0x3f	; 63
    2104:	f8 94       	cli
    2106:	0f 92       	push	r0
    2108:	fc 01       	movw	r30, r24
    210a:	22 85       	ldd	r18, Z+10	; 0x0a
    210c:	33 85       	ldd	r19, Z+11	; 0x0b
    210e:	2a 57       	subi	r18, 0x7A	; 122
    2110:	33 40       	sbci	r19, 0x03	; 3
    2112:	51 f5       	brne	.+84     	; 0x2168 <vTaskResume+0x84>
    2114:	fc 01       	movw	r30, r24
    2116:	24 89       	ldd	r18, Z+20	; 0x14
    2118:	35 89       	ldd	r19, Z+21	; 0x15
    211a:	f3 e0       	ldi	r31, 0x03	; 3
    211c:	2d 38       	cpi	r18, 0x8D	; 141
    211e:	3f 07       	cpc	r19, r31
    2120:	19 f1       	breq	.+70     	; 0x2168 <vTaskResume+0x84>
    2122:	23 2b       	or	r18, r19
    2124:	09 f5       	brne	.+66     	; 0x2168 <vTaskResume+0x84>
    2126:	ec 01       	movw	r28, r24
    2128:	8c 01       	movw	r16, r24
    212a:	0e 5f       	subi	r16, 0xFE	; 254
    212c:	1f 4f       	sbci	r17, 0xFF	; 255
    212e:	c8 01       	movw	r24, r16
    2130:	0e 94 cb 09 	call	0x1396	; 0x1396 <uxListRemove>
    2134:	8e 89       	ldd	r24, Y+22	; 0x16
    2136:	90 91 76 03 	lds	r25, 0x0376	; 0x800376 <uxTopReadyPriority>
    213a:	98 17       	cp	r25, r24
    213c:	10 f4       	brcc	.+4      	; 0x2142 <vTaskResume+0x5e>
    213e:	80 93 76 03 	sts	0x0376, r24	; 0x800376 <uxTopReadyPriority>
    2142:	29 e0       	ldi	r18, 0x09	; 9
    2144:	82 9f       	mul	r24, r18
    2146:	c0 01       	movw	r24, r0
    2148:	11 24       	eor	r1, r1
    214a:	b8 01       	movw	r22, r16
    214c:	84 55       	subi	r24, 0x54	; 84
    214e:	9c 4f       	sbci	r25, 0xFC	; 252
    2150:	0e 94 72 09 	call	0x12e4	; 0x12e4 <vListInsertEnd>
    2154:	e0 91 d0 03 	lds	r30, 0x03D0	; 0x8003d0 <pxCurrentTCB>
    2158:	f0 91 d1 03 	lds	r31, 0x03D1	; 0x8003d1 <pxCurrentTCB+0x1>
    215c:	9e 89       	ldd	r25, Y+22	; 0x16
    215e:	86 89       	ldd	r24, Z+22	; 0x16
    2160:	98 17       	cp	r25, r24
    2162:	10 f0       	brcs	.+4      	; 0x2168 <vTaskResume+0x84>
    2164:	0e 94 93 0a 	call	0x1526	; 0x1526 <vPortYield>
    2168:	0f 90       	pop	r0
    216a:	0f be       	out	0x3f, r0	; 63
    216c:	df 91       	pop	r29
    216e:	cf 91       	pop	r28
    2170:	1f 91       	pop	r17
    2172:	0f 91       	pop	r16
    2174:	08 95       	ret

00002176 <vTaskStartScheduler>:
    2176:	ef 92       	push	r14
    2178:	ff 92       	push	r15
    217a:	0f 93       	push	r16
    217c:	8d e6       	ldi	r24, 0x6D	; 109
    217e:	e8 2e       	mov	r14, r24
    2180:	83 e0       	ldi	r24, 0x03	; 3
    2182:	f8 2e       	mov	r15, r24
    2184:	00 e0       	ldi	r16, 0x00	; 0
    2186:	20 e0       	ldi	r18, 0x00	; 0
    2188:	30 e0       	ldi	r19, 0x00	; 0
    218a:	40 ec       	ldi	r20, 0xC0	; 192
    218c:	50 e0       	ldi	r21, 0x00	; 0
    218e:	63 ee       	ldi	r22, 0xE3	; 227
    2190:	71 e0       	ldi	r23, 0x01	; 1
    2192:	88 e3       	ldi	r24, 0x38	; 56
    2194:	9f e0       	ldi	r25, 0x0F	; 15
    2196:	0e 94 66 0f 	call	0x1ecc	; 0x1ecc <xTaskCreate>
    219a:	81 30       	cpi	r24, 0x01	; 1
    219c:	b1 f4       	brne	.+44     	; 0x21ca <vTaskStartScheduler+0x54>
    219e:	0e 94 c1 14 	call	0x2982	; 0x2982 <xTimerCreateTimerTask>
    21a2:	81 30       	cpi	r24, 0x01	; 1
    21a4:	91 f4       	brne	.+36     	; 0x21ca <vTaskStartScheduler+0x54>
    21a6:	f8 94       	cli
    21a8:	2f ef       	ldi	r18, 0xFF	; 255
    21aa:	3f ef       	ldi	r19, 0xFF	; 255
    21ac:	30 93 70 03 	sts	0x0370, r19	; 0x800370 <xNextTaskUnblockTime+0x1>
    21b0:	20 93 6f 03 	sts	0x036F, r18	; 0x80036f <xNextTaskUnblockTime>
    21b4:	80 93 75 03 	sts	0x0375, r24	; 0x800375 <xSchedulerRunning>
    21b8:	10 92 78 03 	sts	0x0378, r1	; 0x800378 <xTickCount+0x1>
    21bc:	10 92 77 03 	sts	0x0377, r1	; 0x800377 <xTickCount>
    21c0:	0f 91       	pop	r16
    21c2:	ff 90       	pop	r15
    21c4:	ef 90       	pop	r14
    21c6:	0c 94 5b 0a 	jmp	0x14b6	; 0x14b6 <xPortStartScheduler>
    21ca:	0f 91       	pop	r16
    21cc:	ff 90       	pop	r15
    21ce:	ef 90       	pop	r14
    21d0:	08 95       	ret

000021d2 <vTaskSuspendAll>:
    21d2:	80 91 6c 03 	lds	r24, 0x036C	; 0x80036c <uxSchedulerSuspended>
    21d6:	8f 5f       	subi	r24, 0xFF	; 255
    21d8:	80 93 6c 03 	sts	0x036C, r24	; 0x80036c <uxSchedulerSuspended>
    21dc:	08 95       	ret

000021de <xTaskGetTickCount>:
    21de:	0f b6       	in	r0, 0x3f	; 63
    21e0:	f8 94       	cli
    21e2:	0f 92       	push	r0
    21e4:	80 91 77 03 	lds	r24, 0x0377	; 0x800377 <xTickCount>
    21e8:	90 91 78 03 	lds	r25, 0x0378	; 0x800378 <xTickCount+0x1>
    21ec:	0f 90       	pop	r0
    21ee:	0f be       	out	0x3f, r0	; 63
    21f0:	08 95       	ret

000021f2 <xTaskIncrementTick>:
    21f2:	cf 92       	push	r12
    21f4:	df 92       	push	r13
    21f6:	ef 92       	push	r14
    21f8:	ff 92       	push	r15
    21fa:	0f 93       	push	r16
    21fc:	1f 93       	push	r17
    21fe:	cf 93       	push	r28
    2200:	df 93       	push	r29
    2202:	80 91 6c 03 	lds	r24, 0x036C	; 0x80036c <uxSchedulerSuspended>
    2206:	81 11       	cpse	r24, r1
    2208:	8c c0       	rjmp	.+280    	; 0x2322 <xTaskIncrementTick+0x130>
    220a:	00 91 77 03 	lds	r16, 0x0377	; 0x800377 <xTickCount>
    220e:	10 91 78 03 	lds	r17, 0x0378	; 0x800378 <xTickCount+0x1>
    2212:	0f 5f       	subi	r16, 0xFF	; 255
    2214:	1f 4f       	sbci	r17, 0xFF	; 255
    2216:	10 93 78 03 	sts	0x0378, r17	; 0x800378 <xTickCount+0x1>
    221a:	00 93 77 03 	sts	0x0377, r16	; 0x800377 <xTickCount>
    221e:	01 15       	cp	r16, r1
    2220:	11 05       	cpc	r17, r1
    2222:	b9 f4       	brne	.+46     	; 0x2252 <xTaskIncrementTick+0x60>
    2224:	80 91 98 03 	lds	r24, 0x0398	; 0x800398 <pxDelayedTaskList>
    2228:	90 91 99 03 	lds	r25, 0x0399	; 0x800399 <pxDelayedTaskList+0x1>
    222c:	20 91 96 03 	lds	r18, 0x0396	; 0x800396 <pxOverflowDelayedTaskList>
    2230:	30 91 97 03 	lds	r19, 0x0397	; 0x800397 <pxOverflowDelayedTaskList+0x1>
    2234:	30 93 99 03 	sts	0x0399, r19	; 0x800399 <pxDelayedTaskList+0x1>
    2238:	20 93 98 03 	sts	0x0398, r18	; 0x800398 <pxDelayedTaskList>
    223c:	90 93 97 03 	sts	0x0397, r25	; 0x800397 <pxOverflowDelayedTaskList+0x1>
    2240:	80 93 96 03 	sts	0x0396, r24	; 0x800396 <pxOverflowDelayedTaskList>
    2244:	80 91 72 03 	lds	r24, 0x0372	; 0x800372 <xNumOfOverflows>
    2248:	8f 5f       	subi	r24, 0xFF	; 255
    224a:	80 93 72 03 	sts	0x0372, r24	; 0x800372 <xNumOfOverflows>
    224e:	0e 94 c1 0e 	call	0x1d82	; 0x1d82 <prvResetNextTaskUnblockTime>
    2252:	80 91 6f 03 	lds	r24, 0x036F	; 0x80036f <xNextTaskUnblockTime>
    2256:	90 91 70 03 	lds	r25, 0x0370	; 0x800370 <xNextTaskUnblockTime+0x1>
    225a:	c0 e0       	ldi	r28, 0x00	; 0
    225c:	08 17       	cp	r16, r24
    225e:	19 07       	cpc	r17, r25
    2260:	08 f4       	brcc	.+2      	; 0x2264 <xTaskIncrementTick+0x72>
    2262:	4f c0       	rjmp	.+158    	; 0x2302 <xTaskIncrementTick+0x110>
    2264:	d9 e0       	ldi	r29, 0x09	; 9
    2266:	e0 91 98 03 	lds	r30, 0x0398	; 0x800398 <pxDelayedTaskList>
    226a:	f0 91 99 03 	lds	r31, 0x0399	; 0x800399 <pxDelayedTaskList+0x1>
    226e:	80 81       	ld	r24, Z
    2270:	81 11       	cpse	r24, r1
    2272:	03 c0       	rjmp	.+6      	; 0x227a <xTaskIncrementTick+0x88>
    2274:	8f ef       	ldi	r24, 0xFF	; 255
    2276:	9f ef       	ldi	r25, 0xFF	; 255
    2278:	11 c0       	rjmp	.+34     	; 0x229c <xTaskIncrementTick+0xaa>
    227a:	e0 91 98 03 	lds	r30, 0x0398	; 0x800398 <pxDelayedTaskList>
    227e:	f0 91 99 03 	lds	r31, 0x0399	; 0x800399 <pxDelayedTaskList+0x1>
    2282:	05 80       	ldd	r0, Z+5	; 0x05
    2284:	f6 81       	ldd	r31, Z+6	; 0x06
    2286:	e0 2d       	mov	r30, r0
    2288:	e6 80       	ldd	r14, Z+6	; 0x06
    228a:	f7 80       	ldd	r15, Z+7	; 0x07
    228c:	d7 01       	movw	r26, r14
    228e:	12 96       	adiw	r26, 0x02	; 2
    2290:	8d 91       	ld	r24, X+
    2292:	9c 91       	ld	r25, X
    2294:	13 97       	sbiw	r26, 0x03	; 3
    2296:	08 17       	cp	r16, r24
    2298:	19 07       	cpc	r17, r25
    229a:	28 f4       	brcc	.+10     	; 0x22a6 <xTaskIncrementTick+0xb4>
    229c:	90 93 70 03 	sts	0x0370, r25	; 0x800370 <xNextTaskUnblockTime+0x1>
    22a0:	80 93 6f 03 	sts	0x036F, r24	; 0x80036f <xNextTaskUnblockTime>
    22a4:	2e c0       	rjmp	.+92     	; 0x2302 <xTaskIncrementTick+0x110>
    22a6:	67 01       	movw	r12, r14
    22a8:	b2 e0       	ldi	r27, 0x02	; 2
    22aa:	cb 0e       	add	r12, r27
    22ac:	d1 1c       	adc	r13, r1
    22ae:	c6 01       	movw	r24, r12
    22b0:	0e 94 cb 09 	call	0x1396	; 0x1396 <uxListRemove>
    22b4:	f7 01       	movw	r30, r14
    22b6:	84 89       	ldd	r24, Z+20	; 0x14
    22b8:	95 89       	ldd	r25, Z+21	; 0x15
    22ba:	89 2b       	or	r24, r25
    22bc:	21 f0       	breq	.+8      	; 0x22c6 <xTaskIncrementTick+0xd4>
    22be:	c7 01       	movw	r24, r14
    22c0:	0c 96       	adiw	r24, 0x0c	; 12
    22c2:	0e 94 cb 09 	call	0x1396	; 0x1396 <uxListRemove>
    22c6:	d7 01       	movw	r26, r14
    22c8:	56 96       	adiw	r26, 0x16	; 22
    22ca:	8c 91       	ld	r24, X
    22cc:	90 91 76 03 	lds	r25, 0x0376	; 0x800376 <uxTopReadyPriority>
    22d0:	98 17       	cp	r25, r24
    22d2:	10 f4       	brcc	.+4      	; 0x22d8 <xTaskIncrementTick+0xe6>
    22d4:	80 93 76 03 	sts	0x0376, r24	; 0x800376 <uxTopReadyPriority>
    22d8:	d8 9f       	mul	r29, r24
    22da:	c0 01       	movw	r24, r0
    22dc:	11 24       	eor	r1, r1
    22de:	b6 01       	movw	r22, r12
    22e0:	84 55       	subi	r24, 0x54	; 84
    22e2:	9c 4f       	sbci	r25, 0xFC	; 252
    22e4:	0e 94 72 09 	call	0x12e4	; 0x12e4 <vListInsertEnd>
    22e8:	e0 91 d0 03 	lds	r30, 0x03D0	; 0x8003d0 <pxCurrentTCB>
    22ec:	f0 91 d1 03 	lds	r31, 0x03D1	; 0x8003d1 <pxCurrentTCB+0x1>
    22f0:	d7 01       	movw	r26, r14
    22f2:	56 96       	adiw	r26, 0x16	; 22
    22f4:	9c 91       	ld	r25, X
    22f6:	86 89       	ldd	r24, Z+22	; 0x16
    22f8:	98 17       	cp	r25, r24
    22fa:	08 f4       	brcc	.+2      	; 0x22fe <xTaskIncrementTick+0x10c>
    22fc:	b4 cf       	rjmp	.-152    	; 0x2266 <xTaskIncrementTick+0x74>
    22fe:	c1 e0       	ldi	r28, 0x01	; 1
    2300:	b2 cf       	rjmp	.-156    	; 0x2266 <xTaskIncrementTick+0x74>
    2302:	e0 91 d0 03 	lds	r30, 0x03D0	; 0x8003d0 <pxCurrentTCB>
    2306:	f0 91 d1 03 	lds	r31, 0x03D1	; 0x8003d1 <pxCurrentTCB+0x1>
    230a:	e6 89       	ldd	r30, Z+22	; 0x16
    230c:	b9 e0       	ldi	r27, 0x09	; 9
    230e:	eb 9f       	mul	r30, r27
    2310:	f0 01       	movw	r30, r0
    2312:	11 24       	eor	r1, r1
    2314:	e4 55       	subi	r30, 0x54	; 84
    2316:	fc 4f       	sbci	r31, 0xFC	; 252
    2318:	80 81       	ld	r24, Z
    231a:	82 30       	cpi	r24, 0x02	; 2
    231c:	40 f0       	brcs	.+16     	; 0x232e <xTaskIncrementTick+0x13c>
    231e:	c1 e0       	ldi	r28, 0x01	; 1
    2320:	06 c0       	rjmp	.+12     	; 0x232e <xTaskIncrementTick+0x13c>
    2322:	80 91 74 03 	lds	r24, 0x0374	; 0x800374 <uxPendedTicks>
    2326:	8f 5f       	subi	r24, 0xFF	; 255
    2328:	80 93 74 03 	sts	0x0374, r24	; 0x800374 <uxPendedTicks>
    232c:	c0 e0       	ldi	r28, 0x00	; 0
    232e:	80 91 73 03 	lds	r24, 0x0373	; 0x800373 <xYieldPending>
    2332:	81 11       	cpse	r24, r1
    2334:	c1 e0       	ldi	r28, 0x01	; 1
    2336:	8c 2f       	mov	r24, r28
    2338:	df 91       	pop	r29
    233a:	cf 91       	pop	r28
    233c:	1f 91       	pop	r17
    233e:	0f 91       	pop	r16
    2340:	ff 90       	pop	r15
    2342:	ef 90       	pop	r14
    2344:	df 90       	pop	r13
    2346:	cf 90       	pop	r12
    2348:	08 95       	ret

0000234a <xTaskResumeAll>:
    234a:	ef 92       	push	r14
    234c:	ff 92       	push	r15
    234e:	0f 93       	push	r16
    2350:	1f 93       	push	r17
    2352:	cf 93       	push	r28
    2354:	df 93       	push	r29
    2356:	0f b6       	in	r0, 0x3f	; 63
    2358:	f8 94       	cli
    235a:	0f 92       	push	r0
    235c:	80 91 6c 03 	lds	r24, 0x036C	; 0x80036c <uxSchedulerSuspended>
    2360:	81 50       	subi	r24, 0x01	; 1
    2362:	80 93 6c 03 	sts	0x036C, r24	; 0x80036c <uxSchedulerSuspended>
    2366:	80 91 6c 03 	lds	r24, 0x036C	; 0x80036c <uxSchedulerSuspended>
    236a:	88 23       	and	r24, r24
    236c:	11 f0       	breq	.+4      	; 0x2372 <xTaskResumeAll+0x28>
    236e:	80 e0       	ldi	r24, 0x00	; 0
    2370:	52 c0       	rjmp	.+164    	; 0x2416 <xTaskResumeAll+0xcc>
    2372:	80 91 79 03 	lds	r24, 0x0379	; 0x800379 <uxCurrentNumberOfTasks>
    2376:	88 23       	and	r24, r24
    2378:	d1 f3       	breq	.-12     	; 0x236e <xTaskResumeAll+0x24>
    237a:	c0 e0       	ldi	r28, 0x00	; 0
    237c:	d0 e0       	ldi	r29, 0x00	; 0
    237e:	89 e0       	ldi	r24, 0x09	; 9
    2380:	f8 2e       	mov	r15, r24
    2382:	ee 24       	eor	r14, r14
    2384:	e3 94       	inc	r14
    2386:	80 91 8d 03 	lds	r24, 0x038D	; 0x80038d <xPendingReadyList>
    238a:	88 23       	and	r24, r24
    238c:	51 f1       	breq	.+84     	; 0x23e2 <xTaskResumeAll+0x98>
    238e:	e0 91 92 03 	lds	r30, 0x0392	; 0x800392 <xPendingReadyList+0x5>
    2392:	f0 91 93 03 	lds	r31, 0x0393	; 0x800393 <xPendingReadyList+0x6>
    2396:	c6 81       	ldd	r28, Z+6	; 0x06
    2398:	d7 81       	ldd	r29, Z+7	; 0x07
    239a:	ce 01       	movw	r24, r28
    239c:	0c 96       	adiw	r24, 0x0c	; 12
    239e:	0e 94 cb 09 	call	0x1396	; 0x1396 <uxListRemove>
    23a2:	8e 01       	movw	r16, r28
    23a4:	0e 5f       	subi	r16, 0xFE	; 254
    23a6:	1f 4f       	sbci	r17, 0xFF	; 255
    23a8:	c8 01       	movw	r24, r16
    23aa:	0e 94 cb 09 	call	0x1396	; 0x1396 <uxListRemove>
    23ae:	8e 89       	ldd	r24, Y+22	; 0x16
    23b0:	90 91 76 03 	lds	r25, 0x0376	; 0x800376 <uxTopReadyPriority>
    23b4:	98 17       	cp	r25, r24
    23b6:	10 f4       	brcc	.+4      	; 0x23bc <xTaskResumeAll+0x72>
    23b8:	80 93 76 03 	sts	0x0376, r24	; 0x800376 <uxTopReadyPriority>
    23bc:	f8 9e       	mul	r15, r24
    23be:	c0 01       	movw	r24, r0
    23c0:	11 24       	eor	r1, r1
    23c2:	b8 01       	movw	r22, r16
    23c4:	84 55       	subi	r24, 0x54	; 84
    23c6:	9c 4f       	sbci	r25, 0xFC	; 252
    23c8:	0e 94 72 09 	call	0x12e4	; 0x12e4 <vListInsertEnd>
    23cc:	e0 91 d0 03 	lds	r30, 0x03D0	; 0x8003d0 <pxCurrentTCB>
    23d0:	f0 91 d1 03 	lds	r31, 0x03D1	; 0x8003d1 <pxCurrentTCB+0x1>
    23d4:	9e 89       	ldd	r25, Y+22	; 0x16
    23d6:	86 89       	ldd	r24, Z+22	; 0x16
    23d8:	98 17       	cp	r25, r24
    23da:	a8 f2       	brcs	.-86     	; 0x2386 <xTaskResumeAll+0x3c>
    23dc:	e0 92 73 03 	sts	0x0373, r14	; 0x800373 <xYieldPending>
    23e0:	d2 cf       	rjmp	.-92     	; 0x2386 <xTaskResumeAll+0x3c>
    23e2:	cd 2b       	or	r28, r29
    23e4:	11 f0       	breq	.+4      	; 0x23ea <xTaskResumeAll+0xa0>
    23e6:	0e 94 c1 0e 	call	0x1d82	; 0x1d82 <prvResetNextTaskUnblockTime>
    23ea:	c0 91 74 03 	lds	r28, 0x0374	; 0x800374 <uxPendedTicks>
    23ee:	cc 23       	and	r28, r28
    23f0:	51 f0       	breq	.+20     	; 0x2406 <xTaskResumeAll+0xbc>
    23f2:	d1 e0       	ldi	r29, 0x01	; 1
    23f4:	0e 94 f9 10 	call	0x21f2	; 0x21f2 <xTaskIncrementTick>
    23f8:	81 11       	cpse	r24, r1
    23fa:	d0 93 73 03 	sts	0x0373, r29	; 0x800373 <xYieldPending>
    23fe:	c1 50       	subi	r28, 0x01	; 1
    2400:	c9 f7       	brne	.-14     	; 0x23f4 <xTaskResumeAll+0xaa>
    2402:	10 92 74 03 	sts	0x0374, r1	; 0x800374 <uxPendedTicks>
    2406:	80 91 73 03 	lds	r24, 0x0373	; 0x800373 <xYieldPending>
    240a:	88 23       	and	r24, r24
    240c:	09 f4       	brne	.+2      	; 0x2410 <xTaskResumeAll+0xc6>
    240e:	af cf       	rjmp	.-162    	; 0x236e <xTaskResumeAll+0x24>
    2410:	0e 94 93 0a 	call	0x1526	; 0x1526 <vPortYield>
    2414:	81 e0       	ldi	r24, 0x01	; 1
    2416:	0f 90       	pop	r0
    2418:	0f be       	out	0x3f, r0	; 63
    241a:	df 91       	pop	r29
    241c:	cf 91       	pop	r28
    241e:	1f 91       	pop	r17
    2420:	0f 91       	pop	r16
    2422:	ff 90       	pop	r15
    2424:	ef 90       	pop	r14
    2426:	08 95       	ret

00002428 <vTaskDelayUntil>:
    2428:	0f 93       	push	r16
    242a:	1f 93       	push	r17
    242c:	cf 93       	push	r28
    242e:	df 93       	push	r29
    2430:	8c 01       	movw	r16, r24
    2432:	eb 01       	movw	r28, r22
    2434:	0e 94 e9 10 	call	0x21d2	; 0x21d2 <vTaskSuspendAll>
    2438:	40 91 77 03 	lds	r20, 0x0377	; 0x800377 <xTickCount>
    243c:	50 91 78 03 	lds	r21, 0x0378	; 0x800378 <xTickCount+0x1>
    2440:	f8 01       	movw	r30, r16
    2442:	20 81       	ld	r18, Z
    2444:	31 81       	ldd	r19, Z+1	; 0x01
    2446:	c9 01       	movw	r24, r18
    2448:	8c 0f       	add	r24, r28
    244a:	9d 1f       	adc	r25, r29
    244c:	42 17       	cp	r20, r18
    244e:	53 07       	cpc	r21, r19
    2450:	20 f4       	brcc	.+8      	; 0x245a <vTaskDelayUntil+0x32>
    2452:	82 17       	cp	r24, r18
    2454:	93 07       	cpc	r25, r19
    2456:	40 f4       	brcc	.+16     	; 0x2468 <vTaskDelayUntil+0x40>
    2458:	03 c0       	rjmp	.+6      	; 0x2460 <vTaskDelayUntil+0x38>
    245a:	82 17       	cp	r24, r18
    245c:	93 07       	cpc	r25, r19
    245e:	30 f0       	brcs	.+12     	; 0x246c <vTaskDelayUntil+0x44>
    2460:	21 e0       	ldi	r18, 0x01	; 1
    2462:	48 17       	cp	r20, r24
    2464:	59 07       	cpc	r21, r25
    2466:	18 f0       	brcs	.+6      	; 0x246e <vTaskDelayUntil+0x46>
    2468:	20 e0       	ldi	r18, 0x00	; 0
    246a:	01 c0       	rjmp	.+2      	; 0x246e <vTaskDelayUntil+0x46>
    246c:	21 e0       	ldi	r18, 0x01	; 1
    246e:	f8 01       	movw	r30, r16
    2470:	91 83       	std	Z+1, r25	; 0x01
    2472:	80 83       	st	Z, r24
    2474:	22 23       	and	r18, r18
    2476:	29 f0       	breq	.+10     	; 0x2482 <vTaskDelayUntil+0x5a>
    2478:	60 e0       	ldi	r22, 0x00	; 0
    247a:	84 1b       	sub	r24, r20
    247c:	95 0b       	sbc	r25, r21
    247e:	0e 94 dc 0e 	call	0x1db8	; 0x1db8 <prvAddCurrentTaskToDelayedList>
    2482:	0e 94 a5 11 	call	0x234a	; 0x234a <xTaskResumeAll>
    2486:	81 11       	cpse	r24, r1
    2488:	02 c0       	rjmp	.+4      	; 0x248e <vTaskDelayUntil+0x66>
    248a:	0e 94 93 0a 	call	0x1526	; 0x1526 <vPortYield>
    248e:	df 91       	pop	r29
    2490:	cf 91       	pop	r28
    2492:	1f 91       	pop	r17
    2494:	0f 91       	pop	r16
    2496:	08 95       	ret

00002498 <vTaskDelay>:
    2498:	cf 93       	push	r28
    249a:	df 93       	push	r29
    249c:	ec 01       	movw	r28, r24
    249e:	89 2b       	or	r24, r25
    24a0:	19 f4       	brne	.+6      	; 0x24a8 <vTaskDelay+0x10>
    24a2:	0e 94 93 0a 	call	0x1526	; 0x1526 <vPortYield>
    24a6:	0a c0       	rjmp	.+20     	; 0x24bc <vTaskDelay+0x24>
    24a8:	0e 94 e9 10 	call	0x21d2	; 0x21d2 <vTaskSuspendAll>
    24ac:	60 e0       	ldi	r22, 0x00	; 0
    24ae:	ce 01       	movw	r24, r28
    24b0:	0e 94 dc 0e 	call	0x1db8	; 0x1db8 <prvAddCurrentTaskToDelayedList>
    24b4:	0e 94 a5 11 	call	0x234a	; 0x234a <xTaskResumeAll>
    24b8:	88 23       	and	r24, r24
    24ba:	99 f3       	breq	.-26     	; 0x24a2 <vTaskDelay+0xa>
    24bc:	df 91       	pop	r29
    24be:	cf 91       	pop	r28
    24c0:	08 95       	ret

000024c2 <vTaskSwitchContext>:
    24c2:	80 91 6c 03 	lds	r24, 0x036C	; 0x80036c <uxSchedulerSuspended>
    24c6:	88 23       	and	r24, r24
    24c8:	21 f0       	breq	.+8      	; 0x24d2 <vTaskSwitchContext+0x10>
    24ca:	81 e0       	ldi	r24, 0x01	; 1
    24cc:	80 93 73 03 	sts	0x0373, r24	; 0x800373 <xYieldPending>
    24d0:	08 95       	ret
    24d2:	10 92 73 03 	sts	0x0373, r1	; 0x800373 <xYieldPending>
    24d6:	a0 91 d0 03 	lds	r26, 0x03D0	; 0x8003d0 <pxCurrentTCB>
    24da:	b0 91 d1 03 	lds	r27, 0x03D1	; 0x8003d1 <pxCurrentTCB+0x1>
    24de:	e0 91 d0 03 	lds	r30, 0x03D0	; 0x8003d0 <pxCurrentTCB>
    24e2:	f0 91 d1 03 	lds	r31, 0x03D1	; 0x8003d1 <pxCurrentTCB+0x1>
    24e6:	2d 91       	ld	r18, X+
    24e8:	3c 91       	ld	r19, X
    24ea:	87 89       	ldd	r24, Z+23	; 0x17
    24ec:	90 8d       	ldd	r25, Z+24	; 0x18
    24ee:	82 17       	cp	r24, r18
    24f0:	93 07       	cpc	r25, r19
    24f2:	60 f0       	brcs	.+24     	; 0x250c <vTaskSwitchContext+0x4a>
    24f4:	60 91 d0 03 	lds	r22, 0x03D0	; 0x8003d0 <pxCurrentTCB>
    24f8:	70 91 d1 03 	lds	r23, 0x03D1	; 0x8003d1 <pxCurrentTCB+0x1>
    24fc:	80 91 d0 03 	lds	r24, 0x03D0	; 0x8003d0 <pxCurrentTCB>
    2500:	90 91 d1 03 	lds	r25, 0x03D1	; 0x8003d1 <pxCurrentTCB+0x1>
    2504:	67 5e       	subi	r22, 0xE7	; 231
    2506:	7f 4f       	sbci	r23, 0xFF	; 255
    2508:	0e 94 8f 16 	call	0x2d1e	; 0x2d1e <vApplicationStackOverflowHook>
    250c:	80 91 76 03 	lds	r24, 0x0376	; 0x800376 <uxTopReadyPriority>
    2510:	69 e0       	ldi	r22, 0x09	; 9
    2512:	48 2f       	mov	r20, r24
    2514:	50 e0       	ldi	r21, 0x00	; 0
    2516:	64 9f       	mul	r22, r20
    2518:	90 01       	movw	r18, r0
    251a:	65 9f       	mul	r22, r21
    251c:	30 0d       	add	r19, r0
    251e:	11 24       	eor	r1, r1
    2520:	f9 01       	movw	r30, r18
    2522:	e4 55       	subi	r30, 0x54	; 84
    2524:	fc 4f       	sbci	r31, 0xFC	; 252
    2526:	90 81       	ld	r25, Z
    2528:	91 11       	cpse	r25, r1
    252a:	02 c0       	rjmp	.+4      	; 0x2530 <vTaskSwitchContext+0x6e>
    252c:	81 50       	subi	r24, 0x01	; 1
    252e:	f1 cf       	rjmp	.-30     	; 0x2512 <vTaskSwitchContext+0x50>
    2530:	a1 81       	ldd	r26, Z+1	; 0x01
    2532:	b2 81       	ldd	r27, Z+2	; 0x02
    2534:	12 96       	adiw	r26, 0x02	; 2
    2536:	0d 90       	ld	r0, X+
    2538:	bc 91       	ld	r27, X
    253a:	a0 2d       	mov	r26, r0
    253c:	b2 83       	std	Z+2, r27	; 0x02
    253e:	a1 83       	std	Z+1, r26	; 0x01
    2540:	21 55       	subi	r18, 0x51	; 81
    2542:	3c 4f       	sbci	r19, 0xFC	; 252
    2544:	a2 17       	cp	r26, r18
    2546:	b3 07       	cpc	r27, r19
    2548:	31 f4       	brne	.+12     	; 0x2556 <vTaskSwitchContext+0x94>
    254a:	12 96       	adiw	r26, 0x02	; 2
    254c:	2d 91       	ld	r18, X+
    254e:	3c 91       	ld	r19, X
    2550:	13 97       	sbiw	r26, 0x03	; 3
    2552:	32 83       	std	Z+2, r19	; 0x02
    2554:	21 83       	std	Z+1, r18	; 0x01
    2556:	99 e0       	ldi	r25, 0x09	; 9
    2558:	94 9f       	mul	r25, r20
    255a:	f0 01       	movw	r30, r0
    255c:	95 9f       	mul	r25, r21
    255e:	f0 0d       	add	r31, r0
    2560:	11 24       	eor	r1, r1
    2562:	e4 55       	subi	r30, 0x54	; 84
    2564:	fc 4f       	sbci	r31, 0xFC	; 252
    2566:	01 80       	ldd	r0, Z+1	; 0x01
    2568:	f2 81       	ldd	r31, Z+2	; 0x02
    256a:	e0 2d       	mov	r30, r0
    256c:	26 81       	ldd	r18, Z+6	; 0x06
    256e:	37 81       	ldd	r19, Z+7	; 0x07
    2570:	30 93 d1 03 	sts	0x03D1, r19	; 0x8003d1 <pxCurrentTCB+0x1>
    2574:	20 93 d0 03 	sts	0x03D0, r18	; 0x8003d0 <pxCurrentTCB>
    2578:	80 93 76 03 	sts	0x0376, r24	; 0x800376 <uxTopReadyPriority>
    257c:	08 95       	ret

0000257e <vTaskPlaceOnEventList>:
    257e:	cf 93       	push	r28
    2580:	df 93       	push	r29
    2582:	eb 01       	movw	r28, r22
    2584:	60 91 d0 03 	lds	r22, 0x03D0	; 0x8003d0 <pxCurrentTCB>
    2588:	70 91 d1 03 	lds	r23, 0x03D1	; 0x8003d1 <pxCurrentTCB+0x1>
    258c:	64 5f       	subi	r22, 0xF4	; 244
    258e:	7f 4f       	sbci	r23, 0xFF	; 255
    2590:	0e 94 93 09 	call	0x1326	; 0x1326 <vListInsert>
    2594:	61 e0       	ldi	r22, 0x01	; 1
    2596:	ce 01       	movw	r24, r28
    2598:	df 91       	pop	r29
    259a:	cf 91       	pop	r28
    259c:	0c 94 dc 0e 	jmp	0x1db8	; 0x1db8 <prvAddCurrentTaskToDelayedList>

000025a0 <vTaskPlaceOnEventListRestricted>:
    25a0:	1f 93       	push	r17
    25a2:	cf 93       	push	r28
    25a4:	df 93       	push	r29
    25a6:	eb 01       	movw	r28, r22
    25a8:	14 2f       	mov	r17, r20
    25aa:	60 91 d0 03 	lds	r22, 0x03D0	; 0x8003d0 <pxCurrentTCB>
    25ae:	70 91 d1 03 	lds	r23, 0x03D1	; 0x8003d1 <pxCurrentTCB+0x1>
    25b2:	64 5f       	subi	r22, 0xF4	; 244
    25b4:	7f 4f       	sbci	r23, 0xFF	; 255
    25b6:	0e 94 72 09 	call	0x12e4	; 0x12e4 <vListInsertEnd>
    25ba:	11 23       	and	r17, r17
    25bc:	11 f0       	breq	.+4      	; 0x25c2 <vTaskPlaceOnEventListRestricted+0x22>
    25be:	cf ef       	ldi	r28, 0xFF	; 255
    25c0:	df ef       	ldi	r29, 0xFF	; 255
    25c2:	61 2f       	mov	r22, r17
    25c4:	ce 01       	movw	r24, r28
    25c6:	df 91       	pop	r29
    25c8:	cf 91       	pop	r28
    25ca:	1f 91       	pop	r17
    25cc:	0c 94 dc 0e 	jmp	0x1db8	; 0x1db8 <prvAddCurrentTaskToDelayedList>

000025d0 <xTaskRemoveFromEventList>:
    25d0:	0f 93       	push	r16
    25d2:	1f 93       	push	r17
    25d4:	cf 93       	push	r28
    25d6:	df 93       	push	r29
    25d8:	dc 01       	movw	r26, r24
    25da:	15 96       	adiw	r26, 0x05	; 5
    25dc:	ed 91       	ld	r30, X+
    25de:	fc 91       	ld	r31, X
    25e0:	16 97       	sbiw	r26, 0x06	; 6
    25e2:	c6 81       	ldd	r28, Z+6	; 0x06
    25e4:	d7 81       	ldd	r29, Z+7	; 0x07
    25e6:	8e 01       	movw	r16, r28
    25e8:	04 5f       	subi	r16, 0xF4	; 244
    25ea:	1f 4f       	sbci	r17, 0xFF	; 255
    25ec:	c8 01       	movw	r24, r16
    25ee:	0e 94 cb 09 	call	0x1396	; 0x1396 <uxListRemove>
    25f2:	80 91 6c 03 	lds	r24, 0x036C	; 0x80036c <uxSchedulerSuspended>
    25f6:	81 11       	cpse	r24, r1
    25f8:	14 c0       	rjmp	.+40     	; 0x2622 <xTaskRemoveFromEventList+0x52>
    25fa:	0a 50       	subi	r16, 0x0A	; 10
    25fc:	11 09       	sbc	r17, r1
    25fe:	c8 01       	movw	r24, r16
    2600:	0e 94 cb 09 	call	0x1396	; 0x1396 <uxListRemove>
    2604:	8e 89       	ldd	r24, Y+22	; 0x16
    2606:	90 91 76 03 	lds	r25, 0x0376	; 0x800376 <uxTopReadyPriority>
    260a:	98 17       	cp	r25, r24
    260c:	10 f4       	brcc	.+4      	; 0x2612 <xTaskRemoveFromEventList+0x42>
    260e:	80 93 76 03 	sts	0x0376, r24	; 0x800376 <uxTopReadyPriority>
    2612:	b9 e0       	ldi	r27, 0x09	; 9
    2614:	8b 9f       	mul	r24, r27
    2616:	c0 01       	movw	r24, r0
    2618:	11 24       	eor	r1, r1
    261a:	b8 01       	movw	r22, r16
    261c:	84 55       	subi	r24, 0x54	; 84
    261e:	9c 4f       	sbci	r25, 0xFC	; 252
    2620:	03 c0       	rjmp	.+6      	; 0x2628 <xTaskRemoveFromEventList+0x58>
    2622:	b8 01       	movw	r22, r16
    2624:	8d e8       	ldi	r24, 0x8D	; 141
    2626:	93 e0       	ldi	r25, 0x03	; 3
    2628:	0e 94 72 09 	call	0x12e4	; 0x12e4 <vListInsertEnd>
    262c:	e0 91 d0 03 	lds	r30, 0x03D0	; 0x8003d0 <pxCurrentTCB>
    2630:	f0 91 d1 03 	lds	r31, 0x03D1	; 0x8003d1 <pxCurrentTCB+0x1>
    2634:	9e 89       	ldd	r25, Y+22	; 0x16
    2636:	86 89       	ldd	r24, Z+22	; 0x16
    2638:	89 17       	cp	r24, r25
    263a:	20 f4       	brcc	.+8      	; 0x2644 <xTaskRemoveFromEventList+0x74>
    263c:	81 e0       	ldi	r24, 0x01	; 1
    263e:	80 93 73 03 	sts	0x0373, r24	; 0x800373 <xYieldPending>
    2642:	01 c0       	rjmp	.+2      	; 0x2646 <xTaskRemoveFromEventList+0x76>
    2644:	80 e0       	ldi	r24, 0x00	; 0
    2646:	df 91       	pop	r29
    2648:	cf 91       	pop	r28
    264a:	1f 91       	pop	r17
    264c:	0f 91       	pop	r16
    264e:	08 95       	ret

00002650 <vTaskInternalSetTimeOutState>:
    2650:	20 91 72 03 	lds	r18, 0x0372	; 0x800372 <xNumOfOverflows>
    2654:	fc 01       	movw	r30, r24
    2656:	20 83       	st	Z, r18
    2658:	20 91 77 03 	lds	r18, 0x0377	; 0x800377 <xTickCount>
    265c:	30 91 78 03 	lds	r19, 0x0378	; 0x800378 <xTickCount+0x1>
    2660:	32 83       	std	Z+2, r19	; 0x02
    2662:	21 83       	std	Z+1, r18	; 0x01
    2664:	08 95       	ret

00002666 <xTaskCheckForTimeOut>:
    2666:	cf 93       	push	r28
    2668:	df 93       	push	r29
    266a:	0f b6       	in	r0, 0x3f	; 63
    266c:	f8 94       	cli
    266e:	0f 92       	push	r0
    2670:	40 91 77 03 	lds	r20, 0x0377	; 0x800377 <xTickCount>
    2674:	50 91 78 03 	lds	r21, 0x0378	; 0x800378 <xTickCount+0x1>
    2678:	db 01       	movw	r26, r22
    267a:	2d 91       	ld	r18, X+
    267c:	3c 91       	ld	r19, X
    267e:	2f 3f       	cpi	r18, 0xFF	; 255
    2680:	bf ef       	ldi	r27, 0xFF	; 255
    2682:	3b 07       	cpc	r19, r27
    2684:	d9 f0       	breq	.+54     	; 0x26bc <xTaskCheckForTimeOut+0x56>
    2686:	ec 01       	movw	r28, r24
    2688:	e9 81       	ldd	r30, Y+1	; 0x01
    268a:	fa 81       	ldd	r31, Y+2	; 0x02
    268c:	a0 91 72 03 	lds	r26, 0x0372	; 0x800372 <xNumOfOverflows>
    2690:	b8 81       	ld	r27, Y
    2692:	ba 17       	cp	r27, r26
    2694:	19 f0       	breq	.+6      	; 0x269c <xTaskCheckForTimeOut+0x36>
    2696:	4e 17       	cp	r20, r30
    2698:	5f 07       	cpc	r21, r31
    269a:	90 f4       	brcc	.+36     	; 0x26c0 <xTaskCheckForTimeOut+0x5a>
    269c:	4e 1b       	sub	r20, r30
    269e:	5f 0b       	sbc	r21, r31
    26a0:	fb 01       	movw	r30, r22
    26a2:	42 17       	cp	r20, r18
    26a4:	53 07       	cpc	r21, r19
    26a6:	38 f4       	brcc	.+14     	; 0x26b6 <xTaskCheckForTimeOut+0x50>
    26a8:	24 1b       	sub	r18, r20
    26aa:	35 0b       	sbc	r19, r21
    26ac:	31 83       	std	Z+1, r19	; 0x01
    26ae:	20 83       	st	Z, r18
    26b0:	0e 94 28 13 	call	0x2650	; 0x2650 <vTaskInternalSetTimeOutState>
    26b4:	03 c0       	rjmp	.+6      	; 0x26bc <xTaskCheckForTimeOut+0x56>
    26b6:	11 82       	std	Z+1, r1	; 0x01
    26b8:	10 82       	st	Z, r1
    26ba:	02 c0       	rjmp	.+4      	; 0x26c0 <xTaskCheckForTimeOut+0x5a>
    26bc:	80 e0       	ldi	r24, 0x00	; 0
    26be:	01 c0       	rjmp	.+2      	; 0x26c2 <xTaskCheckForTimeOut+0x5c>
    26c0:	81 e0       	ldi	r24, 0x01	; 1
    26c2:	0f 90       	pop	r0
    26c4:	0f be       	out	0x3f, r0	; 63
    26c6:	df 91       	pop	r29
    26c8:	cf 91       	pop	r28
    26ca:	08 95       	ret

000026cc <vTaskMissedYield>:
    26cc:	81 e0       	ldi	r24, 0x01	; 1
    26ce:	80 93 73 03 	sts	0x0373, r24	; 0x800373 <xYieldPending>
    26d2:	08 95       	ret

000026d4 <xTaskGetSchedulerState>:
    26d4:	80 91 75 03 	lds	r24, 0x0375	; 0x800375 <xSchedulerRunning>
    26d8:	88 23       	and	r24, r24
    26da:	31 f0       	breq	.+12     	; 0x26e8 <xTaskGetSchedulerState+0x14>
    26dc:	80 91 6c 03 	lds	r24, 0x036C	; 0x80036c <uxSchedulerSuspended>
    26e0:	88 23       	and	r24, r24
    26e2:	21 f0       	breq	.+8      	; 0x26ec <xTaskGetSchedulerState+0x18>
    26e4:	80 e0       	ldi	r24, 0x00	; 0
    26e6:	08 95       	ret
    26e8:	81 e0       	ldi	r24, 0x01	; 1
    26ea:	08 95       	ret
    26ec:	82 e0       	ldi	r24, 0x02	; 2
    26ee:	08 95       	ret

000026f0 <xTaskPriorityInherit>:
    26f0:	0f 93       	push	r16
    26f2:	1f 93       	push	r17
    26f4:	cf 93       	push	r28
    26f6:	df 93       	push	r29
    26f8:	fc 01       	movw	r30, r24
    26fa:	89 2b       	or	r24, r25
    26fc:	09 f4       	brne	.+2      	; 0x2700 <xTaskPriorityInherit+0x10>
    26fe:	55 c0       	rjmp	.+170    	; 0x27aa <xTaskPriorityInherit+0xba>
    2700:	86 89       	ldd	r24, Z+22	; 0x16
    2702:	a0 91 d0 03 	lds	r26, 0x03D0	; 0x8003d0 <pxCurrentTCB>
    2706:	b0 91 d1 03 	lds	r27, 0x03D1	; 0x8003d1 <pxCurrentTCB+0x1>
    270a:	56 96       	adiw	r26, 0x16	; 22
    270c:	9c 91       	ld	r25, X
    270e:	89 17       	cp	r24, r25
    2710:	08 f0       	brcs	.+2      	; 0x2714 <xTaskPriorityInherit+0x24>
    2712:	41 c0       	rjmp	.+130    	; 0x2796 <xTaskPriorityInherit+0xa6>
    2714:	24 85       	ldd	r18, Z+12	; 0x0c
    2716:	35 85       	ldd	r19, Z+13	; 0x0d
    2718:	37 fd       	sbrc	r19, 7
    271a:	0c c0       	rjmp	.+24     	; 0x2734 <xTaskPriorityInherit+0x44>
    271c:	a0 91 d0 03 	lds	r26, 0x03D0	; 0x8003d0 <pxCurrentTCB>
    2720:	b0 91 d1 03 	lds	r27, 0x03D1	; 0x8003d1 <pxCurrentTCB+0x1>
    2724:	56 96       	adiw	r26, 0x16	; 22
    2726:	9c 91       	ld	r25, X
    2728:	24 e0       	ldi	r18, 0x04	; 4
    272a:	30 e0       	ldi	r19, 0x00	; 0
    272c:	29 1b       	sub	r18, r25
    272e:	31 09       	sbc	r19, r1
    2730:	35 87       	std	Z+13, r19	; 0x0d
    2732:	24 87       	std	Z+12, r18	; 0x0c
    2734:	29 e0       	ldi	r18, 0x09	; 9
    2736:	82 9f       	mul	r24, r18
    2738:	c0 01       	movw	r24, r0
    273a:	11 24       	eor	r1, r1
    273c:	84 55       	subi	r24, 0x54	; 84
    273e:	9c 4f       	sbci	r25, 0xFC	; 252
    2740:	22 85       	ldd	r18, Z+10	; 0x0a
    2742:	33 85       	ldd	r19, Z+11	; 0x0b
    2744:	28 17       	cp	r18, r24
    2746:	39 07       	cpc	r19, r25
    2748:	e9 f4       	brne	.+58     	; 0x2784 <xTaskPriorityInherit+0x94>
    274a:	8f 01       	movw	r16, r30
    274c:	ef 01       	movw	r28, r30
    274e:	22 96       	adiw	r28, 0x02	; 2
    2750:	ce 01       	movw	r24, r28
    2752:	0e 94 cb 09 	call	0x1396	; 0x1396 <uxListRemove>
    2756:	e0 91 d0 03 	lds	r30, 0x03D0	; 0x8003d0 <pxCurrentTCB>
    275a:	f0 91 d1 03 	lds	r31, 0x03D1	; 0x8003d1 <pxCurrentTCB+0x1>
    275e:	86 89       	ldd	r24, Z+22	; 0x16
    2760:	f8 01       	movw	r30, r16
    2762:	86 8b       	std	Z+22, r24	; 0x16
    2764:	90 91 76 03 	lds	r25, 0x0376	; 0x800376 <uxTopReadyPriority>
    2768:	98 17       	cp	r25, r24
    276a:	10 f4       	brcc	.+4      	; 0x2770 <xTaskPriorityInherit+0x80>
    276c:	80 93 76 03 	sts	0x0376, r24	; 0x800376 <uxTopReadyPriority>
    2770:	f9 e0       	ldi	r31, 0x09	; 9
    2772:	8f 9f       	mul	r24, r31
    2774:	c0 01       	movw	r24, r0
    2776:	11 24       	eor	r1, r1
    2778:	be 01       	movw	r22, r28
    277a:	84 55       	subi	r24, 0x54	; 84
    277c:	9c 4f       	sbci	r25, 0xFC	; 252
    277e:	0e 94 72 09 	call	0x12e4	; 0x12e4 <vListInsertEnd>
    2782:	07 c0       	rjmp	.+14     	; 0x2792 <xTaskPriorityInherit+0xa2>
    2784:	a0 91 d0 03 	lds	r26, 0x03D0	; 0x8003d0 <pxCurrentTCB>
    2788:	b0 91 d1 03 	lds	r27, 0x03D1	; 0x8003d1 <pxCurrentTCB+0x1>
    278c:	56 96       	adiw	r26, 0x16	; 22
    278e:	8c 91       	ld	r24, X
    2790:	86 8b       	std	Z+22, r24	; 0x16
    2792:	81 e0       	ldi	r24, 0x01	; 1
    2794:	0b c0       	rjmp	.+22     	; 0x27ac <xTaskPriorityInherit+0xbc>
    2796:	a0 91 d0 03 	lds	r26, 0x03D0	; 0x8003d0 <pxCurrentTCB>
    279a:	b0 91 d1 03 	lds	r27, 0x03D1	; 0x8003d1 <pxCurrentTCB+0x1>
    279e:	81 e0       	ldi	r24, 0x01	; 1
    27a0:	21 a1       	ldd	r18, Z+33	; 0x21
    27a2:	56 96       	adiw	r26, 0x16	; 22
    27a4:	9c 91       	ld	r25, X
    27a6:	29 17       	cp	r18, r25
    27a8:	08 f0       	brcs	.+2      	; 0x27ac <xTaskPriorityInherit+0xbc>
    27aa:	80 e0       	ldi	r24, 0x00	; 0
    27ac:	df 91       	pop	r29
    27ae:	cf 91       	pop	r28
    27b0:	1f 91       	pop	r17
    27b2:	0f 91       	pop	r16
    27b4:	08 95       	ret

000027b6 <xTaskPriorityDisinherit>:
    27b6:	0f 93       	push	r16
    27b8:	1f 93       	push	r17
    27ba:	cf 93       	push	r28
    27bc:	df 93       	push	r29
    27be:	fc 01       	movw	r30, r24
    27c0:	89 2b       	or	r24, r25
    27c2:	11 f4       	brne	.+4      	; 0x27c8 <xTaskPriorityDisinherit+0x12>
    27c4:	80 e0       	ldi	r24, 0x00	; 0
    27c6:	2c c0       	rjmp	.+88     	; 0x2820 <xTaskPriorityDisinherit+0x6a>
    27c8:	82 a1       	ldd	r24, Z+34	; 0x22
    27ca:	81 50       	subi	r24, 0x01	; 1
    27cc:	82 a3       	std	Z+34, r24	; 0x22
    27ce:	26 89       	ldd	r18, Z+22	; 0x16
    27d0:	91 a1       	ldd	r25, Z+33	; 0x21
    27d2:	29 17       	cp	r18, r25
    27d4:	b9 f3       	breq	.-18     	; 0x27c4 <xTaskPriorityDisinherit+0xe>
    27d6:	81 11       	cpse	r24, r1
    27d8:	f5 cf       	rjmp	.-22     	; 0x27c4 <xTaskPriorityDisinherit+0xe>
    27da:	ef 01       	movw	r28, r30
    27dc:	8f 01       	movw	r16, r30
    27de:	0e 5f       	subi	r16, 0xFE	; 254
    27e0:	1f 4f       	sbci	r17, 0xFF	; 255
    27e2:	c8 01       	movw	r24, r16
    27e4:	0e 94 cb 09 	call	0x1396	; 0x1396 <uxListRemove>
    27e8:	89 a1       	ldd	r24, Y+33	; 0x21
    27ea:	8e 8b       	std	Y+22, r24	; 0x16
    27ec:	48 2f       	mov	r20, r24
    27ee:	50 e0       	ldi	r21, 0x00	; 0
    27f0:	24 e0       	ldi	r18, 0x04	; 4
    27f2:	30 e0       	ldi	r19, 0x00	; 0
    27f4:	24 1b       	sub	r18, r20
    27f6:	35 0b       	sbc	r19, r21
    27f8:	3d 87       	std	Y+13, r19	; 0x0d
    27fa:	2c 87       	std	Y+12, r18	; 0x0c
    27fc:	90 91 76 03 	lds	r25, 0x0376	; 0x800376 <uxTopReadyPriority>
    2800:	98 17       	cp	r25, r24
    2802:	10 f4       	brcc	.+4      	; 0x2808 <xTaskPriorityDisinherit+0x52>
    2804:	80 93 76 03 	sts	0x0376, r24	; 0x800376 <uxTopReadyPriority>
    2808:	29 e0       	ldi	r18, 0x09	; 9
    280a:	24 9f       	mul	r18, r20
    280c:	c0 01       	movw	r24, r0
    280e:	25 9f       	mul	r18, r21
    2810:	90 0d       	add	r25, r0
    2812:	11 24       	eor	r1, r1
    2814:	b8 01       	movw	r22, r16
    2816:	84 55       	subi	r24, 0x54	; 84
    2818:	9c 4f       	sbci	r25, 0xFC	; 252
    281a:	0e 94 72 09 	call	0x12e4	; 0x12e4 <vListInsertEnd>
    281e:	81 e0       	ldi	r24, 0x01	; 1
    2820:	df 91       	pop	r29
    2822:	cf 91       	pop	r28
    2824:	1f 91       	pop	r17
    2826:	0f 91       	pop	r16
    2828:	08 95       	ret

0000282a <vTaskPriorityDisinheritAfterTimeout>:
    282a:	0f 93       	push	r16
    282c:	1f 93       	push	r17
    282e:	cf 93       	push	r28
    2830:	df 93       	push	r29
    2832:	fc 01       	movw	r30, r24
    2834:	89 2b       	or	r24, r25
    2836:	d9 f1       	breq	.+118    	; 0x28ae <vTaskPriorityDisinheritAfterTimeout+0x84>
    2838:	91 a1       	ldd	r25, Z+33	; 0x21
    283a:	96 17       	cp	r25, r22
    283c:	08 f4       	brcc	.+2      	; 0x2840 <vTaskPriorityDisinheritAfterTimeout+0x16>
    283e:	96 2f       	mov	r25, r22
    2840:	86 89       	ldd	r24, Z+22	; 0x16
    2842:	89 17       	cp	r24, r25
    2844:	a1 f1       	breq	.+104    	; 0x28ae <vTaskPriorityDisinheritAfterTimeout+0x84>
    2846:	22 a1       	ldd	r18, Z+34	; 0x22
    2848:	21 30       	cpi	r18, 0x01	; 1
    284a:	89 f5       	brne	.+98     	; 0x28ae <vTaskPriorityDisinheritAfterTimeout+0x84>
    284c:	96 8b       	std	Z+22, r25	; 0x16
    284e:	24 85       	ldd	r18, Z+12	; 0x0c
    2850:	35 85       	ldd	r19, Z+13	; 0x0d
    2852:	37 fd       	sbrc	r19, 7
    2854:	06 c0       	rjmp	.+12     	; 0x2862 <vTaskPriorityDisinheritAfterTimeout+0x38>
    2856:	24 e0       	ldi	r18, 0x04	; 4
    2858:	30 e0       	ldi	r19, 0x00	; 0
    285a:	29 1b       	sub	r18, r25
    285c:	31 09       	sbc	r19, r1
    285e:	35 87       	std	Z+13, r19	; 0x0d
    2860:	24 87       	std	Z+12, r18	; 0x0c
    2862:	29 e0       	ldi	r18, 0x09	; 9
    2864:	82 9f       	mul	r24, r18
    2866:	c0 01       	movw	r24, r0
    2868:	11 24       	eor	r1, r1
    286a:	84 55       	subi	r24, 0x54	; 84
    286c:	9c 4f       	sbci	r25, 0xFC	; 252
    286e:	22 85       	ldd	r18, Z+10	; 0x0a
    2870:	33 85       	ldd	r19, Z+11	; 0x0b
    2872:	28 17       	cp	r18, r24
    2874:	39 07       	cpc	r19, r25
    2876:	d9 f4       	brne	.+54     	; 0x28ae <vTaskPriorityDisinheritAfterTimeout+0x84>
    2878:	ef 01       	movw	r28, r30
    287a:	8f 01       	movw	r16, r30
    287c:	0e 5f       	subi	r16, 0xFE	; 254
    287e:	1f 4f       	sbci	r17, 0xFF	; 255
    2880:	c8 01       	movw	r24, r16
    2882:	0e 94 cb 09 	call	0x1396	; 0x1396 <uxListRemove>
    2886:	8e 89       	ldd	r24, Y+22	; 0x16
    2888:	90 91 76 03 	lds	r25, 0x0376	; 0x800376 <uxTopReadyPriority>
    288c:	98 17       	cp	r25, r24
    288e:	10 f4       	brcc	.+4      	; 0x2894 <vTaskPriorityDisinheritAfterTimeout+0x6a>
    2890:	80 93 76 03 	sts	0x0376, r24	; 0x800376 <uxTopReadyPriority>
    2894:	29 e0       	ldi	r18, 0x09	; 9
    2896:	82 9f       	mul	r24, r18
    2898:	c0 01       	movw	r24, r0
    289a:	11 24       	eor	r1, r1
    289c:	b8 01       	movw	r22, r16
    289e:	84 55       	subi	r24, 0x54	; 84
    28a0:	9c 4f       	sbci	r25, 0xFC	; 252
    28a2:	df 91       	pop	r29
    28a4:	cf 91       	pop	r28
    28a6:	1f 91       	pop	r17
    28a8:	0f 91       	pop	r16
    28aa:	0c 94 72 09 	jmp	0x12e4	; 0x12e4 <vListInsertEnd>
    28ae:	df 91       	pop	r29
    28b0:	cf 91       	pop	r28
    28b2:	1f 91       	pop	r17
    28b4:	0f 91       	pop	r16
    28b6:	08 95       	ret

000028b8 <pvTaskIncrementMutexHeldCount>:

    TaskHandle_t pvTaskIncrementMutexHeldCount( void )
    {
        /* If xSemaphoreCreateMutex() is called before any tasks have been created
        then pxCurrentTCB will be NULL. */
        if( pxCurrentTCB != NULL )
    28b8:	80 91 d0 03 	lds	r24, 0x03D0	; 0x8003d0 <pxCurrentTCB>
    28bc:	90 91 d1 03 	lds	r25, 0x03D1	; 0x8003d1 <pxCurrentTCB+0x1>
    28c0:	89 2b       	or	r24, r25
    28c2:	39 f0       	breq	.+14     	; 0x28d2 <pvTaskIncrementMutexHeldCount+0x1a>
        {
            ( pxCurrentTCB->uxMutexesHeld )++;
    28c4:	e0 91 d0 03 	lds	r30, 0x03D0	; 0x8003d0 <pxCurrentTCB>
    28c8:	f0 91 d1 03 	lds	r31, 0x03D1	; 0x8003d1 <pxCurrentTCB+0x1>
    28cc:	82 a1       	ldd	r24, Z+34	; 0x22
    28ce:	8f 5f       	subi	r24, 0xFF	; 255
    28d0:	82 a3       	std	Z+34, r24	; 0x22
        }

        return pxCurrentTCB;
    28d2:	80 91 d0 03 	lds	r24, 0x03D0	; 0x8003d0 <pxCurrentTCB>
    28d6:	90 91 d1 03 	lds	r25, 0x03D1	; 0x8003d1 <pxCurrentTCB+0x1>
    }
    28da:	08 95       	ret

000028dc <prvCheckForValidListAndQueue>:
            pxNewTimer->ucStatus = 0x00;
            prvInitialiseNewTimer( pcTimerName, xTimerPeriodInTicks, uxAutoReload, pvTimerID, pxCallbackFunction, pxNewTimer );
        }

        return pxNewTimer;
    }
    28dc:	0f b6       	in	r0, 0x3f	; 63
    28de:	f8 94       	cli
    28e0:	0f 92       	push	r0
    28e2:	80 91 d6 03 	lds	r24, 0x03D6	; 0x8003d6 <xTimerQueue>
    28e6:	90 91 d7 03 	lds	r25, 0x03D7	; 0x8003d7 <xTimerQueue+0x1>
    28ea:	89 2b       	or	r24, r25
    28ec:	e9 f4       	brne	.+58     	; 0x2928 <prvCheckForValidListAndQueue+0x4c>
    28ee:	85 ee       	ldi	r24, 0xE5	; 229
    28f0:	93 e0       	ldi	r25, 0x03	; 3
    28f2:	0e 94 60 09 	call	0x12c0	; 0x12c0 <vListInitialise>
    28f6:	8c ed       	ldi	r24, 0xDC	; 220
    28f8:	93 e0       	ldi	r25, 0x03	; 3
    28fa:	0e 94 60 09 	call	0x12c0	; 0x12c0 <vListInitialise>
    28fe:	85 ee       	ldi	r24, 0xE5	; 229
    2900:	93 e0       	ldi	r25, 0x03	; 3
    2902:	90 93 db 03 	sts	0x03DB, r25	; 0x8003db <pxCurrentTimerList+0x1>
    2906:	80 93 da 03 	sts	0x03DA, r24	; 0x8003da <pxCurrentTimerList>
    290a:	8c ed       	ldi	r24, 0xDC	; 220
    290c:	93 e0       	ldi	r25, 0x03	; 3
    290e:	90 93 d9 03 	sts	0x03D9, r25	; 0x8003d9 <pxOverflowTimerList+0x1>
    2912:	80 93 d8 03 	sts	0x03D8, r24	; 0x8003d8 <pxOverflowTimerList>
    2916:	40 e0       	ldi	r20, 0x00	; 0
    2918:	65 e0       	ldi	r22, 0x05	; 5
    291a:	8a e0       	ldi	r24, 0x0A	; 10
    291c:	0e 94 41 0c 	call	0x1882	; 0x1882 <xQueueGenericCreate>
    2920:	90 93 d7 03 	sts	0x03D7, r25	; 0x8003d7 <xTimerQueue+0x1>
    2924:	80 93 d6 03 	sts	0x03D6, r24	; 0x8003d6 <xTimerQueue>
    2928:	0f 90       	pop	r0
    292a:	0f be       	out	0x3f, r0	; 63
    292c:	08 95       	ret

0000292e <prvInsertTimerInActiveList>:
    292e:	fc 01       	movw	r30, r24
    2930:	73 83       	std	Z+3, r23	; 0x03
    2932:	62 83       	std	Z+2, r22	; 0x02
    2934:	91 87       	std	Z+9, r25	; 0x09
    2936:	80 87       	std	Z+8, r24	; 0x08
    2938:	46 17       	cp	r20, r22
    293a:	57 07       	cpc	r21, r23
    293c:	78 f0       	brcs	.+30     	; 0x295c <prvInsertTimerInActiveList+0x2e>
    293e:	42 1b       	sub	r20, r18
    2940:	53 0b       	sbc	r21, r19
    2942:	84 85       	ldd	r24, Z+12	; 0x0c
    2944:	95 85       	ldd	r25, Z+13	; 0x0d
    2946:	48 17       	cp	r20, r24
    2948:	59 07       	cpc	r21, r25
    294a:	c8 f4       	brcc	.+50     	; 0x297e <prvInsertTimerInActiveList+0x50>
    294c:	bf 01       	movw	r22, r30
    294e:	6e 5f       	subi	r22, 0xFE	; 254
    2950:	7f 4f       	sbci	r23, 0xFF	; 255
    2952:	80 91 d8 03 	lds	r24, 0x03D8	; 0x8003d8 <pxOverflowTimerList>
    2956:	90 91 d9 03 	lds	r25, 0x03D9	; 0x8003d9 <pxOverflowTimerList+0x1>
    295a:	0d c0       	rjmp	.+26     	; 0x2976 <prvInsertTimerInActiveList+0x48>
    295c:	42 17       	cp	r20, r18
    295e:	53 07       	cpc	r21, r19
    2960:	18 f4       	brcc	.+6      	; 0x2968 <prvInsertTimerInActiveList+0x3a>
    2962:	62 17       	cp	r22, r18
    2964:	73 07       	cpc	r23, r19
    2966:	58 f4       	brcc	.+22     	; 0x297e <prvInsertTimerInActiveList+0x50>
    2968:	bf 01       	movw	r22, r30
    296a:	6e 5f       	subi	r22, 0xFE	; 254
    296c:	7f 4f       	sbci	r23, 0xFF	; 255
    296e:	80 91 da 03 	lds	r24, 0x03DA	; 0x8003da <pxCurrentTimerList>
    2972:	90 91 db 03 	lds	r25, 0x03DB	; 0x8003db <pxCurrentTimerList+0x1>
    2976:	0e 94 93 09 	call	0x1326	; 0x1326 <vListInsert>
    297a:	80 e0       	ldi	r24, 0x00	; 0
    297c:	08 95       	ret
    297e:	81 e0       	ldi	r24, 0x01	; 1
    2980:	08 95       	ret

00002982 <xTimerCreateTimerTask>:
    2982:	ef 92       	push	r14
    2984:	ff 92       	push	r15
    2986:	0f 93       	push	r16
    2988:	0e 94 6e 14 	call	0x28dc	; 0x28dc <prvCheckForValidListAndQueue>
    298c:	80 91 d6 03 	lds	r24, 0x03D6	; 0x8003d6 <xTimerQueue>
    2990:	90 91 d7 03 	lds	r25, 0x03D7	; 0x8003d7 <xTimerQueue+0x1>
    2994:	89 2b       	or	r24, r25
    2996:	81 f0       	breq	.+32     	; 0x29b8 <xTimerCreateTimerTask+0x36>
    2998:	84 ed       	ldi	r24, 0xD4	; 212
    299a:	e8 2e       	mov	r14, r24
    299c:	83 e0       	ldi	r24, 0x03	; 3
    299e:	f8 2e       	mov	r15, r24
    29a0:	03 e0       	ldi	r16, 0x03	; 3
    29a2:	20 e0       	ldi	r18, 0x00	; 0
    29a4:	30 e0       	ldi	r19, 0x00	; 0
    29a6:	45 e5       	ldi	r20, 0x55	; 85
    29a8:	50 e0       	ldi	r21, 0x00	; 0
    29aa:	68 ee       	ldi	r22, 0xE8	; 232
    29ac:	71 e0       	ldi	r23, 0x01	; 1
    29ae:	81 e7       	ldi	r24, 0x71	; 113
    29b0:	95 e1       	ldi	r25, 0x15	; 21
    29b2:	0e 94 66 0f 	call	0x1ecc	; 0x1ecc <xTaskCreate>
    29b6:	01 c0       	rjmp	.+2      	; 0x29ba <xTimerCreateTimerTask+0x38>
    29b8:	80 e0       	ldi	r24, 0x00	; 0
    29ba:	0f 91       	pop	r16
    29bc:	ff 90       	pop	r15
    29be:	ef 90       	pop	r14
    29c0:	08 95       	ret

000029c2 <xTimerGenericCommand>:
    }
}
/*-----------------------------------------------------------*/

BaseType_t xTimerGenericCommand( TimerHandle_t xTimer, const BaseType_t xCommandID, const TickType_t xOptionalValue, BaseType_t * const pxHigherPriorityTaskWoken, const TickType_t xTicksToWait )
{
    29c2:	0f 93       	push	r16
    29c4:	1f 93       	push	r17
    29c6:	cf 93       	push	r28
    29c8:	df 93       	push	r29
    29ca:	00 d0       	rcall	.+0      	; 0x29cc <xTimerGenericCommand+0xa>
    29cc:	00 d0       	rcall	.+0      	; 0x29ce <xTimerGenericCommand+0xc>
    29ce:	1f 92       	push	r1
    29d0:	cd b7       	in	r28, 0x3d	; 61
    29d2:	de b7       	in	r29, 0x3e	; 62

    configASSERT( xTimer );

    /* Send a message to the timer service task to perform a particular action
    on a particular timer definition. */
    if( xTimerQueue != NULL )
    29d4:	a0 91 d6 03 	lds	r26, 0x03D6	; 0x8003d6 <xTimerQueue>
    29d8:	b0 91 d7 03 	lds	r27, 0x03D7	; 0x8003d7 <xTimerQueue+0x1>
    29dc:	10 97       	sbiw	r26, 0x00	; 0
    29de:	29 f1       	breq	.+74     	; 0x2a2a <xTimerGenericCommand+0x68>
    29e0:	f9 01       	movw	r30, r18
    {
        /* Send a command to the timer service task to start the xTimer timer. */
        xMessage.xMessageID = xCommandID;
    29e2:	69 83       	std	Y+1, r22	; 0x01
        xMessage.u.xTimerParameters.xMessageValue = xOptionalValue;
    29e4:	5b 83       	std	Y+3, r21	; 0x03
    29e6:	4a 83       	std	Y+2, r20	; 0x02
        xMessage.u.xTimerParameters.pxTimer = xTimer;
    29e8:	9d 83       	std	Y+5, r25	; 0x05
    29ea:	8c 83       	std	Y+4, r24	; 0x04

        if( xCommandID < tmrFIRST_FROM_ISR_COMMAND )
    29ec:	66 30       	cpi	r22, 0x06	; 6
    29ee:	a4 f4       	brge	.+40     	; 0x2a18 <xTimerGenericCommand+0x56>
        {
            if( xTaskGetSchedulerState() == taskSCHEDULER_RUNNING )
    29f0:	0e 94 6a 13 	call	0x26d4	; 0x26d4 <xTaskGetSchedulerState>
    29f4:	e0 91 d6 03 	lds	r30, 0x03D6	; 0x8003d6 <xTimerQueue>
    29f8:	f0 91 d7 03 	lds	r31, 0x03D7	; 0x8003d7 <xTimerQueue+0x1>
            {
                xReturn = xQueueSendToBack( xTimerQueue, &xMessage, xTicksToWait );
    29fc:	20 e0       	ldi	r18, 0x00	; 0
        xMessage.u.xTimerParameters.xMessageValue = xOptionalValue;
        xMessage.u.xTimerParameters.pxTimer = xTimer;

        if( xCommandID < tmrFIRST_FROM_ISR_COMMAND )
        {
            if( xTaskGetSchedulerState() == taskSCHEDULER_RUNNING )
    29fe:	82 30       	cpi	r24, 0x02	; 2
    2a00:	11 f4       	brne	.+4      	; 0x2a06 <xTimerGenericCommand+0x44>
            {
                xReturn = xQueueSendToBack( xTimerQueue, &xMessage, xTicksToWait );
    2a02:	a8 01       	movw	r20, r16
    2a04:	02 c0       	rjmp	.+4      	; 0x2a0a <xTimerGenericCommand+0x48>
            }
            else
            {
                xReturn = xQueueSendToBack( xTimerQueue, &xMessage, tmrNO_DELAY );
    2a06:	40 e0       	ldi	r20, 0x00	; 0
    2a08:	50 e0       	ldi	r21, 0x00	; 0
    2a0a:	be 01       	movw	r22, r28
    2a0c:	6f 5f       	subi	r22, 0xFF	; 255
    2a0e:	7f 4f       	sbci	r23, 0xFF	; 255
    2a10:	cf 01       	movw	r24, r30
    2a12:	0e 94 69 0c 	call	0x18d2	; 0x18d2 <xQueueGenericSend>
    2a16:	0a c0       	rjmp	.+20     	; 0x2a2c <xTimerGenericCommand+0x6a>
            }
        }
        else
        {
            xReturn = xQueueSendToBackFromISR( xTimerQueue, &xMessage, pxHigherPriorityTaskWoken );
    2a18:	20 e0       	ldi	r18, 0x00	; 0
    2a1a:	af 01       	movw	r20, r30
    2a1c:	be 01       	movw	r22, r28
    2a1e:	6f 5f       	subi	r22, 0xFF	; 255
    2a20:	7f 4f       	sbci	r23, 0xFF	; 255
    2a22:	cd 01       	movw	r24, r26
    2a24:	0e 94 ff 0c 	call	0x19fe	; 0x19fe <xQueueGenericSendFromISR>
    2a28:	01 c0       	rjmp	.+2      	; 0x2a2c <xTimerGenericCommand+0x6a>
}
/*-----------------------------------------------------------*/

BaseType_t xTimerGenericCommand( TimerHandle_t xTimer, const BaseType_t xCommandID, const TickType_t xOptionalValue, BaseType_t * const pxHigherPriorityTaskWoken, const TickType_t xTicksToWait )
{
BaseType_t xReturn = pdFAIL;
    2a2a:	80 e0       	ldi	r24, 0x00	; 0
    {
        mtCOVERAGE_TEST_MARKER();
    }

    return xReturn;
}
    2a2c:	0f 90       	pop	r0
    2a2e:	0f 90       	pop	r0
    2a30:	0f 90       	pop	r0
    2a32:	0f 90       	pop	r0
    2a34:	0f 90       	pop	r0
    2a36:	df 91       	pop	r29
    2a38:	cf 91       	pop	r28
    2a3a:	1f 91       	pop	r17
    2a3c:	0f 91       	pop	r16
    2a3e:	08 95       	ret

00002a40 <prvSwitchTimerLists>:
    }
}
/*-----------------------------------------------------------*/

static void prvSwitchTimerLists( void )
{
    2a40:	ef 92       	push	r14
    2a42:	ff 92       	push	r15
    2a44:	0f 93       	push	r16
    2a46:	1f 93       	push	r17
    2a48:	cf 93       	push	r28
    2a4a:	df 93       	push	r29

    /* The tick count has overflowed.  The timer lists must be switched.
    If there are any timers still referenced from the current timer list
    then they must have expired and should be processed before the lists
    are switched. */
    while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
    2a4c:	e0 91 da 03 	lds	r30, 0x03DA	; 0x8003da <pxCurrentTimerList>
    2a50:	f0 91 db 03 	lds	r31, 0x03DB	; 0x8003db <pxCurrentTimerList+0x1>
    2a54:	80 81       	ld	r24, Z
    2a56:	88 23       	and	r24, r24
    2a58:	89 f1       	breq	.+98     	; 0x2abc <prvSwitchTimerLists+0x7c>
    {
        xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
    2a5a:	05 80       	ldd	r0, Z+5	; 0x05
    2a5c:	f6 81       	ldd	r31, Z+6	; 0x06
    2a5e:	e0 2d       	mov	r30, r0
    2a60:	e0 80       	ld	r14, Z
    2a62:	f1 80       	ldd	r15, Z+1	; 0x01

        /* Remove the timer from the list. */
        pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList ); /*lint !e9087 !e9079 void * is used as this macro is used with tasks and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    2a64:	c6 81       	ldd	r28, Z+6	; 0x06
    2a66:	d7 81       	ldd	r29, Z+7	; 0x07
        ( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
    2a68:	8e 01       	movw	r16, r28
    2a6a:	0e 5f       	subi	r16, 0xFE	; 254
    2a6c:	1f 4f       	sbci	r17, 0xFF	; 255
    2a6e:	c8 01       	movw	r24, r16
    2a70:	0e 94 cb 09 	call	0x1396	; 0x1396 <uxListRemove>
        traceTIMER_EXPIRED( pxTimer );

        /* Execute its callback, then send a command to restart the timer if
        it is an auto-reload timer.  It cannot be restarted here as the lists
        have not yet been switched. */
        pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
    2a74:	e8 89       	ldd	r30, Y+16	; 0x10
    2a76:	f9 89       	ldd	r31, Y+17	; 0x11
    2a78:	ce 01       	movw	r24, r28
    2a7a:	09 95       	icall

        if( ( pxTimer->ucStatus & tmrSTATUS_IS_AUTORELOAD ) != 0 )
    2a7c:	8a 89       	ldd	r24, Y+18	; 0x12
    2a7e:	82 ff       	sbrs	r24, 2
    2a80:	e5 cf       	rjmp	.-54     	; 0x2a4c <prvSwitchTimerLists+0xc>
            the timer going into the same timer list then it has already expired
            and the timer should be re-inserted into the current list so it is
            processed again within this loop.  Otherwise a command should be sent
            to restart the timer to ensure it is only inserted into a list after
            the lists have been swapped. */
            xReloadTime = ( xNextExpireTime + pxTimer->xTimerPeriodInTicks );
    2a82:	8c 85       	ldd	r24, Y+12	; 0x0c
    2a84:	9d 85       	ldd	r25, Y+13	; 0x0d
    2a86:	8e 0d       	add	r24, r14
    2a88:	9f 1d       	adc	r25, r15
            if( xReloadTime > xNextExpireTime )
    2a8a:	e8 16       	cp	r14, r24
    2a8c:	f9 06       	cpc	r15, r25
    2a8e:	60 f4       	brcc	.+24     	; 0x2aa8 <prvSwitchTimerLists+0x68>
            {
                listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xReloadTime );
    2a90:	9b 83       	std	Y+3, r25	; 0x03
    2a92:	8a 83       	std	Y+2, r24	; 0x02
                listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
    2a94:	d9 87       	std	Y+9, r29	; 0x09
    2a96:	c8 87       	std	Y+8, r28	; 0x08
                vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
    2a98:	b8 01       	movw	r22, r16
    2a9a:	80 91 da 03 	lds	r24, 0x03DA	; 0x8003da <pxCurrentTimerList>
    2a9e:	90 91 db 03 	lds	r25, 0x03DB	; 0x8003db <pxCurrentTimerList+0x1>
    2aa2:	0e 94 93 09 	call	0x1326	; 0x1326 <vListInsert>
    2aa6:	d2 cf       	rjmp	.-92     	; 0x2a4c <prvSwitchTimerLists+0xc>
            }
            else
            {
                xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY );
    2aa8:	00 e0       	ldi	r16, 0x00	; 0
    2aaa:	10 e0       	ldi	r17, 0x00	; 0
    2aac:	20 e0       	ldi	r18, 0x00	; 0
    2aae:	30 e0       	ldi	r19, 0x00	; 0
    2ab0:	a7 01       	movw	r20, r14
    2ab2:	60 e0       	ldi	r22, 0x00	; 0
    2ab4:	ce 01       	movw	r24, r28
    2ab6:	0e 94 e1 14 	call	0x29c2	; 0x29c2 <xTimerGenericCommand>
    2aba:	c8 cf       	rjmp	.-112    	; 0x2a4c <prvSwitchTimerLists+0xc>
            mtCOVERAGE_TEST_MARKER();
        }
    }

    pxTemp = pxCurrentTimerList;
    pxCurrentTimerList = pxOverflowTimerList;
    2abc:	80 91 d8 03 	lds	r24, 0x03D8	; 0x8003d8 <pxOverflowTimerList>
    2ac0:	90 91 d9 03 	lds	r25, 0x03D9	; 0x8003d9 <pxOverflowTimerList+0x1>
    2ac4:	90 93 db 03 	sts	0x03DB, r25	; 0x8003db <pxCurrentTimerList+0x1>
    2ac8:	80 93 da 03 	sts	0x03DA, r24	; 0x8003da <pxCurrentTimerList>
    pxOverflowTimerList = pxTemp;
    2acc:	f0 93 d9 03 	sts	0x03D9, r31	; 0x8003d9 <pxOverflowTimerList+0x1>
    2ad0:	e0 93 d8 03 	sts	0x03D8, r30	; 0x8003d8 <pxOverflowTimerList>
}
    2ad4:	df 91       	pop	r29
    2ad6:	cf 91       	pop	r28
    2ad8:	1f 91       	pop	r17
    2ada:	0f 91       	pop	r16
    2adc:	ff 90       	pop	r15
    2ade:	ef 90       	pop	r14
    2ae0:	08 95       	ret

00002ae2 <prvTimerTask>:
    pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
}
/*-----------------------------------------------------------*/

static portTASK_FUNCTION( prvTimerTask, pvParameters )
{
    2ae2:	cf 93       	push	r28
    2ae4:	df 93       	push	r29
    2ae6:	00 d0       	rcall	.+0      	; 0x2ae8 <prvTimerTask+0x6>
    2ae8:	00 d0       	rcall	.+0      	; 0x2aea <prvTimerTask+0x8>
    2aea:	1f 92       	push	r1
    2aec:	cd b7       	in	r28, 0x3d	; 61
    2aee:	de b7       	in	r29, 0x3e	; 62
    the timer with the nearest expiry time will expire.  If there are no
    active timers then just set the next expire time to 0.  That will cause
    this task to unblock when the tick count overflows, at which point the
    timer lists will be switched and the next expiry time can be
    re-assessed.  */
    *pxListWasEmpty = listLIST_IS_EMPTY( pxCurrentTimerList );
    2af0:	e0 91 da 03 	lds	r30, 0x03DA	; 0x8003da <pxCurrentTimerList>
    2af4:	f0 91 db 03 	lds	r31, 0x03DB	; 0x8003db <pxCurrentTimerList+0x1>
    2af8:	d0 80       	ld	r13, Z
    if( *pxListWasEmpty == pdFALSE )
    2afa:	dd 20       	and	r13, r13
    2afc:	31 f0       	breq	.+12     	; 0x2b0a <prvTimerTask+0x28>
    {
        xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
    2afe:	05 80       	ldd	r0, Z+5	; 0x05
    2b00:	f6 81       	ldd	r31, Z+6	; 0x06
    2b02:	e0 2d       	mov	r30, r0
    2b04:	e0 80       	ld	r14, Z
    2b06:	f1 80       	ldd	r15, Z+1	; 0x01
    2b08:	02 c0       	rjmp	.+4      	; 0x2b0e <prvTimerTask+0x2c>
    }
    else
    {
        /* Ensure the task unblocks when the tick count rolls over. */
        xNextExpireTime = ( TickType_t ) 0U;
    2b0a:	e1 2c       	mov	r14, r1
    2b0c:	f1 2c       	mov	r15, r1
static void prvProcessTimerOrBlockTask( const TickType_t xNextExpireTime, BaseType_t xListWasEmpty )
{
TickType_t xTimeNow;
BaseType_t xTimerListsWereSwitched;

    vTaskSuspendAll();
    2b0e:	0e 94 e9 10 	call	0x21d2	; 0x21d2 <vTaskSuspendAll>
static TickType_t prvSampleTimeNow( BaseType_t * const pxTimerListsWereSwitched )
{
TickType_t xTimeNow;
PRIVILEGED_DATA static TickType_t xLastTime = ( TickType_t ) 0U; /*lint !e956 Variable is only accessible to one task. */

    xTimeNow = xTaskGetTickCount();
    2b12:	0e 94 ef 10 	call	0x21de	; 0x21de <xTaskGetTickCount>
    2b16:	8c 01       	movw	r16, r24

    if( xTimeNow < xLastTime )
    2b18:	80 91 d2 03 	lds	r24, 0x03D2	; 0x8003d2 <xLastTime.2412>
    2b1c:	90 91 d3 03 	lds	r25, 0x03D3	; 0x8003d3 <xLastTime.2412+0x1>
    2b20:	08 17       	cp	r16, r24
    2b22:	19 07       	cpc	r17, r25
    2b24:	20 f4       	brcc	.+8      	; 0x2b2e <prvTimerTask+0x4c>
    {
        prvSwitchTimerLists();
    2b26:	0e 94 20 15 	call	0x2a40	; 0x2a40 <prvSwitchTimerLists>
        *pxTimerListsWereSwitched = pdTRUE;
    2b2a:	81 e0       	ldi	r24, 0x01	; 1
    2b2c:	01 c0       	rjmp	.+2      	; 0x2b30 <prvTimerTask+0x4e>
    }
    else
    {
        *pxTimerListsWereSwitched = pdFALSE;
    2b2e:	80 e0       	ldi	r24, 0x00	; 0
    }

    xLastTime = xTimeNow;
    2b30:	10 93 d3 03 	sts	0x03D3, r17	; 0x8003d3 <xLastTime.2412+0x1>
    2b34:	00 93 d2 03 	sts	0x03D2, r16	; 0x8003d2 <xLastTime.2412>
        has expired or not.  If obtaining the time causes the lists to switch
        then don't process this timer as any timers that remained in the list
        when the lists were switched will have been processed within the
        prvSampleTimeNow() function. */
        xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
        if( xTimerListsWereSwitched == pdFALSE )
    2b38:	81 11       	cpse	r24, r1
    2b3a:	55 c0       	rjmp	.+170    	; 0x2be6 <prvTimerTask+0x104>
        {
            /* The tick count has not overflowed, has the timer expired? */
            if( ( xListWasEmpty == pdFALSE ) && ( xNextExpireTime <= xTimeNow ) )
    2b3c:	dd 20       	and	r13, r13
    2b3e:	d9 f1       	breq	.+118    	; 0x2bb6 <prvTimerTask+0xd4>
    2b40:	0e 15       	cp	r16, r14
    2b42:	1f 05       	cpc	r17, r15
    2b44:	08 f4       	brcc	.+2      	; 0x2b48 <prvTimerTask+0x66>
    2b46:	3e c0       	rjmp	.+124    	; 0x2bc4 <prvTimerTask+0xe2>
            {
                ( void ) xTaskResumeAll();
    2b48:	0e 94 a5 11 	call	0x234a	; 0x234a <xTaskResumeAll>
/*-----------------------------------------------------------*/

static void prvProcessExpiredTimer( const TickType_t xNextExpireTime, const TickType_t xTimeNow )
{
BaseType_t xResult;
Timer_t * const pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList ); /*lint !e9087 !e9079 void * is used as this macro is used with tasks and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    2b4c:	e0 91 da 03 	lds	r30, 0x03DA	; 0x8003da <pxCurrentTimerList>
    2b50:	f0 91 db 03 	lds	r31, 0x03DB	; 0x8003db <pxCurrentTimerList+0x1>
    2b54:	05 80       	ldd	r0, Z+5	; 0x05
    2b56:	f6 81       	ldd	r31, Z+6	; 0x06
    2b58:	e0 2d       	mov	r30, r0
    2b5a:	c6 80       	ldd	r12, Z+6	; 0x06
    2b5c:	d7 80       	ldd	r13, Z+7	; 0x07

    /* Remove the timer from the list of active timers.  A check has already
    been performed to ensure the list is not empty. */
    ( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
    2b5e:	c6 01       	movw	r24, r12
    2b60:	02 96       	adiw	r24, 0x02	; 2
    2b62:	0e 94 cb 09 	call	0x1396	; 0x1396 <uxListRemove>
    traceTIMER_EXPIRED( pxTimer );

    /* If the timer is an auto reload timer then calculate the next
    expiry time and re-insert the timer in the list of active timers. */
    if( ( pxTimer->ucStatus & tmrSTATUS_IS_AUTORELOAD ) != 0 )
    2b66:	d6 01       	movw	r26, r12
    2b68:	52 96       	adiw	r26, 0x12	; 18
    2b6a:	8c 91       	ld	r24, X
    2b6c:	52 97       	sbiw	r26, 0x12	; 18
    2b6e:	82 ff       	sbrs	r24, 2
    2b70:	17 c0       	rjmp	.+46     	; 0x2ba0 <prvTimerTask+0xbe>
    {
        /* The timer is inserted into a list using a time relative to anything
        other than the current time.  It will therefore be inserted into the
        correct list relative to the time this task thinks it is now. */
        if( prvInsertTimerInActiveList( pxTimer, ( xNextExpireTime + pxTimer->xTimerPeriodInTicks ), xTimeNow, xNextExpireTime ) != pdFALSE )
    2b72:	1c 96       	adiw	r26, 0x0c	; 12
    2b74:	6d 91       	ld	r22, X+
    2b76:	7c 91       	ld	r23, X
    2b78:	1d 97       	sbiw	r26, 0x0d	; 13
    2b7a:	6e 0d       	add	r22, r14
    2b7c:	7f 1d       	adc	r23, r15
    2b7e:	97 01       	movw	r18, r14
    2b80:	a8 01       	movw	r20, r16
    2b82:	c6 01       	movw	r24, r12
    2b84:	0e 94 97 14 	call	0x292e	; 0x292e <prvInsertTimerInActiveList>
    2b88:	88 23       	and	r24, r24
    2b8a:	69 f0       	breq	.+26     	; 0x2ba6 <prvTimerTask+0xc4>
        {
            /* The timer expired before it was added to the active timer
            list.  Reload it now.  */
            xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY );
    2b8c:	00 e0       	ldi	r16, 0x00	; 0
    2b8e:	10 e0       	ldi	r17, 0x00	; 0
    2b90:	20 e0       	ldi	r18, 0x00	; 0
    2b92:	30 e0       	ldi	r19, 0x00	; 0
    2b94:	a7 01       	movw	r20, r14
    2b96:	60 e0       	ldi	r22, 0x00	; 0
    2b98:	c6 01       	movw	r24, r12
    2b9a:	0e 94 e1 14 	call	0x29c2	; 0x29c2 <xTimerGenericCommand>
    2b9e:	03 c0       	rjmp	.+6      	; 0x2ba6 <prvTimerTask+0xc4>
            mtCOVERAGE_TEST_MARKER();
        }
    }
    else
    {
        pxTimer->ucStatus &= ~tmrSTATUS_IS_ACTIVE;
    2ba0:	8e 7f       	andi	r24, 0xFE	; 254
    2ba2:	f6 01       	movw	r30, r12
    2ba4:	82 8b       	std	Z+18, r24	; 0x12
        mtCOVERAGE_TEST_MARKER();
    }

    /* Call the timer callback. */
    pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
    2ba6:	d6 01       	movw	r26, r12
    2ba8:	50 96       	adiw	r26, 0x10	; 16
    2baa:	ed 91       	ld	r30, X+
    2bac:	fc 91       	ld	r31, X
    2bae:	51 97       	sbiw	r26, 0x11	; 17
    2bb0:	c6 01       	movw	r24, r12
    2bb2:	09 95       	icall
    2bb4:	1e c0       	rjmp	.+60     	; 0x2bf2 <prvTimerTask+0x110>
                case when the current timer list is empty. */
                if( xListWasEmpty != pdFALSE )
                {
                    /* The current timer list is empty - is the overflow list
                    also empty? */
                    xListWasEmpty = listLIST_IS_EMPTY( pxOverflowTimerList );
    2bb6:	e0 91 d8 03 	lds	r30, 0x03D8	; 0x8003d8 <pxOverflowTimerList>
    2bba:	f0 91 d9 03 	lds	r31, 0x03D9	; 0x8003d9 <pxOverflowTimerList+0x1>
    2bbe:	80 81       	ld	r24, Z
    2bc0:	41 e0       	ldi	r20, 0x01	; 1
    2bc2:	81 11       	cpse	r24, r1
        prvSampleTimeNow() function. */
        xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
        if( xTimerListsWereSwitched == pdFALSE )
        {
            /* The tick count has not overflowed, has the timer expired? */
            if( ( xListWasEmpty == pdFALSE ) && ( xNextExpireTime <= xTimeNow ) )
    2bc4:	40 e0       	ldi	r20, 0x00	; 0
                    /* The current timer list is empty - is the overflow list
                    also empty? */
                    xListWasEmpty = listLIST_IS_EMPTY( pxOverflowTimerList );
                }

                vQueueWaitForMessageRestricted( xTimerQueue, ( xNextExpireTime - xTimeNow ), xListWasEmpty );
    2bc6:	b7 01       	movw	r22, r14
    2bc8:	60 1b       	sub	r22, r16
    2bca:	71 0b       	sbc	r23, r17
    2bcc:	80 91 d6 03 	lds	r24, 0x03D6	; 0x8003d6 <xTimerQueue>
    2bd0:	90 91 d7 03 	lds	r25, 0x03D7	; 0x8003d7 <xTimerQueue+0x1>
    2bd4:	0e 94 a5 0e 	call	0x1d4a	; 0x1d4a <vQueueWaitForMessageRestricted>

                if( xTaskResumeAll() == pdFALSE )
    2bd8:	0e 94 a5 11 	call	0x234a	; 0x234a <xTaskResumeAll>
    2bdc:	81 11       	cpse	r24, r1
    2bde:	09 c0       	rjmp	.+18     	; 0x2bf2 <prvTimerTask+0x110>
                {
                    /* Yield to wait for either a command to arrive, or the
                    block time to expire.  If a command arrived between the
                    critical section being exited and this yield then the yield
                    will not cause the task to block. */
                    portYIELD_WITHIN_API();
    2be0:	0e 94 93 0a 	call	0x1526	; 0x1526 <vPortYield>
    2be4:	06 c0       	rjmp	.+12     	; 0x2bf2 <prvTimerTask+0x110>
                }
            }
        }
        else
        {
            ( void ) xTaskResumeAll();
    2be6:	0e 94 a5 11 	call	0x234a	; 0x234a <xTaskResumeAll>
    2bea:	03 c0       	rjmp	.+6      	; 0x2bf2 <prvTimerTask+0x110>
        }
        #endif /* INCLUDE_xTimerPendFunctionCall */

        /* Commands that are positive are timer commands rather than pended
        function calls. */
        if( xMessage.xMessageID >= ( BaseType_t ) 0 )
    2bec:	89 81       	ldd	r24, Y+1	; 0x01
    2bee:	87 ff       	sbrs	r24, 7
    2bf0:	0e c0       	rjmp	.+28     	; 0x2c0e <prvTimerTask+0x12c>
DaemonTaskMessage_t xMessage;
Timer_t *pxTimer;
BaseType_t xTimerListsWereSwitched, xResult;
TickType_t xTimeNow;

    while( xQueueReceive( xTimerQueue, &xMessage, tmrNO_DELAY ) != pdFAIL ) /*lint !e603 xMessage does not have to be initialised as it is passed out, not in, and it is not used unless xQueueReceive() returns pdTRUE. */
    2bf2:	40 e0       	ldi	r20, 0x00	; 0
    2bf4:	50 e0       	ldi	r21, 0x00	; 0
    2bf6:	be 01       	movw	r22, r28
    2bf8:	6f 5f       	subi	r22, 0xFF	; 255
    2bfa:	7f 4f       	sbci	r23, 0xFF	; 255
    2bfc:	80 91 d6 03 	lds	r24, 0x03D6	; 0x8003d6 <xTimerQueue>
    2c00:	90 91 d7 03 	lds	r25, 0x03D7	; 0x8003d7 <xTimerQueue+0x1>
    2c04:	0e 94 51 0d 	call	0x1aa2	; 0x1aa2 <xQueueReceive>
    2c08:	81 11       	cpse	r24, r1
    2c0a:	f0 cf       	rjmp	.-32     	; 0x2bec <prvTimerTask+0x10a>
    2c0c:	71 cf       	rjmp	.-286    	; 0x2af0 <prvTimerTask+0xe>
        function calls. */
        if( xMessage.xMessageID >= ( BaseType_t ) 0 )
        {
            /* The messages uses the xTimerParameters member to work on a
            software timer. */
            pxTimer = xMessage.u.xTimerParameters.pxTimer;
    2c0e:	ec 80       	ldd	r14, Y+4	; 0x04
    2c10:	fd 80       	ldd	r15, Y+5	; 0x05

        if( listIS_CONTAINED_WITHIN( NULL, &( pxTimer->xTimerListItem ) ) == pdFALSE ) /*lint !e961. The cast is only redundant when NULL is passed into the macro. */
    2c12:	f7 01       	movw	r30, r14
    2c14:	82 85       	ldd	r24, Z+10	; 0x0a
    2c16:	93 85       	ldd	r25, Z+11	; 0x0b
    2c18:	89 2b       	or	r24, r25
    2c1a:	21 f0       	breq	.+8      	; 0x2c24 <prvTimerTask+0x142>
            {
                /* The timer is in a list, remove it. */
                ( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
    2c1c:	c7 01       	movw	r24, r14
    2c1e:	02 96       	adiw	r24, 0x02	; 2
    2c20:	0e 94 cb 09 	call	0x1396	; 0x1396 <uxListRemove>
static TickType_t prvSampleTimeNow( BaseType_t * const pxTimerListsWereSwitched )
{
TickType_t xTimeNow;
PRIVILEGED_DATA static TickType_t xLastTime = ( TickType_t ) 0U; /*lint !e956 Variable is only accessible to one task. */

    xTimeNow = xTaskGetTickCount();
    2c24:	0e 94 ef 10 	call	0x21de	; 0x21de <xTaskGetTickCount>
    2c28:	6c 01       	movw	r12, r24

    if( xTimeNow < xLastTime )
    2c2a:	80 91 d2 03 	lds	r24, 0x03D2	; 0x8003d2 <xLastTime.2412>
    2c2e:	90 91 d3 03 	lds	r25, 0x03D3	; 0x8003d3 <xLastTime.2412+0x1>
    2c32:	c8 16       	cp	r12, r24
    2c34:	d9 06       	cpc	r13, r25
    2c36:	10 f4       	brcc	.+4      	; 0x2c3c <prvTimerTask+0x15a>
    {
        prvSwitchTimerLists();
    2c38:	0e 94 20 15 	call	0x2a40	; 0x2a40 <prvSwitchTimerLists>
    else
    {
        *pxTimerListsWereSwitched = pdFALSE;
    }

    xLastTime = xTimeNow;
    2c3c:	d0 92 d3 03 	sts	0x03D3, r13	; 0x8003d3 <xLastTime.2412+0x1>
    2c40:	c0 92 d2 03 	sts	0x03D2, r12	; 0x8003d2 <xLastTime.2412>
            possibility of a higher priority task adding a message to the message
            queue with a time that is ahead of the timer daemon task (because it
            pre-empted the timer daemon task after the xTimeNow value was set). */
            xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );

            switch( xMessage.xMessageID )
    2c44:	e9 81       	ldd	r30, Y+1	; 0x01
    2c46:	0e 2e       	mov	r0, r30
    2c48:	00 0c       	add	r0, r0
    2c4a:	ff 0b       	sbc	r31, r31
    2c4c:	ea 30       	cpi	r30, 0x0A	; 10
    2c4e:	f1 05       	cpc	r31, r1
    2c50:	80 f6       	brcc	.-96     	; 0x2bf2 <prvTimerTask+0x110>
    2c52:	ec 5c       	subi	r30, 0xCC	; 204
    2c54:	ff 4f       	sbci	r31, 0xFF	; 255
    2c56:	d7 01       	movw	r26, r14
    2c58:	52 96       	adiw	r26, 0x12	; 18
    2c5a:	8c 91       	ld	r24, X
    2c5c:	0c 94 e3 23 	jmp	0x47c6	; 0x47c6 <__tablejump2__>
                case tmrCOMMAND_START_FROM_ISR :
                case tmrCOMMAND_RESET :
                case tmrCOMMAND_RESET_FROM_ISR :
                case tmrCOMMAND_START_DONT_TRACE :
                    /* Start or restart a timer. */
                    pxTimer->ucStatus |= tmrSTATUS_IS_ACTIVE;
    2c60:	81 60       	ori	r24, 0x01	; 1
    2c62:	f7 01       	movw	r30, r14
    2c64:	82 8b       	std	Z+18, r24	; 0x12
                    if( prvInsertTimerInActiveList( pxTimer,  xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, xTimeNow, xMessage.u.xTimerParameters.xMessageValue ) != pdFALSE )
    2c66:	2a 81       	ldd	r18, Y+2	; 0x02
    2c68:	3b 81       	ldd	r19, Y+3	; 0x03
    2c6a:	64 85       	ldd	r22, Z+12	; 0x0c
    2c6c:	75 85       	ldd	r23, Z+13	; 0x0d
    2c6e:	62 0f       	add	r22, r18
    2c70:	73 1f       	adc	r23, r19
    2c72:	a6 01       	movw	r20, r12
    2c74:	c7 01       	movw	r24, r14
    2c76:	0e 94 97 14 	call	0x292e	; 0x292e <prvInsertTimerInActiveList>
    2c7a:	88 23       	and	r24, r24
    2c7c:	09 f4       	brne	.+2      	; 0x2c80 <prvTimerTask+0x19e>
    2c7e:	b9 cf       	rjmp	.-142    	; 0x2bf2 <prvTimerTask+0x110>
                    {
                        /* The timer expired before it was added to the active
                        timer list.  Process it now. */
                        pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
    2c80:	d7 01       	movw	r26, r14
    2c82:	50 96       	adiw	r26, 0x10	; 16
    2c84:	ed 91       	ld	r30, X+
    2c86:	fc 91       	ld	r31, X
    2c88:	51 97       	sbiw	r26, 0x11	; 17
    2c8a:	c7 01       	movw	r24, r14
    2c8c:	09 95       	icall
                        traceTIMER_EXPIRED( pxTimer );

                        if( ( pxTimer->ucStatus & tmrSTATUS_IS_AUTORELOAD ) != 0 )
    2c8e:	f7 01       	movw	r30, r14
    2c90:	82 89       	ldd	r24, Z+18	; 0x12
    2c92:	82 ff       	sbrs	r24, 2
    2c94:	ae cf       	rjmp	.-164    	; 0x2bf2 <prvTimerTask+0x110>
                        {
                            xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, NULL, tmrNO_DELAY );
    2c96:	4a 81       	ldd	r20, Y+2	; 0x02
    2c98:	5b 81       	ldd	r21, Y+3	; 0x03
    2c9a:	84 85       	ldd	r24, Z+12	; 0x0c
    2c9c:	95 85       	ldd	r25, Z+13	; 0x0d
    2c9e:	48 0f       	add	r20, r24
    2ca0:	59 1f       	adc	r21, r25
    2ca2:	00 e0       	ldi	r16, 0x00	; 0
    2ca4:	10 e0       	ldi	r17, 0x00	; 0
    2ca6:	20 e0       	ldi	r18, 0x00	; 0
    2ca8:	30 e0       	ldi	r19, 0x00	; 0
    2caa:	60 e0       	ldi	r22, 0x00	; 0
    2cac:	c7 01       	movw	r24, r14
    2cae:	0e 94 e1 14 	call	0x29c2	; 0x29c2 <xTimerGenericCommand>
    2cb2:	9f cf       	rjmp	.-194    	; 0x2bf2 <prvTimerTask+0x110>
                    pxTimer->ucStatus &= ~tmrSTATUS_IS_ACTIVE;
                    break;

                case tmrCOMMAND_CHANGE_PERIOD :
                case tmrCOMMAND_CHANGE_PERIOD_FROM_ISR :
                    pxTimer->ucStatus |= tmrSTATUS_IS_ACTIVE;
    2cb4:	81 60       	ori	r24, 0x01	; 1
    2cb6:	f7 01       	movw	r30, r14
    2cb8:	82 8b       	std	Z+18, r24	; 0x12
                    pxTimer->xTimerPeriodInTicks = xMessage.u.xTimerParameters.xMessageValue;
    2cba:	6a 81       	ldd	r22, Y+2	; 0x02
    2cbc:	7b 81       	ldd	r23, Y+3	; 0x03
    2cbe:	75 87       	std	Z+13, r23	; 0x0d
    2cc0:	64 87       	std	Z+12, r22	; 0x0c
                    be longer or shorter than the old one.  The command time is
                    therefore set to the current time, and as the period cannot
                    be zero the next expiry time can only be in the future,
                    meaning (unlike for the xTimerStart() case above) there is
                    no fail case that needs to be handled here. */
                    ( void ) prvInsertTimerInActiveList( pxTimer, ( xTimeNow + pxTimer->xTimerPeriodInTicks ), xTimeNow, xTimeNow );
    2cc2:	6c 0d       	add	r22, r12
    2cc4:	7d 1d       	adc	r23, r13
    2cc6:	96 01       	movw	r18, r12
    2cc8:	a6 01       	movw	r20, r12
    2cca:	c7 01       	movw	r24, r14
    2ccc:	0e 94 97 14 	call	0x292e	; 0x292e <prvInsertTimerInActiveList>
    2cd0:	90 cf       	rjmp	.-224    	; 0x2bf2 <prvTimerTask+0x110>
                    #if ( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
                    {
                    /* The timer has already been removed from the active list,
                    just free up the memory if the memory was dynamically
                    allocated. */
                        if( ( pxTimer->ucStatus & tmrSTATUS_IS_STATICALLY_ALLOCATED ) == ( uint8_t ) 0 )
    2cd2:	81 fd       	sbrc	r24, 1
    2cd4:	04 c0       	rjmp	.+8      	; 0x2cde <prvTimerTask+0x1fc>
                        {
                            vPortFree( pxTimer );
    2cd6:	c7 01       	movw	r24, r14
    2cd8:	0e 94 4f 09 	call	0x129e	; 0x129e <vPortFree>
    2cdc:	8a cf       	rjmp	.-236    	; 0x2bf2 <prvTimerTask+0x110>
                        }
                        else
                        {
                            pxTimer->ucStatus &= ~tmrSTATUS_IS_ACTIVE;
    2cde:	8e 7f       	andi	r24, 0xFE	; 254
    2ce0:	d7 01       	movw	r26, r14
    2ce2:	52 96       	adiw	r26, 0x12	; 18
    2ce4:	8c 93       	st	X, r24
    2ce6:	85 cf       	rjmp	.-246    	; 0x2bf2 <prvTimerTask+0x110>

00002ce8 <initVariant>:
{
#if defined(USBCON)
    USBDevice.attach();
#endif

    setup();        // the normal Arduino setup() function is run here.
    2ce8:	0e 94 b1 05 	call	0xb62	; 0xb62 <setup>
    vTaskStartScheduler(); // initialise and run the freeRTOS scheduler. Execution should never return here.
    2cec:	0e 94 bb 10 	call	0x2176	; 0x2176 <vTaskStartScheduler>
    2cf0:	08 95       	ret

00002cf2 <vApplicationIdleHook>:
 */
void vApplicationIdleHook( void ) __attribute__((weak));

void vApplicationIdleHook( void )
{
    loop();        // the normal Arduino loop() function is run here.
    2cf2:	0e 94 38 06 	call	0xc70	; 0xc70 <loop>
    if (serialEventRun) serialEventRun();
    2cf6:	88 e2       	ldi	r24, 0x28	; 40
    2cf8:	9d e1       	ldi	r25, 0x1D	; 29
    2cfa:	89 2b       	or	r24, r25
    2cfc:	11 f0       	breq	.+4      	; 0x2d02 <vApplicationIdleHook+0x10>
    2cfe:	0c 94 28 1d 	jmp	0x3a50	; 0x3a50 <_Z14serialEventRunv>
    2d02:	08 95       	ret

00002d04 <vApplicationMallocFailedHook>:
#elif defined(__AVR_ATmega644P__) || defined(__AVR_ATmega644PA__) || defined(__AVR_ATmega1284P__) || defined(__AVR_ATmega1284PA__) // Seeed Goldilocks with 1284p
    DDRB  |= _BV(DDB7);
    PORTB |= _BV(PORTB7);       // Main (red PB7) LED on. Main LED on.

#elif defined(__AVR_ATmega328P__) || defined(__AVR_ATmega168__) || defined(__AVR_ATmega8__) // assume we're using an Arduino Uno with 328p
    DDRB  |= _BV(DDB5);
    2d04:	25 9a       	sbi	0x04, 5	; 4
    PORTB |= _BV(PORTB5);       // Main (red PB5) LED on. Main LED on.
    2d06:	2d 9a       	sbi	0x05, 5	; 5
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    2d08:	2f ef       	ldi	r18, 0xFF	; 255
    2d0a:	80 e7       	ldi	r24, 0x70	; 112
    2d0c:	92 e0       	ldi	r25, 0x02	; 2
    2d0e:	21 50       	subi	r18, 0x01	; 1
    2d10:	80 40       	sbci	r24, 0x00	; 0
    2d12:	90 40       	sbci	r25, 0x00	; 0
    2d14:	e1 f7       	brne	.-8      	; 0x2d0e <vApplicationMallocFailedHook+0xa>
    2d16:	00 c0       	rjmp	.+0      	; 0x2d18 <vApplicationMallocFailedHook+0x14>
    2d18:	00 00       	nop

#elif defined(__AVR_ATmega644P__) || defined(__AVR_ATmega644PA__) || defined(__AVR_ATmega1284P__) || defined(__AVR_ATmega1284PA__) // Seeed Goldilocks with 1284p
        PINB  |= _BV(PINB7);       // Main (red PB7) LED toggle. Main LED fast blink.

#elif defined(__AVR_ATmega328P__) || defined(__AVR_ATmega168__) || defined(__AVR_ATmega8__) // assume we're using an Arduino Uno with 328p
        PINB  |= _BV(PINB5);       // Main (red PB5) LED toggle. Main LED fast blink.
    2d1a:	1d 9a       	sbi	0x03, 5	; 3
    2d1c:	f5 cf       	rjmp	.-22     	; 0x2d08 <vApplicationMallocFailedHook+0x4>

00002d1e <vApplicationStackOverflowHook>:
#elif defined(__AVR_ATmega644P__) || defined(__AVR_ATmega644PA__) || defined(__AVR_ATmega1284P__) || defined(__AVR_ATmega1284PA__) // Seeed Goldilocks with 1284p
    DDRB  |= _BV(DDB7);
    PORTB |= _BV(PORTB7);       // Main (red PB7) LED on. Main LED on.

#elif defined(__AVR_ATmega328P__) || defined(__AVR_ATmega168__) || defined(__AVR_ATmega8__) // assume we're using an Arduino Uno with 328p
    DDRB  |= _BV(DDB5);
    2d1e:	25 9a       	sbi	0x04, 5	; 4
    PORTB |= _BV(PORTB5);       // Main (red PB5) LED on. Main LED on.
    2d20:	2d 9a       	sbi	0x05, 5	; 5
    2d22:	2f ef       	ldi	r18, 0xFF	; 255
    2d24:	87 ea       	ldi	r24, 0xA7	; 167
    2d26:	91 e6       	ldi	r25, 0x61	; 97
    2d28:	21 50       	subi	r18, 0x01	; 1
    2d2a:	80 40       	sbci	r24, 0x00	; 0
    2d2c:	90 40       	sbci	r25, 0x00	; 0
    2d2e:	e1 f7       	brne	.-8      	; 0x2d28 <vApplicationStackOverflowHook+0xa>
    2d30:	00 c0       	rjmp	.+0      	; 0x2d32 <vApplicationStackOverflowHook+0x14>
    2d32:	00 00       	nop

#elif defined(__AVR_ATmega644P__) || defined(__AVR_ATmega644PA__) || defined(__AVR_ATmega1284P__) || defined(__AVR_ATmega1284PA__) // Seeed Goldilocks with 1284p
        PINB  |= _BV(PINB7);       // Main (red PB7) LED toggle. Main LED slow blink.

#elif defined(__AVR_ATmega328P__) || defined(__AVR_ATmega168__) || defined(__AVR_ATmega8__) // assume we're using an Arduino Uno with 328p
        PINB  |= _BV(PINB5);       // Main (red PB5) LED toggle. Main LED slow blink.
    2d34:	1d 9a       	sbi	0x03, 5	; 3
    2d36:	f5 cf       	rjmp	.-22     	; 0x2d22 <vApplicationStackOverflowHook+0x4>

00002d38 <_ZN9MD_TCS23010initialiseEv>:
  }
  FreqCount.end();      // stop
  DUMP("VALUE ", FreqCount.read());

  return(FreqCount.read() * _readDiv);
}
    2d38:	0f 93       	push	r16
    2d3a:	1f 93       	push	r17
    2d3c:	fc 01       	movw	r30, r24
    2d3e:	8f ef       	ldi	r24, 0xFF	; 255
    2d40:	80 83       	st	Z, r24
    2d42:	81 83       	std	Z+1, r24	; 0x01
    2d44:	82 83       	std	Z+2, r24	; 0x02
    2d46:	83 83       	std	Z+3, r24	; 0x03
    2d48:	84 83       	std	Z+4, r24	; 0x04
    2d4a:	8a e0       	ldi	r24, 0x0A	; 10
    2d4c:	85 83       	std	Z+5, r24	; 0x05
    2d4e:	16 82       	std	Z+6, r1	; 0x06
    2d50:	df 01       	movw	r26, r30
    2d52:	17 96       	adiw	r26, 0x07	; 7
    2d54:	73 96       	adiw	r30, 0x13	; 19
    2d56:	00 e7       	ldi	r16, 0x70	; 112
    2d58:	17 e1       	ldi	r17, 0x17	; 23
    2d5a:	20 e0       	ldi	r18, 0x00	; 0
    2d5c:	30 e0       	ldi	r19, 0x00	; 0
    2d5e:	48 ed       	ldi	r20, 0xD8	; 216
    2d60:	56 ed       	ldi	r21, 0xD6	; 214
    2d62:	60 e0       	ldi	r22, 0x00	; 0
    2d64:	70 e0       	ldi	r23, 0x00	; 0
    2d66:	0d 93       	st	X+, r16
    2d68:	1d 93       	st	X+, r17
    2d6a:	2d 93       	st	X+, r18
    2d6c:	3d 93       	st	X+, r19
    2d6e:	18 96       	adiw	r26, 0x08	; 8
    2d70:	4d 93       	st	X+, r20
    2d72:	5d 93       	st	X+, r21
    2d74:	6d 93       	st	X+, r22
    2d76:	7c 93       	st	X, r23
    2d78:	1b 97       	sbiw	r26, 0x0b	; 11
    2d7a:	ae 17       	cp	r26, r30
    2d7c:	bf 07       	cpc	r27, r31
    2d7e:	99 f7       	brne	.-26     	; 0x2d66 <_ZN9MD_TCS23010initialiseEv+0x2e>
    2d80:	1f 91       	pop	r17
    2d82:	0f 91       	pop	r16
    2d84:	08 95       	ret

00002d86 <_ZN9MD_TCS230C1Ehhh>:
    2d86:	ff 92       	push	r15
    2d88:	0f 93       	push	r16
    2d8a:	1f 93       	push	r17
    2d8c:	cf 93       	push	r28
    2d8e:	df 93       	push	r29
    2d90:	ec 01       	movw	r28, r24
    2d92:	f6 2e       	mov	r15, r22
    2d94:	04 2f       	mov	r16, r20
    2d96:	12 2f       	mov	r17, r18
    2d98:	0e 94 9c 16 	call	0x2d38	; 0x2d38 <_ZN9MD_TCS23010initialiseEv>
    2d9c:	fb 82       	std	Y+3, r15	; 0x03
    2d9e:	0c 83       	std	Y+4, r16	; 0x04
    2da0:	18 83       	st	Y, r17
    2da2:	df 91       	pop	r29
    2da4:	cf 91       	pop	r28
    2da6:	1f 91       	pop	r17
    2da8:	0f 91       	pop	r16
    2daa:	ff 90       	pop	r15
    2dac:	08 95       	ret

00002dae <_ZN9MD_TCS230D1Ev>:
    2dae:	08 95       	ret

00002db0 <_ZN9MD_TCS2309setFilterEh>:
    2db0:	cf 93       	push	r28
    2db2:	df 93       	push	r29
    2db4:	ec 01       	movw	r28, r24
    2db6:	8b 81       	ldd	r24, Y+3	; 0x03
    2db8:	8f 3f       	cpi	r24, 0xFF	; 255
    2dba:	e9 f0       	breq	.+58     	; 0x2df6 <_ZN9MD_TCS2309setFilterEh+0x46>
    2dbc:	9c 81       	ldd	r25, Y+4	; 0x04
    2dbe:	9f 3f       	cpi	r25, 0xFF	; 255
    2dc0:	d1 f0       	breq	.+52     	; 0x2df6 <_ZN9MD_TCS2309setFilterEh+0x46>
    2dc2:	61 30       	cpi	r22, 0x01	; 1
    2dc4:	49 f0       	breq	.+18     	; 0x2dd8 <_ZN9MD_TCS2309setFilterEh+0x28>
    2dc6:	30 f0       	brcs	.+12     	; 0x2dd4 <_ZN9MD_TCS2309setFilterEh+0x24>
    2dc8:	62 30       	cpi	r22, 0x02	; 2
    2dca:	41 f0       	breq	.+16     	; 0x2ddc <_ZN9MD_TCS2309setFilterEh+0x2c>
    2dcc:	63 30       	cpi	r22, 0x03	; 3
    2dce:	99 f4       	brne	.+38     	; 0x2df6 <_ZN9MD_TCS2309setFilterEh+0x46>
    2dd0:	61 e0       	ldi	r22, 0x01	; 1
    2dd2:	09 c0       	rjmp	.+18     	; 0x2de6 <_ZN9MD_TCS2309setFilterEh+0x36>
    2dd4:	60 e0       	ldi	r22, 0x00	; 0
    2dd6:	07 c0       	rjmp	.+14     	; 0x2de6 <_ZN9MD_TCS2309setFilterEh+0x36>
    2dd8:	61 e0       	ldi	r22, 0x01	; 1
    2dda:	01 c0       	rjmp	.+2      	; 0x2dde <_ZN9MD_TCS2309setFilterEh+0x2e>
    2ddc:	60 e0       	ldi	r22, 0x00	; 0
    2dde:	0e 94 48 22 	call	0x4490	; 0x4490 <digitalWrite>
    2de2:	61 e0       	ldi	r22, 0x01	; 1
    2de4:	03 c0       	rjmp	.+6      	; 0x2dec <_ZN9MD_TCS2309setFilterEh+0x3c>
    2de6:	0e 94 48 22 	call	0x4490	; 0x4490 <digitalWrite>
    2dea:	60 e0       	ldi	r22, 0x00	; 0
    2dec:	8c 81       	ldd	r24, Y+4	; 0x04
    2dee:	df 91       	pop	r29
    2df0:	cf 91       	pop	r28
    2df2:	0c 94 48 22 	jmp	0x4490	; 0x4490 <digitalWrite>
    2df6:	df 91       	pop	r29
    2df8:	cf 91       	pop	r28
    2dfa:	08 95       	ret

00002dfc <_ZN9MD_TCS23013setFrequency2Eh>:
    2dfc:	cf 93       	push	r28
    2dfe:	df 93       	push	r29
    2e00:	ec 01       	movw	r28, r24
    2e02:	89 81       	ldd	r24, Y+1	; 0x01
    2e04:	8f 3f       	cpi	r24, 0xFF	; 255
    2e06:	e9 f0       	breq	.+58     	; 0x2e42 <_ZN9MD_TCS23013setFrequency2Eh+0x46>
    2e08:	9a 81       	ldd	r25, Y+2	; 0x02
    2e0a:	9f 3f       	cpi	r25, 0xFF	; 255
    2e0c:	d1 f0       	breq	.+52     	; 0x2e42 <_ZN9MD_TCS23013setFrequency2Eh+0x46>
    2e0e:	61 30       	cpi	r22, 0x01	; 1
    2e10:	49 f0       	breq	.+18     	; 0x2e24 <_ZN9MD_TCS23013setFrequency2Eh+0x28>
    2e12:	30 f0       	brcs	.+12     	; 0x2e20 <_ZN9MD_TCS23013setFrequency2Eh+0x24>
    2e14:	62 30       	cpi	r22, 0x02	; 2
    2e16:	41 f0       	breq	.+16     	; 0x2e28 <_ZN9MD_TCS23013setFrequency2Eh+0x2c>
    2e18:	63 30       	cpi	r22, 0x03	; 3
    2e1a:	99 f4       	brne	.+38     	; 0x2e42 <_ZN9MD_TCS23013setFrequency2Eh+0x46>
    2e1c:	60 e0       	ldi	r22, 0x00	; 0
    2e1e:	09 c0       	rjmp	.+18     	; 0x2e32 <_ZN9MD_TCS23013setFrequency2Eh+0x36>
    2e20:	61 e0       	ldi	r22, 0x01	; 1
    2e22:	03 c0       	rjmp	.+6      	; 0x2e2a <_ZN9MD_TCS23013setFrequency2Eh+0x2e>
    2e24:	61 e0       	ldi	r22, 0x01	; 1
    2e26:	05 c0       	rjmp	.+10     	; 0x2e32 <_ZN9MD_TCS23013setFrequency2Eh+0x36>
    2e28:	60 e0       	ldi	r22, 0x00	; 0
    2e2a:	0e 94 48 22 	call	0x4490	; 0x4490 <digitalWrite>
    2e2e:	61 e0       	ldi	r22, 0x01	; 1
    2e30:	03 c0       	rjmp	.+6      	; 0x2e38 <_ZN9MD_TCS23013setFrequency2Eh+0x3c>
    2e32:	0e 94 48 22 	call	0x4490	; 0x4490 <digitalWrite>
    2e36:	60 e0       	ldi	r22, 0x00	; 0
    2e38:	8a 81       	ldd	r24, Y+2	; 0x02
    2e3a:	df 91       	pop	r29
    2e3c:	cf 91       	pop	r28
    2e3e:	0c 94 48 22 	jmp	0x4490	; 0x4490 <digitalWrite>
    2e42:	df 91       	pop	r29
    2e44:	cf 91       	pop	r28
    2e46:	08 95       	ret

00002e48 <_ZN9MD_TCS2309setEnableEb>:
    2e48:	fc 01       	movw	r30, r24
    2e4a:	20 81       	ld	r18, Z
    2e4c:	2f 3f       	cpi	r18, 0xFF	; 255
    2e4e:	29 f0       	breq	.+10     	; 0x2e5a <_ZN9MD_TCS2309setEnableEb+0x12>
    2e50:	91 e0       	ldi	r25, 0x01	; 1
    2e52:	69 27       	eor	r22, r25
    2e54:	82 2f       	mov	r24, r18
    2e56:	0c 94 48 22 	jmp	0x4490	; 0x4490 <digitalWrite>
    2e5a:	66 23       	and	r22, r22
    2e5c:	19 f0       	breq	.+6      	; 0x2e64 <_ZN9MD_TCS2309setEnableEb+0x1c>
    2e5e:	fc 01       	movw	r30, r24
    2e60:	66 81       	ldd	r22, Z+6	; 0x06
    2e62:	01 c0       	rjmp	.+2      	; 0x2e66 <_ZN9MD_TCS2309setEnableEb+0x1e>
    2e64:	63 e0       	ldi	r22, 0x03	; 3
    2e66:	0c 94 fe 16 	jmp	0x2dfc	; 0x2dfc <_ZN9MD_TCS23013setFrequency2Eh>

00002e6a <_ZN9MD_TCS2305beginEv>:
    2e6a:	cf 93       	push	r28
    2e6c:	df 93       	push	r29
    2e6e:	ec 01       	movw	r28, r24
    2e70:	89 81       	ldd	r24, Y+1	; 0x01
    2e72:	8f 3f       	cpi	r24, 0xFF	; 255
    2e74:	19 f0       	breq	.+6      	; 0x2e7c <_ZN9MD_TCS2305beginEv+0x12>
    2e76:	61 e0       	ldi	r22, 0x01	; 1
    2e78:	0e 94 0c 22 	call	0x4418	; 0x4418 <pinMode>
    2e7c:	8a 81       	ldd	r24, Y+2	; 0x02
    2e7e:	8f 3f       	cpi	r24, 0xFF	; 255
    2e80:	19 f0       	breq	.+6      	; 0x2e88 <_ZN9MD_TCS2305beginEv+0x1e>
    2e82:	61 e0       	ldi	r22, 0x01	; 1
    2e84:	0e 94 0c 22 	call	0x4418	; 0x4418 <pinMode>
    2e88:	8b 81       	ldd	r24, Y+3	; 0x03
    2e8a:	8f 3f       	cpi	r24, 0xFF	; 255
    2e8c:	19 f0       	breq	.+6      	; 0x2e94 <_ZN9MD_TCS2305beginEv+0x2a>
    2e8e:	61 e0       	ldi	r22, 0x01	; 1
    2e90:	0e 94 0c 22 	call	0x4418	; 0x4418 <pinMode>
    2e94:	8c 81       	ldd	r24, Y+4	; 0x04
    2e96:	8f 3f       	cpi	r24, 0xFF	; 255
    2e98:	19 f0       	breq	.+6      	; 0x2ea0 <_ZN9MD_TCS2305beginEv+0x36>
    2e9a:	61 e0       	ldi	r22, 0x01	; 1
    2e9c:	0e 94 0c 22 	call	0x4418	; 0x4418 <pinMode>
    2ea0:	88 81       	ld	r24, Y
    2ea2:	8f 3f       	cpi	r24, 0xFF	; 255
    2ea4:	19 f0       	breq	.+6      	; 0x2eac <_ZN9MD_TCS2305beginEv+0x42>
    2ea6:	61 e0       	ldi	r22, 0x01	; 1
    2ea8:	0e 94 0c 22 	call	0x4418	; 0x4418 <pinMode>
    2eac:	60 e0       	ldi	r22, 0x00	; 0
    2eae:	ce 01       	movw	r24, r28
    2eb0:	0e 94 24 17 	call	0x2e48	; 0x2e48 <_ZN9MD_TCS2309setEnableEb>
    2eb4:	6e 81       	ldd	r22, Y+6	; 0x06
    2eb6:	ce 01       	movw	r24, r28
    2eb8:	df 91       	pop	r29
    2eba:	cf 91       	pop	r28
    2ebc:	0c 94 fe 16 	jmp	0x2dfc	; 0x2dfc <_ZN9MD_TCS23013setFrequency2Eh>

00002ec0 <_ZN9MD_TCS2306getRGBEP9colorData>:
    2ec0:	dc 01       	movw	r26, r24
    2ec2:	fb 01       	movw	r30, r22
    2ec4:	30 97       	sbiw	r30, 0x00	; 0
    2ec6:	59 f0       	breq	.+22     	; 0x2ede <_ZN9MD_TCS2306getRGBEP9colorData+0x1e>
    2ec8:	9b 96       	adiw	r26, 0x2b	; 43
    2eca:	8c 91       	ld	r24, X
    2ecc:	9b 97       	sbiw	r26, 0x2b	; 43
    2ece:	80 83       	st	Z, r24
    2ed0:	9c 96       	adiw	r26, 0x2c	; 44
    2ed2:	8c 91       	ld	r24, X
    2ed4:	9c 97       	sbiw	r26, 0x2c	; 44
    2ed6:	81 83       	std	Z+1, r24	; 0x01
    2ed8:	9d 96       	adiw	r26, 0x2d	; 45
    2eda:	8c 91       	ld	r24, X
    2edc:	82 83       	std	Z+2, r24	; 0x02
    2ede:	08 95       	ret

00002ee0 <_ZN9MD_TCS23017RGBTransformationEv>:
  return(s);
}

void MD_TCS230::RGBTransformation(void)
// Exploiting linear relationship to remap the range 
{
    2ee0:	4f 92       	push	r4
    2ee2:	5f 92       	push	r5
    2ee4:	6f 92       	push	r6
    2ee6:	7f 92       	push	r7
    2ee8:	8f 92       	push	r8
    2eea:	9f 92       	push	r9
    2eec:	af 92       	push	r10
    2eee:	bf 92       	push	r11
    2ef0:	df 92       	push	r13
    2ef2:	ef 92       	push	r14
    2ef4:	ff 92       	push	r15
    2ef6:	0f 93       	push	r16
    2ef8:	1f 93       	push	r17
    2efa:	cf 93       	push	r28
    2efc:	df 93       	push	r29
    2efe:	8c 01       	movw	r16, r24
    2f00:	09 5f       	subi	r16, 0xF9	; 249
    2f02:	1f 4f       	sbci	r17, 0xFF	; 255
    2f04:	ec 01       	movw	r28, r24
    2f06:	7c 01       	movw	r14, r24
    2f08:	83 e1       	ldi	r24, 0x13	; 19
    2f0a:	e8 0e       	add	r14, r24
    2f0c:	f1 1c       	adc	r15, r1
    x = (_Fo.value[i] - _Fd.value[i]) * 255;
    x /= (_Fw.value[i] - _Fd.value[i]);

    // copy results back into the global structures
    if (x < 0) _rgb.value[i] = 0; 
    else if (x > 255) _rgb.value[i] = 255;
    2f0e:	dd 24       	eor	r13, r13
    2f10:	da 94       	dec	r13
    2f12:	f8 01       	movw	r30, r16
{
  int32_t x;

  for (uint8_t i=0; i<RGB_SIZE; i++)
  {
    x = (_Fo.value[i] - _Fd.value[i]) * 255;
    2f14:	d8 01       	movw	r26, r16
    2f16:	8d 90       	ld	r8, X+
    2f18:	9d 90       	ld	r9, X+
    2f1a:	ad 90       	ld	r10, X+
    2f1c:	bd 90       	ld	r11, X+
    2f1e:	8d 01       	movw	r16, r26
    2f20:	80 8d       	ldd	r24, Z+24	; 0x18
    2f22:	91 8d       	ldd	r25, Z+25	; 0x19
    2f24:	a2 8d       	ldd	r26, Z+26	; 0x1a
    2f26:	b3 8d       	ldd	r27, Z+27	; 0x1b
    2f28:	9c 01       	movw	r18, r24
    2f2a:	ad 01       	movw	r20, r26
    2f2c:	28 19       	sub	r18, r8
    2f2e:	39 09       	sbc	r19, r9
    2f30:	4a 09       	sbc	r20, r10
    2f32:	5b 09       	sbc	r21, r11
    2f34:	af ef       	ldi	r26, 0xFF	; 255
    2f36:	b0 e0       	ldi	r27, 0x00	; 0
    2f38:	0e 94 e9 23 	call	0x47d2	; 0x47d2 <__muluhisi3>
    x /= (_Fw.value[i] - _Fd.value[i]);
    2f3c:	f8 01       	movw	r30, r16
    2f3e:	40 84       	ldd	r4, Z+8	; 0x08
    2f40:	51 84       	ldd	r5, Z+9	; 0x09
    2f42:	62 84       	ldd	r6, Z+10	; 0x0a
    2f44:	73 84       	ldd	r7, Z+11	; 0x0b
    2f46:	a3 01       	movw	r20, r6
    2f48:	92 01       	movw	r18, r4
    2f4a:	28 19       	sub	r18, r8
    2f4c:	39 09       	sbc	r19, r9
    2f4e:	4a 09       	sbc	r20, r10
    2f50:	5b 09       	sbc	r21, r11
    2f52:	0e 94 c4 23 	call	0x4788	; 0x4788 <__divmodsi4>

    // copy results back into the global structures
    if (x < 0) _rgb.value[i] = 0; 
    2f56:	57 ff       	sbrs	r21, 7
    2f58:	02 c0       	rjmp	.+4      	; 0x2f5e <_ZN9MD_TCS23017RGBTransformationEv+0x7e>
    2f5a:	1b a6       	std	Y+43, r1	; 0x2b
    2f5c:	09 c0       	rjmp	.+18     	; 0x2f70 <_ZN9MD_TCS23017RGBTransformationEv+0x90>
    else if (x > 255) _rgb.value[i] = 255;
    2f5e:	2f 3f       	cpi	r18, 0xFF	; 255
    2f60:	31 05       	cpc	r19, r1
    2f62:	41 05       	cpc	r20, r1
    2f64:	51 05       	cpc	r21, r1
    2f66:	19 f0       	breq	.+6      	; 0x2f6e <_ZN9MD_TCS23017RGBTransformationEv+0x8e>
    2f68:	14 f0       	brlt	.+4      	; 0x2f6e <_ZN9MD_TCS23017RGBTransformationEv+0x8e>
    2f6a:	db a6       	std	Y+43, r13	; 0x2b
    2f6c:	01 c0       	rjmp	.+2      	; 0x2f70 <_ZN9MD_TCS23017RGBTransformationEv+0x90>
    else _rgb.value[i] = x;
    2f6e:	2b a7       	std	Y+43, r18	; 0x2b
    2f70:	21 96       	adiw	r28, 0x01	; 1
void MD_TCS230::RGBTransformation(void)
// Exploiting linear relationship to remap the range 
{
  int32_t x;

  for (uint8_t i=0; i<RGB_SIZE; i++)
    2f72:	0e 15       	cp	r16, r14
    2f74:	1f 05       	cpc	r17, r15
    2f76:	69 f6       	brne	.-102    	; 0x2f12 <_ZN9MD_TCS23017RGBTransformationEv+0x32>
    // copy results back into the global structures
    if (x < 0) _rgb.value[i] = 0; 
    else if (x > 255) _rgb.value[i] = 255;
    else _rgb.value[i] = x;
  }
}
    2f78:	df 91       	pop	r29
    2f7a:	cf 91       	pop	r28
    2f7c:	1f 91       	pop	r17
    2f7e:	0f 91       	pop	r16
    2f80:	ff 90       	pop	r15
    2f82:	ef 90       	pop	r14
    2f84:	df 90       	pop	r13
    2f86:	bf 90       	pop	r11
    2f88:	af 90       	pop	r10
    2f8a:	9f 90       	pop	r9
    2f8c:	8f 90       	pop	r8
    2f8e:	7f 90       	pop	r7
    2f90:	6f 90       	pop	r6
    2f92:	5f 90       	pop	r5
    2f94:	4f 90       	pop	r4
    2f96:	08 95       	ret

00002f98 <_ZN9MD_TCS2307readFSMEh>:
  return(_readState == 0);
}

uint8_t MD_TCS230::readFSM(uint8_t s)
// Finite State Machine to read a value (internal function)
{
    2f98:	0f 93       	push	r16
    2f9a:	1f 93       	push	r17
    2f9c:	cf 93       	push	r28
    2f9e:	df 93       	push	r29
    2fa0:	8c 01       	movw	r16, r24
    2fa2:	c6 2f       	mov	r28, r22
  static const uint8_t seq[] = { TCS230_RGB_R, TCS230_RGB_G, TCS230_RGB_B };
  static uint8_t       currCol;  // index for seq above

  switch(s)
    2fa4:	61 30       	cpi	r22, 0x01	; 1
    2fa6:	49 f0       	breq	.+18     	; 0x2fba <_ZN9MD_TCS2307readFSMEh+0x22>
    2fa8:	18 f0       	brcs	.+6      	; 0x2fb0 <_ZN9MD_TCS2307readFSMEh+0x18>
    2faa:	62 30       	cpi	r22, 0x02	; 2
    2fac:	d9 f0       	breq	.+54     	; 0x2fe4 <_ZN9MD_TCS2307readFSMEh+0x4c>
    2fae:	4c c0       	rjmp	.+152    	; 0x3048 <_ZN9MD_TCS2307readFSMEh+0xb0>
  {
  case 0: // enable the hardware for reading
    DUMPS("\n0");
    currCol = 0;  // RGB_R but we don't care
    2fb0:	10 92 ee 03 	sts	0x03EE, r1	; 0x8003ee <_ZZN9MD_TCS2307readFSMEhE7currCol>
    setEnable(true);
    2fb4:	61 e0       	ldi	r22, 0x01	; 1
    2fb6:	0e 94 24 17 	call	0x2e48	; 0x2e48 <_ZN9MD_TCS2309setEnableEb>
    s++;
    // fall through to the next state

  case 1: // select a filter and start a reading
    DUMPS("\n1");
    setFilter(seq[currCol]);
    2fba:	e0 91 ee 03 	lds	r30, 0x03EE	; 0x8003ee <_ZZN9MD_TCS2307readFSMEhE7currCol>
    2fbe:	f0 e0       	ldi	r31, 0x00	; 0
    2fc0:	e0 51       	subi	r30, 0x10	; 16
    2fc2:	fe 4f       	sbci	r31, 0xFE	; 254
    2fc4:	60 81       	ld	r22, Z
    2fc6:	c8 01       	movw	r24, r16
    2fc8:	0e 94 d8 16 	call	0x2db0	; 0x2db0 <_ZN9MD_TCS2309setFilterEh>
    FreqCount.begin(1000/_readDiv);
    2fcc:	f8 01       	movw	r30, r16
    2fce:	65 81       	ldd	r22, Z+5	; 0x05
    2fd0:	70 e0       	ldi	r23, 0x00	; 0
    2fd2:	88 ee       	ldi	r24, 0xE8	; 232
    2fd4:	93 e0       	ldi	r25, 0x03	; 3
    2fd6:	0e 94 8e 23 	call	0x471c	; 0x471c <__divmodhi4>
    2fda:	cb 01       	movw	r24, r22
    2fdc:	0e 94 77 22 	call	0x44ee	; 0x44ee <_ZN14FreqCountClass5beginEj>
    s++;
    2fe0:	c2 e0       	ldi	r28, 0x02	; 2
    break;
    2fe2:	32 c0       	rjmp	.+100    	; 0x3048 <_ZN9MD_TCS2307readFSMEh+0xb0>

  case 2: // see if a value is available
    DUMPS("2");
    if (FreqCount.available())
    2fe4:	0e 94 ef 22 	call	0x45de	; 0x45de <_ZN14FreqCountClass9availableEv>
    2fe8:	88 23       	and	r24, r24
    2fea:	71 f1       	breq	.+92     	; 0x3048 <_ZN9MD_TCS2307readFSMEh+0xb0>
    {
      DUMP(" VALUE ", FreqCount.read());
      // read the value and save it 
      _Fo.value[seq[currCol++]] = FreqCount.read() * _readDiv;
    2fec:	e0 91 ee 03 	lds	r30, 0x03EE	; 0x8003ee <_ZZN9MD_TCS2307readFSMEhE7currCol>
    2ff0:	81 e0       	ldi	r24, 0x01	; 1
    2ff2:	8e 0f       	add	r24, r30
    2ff4:	80 93 ee 03 	sts	0x03EE, r24	; 0x8003ee <_ZZN9MD_TCS2307readFSMEhE7currCol>
    2ff8:	f0 e0       	ldi	r31, 0x00	; 0
    2ffa:	e0 51       	subi	r30, 0x10	; 16
    2ffc:	fe 4f       	sbci	r31, 0xFE	; 254
    2ffe:	c0 81       	ld	r28, Z
    3000:	d0 e0       	ldi	r29, 0x00	; 0
    3002:	0e 94 f2 22 	call	0x45e4	; 0x45e4 <_ZN14FreqCountClass4readEv>
    3006:	9b 01       	movw	r18, r22
    3008:	ac 01       	movw	r20, r24
    300a:	cc 0f       	add	r28, r28
    300c:	dd 1f       	adc	r29, r29
    300e:	cc 0f       	add	r28, r28
    3010:	dd 1f       	adc	r29, r29
    3012:	c0 0f       	add	r28, r16
    3014:	d1 1f       	adc	r29, r17
    3016:	f8 01       	movw	r30, r16
    3018:	a5 81       	ldd	r26, Z+5	; 0x05
    301a:	b0 e0       	ldi	r27, 0x00	; 0
    301c:	0e 94 e9 23 	call	0x47d2	; 0x47d2 <__muluhisi3>
    3020:	6f 8f       	std	Y+31, r22	; 0x1f
    3022:	78 a3       	std	Y+32, r23	; 0x20
    3024:	89 a3       	std	Y+33, r24	; 0x21
    3026:	9a a3       	std	Y+34, r25	; 0x22

      if (currCol < RGB_SIZE)
    3028:	80 91 ee 03 	lds	r24, 0x03EE	; 0x8003ee <_ZZN9MD_TCS2307readFSMEhE7currCol>
    302c:	83 30       	cpi	r24, 0x03	; 3
    302e:	58 f0       	brcs	.+22     	; 0x3046 <_ZN9MD_TCS2307readFSMEh+0xae>
        s--;
      }
      else
      {
        // end this reading session
        FreqCount.end();
    3030:	0e 94 00 23 	call	0x4600	; 0x4600 <_ZN14FreqCountClass3endEv>
        setEnable(false);
    3034:	60 e0       	ldi	r22, 0x00	; 0
    3036:	c8 01       	movw	r24, r16
    3038:	0e 94 24 17 	call	0x2e48	; 0x2e48 <_ZN9MD_TCS2309setEnableEb>
        RGBTransformation();
    303c:	c8 01       	movw	r24, r16
    303e:	0e 94 70 17 	call	0x2ee0	; 0x2ee0 <_ZN9MD_TCS23017RGBTransformationEv>
        s = 0;
    3042:	c0 e0       	ldi	r28, 0x00	; 0
    3044:	01 c0       	rjmp	.+2      	; 0x3048 <_ZN9MD_TCS2307readFSMEh+0xb0>
      _Fo.value[seq[currCol++]] = FreqCount.read() * _readDiv;

      if (currCol < RGB_SIZE)
      {
        // loop around again on next call to available()
        s--;
    3046:	c1 e0       	ldi	r28, 0x01	; 1
    }
    break;
  }

  return(s);
}
    3048:	8c 2f       	mov	r24, r28
    304a:	df 91       	pop	r29
    304c:	cf 91       	pop	r28
    304e:	1f 91       	pop	r17
    3050:	0f 91       	pop	r16
    3052:	08 95       	ret

00003054 <_ZN9MD_TCS2304readEv>:
  return(FreqCount.read() * _readDiv);
}

void MD_TCS230::read(void)
// initiate the finite state machine for reading a value
{
    3054:	cf 93       	push	r28
    3056:	df 93       	push	r29
    3058:	ec 01       	movw	r28, r24
  _readState = readFSM(0);
    305a:	60 e0       	ldi	r22, 0x00	; 0
    305c:	0e 94 cc 17 	call	0x2f98	; 0x2f98 <_ZN9MD_TCS2307readFSMEh>
    3060:	8e a7       	std	Y+46, r24	; 0x2e
}
    3062:	df 91       	pop	r29
    3064:	cf 91       	pop	r28
    3066:	08 95       	ret

00003068 <_ZN9MD_TCS2309availableEv>:

bool MD_TCS230::available(void)
// check if a value is ready. Called repeatedly until it is!
{
    3068:	cf 93       	push	r28
    306a:	df 93       	push	r29
    306c:	ec 01       	movw	r28, r24
  _readState = readFSM(_readState);
    306e:	6e a5       	ldd	r22, Y+46	; 0x2e
    3070:	0e 94 cc 17 	call	0x2f98	; 0x2f98 <_ZN9MD_TCS2307readFSMEh>
    3074:	98 2f       	mov	r25, r24
    3076:	8e a7       	std	Y+46, r24	; 0x2e

  return(_readState == 0);
    3078:	81 e0       	ldi	r24, 0x01	; 1
    307a:	91 11       	cpse	r25, r1
    307c:	80 e0       	ldi	r24, 0x00	; 0
}
    307e:	df 91       	pop	r29
    3080:	cf 91       	pop	r28
    3082:	08 95       	ret

00003084 <_ZN5Print17availableForWriteEv>:
uint16_t SoftwareSerial::subtract_cap(uint16_t num, uint16_t sub) {
  if (num > sub)
    return num - sub;
  else
    return 1;
}
    3084:	80 e0       	ldi	r24, 0x00	; 0
    3086:	90 e0       	ldi	r25, 0x00	; 0
    3088:	08 95       	ret

0000308a <_ZN14SoftwareSerial4readEv>:
    308a:	20 91 31 04 	lds	r18, 0x0431	; 0x800431 <_ZN14SoftwareSerial13active_objectE>
    308e:	30 91 32 04 	lds	r19, 0x0432	; 0x800432 <_ZN14SoftwareSerial13active_objectE+0x1>
    3092:	28 17       	cp	r18, r24
    3094:	39 07       	cpc	r19, r25
    3096:	b9 f4       	brne	.+46     	; 0x30c6 <_ZN14SoftwareSerial4readEv+0x3c>
    3098:	90 91 ef 03 	lds	r25, 0x03EF	; 0x8003ef <_ZN14SoftwareSerial20_receive_buffer_headE>
    309c:	80 91 f0 03 	lds	r24, 0x03F0	; 0x8003f0 <_ZN14SoftwareSerial20_receive_buffer_tailE>
    30a0:	98 17       	cp	r25, r24
    30a2:	89 f0       	breq	.+34     	; 0x30c6 <_ZN14SoftwareSerial4readEv+0x3c>
    30a4:	e0 91 ef 03 	lds	r30, 0x03EF	; 0x8003ef <_ZN14SoftwareSerial20_receive_buffer_headE>
    30a8:	f0 e0       	ldi	r31, 0x00	; 0
    30aa:	ef 50       	subi	r30, 0x0F	; 15
    30ac:	fc 4f       	sbci	r31, 0xFC	; 252
    30ae:	80 81       	ld	r24, Z
    30b0:	20 91 ef 03 	lds	r18, 0x03EF	; 0x8003ef <_ZN14SoftwareSerial20_receive_buffer_headE>
    30b4:	30 e0       	ldi	r19, 0x00	; 0
    30b6:	2f 5f       	subi	r18, 0xFF	; 255
    30b8:	3f 4f       	sbci	r19, 0xFF	; 255
    30ba:	2f 73       	andi	r18, 0x3F	; 63
    30bc:	33 27       	eor	r19, r19
    30be:	20 93 ef 03 	sts	0x03EF, r18	; 0x8003ef <_ZN14SoftwareSerial20_receive_buffer_headE>
    30c2:	90 e0       	ldi	r25, 0x00	; 0
    30c4:	08 95       	ret
    30c6:	8f ef       	ldi	r24, 0xFF	; 255
    30c8:	9f ef       	ldi	r25, 0xFF	; 255
    30ca:	08 95       	ret

000030cc <_ZN14SoftwareSerial5writeEh>:
    30cc:	1f 93       	push	r17
    30ce:	cf 93       	push	r28
    30d0:	df 93       	push	r29
    30d2:	dc 01       	movw	r26, r24
    30d4:	5c 96       	adiw	r26, 0x1c	; 28
    30d6:	8d 91       	ld	r24, X+
    30d8:	9c 91       	ld	r25, X
    30da:	5d 97       	sbiw	r26, 0x1d	; 29
    30dc:	00 97       	sbiw	r24, 0x00	; 0
    30de:	39 f4       	brne	.+14     	; 0x30ee <_ZN14SoftwareSerial5writeEh+0x22>
    30e0:	21 e0       	ldi	r18, 0x01	; 1
    30e2:	30 e0       	ldi	r19, 0x00	; 0
    30e4:	13 96       	adiw	r26, 0x03	; 3
    30e6:	3c 93       	st	X, r19
    30e8:	2e 93       	st	-X, r18
    30ea:	12 97       	sbiw	r26, 0x02	; 2
    30ec:	3b c0       	rjmp	.+118    	; 0x3164 <_ZN14SoftwareSerial5writeEh+0x98>
    30ee:	51 96       	adiw	r26, 0x11	; 17
    30f0:	ed 91       	ld	r30, X+
    30f2:	fc 91       	ld	r31, X
    30f4:	52 97       	sbiw	r26, 0x12	; 18
    30f6:	50 96       	adiw	r26, 0x10	; 16
    30f8:	2c 91       	ld	r18, X
    30fa:	50 97       	sbiw	r26, 0x10	; 16
    30fc:	32 2f       	mov	r19, r18
    30fe:	30 95       	com	r19
    3100:	1f b7       	in	r17, 0x3f	; 63
    3102:	5e 96       	adiw	r26, 0x1e	; 30
    3104:	4c 91       	ld	r20, X
    3106:	5e 97       	sbiw	r26, 0x1e	; 30
    3108:	74 2f       	mov	r23, r20
    310a:	72 70       	andi	r23, 0x02	; 2
    310c:	41 fd       	sbrc	r20, 1
    310e:	60 95       	com	r22
    3110:	f8 94       	cli
    3112:	40 81       	ld	r20, Z
    3114:	77 23       	and	r23, r23
    3116:	11 f0       	breq	.+4      	; 0x311c <_ZN14SoftwareSerial5writeEh+0x50>
    3118:	42 2b       	or	r20, r18
    311a:	01 c0       	rjmp	.+2      	; 0x311e <_ZN14SoftwareSerial5writeEh+0x52>
    311c:	43 23       	and	r20, r19
    311e:	40 83       	st	Z, r20
    3120:	ec 01       	movw	r28, r24
    3122:	21 97       	sbiw	r28, 0x01	; 1
    3124:	f1 f7       	brne	.-4      	; 0x3122 <_ZN14SoftwareSerial5writeEh+0x56>
    3126:	48 e0       	ldi	r20, 0x08	; 8
    3128:	50 81       	ld	r21, Z
    312a:	60 ff       	sbrs	r22, 0
    312c:	02 c0       	rjmp	.+4      	; 0x3132 <_ZN14SoftwareSerial5writeEh+0x66>
    312e:	52 2b       	or	r21, r18
    3130:	01 c0       	rjmp	.+2      	; 0x3134 <_ZN14SoftwareSerial5writeEh+0x68>
    3132:	53 23       	and	r21, r19
    3134:	50 83       	st	Z, r21
    3136:	ec 01       	movw	r28, r24
    3138:	21 97       	sbiw	r28, 0x01	; 1
    313a:	f1 f7       	brne	.-4      	; 0x3138 <_ZN14SoftwareSerial5writeEh+0x6c>
    313c:	66 95       	lsr	r22
    313e:	41 50       	subi	r20, 0x01	; 1
    3140:	99 f7       	brne	.-26     	; 0x3128 <_ZN14SoftwareSerial5writeEh+0x5c>
    3142:	80 81       	ld	r24, Z
    3144:	77 23       	and	r23, r23
    3146:	19 f0       	breq	.+6      	; 0x314e <_ZN14SoftwareSerial5writeEh+0x82>
    3148:	83 23       	and	r24, r19
    314a:	80 83       	st	Z, r24
    314c:	02 c0       	rjmp	.+4      	; 0x3152 <_ZN14SoftwareSerial5writeEh+0x86>
    314e:	28 2b       	or	r18, r24
    3150:	20 83       	st	Z, r18
    3152:	1f bf       	out	0x3f, r17	; 63
    3154:	5c 96       	adiw	r26, 0x1c	; 28
    3156:	8d 91       	ld	r24, X+
    3158:	9c 91       	ld	r25, X
    315a:	5d 97       	sbiw	r26, 0x1d	; 29
    315c:	01 97       	sbiw	r24, 0x01	; 1
    315e:	f1 f7       	brne	.-4      	; 0x315c <_ZN14SoftwareSerial5writeEh+0x90>
    3160:	81 e0       	ldi	r24, 0x01	; 1
    3162:	90 e0       	ldi	r25, 0x00	; 0
    3164:	df 91       	pop	r29
    3166:	cf 91       	pop	r28
    3168:	1f 91       	pop	r17
    316a:	08 95       	ret

0000316c <_ZN14SoftwareSerial5flushEv>:
    316c:	08 95       	ret

0000316e <_ZN14SoftwareSerial4peekEv>:
    316e:	20 91 31 04 	lds	r18, 0x0431	; 0x800431 <_ZN14SoftwareSerial13active_objectE>
    3172:	30 91 32 04 	lds	r19, 0x0432	; 0x800432 <_ZN14SoftwareSerial13active_objectE+0x1>
    3176:	28 17       	cp	r18, r24
    3178:	39 07       	cpc	r19, r25
    317a:	71 f4       	brne	.+28     	; 0x3198 <_ZN14SoftwareSerial4peekEv+0x2a>
    317c:	90 91 ef 03 	lds	r25, 0x03EF	; 0x8003ef <_ZN14SoftwareSerial20_receive_buffer_headE>
    3180:	80 91 f0 03 	lds	r24, 0x03F0	; 0x8003f0 <_ZN14SoftwareSerial20_receive_buffer_tailE>
    3184:	98 17       	cp	r25, r24
    3186:	41 f0       	breq	.+16     	; 0x3198 <_ZN14SoftwareSerial4peekEv+0x2a>
    3188:	e0 91 ef 03 	lds	r30, 0x03EF	; 0x8003ef <_ZN14SoftwareSerial20_receive_buffer_headE>
    318c:	f0 e0       	ldi	r31, 0x00	; 0
    318e:	ef 50       	subi	r30, 0x0F	; 15
    3190:	fc 4f       	sbci	r31, 0xFC	; 252
    3192:	80 81       	ld	r24, Z
    3194:	90 e0       	ldi	r25, 0x00	; 0
    3196:	08 95       	ret
    3198:	8f ef       	ldi	r24, 0xFF	; 255
    319a:	9f ef       	ldi	r25, 0xFF	; 255
    319c:	08 95       	ret

0000319e <_ZN14SoftwareSerial9availableEv>:
    319e:	20 91 31 04 	lds	r18, 0x0431	; 0x800431 <_ZN14SoftwareSerial13active_objectE>
    31a2:	30 91 32 04 	lds	r19, 0x0432	; 0x800432 <_ZN14SoftwareSerial13active_objectE+0x1>
    31a6:	28 17       	cp	r18, r24
    31a8:	39 07       	cpc	r19, r25
    31aa:	71 f4       	brne	.+28     	; 0x31c8 <_ZN14SoftwareSerial9availableEv+0x2a>
    31ac:	80 91 f0 03 	lds	r24, 0x03F0	; 0x8003f0 <_ZN14SoftwareSerial20_receive_buffer_tailE>
    31b0:	20 91 ef 03 	lds	r18, 0x03EF	; 0x8003ef <_ZN14SoftwareSerial20_receive_buffer_headE>
    31b4:	90 e0       	ldi	r25, 0x00	; 0
    31b6:	80 5c       	subi	r24, 0xC0	; 192
    31b8:	9f 4f       	sbci	r25, 0xFF	; 255
    31ba:	82 1b       	sub	r24, r18
    31bc:	91 09       	sbc	r25, r1
    31be:	60 e4       	ldi	r22, 0x40	; 64
    31c0:	70 e0       	ldi	r23, 0x00	; 0
    31c2:	0e 94 8e 23 	call	0x471c	; 0x471c <__divmodhi4>
    31c6:	08 95       	ret
    31c8:	80 e0       	ldi	r24, 0x00	; 0
    31ca:	90 e0       	ldi	r25, 0x00	; 0
    31cc:	08 95       	ret

000031ce <_ZN14SoftwareSerial13stopListeningEv>:
    31ce:	e0 91 31 04 	lds	r30, 0x0431	; 0x800431 <_ZN14SoftwareSerial13active_objectE>
    31d2:	f0 91 32 04 	lds	r31, 0x0432	; 0x800432 <_ZN14SoftwareSerial13active_objectE+0x1>
    31d6:	e8 17       	cp	r30, r24
    31d8:	f9 07       	cpc	r31, r25
    31da:	69 f4       	brne	.+26     	; 0x31f6 <_ZN14SoftwareSerial13stopListeningEv+0x28>
    31dc:	a3 89       	ldd	r26, Z+19	; 0x13
    31de:	b4 89       	ldd	r27, Z+20	; 0x14
    31e0:	9c 91       	ld	r25, X
    31e2:	85 89       	ldd	r24, Z+21	; 0x15
    31e4:	80 95       	com	r24
    31e6:	89 23       	and	r24, r25
    31e8:	8c 93       	st	X, r24
    31ea:	10 92 32 04 	sts	0x0432, r1	; 0x800432 <_ZN14SoftwareSerial13active_objectE+0x1>
    31ee:	10 92 31 04 	sts	0x0431, r1	; 0x800431 <_ZN14SoftwareSerial13active_objectE>
    31f2:	81 e0       	ldi	r24, 0x01	; 1
    31f4:	08 95       	ret
    31f6:	80 e0       	ldi	r24, 0x00	; 0
    31f8:	08 95       	ret

000031fa <_ZN14SoftwareSerial6listenEv>:
    31fa:	cf 93       	push	r28
    31fc:	df 93       	push	r29
    31fe:	ec 01       	movw	r28, r24
    3200:	8a 8d       	ldd	r24, Y+26	; 0x1a
    3202:	9b 8d       	ldd	r25, Y+27	; 0x1b
    3204:	89 2b       	or	r24, r25
    3206:	f1 f0       	breq	.+60     	; 0x3244 <_ZN14SoftwareSerial6listenEv+0x4a>
    3208:	80 91 31 04 	lds	r24, 0x0431	; 0x800431 <_ZN14SoftwareSerial13active_objectE>
    320c:	90 91 32 04 	lds	r25, 0x0432	; 0x800432 <_ZN14SoftwareSerial13active_objectE+0x1>
    3210:	c8 17       	cp	r28, r24
    3212:	d9 07       	cpc	r29, r25
    3214:	b9 f0       	breq	.+46     	; 0x3244 <_ZN14SoftwareSerial6listenEv+0x4a>
    3216:	00 97       	sbiw	r24, 0x00	; 0
    3218:	11 f0       	breq	.+4      	; 0x321e <_ZN14SoftwareSerial6listenEv+0x24>
    321a:	0e 94 e7 18 	call	0x31ce	; 0x31ce <_ZN14SoftwareSerial13stopListeningEv>
    321e:	8e 8d       	ldd	r24, Y+30	; 0x1e
    3220:	8e 7f       	andi	r24, 0xFE	; 254
    3222:	8e 8f       	std	Y+30, r24	; 0x1e
    3224:	10 92 f0 03 	sts	0x03F0, r1	; 0x8003f0 <_ZN14SoftwareSerial20_receive_buffer_tailE>
    3228:	10 92 ef 03 	sts	0x03EF, r1	; 0x8003ef <_ZN14SoftwareSerial20_receive_buffer_headE>
    322c:	d0 93 32 04 	sts	0x0432, r29	; 0x800432 <_ZN14SoftwareSerial13active_objectE+0x1>
    3230:	c0 93 31 04 	sts	0x0431, r28	; 0x800431 <_ZN14SoftwareSerial13active_objectE>
    3234:	eb 89       	ldd	r30, Y+19	; 0x13
    3236:	fc 89       	ldd	r31, Y+20	; 0x14
    3238:	90 81       	ld	r25, Z
    323a:	8d 89       	ldd	r24, Y+21	; 0x15
    323c:	89 2b       	or	r24, r25
    323e:	80 83       	st	Z, r24
    3240:	81 e0       	ldi	r24, 0x01	; 1
    3242:	01 c0       	rjmp	.+2      	; 0x3246 <_ZN14SoftwareSerial6listenEv+0x4c>
    3244:	80 e0       	ldi	r24, 0x00	; 0
    3246:	df 91       	pop	r29
    3248:	cf 91       	pop	r28
    324a:	08 95       	ret

0000324c <__vector_3>:
    324c:	1f 92       	push	r1
    324e:	0f 92       	push	r0
    3250:	0f b6       	in	r0, 0x3f	; 63
    3252:	0f 92       	push	r0
    3254:	11 24       	eor	r1, r1
    3256:	2f 93       	push	r18
    3258:	3f 93       	push	r19
    325a:	4f 93       	push	r20
    325c:	5f 93       	push	r21
    325e:	6f 93       	push	r22
    3260:	7f 93       	push	r23
    3262:	8f 93       	push	r24
    3264:	9f 93       	push	r25
    3266:	af 93       	push	r26
    3268:	bf 93       	push	r27
    326a:	ef 93       	push	r30
    326c:	ff 93       	push	r31
    326e:	e0 91 31 04 	lds	r30, 0x0431	; 0x800431 <_ZN14SoftwareSerial13active_objectE>
    3272:	f0 91 32 04 	lds	r31, 0x0432	; 0x800432 <_ZN14SoftwareSerial13active_objectE+0x1>
    3276:	30 97       	sbiw	r30, 0x00	; 0
    3278:	09 f4       	brne	.+2      	; 0x327c <__vector_3+0x30>
    327a:	51 c0       	rjmp	.+162    	; 0x331e <__vector_3+0xd2>
    327c:	96 8d       	ldd	r25, Z+30	; 0x1e
    327e:	a6 85       	ldd	r26, Z+14	; 0x0e
    3280:	b7 85       	ldd	r27, Z+15	; 0x0f
    3282:	85 85       	ldd	r24, Z+13	; 0x0d
    3284:	91 ff       	sbrs	r25, 1
    3286:	04 c0       	rjmp	.+8      	; 0x3290 <__vector_3+0x44>
    3288:	9c 91       	ld	r25, X
    328a:	89 23       	and	r24, r25
    328c:	29 f4       	brne	.+10     	; 0x3298 <__vector_3+0x4c>
    328e:	47 c0       	rjmp	.+142    	; 0x331e <__vector_3+0xd2>
    3290:	9c 91       	ld	r25, X
    3292:	89 23       	and	r24, r25
    3294:	09 f0       	breq	.+2      	; 0x3298 <__vector_3+0x4c>
    3296:	43 c0       	rjmp	.+134    	; 0x331e <__vector_3+0xd2>
    3298:	a3 89       	ldd	r26, Z+19	; 0x13
    329a:	b4 89       	ldd	r27, Z+20	; 0x14
    329c:	9c 91       	ld	r25, X
    329e:	85 89       	ldd	r24, Z+21	; 0x15
    32a0:	80 95       	com	r24
    32a2:	89 23       	and	r24, r25
    32a4:	8c 93       	st	X, r24
    32a6:	86 89       	ldd	r24, Z+22	; 0x16
    32a8:	97 89       	ldd	r25, Z+23	; 0x17
    32aa:	01 97       	sbiw	r24, 0x01	; 1
    32ac:	f1 f7       	brne	.-4      	; 0x32aa <__vector_3+0x5e>
    32ae:	60 8d       	ldd	r22, Z+24	; 0x18
    32b0:	71 8d       	ldd	r23, Z+25	; 0x19
    32b2:	a6 85       	ldd	r26, Z+14	; 0x0e
    32b4:	b7 85       	ldd	r27, Z+15	; 0x0f
    32b6:	55 85       	ldd	r21, Z+13	; 0x0d
    32b8:	38 e0       	ldi	r19, 0x08	; 8
    32ba:	20 e0       	ldi	r18, 0x00	; 0
    32bc:	cb 01       	movw	r24, r22
    32be:	01 97       	sbiw	r24, 0x01	; 1
    32c0:	f1 f7       	brne	.-4      	; 0x32be <__vector_3+0x72>
    32c2:	82 2f       	mov	r24, r18
    32c4:	90 e0       	ldi	r25, 0x00	; 0
    32c6:	95 95       	asr	r25
    32c8:	87 95       	ror	r24
    32ca:	28 2f       	mov	r18, r24
    32cc:	4c 91       	ld	r20, X
    32ce:	45 23       	and	r20, r21
    32d0:	09 f0       	breq	.+2      	; 0x32d4 <__vector_3+0x88>
    32d2:	20 68       	ori	r18, 0x80	; 128
    32d4:	31 50       	subi	r19, 0x01	; 1
    32d6:	91 f7       	brne	.-28     	; 0x32bc <__vector_3+0x70>
    32d8:	86 8d       	ldd	r24, Z+30	; 0x1e
    32da:	81 fd       	sbrc	r24, 1
    32dc:	20 95       	com	r18
    32de:	80 91 f0 03 	lds	r24, 0x03F0	; 0x8003f0 <_ZN14SoftwareSerial20_receive_buffer_tailE>
    32e2:	90 e0       	ldi	r25, 0x00	; 0
    32e4:	01 96       	adiw	r24, 0x01	; 1
    32e6:	8f 73       	andi	r24, 0x3F	; 63
    32e8:	99 27       	eor	r25, r25
    32ea:	30 91 ef 03 	lds	r19, 0x03EF	; 0x8003ef <_ZN14SoftwareSerial20_receive_buffer_headE>
    32ee:	38 17       	cp	r19, r24
    32f0:	49 f0       	breq	.+18     	; 0x3304 <__vector_3+0xb8>
    32f2:	a0 91 f0 03 	lds	r26, 0x03F0	; 0x8003f0 <_ZN14SoftwareSerial20_receive_buffer_tailE>
    32f6:	b0 e0       	ldi	r27, 0x00	; 0
    32f8:	af 50       	subi	r26, 0x0F	; 15
    32fa:	bc 4f       	sbci	r27, 0xFC	; 252
    32fc:	2c 93       	st	X, r18
    32fe:	80 93 f0 03 	sts	0x03F0, r24	; 0x8003f0 <_ZN14SoftwareSerial20_receive_buffer_tailE>
    3302:	03 c0       	rjmp	.+6      	; 0x330a <__vector_3+0xbe>
    3304:	86 8d       	ldd	r24, Z+30	; 0x1e
    3306:	81 60       	ori	r24, 0x01	; 1
    3308:	86 8f       	std	Z+30, r24	; 0x1e
    330a:	82 8d       	ldd	r24, Z+26	; 0x1a
    330c:	93 8d       	ldd	r25, Z+27	; 0x1b
    330e:	01 97       	sbiw	r24, 0x01	; 1
    3310:	f1 f7       	brne	.-4      	; 0x330e <__vector_3+0xc2>
    3312:	a3 89       	ldd	r26, Z+19	; 0x13
    3314:	b4 89       	ldd	r27, Z+20	; 0x14
    3316:	9c 91       	ld	r25, X
    3318:	85 89       	ldd	r24, Z+21	; 0x15
    331a:	89 2b       	or	r24, r25
    331c:	8c 93       	st	X, r24
    331e:	ff 91       	pop	r31
    3320:	ef 91       	pop	r30
    3322:	bf 91       	pop	r27
    3324:	af 91       	pop	r26
    3326:	9f 91       	pop	r25
    3328:	8f 91       	pop	r24
    332a:	7f 91       	pop	r23
    332c:	6f 91       	pop	r22
    332e:	5f 91       	pop	r21
    3330:	4f 91       	pop	r20
    3332:	3f 91       	pop	r19
    3334:	2f 91       	pop	r18
    3336:	0f 90       	pop	r0
    3338:	0f be       	out	0x3f, r0	; 63
    333a:	0f 90       	pop	r0
    333c:	1f 90       	pop	r1
    333e:	18 95       	reti

00003340 <_ZN14SoftwareSerialD1Ev>:
    3340:	27 ef       	ldi	r18, 0xF7	; 247
    3342:	31 e0       	ldi	r19, 0x01	; 1
    3344:	fc 01       	movw	r30, r24
    3346:	31 83       	std	Z+1, r19	; 0x01
    3348:	20 83       	st	Z, r18
    334a:	0c 94 e7 18 	jmp	0x31ce	; 0x31ce <_ZN14SoftwareSerial13stopListeningEv>

0000334e <_ZN14SoftwareSerial5setTXEh>:
    334e:	1f 93       	push	r17
    3350:	cf 93       	push	r28
    3352:	df 93       	push	r29
    3354:	ec 01       	movw	r28, r24
    3356:	16 2f       	mov	r17, r22
    3358:	6e 8d       	ldd	r22, Y+30	; 0x1e
    335a:	66 95       	lsr	r22
    335c:	61 70       	andi	r22, 0x01	; 1
    335e:	81 e0       	ldi	r24, 0x01	; 1
    3360:	68 27       	eor	r22, r24
    3362:	81 2f       	mov	r24, r17
    3364:	0e 94 48 22 	call	0x4490	; 0x4490 <digitalWrite>
    3368:	61 e0       	ldi	r22, 0x01	; 1
    336a:	81 2f       	mov	r24, r17
    336c:	0e 94 0c 22 	call	0x4418	; 0x4418 <pinMode>
    3370:	81 2f       	mov	r24, r17
    3372:	90 e0       	ldi	r25, 0x00	; 0
    3374:	fc 01       	movw	r30, r24
    3376:	ea 53       	subi	r30, 0x3A	; 58
    3378:	ff 4f       	sbci	r31, 0xFF	; 255
    337a:	e4 91       	lpm	r30, Z
    337c:	e8 8b       	std	Y+16, r30	; 0x10
    337e:	fc 01       	movw	r30, r24
    3380:	e6 52       	subi	r30, 0x26	; 38
    3382:	ff 4f       	sbci	r31, 0xFF	; 255
    3384:	e4 91       	lpm	r30, Z
    3386:	f0 e0       	ldi	r31, 0x00	; 0
    3388:	ee 0f       	add	r30, r30
    338a:	ff 1f       	adc	r31, r31
    338c:	e8 50       	subi	r30, 0x08	; 8
    338e:	ff 4f       	sbci	r31, 0xFF	; 255
    3390:	85 91       	lpm	r24, Z+
    3392:	94 91       	lpm	r25, Z
    3394:	9a 8b       	std	Y+18, r25	; 0x12
    3396:	89 8b       	std	Y+17, r24	; 0x11
    3398:	df 91       	pop	r29
    339a:	cf 91       	pop	r28
    339c:	1f 91       	pop	r17
    339e:	08 95       	ret

000033a0 <_ZN14SoftwareSerial5setRXEh>:
    33a0:	1f 93       	push	r17
    33a2:	cf 93       	push	r28
    33a4:	df 93       	push	r29
    33a6:	ec 01       	movw	r28, r24
    33a8:	16 2f       	mov	r17, r22
    33aa:	60 e0       	ldi	r22, 0x00	; 0
    33ac:	81 2f       	mov	r24, r17
    33ae:	0e 94 0c 22 	call	0x4418	; 0x4418 <pinMode>
    33b2:	8e 8d       	ldd	r24, Y+30	; 0x1e
    33b4:	81 fd       	sbrc	r24, 1
    33b6:	04 c0       	rjmp	.+8      	; 0x33c0 <_ZN14SoftwareSerial5setRXEh+0x20>
    33b8:	61 e0       	ldi	r22, 0x01	; 1
    33ba:	81 2f       	mov	r24, r17
    33bc:	0e 94 48 22 	call	0x4490	; 0x4490 <digitalWrite>
    33c0:	1c 87       	std	Y+12, r17	; 0x0c
    33c2:	81 2f       	mov	r24, r17
    33c4:	90 e0       	ldi	r25, 0x00	; 0
    33c6:	fc 01       	movw	r30, r24
    33c8:	ea 53       	subi	r30, 0x3A	; 58
    33ca:	ff 4f       	sbci	r31, 0xFF	; 255
    33cc:	e4 91       	lpm	r30, Z
    33ce:	ed 87       	std	Y+13, r30	; 0x0d
    33d0:	fc 01       	movw	r30, r24
    33d2:	e6 52       	subi	r30, 0x26	; 38
    33d4:	ff 4f       	sbci	r31, 0xFF	; 255
    33d6:	e4 91       	lpm	r30, Z
    33d8:	f0 e0       	ldi	r31, 0x00	; 0
    33da:	ee 0f       	add	r30, r30
    33dc:	ff 1f       	adc	r31, r31
    33de:	e2 51       	subi	r30, 0x12	; 18
    33e0:	ff 4f       	sbci	r31, 0xFF	; 255
    33e2:	85 91       	lpm	r24, Z+
    33e4:	94 91       	lpm	r25, Z
    33e6:	9f 87       	std	Y+15, r25	; 0x0f
    33e8:	8e 87       	std	Y+14, r24	; 0x0e
    33ea:	df 91       	pop	r29
    33ec:	cf 91       	pop	r28
    33ee:	1f 91       	pop	r17
    33f0:	08 95       	ret

000033f2 <_ZN14SoftwareSerialC1Ehhb>:
    33f2:	1f 93       	push	r17
    33f4:	cf 93       	push	r28
    33f6:	df 93       	push	r29
    33f8:	ec 01       	movw	r28, r24
    33fa:	16 2f       	mov	r17, r22
    33fc:	1b 82       	std	Y+3, r1	; 0x03
    33fe:	1a 82       	std	Y+2, r1	; 0x02
    3400:	88 ee       	ldi	r24, 0xE8	; 232
    3402:	93 e0       	ldi	r25, 0x03	; 3
    3404:	a0 e0       	ldi	r26, 0x00	; 0
    3406:	b0 e0       	ldi	r27, 0x00	; 0
    3408:	8c 83       	std	Y+4, r24	; 0x04
    340a:	9d 83       	std	Y+5, r25	; 0x05
    340c:	ae 83       	std	Y+6, r26	; 0x06
    340e:	bf 83       	std	Y+7, r27	; 0x07
    3410:	87 ef       	ldi	r24, 0xF7	; 247
    3412:	91 e0       	ldi	r25, 0x01	; 1
    3414:	99 83       	std	Y+1, r25	; 0x01
    3416:	88 83       	st	Y, r24
    3418:	1f 8a       	std	Y+23, r1	; 0x17
    341a:	1e 8a       	std	Y+22, r1	; 0x16
    341c:	19 8e       	std	Y+25, r1	; 0x19
    341e:	18 8e       	std	Y+24, r1	; 0x18
    3420:	1b 8e       	std	Y+27, r1	; 0x1b
    3422:	1a 8e       	std	Y+26, r1	; 0x1a
    3424:	1d 8e       	std	Y+29, r1	; 0x1d
    3426:	1c 8e       	std	Y+28, r1	; 0x1c
    3428:	8e 8d       	ldd	r24, Y+30	; 0x1e
    342a:	8e 7f       	andi	r24, 0xFE	; 254
    342c:	20 fb       	bst	r18, 0
    342e:	81 f9       	bld	r24, 1
    3430:	8e 8f       	std	Y+30, r24	; 0x1e
    3432:	64 2f       	mov	r22, r20
    3434:	ce 01       	movw	r24, r28
    3436:	0e 94 a7 19 	call	0x334e	; 0x334e <_ZN14SoftwareSerial5setTXEh>
    343a:	61 2f       	mov	r22, r17
    343c:	ce 01       	movw	r24, r28
    343e:	df 91       	pop	r29
    3440:	cf 91       	pop	r28
    3442:	1f 91       	pop	r17
    3444:	0c 94 d0 19 	jmp	0x33a0	; 0x33a0 <_ZN14SoftwareSerial5setRXEh>

00003448 <_ZN14SoftwareSerial5beginEl>:
//
// Public methods
//

void SoftwareSerial::begin(long speed)
{
    3448:	cf 93       	push	r28
    344a:	df 93       	push	r29
    344c:	ec 01       	movw	r28, r24
    344e:	9a 01       	movw	r18, r20
    3450:	ab 01       	movw	r20, r22
  _rx_delay_centering = _rx_delay_intrabit = _rx_delay_stopbit = _tx_delay = 0;
    3452:	1b 8e       	std	Y+27, r1	; 0x1b
    3454:	1a 8e       	std	Y+26, r1	; 0x1a
    3456:	19 8e       	std	Y+25, r1	; 0x19
    3458:	18 8e       	std	Y+24, r1	; 0x18
    345a:	1f 8a       	std	Y+23, r1	; 0x17
    345c:	1e 8a       	std	Y+22, r1	; 0x16

  // Precalculate the various delays, in number of 4-cycle delays
  uint16_t bit_delay = (F_CPU / speed) / 4;
    345e:	60 e0       	ldi	r22, 0x00	; 0
    3460:	79 e0       	ldi	r23, 0x09	; 9
    3462:	8d e3       	ldi	r24, 0x3D	; 61
    3464:	90 e0       	ldi	r25, 0x00	; 0
    3466:	0e 94 c4 23 	call	0x4788	; 0x4788 <__divmodsi4>
    346a:	f9 01       	movw	r30, r18
  uint8_t port = digitalPinToPort(rx);
  _receivePortRegister = portInputRegister(port);
}

uint16_t SoftwareSerial::subtract_cap(uint16_t num, uint16_t sub) {
  if (num > sub)
    346c:	24 30       	cpi	r18, 0x04	; 4
    346e:	31 05       	cpc	r19, r1
    3470:	18 f0       	brcs	.+6      	; 0x3478 <_ZN14SoftwareSerial5beginEl+0x30>
    return num - sub;
    3472:	c9 01       	movw	r24, r18
    3474:	03 97       	sbiw	r24, 0x03	; 3
    3476:	02 c0       	rjmp	.+4      	; 0x347c <_ZN14SoftwareSerial5beginEl+0x34>
  else
    return 1;
    3478:	81 e0       	ldi	r24, 0x01	; 1
    347a:	90 e0       	ldi	r25, 0x00	; 0
  // 12 (gcc 4.8.2) or 13 (gcc 4.3.2) cycles from start bit to first bit,
  // 15 (gcc 4.8.2) or 16 (gcc 4.3.2) cycles between bits,
  // 12 (gcc 4.8.2) or 14 (gcc 4.3.2) cycles from last bit to stop bit
  // These are all close enough to just use 15 cycles, since the inter-bit
  // timings are the most critical (deviations stack 8 times)
  _tx_delay = subtract_cap(bit_delay, 15 / 4);
    347c:	9d 8f       	std	Y+29, r25	; 0x1d
    347e:	8c 8f       	std	Y+28, r24	; 0x1c

  // Only setup rx when we have a valid PCINT for this pin
  if (digitalPinToPCICR(_receivePin)) {
    3480:	6c 85       	ldd	r22, Y+12	; 0x0c
    3482:	66 31       	cpi	r22, 0x16	; 22
    3484:	08 f0       	brcs	.+2      	; 0x3488 <_ZN14SoftwareSerial5beginEl+0x40>
    3486:	69 c0       	rjmp	.+210    	; 0x355a <_ZN14SoftwareSerial5beginEl+0x112>
    // are 17 more cycles until the pin value is read (excluding the
    // delay in the loop).
    // We want to have a total delay of 1.5 bit time. Inside the loop,
    // we already wait for 1 bit time - 23 cycles, so here we wait for
    // 0.5 bit time - (71 + 18 - 22) cycles.
    _rx_delay_centering = subtract_cap(bit_delay / 2, (4 + 4 + 75 + 17 - 23) / 4);
    3488:	c9 01       	movw	r24, r18
    348a:	96 95       	lsr	r25
    348c:	87 95       	ror	r24
  uint8_t port = digitalPinToPort(rx);
  _receivePortRegister = portInputRegister(port);
}

uint16_t SoftwareSerial::subtract_cap(uint16_t num, uint16_t sub) {
  if (num > sub)
    348e:	84 31       	cpi	r24, 0x14	; 20
    3490:	91 05       	cpc	r25, r1
    3492:	10 f0       	brcs	.+4      	; 0x3498 <_ZN14SoftwareSerial5beginEl+0x50>
    return num - sub;
    3494:	43 97       	sbiw	r24, 0x13	; 19
    3496:	02 c0       	rjmp	.+4      	; 0x349c <_ZN14SoftwareSerial5beginEl+0x54>
  else
    return 1;
    3498:	81 e0       	ldi	r24, 0x01	; 1
    349a:	90 e0       	ldi	r25, 0x00	; 0
    // are 17 more cycles until the pin value is read (excluding the
    // delay in the loop).
    // We want to have a total delay of 1.5 bit time. Inside the loop,
    // we already wait for 1 bit time - 23 cycles, so here we wait for
    // 0.5 bit time - (71 + 18 - 22) cycles.
    _rx_delay_centering = subtract_cap(bit_delay / 2, (4 + 4 + 75 + 17 - 23) / 4);
    349c:	9f 8b       	std	Y+23, r25	; 0x17
    349e:	8e 8b       	std	Y+22, r24	; 0x16
  uint8_t port = digitalPinToPort(rx);
  _receivePortRegister = portInputRegister(port);
}

uint16_t SoftwareSerial::subtract_cap(uint16_t num, uint16_t sub) {
  if (num > sub)
    34a0:	36 97       	sbiw	r30, 0x06	; 6
    34a2:	18 f0       	brcs	.+6      	; 0x34aa <_ZN14SoftwareSerial5beginEl+0x62>
    return num - sub;
    34a4:	c9 01       	movw	r24, r18
    34a6:	05 97       	sbiw	r24, 0x05	; 5
    34a8:	02 c0       	rjmp	.+4      	; 0x34ae <_ZN14SoftwareSerial5beginEl+0x66>
  else
    return 1;
    34aa:	81 e0       	ldi	r24, 0x01	; 1
    34ac:	90 e0       	ldi	r25, 0x00	; 0
    // we already wait for 1 bit time - 23 cycles, so here we wait for
    // 0.5 bit time - (71 + 18 - 22) cycles.
    _rx_delay_centering = subtract_cap(bit_delay / 2, (4 + 4 + 75 + 17 - 23) / 4);

    // There are 23 cycles in each loop iteration (excluding the delay)
    _rx_delay_intrabit = subtract_cap(bit_delay, 23 / 4);
    34ae:	99 8f       	std	Y+25, r25	; 0x19
    34b0:	88 8f       	std	Y+24, r24	; 0x18
    // mask is enabled again (which _must_ happen during the stopbit).
    // This delay aims at 3/4 of a bit time, meaning the end of the
    // delay will be at 1/4th of the stopbit. This allows some extra
    // time for ISR cleanup, which makes 115200 baud at 16Mhz work more
    // reliably
    _rx_delay_stopbit = subtract_cap(bit_delay * 3 / 4, (37 + 11) / 4);
    34b2:	c9 01       	movw	r24, r18
    34b4:	88 0f       	add	r24, r24
    34b6:	99 1f       	adc	r25, r25
    34b8:	28 0f       	add	r18, r24
    34ba:	39 1f       	adc	r19, r25
    34bc:	36 95       	lsr	r19
    34be:	27 95       	ror	r18
    34c0:	36 95       	lsr	r19
    34c2:	27 95       	ror	r18
  uint8_t port = digitalPinToPort(rx);
  _receivePortRegister = portInputRegister(port);
}

uint16_t SoftwareSerial::subtract_cap(uint16_t num, uint16_t sub) {
  if (num > sub)
    34c4:	2d 30       	cpi	r18, 0x0D	; 13
    34c6:	31 05       	cpc	r19, r1
    34c8:	18 f0       	brcs	.+6      	; 0x34d0 <_ZN14SoftwareSerial5beginEl+0x88>
    return num - sub;
    34ca:	2c 50       	subi	r18, 0x0C	; 12
    34cc:	31 09       	sbc	r19, r1
    34ce:	02 c0       	rjmp	.+4      	; 0x34d4 <_ZN14SoftwareSerial5beginEl+0x8c>
  else
    return 1;
    34d0:	21 e0       	ldi	r18, 0x01	; 1
    34d2:	30 e0       	ldi	r19, 0x00	; 0
    // mask is enabled again (which _must_ happen during the stopbit).
    // This delay aims at 3/4 of a bit time, meaning the end of the
    // delay will be at 1/4th of the stopbit. This allows some extra
    // time for ISR cleanup, which makes 115200 baud at 16Mhz work more
    // reliably
    _rx_delay_stopbit = subtract_cap(bit_delay * 3 / 4, (37 + 11) / 4);
    34d4:	3b 8f       	std	Y+27, r19	; 0x1b
    34d6:	2a 8f       	std	Y+26, r18	; 0x1a


    // Enable the PCINT for the entire port here, but never disable it
    // (others might also need it, so we disable the interrupt by using
    // the per-pin PCMSK register).
    *digitalPinToPCICR(_receivePin) |= _BV(digitalPinToPCICRbit(_receivePin));
    34d8:	90 91 68 00 	lds	r25, 0x0068	; 0x800068 <__DATA_REGION_ORIGIN__+0x8>
    34dc:	68 30       	cpi	r22, 0x08	; 8
    34de:	50 f0       	brcs	.+20     	; 0x34f4 <_ZN14SoftwareSerial5beginEl+0xac>
    34e0:	21 e0       	ldi	r18, 0x01	; 1
    34e2:	6e 30       	cpi	r22, 0x0E	; 14
    34e4:	08 f4       	brcc	.+2      	; 0x34e8 <_ZN14SoftwareSerial5beginEl+0xa0>
    34e6:	20 e0       	ldi	r18, 0x00	; 0
    34e8:	81 e0       	ldi	r24, 0x01	; 1
    34ea:	01 c0       	rjmp	.+2      	; 0x34ee <_ZN14SoftwareSerial5beginEl+0xa6>
    34ec:	88 0f       	add	r24, r24
    34ee:	2a 95       	dec	r18
    34f0:	ea f7       	brpl	.-6      	; 0x34ec <_ZN14SoftwareSerial5beginEl+0xa4>
    34f2:	01 c0       	rjmp	.+2      	; 0x34f6 <_ZN14SoftwareSerial5beginEl+0xae>
    34f4:	84 e0       	ldi	r24, 0x04	; 4
    34f6:	89 2b       	or	r24, r25
    34f8:	80 93 68 00 	sts	0x0068, r24	; 0x800068 <__DATA_REGION_ORIGIN__+0x8>
    // Precalculate the pcint mask register and value, so setRxIntMask
    // can be used inside the ISR without costing too much time.
    _pcint_maskreg = digitalPinToPCMSK(_receivePin);
    34fc:	9c 85       	ldd	r25, Y+12	; 0x0c
    34fe:	98 30       	cpi	r25, 0x08	; 8
    3500:	38 f0       	brcs	.+14     	; 0x3510 <_ZN14SoftwareSerial5beginEl+0xc8>
    3502:	9e 30       	cpi	r25, 0x0E	; 14
    3504:	40 f0       	brcs	.+16     	; 0x3516 <_ZN14SoftwareSerial5beginEl+0xce>
    3506:	96 31       	cpi	r25, 0x16	; 22
    3508:	48 f0       	brcs	.+18     	; 0x351c <_ZN14SoftwareSerial5beginEl+0xd4>
    350a:	20 e0       	ldi	r18, 0x00	; 0
    350c:	30 e0       	ldi	r19, 0x00	; 0
    350e:	08 c0       	rjmp	.+16     	; 0x3520 <_ZN14SoftwareSerial5beginEl+0xd8>
    3510:	2d e6       	ldi	r18, 0x6D	; 109
    3512:	30 e0       	ldi	r19, 0x00	; 0
    3514:	05 c0       	rjmp	.+10     	; 0x3520 <_ZN14SoftwareSerial5beginEl+0xd8>
    3516:	2b e6       	ldi	r18, 0x6B	; 107
    3518:	30 e0       	ldi	r19, 0x00	; 0
    351a:	02 c0       	rjmp	.+4      	; 0x3520 <_ZN14SoftwareSerial5beginEl+0xd8>
    351c:	2c e6       	ldi	r18, 0x6C	; 108
    351e:	30 e0       	ldi	r19, 0x00	; 0
    3520:	3c 8b       	std	Y+20, r19	; 0x14
    3522:	2b 8b       	std	Y+19, r18	; 0x13
    _pcint_maskvalue = _BV(digitalPinToPCMSKbit(_receivePin));
    3524:	98 30       	cpi	r25, 0x08	; 8
    3526:	30 f4       	brcc	.+12     	; 0x3534 <_ZN14SoftwareSerial5beginEl+0xec>
    3528:	81 e0       	ldi	r24, 0x01	; 1
    352a:	01 c0       	rjmp	.+2      	; 0x352e <_ZN14SoftwareSerial5beginEl+0xe6>
    352c:	88 0f       	add	r24, r24
    352e:	9a 95       	dec	r25
    3530:	ea f7       	brpl	.-6      	; 0x352c <_ZN14SoftwareSerial5beginEl+0xe4>
    3532:	0e c0       	rjmp	.+28     	; 0x3550 <_ZN14SoftwareSerial5beginEl+0x108>
    3534:	29 2f       	mov	r18, r25
    3536:	30 e0       	ldi	r19, 0x00	; 0
    3538:	9e 30       	cpi	r25, 0x0E	; 14
    353a:	18 f4       	brcc	.+6      	; 0x3542 <_ZN14SoftwareSerial5beginEl+0xfa>
    353c:	28 50       	subi	r18, 0x08	; 8
    353e:	31 09       	sbc	r19, r1
    3540:	02 c0       	rjmp	.+4      	; 0x3546 <_ZN14SoftwareSerial5beginEl+0xfe>
    3542:	2e 50       	subi	r18, 0x0E	; 14
    3544:	31 09       	sbc	r19, r1
    3546:	81 e0       	ldi	r24, 0x01	; 1
    3548:	01 c0       	rjmp	.+2      	; 0x354c <_ZN14SoftwareSerial5beginEl+0x104>
    354a:	88 0f       	add	r24, r24
    354c:	2a 95       	dec	r18
    354e:	ea f7       	brpl	.-6      	; 0x354a <_ZN14SoftwareSerial5beginEl+0x102>
    3550:	8d 8b       	std	Y+21, r24	; 0x15
	__asm__ volatile (
		"1: sbiw %0,1" "\n\t"
		"brne 1b"
		: "=w" (__count)
		: "0" (__count)
	);
    3552:	8c 8d       	ldd	r24, Y+28	; 0x1c
    3554:	9d 8d       	ldd	r25, Y+29	; 0x1d
    3556:	01 97       	sbiw	r24, 0x01	; 1
    3558:	f1 f7       	brne	.-4      	; 0x3556 <_ZN14SoftwareSerial5beginEl+0x10e>
#if _DEBUG
  pinMode(_DEBUG_PIN1, OUTPUT);
  pinMode(_DEBUG_PIN2, OUTPUT);
#endif

  listen();
    355a:	ce 01       	movw	r24, r28
}
    355c:	df 91       	pop	r29
    355e:	cf 91       	pop	r28
#if _DEBUG
  pinMode(_DEBUG_PIN1, OUTPUT);
  pinMode(_DEBUG_PIN2, OUTPUT);
#endif

  listen();
    3560:	0c 94 fd 18 	jmp	0x31fa	; 0x31fa <_ZN14SoftwareSerial6listenEv>

00003564 <__subsf3>:
    3564:	50 58       	subi	r21, 0x80	; 128

00003566 <__addsf3>:
    3566:	bb 27       	eor	r27, r27
    3568:	aa 27       	eor	r26, r26
    356a:	0e 94 ca 1a 	call	0x3594	; 0x3594 <__addsf3x>
    356e:	0c 94 44 1c 	jmp	0x3888	; 0x3888 <__fp_round>
    3572:	0e 94 36 1c 	call	0x386c	; 0x386c <__fp_pscA>
    3576:	38 f0       	brcs	.+14     	; 0x3586 <__addsf3+0x20>
    3578:	0e 94 3d 1c 	call	0x387a	; 0x387a <__fp_pscB>
    357c:	20 f0       	brcs	.+8      	; 0x3586 <__addsf3+0x20>
    357e:	39 f4       	brne	.+14     	; 0x358e <__addsf3+0x28>
    3580:	9f 3f       	cpi	r25, 0xFF	; 255
    3582:	19 f4       	brne	.+6      	; 0x358a <__addsf3+0x24>
    3584:	26 f4       	brtc	.+8      	; 0x358e <__addsf3+0x28>
    3586:	0c 94 33 1c 	jmp	0x3866	; 0x3866 <__fp_nan>
    358a:	0e f4       	brtc	.+2      	; 0x358e <__addsf3+0x28>
    358c:	e0 95       	com	r30
    358e:	e7 fb       	bst	r30, 7
    3590:	0c 94 2d 1c 	jmp	0x385a	; 0x385a <__fp_inf>

00003594 <__addsf3x>:
    3594:	e9 2f       	mov	r30, r25
    3596:	0e 94 55 1c 	call	0x38aa	; 0x38aa <__fp_split3>
    359a:	58 f3       	brcs	.-42     	; 0x3572 <__addsf3+0xc>
    359c:	ba 17       	cp	r27, r26
    359e:	62 07       	cpc	r22, r18
    35a0:	73 07       	cpc	r23, r19
    35a2:	84 07       	cpc	r24, r20
    35a4:	95 07       	cpc	r25, r21
    35a6:	20 f0       	brcs	.+8      	; 0x35b0 <__addsf3x+0x1c>
    35a8:	79 f4       	brne	.+30     	; 0x35c8 <__addsf3x+0x34>
    35aa:	a6 f5       	brtc	.+104    	; 0x3614 <__addsf3x+0x80>
    35ac:	0c 94 77 1c 	jmp	0x38ee	; 0x38ee <__fp_zero>
    35b0:	0e f4       	brtc	.+2      	; 0x35b4 <__addsf3x+0x20>
    35b2:	e0 95       	com	r30
    35b4:	0b 2e       	mov	r0, r27
    35b6:	ba 2f       	mov	r27, r26
    35b8:	a0 2d       	mov	r26, r0
    35ba:	0b 01       	movw	r0, r22
    35bc:	b9 01       	movw	r22, r18
    35be:	90 01       	movw	r18, r0
    35c0:	0c 01       	movw	r0, r24
    35c2:	ca 01       	movw	r24, r20
    35c4:	a0 01       	movw	r20, r0
    35c6:	11 24       	eor	r1, r1
    35c8:	ff 27       	eor	r31, r31
    35ca:	59 1b       	sub	r21, r25
    35cc:	99 f0       	breq	.+38     	; 0x35f4 <__addsf3x+0x60>
    35ce:	59 3f       	cpi	r21, 0xF9	; 249
    35d0:	50 f4       	brcc	.+20     	; 0x35e6 <__addsf3x+0x52>
    35d2:	50 3e       	cpi	r21, 0xE0	; 224
    35d4:	68 f1       	brcs	.+90     	; 0x3630 <__addsf3x+0x9c>
    35d6:	1a 16       	cp	r1, r26
    35d8:	f0 40       	sbci	r31, 0x00	; 0
    35da:	a2 2f       	mov	r26, r18
    35dc:	23 2f       	mov	r18, r19
    35de:	34 2f       	mov	r19, r20
    35e0:	44 27       	eor	r20, r20
    35e2:	58 5f       	subi	r21, 0xF8	; 248
    35e4:	f3 cf       	rjmp	.-26     	; 0x35cc <__addsf3x+0x38>
    35e6:	46 95       	lsr	r20
    35e8:	37 95       	ror	r19
    35ea:	27 95       	ror	r18
    35ec:	a7 95       	ror	r26
    35ee:	f0 40       	sbci	r31, 0x00	; 0
    35f0:	53 95       	inc	r21
    35f2:	c9 f7       	brne	.-14     	; 0x35e6 <__addsf3x+0x52>
    35f4:	7e f4       	brtc	.+30     	; 0x3614 <__addsf3x+0x80>
    35f6:	1f 16       	cp	r1, r31
    35f8:	ba 0b       	sbc	r27, r26
    35fa:	62 0b       	sbc	r22, r18
    35fc:	73 0b       	sbc	r23, r19
    35fe:	84 0b       	sbc	r24, r20
    3600:	ba f0       	brmi	.+46     	; 0x3630 <__addsf3x+0x9c>
    3602:	91 50       	subi	r25, 0x01	; 1
    3604:	a1 f0       	breq	.+40     	; 0x362e <__addsf3x+0x9a>
    3606:	ff 0f       	add	r31, r31
    3608:	bb 1f       	adc	r27, r27
    360a:	66 1f       	adc	r22, r22
    360c:	77 1f       	adc	r23, r23
    360e:	88 1f       	adc	r24, r24
    3610:	c2 f7       	brpl	.-16     	; 0x3602 <__addsf3x+0x6e>
    3612:	0e c0       	rjmp	.+28     	; 0x3630 <__addsf3x+0x9c>
    3614:	ba 0f       	add	r27, r26
    3616:	62 1f       	adc	r22, r18
    3618:	73 1f       	adc	r23, r19
    361a:	84 1f       	adc	r24, r20
    361c:	48 f4       	brcc	.+18     	; 0x3630 <__addsf3x+0x9c>
    361e:	87 95       	ror	r24
    3620:	77 95       	ror	r23
    3622:	67 95       	ror	r22
    3624:	b7 95       	ror	r27
    3626:	f7 95       	ror	r31
    3628:	9e 3f       	cpi	r25, 0xFE	; 254
    362a:	08 f0       	brcs	.+2      	; 0x362e <__addsf3x+0x9a>
    362c:	b0 cf       	rjmp	.-160    	; 0x358e <__addsf3+0x28>
    362e:	93 95       	inc	r25
    3630:	88 0f       	add	r24, r24
    3632:	08 f0       	brcs	.+2      	; 0x3636 <__addsf3x+0xa2>
    3634:	99 27       	eor	r25, r25
    3636:	ee 0f       	add	r30, r30
    3638:	97 95       	ror	r25
    363a:	87 95       	ror	r24
    363c:	08 95       	ret

0000363e <__cmpsf2>:
    363e:	0e 94 09 1c 	call	0x3812	; 0x3812 <__fp_cmp>
    3642:	08 f4       	brcc	.+2      	; 0x3646 <__cmpsf2+0x8>
    3644:	81 e0       	ldi	r24, 0x01	; 1
    3646:	08 95       	ret

00003648 <__divsf3>:
    3648:	0e 94 38 1b 	call	0x3670	; 0x3670 <__divsf3x>
    364c:	0c 94 44 1c 	jmp	0x3888	; 0x3888 <__fp_round>
    3650:	0e 94 3d 1c 	call	0x387a	; 0x387a <__fp_pscB>
    3654:	58 f0       	brcs	.+22     	; 0x366c <__divsf3+0x24>
    3656:	0e 94 36 1c 	call	0x386c	; 0x386c <__fp_pscA>
    365a:	40 f0       	brcs	.+16     	; 0x366c <__divsf3+0x24>
    365c:	29 f4       	brne	.+10     	; 0x3668 <__divsf3+0x20>
    365e:	5f 3f       	cpi	r21, 0xFF	; 255
    3660:	29 f0       	breq	.+10     	; 0x366c <__divsf3+0x24>
    3662:	0c 94 2d 1c 	jmp	0x385a	; 0x385a <__fp_inf>
    3666:	51 11       	cpse	r21, r1
    3668:	0c 94 78 1c 	jmp	0x38f0	; 0x38f0 <__fp_szero>
    366c:	0c 94 33 1c 	jmp	0x3866	; 0x3866 <__fp_nan>

00003670 <__divsf3x>:
    3670:	0e 94 55 1c 	call	0x38aa	; 0x38aa <__fp_split3>
    3674:	68 f3       	brcs	.-38     	; 0x3650 <__divsf3+0x8>

00003676 <__divsf3_pse>:
    3676:	99 23       	and	r25, r25
    3678:	b1 f3       	breq	.-20     	; 0x3666 <__divsf3+0x1e>
    367a:	55 23       	and	r21, r21
    367c:	91 f3       	breq	.-28     	; 0x3662 <__divsf3+0x1a>
    367e:	95 1b       	sub	r25, r21
    3680:	55 0b       	sbc	r21, r21
    3682:	bb 27       	eor	r27, r27
    3684:	aa 27       	eor	r26, r26
    3686:	62 17       	cp	r22, r18
    3688:	73 07       	cpc	r23, r19
    368a:	84 07       	cpc	r24, r20
    368c:	38 f0       	brcs	.+14     	; 0x369c <__divsf3_pse+0x26>
    368e:	9f 5f       	subi	r25, 0xFF	; 255
    3690:	5f 4f       	sbci	r21, 0xFF	; 255
    3692:	22 0f       	add	r18, r18
    3694:	33 1f       	adc	r19, r19
    3696:	44 1f       	adc	r20, r20
    3698:	aa 1f       	adc	r26, r26
    369a:	a9 f3       	breq	.-22     	; 0x3686 <__divsf3_pse+0x10>
    369c:	35 d0       	rcall	.+106    	; 0x3708 <__divsf3_pse+0x92>
    369e:	0e 2e       	mov	r0, r30
    36a0:	3a f0       	brmi	.+14     	; 0x36b0 <__divsf3_pse+0x3a>
    36a2:	e0 e8       	ldi	r30, 0x80	; 128
    36a4:	32 d0       	rcall	.+100    	; 0x370a <__divsf3_pse+0x94>
    36a6:	91 50       	subi	r25, 0x01	; 1
    36a8:	50 40       	sbci	r21, 0x00	; 0
    36aa:	e6 95       	lsr	r30
    36ac:	00 1c       	adc	r0, r0
    36ae:	ca f7       	brpl	.-14     	; 0x36a2 <__divsf3_pse+0x2c>
    36b0:	2b d0       	rcall	.+86     	; 0x3708 <__divsf3_pse+0x92>
    36b2:	fe 2f       	mov	r31, r30
    36b4:	29 d0       	rcall	.+82     	; 0x3708 <__divsf3_pse+0x92>
    36b6:	66 0f       	add	r22, r22
    36b8:	77 1f       	adc	r23, r23
    36ba:	88 1f       	adc	r24, r24
    36bc:	bb 1f       	adc	r27, r27
    36be:	26 17       	cp	r18, r22
    36c0:	37 07       	cpc	r19, r23
    36c2:	48 07       	cpc	r20, r24
    36c4:	ab 07       	cpc	r26, r27
    36c6:	b0 e8       	ldi	r27, 0x80	; 128
    36c8:	09 f0       	breq	.+2      	; 0x36cc <__divsf3_pse+0x56>
    36ca:	bb 0b       	sbc	r27, r27
    36cc:	80 2d       	mov	r24, r0
    36ce:	bf 01       	movw	r22, r30
    36d0:	ff 27       	eor	r31, r31
    36d2:	93 58       	subi	r25, 0x83	; 131
    36d4:	5f 4f       	sbci	r21, 0xFF	; 255
    36d6:	3a f0       	brmi	.+14     	; 0x36e6 <__divsf3_pse+0x70>
    36d8:	9e 3f       	cpi	r25, 0xFE	; 254
    36da:	51 05       	cpc	r21, r1
    36dc:	78 f0       	brcs	.+30     	; 0x36fc <__divsf3_pse+0x86>
    36de:	0c 94 2d 1c 	jmp	0x385a	; 0x385a <__fp_inf>
    36e2:	0c 94 78 1c 	jmp	0x38f0	; 0x38f0 <__fp_szero>
    36e6:	5f 3f       	cpi	r21, 0xFF	; 255
    36e8:	e4 f3       	brlt	.-8      	; 0x36e2 <__divsf3_pse+0x6c>
    36ea:	98 3e       	cpi	r25, 0xE8	; 232
    36ec:	d4 f3       	brlt	.-12     	; 0x36e2 <__divsf3_pse+0x6c>
    36ee:	86 95       	lsr	r24
    36f0:	77 95       	ror	r23
    36f2:	67 95       	ror	r22
    36f4:	b7 95       	ror	r27
    36f6:	f7 95       	ror	r31
    36f8:	9f 5f       	subi	r25, 0xFF	; 255
    36fa:	c9 f7       	brne	.-14     	; 0x36ee <__divsf3_pse+0x78>
    36fc:	88 0f       	add	r24, r24
    36fe:	91 1d       	adc	r25, r1
    3700:	96 95       	lsr	r25
    3702:	87 95       	ror	r24
    3704:	97 f9       	bld	r25, 7
    3706:	08 95       	ret
    3708:	e1 e0       	ldi	r30, 0x01	; 1
    370a:	66 0f       	add	r22, r22
    370c:	77 1f       	adc	r23, r23
    370e:	88 1f       	adc	r24, r24
    3710:	bb 1f       	adc	r27, r27
    3712:	62 17       	cp	r22, r18
    3714:	73 07       	cpc	r23, r19
    3716:	84 07       	cpc	r24, r20
    3718:	ba 07       	cpc	r27, r26
    371a:	20 f0       	brcs	.+8      	; 0x3724 <__divsf3_pse+0xae>
    371c:	62 1b       	sub	r22, r18
    371e:	73 0b       	sbc	r23, r19
    3720:	84 0b       	sbc	r24, r20
    3722:	ba 0b       	sbc	r27, r26
    3724:	ee 1f       	adc	r30, r30
    3726:	88 f7       	brcc	.-30     	; 0x370a <__divsf3_pse+0x94>
    3728:	e0 95       	com	r30
    372a:	08 95       	ret

0000372c <__fixsfsi>:
    372c:	0e 94 9d 1b 	call	0x373a	; 0x373a <__fixunssfsi>
    3730:	68 94       	set
    3732:	b1 11       	cpse	r27, r1
    3734:	0c 94 78 1c 	jmp	0x38f0	; 0x38f0 <__fp_szero>
    3738:	08 95       	ret

0000373a <__fixunssfsi>:
    373a:	0e 94 5d 1c 	call	0x38ba	; 0x38ba <__fp_splitA>
    373e:	88 f0       	brcs	.+34     	; 0x3762 <__fixunssfsi+0x28>
    3740:	9f 57       	subi	r25, 0x7F	; 127
    3742:	98 f0       	brcs	.+38     	; 0x376a <__fixunssfsi+0x30>
    3744:	b9 2f       	mov	r27, r25
    3746:	99 27       	eor	r25, r25
    3748:	b7 51       	subi	r27, 0x17	; 23
    374a:	b0 f0       	brcs	.+44     	; 0x3778 <__fixunssfsi+0x3e>
    374c:	e1 f0       	breq	.+56     	; 0x3786 <__fixunssfsi+0x4c>
    374e:	66 0f       	add	r22, r22
    3750:	77 1f       	adc	r23, r23
    3752:	88 1f       	adc	r24, r24
    3754:	99 1f       	adc	r25, r25
    3756:	1a f0       	brmi	.+6      	; 0x375e <__fixunssfsi+0x24>
    3758:	ba 95       	dec	r27
    375a:	c9 f7       	brne	.-14     	; 0x374e <__fixunssfsi+0x14>
    375c:	14 c0       	rjmp	.+40     	; 0x3786 <__fixunssfsi+0x4c>
    375e:	b1 30       	cpi	r27, 0x01	; 1
    3760:	91 f0       	breq	.+36     	; 0x3786 <__fixunssfsi+0x4c>
    3762:	0e 94 77 1c 	call	0x38ee	; 0x38ee <__fp_zero>
    3766:	b1 e0       	ldi	r27, 0x01	; 1
    3768:	08 95       	ret
    376a:	0c 94 77 1c 	jmp	0x38ee	; 0x38ee <__fp_zero>
    376e:	67 2f       	mov	r22, r23
    3770:	78 2f       	mov	r23, r24
    3772:	88 27       	eor	r24, r24
    3774:	b8 5f       	subi	r27, 0xF8	; 248
    3776:	39 f0       	breq	.+14     	; 0x3786 <__fixunssfsi+0x4c>
    3778:	b9 3f       	cpi	r27, 0xF9	; 249
    377a:	cc f3       	brlt	.-14     	; 0x376e <__fixunssfsi+0x34>
    377c:	86 95       	lsr	r24
    377e:	77 95       	ror	r23
    3780:	67 95       	ror	r22
    3782:	b3 95       	inc	r27
    3784:	d9 f7       	brne	.-10     	; 0x377c <__fixunssfsi+0x42>
    3786:	3e f4       	brtc	.+14     	; 0x3796 <__fixunssfsi+0x5c>
    3788:	90 95       	com	r25
    378a:	80 95       	com	r24
    378c:	70 95       	com	r23
    378e:	61 95       	neg	r22
    3790:	7f 4f       	sbci	r23, 0xFF	; 255
    3792:	8f 4f       	sbci	r24, 0xFF	; 255
    3794:	9f 4f       	sbci	r25, 0xFF	; 255
    3796:	08 95       	ret

00003798 <__floatunsisf>:
    3798:	e8 94       	clt
    379a:	09 c0       	rjmp	.+18     	; 0x37ae <__floatsisf+0x12>

0000379c <__floatsisf>:
    379c:	97 fb       	bst	r25, 7
    379e:	3e f4       	brtc	.+14     	; 0x37ae <__floatsisf+0x12>
    37a0:	90 95       	com	r25
    37a2:	80 95       	com	r24
    37a4:	70 95       	com	r23
    37a6:	61 95       	neg	r22
    37a8:	7f 4f       	sbci	r23, 0xFF	; 255
    37aa:	8f 4f       	sbci	r24, 0xFF	; 255
    37ac:	9f 4f       	sbci	r25, 0xFF	; 255
    37ae:	99 23       	and	r25, r25
    37b0:	a9 f0       	breq	.+42     	; 0x37dc <__floatsisf+0x40>
    37b2:	f9 2f       	mov	r31, r25
    37b4:	96 e9       	ldi	r25, 0x96	; 150
    37b6:	bb 27       	eor	r27, r27
    37b8:	93 95       	inc	r25
    37ba:	f6 95       	lsr	r31
    37bc:	87 95       	ror	r24
    37be:	77 95       	ror	r23
    37c0:	67 95       	ror	r22
    37c2:	b7 95       	ror	r27
    37c4:	f1 11       	cpse	r31, r1
    37c6:	f8 cf       	rjmp	.-16     	; 0x37b8 <__floatsisf+0x1c>
    37c8:	fa f4       	brpl	.+62     	; 0x3808 <__floatsisf+0x6c>
    37ca:	bb 0f       	add	r27, r27
    37cc:	11 f4       	brne	.+4      	; 0x37d2 <__floatsisf+0x36>
    37ce:	60 ff       	sbrs	r22, 0
    37d0:	1b c0       	rjmp	.+54     	; 0x3808 <__floatsisf+0x6c>
    37d2:	6f 5f       	subi	r22, 0xFF	; 255
    37d4:	7f 4f       	sbci	r23, 0xFF	; 255
    37d6:	8f 4f       	sbci	r24, 0xFF	; 255
    37d8:	9f 4f       	sbci	r25, 0xFF	; 255
    37da:	16 c0       	rjmp	.+44     	; 0x3808 <__floatsisf+0x6c>
    37dc:	88 23       	and	r24, r24
    37de:	11 f0       	breq	.+4      	; 0x37e4 <__floatsisf+0x48>
    37e0:	96 e9       	ldi	r25, 0x96	; 150
    37e2:	11 c0       	rjmp	.+34     	; 0x3806 <__floatsisf+0x6a>
    37e4:	77 23       	and	r23, r23
    37e6:	21 f0       	breq	.+8      	; 0x37f0 <__floatsisf+0x54>
    37e8:	9e e8       	ldi	r25, 0x8E	; 142
    37ea:	87 2f       	mov	r24, r23
    37ec:	76 2f       	mov	r23, r22
    37ee:	05 c0       	rjmp	.+10     	; 0x37fa <__floatsisf+0x5e>
    37f0:	66 23       	and	r22, r22
    37f2:	71 f0       	breq	.+28     	; 0x3810 <__floatsisf+0x74>
    37f4:	96 e8       	ldi	r25, 0x86	; 134
    37f6:	86 2f       	mov	r24, r22
    37f8:	70 e0       	ldi	r23, 0x00	; 0
    37fa:	60 e0       	ldi	r22, 0x00	; 0
    37fc:	2a f0       	brmi	.+10     	; 0x3808 <__floatsisf+0x6c>
    37fe:	9a 95       	dec	r25
    3800:	66 0f       	add	r22, r22
    3802:	77 1f       	adc	r23, r23
    3804:	88 1f       	adc	r24, r24
    3806:	da f7       	brpl	.-10     	; 0x37fe <__floatsisf+0x62>
    3808:	88 0f       	add	r24, r24
    380a:	96 95       	lsr	r25
    380c:	87 95       	ror	r24
    380e:	97 f9       	bld	r25, 7
    3810:	08 95       	ret

00003812 <__fp_cmp>:
    3812:	99 0f       	add	r25, r25
    3814:	00 08       	sbc	r0, r0
    3816:	55 0f       	add	r21, r21
    3818:	aa 0b       	sbc	r26, r26
    381a:	e0 e8       	ldi	r30, 0x80	; 128
    381c:	fe ef       	ldi	r31, 0xFE	; 254
    381e:	16 16       	cp	r1, r22
    3820:	17 06       	cpc	r1, r23
    3822:	e8 07       	cpc	r30, r24
    3824:	f9 07       	cpc	r31, r25
    3826:	c0 f0       	brcs	.+48     	; 0x3858 <__fp_cmp+0x46>
    3828:	12 16       	cp	r1, r18
    382a:	13 06       	cpc	r1, r19
    382c:	e4 07       	cpc	r30, r20
    382e:	f5 07       	cpc	r31, r21
    3830:	98 f0       	brcs	.+38     	; 0x3858 <__fp_cmp+0x46>
    3832:	62 1b       	sub	r22, r18
    3834:	73 0b       	sbc	r23, r19
    3836:	84 0b       	sbc	r24, r20
    3838:	95 0b       	sbc	r25, r21
    383a:	39 f4       	brne	.+14     	; 0x384a <__fp_cmp+0x38>
    383c:	0a 26       	eor	r0, r26
    383e:	61 f0       	breq	.+24     	; 0x3858 <__fp_cmp+0x46>
    3840:	23 2b       	or	r18, r19
    3842:	24 2b       	or	r18, r20
    3844:	25 2b       	or	r18, r21
    3846:	21 f4       	brne	.+8      	; 0x3850 <__fp_cmp+0x3e>
    3848:	08 95       	ret
    384a:	0a 26       	eor	r0, r26
    384c:	09 f4       	brne	.+2      	; 0x3850 <__fp_cmp+0x3e>
    384e:	a1 40       	sbci	r26, 0x01	; 1
    3850:	a6 95       	lsr	r26
    3852:	8f ef       	ldi	r24, 0xFF	; 255
    3854:	81 1d       	adc	r24, r1
    3856:	81 1d       	adc	r24, r1
    3858:	08 95       	ret

0000385a <__fp_inf>:
    385a:	97 f9       	bld	r25, 7
    385c:	9f 67       	ori	r25, 0x7F	; 127
    385e:	80 e8       	ldi	r24, 0x80	; 128
    3860:	70 e0       	ldi	r23, 0x00	; 0
    3862:	60 e0       	ldi	r22, 0x00	; 0
    3864:	08 95       	ret

00003866 <__fp_nan>:
    3866:	9f ef       	ldi	r25, 0xFF	; 255
    3868:	80 ec       	ldi	r24, 0xC0	; 192
    386a:	08 95       	ret

0000386c <__fp_pscA>:
    386c:	00 24       	eor	r0, r0
    386e:	0a 94       	dec	r0
    3870:	16 16       	cp	r1, r22
    3872:	17 06       	cpc	r1, r23
    3874:	18 06       	cpc	r1, r24
    3876:	09 06       	cpc	r0, r25
    3878:	08 95       	ret

0000387a <__fp_pscB>:
    387a:	00 24       	eor	r0, r0
    387c:	0a 94       	dec	r0
    387e:	12 16       	cp	r1, r18
    3880:	13 06       	cpc	r1, r19
    3882:	14 06       	cpc	r1, r20
    3884:	05 06       	cpc	r0, r21
    3886:	08 95       	ret

00003888 <__fp_round>:
    3888:	09 2e       	mov	r0, r25
    388a:	03 94       	inc	r0
    388c:	00 0c       	add	r0, r0
    388e:	11 f4       	brne	.+4      	; 0x3894 <__fp_round+0xc>
    3890:	88 23       	and	r24, r24
    3892:	52 f0       	brmi	.+20     	; 0x38a8 <__fp_round+0x20>
    3894:	bb 0f       	add	r27, r27
    3896:	40 f4       	brcc	.+16     	; 0x38a8 <__fp_round+0x20>
    3898:	bf 2b       	or	r27, r31
    389a:	11 f4       	brne	.+4      	; 0x38a0 <__fp_round+0x18>
    389c:	60 ff       	sbrs	r22, 0
    389e:	04 c0       	rjmp	.+8      	; 0x38a8 <__fp_round+0x20>
    38a0:	6f 5f       	subi	r22, 0xFF	; 255
    38a2:	7f 4f       	sbci	r23, 0xFF	; 255
    38a4:	8f 4f       	sbci	r24, 0xFF	; 255
    38a6:	9f 4f       	sbci	r25, 0xFF	; 255
    38a8:	08 95       	ret

000038aa <__fp_split3>:
    38aa:	57 fd       	sbrc	r21, 7
    38ac:	90 58       	subi	r25, 0x80	; 128
    38ae:	44 0f       	add	r20, r20
    38b0:	55 1f       	adc	r21, r21
    38b2:	59 f0       	breq	.+22     	; 0x38ca <__fp_splitA+0x10>
    38b4:	5f 3f       	cpi	r21, 0xFF	; 255
    38b6:	71 f0       	breq	.+28     	; 0x38d4 <__fp_splitA+0x1a>
    38b8:	47 95       	ror	r20

000038ba <__fp_splitA>:
    38ba:	88 0f       	add	r24, r24
    38bc:	97 fb       	bst	r25, 7
    38be:	99 1f       	adc	r25, r25
    38c0:	61 f0       	breq	.+24     	; 0x38da <__fp_splitA+0x20>
    38c2:	9f 3f       	cpi	r25, 0xFF	; 255
    38c4:	79 f0       	breq	.+30     	; 0x38e4 <__fp_splitA+0x2a>
    38c6:	87 95       	ror	r24
    38c8:	08 95       	ret
    38ca:	12 16       	cp	r1, r18
    38cc:	13 06       	cpc	r1, r19
    38ce:	14 06       	cpc	r1, r20
    38d0:	55 1f       	adc	r21, r21
    38d2:	f2 cf       	rjmp	.-28     	; 0x38b8 <__fp_split3+0xe>
    38d4:	46 95       	lsr	r20
    38d6:	f1 df       	rcall	.-30     	; 0x38ba <__fp_splitA>
    38d8:	08 c0       	rjmp	.+16     	; 0x38ea <__fp_splitA+0x30>
    38da:	16 16       	cp	r1, r22
    38dc:	17 06       	cpc	r1, r23
    38de:	18 06       	cpc	r1, r24
    38e0:	99 1f       	adc	r25, r25
    38e2:	f1 cf       	rjmp	.-30     	; 0x38c6 <__fp_splitA+0xc>
    38e4:	86 95       	lsr	r24
    38e6:	71 05       	cpc	r23, r1
    38e8:	61 05       	cpc	r22, r1
    38ea:	08 94       	sec
    38ec:	08 95       	ret

000038ee <__fp_zero>:
    38ee:	e8 94       	clt

000038f0 <__fp_szero>:
    38f0:	bb 27       	eor	r27, r27
    38f2:	66 27       	eor	r22, r22
    38f4:	77 27       	eor	r23, r23
    38f6:	cb 01       	movw	r24, r22
    38f8:	97 f9       	bld	r25, 7
    38fa:	08 95       	ret

000038fc <__mulsf3>:
    38fc:	0e 94 91 1c 	call	0x3922	; 0x3922 <__mulsf3x>
    3900:	0c 94 44 1c 	jmp	0x3888	; 0x3888 <__fp_round>
    3904:	0e 94 36 1c 	call	0x386c	; 0x386c <__fp_pscA>
    3908:	38 f0       	brcs	.+14     	; 0x3918 <__mulsf3+0x1c>
    390a:	0e 94 3d 1c 	call	0x387a	; 0x387a <__fp_pscB>
    390e:	20 f0       	brcs	.+8      	; 0x3918 <__mulsf3+0x1c>
    3910:	95 23       	and	r25, r21
    3912:	11 f0       	breq	.+4      	; 0x3918 <__mulsf3+0x1c>
    3914:	0c 94 2d 1c 	jmp	0x385a	; 0x385a <__fp_inf>
    3918:	0c 94 33 1c 	jmp	0x3866	; 0x3866 <__fp_nan>
    391c:	11 24       	eor	r1, r1
    391e:	0c 94 78 1c 	jmp	0x38f0	; 0x38f0 <__fp_szero>

00003922 <__mulsf3x>:
    3922:	0e 94 55 1c 	call	0x38aa	; 0x38aa <__fp_split3>
    3926:	70 f3       	brcs	.-36     	; 0x3904 <__mulsf3+0x8>

00003928 <__mulsf3_pse>:
    3928:	95 9f       	mul	r25, r21
    392a:	c1 f3       	breq	.-16     	; 0x391c <__mulsf3+0x20>
    392c:	95 0f       	add	r25, r21
    392e:	50 e0       	ldi	r21, 0x00	; 0
    3930:	55 1f       	adc	r21, r21
    3932:	62 9f       	mul	r22, r18
    3934:	f0 01       	movw	r30, r0
    3936:	72 9f       	mul	r23, r18
    3938:	bb 27       	eor	r27, r27
    393a:	f0 0d       	add	r31, r0
    393c:	b1 1d       	adc	r27, r1
    393e:	63 9f       	mul	r22, r19
    3940:	aa 27       	eor	r26, r26
    3942:	f0 0d       	add	r31, r0
    3944:	b1 1d       	adc	r27, r1
    3946:	aa 1f       	adc	r26, r26
    3948:	64 9f       	mul	r22, r20
    394a:	66 27       	eor	r22, r22
    394c:	b0 0d       	add	r27, r0
    394e:	a1 1d       	adc	r26, r1
    3950:	66 1f       	adc	r22, r22
    3952:	82 9f       	mul	r24, r18
    3954:	22 27       	eor	r18, r18
    3956:	b0 0d       	add	r27, r0
    3958:	a1 1d       	adc	r26, r1
    395a:	62 1f       	adc	r22, r18
    395c:	73 9f       	mul	r23, r19
    395e:	b0 0d       	add	r27, r0
    3960:	a1 1d       	adc	r26, r1
    3962:	62 1f       	adc	r22, r18
    3964:	83 9f       	mul	r24, r19
    3966:	a0 0d       	add	r26, r0
    3968:	61 1d       	adc	r22, r1
    396a:	22 1f       	adc	r18, r18
    396c:	74 9f       	mul	r23, r20
    396e:	33 27       	eor	r19, r19
    3970:	a0 0d       	add	r26, r0
    3972:	61 1d       	adc	r22, r1
    3974:	23 1f       	adc	r18, r19
    3976:	84 9f       	mul	r24, r20
    3978:	60 0d       	add	r22, r0
    397a:	21 1d       	adc	r18, r1
    397c:	82 2f       	mov	r24, r18
    397e:	76 2f       	mov	r23, r22
    3980:	6a 2f       	mov	r22, r26
    3982:	11 24       	eor	r1, r1
    3984:	9f 57       	subi	r25, 0x7F	; 127
    3986:	50 40       	sbci	r21, 0x00	; 0
    3988:	9a f0       	brmi	.+38     	; 0x39b0 <__mulsf3_pse+0x88>
    398a:	f1 f0       	breq	.+60     	; 0x39c8 <__mulsf3_pse+0xa0>
    398c:	88 23       	and	r24, r24
    398e:	4a f0       	brmi	.+18     	; 0x39a2 <__mulsf3_pse+0x7a>
    3990:	ee 0f       	add	r30, r30
    3992:	ff 1f       	adc	r31, r31
    3994:	bb 1f       	adc	r27, r27
    3996:	66 1f       	adc	r22, r22
    3998:	77 1f       	adc	r23, r23
    399a:	88 1f       	adc	r24, r24
    399c:	91 50       	subi	r25, 0x01	; 1
    399e:	50 40       	sbci	r21, 0x00	; 0
    39a0:	a9 f7       	brne	.-22     	; 0x398c <__mulsf3_pse+0x64>
    39a2:	9e 3f       	cpi	r25, 0xFE	; 254
    39a4:	51 05       	cpc	r21, r1
    39a6:	80 f0       	brcs	.+32     	; 0x39c8 <__mulsf3_pse+0xa0>
    39a8:	0c 94 2d 1c 	jmp	0x385a	; 0x385a <__fp_inf>
    39ac:	0c 94 78 1c 	jmp	0x38f0	; 0x38f0 <__fp_szero>
    39b0:	5f 3f       	cpi	r21, 0xFF	; 255
    39b2:	e4 f3       	brlt	.-8      	; 0x39ac <__mulsf3_pse+0x84>
    39b4:	98 3e       	cpi	r25, 0xE8	; 232
    39b6:	d4 f3       	brlt	.-12     	; 0x39ac <__mulsf3_pse+0x84>
    39b8:	86 95       	lsr	r24
    39ba:	77 95       	ror	r23
    39bc:	67 95       	ror	r22
    39be:	b7 95       	ror	r27
    39c0:	f7 95       	ror	r31
    39c2:	e7 95       	ror	r30
    39c4:	9f 5f       	subi	r25, 0xFF	; 255
    39c6:	c1 f7       	brne	.-16     	; 0x39b8 <__mulsf3_pse+0x90>
    39c8:	fe 2b       	or	r31, r30
    39ca:	88 0f       	add	r24, r24
    39cc:	91 1d       	adc	r25, r1
    39ce:	96 95       	lsr	r25
    39d0:	87 95       	ror	r24
    39d2:	97 f9       	bld	r25, 7
    39d4:	08 95       	ret

000039d6 <_ZN14HardwareSerial9availableEv>:
  // clear any received data
  _rx_buffer_head = _rx_buffer_tail;
}

int HardwareSerial::available(void)
{
    39d6:	fc 01       	movw	r30, r24
  return ((unsigned int)(SERIAL_RX_BUFFER_SIZE + _rx_buffer_head - _rx_buffer_tail)) % SERIAL_RX_BUFFER_SIZE;
    39d8:	91 8d       	ldd	r25, Z+25	; 0x19
    39da:	22 8d       	ldd	r18, Z+26	; 0x1a
    39dc:	89 2f       	mov	r24, r25
    39de:	90 e0       	ldi	r25, 0x00	; 0
    39e0:	80 5c       	subi	r24, 0xC0	; 192
    39e2:	9f 4f       	sbci	r25, 0xFF	; 255
    39e4:	82 1b       	sub	r24, r18
    39e6:	91 09       	sbc	r25, r1
}
    39e8:	8f 73       	andi	r24, 0x3F	; 63
    39ea:	99 27       	eor	r25, r25
    39ec:	08 95       	ret

000039ee <_ZN14HardwareSerial4peekEv>:

int HardwareSerial::peek(void)
{
    39ee:	fc 01       	movw	r30, r24
  if (_rx_buffer_head == _rx_buffer_tail) {
    39f0:	91 8d       	ldd	r25, Z+25	; 0x19
    39f2:	82 8d       	ldd	r24, Z+26	; 0x1a
    39f4:	98 17       	cp	r25, r24
    39f6:	31 f0       	breq	.+12     	; 0x3a04 <_ZN14HardwareSerial4peekEv+0x16>
    return -1;
  } else {
    return _rx_buffer[_rx_buffer_tail];
    39f8:	82 8d       	ldd	r24, Z+26	; 0x1a
    39fa:	e8 0f       	add	r30, r24
    39fc:	f1 1d       	adc	r31, r1
    39fe:	85 8d       	ldd	r24, Z+29	; 0x1d
    3a00:	90 e0       	ldi	r25, 0x00	; 0
    3a02:	08 95       	ret
}

int HardwareSerial::peek(void)
{
  if (_rx_buffer_head == _rx_buffer_tail) {
    return -1;
    3a04:	8f ef       	ldi	r24, 0xFF	; 255
    3a06:	9f ef       	ldi	r25, 0xFF	; 255
  } else {
    return _rx_buffer[_rx_buffer_tail];
  }
}
    3a08:	08 95       	ret

00003a0a <_ZN14HardwareSerial4readEv>:

int HardwareSerial::read(void)
{
    3a0a:	fc 01       	movw	r30, r24
  // if the head isn't ahead of the tail, we don't have any characters
  if (_rx_buffer_head == _rx_buffer_tail) {
    3a0c:	91 8d       	ldd	r25, Z+25	; 0x19
    3a0e:	82 8d       	ldd	r24, Z+26	; 0x1a
    3a10:	98 17       	cp	r25, r24
    3a12:	61 f0       	breq	.+24     	; 0x3a2c <_ZN14HardwareSerial4readEv+0x22>
    return -1;
  } else {
    unsigned char c = _rx_buffer[_rx_buffer_tail];
    3a14:	82 8d       	ldd	r24, Z+26	; 0x1a
    3a16:	df 01       	movw	r26, r30
    3a18:	a8 0f       	add	r26, r24
    3a1a:	b1 1d       	adc	r27, r1
    3a1c:	5d 96       	adiw	r26, 0x1d	; 29
    3a1e:	8c 91       	ld	r24, X
    _rx_buffer_tail = (rx_buffer_index_t)(_rx_buffer_tail + 1) % SERIAL_RX_BUFFER_SIZE;
    3a20:	92 8d       	ldd	r25, Z+26	; 0x1a
    3a22:	9f 5f       	subi	r25, 0xFF	; 255
    3a24:	9f 73       	andi	r25, 0x3F	; 63
    3a26:	92 8f       	std	Z+26, r25	; 0x1a
    return c;
    3a28:	90 e0       	ldi	r25, 0x00	; 0
    3a2a:	08 95       	ret

int HardwareSerial::read(void)
{
  // if the head isn't ahead of the tail, we don't have any characters
  if (_rx_buffer_head == _rx_buffer_tail) {
    return -1;
    3a2c:	8f ef       	ldi	r24, 0xFF	; 255
    3a2e:	9f ef       	ldi	r25, 0xFF	; 255
  } else {
    unsigned char c = _rx_buffer[_rx_buffer_tail];
    _rx_buffer_tail = (rx_buffer_index_t)(_rx_buffer_tail + 1) % SERIAL_RX_BUFFER_SIZE;
    return c;
  }
}
    3a30:	08 95       	ret

00003a32 <_ZN14HardwareSerial17availableForWriteEv>:
{
  tx_buffer_index_t head;
  tx_buffer_index_t tail;

  TX_BUFFER_ATOMIC {
    head = _tx_buffer_head;
    3a32:	fc 01       	movw	r30, r24
    3a34:	53 8d       	ldd	r21, Z+27	; 0x1b
    tail = _tx_buffer_tail;
    3a36:	44 8d       	ldd	r20, Z+28	; 0x1c
    3a38:	25 2f       	mov	r18, r21
    3a3a:	30 e0       	ldi	r19, 0x00	; 0
    3a3c:	84 2f       	mov	r24, r20
    3a3e:	90 e0       	ldi	r25, 0x00	; 0
  }
  if (head >= tail) return SERIAL_TX_BUFFER_SIZE - 1 - head + tail;
    3a40:	82 1b       	sub	r24, r18
    3a42:	93 0b       	sbc	r25, r19
    3a44:	54 17       	cp	r21, r20
    3a46:	10 f0       	brcs	.+4      	; 0x3a4c <_ZN14HardwareSerial17availableForWriteEv+0x1a>
    3a48:	cf 96       	adiw	r24, 0x3f	; 63
    3a4a:	08 95       	ret
  return tail - head - 1;
    3a4c:	01 97       	sbiw	r24, 0x01	; 1
}
    3a4e:	08 95       	ret

00003a50 <_Z14serialEventRunv>:
#endif

void serialEventRun(void)
{
#if defined(HAVE_HWSERIAL0)
  if (Serial0_available && serialEvent && Serial0_available()) serialEvent();
    3a50:	84 e8       	ldi	r24, 0x84	; 132
    3a52:	9e e1       	ldi	r25, 0x1E	; 30
    3a54:	89 2b       	or	r24, r25
    3a56:	49 f0       	breq	.+18     	; 0x3a6a <_Z14serialEventRunv+0x1a>
    3a58:	80 e0       	ldi	r24, 0x00	; 0
    3a5a:	90 e0       	ldi	r25, 0x00	; 0
    3a5c:	89 2b       	or	r24, r25
    3a5e:	29 f0       	breq	.+10     	; 0x3a6a <_Z14serialEventRunv+0x1a>
    3a60:	0e 94 84 1e 	call	0x3d08	; 0x3d08 <_Z17Serial0_availablev>
    3a64:	81 11       	cpse	r24, r1
    3a66:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>
    3a6a:	08 95       	ret

00003a6c <_ZN14HardwareSerial17_tx_udr_empty_irqEv>:
#endif

// Actual interrupt handlers //////////////////////////////////////////////////////////////

void HardwareSerial::_tx_udr_empty_irq(void)
{
    3a6c:	fc 01       	movw	r30, r24
  // If interrupts are enabled, there must be more data in the output
  // buffer. Send the next byte
  unsigned char c = _tx_buffer[_tx_buffer_tail];
    3a6e:	84 8d       	ldd	r24, Z+28	; 0x1c
    3a70:	df 01       	movw	r26, r30
    3a72:	a8 0f       	add	r26, r24
    3a74:	b1 1d       	adc	r27, r1
    3a76:	a3 5a       	subi	r26, 0xA3	; 163
    3a78:	bf 4f       	sbci	r27, 0xFF	; 255
    3a7a:	2c 91       	ld	r18, X
  _tx_buffer_tail = (_tx_buffer_tail + 1) % SERIAL_TX_BUFFER_SIZE;
    3a7c:	84 8d       	ldd	r24, Z+28	; 0x1c
    3a7e:	90 e0       	ldi	r25, 0x00	; 0
    3a80:	01 96       	adiw	r24, 0x01	; 1
    3a82:	8f 73       	andi	r24, 0x3F	; 63
    3a84:	99 27       	eor	r25, r25
    3a86:	84 8f       	std	Z+28, r24	; 0x1c

  *_udr = c;
    3a88:	a6 89       	ldd	r26, Z+22	; 0x16
    3a8a:	b7 89       	ldd	r27, Z+23	; 0x17
    3a8c:	2c 93       	st	X, r18
  // location". This makes sure flush() won't return until the bytes
  // actually got written. Other r/w bits are preserved, and zeroes
  // written to the rest.

#ifdef MPCM0
  *_ucsra = ((*_ucsra) & ((1 << U2X0) | (1 << MPCM0))) | (1 << TXC0);
    3a8e:	a0 89       	ldd	r26, Z+16	; 0x10
    3a90:	b1 89       	ldd	r27, Z+17	; 0x11
    3a92:	8c 91       	ld	r24, X
    3a94:	83 70       	andi	r24, 0x03	; 3
    3a96:	80 64       	ori	r24, 0x40	; 64
    3a98:	8c 93       	st	X, r24
#else
  *_ucsra = ((*_ucsra) & ((1 << U2X0) | (1 << TXC0)));
#endif

  if (_tx_buffer_head == _tx_buffer_tail) {
    3a9a:	93 8d       	ldd	r25, Z+27	; 0x1b
    3a9c:	84 8d       	ldd	r24, Z+28	; 0x1c
    3a9e:	98 13       	cpse	r25, r24
    3aa0:	06 c0       	rjmp	.+12     	; 0x3aae <_ZN14HardwareSerial17_tx_udr_empty_irqEv+0x42>
    // Buffer empty, so disable interrupts
    cbi(*_ucsrb, UDRIE0);
    3aa2:	02 88       	ldd	r0, Z+18	; 0x12
    3aa4:	f3 89       	ldd	r31, Z+19	; 0x13
    3aa6:	e0 2d       	mov	r30, r0
    3aa8:	80 81       	ld	r24, Z
    3aaa:	8f 7d       	andi	r24, 0xDF	; 223
    3aac:	80 83       	st	Z, r24
    3aae:	08 95       	ret

00003ab0 <_ZN14HardwareSerial5writeEh>:
  // If we get here, nothing is queued anymore (DRIE is disabled) and
  // the hardware finished tranmission (TXC is set).
}

size_t HardwareSerial::write(uint8_t c)
{
    3ab0:	ef 92       	push	r14
    3ab2:	ff 92       	push	r15
    3ab4:	0f 93       	push	r16
    3ab6:	1f 93       	push	r17
    3ab8:	cf 93       	push	r28
    3aba:	df 93       	push	r29
    3abc:	ec 01       	movw	r28, r24
  _written = true;
    3abe:	81 e0       	ldi	r24, 0x01	; 1
    3ac0:	88 8f       	std	Y+24, r24	; 0x18
  // If the buffer and the data register is empty, just write the byte
  // to the data register and be done. This shortcut helps
  // significantly improve the effective datarate at high (>
  // 500kbit/s) bitrates, where interrupt overhead becomes a slowdown.
  if (_tx_buffer_head == _tx_buffer_tail && bit_is_set(*_ucsra, UDRE0)) {
    3ac2:	9b 8d       	ldd	r25, Y+27	; 0x1b
    3ac4:	8c 8d       	ldd	r24, Y+28	; 0x1c
    3ac6:	98 13       	cpse	r25, r24
    3ac8:	05 c0       	rjmp	.+10     	; 0x3ad4 <_ZN14HardwareSerial5writeEh+0x24>
    3aca:	e8 89       	ldd	r30, Y+16	; 0x10
    3acc:	f9 89       	ldd	r31, Y+17	; 0x11
    3ace:	80 81       	ld	r24, Z
    3ad0:	85 fd       	sbrc	r24, 5
    3ad2:	26 c0       	rjmp	.+76     	; 0x3b20 <_ZN14HardwareSerial5writeEh+0x70>
    3ad4:	f6 2e       	mov	r15, r22
      *_ucsra = ((*_ucsra) & ((1 << U2X0) | (1 << TXC0)));
#endif
    }
    return 1;
  }
  tx_buffer_index_t i = (_tx_buffer_head + 1) % SERIAL_TX_BUFFER_SIZE;
    3ad6:	0b 8d       	ldd	r16, Y+27	; 0x1b
    3ad8:	10 e0       	ldi	r17, 0x00	; 0
    3ada:	0f 5f       	subi	r16, 0xFF	; 255
    3adc:	1f 4f       	sbci	r17, 0xFF	; 255
    3ade:	0f 73       	andi	r16, 0x3F	; 63
    3ae0:	11 27       	eor	r17, r17
    3ae2:	e0 2e       	mov	r14, r16
	
  // If the output buffer is full, there's nothing for it other than to 
  // wait for the interrupt handler to empty it a bit
  while (i == _tx_buffer_tail) {
    3ae4:	8c 8d       	ldd	r24, Y+28	; 0x1c
    3ae6:	e8 12       	cpse	r14, r24
    3ae8:	0c c0       	rjmp	.+24     	; 0x3b02 <_ZN14HardwareSerial5writeEh+0x52>
    if (bit_is_clear(SREG, SREG_I)) {
    3aea:	0f b6       	in	r0, 0x3f	; 63
    3aec:	07 fc       	sbrc	r0, 7
    3aee:	fa cf       	rjmp	.-12     	; 0x3ae4 <_ZN14HardwareSerial5writeEh+0x34>
      // Interrupts are disabled, so we'll have to poll the data
      // register empty flag ourselves. If it is set, pretend an
      // interrupt has happened and call the handler to free up
      // space for us.
      if(bit_is_set(*_ucsra, UDRE0))
    3af0:	e8 89       	ldd	r30, Y+16	; 0x10
    3af2:	f9 89       	ldd	r31, Y+17	; 0x11
    3af4:	80 81       	ld	r24, Z
    3af6:	85 ff       	sbrs	r24, 5
    3af8:	f5 cf       	rjmp	.-22     	; 0x3ae4 <_ZN14HardwareSerial5writeEh+0x34>
	_tx_udr_empty_irq();
    3afa:	ce 01       	movw	r24, r28
    3afc:	0e 94 36 1d 	call	0x3a6c	; 0x3a6c <_ZN14HardwareSerial17_tx_udr_empty_irqEv>
    3b00:	f1 cf       	rjmp	.-30     	; 0x3ae4 <_ZN14HardwareSerial5writeEh+0x34>
    } else {
      // nop, the interrupt handler will free up space for us
    }
  }

  _tx_buffer[_tx_buffer_head] = c;
    3b02:	8b 8d       	ldd	r24, Y+27	; 0x1b
    3b04:	fe 01       	movw	r30, r28
    3b06:	e8 0f       	add	r30, r24
    3b08:	f1 1d       	adc	r31, r1
    3b0a:	e3 5a       	subi	r30, 0xA3	; 163
    3b0c:	ff 4f       	sbci	r31, 0xFF	; 255
    3b0e:	f0 82       	st	Z, r15

  // make atomic to prevent execution of ISR between setting the
  // head pointer and setting the interrupt flag resulting in buffer
  // retransmission
  ATOMIC_BLOCK(ATOMIC_RESTORESTATE) {
    3b10:	9f b7       	in	r25, 0x3f	; 63
    return 1;
}

static __inline__ uint8_t __iCliRetVal(void)
{
    cli();
    3b12:	f8 94       	cli
    _tx_buffer_head = i;
    3b14:	0b 8f       	std	Y+27, r16	; 0x1b
    sbi(*_ucsrb, UDRIE0);
    3b16:	ea 89       	ldd	r30, Y+18	; 0x12
    3b18:	fb 89       	ldd	r31, Y+19	; 0x13
    3b1a:	80 81       	ld	r24, Z
    3b1c:	80 62       	ori	r24, 0x20	; 32
    3b1e:	0a c0       	rjmp	.+20     	; 0x3b34 <_ZN14HardwareSerial5writeEh+0x84>
    // So writing UDR must happen first.
    // Writing UDR and clearing TC must be done atomically, otherwise
    // interrupts might delay the TXC clear so the byte written to UDR
    // is transmitted (setting TXC) before clearing TXC. Then TXC will
    // be cleared when no bytes are left, causing flush() to hang
    ATOMIC_BLOCK(ATOMIC_RESTORESTATE) {
    3b20:	9f b7       	in	r25, 0x3f	; 63
    3b22:	f8 94       	cli
      *_udr = c;
    3b24:	ee 89       	ldd	r30, Y+22	; 0x16
    3b26:	ff 89       	ldd	r31, Y+23	; 0x17
    3b28:	60 83       	st	Z, r22
#ifdef MPCM0
      *_ucsra = ((*_ucsra) & ((1 << U2X0) | (1 << MPCM0))) | (1 << TXC0);
    3b2a:	e8 89       	ldd	r30, Y+16	; 0x10
    3b2c:	f9 89       	ldd	r31, Y+17	; 0x11
    3b2e:	80 81       	ld	r24, Z
    3b30:	83 70       	andi	r24, 0x03	; 3
    3b32:	80 64       	ori	r24, 0x40	; 64
    3b34:	80 83       	st	Z, r24
    (void)__s;
}

static __inline__ void __iRestore(const  uint8_t *__s)
{
    SREG = *__s;
    3b36:	9f bf       	out	0x3f, r25	; 63
    _tx_buffer_head = i;
    sbi(*_ucsrb, UDRIE0);
  }
  
  return 1;
}
    3b38:	81 e0       	ldi	r24, 0x01	; 1
    3b3a:	90 e0       	ldi	r25, 0x00	; 0
    3b3c:	df 91       	pop	r29
    3b3e:	cf 91       	pop	r28
    3b40:	1f 91       	pop	r17
    3b42:	0f 91       	pop	r16
    3b44:	ff 90       	pop	r15
    3b46:	ef 90       	pop	r14
    3b48:	08 95       	ret

00003b4a <_ZN14HardwareSerial5flushEv>:
  if (head >= tail) return SERIAL_TX_BUFFER_SIZE - 1 - head + tail;
  return tail - head - 1;
}

void HardwareSerial::flush()
{
    3b4a:	cf 93       	push	r28
    3b4c:	df 93       	push	r29
    3b4e:	ec 01       	movw	r28, r24
  // If we have never written a byte, no need to flush. This special
  // case is needed since there is no way to force the TXC (transmit
  // complete) bit to 1 during initialization
  if (!_written)
    3b50:	88 8d       	ldd	r24, Y+24	; 0x18
    3b52:	88 23       	and	r24, r24
    3b54:	c9 f0       	breq	.+50     	; 0x3b88 <_ZN14HardwareSerial5flushEv+0x3e>
    return;

  while (bit_is_set(*_ucsrb, UDRIE0) || bit_is_clear(*_ucsra, TXC0)) {
    3b56:	ea 89       	ldd	r30, Y+18	; 0x12
    3b58:	fb 89       	ldd	r31, Y+19	; 0x13
    3b5a:	80 81       	ld	r24, Z
    3b5c:	85 fd       	sbrc	r24, 5
    3b5e:	05 c0       	rjmp	.+10     	; 0x3b6a <_ZN14HardwareSerial5flushEv+0x20>
    3b60:	a8 89       	ldd	r26, Y+16	; 0x10
    3b62:	b9 89       	ldd	r27, Y+17	; 0x11
    3b64:	8c 91       	ld	r24, X
    3b66:	86 fd       	sbrc	r24, 6
    3b68:	0f c0       	rjmp	.+30     	; 0x3b88 <_ZN14HardwareSerial5flushEv+0x3e>
    if (bit_is_clear(SREG, SREG_I) && bit_is_set(*_ucsrb, UDRIE0))
    3b6a:	0f b6       	in	r0, 0x3f	; 63
    3b6c:	07 fc       	sbrc	r0, 7
    3b6e:	f5 cf       	rjmp	.-22     	; 0x3b5a <_ZN14HardwareSerial5flushEv+0x10>
    3b70:	80 81       	ld	r24, Z
    3b72:	85 ff       	sbrs	r24, 5
    3b74:	f2 cf       	rjmp	.-28     	; 0x3b5a <_ZN14HardwareSerial5flushEv+0x10>
	// Interrupts are globally disabled, but the DR empty
	// interrupt should be enabled, so poll the DR empty flag to
	// prevent deadlock
	if (bit_is_set(*_ucsra, UDRE0))
    3b76:	a8 89       	ldd	r26, Y+16	; 0x10
    3b78:	b9 89       	ldd	r27, Y+17	; 0x11
    3b7a:	8c 91       	ld	r24, X
    3b7c:	85 ff       	sbrs	r24, 5
    3b7e:	ed cf       	rjmp	.-38     	; 0x3b5a <_ZN14HardwareSerial5flushEv+0x10>
	  _tx_udr_empty_irq();
    3b80:	ce 01       	movw	r24, r28
    3b82:	0e 94 36 1d 	call	0x3a6c	; 0x3a6c <_ZN14HardwareSerial17_tx_udr_empty_irqEv>
    3b86:	e7 cf       	rjmp	.-50     	; 0x3b56 <_ZN14HardwareSerial5flushEv+0xc>
  }
  // If we get here, nothing is queued anymore (DRIE is disabled) and
  // the hardware finished tranmission (TXC is set).
}
    3b88:	df 91       	pop	r29
    3b8a:	cf 91       	pop	r28
    3b8c:	08 95       	ret

00003b8e <_ZN14HardwareSerial5beginEmh>:
}

// Public Methods //////////////////////////////////////////////////////////////

void HardwareSerial::begin(unsigned long baud, byte config)
{
    3b8e:	cf 92       	push	r12
    3b90:	df 92       	push	r13
    3b92:	ef 92       	push	r14
    3b94:	ff 92       	push	r15
    3b96:	1f 93       	push	r17
    3b98:	cf 93       	push	r28
    3b9a:	df 93       	push	r29
    3b9c:	ec 01       	movw	r28, r24
    3b9e:	6a 01       	movw	r12, r20
    3ba0:	7b 01       	movw	r14, r22
    3ba2:	12 2f       	mov	r17, r18
  // Try u2x mode first
  uint16_t baud_setting = (F_CPU / 4 / baud - 1) / 2;
  *_ucsra = 1 << U2X0;
    3ba4:	e8 89       	ldd	r30, Y+16	; 0x10
    3ba6:	f9 89       	ldd	r31, Y+17	; 0x11
    3ba8:	82 e0       	ldi	r24, 0x02	; 2
    3baa:	80 83       	st	Z, r24
  // hardcoded exception for 57600 for compatibility with the bootloader
  // shipped with the Duemilanove and previous boards and the firmware
  // on the 8U2 on the Uno and Mega 2560. Also, The baud_setting cannot
  // be > 4095, so switch back to non-u2x mode if the baud rate is too
  // low.
  if (((F_CPU == 16000000UL) && (baud == 57600)) || (baud_setting >4095))
    3bac:	41 15       	cp	r20, r1
    3bae:	51 4e       	sbci	r21, 0xE1	; 225
    3bb0:	61 05       	cpc	r22, r1
    3bb2:	71 05       	cpc	r23, r1
    3bb4:	b1 f0       	breq	.+44     	; 0x3be2 <_ZN14HardwareSerial5beginEmh+0x54>
// Public Methods //////////////////////////////////////////////////////////////

void HardwareSerial::begin(unsigned long baud, byte config)
{
  // Try u2x mode first
  uint16_t baud_setting = (F_CPU / 4 / baud - 1) / 2;
    3bb6:	60 e0       	ldi	r22, 0x00	; 0
    3bb8:	79 e0       	ldi	r23, 0x09	; 9
    3bba:	8d e3       	ldi	r24, 0x3D	; 61
    3bbc:	90 e0       	ldi	r25, 0x00	; 0
    3bbe:	a7 01       	movw	r20, r14
    3bc0:	96 01       	movw	r18, r12
    3bc2:	0e 94 a2 23 	call	0x4744	; 0x4744 <__udivmodsi4>
    3bc6:	da 01       	movw	r26, r20
    3bc8:	c9 01       	movw	r24, r18
    3bca:	01 97       	sbiw	r24, 0x01	; 1
    3bcc:	a1 09       	sbc	r26, r1
    3bce:	b1 09       	sbc	r27, r1
    3bd0:	b6 95       	lsr	r27
    3bd2:	a7 95       	ror	r26
    3bd4:	97 95       	ror	r25
    3bd6:	87 95       	ror	r24
    3bd8:	9c 01       	movw	r18, r24
  // hardcoded exception for 57600 for compatibility with the bootloader
  // shipped with the Duemilanove and previous boards and the firmware
  // on the 8U2 on the Uno and Mega 2560. Also, The baud_setting cannot
  // be > 4095, so switch back to non-u2x mode if the baud rate is too
  // low.
  if (((F_CPU == 16000000UL) && (baud == 57600)) || (baud_setting >4095))
    3bda:	21 15       	cp	r18, r1
    3bdc:	80 e1       	ldi	r24, 0x10	; 16
    3bde:	38 07       	cpc	r19, r24
    3be0:	a8 f0       	brcs	.+42     	; 0x3c0c <_ZN14HardwareSerial5beginEmh+0x7e>
  {
    *_ucsra = 0;
    3be2:	e8 89       	ldd	r30, Y+16	; 0x10
    3be4:	f9 89       	ldd	r31, Y+17	; 0x11
    3be6:	10 82       	st	Z, r1
    baud_setting = (F_CPU / 8 / baud - 1) / 2;
    3be8:	60 e8       	ldi	r22, 0x80	; 128
    3bea:	74 e8       	ldi	r23, 0x84	; 132
    3bec:	8e e1       	ldi	r24, 0x1E	; 30
    3bee:	90 e0       	ldi	r25, 0x00	; 0
    3bf0:	a7 01       	movw	r20, r14
    3bf2:	96 01       	movw	r18, r12
    3bf4:	0e 94 a2 23 	call	0x4744	; 0x4744 <__udivmodsi4>
    3bf8:	da 01       	movw	r26, r20
    3bfa:	c9 01       	movw	r24, r18
    3bfc:	01 97       	sbiw	r24, 0x01	; 1
    3bfe:	a1 09       	sbc	r26, r1
    3c00:	b1 09       	sbc	r27, r1
    3c02:	b6 95       	lsr	r27
    3c04:	a7 95       	ror	r26
    3c06:	97 95       	ror	r25
    3c08:	87 95       	ror	r24
    3c0a:	9c 01       	movw	r18, r24
  }

  // assign the baud_setting, a.k.a. ubrr (USART Baud Rate Register)
  *_ubrrh = baud_setting >> 8;
    3c0c:	ec 85       	ldd	r30, Y+12	; 0x0c
    3c0e:	fd 85       	ldd	r31, Y+13	; 0x0d
    3c10:	30 83       	st	Z, r19
  *_ubrrl = baud_setting;
    3c12:	ee 85       	ldd	r30, Y+14	; 0x0e
    3c14:	ff 85       	ldd	r31, Y+15	; 0x0f
    3c16:	20 83       	st	Z, r18

  _written = false;
    3c18:	18 8e       	std	Y+24, r1	; 0x18

  //set the data bits, parity, and stop bits
#if defined(__AVR_ATmega8__)
  config |= 0x80; // select UCSRC register (shared with UBRRH)
#endif
  *_ucsrc = config;
    3c1a:	ec 89       	ldd	r30, Y+20	; 0x14
    3c1c:	fd 89       	ldd	r31, Y+21	; 0x15
    3c1e:	10 83       	st	Z, r17
  
  sbi(*_ucsrb, RXEN0);
    3c20:	ea 89       	ldd	r30, Y+18	; 0x12
    3c22:	fb 89       	ldd	r31, Y+19	; 0x13
    3c24:	80 81       	ld	r24, Z
    3c26:	80 61       	ori	r24, 0x10	; 16
    3c28:	80 83       	st	Z, r24
  sbi(*_ucsrb, TXEN0);
    3c2a:	ea 89       	ldd	r30, Y+18	; 0x12
    3c2c:	fb 89       	ldd	r31, Y+19	; 0x13
    3c2e:	80 81       	ld	r24, Z
    3c30:	88 60       	ori	r24, 0x08	; 8
    3c32:	80 83       	st	Z, r24
  sbi(*_ucsrb, RXCIE0);
    3c34:	ea 89       	ldd	r30, Y+18	; 0x12
    3c36:	fb 89       	ldd	r31, Y+19	; 0x13
    3c38:	80 81       	ld	r24, Z
    3c3a:	80 68       	ori	r24, 0x80	; 128
    3c3c:	80 83       	st	Z, r24
  cbi(*_ucsrb, UDRIE0);
    3c3e:	ea 89       	ldd	r30, Y+18	; 0x12
    3c40:	fb 89       	ldd	r31, Y+19	; 0x13
    3c42:	80 81       	ld	r24, Z
    3c44:	8f 7d       	andi	r24, 0xDF	; 223
    3c46:	80 83       	st	Z, r24
}
    3c48:	df 91       	pop	r29
    3c4a:	cf 91       	pop	r28
    3c4c:	1f 91       	pop	r17
    3c4e:	ff 90       	pop	r15
    3c50:	ef 90       	pop	r14
    3c52:	df 90       	pop	r13
    3c54:	cf 90       	pop	r12
    3c56:	08 95       	ret

00003c58 <__vector_18>:
#elif defined(USART_RXC_vect)
  ISR(USART_RXC_vect) // ATmega8
#else
  #error "Don't know what the Data Received vector is called for Serial"
#endif
  {
    3c58:	1f 92       	push	r1
    3c5a:	0f 92       	push	r0
    3c5c:	0f b6       	in	r0, 0x3f	; 63
    3c5e:	0f 92       	push	r0
    3c60:	11 24       	eor	r1, r1
    3c62:	2f 93       	push	r18
    3c64:	8f 93       	push	r24
    3c66:	9f 93       	push	r25
    3c68:	ef 93       	push	r30
    3c6a:	ff 93       	push	r31

// Actual interrupt handlers //////////////////////////////////////////////////////////////

void HardwareSerial::_rx_complete_irq(void)
{
  if (bit_is_clear(*_ucsra, UPE0)) {
    3c6c:	e0 91 43 04 	lds	r30, 0x0443	; 0x800443 <Serial+0x10>
    3c70:	f0 91 44 04 	lds	r31, 0x0444	; 0x800444 <Serial+0x11>
    3c74:	80 81       	ld	r24, Z
    3c76:	e0 91 49 04 	lds	r30, 0x0449	; 0x800449 <Serial+0x16>
    3c7a:	f0 91 4a 04 	lds	r31, 0x044A	; 0x80044a <Serial+0x17>
    3c7e:	82 fd       	sbrc	r24, 2
    3c80:	12 c0       	rjmp	.+36     	; 0x3ca6 <__vector_18+0x4e>
    // No Parity error, read byte and store it in the buffer if there is
    // room
    unsigned char c = *_udr;
    3c82:	90 81       	ld	r25, Z
    rx_buffer_index_t i = (unsigned int)(_rx_buffer_head + 1) % SERIAL_RX_BUFFER_SIZE;
    3c84:	80 91 4c 04 	lds	r24, 0x044C	; 0x80044c <Serial+0x19>
    3c88:	8f 5f       	subi	r24, 0xFF	; 255
    3c8a:	8f 73       	andi	r24, 0x3F	; 63

    // if we should be storing the received character into the location
    // just before the tail (meaning that the head would advance to the
    // current location of the tail), we're about to overflow the buffer
    // and so we don't write the character or advance the head.
    if (i != _rx_buffer_tail) {
    3c8c:	20 91 4d 04 	lds	r18, 0x044D	; 0x80044d <Serial+0x1a>
    3c90:	82 17       	cp	r24, r18
    3c92:	51 f0       	breq	.+20     	; 0x3ca8 <__vector_18+0x50>
      _rx_buffer[_rx_buffer_head] = c;
    3c94:	e0 91 4c 04 	lds	r30, 0x044C	; 0x80044c <Serial+0x19>
    3c98:	f0 e0       	ldi	r31, 0x00	; 0
    3c9a:	ed 5c       	subi	r30, 0xCD	; 205
    3c9c:	fb 4f       	sbci	r31, 0xFB	; 251
    3c9e:	95 8f       	std	Z+29, r25	; 0x1d
      _rx_buffer_head = i;
    3ca0:	80 93 4c 04 	sts	0x044C, r24	; 0x80044c <Serial+0x19>
    3ca4:	01 c0       	rjmp	.+2      	; 0x3ca8 <__vector_18+0x50>
    }
  } else {
    // Parity error, read byte but discard it
    *_udr;
    3ca6:	80 81       	ld	r24, Z
    Serial._rx_complete_irq();
  }
    3ca8:	ff 91       	pop	r31
    3caa:	ef 91       	pop	r30
    3cac:	9f 91       	pop	r25
    3cae:	8f 91       	pop	r24
    3cb0:	2f 91       	pop	r18
    3cb2:	0f 90       	pop	r0
    3cb4:	0f be       	out	0x3f, r0	; 63
    3cb6:	0f 90       	pop	r0
    3cb8:	1f 90       	pop	r1
    3cba:	18 95       	reti

00003cbc <__vector_19>:
#elif defined(USART_UDRE_vect)
ISR(USART_UDRE_vect)
#else
  #error "Don't know what the Data Register Empty vector is called for Serial"
#endif
{
    3cbc:	1f 92       	push	r1
    3cbe:	0f 92       	push	r0
    3cc0:	0f b6       	in	r0, 0x3f	; 63
    3cc2:	0f 92       	push	r0
    3cc4:	11 24       	eor	r1, r1
    3cc6:	2f 93       	push	r18
    3cc8:	3f 93       	push	r19
    3cca:	4f 93       	push	r20
    3ccc:	5f 93       	push	r21
    3cce:	6f 93       	push	r22
    3cd0:	7f 93       	push	r23
    3cd2:	8f 93       	push	r24
    3cd4:	9f 93       	push	r25
    3cd6:	af 93       	push	r26
    3cd8:	bf 93       	push	r27
    3cda:	ef 93       	push	r30
    3cdc:	ff 93       	push	r31
  Serial._tx_udr_empty_irq();
    3cde:	83 e3       	ldi	r24, 0x33	; 51
    3ce0:	94 e0       	ldi	r25, 0x04	; 4
    3ce2:	0e 94 36 1d 	call	0x3a6c	; 0x3a6c <_ZN14HardwareSerial17_tx_udr_empty_irqEv>
}
    3ce6:	ff 91       	pop	r31
    3ce8:	ef 91       	pop	r30
    3cea:	bf 91       	pop	r27
    3cec:	af 91       	pop	r26
    3cee:	9f 91       	pop	r25
    3cf0:	8f 91       	pop	r24
    3cf2:	7f 91       	pop	r23
    3cf4:	6f 91       	pop	r22
    3cf6:	5f 91       	pop	r21
    3cf8:	4f 91       	pop	r20
    3cfa:	3f 91       	pop	r19
    3cfc:	2f 91       	pop	r18
    3cfe:	0f 90       	pop	r0
    3d00:	0f be       	out	0x3f, r0	; 63
    3d02:	0f 90       	pop	r0
    3d04:	1f 90       	pop	r1
    3d06:	18 95       	reti

00003d08 <_Z17Serial0_availablev>:
#endif

// Function that can be weakly referenced by serialEventRun to prevent
// pulling in this file if it's not otherwise used.
bool Serial0_available() {
  return Serial.available();
    3d08:	83 e3       	ldi	r24, 0x33	; 51
    3d0a:	94 e0       	ldi	r25, 0x04	; 4
    3d0c:	0e 94 eb 1c 	call	0x39d6	; 0x39d6 <_ZN14HardwareSerial9availableEv>
    3d10:	21 e0       	ldi	r18, 0x01	; 1
    3d12:	89 2b       	or	r24, r25
    3d14:	09 f4       	brne	.+2      	; 0x3d18 <_Z17Serial0_availablev+0x10>
    3d16:	20 e0       	ldi	r18, 0x00	; 0
}
    3d18:	82 2f       	mov	r24, r18
    3d1a:	08 95       	ret

00003d1c <_GLOBAL__sub_I___vector_18>:
    size_t printNumber(unsigned long, uint8_t);
    size_t printFloat(double, uint8_t);
  protected:
    void setWriteError(int err = 1) { write_error = err; }
  public:
    Print() : write_error(0) {}
    3d1c:	e3 e3       	ldi	r30, 0x33	; 51
    3d1e:	f4 e0       	ldi	r31, 0x04	; 4
    3d20:	13 82       	std	Z+3, r1	; 0x03
    3d22:	12 82       	std	Z+2, r1	; 0x02
  public:
    virtual int available() = 0;
    virtual int read() = 0;
    virtual int peek() = 0;

    Stream() {_timeout=1000;}
    3d24:	88 ee       	ldi	r24, 0xE8	; 232
    3d26:	93 e0       	ldi	r25, 0x03	; 3
    3d28:	a0 e0       	ldi	r26, 0x00	; 0
    3d2a:	b0 e0       	ldi	r27, 0x00	; 0
    3d2c:	84 83       	std	Z+4, r24	; 0x04
    3d2e:	95 83       	std	Z+5, r25	; 0x05
    3d30:	a6 83       	std	Z+6, r26	; 0x06
    3d32:	b7 83       	std	Z+7, r27	; 0x07
  volatile uint8_t *ucsrc, volatile uint8_t *udr) :
    _ubrrh(ubrrh), _ubrrl(ubrrl),
    _ucsra(ucsra), _ucsrb(ucsrb), _ucsrc(ucsrc),
    _udr(udr),
    _rx_buffer_head(0), _rx_buffer_tail(0),
    _tx_buffer_head(0), _tx_buffer_tail(0)
    3d34:	89 e0       	ldi	r24, 0x09	; 9
    3d36:	92 e0       	ldi	r25, 0x02	; 2
    3d38:	91 83       	std	Z+1, r25	; 0x01
    3d3a:	80 83       	st	Z, r24
    3d3c:	85 ec       	ldi	r24, 0xC5	; 197
    3d3e:	90 e0       	ldi	r25, 0x00	; 0
    3d40:	95 87       	std	Z+13, r25	; 0x0d
    3d42:	84 87       	std	Z+12, r24	; 0x0c
    3d44:	84 ec       	ldi	r24, 0xC4	; 196
    3d46:	90 e0       	ldi	r25, 0x00	; 0
    3d48:	97 87       	std	Z+15, r25	; 0x0f
    3d4a:	86 87       	std	Z+14, r24	; 0x0e
    3d4c:	80 ec       	ldi	r24, 0xC0	; 192
    3d4e:	90 e0       	ldi	r25, 0x00	; 0
    3d50:	91 8b       	std	Z+17, r25	; 0x11
    3d52:	80 8b       	std	Z+16, r24	; 0x10
    3d54:	81 ec       	ldi	r24, 0xC1	; 193
    3d56:	90 e0       	ldi	r25, 0x00	; 0
    3d58:	93 8b       	std	Z+19, r25	; 0x13
    3d5a:	82 8b       	std	Z+18, r24	; 0x12
    3d5c:	82 ec       	ldi	r24, 0xC2	; 194
    3d5e:	90 e0       	ldi	r25, 0x00	; 0
    3d60:	95 8b       	std	Z+21, r25	; 0x15
    3d62:	84 8b       	std	Z+20, r24	; 0x14
    3d64:	86 ec       	ldi	r24, 0xC6	; 198
    3d66:	90 e0       	ldi	r25, 0x00	; 0
    3d68:	97 8b       	std	Z+23, r25	; 0x17
    3d6a:	86 8b       	std	Z+22, r24	; 0x16
    3d6c:	11 8e       	std	Z+25, r1	; 0x19
    3d6e:	12 8e       	std	Z+26, r1	; 0x1a
    3d70:	13 8e       	std	Z+27, r1	; 0x1b
    3d72:	14 8e       	std	Z+28, r1	; 0x1c
    3d74:	08 95       	ret

00003d76 <main>:
void setupUSB() __attribute__((weak));
void setupUSB() { }

int main(void)
{
	init();
    3d76:	0e 94 2c 21 	call	0x4258	; 0x4258 <init>

	initVariant();
    3d7a:	0e 94 74 16 	call	0x2ce8	; 0x2ce8 <initVariant>

#if defined(USBCON)
	USBDevice.attach();
#endif
	
	setup();
    3d7e:	0e 94 b1 05 	call	0xb62	; 0xb62 <setup>
    
	for (;;) {
		loop();
		if (serialEventRun) serialEventRun();
    3d82:	c8 e2       	ldi	r28, 0x28	; 40
    3d84:	dd e1       	ldi	r29, 0x1D	; 29
#endif
	
	setup();
    
	for (;;) {
		loop();
    3d86:	0e 94 38 06 	call	0xc70	; 0xc70 <loop>
		if (serialEventRun) serialEventRun();
    3d8a:	20 97       	sbiw	r28, 0x00	; 0
    3d8c:	e1 f3       	breq	.-8      	; 0x3d86 <main+0x10>
    3d8e:	0e 94 28 1d 	call	0x3a50	; 0x3a50 <_Z14serialEventRunv>
    3d92:	f9 cf       	rjmp	.-14     	; 0x3d86 <main+0x10>

00003d94 <_ZN5Print5writeEPKhj>:
size_t Print::println(unsigned long num, int base)
{
  size_t n = print(num, base);
  n += println();
  return n;
}
    3d94:	cf 92       	push	r12
    3d96:	df 92       	push	r13
    3d98:	ef 92       	push	r14
    3d9a:	ff 92       	push	r15
    3d9c:	0f 93       	push	r16
    3d9e:	1f 93       	push	r17
    3da0:	cf 93       	push	r28
    3da2:	df 93       	push	r29
    3da4:	6c 01       	movw	r12, r24
    3da6:	7a 01       	movw	r14, r20
    3da8:	8b 01       	movw	r16, r22
    3daa:	c0 e0       	ldi	r28, 0x00	; 0
    3dac:	d0 e0       	ldi	r29, 0x00	; 0
    3dae:	ce 15       	cp	r28, r14
    3db0:	df 05       	cpc	r29, r15
    3db2:	81 f0       	breq	.+32     	; 0x3dd4 <_ZN5Print5writeEPKhj+0x40>
    3db4:	d8 01       	movw	r26, r16
    3db6:	6d 91       	ld	r22, X+
    3db8:	8d 01       	movw	r16, r26
    3dba:	d6 01       	movw	r26, r12
    3dbc:	ed 91       	ld	r30, X+
    3dbe:	fc 91       	ld	r31, X
    3dc0:	01 90       	ld	r0, Z+
    3dc2:	f0 81       	ld	r31, Z
    3dc4:	e0 2d       	mov	r30, r0
    3dc6:	c6 01       	movw	r24, r12
    3dc8:	09 95       	icall
    3dca:	89 2b       	or	r24, r25
    3dcc:	11 f0       	breq	.+4      	; 0x3dd2 <_ZN5Print5writeEPKhj+0x3e>
    3dce:	21 96       	adiw	r28, 0x01	; 1
    3dd0:	ee cf       	rjmp	.-36     	; 0x3dae <_ZN5Print5writeEPKhj+0x1a>
    3dd2:	7e 01       	movw	r14, r28
    3dd4:	c7 01       	movw	r24, r14
    3dd6:	df 91       	pop	r29
    3dd8:	cf 91       	pop	r28
    3dda:	1f 91       	pop	r17
    3ddc:	0f 91       	pop	r16
    3dde:	ff 90       	pop	r15
    3de0:	ef 90       	pop	r14
    3de2:	df 90       	pop	r13
    3de4:	cf 90       	pop	r12
    3de6:	08 95       	ret

00003de8 <_ZN5Print5printEPK19__FlashStringHelper>:
    3de8:	ef 92       	push	r14
    3dea:	ff 92       	push	r15
    3dec:	0f 93       	push	r16
    3dee:	1f 93       	push	r17
    3df0:	cf 93       	push	r28
    3df2:	df 93       	push	r29
    3df4:	8c 01       	movw	r16, r24
    3df6:	7b 01       	movw	r14, r22
    3df8:	c0 e0       	ldi	r28, 0x00	; 0
    3dfa:	d0 e0       	ldi	r29, 0x00	; 0
    3dfc:	f7 01       	movw	r30, r14
    3dfe:	ec 0f       	add	r30, r28
    3e00:	fd 1f       	adc	r31, r29
    3e02:	64 91       	lpm	r22, Z
    3e04:	66 23       	and	r22, r22
    3e06:	61 f0       	breq	.+24     	; 0x3e20 <_ZN5Print5printEPK19__FlashStringHelper+0x38>
    3e08:	d8 01       	movw	r26, r16
    3e0a:	ed 91       	ld	r30, X+
    3e0c:	fc 91       	ld	r31, X
    3e0e:	01 90       	ld	r0, Z+
    3e10:	f0 81       	ld	r31, Z
    3e12:	e0 2d       	mov	r30, r0
    3e14:	c8 01       	movw	r24, r16
    3e16:	09 95       	icall
    3e18:	89 2b       	or	r24, r25
    3e1a:	11 f0       	breq	.+4      	; 0x3e20 <_ZN5Print5printEPK19__FlashStringHelper+0x38>
    3e1c:	21 96       	adiw	r28, 0x01	; 1
    3e1e:	ee cf       	rjmp	.-36     	; 0x3dfc <_ZN5Print5printEPK19__FlashStringHelper+0x14>
    3e20:	ce 01       	movw	r24, r28
    3e22:	df 91       	pop	r29
    3e24:	cf 91       	pop	r28
    3e26:	1f 91       	pop	r17
    3e28:	0f 91       	pop	r16
    3e2a:	ff 90       	pop	r15
    3e2c:	ef 90       	pop	r14
    3e2e:	08 95       	ret

00003e30 <_ZN5Print5printEPKc>:
    3e30:	0c 94 b3 00 	jmp	0x166	; 0x166 <_ZN5Print5writeEPKc>

00003e34 <_ZN5Print5printEc>:
    3e34:	dc 01       	movw	r26, r24
    3e36:	ed 91       	ld	r30, X+
    3e38:	fc 91       	ld	r31, X
    3e3a:	01 90       	ld	r0, Z+
    3e3c:	f0 81       	ld	r31, Z
    3e3e:	e0 2d       	mov	r30, r0
    3e40:	09 94       	ijmp

00003e42 <_ZN5Print7printlnEv>:
    3e42:	67 e1       	ldi	r22, 0x17	; 23
    3e44:	72 e0       	ldi	r23, 0x02	; 2
    3e46:	0c 94 b3 00 	jmp	0x166	; 0x166 <_ZN5Print5writeEPKc>

00003e4a <_ZN5Print7printlnEPKc>:
    3e4a:	0f 93       	push	r16
    3e4c:	1f 93       	push	r17
    3e4e:	cf 93       	push	r28
    3e50:	df 93       	push	r29
    3e52:	ec 01       	movw	r28, r24
    3e54:	0e 94 b3 00 	call	0x166	; 0x166 <_ZN5Print5writeEPKc>
    3e58:	8c 01       	movw	r16, r24
    3e5a:	ce 01       	movw	r24, r28
    3e5c:	0e 94 21 1f 	call	0x3e42	; 0x3e42 <_ZN5Print7printlnEv>
    3e60:	80 0f       	add	r24, r16
    3e62:	91 1f       	adc	r25, r17
    3e64:	df 91       	pop	r29
    3e66:	cf 91       	pop	r28
    3e68:	1f 91       	pop	r17
    3e6a:	0f 91       	pop	r16
    3e6c:	08 95       	ret

00003e6e <_ZN5Print11printNumberEmh>:
    3e6e:	8f 92       	push	r8
    3e70:	9f 92       	push	r9
    3e72:	af 92       	push	r10
    3e74:	bf 92       	push	r11
    3e76:	ef 92       	push	r14
    3e78:	ff 92       	push	r15
    3e7a:	0f 93       	push	r16
    3e7c:	1f 93       	push	r17
    3e7e:	cf 93       	push	r28
    3e80:	df 93       	push	r29
    3e82:	cd b7       	in	r28, 0x3d	; 61
    3e84:	de b7       	in	r29, 0x3e	; 62
    3e86:	a1 97       	sbiw	r28, 0x21	; 33
    3e88:	0f b6       	in	r0, 0x3f	; 63
    3e8a:	f8 94       	cli
    3e8c:	de bf       	out	0x3e, r29	; 62
    3e8e:	0f be       	out	0x3f, r0	; 63
    3e90:	cd bf       	out	0x3d, r28	; 61
    3e92:	7c 01       	movw	r14, r24
    3e94:	fa 01       	movw	r30, r20
    3e96:	cb 01       	movw	r24, r22
    3e98:	19 a2       	std	Y+33, r1	; 0x21
    3e9a:	22 30       	cpi	r18, 0x02	; 2
    3e9c:	08 f4       	brcc	.+2      	; 0x3ea0 <_ZN5Print11printNumberEmh+0x32>
    3e9e:	2a e0       	ldi	r18, 0x0A	; 10
    3ea0:	8e 01       	movw	r16, r28
    3ea2:	0f 5d       	subi	r16, 0xDF	; 223
    3ea4:	1f 4f       	sbci	r17, 0xFF	; 255
    3ea6:	82 2e       	mov	r8, r18
    3ea8:	91 2c       	mov	r9, r1
    3eaa:	a1 2c       	mov	r10, r1
    3eac:	b1 2c       	mov	r11, r1
    3eae:	bf 01       	movw	r22, r30
    3eb0:	a5 01       	movw	r20, r10
    3eb2:	94 01       	movw	r18, r8
    3eb4:	0e 94 a2 23 	call	0x4744	; 0x4744 <__udivmodsi4>
    3eb8:	f9 01       	movw	r30, r18
    3eba:	ca 01       	movw	r24, r20
    3ebc:	01 50       	subi	r16, 0x01	; 1
    3ebe:	11 09       	sbc	r17, r1
    3ec0:	6a 30       	cpi	r22, 0x0A	; 10
    3ec2:	10 f4       	brcc	.+4      	; 0x3ec8 <_ZN5Print11printNumberEmh+0x5a>
    3ec4:	60 5d       	subi	r22, 0xD0	; 208
    3ec6:	01 c0       	rjmp	.+2      	; 0x3eca <_ZN5Print11printNumberEmh+0x5c>
    3ec8:	69 5c       	subi	r22, 0xC9	; 201
    3eca:	d8 01       	movw	r26, r16
    3ecc:	6c 93       	st	X, r22
    3ece:	23 2b       	or	r18, r19
    3ed0:	24 2b       	or	r18, r20
    3ed2:	25 2b       	or	r18, r21
    3ed4:	61 f7       	brne	.-40     	; 0x3eae <_ZN5Print11printNumberEmh+0x40>
    3ed6:	b8 01       	movw	r22, r16
    3ed8:	c7 01       	movw	r24, r14
    3eda:	0e 94 b3 00 	call	0x166	; 0x166 <_ZN5Print5writeEPKc>
    3ede:	a1 96       	adiw	r28, 0x21	; 33
    3ee0:	0f b6       	in	r0, 0x3f	; 63
    3ee2:	f8 94       	cli
    3ee4:	de bf       	out	0x3e, r29	; 62
    3ee6:	0f be       	out	0x3f, r0	; 63
    3ee8:	cd bf       	out	0x3d, r28	; 61
    3eea:	df 91       	pop	r29
    3eec:	cf 91       	pop	r28
    3eee:	1f 91       	pop	r17
    3ef0:	0f 91       	pop	r16
    3ef2:	ff 90       	pop	r15
    3ef4:	ef 90       	pop	r14
    3ef6:	bf 90       	pop	r11
    3ef8:	af 90       	pop	r10
    3efa:	9f 90       	pop	r9
    3efc:	8f 90       	pop	r8
    3efe:	08 95       	ret

00003f00 <_ZN5Print5printEmi>:
    3f00:	21 15       	cp	r18, r1
    3f02:	31 05       	cpc	r19, r1
    3f04:	41 f4       	brne	.+16     	; 0x3f16 <_ZN5Print5printEmi+0x16>
    3f06:	dc 01       	movw	r26, r24
    3f08:	ed 91       	ld	r30, X+
    3f0a:	fc 91       	ld	r31, X
    3f0c:	01 90       	ld	r0, Z+
    3f0e:	f0 81       	ld	r31, Z
    3f10:	e0 2d       	mov	r30, r0
    3f12:	64 2f       	mov	r22, r20
    3f14:	09 94       	ijmp
    3f16:	0c 94 37 1f 	jmp	0x3e6e	; 0x3e6e <_ZN5Print11printNumberEmh>

00003f1a <_ZN5Print5printEhi>:
    3f1a:	9a 01       	movw	r18, r20
    3f1c:	46 2f       	mov	r20, r22
    3f1e:	50 e0       	ldi	r21, 0x00	; 0
    3f20:	60 e0       	ldi	r22, 0x00	; 0
    3f22:	70 e0       	ldi	r23, 0x00	; 0
    3f24:	0c 94 80 1f 	jmp	0x3f00	; 0x3f00 <_ZN5Print5printEmi>

00003f28 <_ZN5Print7printlnEhi>:
    3f28:	0f 93       	push	r16
    3f2a:	1f 93       	push	r17
    3f2c:	cf 93       	push	r28
    3f2e:	df 93       	push	r29
    3f30:	ec 01       	movw	r28, r24
    3f32:	0e 94 8d 1f 	call	0x3f1a	; 0x3f1a <_ZN5Print5printEhi>
    3f36:	8c 01       	movw	r16, r24
    3f38:	ce 01       	movw	r24, r28
    3f3a:	0e 94 21 1f 	call	0x3e42	; 0x3e42 <_ZN5Print7printlnEv>
    3f3e:	80 0f       	add	r24, r16
    3f40:	91 1f       	adc	r25, r17
    3f42:	df 91       	pop	r29
    3f44:	cf 91       	pop	r28
    3f46:	1f 91       	pop	r17
    3f48:	0f 91       	pop	r16
    3f4a:	08 95       	ret

00003f4c <_ZN5Print5printEli>:
{
  return print((unsigned long) n, base);
}

size_t Print::print(long n, int base)
{
    3f4c:	cf 92       	push	r12
    3f4e:	df 92       	push	r13
    3f50:	ef 92       	push	r14
    3f52:	ff 92       	push	r15
    3f54:	0f 93       	push	r16
    3f56:	1f 93       	push	r17
    3f58:	cf 93       	push	r28
    3f5a:	df 93       	push	r29
  if (base == 0) {
    3f5c:	21 15       	cp	r18, r1
    3f5e:	31 05       	cpc	r19, r1
    3f60:	81 f4       	brne	.+32     	; 0x3f82 <_ZN5Print5printEli+0x36>
    return write(n);
    3f62:	dc 01       	movw	r26, r24
    3f64:	ed 91       	ld	r30, X+
    3f66:	fc 91       	ld	r31, X
    3f68:	01 90       	ld	r0, Z+
    3f6a:	f0 81       	ld	r31, Z
    3f6c:	e0 2d       	mov	r30, r0
    3f6e:	64 2f       	mov	r22, r20
    }
    return printNumber(n, 10);
  } else {
    return printNumber(n, base);
  }
}
    3f70:	df 91       	pop	r29
    3f72:	cf 91       	pop	r28
    3f74:	1f 91       	pop	r17
    3f76:	0f 91       	pop	r16
    3f78:	ff 90       	pop	r15
    3f7a:	ef 90       	pop	r14
    3f7c:	df 90       	pop	r13
    3f7e:	cf 90       	pop	r12
}

size_t Print::print(long n, int base)
{
  if (base == 0) {
    return write(n);
    3f80:	09 94       	ijmp
  } else if (base == 10) {
    3f82:	2a 30       	cpi	r18, 0x0A	; 10
    3f84:	31 05       	cpc	r19, r1
    3f86:	01 f5       	brne	.+64     	; 0x3fc8 <_ZN5Print5printEli+0x7c>
    if (n < 0) {
    3f88:	77 ff       	sbrs	r23, 7
    3f8a:	1d c0       	rjmp	.+58     	; 0x3fc6 <_ZN5Print5printEli+0x7a>
    3f8c:	6a 01       	movw	r12, r20
    3f8e:	7b 01       	movw	r14, r22
    3f90:	ec 01       	movw	r28, r24
      int t = print('-');
    3f92:	6d e2       	ldi	r22, 0x2D	; 45
    3f94:	0e 94 1a 1f 	call	0x3e34	; 0x3e34 <_ZN5Print5printEc>
    3f98:	8c 01       	movw	r16, r24
      n = -n;
      return printNumber(n, 10) + t;
    3f9a:	44 27       	eor	r20, r20
    3f9c:	55 27       	eor	r21, r21
    3f9e:	ba 01       	movw	r22, r20
    3fa0:	4c 19       	sub	r20, r12
    3fa2:	5d 09       	sbc	r21, r13
    3fa4:	6e 09       	sbc	r22, r14
    3fa6:	7f 09       	sbc	r23, r15
    3fa8:	2a e0       	ldi	r18, 0x0A	; 10
    3faa:	ce 01       	movw	r24, r28
    3fac:	0e 94 37 1f 	call	0x3e6e	; 0x3e6e <_ZN5Print11printNumberEmh>
    3fb0:	80 0f       	add	r24, r16
    3fb2:	91 1f       	adc	r25, r17
    }
    return printNumber(n, 10);
  } else {
    return printNumber(n, base);
  }
}
    3fb4:	df 91       	pop	r29
    3fb6:	cf 91       	pop	r28
    3fb8:	1f 91       	pop	r17
    3fba:	0f 91       	pop	r16
    3fbc:	ff 90       	pop	r15
    3fbe:	ef 90       	pop	r14
    3fc0:	df 90       	pop	r13
    3fc2:	cf 90       	pop	r12
    3fc4:	08 95       	ret
    if (n < 0) {
      int t = print('-');
      n = -n;
      return printNumber(n, 10) + t;
    }
    return printNumber(n, 10);
    3fc6:	2a e0       	ldi	r18, 0x0A	; 10
  } else {
    return printNumber(n, base);
  }
}
    3fc8:	df 91       	pop	r29
    3fca:	cf 91       	pop	r28
    3fcc:	1f 91       	pop	r17
    3fce:	0f 91       	pop	r16
    3fd0:	ff 90       	pop	r15
    3fd2:	ef 90       	pop	r14
    3fd4:	df 90       	pop	r13
    3fd6:	cf 90       	pop	r12
      n = -n;
      return printNumber(n, 10) + t;
    }
    return printNumber(n, 10);
  } else {
    return printNumber(n, base);
    3fd8:	0c 94 37 1f 	jmp	0x3e6e	; 0x3e6e <_ZN5Print11printNumberEmh>

00003fdc <_ZN5Print5printEii>:
{
  return print((unsigned long) b, base);
}

size_t Print::print(int n, int base)
{
    3fdc:	9a 01       	movw	r18, r20
  return print((long) n, base);
    3fde:	ab 01       	movw	r20, r22
    3fe0:	77 0f       	add	r23, r23
    3fe2:	66 0b       	sbc	r22, r22
    3fe4:	77 0b       	sbc	r23, r23
    3fe6:	0c 94 a6 1f 	jmp	0x3f4c	; 0x3f4c <_ZN5Print5printEli>

00003fea <_ZN5Print7printlnEii>:
  n += println();
  return n;
}

size_t Print::println(int num, int base)
{
    3fea:	0f 93       	push	r16
    3fec:	1f 93       	push	r17
    3fee:	cf 93       	push	r28
    3ff0:	df 93       	push	r29
    3ff2:	ec 01       	movw	r28, r24
  size_t n = print(num, base);
    3ff4:	0e 94 ee 1f 	call	0x3fdc	; 0x3fdc <_ZN5Print5printEii>
    3ff8:	8c 01       	movw	r16, r24
  n += println();
    3ffa:	ce 01       	movw	r24, r28
    3ffc:	0e 94 21 1f 	call	0x3e42	; 0x3e42 <_ZN5Print7printlnEv>
  return n;
}
    4000:	80 0f       	add	r24, r16
    4002:	91 1f       	adc	r25, r17
    4004:	df 91       	pop	r29
    4006:	cf 91       	pop	r28
    4008:	1f 91       	pop	r17
    400a:	0f 91       	pop	r16
    400c:	08 95       	ret

0000400e <nothing>:
    #endif
      break;       
#endif
    }
      
    intFunc[interruptNum] = nothing;
    400e:	08 95       	ret

00004010 <attachInterrupt>:
    4010:	82 30       	cpi	r24, 0x02	; 2
    4012:	e8 f4       	brcc	.+58     	; 0x404e <attachInterrupt+0x3e>
    4014:	e8 2f       	mov	r30, r24
    4016:	f0 e0       	ldi	r31, 0x00	; 0
    4018:	ee 0f       	add	r30, r30
    401a:	ff 1f       	adc	r31, r31
    401c:	e5 5c       	subi	r30, 0xC5	; 197
    401e:	fe 4f       	sbci	r31, 0xFE	; 254
    4020:	71 83       	std	Z+1, r23	; 0x01
    4022:	60 83       	st	Z, r22
    4024:	81 30       	cpi	r24, 0x01	; 1
    4026:	41 f0       	breq	.+16     	; 0x4038 <attachInterrupt+0x28>
    4028:	80 91 69 00 	lds	r24, 0x0069	; 0x800069 <__DATA_REGION_ORIGIN__+0x9>
    402c:	8c 7f       	andi	r24, 0xFC	; 252
    402e:	48 2b       	or	r20, r24
    4030:	40 93 69 00 	sts	0x0069, r20	; 0x800069 <__DATA_REGION_ORIGIN__+0x9>
    4034:	e8 9a       	sbi	0x1d, 0	; 29
    4036:	08 95       	ret
    4038:	80 91 69 00 	lds	r24, 0x0069	; 0x800069 <__DATA_REGION_ORIGIN__+0x9>
    403c:	83 7f       	andi	r24, 0xF3	; 243
    403e:	44 0f       	add	r20, r20
    4040:	55 1f       	adc	r21, r21
    4042:	44 0f       	add	r20, r20
    4044:	55 1f       	adc	r21, r21
    4046:	48 2b       	or	r20, r24
    4048:	40 93 69 00 	sts	0x0069, r20	; 0x800069 <__DATA_REGION_ORIGIN__+0x9>
    404c:	e9 9a       	sbi	0x1d, 1	; 29
    404e:	08 95       	ret

00004050 <__vector_1>:
IMPLEMENT_ISR(INT6_vect, EXTERNAL_INT_6)
IMPLEMENT_ISR(INT7_vect, EXTERNAL_INT_7)

#else

IMPLEMENT_ISR(INT0_vect, EXTERNAL_INT_0)
    4050:	1f 92       	push	r1
    4052:	0f 92       	push	r0
    4054:	0f b6       	in	r0, 0x3f	; 63
    4056:	0f 92       	push	r0
    4058:	11 24       	eor	r1, r1
    405a:	2f 93       	push	r18
    405c:	3f 93       	push	r19
    405e:	4f 93       	push	r20
    4060:	5f 93       	push	r21
    4062:	6f 93       	push	r22
    4064:	7f 93       	push	r23
    4066:	8f 93       	push	r24
    4068:	9f 93       	push	r25
    406a:	af 93       	push	r26
    406c:	bf 93       	push	r27
    406e:	ef 93       	push	r30
    4070:	ff 93       	push	r31
    4072:	e0 91 3b 01 	lds	r30, 0x013B	; 0x80013b <intFunc>
    4076:	f0 91 3c 01 	lds	r31, 0x013C	; 0x80013c <intFunc+0x1>
    407a:	09 95       	icall
    407c:	ff 91       	pop	r31
    407e:	ef 91       	pop	r30
    4080:	bf 91       	pop	r27
    4082:	af 91       	pop	r26
    4084:	9f 91       	pop	r25
    4086:	8f 91       	pop	r24
    4088:	7f 91       	pop	r23
    408a:	6f 91       	pop	r22
    408c:	5f 91       	pop	r21
    408e:	4f 91       	pop	r20
    4090:	3f 91       	pop	r19
    4092:	2f 91       	pop	r18
    4094:	0f 90       	pop	r0
    4096:	0f be       	out	0x3f, r0	; 63
    4098:	0f 90       	pop	r0
    409a:	1f 90       	pop	r1
    409c:	18 95       	reti

0000409e <__vector_2>:
IMPLEMENT_ISR(INT1_vect, EXTERNAL_INT_1)
    409e:	1f 92       	push	r1
    40a0:	0f 92       	push	r0
    40a2:	0f b6       	in	r0, 0x3f	; 63
    40a4:	0f 92       	push	r0
    40a6:	11 24       	eor	r1, r1
    40a8:	2f 93       	push	r18
    40aa:	3f 93       	push	r19
    40ac:	4f 93       	push	r20
    40ae:	5f 93       	push	r21
    40b0:	6f 93       	push	r22
    40b2:	7f 93       	push	r23
    40b4:	8f 93       	push	r24
    40b6:	9f 93       	push	r25
    40b8:	af 93       	push	r26
    40ba:	bf 93       	push	r27
    40bc:	ef 93       	push	r30
    40be:	ff 93       	push	r31
    40c0:	e0 91 3d 01 	lds	r30, 0x013D	; 0x80013d <intFunc+0x2>
    40c4:	f0 91 3e 01 	lds	r31, 0x013E	; 0x80013e <intFunc+0x3>
    40c8:	09 95       	icall
    40ca:	ff 91       	pop	r31
    40cc:	ef 91       	pop	r30
    40ce:	bf 91       	pop	r27
    40d0:	af 91       	pop	r26
    40d2:	9f 91       	pop	r25
    40d4:	8f 91       	pop	r24
    40d6:	7f 91       	pop	r23
    40d8:	6f 91       	pop	r22
    40da:	5f 91       	pop	r21
    40dc:	4f 91       	pop	r20
    40de:	3f 91       	pop	r19
    40e0:	2f 91       	pop	r18
    40e2:	0f 90       	pop	r0
    40e4:	0f be       	out	0x3f, r0	; 63
    40e6:	0f 90       	pop	r0
    40e8:	1f 90       	pop	r1
    40ea:	18 95       	reti

000040ec <__vector_16>:
	cli();
	m = timer0_millis;
	SREG = oldSREG;

	return m;
}
    40ec:	1f 92       	push	r1
    40ee:	0f 92       	push	r0
    40f0:	0f b6       	in	r0, 0x3f	; 63
    40f2:	0f 92       	push	r0
    40f4:	11 24       	eor	r1, r1
    40f6:	2f 93       	push	r18
    40f8:	3f 93       	push	r19
    40fa:	8f 93       	push	r24
    40fc:	9f 93       	push	r25
    40fe:	af 93       	push	r26
    4100:	bf 93       	push	r27
    4102:	80 91 d1 04 	lds	r24, 0x04D1	; 0x8004d1 <timer0_millis>
    4106:	90 91 d2 04 	lds	r25, 0x04D2	; 0x8004d2 <timer0_millis+0x1>
    410a:	a0 91 d3 04 	lds	r26, 0x04D3	; 0x8004d3 <timer0_millis+0x2>
    410e:	b0 91 d4 04 	lds	r27, 0x04D4	; 0x8004d4 <timer0_millis+0x3>
    4112:	30 91 d0 04 	lds	r19, 0x04D0	; 0x8004d0 <timer0_fract>
    4116:	23 e0       	ldi	r18, 0x03	; 3
    4118:	23 0f       	add	r18, r19
    411a:	2d 37       	cpi	r18, 0x7D	; 125
    411c:	20 f4       	brcc	.+8      	; 0x4126 <__vector_16+0x3a>
    411e:	01 96       	adiw	r24, 0x01	; 1
    4120:	a1 1d       	adc	r26, r1
    4122:	b1 1d       	adc	r27, r1
    4124:	05 c0       	rjmp	.+10     	; 0x4130 <__vector_16+0x44>
    4126:	26 e8       	ldi	r18, 0x86	; 134
    4128:	23 0f       	add	r18, r19
    412a:	02 96       	adiw	r24, 0x02	; 2
    412c:	a1 1d       	adc	r26, r1
    412e:	b1 1d       	adc	r27, r1
    4130:	20 93 d0 04 	sts	0x04D0, r18	; 0x8004d0 <timer0_fract>
    4134:	80 93 d1 04 	sts	0x04D1, r24	; 0x8004d1 <timer0_millis>
    4138:	90 93 d2 04 	sts	0x04D2, r25	; 0x8004d2 <timer0_millis+0x1>
    413c:	a0 93 d3 04 	sts	0x04D3, r26	; 0x8004d3 <timer0_millis+0x2>
    4140:	b0 93 d4 04 	sts	0x04D4, r27	; 0x8004d4 <timer0_millis+0x3>
    4144:	80 91 d5 04 	lds	r24, 0x04D5	; 0x8004d5 <timer0_overflow_count>
    4148:	90 91 d6 04 	lds	r25, 0x04D6	; 0x8004d6 <timer0_overflow_count+0x1>
    414c:	a0 91 d7 04 	lds	r26, 0x04D7	; 0x8004d7 <timer0_overflow_count+0x2>
    4150:	b0 91 d8 04 	lds	r27, 0x04D8	; 0x8004d8 <timer0_overflow_count+0x3>
    4154:	01 96       	adiw	r24, 0x01	; 1
    4156:	a1 1d       	adc	r26, r1
    4158:	b1 1d       	adc	r27, r1
    415a:	80 93 d5 04 	sts	0x04D5, r24	; 0x8004d5 <timer0_overflow_count>
    415e:	90 93 d6 04 	sts	0x04D6, r25	; 0x8004d6 <timer0_overflow_count+0x1>
    4162:	a0 93 d7 04 	sts	0x04D7, r26	; 0x8004d7 <timer0_overflow_count+0x2>
    4166:	b0 93 d8 04 	sts	0x04D8, r27	; 0x8004d8 <timer0_overflow_count+0x3>
    416a:	bf 91       	pop	r27
    416c:	af 91       	pop	r26
    416e:	9f 91       	pop	r25
    4170:	8f 91       	pop	r24
    4172:	3f 91       	pop	r19
    4174:	2f 91       	pop	r18
    4176:	0f 90       	pop	r0
    4178:	0f be       	out	0x3f, r0	; 63
    417a:	0f 90       	pop	r0
    417c:	1f 90       	pop	r1
    417e:	18 95       	reti

00004180 <micros>:

unsigned long micros() {
	unsigned long m;
	uint8_t oldSREG = SREG, t;
    4180:	3f b7       	in	r19, 0x3f	; 63
	
	cli();
    4182:	f8 94       	cli
	m = timer0_overflow_count;
    4184:	80 91 d5 04 	lds	r24, 0x04D5	; 0x8004d5 <timer0_overflow_count>
    4188:	90 91 d6 04 	lds	r25, 0x04D6	; 0x8004d6 <timer0_overflow_count+0x1>
    418c:	a0 91 d7 04 	lds	r26, 0x04D7	; 0x8004d7 <timer0_overflow_count+0x2>
    4190:	b0 91 d8 04 	lds	r27, 0x04D8	; 0x8004d8 <timer0_overflow_count+0x3>
#if defined(TCNT0)
	t = TCNT0;
    4194:	26 b5       	in	r18, 0x26	; 38
#else
	#error TIMER 0 not defined
#endif

#ifdef TIFR0
	if ((TIFR0 & _BV(TOV0)) && (t < 255))
    4196:	a8 9b       	sbis	0x15, 0	; 21
    4198:	05 c0       	rjmp	.+10     	; 0x41a4 <micros+0x24>
    419a:	2f 3f       	cpi	r18, 0xFF	; 255
    419c:	19 f0       	breq	.+6      	; 0x41a4 <micros+0x24>
		m++;
    419e:	01 96       	adiw	r24, 0x01	; 1
    41a0:	a1 1d       	adc	r26, r1
    41a2:	b1 1d       	adc	r27, r1
#else
	if ((TIFR & _BV(TOV0)) && (t < 255))
		m++;
#endif

	SREG = oldSREG;
    41a4:	3f bf       	out	0x3f, r19	; 63
	
	return ((m << 8) + t) * (64 / clockCyclesPerMicrosecond());
    41a6:	ba 2f       	mov	r27, r26
    41a8:	a9 2f       	mov	r26, r25
    41aa:	98 2f       	mov	r25, r24
    41ac:	88 27       	eor	r24, r24
    41ae:	82 0f       	add	r24, r18
    41b0:	91 1d       	adc	r25, r1
    41b2:	a1 1d       	adc	r26, r1
    41b4:	b1 1d       	adc	r27, r1
    41b6:	bc 01       	movw	r22, r24
    41b8:	cd 01       	movw	r24, r26
    41ba:	42 e0       	ldi	r20, 0x02	; 2
    41bc:	66 0f       	add	r22, r22
    41be:	77 1f       	adc	r23, r23
    41c0:	88 1f       	adc	r24, r24
    41c2:	99 1f       	adc	r25, r25
    41c4:	4a 95       	dec	r20
    41c6:	d1 f7       	brne	.-12     	; 0x41bc <micros+0x3c>
}
    41c8:	08 95       	ret

000041ca <delay>:

void delay(unsigned long ms)
{
    41ca:	8f 92       	push	r8
    41cc:	9f 92       	push	r9
    41ce:	af 92       	push	r10
    41d0:	bf 92       	push	r11
    41d2:	cf 92       	push	r12
    41d4:	df 92       	push	r13
    41d6:	ef 92       	push	r14
    41d8:	ff 92       	push	r15
    41da:	6b 01       	movw	r12, r22
    41dc:	7c 01       	movw	r14, r24
	uint32_t start = micros();
    41de:	0e 94 c0 20 	call	0x4180	; 0x4180 <micros>
    41e2:	4b 01       	movw	r8, r22
    41e4:	5c 01       	movw	r10, r24

	while (ms > 0) {
    41e6:	c1 14       	cp	r12, r1
    41e8:	d1 04       	cpc	r13, r1
    41ea:	e1 04       	cpc	r14, r1
    41ec:	f1 04       	cpc	r15, r1
    41ee:	01 f1       	breq	.+64     	; 0x4230 <delay+0x66>
		yield();
    41f0:	0e 94 8d 23 	call	0x471a	; 0x471a <yield>
		while ( ms > 0 && (micros() - start) >= 1000) {
    41f4:	0e 94 c0 20 	call	0x4180	; 0x4180 <micros>
    41f8:	dc 01       	movw	r26, r24
    41fa:	cb 01       	movw	r24, r22
    41fc:	88 19       	sub	r24, r8
    41fe:	99 09       	sbc	r25, r9
    4200:	aa 09       	sbc	r26, r10
    4202:	bb 09       	sbc	r27, r11
    4204:	88 3e       	cpi	r24, 0xE8	; 232
    4206:	93 40       	sbci	r25, 0x03	; 3
    4208:	a1 05       	cpc	r26, r1
    420a:	b1 05       	cpc	r27, r1
    420c:	60 f3       	brcs	.-40     	; 0x41e6 <delay+0x1c>
			ms--;
    420e:	21 e0       	ldi	r18, 0x01	; 1
    4210:	c2 1a       	sub	r12, r18
    4212:	d1 08       	sbc	r13, r1
    4214:	e1 08       	sbc	r14, r1
    4216:	f1 08       	sbc	r15, r1
			start += 1000;
    4218:	88 ee       	ldi	r24, 0xE8	; 232
    421a:	88 0e       	add	r8, r24
    421c:	83 e0       	ldi	r24, 0x03	; 3
    421e:	98 1e       	adc	r9, r24
    4220:	a1 1c       	adc	r10, r1
    4222:	b1 1c       	adc	r11, r1
{
	uint32_t start = micros();

	while (ms > 0) {
		yield();
		while ( ms > 0 && (micros() - start) >= 1000) {
    4224:	c1 14       	cp	r12, r1
    4226:	d1 04       	cpc	r13, r1
    4228:	e1 04       	cpc	r14, r1
    422a:	f1 04       	cpc	r15, r1
    422c:	19 f7       	brne	.-58     	; 0x41f4 <delay+0x2a>
    422e:	db cf       	rjmp	.-74     	; 0x41e6 <delay+0x1c>
			ms--;
			start += 1000;
		}
	}
}
    4230:	ff 90       	pop	r15
    4232:	ef 90       	pop	r14
    4234:	df 90       	pop	r13
    4236:	cf 90       	pop	r12
    4238:	bf 90       	pop	r11
    423a:	af 90       	pop	r10
    423c:	9f 90       	pop	r9
    423e:	8f 90       	pop	r8
    4240:	08 95       	ret

00004242 <delayMicroseconds>:
#elif F_CPU >= 16000000L
	// for the 16 MHz clock on most Arduino boards

	// for a one-microsecond delay, simply return.  the overhead
	// of the function call takes 14 (16) cycles, which is 1us
	if (us <= 1) return; //  = 3 cycles, (4 when true)
    4242:	82 30       	cpi	r24, 0x02	; 2
    4244:	91 05       	cpc	r25, r1
    4246:	38 f0       	brcs	.+14     	; 0x4256 <delayMicroseconds+0x14>

	// the following loop takes 1/4 of a microsecond (4 cycles)
	// per iteration, so execute it four times for each microsecond of
	// delay requested.
	us <<= 2; // x4 us, = 4 cycles
    4248:	88 0f       	add	r24, r24
    424a:	99 1f       	adc	r25, r25
    424c:	88 0f       	add	r24, r24
    424e:	99 1f       	adc	r25, r25

	// account for the time taken in the preceeding commands.
	// we just burned 19 (21) cycles above, remove 5, (5*4=20)
	// us is at least 8 so we can substract 5
	us -= 5; // = 2 cycles,
    4250:	05 97       	sbiw	r24, 0x05	; 5
	

#endif

	// busy wait
	__asm__ __volatile__ (
    4252:	01 97       	sbiw	r24, 0x01	; 1
    4254:	f1 f7       	brne	.-4      	; 0x4252 <delayMicroseconds+0x10>
    4256:	08 95       	ret

00004258 <init>:

void init()
{
	// this needs to be called before setup() or some functions won't
	// work there
	sei();
    4258:	78 94       	sei
	
	// on the ATmega168, timer 0 is also used for fast hardware pwm
	// (using phase-correct PWM would mean that timer 0 overflowed half as often
	// resulting in different millis() behavior on the ATmega8 and ATmega168)
#if defined(TCCR0A) && defined(WGM01)
	sbi(TCCR0A, WGM01);
    425a:	84 b5       	in	r24, 0x24	; 36
    425c:	82 60       	ori	r24, 0x02	; 2
    425e:	84 bd       	out	0x24, r24	; 36
	sbi(TCCR0A, WGM00);
    4260:	84 b5       	in	r24, 0x24	; 36
    4262:	81 60       	ori	r24, 0x01	; 1
    4264:	84 bd       	out	0x24, r24	; 36
	// this combination is for the standard atmega8
	sbi(TCCR0, CS01);
	sbi(TCCR0, CS00);
#elif defined(TCCR0B) && defined(CS01) && defined(CS00)
	// this combination is for the standard 168/328/1280/2560
	sbi(TCCR0B, CS01);
    4266:	85 b5       	in	r24, 0x25	; 37
    4268:	82 60       	ori	r24, 0x02	; 2
    426a:	85 bd       	out	0x25, r24	; 37
	sbi(TCCR0B, CS00);
    426c:	85 b5       	in	r24, 0x25	; 37
    426e:	81 60       	ori	r24, 0x01	; 1
    4270:	85 bd       	out	0x25, r24	; 37

	// enable timer 0 overflow interrupt
#if defined(TIMSK) && defined(TOIE0)
	sbi(TIMSK, TOIE0);
#elif defined(TIMSK0) && defined(TOIE0)
	sbi(TIMSK0, TOIE0);
    4272:	ee e6       	ldi	r30, 0x6E	; 110
    4274:	f0 e0       	ldi	r31, 0x00	; 0
    4276:	80 81       	ld	r24, Z
    4278:	81 60       	ori	r24, 0x01	; 1
    427a:	80 83       	st	Z, r24
	// this is better for motors as it ensures an even waveform
	// note, however, that fast pwm mode can achieve a frequency of up
	// 8 MHz (with a 16 MHz clock) at 50% duty cycle

#if defined(TCCR1B) && defined(CS11) && defined(CS10)
	TCCR1B = 0;
    427c:	e1 e8       	ldi	r30, 0x81	; 129
    427e:	f0 e0       	ldi	r31, 0x00	; 0
    4280:	10 82       	st	Z, r1

	// set timer 1 prescale factor to 64
	sbi(TCCR1B, CS11);
    4282:	80 81       	ld	r24, Z
    4284:	82 60       	ori	r24, 0x02	; 2
    4286:	80 83       	st	Z, r24
#if F_CPU >= 8000000L
	sbi(TCCR1B, CS10);
    4288:	80 81       	ld	r24, Z
    428a:	81 60       	ori	r24, 0x01	; 1
    428c:	80 83       	st	Z, r24
	sbi(TCCR1, CS10);
#endif
#endif
	// put timer 1 in 8-bit phase correct pwm mode
#if defined(TCCR1A) && defined(WGM10)
	sbi(TCCR1A, WGM10);
    428e:	e0 e8       	ldi	r30, 0x80	; 128
    4290:	f0 e0       	ldi	r31, 0x00	; 0
    4292:	80 81       	ld	r24, Z
    4294:	81 60       	ori	r24, 0x01	; 1
    4296:	80 83       	st	Z, r24

	// set timer 2 prescale factor to 64
#if defined(TCCR2) && defined(CS22)
	sbi(TCCR2, CS22);
#elif defined(TCCR2B) && defined(CS22)
	sbi(TCCR2B, CS22);
    4298:	e1 eb       	ldi	r30, 0xB1	; 177
    429a:	f0 e0       	ldi	r31, 0x00	; 0
    429c:	80 81       	ld	r24, Z
    429e:	84 60       	ori	r24, 0x04	; 4
    42a0:	80 83       	st	Z, r24

	// configure timer 2 for phase correct pwm (8-bit)
#if defined(TCCR2) && defined(WGM20)
	sbi(TCCR2, WGM20);
#elif defined(TCCR2A) && defined(WGM20)
	sbi(TCCR2A, WGM20);
    42a2:	e0 eb       	ldi	r30, 0xB0	; 176
    42a4:	f0 e0       	ldi	r31, 0x00	; 0
    42a6:	80 81       	ld	r24, Z
    42a8:	81 60       	ori	r24, 0x01	; 1
    42aa:	80 83       	st	Z, r24
#endif

#if defined(ADCSRA)
	// set a2d prescaler so we are inside the desired 50-200 KHz range.
	#if F_CPU >= 16000000 // 16 MHz / 128 = 125 KHz
		sbi(ADCSRA, ADPS2);
    42ac:	ea e7       	ldi	r30, 0x7A	; 122
    42ae:	f0 e0       	ldi	r31, 0x00	; 0
    42b0:	80 81       	ld	r24, Z
    42b2:	84 60       	ori	r24, 0x04	; 4
    42b4:	80 83       	st	Z, r24
		sbi(ADCSRA, ADPS1);
    42b6:	80 81       	ld	r24, Z
    42b8:	82 60       	ori	r24, 0x02	; 2
    42ba:	80 83       	st	Z, r24
		sbi(ADCSRA, ADPS0);
    42bc:	80 81       	ld	r24, Z
    42be:	81 60       	ori	r24, 0x01	; 1
    42c0:	80 83       	st	Z, r24
		cbi(ADCSRA, ADPS2);
		cbi(ADCSRA, ADPS1);
		sbi(ADCSRA, ADPS0);
	#endif
	// enable a2d conversions
	sbi(ADCSRA, ADEN);
    42c2:	80 81       	ld	r24, Z
    42c4:	80 68       	ori	r24, 0x80	; 128
    42c6:	80 83       	st	Z, r24
	// here so they can be used as normal digital i/o; they will be
	// reconnected in Serial.begin()
#if defined(UCSRB)
	UCSRB = 0;
#elif defined(UCSR0B)
	UCSR0B = 0;
    42c8:	10 92 c1 00 	sts	0x00C1, r1	; 0x8000c1 <__DATA_REGION_ORIGIN__+0x61>
    42cc:	08 95       	ret

000042ce <analogRead>:
#elif defined(__AVR_ATmega32U4__)
	if (pin >= 18) pin -= 18; // allow for channel or pin numbers
#elif defined(__AVR_ATmega1284__) || defined(__AVR_ATmega1284P__) || defined(__AVR_ATmega644__) || defined(__AVR_ATmega644A__) || defined(__AVR_ATmega644P__) || defined(__AVR_ATmega644PA__)
	if (pin >= 24) pin -= 24; // allow for channel or pin numbers
#else
	if (pin >= 14) pin -= 14; // allow for channel or pin numbers
    42ce:	8e 30       	cpi	r24, 0x0E	; 14
    42d0:	08 f0       	brcs	.+2      	; 0x42d4 <analogRead+0x6>
    42d2:	8e 50       	subi	r24, 0x0E	; 14
	// to 0 (the default).
#if defined(ADMUX)
#if defined(__AVR_ATtiny25__) || defined(__AVR_ATtiny45__) || defined(__AVR_ATtiny85__)
	ADMUX = (analog_reference << 4) | (pin & 0x07);
#else
	ADMUX = (analog_reference << 6) | (pin & 0x07);
    42d4:	20 91 3f 01 	lds	r18, 0x013F	; 0x80013f <analog_reference>
    42d8:	90 e4       	ldi	r25, 0x40	; 64
    42da:	29 9f       	mul	r18, r25
    42dc:	90 01       	movw	r18, r0
    42de:	11 24       	eor	r1, r1
    42e0:	87 70       	andi	r24, 0x07	; 7
    42e2:	82 2b       	or	r24, r18
    42e4:	80 93 7c 00 	sts	0x007C, r24	; 0x80007c <__DATA_REGION_ORIGIN__+0x1c>
	// without a delay, we seem to read from the wrong channel
	//delay(1);

#if defined(ADCSRA) && defined(ADCL)
	// start the conversion
	sbi(ADCSRA, ADSC);
    42e8:	80 91 7a 00 	lds	r24, 0x007A	; 0x80007a <__DATA_REGION_ORIGIN__+0x1a>
    42ec:	80 64       	ori	r24, 0x40	; 64
    42ee:	80 93 7a 00 	sts	0x007A, r24	; 0x80007a <__DATA_REGION_ORIGIN__+0x1a>

	// ADSC is cleared when the conversion finishes
	while (bit_is_set(ADCSRA, ADSC));
    42f2:	80 91 7a 00 	lds	r24, 0x007A	; 0x80007a <__DATA_REGION_ORIGIN__+0x1a>
    42f6:	86 fd       	sbrc	r24, 6
    42f8:	fc cf       	rjmp	.-8      	; 0x42f2 <analogRead+0x24>

	// we have to read ADCL first; doing so locks both ADCL
	// and ADCH until ADCH is read.  reading ADCL second would
	// cause the results of each conversion to be discarded,
	// as ADCL and ADCH would be locked when it completed.
	low  = ADCL;
    42fa:	80 91 78 00 	lds	r24, 0x0078	; 0x800078 <__DATA_REGION_ORIGIN__+0x18>
	high = ADCH;
    42fe:	20 91 79 00 	lds	r18, 0x0079	; 0x800079 <__DATA_REGION_ORIGIN__+0x19>
	low  = 0;
	high = 0;
#endif

	// combine the two bytes
	return (high << 8) | low;
    4302:	90 e0       	ldi	r25, 0x00	; 0
}
    4304:	92 2b       	or	r25, r18
    4306:	08 95       	ret

00004308 <analogWrite>:
// Right now, PWM output only works on the pins with
// hardware support.  These are defined in the appropriate
// pins_*.c file.  For the rest of the pins, we default
// to digital output.
void analogWrite(uint8_t pin, int val)
{
    4308:	1f 93       	push	r17
    430a:	cf 93       	push	r28
    430c:	df 93       	push	r29
    430e:	18 2f       	mov	r17, r24
    4310:	eb 01       	movw	r28, r22
	// We need to make sure the PWM output is enabled for those pins
	// that support it, as we turn it off when digitally reading or
	// writing with them.  Also, make sure the pin is in output mode
	// for consistenty with Wiring, which doesn't require a pinMode
	// call for the analog output pins.
	pinMode(pin, OUTPUT);
    4312:	61 e0       	ldi	r22, 0x01	; 1
    4314:	0e 94 0c 22 	call	0x4418	; 0x4418 <pinMode>
	if (val == 0)
    4318:	20 97       	sbiw	r28, 0x00	; 0
    431a:	11 f4       	brne	.+4      	; 0x4320 <analogWrite+0x18>
	{
		digitalWrite(pin, LOW);
    431c:	60 e0       	ldi	r22, 0x00	; 0
    431e:	04 c0       	rjmp	.+8      	; 0x4328 <analogWrite+0x20>
	}
	else if (val == 255)
    4320:	cf 3f       	cpi	r28, 0xFF	; 255
    4322:	d1 05       	cpc	r29, r1
    4324:	39 f4       	brne	.+14     	; 0x4334 <analogWrite+0x2c>
	{
		digitalWrite(pin, HIGH);
    4326:	61 e0       	ldi	r22, 0x01	; 1
    4328:	81 2f       	mov	r24, r17
				} else {
					digitalWrite(pin, HIGH);
				}
		}
	}
}
    432a:	df 91       	pop	r29
    432c:	cf 91       	pop	r28
    432e:	1f 91       	pop	r17
	{
		digitalWrite(pin, LOW);
	}
	else if (val == 255)
	{
		digitalWrite(pin, HIGH);
    4330:	0c 94 48 22 	jmp	0x4490	; 0x4490 <digitalWrite>
	}
	else
	{
		switch(digitalPinToTimer(pin))
    4334:	e1 2f       	mov	r30, r17
    4336:	f0 e0       	ldi	r31, 0x00	; 0
    4338:	ee 54       	subi	r30, 0x4E	; 78
    433a:	ff 4f       	sbci	r31, 0xFF	; 255
    433c:	e4 91       	lpm	r30, Z
    433e:	e3 30       	cpi	r30, 0x03	; 3
    4340:	f9 f0       	breq	.+62     	; 0x4380 <analogWrite+0x78>
    4342:	48 f4       	brcc	.+18     	; 0x4356 <analogWrite+0x4e>
    4344:	e1 30       	cpi	r30, 0x01	; 1
    4346:	b9 f0       	breq	.+46     	; 0x4376 <analogWrite+0x6e>
    4348:	e2 30       	cpi	r30, 0x02	; 2
    434a:	a1 f5       	brne	.+104    	; 0x43b4 <analogWrite+0xac>
			#endif

			#if defined(TCCR0A) && defined(COM0B1)
			case TIMER0B:
				// connect pwm to pin on timer 0, channel B
				sbi(TCCR0A, COM0B1);
    434c:	84 b5       	in	r24, 0x24	; 36
    434e:	80 62       	ori	r24, 0x20	; 32
    4350:	84 bd       	out	0x24, r24	; 36
				OCR0B = val; // set pwm duty
    4352:	c8 bd       	out	0x28, r28	; 40
				break;
    4354:	34 c0       	rjmp	.+104    	; 0x43be <analogWrite+0xb6>
	{
		digitalWrite(pin, HIGH);
	}
	else
	{
		switch(digitalPinToTimer(pin))
    4356:	e7 30       	cpi	r30, 0x07	; 7
    4358:	e9 f0       	breq	.+58     	; 0x4394 <analogWrite+0x8c>
    435a:	e8 30       	cpi	r30, 0x08	; 8
    435c:	19 f1       	breq	.+70     	; 0x43a4 <analogWrite+0x9c>
    435e:	e4 30       	cpi	r30, 0x04	; 4
    4360:	49 f5       	brne	.+82     	; 0x43b4 <analogWrite+0xac>
			#endif

			#if defined(TCCR1A) && defined(COM1B1)
			case TIMER1B:
				// connect pwm to pin on timer 1, channel B
				sbi(TCCR1A, COM1B1);
    4362:	80 91 80 00 	lds	r24, 0x0080	; 0x800080 <__DATA_REGION_ORIGIN__+0x20>
    4366:	80 62       	ori	r24, 0x20	; 32
    4368:	80 93 80 00 	sts	0x0080, r24	; 0x800080 <__DATA_REGION_ORIGIN__+0x20>
				OCR1B = val; // set pwm duty
    436c:	d0 93 8b 00 	sts	0x008B, r29	; 0x80008b <__DATA_REGION_ORIGIN__+0x2b>
    4370:	c0 93 8a 00 	sts	0x008A, r28	; 0x80008a <__DATA_REGION_ORIGIN__+0x2a>
				break;
    4374:	24 c0       	rjmp	.+72     	; 0x43be <analogWrite+0xb6>
			#endif

			#if defined(TCCR0A) && defined(COM0A1)
			case TIMER0A:
				// connect pwm to pin on timer 0, channel A
				sbi(TCCR0A, COM0A1);
    4376:	84 b5       	in	r24, 0x24	; 36
    4378:	80 68       	ori	r24, 0x80	; 128
    437a:	84 bd       	out	0x24, r24	; 36
				OCR0A = val; // set pwm duty
    437c:	c7 bd       	out	0x27, r28	; 39
				break;
    437e:	1f c0       	rjmp	.+62     	; 0x43be <analogWrite+0xb6>
			#endif

			#if defined(TCCR1A) && defined(COM1A1)
			case TIMER1A:
				// connect pwm to pin on timer 1, channel A
				sbi(TCCR1A, COM1A1);
    4380:	80 91 80 00 	lds	r24, 0x0080	; 0x800080 <__DATA_REGION_ORIGIN__+0x20>
    4384:	80 68       	ori	r24, 0x80	; 128
    4386:	80 93 80 00 	sts	0x0080, r24	; 0x800080 <__DATA_REGION_ORIGIN__+0x20>
				OCR1A = val; // set pwm duty
    438a:	d0 93 89 00 	sts	0x0089, r29	; 0x800089 <__DATA_REGION_ORIGIN__+0x29>
    438e:	c0 93 88 00 	sts	0x0088, r28	; 0x800088 <__DATA_REGION_ORIGIN__+0x28>
				break;
    4392:	15 c0       	rjmp	.+42     	; 0x43be <analogWrite+0xb6>
			#endif

			#if defined(TCCR2A) && defined(COM2A1)
			case TIMER2A:
				// connect pwm to pin on timer 2, channel A
				sbi(TCCR2A, COM2A1);
    4394:	80 91 b0 00 	lds	r24, 0x00B0	; 0x8000b0 <__DATA_REGION_ORIGIN__+0x50>
    4398:	80 68       	ori	r24, 0x80	; 128
    439a:	80 93 b0 00 	sts	0x00B0, r24	; 0x8000b0 <__DATA_REGION_ORIGIN__+0x50>
				OCR2A = val; // set pwm duty
    439e:	c0 93 b3 00 	sts	0x00B3, r28	; 0x8000b3 <__DATA_REGION_ORIGIN__+0x53>
				break;
    43a2:	0d c0       	rjmp	.+26     	; 0x43be <analogWrite+0xb6>
			#endif

			#if defined(TCCR2A) && defined(COM2B1)
			case TIMER2B:
				// connect pwm to pin on timer 2, channel B
				sbi(TCCR2A, COM2B1);
    43a4:	80 91 b0 00 	lds	r24, 0x00B0	; 0x8000b0 <__DATA_REGION_ORIGIN__+0x50>
    43a8:	80 62       	ori	r24, 0x20	; 32
    43aa:	80 93 b0 00 	sts	0x00B0, r24	; 0x8000b0 <__DATA_REGION_ORIGIN__+0x50>
				OCR2B = val; // set pwm duty
    43ae:	c0 93 b4 00 	sts	0x00B4, r28	; 0x8000b4 <__DATA_REGION_ORIGIN__+0x54>
				break;
    43b2:	05 c0       	rjmp	.+10     	; 0x43be <analogWrite+0xb6>
				break;
			#endif

			case NOT_ON_TIMER:
			default:
				if (val < 128) {
    43b4:	c0 38       	cpi	r28, 0x80	; 128
    43b6:	d1 05       	cpc	r29, r1
    43b8:	0c f0       	brlt	.+2      	; 0x43bc <analogWrite+0xb4>
    43ba:	b5 cf       	rjmp	.-150    	; 0x4326 <analogWrite+0x1e>
    43bc:	af cf       	rjmp	.-162    	; 0x431c <analogWrite+0x14>
				} else {
					digitalWrite(pin, HIGH);
				}
		}
	}
}
    43be:	df 91       	pop	r29
    43c0:	cf 91       	pop	r28
    43c2:	1f 91       	pop	r17
    43c4:	08 95       	ret

000043c6 <turnOffPWM>:
//
//static inline void turnOffPWM(uint8_t timer) __attribute__ ((always_inline));
//static inline void turnOffPWM(uint8_t timer)
static void turnOffPWM(uint8_t timer)
{
	switch (timer)
    43c6:	83 30       	cpi	r24, 0x03	; 3
    43c8:	81 f0       	breq	.+32     	; 0x43ea <turnOffPWM+0x24>
    43ca:	28 f4       	brcc	.+10     	; 0x43d6 <turnOffPWM+0x10>
    43cc:	81 30       	cpi	r24, 0x01	; 1
    43ce:	99 f0       	breq	.+38     	; 0x43f6 <turnOffPWM+0x30>
    43d0:	82 30       	cpi	r24, 0x02	; 2
    43d2:	a1 f0       	breq	.+40     	; 0x43fc <turnOffPWM+0x36>
    43d4:	08 95       	ret
    43d6:	87 30       	cpi	r24, 0x07	; 7
    43d8:	a9 f0       	breq	.+42     	; 0x4404 <turnOffPWM+0x3e>
    43da:	88 30       	cpi	r24, 0x08	; 8
    43dc:	b9 f0       	breq	.+46     	; 0x440c <turnOffPWM+0x46>
    43de:	84 30       	cpi	r24, 0x04	; 4
    43e0:	d1 f4       	brne	.+52     	; 0x4416 <turnOffPWM+0x50>
	{
		#if defined(TCCR1A) && defined(COM1A1)
		case TIMER1A:   cbi(TCCR1A, COM1A1);    break;
		#endif
		#if defined(TCCR1A) && defined(COM1B1)
		case TIMER1B:   cbi(TCCR1A, COM1B1);    break;
    43e2:	80 91 80 00 	lds	r24, 0x0080	; 0x800080 <__DATA_REGION_ORIGIN__+0x20>
    43e6:	8f 7d       	andi	r24, 0xDF	; 223
    43e8:	03 c0       	rjmp	.+6      	; 0x43f0 <turnOffPWM+0x2a>
static void turnOffPWM(uint8_t timer)
{
	switch (timer)
	{
		#if defined(TCCR1A) && defined(COM1A1)
		case TIMER1A:   cbi(TCCR1A, COM1A1);    break;
    43ea:	80 91 80 00 	lds	r24, 0x0080	; 0x800080 <__DATA_REGION_ORIGIN__+0x20>
    43ee:	8f 77       	andi	r24, 0x7F	; 127
		#endif
		#if defined(TCCR1A) && defined(COM1B1)
		case TIMER1B:   cbi(TCCR1A, COM1B1);    break;
    43f0:	80 93 80 00 	sts	0x0080, r24	; 0x800080 <__DATA_REGION_ORIGIN__+0x20>
    43f4:	08 95       	ret
		#if defined(TCCR2) && defined(COM21)
		case  TIMER2:   cbi(TCCR2, COM21);      break;
		#endif
		
		#if defined(TCCR0A) && defined(COM0A1)
		case  TIMER0A:  cbi(TCCR0A, COM0A1);    break;
    43f6:	84 b5       	in	r24, 0x24	; 36
    43f8:	8f 77       	andi	r24, 0x7F	; 127
    43fa:	02 c0       	rjmp	.+4      	; 0x4400 <turnOffPWM+0x3a>
		#endif
		
		#if defined(TCCR0A) && defined(COM0B1)
		case  TIMER0B:  cbi(TCCR0A, COM0B1);    break;
    43fc:	84 b5       	in	r24, 0x24	; 36
    43fe:	8f 7d       	andi	r24, 0xDF	; 223
    4400:	84 bd       	out	0x24, r24	; 36
    4402:	08 95       	ret
		#endif
		#if defined(TCCR2A) && defined(COM2A1)
		case  TIMER2A:  cbi(TCCR2A, COM2A1);    break;
    4404:	80 91 b0 00 	lds	r24, 0x00B0	; 0x8000b0 <__DATA_REGION_ORIGIN__+0x50>
    4408:	8f 77       	andi	r24, 0x7F	; 127
    440a:	03 c0       	rjmp	.+6      	; 0x4412 <turnOffPWM+0x4c>
		#endif
		#if defined(TCCR2A) && defined(COM2B1)
		case  TIMER2B:  cbi(TCCR2A, COM2B1);    break;
    440c:	80 91 b0 00 	lds	r24, 0x00B0	; 0x8000b0 <__DATA_REGION_ORIGIN__+0x50>
    4410:	8f 7d       	andi	r24, 0xDF	; 223
    4412:	80 93 b0 00 	sts	0x00B0, r24	; 0x8000b0 <__DATA_REGION_ORIGIN__+0x50>
    4416:	08 95       	ret

00004418 <pinMode>:
#define ARDUINO_MAIN
#include "wiring_private.h"
#include "pins_arduino.h"

void pinMode(uint8_t pin, uint8_t mode)
{
    4418:	cf 93       	push	r28
    441a:	df 93       	push	r29
	uint8_t bit = digitalPinToBitMask(pin);
    441c:	90 e0       	ldi	r25, 0x00	; 0
    441e:	fc 01       	movw	r30, r24
    4420:	ea 53       	subi	r30, 0x3A	; 58
    4422:	ff 4f       	sbci	r31, 0xFF	; 255
    4424:	24 91       	lpm	r18, Z
	uint8_t port = digitalPinToPort(pin);
    4426:	fc 01       	movw	r30, r24
    4428:	e6 52       	subi	r30, 0x26	; 38
    442a:	ff 4f       	sbci	r31, 0xFF	; 255
    442c:	84 91       	lpm	r24, Z
	volatile uint8_t *reg, *out;

	if (port == NOT_A_PIN) return;
    442e:	88 23       	and	r24, r24
    4430:	61 f1       	breq	.+88     	; 0x448a <pinMode+0x72>

	// JWS: can I let the optimizer do this?
	reg = portModeRegister(port);
    4432:	90 e0       	ldi	r25, 0x00	; 0
    4434:	88 0f       	add	r24, r24
    4436:	99 1f       	adc	r25, r25
    4438:	fc 01       	movw	r30, r24
    443a:	ee 5f       	subi	r30, 0xFE	; 254
    443c:	fe 4f       	sbci	r31, 0xFE	; 254
    443e:	c5 91       	lpm	r28, Z+
    4440:	d4 91       	lpm	r29, Z
	out = portOutputRegister(port);
    4442:	fc 01       	movw	r30, r24
    4444:	e8 50       	subi	r30, 0x08	; 8
    4446:	ff 4f       	sbci	r31, 0xFF	; 255
    4448:	a5 91       	lpm	r26, Z+
    444a:	b4 91       	lpm	r27, Z

	if (mode == INPUT) { 
    444c:	61 11       	cpse	r22, r1
    444e:	09 c0       	rjmp	.+18     	; 0x4462 <pinMode+0x4a>
		uint8_t oldSREG = SREG;
    4450:	9f b7       	in	r25, 0x3f	; 63
                cli();
    4452:	f8 94       	cli
		*reg &= ~bit;
    4454:	88 81       	ld	r24, Y
    4456:	20 95       	com	r18
    4458:	82 23       	and	r24, r18
    445a:	88 83       	st	Y, r24
		*out &= ~bit;
    445c:	ec 91       	ld	r30, X
    445e:	2e 23       	and	r18, r30
    4460:	0b c0       	rjmp	.+22     	; 0x4478 <pinMode+0x60>
		SREG = oldSREG;
	} else if (mode == INPUT_PULLUP) {
    4462:	62 30       	cpi	r22, 0x02	; 2
    4464:	61 f4       	brne	.+24     	; 0x447e <pinMode+0x66>
		uint8_t oldSREG = SREG;
    4466:	9f b7       	in	r25, 0x3f	; 63
                cli();
    4468:	f8 94       	cli
		*reg &= ~bit;
    446a:	88 81       	ld	r24, Y
    446c:	32 2f       	mov	r19, r18
    446e:	30 95       	com	r19
    4470:	83 23       	and	r24, r19
    4472:	88 83       	st	Y, r24
		*out |= bit;
    4474:	ec 91       	ld	r30, X
    4476:	2e 2b       	or	r18, r30
    4478:	2c 93       	st	X, r18
		SREG = oldSREG;
    447a:	9f bf       	out	0x3f, r25	; 63
    447c:	06 c0       	rjmp	.+12     	; 0x448a <pinMode+0x72>
	} else {
		uint8_t oldSREG = SREG;
    447e:	8f b7       	in	r24, 0x3f	; 63
                cli();
    4480:	f8 94       	cli
		*reg |= bit;
    4482:	e8 81       	ld	r30, Y
    4484:	2e 2b       	or	r18, r30
    4486:	28 83       	st	Y, r18
		SREG = oldSREG;
    4488:	8f bf       	out	0x3f, r24	; 63
	}
}
    448a:	df 91       	pop	r29
    448c:	cf 91       	pop	r28
    448e:	08 95       	ret

00004490 <digitalWrite>:
		#endif
	}
}

void digitalWrite(uint8_t pin, uint8_t val)
{
    4490:	1f 93       	push	r17
    4492:	cf 93       	push	r28
    4494:	df 93       	push	r29
	uint8_t timer = digitalPinToTimer(pin);
    4496:	28 2f       	mov	r18, r24
    4498:	30 e0       	ldi	r19, 0x00	; 0
    449a:	f9 01       	movw	r30, r18
    449c:	ee 54       	subi	r30, 0x4E	; 78
    449e:	ff 4f       	sbci	r31, 0xFF	; 255
    44a0:	84 91       	lpm	r24, Z
	uint8_t bit = digitalPinToBitMask(pin);
    44a2:	f9 01       	movw	r30, r18
    44a4:	ea 53       	subi	r30, 0x3A	; 58
    44a6:	ff 4f       	sbci	r31, 0xFF	; 255
    44a8:	d4 91       	lpm	r29, Z
	uint8_t port = digitalPinToPort(pin);
    44aa:	f9 01       	movw	r30, r18
    44ac:	e6 52       	subi	r30, 0x26	; 38
    44ae:	ff 4f       	sbci	r31, 0xFF	; 255
    44b0:	c4 91       	lpm	r28, Z
	volatile uint8_t *out;

	if (port == NOT_A_PIN) return;
    44b2:	cc 23       	and	r28, r28
    44b4:	c1 f0       	breq	.+48     	; 0x44e6 <digitalWrite+0x56>
    44b6:	16 2f       	mov	r17, r22

	// If the pin that support PWM output, we need to turn it off
	// before doing a digital write.
	if (timer != NOT_ON_TIMER) turnOffPWM(timer);
    44b8:	81 11       	cpse	r24, r1
    44ba:	0e 94 e3 21 	call	0x43c6	; 0x43c6 <turnOffPWM>

	out = portOutputRegister(port);
    44be:	ec 2f       	mov	r30, r28
    44c0:	f0 e0       	ldi	r31, 0x00	; 0
    44c2:	ee 0f       	add	r30, r30
    44c4:	ff 1f       	adc	r31, r31
    44c6:	e8 50       	subi	r30, 0x08	; 8
    44c8:	ff 4f       	sbci	r31, 0xFF	; 255
    44ca:	a5 91       	lpm	r26, Z+
    44cc:	b4 91       	lpm	r27, Z

	uint8_t oldSREG = SREG;
    44ce:	9f b7       	in	r25, 0x3f	; 63
	cli();
    44d0:	f8 94       	cli

	if (val == LOW) {
    44d2:	11 11       	cpse	r17, r1
    44d4:	04 c0       	rjmp	.+8      	; 0x44de <digitalWrite+0x4e>
		*out &= ~bit;
    44d6:	8c 91       	ld	r24, X
    44d8:	d0 95       	com	r29
    44da:	d8 23       	and	r29, r24
    44dc:	02 c0       	rjmp	.+4      	; 0x44e2 <digitalWrite+0x52>
	} else {
		*out |= bit;
    44de:	ec 91       	ld	r30, X
    44e0:	de 2b       	or	r29, r30
    44e2:	dc 93       	st	X, r29
	}

	SREG = oldSREG;
    44e4:	9f bf       	out	0x3f, r25	; 63
}
    44e6:	df 91       	pop	r29
    44e8:	cf 91       	pop	r28
    44ea:	1f 91       	pop	r17
    44ec:	08 95       	ret

000044ee <_ZN14FreqCountClass5beginEj>:
static uint16_t gate_index;


void FreqCountClass::begin(uint16_t msec)
{
	if (msec < 1) return;
    44ee:	00 97       	sbiw	r24, 0x00	; 0
    44f0:	09 f4       	brne	.+2      	; 0x44f4 <_ZN14FreqCountClass5beginEj+0x6>
    44f2:	74 c0       	rjmp	.+232    	; 0x45dc <L_130_loop+0xc>
	gate_index = 0;
    44f4:	10 92 da 04 	sts	0x04DA, r1	; 0x8004da <_ZL10gate_index+0x1>
    44f8:	10 92 d9 04 	sts	0x04D9, r1	; 0x8004d9 <_ZL10gate_index>
	count_msw = 0;
    44fc:	10 92 e7 04 	sts	0x04E7, r1	; 0x8004e7 <_ZL9count_msw+0x1>
    4500:	10 92 e6 04 	sts	0x04E6, r1	; 0x8004e6 <_ZL9count_msw>
	count_prev = 0;
    4504:	10 92 e2 04 	sts	0x04E2, r1	; 0x8004e2 <_ZL10count_prev>
    4508:	10 92 e3 04 	sts	0x04E3, r1	; 0x8004e3 <_ZL10count_prev+0x1>
    450c:	10 92 e4 04 	sts	0x04E4, r1	; 0x8004e4 <_ZL10count_prev+0x2>
    4510:	10 92 e5 04 	sts	0x04E5, r1	; 0x8004e5 <_ZL10count_prev+0x3>
	count_ready = 0;
    4514:	10 92 dd 04 	sts	0x04DD, r1	; 0x8004dd <_ZL11count_ready>

static uint8_t saveTCCR1A, saveTCCR1B;

static inline void counter_init(void)
{
	saveTCCR1A = TCCR1A;
    4518:	20 91 80 00 	lds	r18, 0x0080	; 0x800080 <__DATA_REGION_ORIGIN__+0x20>
    451c:	20 93 ec 04 	sts	0x04EC, r18	; 0x8004ec <_ZL10saveTCCR1A>
	saveTCCR1B = TCCR1B;
    4520:	20 91 81 00 	lds	r18, 0x0081	; 0x800081 <__DATA_REGION_ORIGIN__+0x21>
    4524:	20 93 eb 04 	sts	0x04EB, r18	; 0x8004eb <_ZL10saveTCCR1B>
	TCCR1B = 0;
    4528:	10 92 81 00 	sts	0x0081, r1	; 0x800081 <__DATA_REGION_ORIGIN__+0x21>
	TCCR1A = 0;
    452c:	10 92 80 00 	sts	0x0080, r1	; 0x800080 <__DATA_REGION_ORIGIN__+0x20>
	TCNT1 = 0;
    4530:	10 92 85 00 	sts	0x0085, r1	; 0x800085 <__DATA_REGION_ORIGIN__+0x25>
    4534:	10 92 84 00 	sts	0x0084, r1	; 0x800084 <__DATA_REGION_ORIGIN__+0x24>
	TIFR1 = (1<<TOV1);
    4538:	21 e0       	ldi	r18, 0x01	; 1
    453a:	26 bb       	out	0x16, r18	; 22
	TIMSK1 = 0;
    453c:	10 92 6f 00 	sts	0x006F, r1	; 0x80006f <__DATA_REGION_ORIGIN__+0xf>

static inline uint16_t timer_init(uint16_t msec)
{
	uint16_t gate_len;

	saveTCCR2A = TCCR2A;
    4540:	20 91 b0 00 	lds	r18, 0x00B0	; 0x8000b0 <__DATA_REGION_ORIGIN__+0x50>
    4544:	20 93 ea 04 	sts	0x04EA, r18	; 0x8004ea <_ZL10saveTCCR2A>
	saveTCCR2B = TCCR2B;
    4548:	20 91 b1 00 	lds	r18, 0x00B1	; 0x8000b1 <__DATA_REGION_ORIGIN__+0x51>
    454c:	20 93 e9 04 	sts	0x04E9, r18	; 0x8004e9 <_ZL10saveTCCR2B>
	TCCR2B = 0;
    4550:	10 92 b1 00 	sts	0x00B1, r1	; 0x8000b1 <__DATA_REGION_ORIGIN__+0x51>
	TCCR2A = (1<<WGM21);
    4554:	22 e0       	ldi	r18, 0x02	; 2
    4556:	20 93 b0 00 	sts	0x00B0, r18	; 0x8000b0 <__DATA_REGION_ORIGIN__+0x50>
	if ((msec & 7) == 0) {
    455a:	9c 01       	movw	r18, r24
    455c:	27 70       	andi	r18, 0x07	; 7
    455e:	33 27       	eor	r19, r19
    4560:	23 2b       	or	r18, r19
    4562:	51 f4       	brne	.+20     	; 0x4578 <_ZN14FreqCountClass5beginEj+0x8a>
		gate_len = msec >> 3;
    4564:	43 e0       	ldi	r20, 0x03	; 3
    4566:	96 95       	lsr	r25
    4568:	87 95       	ror	r24
    456a:	4a 95       	dec	r20
    456c:	e1 f7       	brne	.-8      	; 0x4566 <_ZN14FreqCountClass5beginEj+0x78>
		OCR2A = TIMER2_OCR2A_8MS_VAL;
    456e:	2c e7       	ldi	r18, 0x7C	; 124
    4570:	20 93 b3 00 	sts	0x00B3, r18	; 0x8000b3 <__DATA_REGION_ORIGIN__+0x53>
		startTCCR2B = TIMER2_TCCR2B_8MS_VAL;
    4574:	27 e0       	ldi	r18, 0x07	; 7
    4576:	18 c0       	rjmp	.+48     	; 0x45a8 <_ZN14FreqCountClass5beginEj+0xba>
	} else if ((msec & 3) == 0) {
    4578:	9c 01       	movw	r18, r24
    457a:	23 70       	andi	r18, 0x03	; 3
    457c:	33 27       	eor	r19, r19
    457e:	23 2b       	or	r18, r19
    4580:	31 f4       	brne	.+12     	; 0x458e <_ZN14FreqCountClass5beginEj+0xa0>
		gate_len = msec >> 2;
    4582:	96 95       	lsr	r25
    4584:	87 95       	ror	r24
    4586:	96 95       	lsr	r25
    4588:	87 95       	ror	r24
		OCR2A = TIMER2_OCR2A_4MS_VAL;
    458a:	29 ef       	ldi	r18, 0xF9	; 249
    458c:	05 c0       	rjmp	.+10     	; 0x4598 <_ZN14FreqCountClass5beginEj+0xaa>
		startTCCR2B = TIMER2_TCCR2B_4MS_VAL;
	} else if ((msec & 1) == 0) {
    458e:	80 fd       	sbrc	r24, 0
    4590:	07 c0       	rjmp	.+14     	; 0x45a0 <_ZN14FreqCountClass5beginEj+0xb2>
		gate_len = msec >> 1;
    4592:	96 95       	lsr	r25
    4594:	87 95       	ror	r24
		OCR2A = TIMER2_OCR2A_2MS_VAL;
    4596:	2c e7       	ldi	r18, 0x7C	; 124
    4598:	20 93 b3 00 	sts	0x00B3, r18	; 0x8000b3 <__DATA_REGION_ORIGIN__+0x53>
		startTCCR2B = TIMER2_TCCR2B_2MS_VAL;
    459c:	26 e0       	ldi	r18, 0x06	; 6
    459e:	04 c0       	rjmp	.+8      	; 0x45a8 <_ZN14FreqCountClass5beginEj+0xba>
	} else {
		gate_len = msec;
		OCR2A = TIMER2_OCR2A_1MS_VAL;
    45a0:	2c e7       	ldi	r18, 0x7C	; 124
    45a2:	20 93 b3 00 	sts	0x00B3, r18	; 0x8000b3 <__DATA_REGION_ORIGIN__+0x53>
		startTCCR2B = TIMER2_TCCR2B_1MS_VAL;
    45a6:	25 e0       	ldi	r18, 0x05	; 5
    45a8:	20 93 e8 04 	sts	0x04E8, r18	; 0x8004e8 <_ZL11startTCCR2B>
	}
	TIFR2 = (1<<OCF2A);
    45ac:	22 e0       	ldi	r18, 0x02	; 2
    45ae:	27 bb       	out	0x17, r18	; 23
	TCNT2 = 0;
    45b0:	10 92 b2 00 	sts	0x00B2, r1	; 0x8000b2 <__DATA_REGION_ORIGIN__+0x52>
	counter_init();
	gate_length = timer_init(msec);
    45b4:	90 93 dc 04 	sts	0x04DC, r25	; 0x8004dc <_ZL11gate_length+0x1>
    45b8:	80 93 db 04 	sts	0x04DB, r24	; 0x8004db <_ZL11gate_length>
	uint8_t status = SREG;
    45bc:	9f b7       	in	r25, 0x3f	; 63
	cli();
    45be:	f8 94       	cli
	return gate_len;
}

static inline void timer_start(void)
{
	GTCCR = (1<<PSRASY);
    45c0:	23 bd       	out	0x23, r18	; 35
	TCCR2B = startTCCR2B;
    45c2:	80 91 e8 04 	lds	r24, 0x04E8	; 0x8004e8 <_ZL11startTCCR2B>
    45c6:	80 93 b1 00 	sts	0x00B1, r24	; 0x8000b1 <__DATA_REGION_ORIGIN__+0x51>
	TIMSK2 = (1<<OCIE2A);
    45ca:	20 93 70 00 	sts	0x0070, r18	; 0x800070 <__DATA_REGION_ORIGIN__+0x10>
		"L_%=_loop:"
		"subi   %0, 1"		"\n\t"
		"brne   L_%=_loop"	"\n\t"
		: "+d" (cycles_times_3)
		: "0" (cycles_times_3)
	);
    45ce:	8b e0       	ldi	r24, 0x0B	; 11

000045d0 <L_130_loop>:
    45d0:	81 50       	subi	r24, 0x01	; 1
    45d2:	f1 f7       	brne	.-4      	; 0x45d0 <L_130_loop>
	TIMSK1 = 0;
}

static inline void counter_start(void)
{
	TCCR1B = (1<<CS12) | (1<<CS11) | (1<<CS10);
    45d4:	87 e0       	ldi	r24, 0x07	; 7
    45d6:	80 93 81 00 	sts	0x0081, r24	; 0x800081 <__DATA_REGION_ORIGIN__+0x21>
	timer_start();
	timer_isr_latency_delay();
	counter_start();
	SREG = status;
    45da:	9f bf       	out	0x3f, r25	; 63
    45dc:	08 95       	ret

000045de <_ZN14FreqCountClass9availableEv>:
}

uint8_t FreqCountClass::available(void)
{
	return count_ready;
    45de:	80 91 dd 04 	lds	r24, 0x04DD	; 0x8004dd <_ZL11count_ready>
}
    45e2:	08 95       	ret

000045e4 <_ZN14FreqCountClass4readEv>:
uint32_t FreqCountClass::read(void)
{
	uint32_t count;
	uint8_t status;

	status = SREG;
    45e4:	2f b7       	in	r18, 0x3f	; 63
	cli();
    45e6:	f8 94       	cli
	count = count_output;
    45e8:	60 91 de 04 	lds	r22, 0x04DE	; 0x8004de <_ZL12count_output>
    45ec:	70 91 df 04 	lds	r23, 0x04DF	; 0x8004df <_ZL12count_output+0x1>
    45f0:	80 91 e0 04 	lds	r24, 0x04E0	; 0x8004e0 <_ZL12count_output+0x2>
    45f4:	90 91 e1 04 	lds	r25, 0x04E1	; 0x8004e1 <_ZL12count_output+0x3>
	count_ready = 0;
    45f8:	10 92 dd 04 	sts	0x04DD, r1	; 0x8004dd <_ZL11count_ready>
	SREG = status;
    45fc:	2f bf       	out	0x3f, r18	; 63
	return count;
}
    45fe:	08 95       	ret

00004600 <_ZN14FreqCountClass3endEv>:
	TIMSK2 = (1<<OCIE2A);
}

static inline void timer_shutdown(void)
{
	TCCR2B = 0;
    4600:	e1 eb       	ldi	r30, 0xB1	; 177
    4602:	f0 e0       	ldi	r31, 0x00	; 0
    4604:	10 82       	st	Z, r1
	TIMSK2 = 0;
    4606:	10 92 70 00 	sts	0x0070, r1	; 0x800070 <__DATA_REGION_ORIGIN__+0x10>
	TCCR2A = saveTCCR2A;
    460a:	80 91 ea 04 	lds	r24, 0x04EA	; 0x8004ea <_ZL10saveTCCR2A>
    460e:	80 93 b0 00 	sts	0x00B0, r24	; 0x8000b0 <__DATA_REGION_ORIGIN__+0x50>
	TCCR2B = saveTCCR2B;
    4612:	80 91 e9 04 	lds	r24, 0x04E9	; 0x8004e9 <_ZL10saveTCCR2B>
    4616:	80 83       	st	Z, r24
	TCCR1B = (1<<CS12) | (1<<CS11) | (1<<CS10);
}

static inline void counter_shutdown(void)
{
	TCCR1B = 0;
    4618:	e1 e8       	ldi	r30, 0x81	; 129
    461a:	f0 e0       	ldi	r31, 0x00	; 0
    461c:	10 82       	st	Z, r1
	TCCR1A = saveTCCR1A;
    461e:	80 91 ec 04 	lds	r24, 0x04EC	; 0x8004ec <_ZL10saveTCCR1A>
    4622:	80 93 80 00 	sts	0x0080, r24	; 0x800080 <__DATA_REGION_ORIGIN__+0x20>
	TCCR1B = saveTCCR1B;
    4626:	80 91 eb 04 	lds	r24, 0x04EB	; 0x8004eb <_ZL10saveTCCR1B>
    462a:	80 83       	st	Z, r24
    462c:	08 95       	ret

0000462e <__vector_7>:
	counter_shutdown();
}


ISR(TIMER_ISR_VECTOR)
{
    462e:	1f 92       	push	r1
    4630:	0f 92       	push	r0
    4632:	0f b6       	in	r0, 0x3f	; 63
    4634:	0f 92       	push	r0
    4636:	11 24       	eor	r1, r1
    4638:	0f 93       	push	r16
    463a:	1f 93       	push	r17
    463c:	2f 93       	push	r18
    463e:	3f 93       	push	r19
    4640:	4f 93       	push	r20
    4642:	5f 93       	push	r21
    4644:	6f 93       	push	r22
    4646:	7f 93       	push	r23
    4648:	8f 93       	push	r24
    464a:	9f 93       	push	r25
    464c:	af 93       	push	r26
    464e:	bf 93       	push	r27
}

static inline uint16_t counter_read(void)
{
	return TCNT1;
    4650:	20 91 84 00 	lds	r18, 0x0084	; 0x800084 <__DATA_REGION_ORIGIN__+0x24>
    4654:	30 91 85 00 	lds	r19, 0x0085	; 0x800085 <__DATA_REGION_ORIGIN__+0x25>
	uint16_t count_lsw;
	uint32_t count;
	uint16_t index, length;

	count_lsw = counter_read();
	if (counter_overflow()) {
    4658:	b0 9b       	sbis	0x16, 0	; 22
    465a:	0b c0       	rjmp	.+22     	; 0x4672 <__vector_7+0x44>
	return TIFR1 & (1<<TOV1);
}

static inline void counter_overflow_reset(void)
{
	TIFR1 = (1<<TOV1);
    465c:	81 e0       	ldi	r24, 0x01	; 1
    465e:	86 bb       	out	0x16, r24	; 22
		counter_overflow_reset();
		count_msw++;
    4660:	80 91 e6 04 	lds	r24, 0x04E6	; 0x8004e6 <_ZL9count_msw>
    4664:	90 91 e7 04 	lds	r25, 0x04E7	; 0x8004e7 <_ZL9count_msw+0x1>
    4668:	01 96       	adiw	r24, 0x01	; 1
    466a:	90 93 e7 04 	sts	0x04E7, r25	; 0x8004e7 <_ZL9count_msw+0x1>
    466e:	80 93 e6 04 	sts	0x04E6, r24	; 0x8004e6 <_ZL9count_msw>
	}
	index = gate_index + 1;
    4672:	80 91 d9 04 	lds	r24, 0x04D9	; 0x8004d9 <_ZL10gate_index>
    4676:	90 91 da 04 	lds	r25, 0x04DA	; 0x8004da <_ZL10gate_index+0x1>
    467a:	01 96       	adiw	r24, 0x01	; 1
	length = gate_length;
	if (index >= length) {
    467c:	40 91 db 04 	lds	r20, 0x04DB	; 0x8004db <_ZL11gate_length>
    4680:	50 91 dc 04 	lds	r21, 0x04DC	; 0x8004dc <_ZL11gate_length+0x1>
    4684:	84 17       	cp	r24, r20
    4686:	95 07       	cpc	r25, r21
    4688:	98 f1       	brcs	.+102    	; 0x46f0 <__vector_7+0xc2>
		gate_index = 0;
    468a:	10 92 da 04 	sts	0x04DA, r1	; 0x8004da <_ZL10gate_index+0x1>
    468e:	10 92 d9 04 	sts	0x04D9, r1	; 0x8004d9 <_ZL10gate_index>
		count = ((uint32_t)count_msw << 16) + count_lsw;
    4692:	80 91 e6 04 	lds	r24, 0x04E6	; 0x8004e6 <_ZL9count_msw>
    4696:	90 91 e7 04 	lds	r25, 0x04E7	; 0x8004e7 <_ZL9count_msw+0x1>
    469a:	a0 e0       	ldi	r26, 0x00	; 0
    469c:	b0 e0       	ldi	r27, 0x00	; 0
    469e:	dc 01       	movw	r26, r24
    46a0:	99 27       	eor	r25, r25
    46a2:	88 27       	eor	r24, r24
    46a4:	82 0f       	add	r24, r18
    46a6:	93 1f       	adc	r25, r19
    46a8:	a1 1d       	adc	r26, r1
    46aa:	b1 1d       	adc	r27, r1
		count_output = count - count_prev;
    46ac:	40 91 e2 04 	lds	r20, 0x04E2	; 0x8004e2 <_ZL10count_prev>
    46b0:	50 91 e3 04 	lds	r21, 0x04E3	; 0x8004e3 <_ZL10count_prev+0x1>
    46b4:	60 91 e4 04 	lds	r22, 0x04E4	; 0x8004e4 <_ZL10count_prev+0x2>
    46b8:	70 91 e5 04 	lds	r23, 0x04E5	; 0x8004e5 <_ZL10count_prev+0x3>
    46bc:	8c 01       	movw	r16, r24
    46be:	9d 01       	movw	r18, r26
    46c0:	04 1b       	sub	r16, r20
    46c2:	15 0b       	sbc	r17, r21
    46c4:	26 0b       	sbc	r18, r22
    46c6:	37 0b       	sbc	r19, r23
    46c8:	00 93 de 04 	sts	0x04DE, r16	; 0x8004de <_ZL12count_output>
    46cc:	10 93 df 04 	sts	0x04DF, r17	; 0x8004df <_ZL12count_output+0x1>
    46d0:	20 93 e0 04 	sts	0x04E0, r18	; 0x8004e0 <_ZL12count_output+0x2>
    46d4:	30 93 e1 04 	sts	0x04E1, r19	; 0x8004e1 <_ZL12count_output+0x3>
		count_prev = count;
    46d8:	80 93 e2 04 	sts	0x04E2, r24	; 0x8004e2 <_ZL10count_prev>
    46dc:	90 93 e3 04 	sts	0x04E3, r25	; 0x8004e3 <_ZL10count_prev+0x1>
    46e0:	a0 93 e4 04 	sts	0x04E4, r26	; 0x8004e4 <_ZL10count_prev+0x2>
    46e4:	b0 93 e5 04 	sts	0x04E5, r27	; 0x8004e5 <_ZL10count_prev+0x3>
		count_ready = 1;
    46e8:	81 e0       	ldi	r24, 0x01	; 1
    46ea:	80 93 dd 04 	sts	0x04DD, r24	; 0x8004dd <_ZL11count_ready>
    46ee:	04 c0       	rjmp	.+8      	; 0x46f8 <__vector_7+0xca>
		restore_other_interrupts();
	} else {
		if (index == length - 1) disable_other_interrupts();
		gate_index = index;
    46f0:	90 93 da 04 	sts	0x04DA, r25	; 0x8004da <_ZL10gate_index+0x1>
    46f4:	80 93 d9 04 	sts	0x04D9, r24	; 0x8004d9 <_ZL10gate_index>
	}
}
    46f8:	bf 91       	pop	r27
    46fa:	af 91       	pop	r26
    46fc:	9f 91       	pop	r25
    46fe:	8f 91       	pop	r24
    4700:	7f 91       	pop	r23
    4702:	6f 91       	pop	r22
    4704:	5f 91       	pop	r21
    4706:	4f 91       	pop	r20
    4708:	3f 91       	pop	r19
    470a:	2f 91       	pop	r18
    470c:	1f 91       	pop	r17
    470e:	0f 91       	pop	r16
    4710:	0f 90       	pop	r0
    4712:	0f be       	out	0x3f, r0	; 63
    4714:	0f 90       	pop	r0
    4716:	1f 90       	pop	r1
    4718:	18 95       	reti

0000471a <yield>:
 * libraries or sketches that supports cooperative threads.
 *
 * Its defined as a weak symbol and it can be redefined to implement a
 * real cooperative scheduler.
 */
static void __empty() {
    471a:	08 95       	ret

0000471c <__divmodhi4>:
    471c:	97 fb       	bst	r25, 7
    471e:	07 2e       	mov	r0, r23
    4720:	16 f4       	brtc	.+4      	; 0x4726 <__divmodhi4+0xa>
    4722:	00 94       	com	r0
    4724:	07 d0       	rcall	.+14     	; 0x4734 <__divmodhi4_neg1>
    4726:	77 fd       	sbrc	r23, 7
    4728:	09 d0       	rcall	.+18     	; 0x473c <__divmodhi4_neg2>
    472a:	0e 94 f4 23 	call	0x47e8	; 0x47e8 <__udivmodhi4>
    472e:	07 fc       	sbrc	r0, 7
    4730:	05 d0       	rcall	.+10     	; 0x473c <__divmodhi4_neg2>
    4732:	3e f4       	brtc	.+14     	; 0x4742 <__divmodhi4_exit>

00004734 <__divmodhi4_neg1>:
    4734:	90 95       	com	r25
    4736:	81 95       	neg	r24
    4738:	9f 4f       	sbci	r25, 0xFF	; 255
    473a:	08 95       	ret

0000473c <__divmodhi4_neg2>:
    473c:	70 95       	com	r23
    473e:	61 95       	neg	r22
    4740:	7f 4f       	sbci	r23, 0xFF	; 255

00004742 <__divmodhi4_exit>:
    4742:	08 95       	ret

00004744 <__udivmodsi4>:
    4744:	a1 e2       	ldi	r26, 0x21	; 33
    4746:	1a 2e       	mov	r1, r26
    4748:	aa 1b       	sub	r26, r26
    474a:	bb 1b       	sub	r27, r27
    474c:	fd 01       	movw	r30, r26
    474e:	0d c0       	rjmp	.+26     	; 0x476a <__udivmodsi4_ep>

00004750 <__udivmodsi4_loop>:
    4750:	aa 1f       	adc	r26, r26
    4752:	bb 1f       	adc	r27, r27
    4754:	ee 1f       	adc	r30, r30
    4756:	ff 1f       	adc	r31, r31
    4758:	a2 17       	cp	r26, r18
    475a:	b3 07       	cpc	r27, r19
    475c:	e4 07       	cpc	r30, r20
    475e:	f5 07       	cpc	r31, r21
    4760:	20 f0       	brcs	.+8      	; 0x476a <__udivmodsi4_ep>
    4762:	a2 1b       	sub	r26, r18
    4764:	b3 0b       	sbc	r27, r19
    4766:	e4 0b       	sbc	r30, r20
    4768:	f5 0b       	sbc	r31, r21

0000476a <__udivmodsi4_ep>:
    476a:	66 1f       	adc	r22, r22
    476c:	77 1f       	adc	r23, r23
    476e:	88 1f       	adc	r24, r24
    4770:	99 1f       	adc	r25, r25
    4772:	1a 94       	dec	r1
    4774:	69 f7       	brne	.-38     	; 0x4750 <__udivmodsi4_loop>
    4776:	60 95       	com	r22
    4778:	70 95       	com	r23
    477a:	80 95       	com	r24
    477c:	90 95       	com	r25
    477e:	9b 01       	movw	r18, r22
    4780:	ac 01       	movw	r20, r24
    4782:	bd 01       	movw	r22, r26
    4784:	cf 01       	movw	r24, r30
    4786:	08 95       	ret

00004788 <__divmodsi4>:
    4788:	05 2e       	mov	r0, r21
    478a:	97 fb       	bst	r25, 7
    478c:	1e f4       	brtc	.+6      	; 0x4794 <__divmodsi4+0xc>
    478e:	00 94       	com	r0
    4790:	0e 94 db 23 	call	0x47b6	; 0x47b6 <__negsi2>
    4794:	57 fd       	sbrc	r21, 7
    4796:	07 d0       	rcall	.+14     	; 0x47a6 <__divmodsi4_neg2>
    4798:	0e 94 a2 23 	call	0x4744	; 0x4744 <__udivmodsi4>
    479c:	07 fc       	sbrc	r0, 7
    479e:	03 d0       	rcall	.+6      	; 0x47a6 <__divmodsi4_neg2>
    47a0:	4e f4       	brtc	.+18     	; 0x47b4 <__divmodsi4_exit>
    47a2:	0c 94 db 23 	jmp	0x47b6	; 0x47b6 <__negsi2>

000047a6 <__divmodsi4_neg2>:
    47a6:	50 95       	com	r21
    47a8:	40 95       	com	r20
    47aa:	30 95       	com	r19
    47ac:	21 95       	neg	r18
    47ae:	3f 4f       	sbci	r19, 0xFF	; 255
    47b0:	4f 4f       	sbci	r20, 0xFF	; 255
    47b2:	5f 4f       	sbci	r21, 0xFF	; 255

000047b4 <__divmodsi4_exit>:
    47b4:	08 95       	ret

000047b6 <__negsi2>:
    47b6:	90 95       	com	r25
    47b8:	80 95       	com	r24
    47ba:	70 95       	com	r23
    47bc:	61 95       	neg	r22
    47be:	7f 4f       	sbci	r23, 0xFF	; 255
    47c0:	8f 4f       	sbci	r24, 0xFF	; 255
    47c2:	9f 4f       	sbci	r25, 0xFF	; 255
    47c4:	08 95       	ret

000047c6 <__tablejump2__>:
    47c6:	ee 0f       	add	r30, r30
    47c8:	ff 1f       	adc	r31, r31
    47ca:	05 90       	lpm	r0, Z+
    47cc:	f4 91       	lpm	r31, Z
    47ce:	e0 2d       	mov	r30, r0
    47d0:	09 94       	ijmp

000047d2 <__muluhisi3>:
    47d2:	0e 94 08 24 	call	0x4810	; 0x4810 <__umulhisi3>
    47d6:	a5 9f       	mul	r26, r21
    47d8:	90 0d       	add	r25, r0
    47da:	b4 9f       	mul	r27, r20
    47dc:	90 0d       	add	r25, r0
    47de:	a4 9f       	mul	r26, r20
    47e0:	80 0d       	add	r24, r0
    47e2:	91 1d       	adc	r25, r1
    47e4:	11 24       	eor	r1, r1
    47e6:	08 95       	ret

000047e8 <__udivmodhi4>:
    47e8:	aa 1b       	sub	r26, r26
    47ea:	bb 1b       	sub	r27, r27
    47ec:	51 e1       	ldi	r21, 0x11	; 17
    47ee:	07 c0       	rjmp	.+14     	; 0x47fe <__udivmodhi4_ep>

000047f0 <__udivmodhi4_loop>:
    47f0:	aa 1f       	adc	r26, r26
    47f2:	bb 1f       	adc	r27, r27
    47f4:	a6 17       	cp	r26, r22
    47f6:	b7 07       	cpc	r27, r23
    47f8:	10 f0       	brcs	.+4      	; 0x47fe <__udivmodhi4_ep>
    47fa:	a6 1b       	sub	r26, r22
    47fc:	b7 0b       	sbc	r27, r23

000047fe <__udivmodhi4_ep>:
    47fe:	88 1f       	adc	r24, r24
    4800:	99 1f       	adc	r25, r25
    4802:	5a 95       	dec	r21
    4804:	a9 f7       	brne	.-22     	; 0x47f0 <__udivmodhi4_loop>
    4806:	80 95       	com	r24
    4808:	90 95       	com	r25
    480a:	bc 01       	movw	r22, r24
    480c:	cd 01       	movw	r24, r26
    480e:	08 95       	ret

00004810 <__umulhisi3>:
    4810:	a2 9f       	mul	r26, r18
    4812:	b0 01       	movw	r22, r0
    4814:	b3 9f       	mul	r27, r19
    4816:	c0 01       	movw	r24, r0
    4818:	a3 9f       	mul	r26, r19
    481a:	70 0d       	add	r23, r0
    481c:	81 1d       	adc	r24, r1
    481e:	11 24       	eor	r1, r1
    4820:	91 1d       	adc	r25, r1
    4822:	b2 9f       	mul	r27, r18
    4824:	70 0d       	add	r23, r0
    4826:	81 1d       	adc	r24, r1
    4828:	11 24       	eor	r1, r1
    482a:	91 1d       	adc	r25, r1
    482c:	08 95       	ret

0000482e <malloc>:
    482e:	0f 93       	push	r16
    4830:	1f 93       	push	r17
    4832:	cf 93       	push	r28
    4834:	df 93       	push	r29
    4836:	82 30       	cpi	r24, 0x02	; 2
    4838:	91 05       	cpc	r25, r1
    483a:	10 f4       	brcc	.+4      	; 0x4840 <malloc+0x12>
    483c:	82 e0       	ldi	r24, 0x02	; 2
    483e:	90 e0       	ldi	r25, 0x00	; 0
    4840:	e0 91 ef 04 	lds	r30, 0x04EF	; 0x8004ef <__flp>
    4844:	f0 91 f0 04 	lds	r31, 0x04F0	; 0x8004f0 <__flp+0x1>
    4848:	20 e0       	ldi	r18, 0x00	; 0
    484a:	30 e0       	ldi	r19, 0x00	; 0
    484c:	a0 e0       	ldi	r26, 0x00	; 0
    484e:	b0 e0       	ldi	r27, 0x00	; 0
    4850:	30 97       	sbiw	r30, 0x00	; 0
    4852:	19 f1       	breq	.+70     	; 0x489a <malloc+0x6c>
    4854:	40 81       	ld	r20, Z
    4856:	51 81       	ldd	r21, Z+1	; 0x01
    4858:	02 81       	ldd	r16, Z+2	; 0x02
    485a:	13 81       	ldd	r17, Z+3	; 0x03
    485c:	48 17       	cp	r20, r24
    485e:	59 07       	cpc	r21, r25
    4860:	c8 f0       	brcs	.+50     	; 0x4894 <malloc+0x66>
    4862:	84 17       	cp	r24, r20
    4864:	95 07       	cpc	r25, r21
    4866:	69 f4       	brne	.+26     	; 0x4882 <malloc+0x54>
    4868:	10 97       	sbiw	r26, 0x00	; 0
    486a:	31 f0       	breq	.+12     	; 0x4878 <malloc+0x4a>
    486c:	12 96       	adiw	r26, 0x02	; 2
    486e:	0c 93       	st	X, r16
    4870:	12 97       	sbiw	r26, 0x02	; 2
    4872:	13 96       	adiw	r26, 0x03	; 3
    4874:	1c 93       	st	X, r17
    4876:	27 c0       	rjmp	.+78     	; 0x48c6 <malloc+0x98>
    4878:	00 93 ef 04 	sts	0x04EF, r16	; 0x8004ef <__flp>
    487c:	10 93 f0 04 	sts	0x04F0, r17	; 0x8004f0 <__flp+0x1>
    4880:	22 c0       	rjmp	.+68     	; 0x48c6 <malloc+0x98>
    4882:	21 15       	cp	r18, r1
    4884:	31 05       	cpc	r19, r1
    4886:	19 f0       	breq	.+6      	; 0x488e <malloc+0x60>
    4888:	42 17       	cp	r20, r18
    488a:	53 07       	cpc	r21, r19
    488c:	18 f4       	brcc	.+6      	; 0x4894 <malloc+0x66>
    488e:	9a 01       	movw	r18, r20
    4890:	bd 01       	movw	r22, r26
    4892:	ef 01       	movw	r28, r30
    4894:	df 01       	movw	r26, r30
    4896:	f8 01       	movw	r30, r16
    4898:	db cf       	rjmp	.-74     	; 0x4850 <malloc+0x22>
    489a:	21 15       	cp	r18, r1
    489c:	31 05       	cpc	r19, r1
    489e:	f9 f0       	breq	.+62     	; 0x48de <malloc+0xb0>
    48a0:	28 1b       	sub	r18, r24
    48a2:	39 0b       	sbc	r19, r25
    48a4:	24 30       	cpi	r18, 0x04	; 4
    48a6:	31 05       	cpc	r19, r1
    48a8:	80 f4       	brcc	.+32     	; 0x48ca <malloc+0x9c>
    48aa:	8a 81       	ldd	r24, Y+2	; 0x02
    48ac:	9b 81       	ldd	r25, Y+3	; 0x03
    48ae:	61 15       	cp	r22, r1
    48b0:	71 05       	cpc	r23, r1
    48b2:	21 f0       	breq	.+8      	; 0x48bc <malloc+0x8e>
    48b4:	fb 01       	movw	r30, r22
    48b6:	93 83       	std	Z+3, r25	; 0x03
    48b8:	82 83       	std	Z+2, r24	; 0x02
    48ba:	04 c0       	rjmp	.+8      	; 0x48c4 <malloc+0x96>
    48bc:	90 93 f0 04 	sts	0x04F0, r25	; 0x8004f0 <__flp+0x1>
    48c0:	80 93 ef 04 	sts	0x04EF, r24	; 0x8004ef <__flp>
    48c4:	fe 01       	movw	r30, r28
    48c6:	32 96       	adiw	r30, 0x02	; 2
    48c8:	44 c0       	rjmp	.+136    	; 0x4952 <malloc+0x124>
    48ca:	fe 01       	movw	r30, r28
    48cc:	e2 0f       	add	r30, r18
    48ce:	f3 1f       	adc	r31, r19
    48d0:	81 93       	st	Z+, r24
    48d2:	91 93       	st	Z+, r25
    48d4:	22 50       	subi	r18, 0x02	; 2
    48d6:	31 09       	sbc	r19, r1
    48d8:	39 83       	std	Y+1, r19	; 0x01
    48da:	28 83       	st	Y, r18
    48dc:	3a c0       	rjmp	.+116    	; 0x4952 <malloc+0x124>
    48de:	20 91 ed 04 	lds	r18, 0x04ED	; 0x8004ed <__brkval>
    48e2:	30 91 ee 04 	lds	r19, 0x04EE	; 0x8004ee <__brkval+0x1>
    48e6:	23 2b       	or	r18, r19
    48e8:	41 f4       	brne	.+16     	; 0x48fa <malloc+0xcc>
    48ea:	20 91 02 01 	lds	r18, 0x0102	; 0x800102 <__malloc_heap_start>
    48ee:	30 91 03 01 	lds	r19, 0x0103	; 0x800103 <__malloc_heap_start+0x1>
    48f2:	30 93 ee 04 	sts	0x04EE, r19	; 0x8004ee <__brkval+0x1>
    48f6:	20 93 ed 04 	sts	0x04ED, r18	; 0x8004ed <__brkval>
    48fa:	20 91 00 01 	lds	r18, 0x0100	; 0x800100 <__data_start>
    48fe:	30 91 01 01 	lds	r19, 0x0101	; 0x800101 <__data_start+0x1>
    4902:	21 15       	cp	r18, r1
    4904:	31 05       	cpc	r19, r1
    4906:	41 f4       	brne	.+16     	; 0x4918 <malloc+0xea>
    4908:	2d b7       	in	r18, 0x3d	; 61
    490a:	3e b7       	in	r19, 0x3e	; 62
    490c:	40 91 04 01 	lds	r20, 0x0104	; 0x800104 <__malloc_margin>
    4910:	50 91 05 01 	lds	r21, 0x0105	; 0x800105 <__malloc_margin+0x1>
    4914:	24 1b       	sub	r18, r20
    4916:	35 0b       	sbc	r19, r21
    4918:	e0 91 ed 04 	lds	r30, 0x04ED	; 0x8004ed <__brkval>
    491c:	f0 91 ee 04 	lds	r31, 0x04EE	; 0x8004ee <__brkval+0x1>
    4920:	e2 17       	cp	r30, r18
    4922:	f3 07       	cpc	r31, r19
    4924:	a0 f4       	brcc	.+40     	; 0x494e <malloc+0x120>
    4926:	2e 1b       	sub	r18, r30
    4928:	3f 0b       	sbc	r19, r31
    492a:	28 17       	cp	r18, r24
    492c:	39 07       	cpc	r19, r25
    492e:	78 f0       	brcs	.+30     	; 0x494e <malloc+0x120>
    4930:	ac 01       	movw	r20, r24
    4932:	4e 5f       	subi	r20, 0xFE	; 254
    4934:	5f 4f       	sbci	r21, 0xFF	; 255
    4936:	24 17       	cp	r18, r20
    4938:	35 07       	cpc	r19, r21
    493a:	48 f0       	brcs	.+18     	; 0x494e <malloc+0x120>
    493c:	4e 0f       	add	r20, r30
    493e:	5f 1f       	adc	r21, r31
    4940:	50 93 ee 04 	sts	0x04EE, r21	; 0x8004ee <__brkval+0x1>
    4944:	40 93 ed 04 	sts	0x04ED, r20	; 0x8004ed <__brkval>
    4948:	81 93       	st	Z+, r24
    494a:	91 93       	st	Z+, r25
    494c:	02 c0       	rjmp	.+4      	; 0x4952 <malloc+0x124>
    494e:	e0 e0       	ldi	r30, 0x00	; 0
    4950:	f0 e0       	ldi	r31, 0x00	; 0
    4952:	cf 01       	movw	r24, r30
    4954:	df 91       	pop	r29
    4956:	cf 91       	pop	r28
    4958:	1f 91       	pop	r17
    495a:	0f 91       	pop	r16
    495c:	08 95       	ret

0000495e <free>:
    495e:	cf 93       	push	r28
    4960:	df 93       	push	r29
    4962:	00 97       	sbiw	r24, 0x00	; 0
    4964:	09 f4       	brne	.+2      	; 0x4968 <free+0xa>
    4966:	81 c0       	rjmp	.+258    	; 0x4a6a <free+0x10c>
    4968:	fc 01       	movw	r30, r24
    496a:	32 97       	sbiw	r30, 0x02	; 2
    496c:	13 82       	std	Z+3, r1	; 0x03
    496e:	12 82       	std	Z+2, r1	; 0x02
    4970:	a0 91 ef 04 	lds	r26, 0x04EF	; 0x8004ef <__flp>
    4974:	b0 91 f0 04 	lds	r27, 0x04F0	; 0x8004f0 <__flp+0x1>
    4978:	10 97       	sbiw	r26, 0x00	; 0
    497a:	81 f4       	brne	.+32     	; 0x499c <free+0x3e>
    497c:	20 81       	ld	r18, Z
    497e:	31 81       	ldd	r19, Z+1	; 0x01
    4980:	82 0f       	add	r24, r18
    4982:	93 1f       	adc	r25, r19
    4984:	20 91 ed 04 	lds	r18, 0x04ED	; 0x8004ed <__brkval>
    4988:	30 91 ee 04 	lds	r19, 0x04EE	; 0x8004ee <__brkval+0x1>
    498c:	28 17       	cp	r18, r24
    498e:	39 07       	cpc	r19, r25
    4990:	51 f5       	brne	.+84     	; 0x49e6 <free+0x88>
    4992:	f0 93 ee 04 	sts	0x04EE, r31	; 0x8004ee <__brkval+0x1>
    4996:	e0 93 ed 04 	sts	0x04ED, r30	; 0x8004ed <__brkval>
    499a:	67 c0       	rjmp	.+206    	; 0x4a6a <free+0x10c>
    499c:	ed 01       	movw	r28, r26
    499e:	20 e0       	ldi	r18, 0x00	; 0
    49a0:	30 e0       	ldi	r19, 0x00	; 0
    49a2:	ce 17       	cp	r28, r30
    49a4:	df 07       	cpc	r29, r31
    49a6:	40 f4       	brcc	.+16     	; 0x49b8 <free+0x5a>
    49a8:	4a 81       	ldd	r20, Y+2	; 0x02
    49aa:	5b 81       	ldd	r21, Y+3	; 0x03
    49ac:	9e 01       	movw	r18, r28
    49ae:	41 15       	cp	r20, r1
    49b0:	51 05       	cpc	r21, r1
    49b2:	f1 f0       	breq	.+60     	; 0x49f0 <free+0x92>
    49b4:	ea 01       	movw	r28, r20
    49b6:	f5 cf       	rjmp	.-22     	; 0x49a2 <free+0x44>
    49b8:	d3 83       	std	Z+3, r29	; 0x03
    49ba:	c2 83       	std	Z+2, r28	; 0x02
    49bc:	40 81       	ld	r20, Z
    49be:	51 81       	ldd	r21, Z+1	; 0x01
    49c0:	84 0f       	add	r24, r20
    49c2:	95 1f       	adc	r25, r21
    49c4:	c8 17       	cp	r28, r24
    49c6:	d9 07       	cpc	r29, r25
    49c8:	59 f4       	brne	.+22     	; 0x49e0 <free+0x82>
    49ca:	88 81       	ld	r24, Y
    49cc:	99 81       	ldd	r25, Y+1	; 0x01
    49ce:	84 0f       	add	r24, r20
    49d0:	95 1f       	adc	r25, r21
    49d2:	02 96       	adiw	r24, 0x02	; 2
    49d4:	91 83       	std	Z+1, r25	; 0x01
    49d6:	80 83       	st	Z, r24
    49d8:	8a 81       	ldd	r24, Y+2	; 0x02
    49da:	9b 81       	ldd	r25, Y+3	; 0x03
    49dc:	93 83       	std	Z+3, r25	; 0x03
    49de:	82 83       	std	Z+2, r24	; 0x02
    49e0:	21 15       	cp	r18, r1
    49e2:	31 05       	cpc	r19, r1
    49e4:	29 f4       	brne	.+10     	; 0x49f0 <free+0x92>
    49e6:	f0 93 f0 04 	sts	0x04F0, r31	; 0x8004f0 <__flp+0x1>
    49ea:	e0 93 ef 04 	sts	0x04EF, r30	; 0x8004ef <__flp>
    49ee:	3d c0       	rjmp	.+122    	; 0x4a6a <free+0x10c>
    49f0:	e9 01       	movw	r28, r18
    49f2:	fb 83       	std	Y+3, r31	; 0x03
    49f4:	ea 83       	std	Y+2, r30	; 0x02
    49f6:	49 91       	ld	r20, Y+
    49f8:	59 91       	ld	r21, Y+
    49fa:	c4 0f       	add	r28, r20
    49fc:	d5 1f       	adc	r29, r21
    49fe:	ec 17       	cp	r30, r28
    4a00:	fd 07       	cpc	r31, r29
    4a02:	61 f4       	brne	.+24     	; 0x4a1c <free+0xbe>
    4a04:	80 81       	ld	r24, Z
    4a06:	91 81       	ldd	r25, Z+1	; 0x01
    4a08:	84 0f       	add	r24, r20
    4a0a:	95 1f       	adc	r25, r21
    4a0c:	02 96       	adiw	r24, 0x02	; 2
    4a0e:	e9 01       	movw	r28, r18
    4a10:	99 83       	std	Y+1, r25	; 0x01
    4a12:	88 83       	st	Y, r24
    4a14:	82 81       	ldd	r24, Z+2	; 0x02
    4a16:	93 81       	ldd	r25, Z+3	; 0x03
    4a18:	9b 83       	std	Y+3, r25	; 0x03
    4a1a:	8a 83       	std	Y+2, r24	; 0x02
    4a1c:	e0 e0       	ldi	r30, 0x00	; 0
    4a1e:	f0 e0       	ldi	r31, 0x00	; 0
    4a20:	12 96       	adiw	r26, 0x02	; 2
    4a22:	8d 91       	ld	r24, X+
    4a24:	9c 91       	ld	r25, X
    4a26:	13 97       	sbiw	r26, 0x03	; 3
    4a28:	00 97       	sbiw	r24, 0x00	; 0
    4a2a:	19 f0       	breq	.+6      	; 0x4a32 <free+0xd4>
    4a2c:	fd 01       	movw	r30, r26
    4a2e:	dc 01       	movw	r26, r24
    4a30:	f7 cf       	rjmp	.-18     	; 0x4a20 <free+0xc2>
    4a32:	8d 91       	ld	r24, X+
    4a34:	9c 91       	ld	r25, X
    4a36:	11 97       	sbiw	r26, 0x01	; 1
    4a38:	9d 01       	movw	r18, r26
    4a3a:	2e 5f       	subi	r18, 0xFE	; 254
    4a3c:	3f 4f       	sbci	r19, 0xFF	; 255
    4a3e:	82 0f       	add	r24, r18
    4a40:	93 1f       	adc	r25, r19
    4a42:	20 91 ed 04 	lds	r18, 0x04ED	; 0x8004ed <__brkval>
    4a46:	30 91 ee 04 	lds	r19, 0x04EE	; 0x8004ee <__brkval+0x1>
    4a4a:	28 17       	cp	r18, r24
    4a4c:	39 07       	cpc	r19, r25
    4a4e:	69 f4       	brne	.+26     	; 0x4a6a <free+0x10c>
    4a50:	30 97       	sbiw	r30, 0x00	; 0
    4a52:	29 f4       	brne	.+10     	; 0x4a5e <free+0x100>
    4a54:	10 92 f0 04 	sts	0x04F0, r1	; 0x8004f0 <__flp+0x1>
    4a58:	10 92 ef 04 	sts	0x04EF, r1	; 0x8004ef <__flp>
    4a5c:	02 c0       	rjmp	.+4      	; 0x4a62 <free+0x104>
    4a5e:	13 82       	std	Z+3, r1	; 0x03
    4a60:	12 82       	std	Z+2, r1	; 0x02
    4a62:	b0 93 ee 04 	sts	0x04EE, r27	; 0x8004ee <__brkval+0x1>
    4a66:	a0 93 ed 04 	sts	0x04ED, r26	; 0x8004ed <__brkval>
    4a6a:	df 91       	pop	r29
    4a6c:	cf 91       	pop	r28
    4a6e:	08 95       	ret

00004a70 <memcpy>:
    4a70:	fb 01       	movw	r30, r22
    4a72:	dc 01       	movw	r26, r24
    4a74:	02 c0       	rjmp	.+4      	; 0x4a7a <memcpy+0xa>
    4a76:	01 90       	ld	r0, Z+
    4a78:	0d 92       	st	X+, r0
    4a7a:	41 50       	subi	r20, 0x01	; 1
    4a7c:	50 40       	sbci	r21, 0x00	; 0
    4a7e:	d8 f7       	brcc	.-10     	; 0x4a76 <memcpy+0x6>
    4a80:	08 95       	ret

00004a82 <memset>:
    4a82:	dc 01       	movw	r26, r24
    4a84:	01 c0       	rjmp	.+2      	; 0x4a88 <memset+0x6>
    4a86:	6d 93       	st	X+, r22
    4a88:	41 50       	subi	r20, 0x01	; 1
    4a8a:	50 40       	sbci	r21, 0x00	; 0
    4a8c:	e0 f7       	brcc	.-8      	; 0x4a86 <memset+0x4>
    4a8e:	08 95       	ret

00004a90 <__do_global_dtors>:
    4a90:	10 e0       	ldi	r17, 0x00	; 0
    4a92:	c8 e8       	ldi	r28, 0x88	; 136
    4a94:	d0 e0       	ldi	r29, 0x00	; 0
    4a96:	04 c0       	rjmp	.+8      	; 0x4aa0 <__do_global_dtors+0x10>
    4a98:	fe 01       	movw	r30, r28
    4a9a:	0e 94 e3 23 	call	0x47c6	; 0x47c6 <__tablejump2__>
    4a9e:	21 96       	adiw	r28, 0x01	; 1
    4aa0:	c9 38       	cpi	r28, 0x89	; 137
    4aa2:	d1 07       	cpc	r29, r17
    4aa4:	c9 f7       	brne	.-14     	; 0x4a98 <__do_global_dtors+0x8>
    4aa6:	f8 94       	cli

00004aa8 <__stop_program>:
    4aa8:	ff cf       	rjmp	.-2      	; 0x4aa8 <__stop_program>
